<html>
<head>
<title>Build a Todo App Using a Microservices Architecture and Use Auth Service to Protect Its Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用微服务架构构建Todo应用程序，并使用授权服务来保护其路线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-todo-app-using-a-microservices-architecture-and-use-auth-service-to-protect-its-routes-f8f0d2ad6669?source=collection_archive---------6-----------------------#2022-06-16">https://betterprogramming.pub/build-a-todo-app-using-a-microservices-architecture-and-use-auth-service-to-protect-its-routes-f8f0d2ad6669?source=collection_archive---------6-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1be9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用身份验证服务来验证JWT令牌并保护您的其他微服务(实验01 —第2部分)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbdd296c925c9c4c315809576b98272b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UPpUI6gvPb0hRETQGNzUA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@kingschurchinternational?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">国王教会国际</a>在<a class="ae kv" href="https://unsplash.com/s/photos/security-guard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="6f39" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我们离开的地方</h1><p id="1c6e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在第一部分中，我展示了如何使用Django构建一个auth微服务，用一个装饰器来保护他的路由，以验证用户是否被授权与他的视图进行交互。如果你错过了，看看这里的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-protect-your-microservices-8d74045061c1"><em class="mk"/></a>。</p><p id="6eac" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在终于到了继续实施我们的待办应用程序开发的时候了。</p><p id="0728" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">正如第一部分所预期的，在这里我将展示我如何开发<em class="mk"> todo微服务</em>以及我如何使用auth服务来保护它的路由。</p><p id="23c1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">最后，我将展示如何使用docker-compose连接所有微服务。</p><p id="5d43" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这里  <em class="mk">可以找到<em class="mk"> Github项目</em> <a class="ae kv" href="https://github.com/anotherbuginthecode/microservices-labs" rel="noopener ugc nofollow" target="_blank"> <em class="mk">。</em></a></em></p><p id="5710" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">文章组织如下:</p><p id="ee87" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">第一部</strong>:</p><ul class=""><li id="519f" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj mv mw mx my bi translated">整体情况</li><li id="ac86" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">授权服务</li></ul><p id="23a3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第二部分:</p><ul class=""><li id="21f9" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj mv mw mx my bi translated">待办服务</li><li id="b18b" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">用docker-compose运行所有服务</li></ul><p id="1cfa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">跟我来，让我们开始这最后一部分吧！</p><h1 id="8bd5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">待办服务</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/344efae101faa934747133bbe766b12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7WVp-0CGsqqOYjS8afmQQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用<a class="ae kv" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank"> Excalidraw </a>制作的草图</p></figure><p id="3736" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">正如上面的草图所解释的，我们想要使用auth服务来告诉我们当前用户是否被授权(200)使用待办服务(401)。</p><p id="2d18" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">要做到这一点，我们希望每个请求在发送时在头中带有<code class="fe nf ng nh ni b">Authorization</code>字段，并带有由auth service生成的承载令牌。否则，该请求将被拒绝，并显示一个<code class="fe nf ng nh ni b">401</code>状态代码。</p><p id="e1a4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">该服务是用Flask实现的，Flask是一个用Python编写的web框架，可以让您轻松开发web应用程序。</p><p id="5387" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们看一下项目结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/30e239ba9390141df01bd8de45d0780a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*gQ7i_eIiLRYBeXZ9ZmMkqg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">待办服务项目结构</p></figure><p id="26c8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">与授权服务一样，我创建了bash脚本和Makefile来自动化繁琐的过程。<br/>你也可以用它们来加快整个进程，做好玩的准备。</p><p id="a96a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">.<strong class="lq ir">flaskenv</strong></code> <strong class="lq ir"> </strong>让您定义一系列参数，这些参数将在您运行应用程序时对您有所帮助。</p><p id="87de" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">此外，它允许您在<em class="mk">开发、测试、</em>和<em class="mk">生产</em>之间对环境类型进行分类。每种类型都会基于<code class="fe nf ng nh ni b">src/config.py</code>文件触发不同的应用程序设置，我将进一步向您展示。</p><p id="b796" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在我的例子中，我在<em class="mk">开发环境</em>中使用SQLite DB，在<em class="mk">生产模式</em>中使用docker时切换到PostgreSQL DB。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">烧瓶环境变量</p></figure><p id="9612" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当您使用命令<code class="fe nf ng nh ni b">flask run</code>(它将根据FLASK_APP参数检查哪个文件执行)或<code class="fe nf ng nh ni b">python runner.py</code>启动应用程序时，python文件<strong class="lq ir"> runner.py </strong>将被启动。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0d2e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，让我们看看src文件夹的内部，解释一下最有趣的文件。</p><h1 id="b713" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Src文件夹</h1><p id="5e22" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们看看<em class="mk"> src </em>文件夹里面有什么。这里，有描述我们的待办服务的核心逻辑和交互。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c7636d3b1c25ed48413f3cbec071ac06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*3cT-XDwOPwg7YCmps_IsoQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">src文件夹中的文件和文件夹</p></figure><p id="e2fd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">app.py </code> —它包含所有配置、所有扩展和在应用程序中注册的所有路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="70db" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">尽管你可以找到app.py的所有其他示例，但我认为这种结构更加灵活和有组织。无论是延伸还是新路线，每样东西都有它的位置。</p><p id="9baa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">正如您将看到的，相同的方法是将核心操作(服务)与路由定义(蓝图)分开。这让我保持所有的路线小，干净和可维护的。</p><p id="91c9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果你感兴趣，我会向你详细展示我通常如何构建我的flask项目，请在评论部分告诉我。</p><p id="017e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">extensions.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="eb35" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这个文件中，我保存了我的flask应用程序中需要的所有必要的扩展。这样，我就可以轻松地在我的蓝图或服务文件中导入DB，例如，不使用app.py。我相信它更容易，更清晰。</p><p id="3336" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">config.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1634" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这里，我们可以找到我之前讨论过的配置。它们是根据环境动态调用的。</p><p id="2c7c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们可以看到，当我们在开发环境下运行app时，会生成一个本地<code class="fe nf ng nh ni b">todo.db</code>。测试也一样。当应用程序在生产环境下运行时(在本例中是我们的docker容器),会发生不同的情况，在生产环境中将建立与PostgreSQL数据库的连接。</p><p id="f03f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">decorators.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bb9f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">decorators.py</code>文件是奇迹发生的地方！</p><p id="655b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">至于auth服务，将使用装饰器<code class="fe nf ng nh ni b">@is_authorized</code>保护每个请求，该装饰器将在当前请求之前执行。它将检查<code class="fe nf ng nh ni b">Authorization</code>字段是否在报头请求中。</p><p id="07d8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果是这样，与auth服务通信的一个<code class="fe nf ng nh ni b">Auth</code>类将根据传递的承载令牌验证用户是否被授权。否则，将返回一个<code class="fe nf ng nh ni b">401</code>状态代码，并且不执行任何操作。</p><p id="b540" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果我们试图调用一个API而不传递承载令牌或无效令牌，auth服务将拒绝该请求，因为它是未授权的。</p><pre class="kg kh ki kj gt nn ni no np aw nq bi"><span id="85f9" class="nr kx iq ni b gy ns nt l nu nv">curl --location --request GET '<a class="ae kv" href="http://localhost:5000/api/v1/todo/?completed=false'" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/api/v1/todo/?completed=false'</a></span><span id="7ae8" class="nr kx iq ni b gy nw nt l nu nv"># curl GET 'http://localhost:5000/api/v1/todo/?completed=false' \                     <br/>--header 'Authorization: Bearer mynotvalidtoken'</span><span id="5d9a" class="nr kx iq ni b gy nw nt l nu nv">&lt;!doctype html&gt;<br/>&lt;html lang=en&gt;<br/>&lt;title&gt;401 Unauthorized&lt;/title&gt;<br/>&lt;h1&gt;Unauthorized&lt;/h1&gt;<br/>&lt;p&gt;The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn&amp;#x27;t understand how to supply the credentials required.&lt;/p&gt;</span></pre><p id="d9c5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">那么让我们看看<code class="fe nf ng nh ni b">Auth</code>级里面的<code class="fe nf ng nh ni b">service/auth_service.py</code>是什么样子的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="57c0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">Auth</code>类包装了auth服务提供的必要API，以验证传递的令牌，并返回发送请求的用户的user_id。</p><p id="2de2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">__init__.py</code>映射auth服务的主机名和端口，以允许todo服务在docker容器中运行时相互进行内部通信。</p><pre class="kg kh ki kj gt nn ni no np aw nq bi"><span id="64af" class="nr kx iq ni b gy ns nt l nu nv">def __init__(self):                                         self.AUTH_SERVICE_NAME = os.getenv('AUTH_SERVICE_NAME', 'localhost')                                     self.AUTH_SERVICE_PORT = os.getenv('AUTH_SERVICE_PORT', '8000')</span></pre><p id="d39a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">方法<code class="fe nf ng nh ni b"><strong class="lq ir">get_user()</strong></code> <strong class="lq ir"> </strong>允许我们根据请求中的承载令牌检索<code class="fe nf ng nh ni b">user_id</code>。在我们的模型中,<code class="fe nf ng nh ni b">user_id</code>将被用作映射用户及其待办事项的字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c7d3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">blueprints/todo.py</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="eb76" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这里，我们可以找到我们可以与待办事项服务进行的所有可能的交互:</p><ul class=""><li id="fd00" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj mv mw mx my bi translated">获取所有用户的待办事项，最终按完成状态过滤</li><li id="8dcf" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">创建新任务</li><li id="1ea6" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">将任务设置为已完成</li><li id="42da" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">更新新的任务文本</li><li id="56b3" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">删除任务</li></ul><p id="8138" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所有的路由都受到<code class="fe nf ng nh ni b"><strong class="lq ir">@is_authorized</strong></code> decorator的保护，对于每个请求，在执行任何动作之前都要检索当前用户。</p><h1 id="fc50" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> Dockerfile </strong></h1><blockquote class="nx ny nz"><p id="98ef" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated"><a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Docker </a>可以通过读取来自<code class="fe nf ng nh ni b"><em class="iq">Dockerfile</em></code>的指令自动构建图像。<code class="fe nf ng nh ni b"><em class="iq">Dockerfile</em></code>是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。使用<code class="fe nf ng nh ni b"><em class="iq">docker build</em></code>用户可以创建一个连续执行几个命令行指令的自动化构建。</p></blockquote><p id="76ce" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我就是这样定义Dockerfile的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="75d1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">与<em class="mk">第1部分</em>中的授权服务相同，基础映像将首先执行的脚本<code class="fe nf ng nh ni b"><em class="mk">entrypoint.sh</em></code> <em class="mk"> </em>作为入口点。</p><p id="e3bc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当您启动docker容器时，它将检查与PostgreSQL DB的连接是否已建立，然后继续执行其他指令。</p><p id="f6f8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然后，基础映像将用于生成开发映像。当容器运行时，命令<code class="fe nf ng nh ni b">python runner.py</code>将被执行，flask app将在<code class="fe nf ng nh ni b">0.0.0.0:5000</code>下运行。</p><h1 id="ac51" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">启动服务</strong></h1><p id="11a9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在是时候推出服务了！我准备了一个<code class="fe nf ng nh ni b"><em class="mk">Makefile</em></code>来自动化这些无聊的东西。如果你已经下载了代码，你只需输入命令<code class="fe nf ng nh ni b"><em class="mk">make &lt;target&gt;</em></code> <em class="mk"> </em>就可以享受了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="12f9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">docker-build</code>:它将创建一个名为msalab01/todo:v1的docker图像。</p><p id="8e4a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">docker-run</code>:启动名为lab01_todo的docker容器。如果你需要使用不同的端口，你必须在make命令中指定带变量的端口，否则，将使用5000。</p><p id="81e7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">local-build</code>:它将启动<code class="fe nf ng nh ni b"><em class="mk">bootstrap.sh</em></code>，自动完成所有初始设置，比如创建虚拟环境和安装依赖项。</p><p id="6aa7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nf ng nh ni b">local-run</code>:它将启动<code class="fe nf ng nh ni b"><em class="mk">start_local_server.sh</em></code> <em class="mk">，</em>一个bash脚本，执行所有基本指令以在本地运行服务器。</p><p id="b625" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意:如果您决定使用docker容器独立运行服务，您将无法在服务之间建立通信，除非您将它们放在同一个网络下。如果您想在进入docker-compose之前测试它们，我的建议是在本地运行它们。</p><h1 id="2f1a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用docker-compose运行所有服务</h1><p id="f2c6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最后，是时候把所有东西放在一起了！</p><p id="198d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了一起运行所有服务并让它们相互通信，我们需要写下一个docker-compose文件。</p><blockquote class="nx ny nz"><p id="3186" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">Docker Compose是一个开发用来帮助定义和共享多容器应用程序的工具。使用Compose，我们可以创建一个YAML文件来定义服务，并且只需一个命令，就可以将所有东西旋转起来或全部拆除。</p></blockquote><p id="aa32" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们看看我们的文件是什么样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="291a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">数据库:</strong>每个数据库都有自己的<strong class="lq ir">卷</strong>和<strong class="lq ir">网络</strong>来保持隔离，只有共享同一网络的服务才能与之通信。</p><p id="aec7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir"> auth service </strong>:获取之前构建的镜像mslab01/auth:v1。此外，由于我们使用PostgreSQL数据库，我们设置了<code class="fe nf ng nh ni b">POSTGRES_ENABLED=1</code>，数据库之间的连接将通过传递用于创建<code class="fe nf ng nh ni b"><strong class="lq ir">auth_db</strong></code>的相同属性来建立。这是可能的，因为auth和auth_db共享同一个网络<em class="mk"> backend_auth_db </em>。此外，为了允许与前端服务通信，我们还需要将服务放在<em class="mk">前端</em>网络下。</p><p id="0642" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir"> todo服务</strong>:获取之前建立的图像<code class="fe nf ng nh ni b">mslab01/todo:v1</code>。同样的故事也适用于这个服务及其数据库(todo_db)。此外，我们通过auth服务的<code class="fe nf ng nh ni b">AUTH_SERVICE_NAME</code>和<code class="fe nf ng nh ni b">AUTH_SERVICE_PORT</code>来允许容器之间通过容器端口进行内部通信。在这种情况下，auth和todo服务共享相同的<em class="mk">前端网络</em>。</p><p id="0fde" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir"> webapp </strong>:取Vue3内置的webapp。我不会展示它是如何创建的，因为这超出了范围，如果你感兴趣，你可以在<a class="ae kv" href="https://github.com/anotherbuginthecode/microservices-labs/tree/main/lab01/frontend" rel="noopener ugc nofollow" target="_blank"> Github </a>上看到代码。您可以选择自己喜欢的框架，并使用Axios、Fetch或Ajax调用API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/12c648979deb5f733f20e69eb160fe54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5PXwgDg0fT9bgY_CXc0Jw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这是docker-compose.yml中的网络共享方式——我用<a class="ae kv" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank"> Excalidraw </a>画的草图</p></figure><h2 id="2598" class="nr kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">准备…开始！</h2><p id="b913" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们期待已久的时刻终于到来了。</p><p id="32a0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">要启动服务，在您的终端根项目下(或者您创建最终<code class="fe nf ng nh ni b">docker-compose.yml</code>的地方)键入命令:</p><pre class="kg kh ki kj gt nn ni no np aw nq bi"><span id="e6a9" class="nr kx iq ni b gy ns nt l nu nv">docker-compose up -d</span></pre><p id="f751" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">去<strong class="lq ir"> localhost </strong>或<strong class="lq ir"> localhost:80 </strong>，如果你还没有创建一个新账户，享受你的成功吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/12051ecbb6ed3d58f8c5a5b28d88dec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zo5tVf-n4hSHhvkc6j-4nw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">登录后的待办事项应用主页</p></figure><h1 id="d1cc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="74ce" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">恭喜你。现在你知道了如何使用微服务架构策略构建待办应用。我们还看到了如何通过授权服务来保护不同的服务，以确保只有授权用户才能与待办事项创建服务进行交互。</p><p id="f63d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我很高兴与你分享了这个实验，我希望你发现它对你的下一个项目有用！</p><p id="d38f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">希望下次研讨会能见到你！跟着我，确保你不会错过任何东西。</p><p id="8b28" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">再见！</p><h1 id="b395" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">有用的链接</h1><div class="oq or gp gr os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-protect-your-microservices-8d74045061c1"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">如何保护您的微服务(1/2)</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">使用身份验证服务来验证JWT令牌并保护您的其他微服务(实验01 —第1部分)</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">better编程. pub</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://github.com/anotherbuginthecode/microservices-labs" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">GitHub -另一个bug in代码/微服务-实验室:一系列实验来了解…</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在我学习微服务架构的过程中，进行了一系列的实验。有时候我会看到一些文章或者…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph kp ot"/></div></div></a></div></div></div>    
</body>
</html>