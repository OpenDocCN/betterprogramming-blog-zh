<html>
<head>
<title>OkHttp Source Code Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OkHttp源代码分析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/okhttp-source-code-analysis-b9fe7d5b7b8a?source=collection_archive---------6-----------------------#2022-02-15">https://betterprogramming.pub/okhttp-source-code-analysis-b9fe7d5b7b8a?source=collection_archive---------6-----------------------#2022-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="62f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于OkHttp框架的原理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8639f2c0399a67dcaef191d45119256c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pVIhXVuCRU8SscN3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@goran_ivos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Goran Ivos </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="59e1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">过程分析</h1><p id="830b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们从一个简单的HTTP请求开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="06a9" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上面的代码将启动两个简单的HTTP请求。下图显示了请求流。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/32e778f3d6331c5637366aa03ee7827c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCGeNvHSLzE6Pcftli4l8Q.png"/></div></div></figure><p id="f2a2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上述流程图仅描述了责任链。在前面的介绍之后，将分别介绍责任链和每个拦截器的原理。</p><h2 id="516a" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">OkHttpClient</h2><p id="6a40" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们使用new <code class="fe ne nf ng nh b">OkHttpClient()</code>来创建一个默认的<code class="fe ne nf ng nh b">OkHttpClient</code>，我们也可以使用<code class="fe ne nf ng nh b">OkHttpClient.Builder</code>来构建一个带有自定义参数的客户端。</p><p id="5543" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">稍后，当我们使用网络请求时，我们将使用这个客户端。可以理解为整个OkHttp的核心类。它封装了整体OkHttp，并提供外部请求发起和一些参数配置接口。我们可以用<code class="fe ne nf ng nh b">OkHttpClient</code>。构建器来设置，负责在内部协调各个类的操作，它实际上并不包含太多的代码。</p><h2 id="271e" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">请求</h2><p id="e57c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">Request</code>很好理解并负责组装请求。</p><h2 id="2263" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">呼叫(真实呼叫)</h2><p id="079b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">然后调用<code class="fe ne nf ng nh b">client.newCall(request)</code>方法，意思是创建一个新的要执行的请求，通过<code class="fe ne nf ng nh b">newCall</code>方法获得一个调用对象(实现为<code class="fe ne nf ng nh b">RealCall</code>)。此时，我们使用Call的execute/enqueue来发起同步/异步请求。</p><p id="a3bc" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">所以每个<code class="fe ne nf ng nh b">Request</code>最终都会封装成一个<code class="fe ne nf ng nh b">RealCall</code>对象。<code class="fe ne nf ng nh b">RealCall</code>和<code class="fe ne nf ng nh b">Request</code>一一对应。Call用于描述可以执行和中断的请求。每次发起请求时，我们都会创建一个<code class="fe ne nf ng nh b">RealCall</code>对象。</p><p id="e261" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">最后调用<code class="fe ne nf ng nh b">RealCall#getResponseWithInterceptorChain()</code>发起请求，这个方法会返回一个响应结果response。</p><h2 id="5c08" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">分配器</h2><p id="712e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">Dispatcher</code>用于管理其对应的<code class="fe ne nf ng nh b">OkHttpClient</code>的所有请求。从上面的流程图可以看出，当使用异步请求时，请求会委托给<code class="fe ne nf ng nh b">Dispatcher</code>对象进行处理，<code class="fe ne nf ng nh b">Dispatcher</code>对象是随着<code class="fe ne nf ng nh b">OkHttpClient</code>的创建而创建的。</p><p id="c517" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">实际上，<code class="fe ne nf ng nh b">Dispatcher</code>不仅用于管理异步请求，还负责管理同步请求。</p><p id="c647" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">当我们发起请求时，无论是异步还是同步，都会被<code class="fe ne nf ng nh b">Dispatcher</code>记录下来。</p><p id="7bb5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们可以通过<code class="fe ne nf ng nh b">OkHtpClient#dispatcher()</code>获取Dispatcher对象，对请求进行统一控制，比如结束所有请求，获取线程池等等。<br/><code class="fe ne nf ng nh b">Dispatcher</code>包含三个队列:</p><ul class=""><li id="012d" class="ni nj iq lq b lr mm lu mn lx nk mb nl mf nm mj nn no np nq bi translated">新的异步请求将首先被添加到队列中</li><li id="0c09" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><code class="fe ne nf ng nh b">runningAsyncCalls</code>:当前运行的异步请求</li><li id="7178" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><code class="fe ne nf ng nh b">runningSyncCalls</code>:当前正在运行同步请求</li></ul><p id="6dcf" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">Dispatcher包含一个用于执行所有异步请求的默认线程池。还可以通过构造函数指定一个线程池，所有异步请求都将通过这个线程池执行。</p><p id="7f22" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">和同步请求一样，异步请求最终也会调用<code class="fe ne nf ng nh b">RealCall#getResponseWithInterceptorChain()</code>发起请求，但是一个是直接调用，一个是在线程池中调用。</p><p id="26ba" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">通过上面的介绍，已经发现重点是名字比较长的方法，只要被调用就能返回响应，这个方法开始涉及到大家熟知的OkHttp责任链模型。</p><h1 id="c180" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">OkHttp责任链</h1><p id="cd6b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这一切都是从一个名字很长的方法开始的。我们知道，在任何情况下，都会调用<code class="fe ne nf ng nh b">RealCall#getResponseWithInterceptorChain()</code>来发起请求并得到最终的响应。</p><p id="2169" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这个方法会根据用户设置的拦截器和几个默认的拦截器来组装拦截器列表，然后创建一个责任链。</p><p id="efa0" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">责任链创建后，会调用其流程方法得到响应并返回，这涉及到两个概念:<code class="fe ne nf ng nh b"><strong class="lq ir">Interceptor</strong></code>和<code class="fe ne nf ng nh b"><strong class="lq ir">Chain</strong></code>。</p><h2 id="88f4" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">拦截机</h2><p id="6102" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">作为拦截器的抽象概念，拦截器接口被设计为观察、拦截和处理请求(如添加头、重定向、数据处理等)的责任链上的一个单元节点。</p><p id="1e14" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">拦截器相互独立，每个拦截器只负责自己关注的任务，不联系其他拦截器。</p><p id="6b48" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">拦截器接口只包含一个方法(OkHttp现在用Kotlin重写):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="124e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">intercept方法接收一个<code class="fe ne nf ng nh b">Chain</code>作为参数并返回一个响应。</p><p id="76fb" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在<code class="fe ne nf ng nh b">RealCall</code>中，为了完成基本功能，下面的默认<code class="fe ne nf ng nh b">Interceptors</code>将被添加到职责的<code class="fe ne nf ng nh b">Chain</code>中:</p><ul class=""><li id="1440" class="ni nj iq lq b lr mm lu mn lx nk mb nl mf nm mj nn no np nq bi translated">用户设置拦截器<br/> <code class="fe ne nf ng nh b">RetryAndFollowUpInterceptor</code>:重试失败重定向</li><li id="8bfd" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><code class="fe ne nf ng nh b">BridgeInterceptor</code>:处理网络头、cookies、gzip等。</li><li id="a4b7" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><code class="fe ne nf ng nh b">CacheInterceptor</code>:管理缓存</li><li id="809d" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><code class="fe ne nf ng nh b">ConnectInterceptor</code>:连接服务器</li><li id="6fa2" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">如果是WebSocket请求，添加相应的拦截器</li><li id="46a5" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated"><code class="fe ne nf ng nh b">CallServerInterceptor</code>:数据发送/接收</li></ul><p id="9ee3" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这些拦截器的具体含义和原理将在后面详细介绍。</p><p id="6792" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">责任链将按照它们被添加的顺序执行这些拦截器，因此顺序非常重要。</p><p id="9c36" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">通过这些拦截器的处理，最终会将一个完美的<code class="fe ne nf ng nh b">Response</code>返回给<code class="fe ne nf ng nh b">RealCall</code>中名字比较长的方法，然后返回给下游用户。至此，一个完整的请求告一段落。</p><h2 id="51e2" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">链子</h2><p id="5ebe" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Chain用来描述责任链，流程方法通过它开始依次执行链上的各个节点，并返回处理后的响应。<br/>Chain的唯一实现是RealInterceptorChain(以下简称RIC)，RIC可以称为拦截器责任链，其中的节点由RealCall中添加的拦截器组成。由于拦截器的独立性，RIC还包含一些公共参数和共享对象。</p><p id="55a0" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe ne nf ng nh b">Interceptor</code>和<code class="fe ne nf ng nh b">Chain</code>相互依赖，相互调用，共同发展，形成了一个完善的调用链。我们来看看他们的通话关系图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0991da43b571092591a259ffbcd7db07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6LEERuz4VGker57mi38kQ.png"/></div></figure><p id="2a26" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">从上图中可以清楚的看到，当我们在一个<code class="fe ne nf ng nh b">Interceptor</code>中调用<code class="fe ne nf ng nh b">Chain#process</code>方法来获取<code class="fe ne nf ng nh b">Response</code>时，在调用当前位置后，请求将按照<code class="fe ne nf ng nh b">Interceptor</code>进行处理。</p><p id="23ef" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">处理完成后，<code class="fe ne nf ng nh b">Response</code>会返回到当前的拦截器，然后处理完成后返回到上一级，直到遍历结束。</p><h1 id="40d0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">网络连接和数据发送与接收</h1><p id="0139" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">上面已经介绍了OkHttp的基本概念、基本配置、线程控制、责任链。先说一个网络框架的灵魂:网络请求的建立和数据的发送接收。</p><p id="e644" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe ne nf ng nh b">RealCall</code>中增加的几个不同的拦截器相互配合完成这些功能。只要你理解了这些基本的拦截器，你就理解了OkHttp的灵魂。</p><p id="d71b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">其实我不建议在看源代码的时候过多关注实现细节。只要了解设计思路，一般实现都差不多，否则很容易被负责任的细节所迷惑。</p><p id="5bcb" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">所以在介绍这些拦截器之前，我们先介绍一下OkHttp中的一些基本概念。</p><h2 id="af46" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">如何建立连接</h2><p id="fa20" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们之前看到的很多网络请求框架，比如凌空等。，都是通过底层的<code class="fe ne nf ng nh b">HTTPURLConnection</code>连接到服务器，OkHttp更好。因为Http协议是基于TCP/IP协议的，底层还在使用Socket，OkHttp直接使用Socket来完成HTTP请求。</p><h2 id="b895" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">途径</h2><p id="cc70" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">route</code>是用来连接服务器的具体路由。它包含IP地址、端口、代理等参数。<br/>由于代理或DNS可能返回多个IP地址，同一接口地址可能对应多个路由。</p><p id="fde5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">创建连接时，将直接使用路由而不是IP地址。</p><h2 id="5777" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">路由选择器</h2><p id="35e0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">路由选择器，存储所有可用的路由，并在准备连接时通过<code class="fe ne nf ng nh b">RouteSelector#next</code>方法获取下一条路由。</p><p id="9d7c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">值得注意的是，<code class="fe ne nf ng nh b">RouteSelector</code>包含了一个<code class="fe ne nf ng nh b">routeDatabase</code>对象，存储连接失败的路由，<code class="fe ne nf ng nh b">RouteSelector</code>会在最后存储最后一条连接失败的路由，以提高连接速度。</p><h2 id="948f" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">真实连接</h2><p id="f86b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">RealConnection</code>实现了<code class="fe ne nf ng nh b">Connection</code>接口，该接口使用Socket建立HTTP/HTTPS连接并获取I/O流。<strong class="lq ir">同一个</strong>连接可以承载多个HTTP请求和响应。</p><p id="1f68" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">其实大致可以理解为Socket，I/O流，以及一些协议的封装。这涉及到很多计算机网络相关的知识，比如TLS握手、HTTPS验证等等。</p><h2 id="9b89" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">RealConnectionPool</h2><p id="d119" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是用于存储<code class="fe ne nf ng nh b">RealConnection</code>的池，在内部，双端队列用于存储。</p><p id="a606" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在OkHttp中，一个连接(<code class="fe ne nf ng nh b">RealConnection</code>)在用完之后不会立即被关闭和释放，而是存储在连接池(<code class="fe ne nf ng nh b">RealConnectionPool</code>)中。</p><p id="180c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">除了缓存连接，缓存池还负责定期清理过期的连接。在<code class="fe ne nf ng nh b">RealConnection</code>中维护一个字段来描述连接的空闲时间。</p><p id="8f1f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">每当一个新的连接被添加到连接池中时，就执行检测，遍历所有的<code class="fe ne nf ng nh b">Connect</code>来找到当前未使用的并且具有最长空闲时间的连接。</p><p id="f286" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果连接空闲时间超过阈值，或者连接池已满，连接将被关闭。</p><p id="7f2b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">另外，<code class="fe ne nf ng nh b">RealConnection</code>还维护了一个<code class="fe ne nf ng nh b">Transmitter</code>的弱引用列表来存储当前使用连接的<code class="fe ne nf ng nh b">Transmitter</code>。当列表为空时，意味着该连接没有被使用。</p><h2 id="3659" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">ExchangeCodec</h2><p id="68d0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">ExchangeCodec</code>负责对<code class="fe ne nf ng nh b">Response</code>进行编码和解码，即写请求和读响应。我们的请求和响应数据通过它被读取和写入。</p><p id="fcf1" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">所以<code class="fe ne nf ng nh b">Connection</code>负责建立连接，<code class="fe ne nf ng nh b">ExchangeCodec</code>负责发送和接收数据。</p><p id="ca34" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe ne nf ng nh b">ExchangeCodec</code>接口有两个实现类:<code class="fe ne nf ng nh b">Http1ExchangeCodec</code>和<code class="fe ne nf ng nh b">Http2ExchangeCodec</code>，分别对应两个协议版本。</p><h2 id="eaee" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">交换</h2><p id="609b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">Exchange</code>功能与<code class="fe ne nf ng nh b">ExchangeCodec</code>类似，但对应的是单个请求，在<code class="fe ne nf ng nh b">ExchangeCodec</code>的基础上负责一些连接管理和事件分发功能。</p><p id="95e0" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">具体来说，<code class="fe ne nf ng nh b">Exchange</code>一一对应请求。当一个新的请求被创建时，一个<code class="fe ne nf ng nh b">Exchange</code>被创建。<code class="fe ne nf ng nh b">Exchange</code>负责发送请求和读取响应数据，<code class="fe ne nf ng nh b">ExchangeCodec</code>用于发送和接收数据。</p><h2 id="8bfb" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">发射机</h2><p id="c51c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">Transmitter</code>是OkHttp网络层的桥梁。我们上面提到的概念，最终都是通过变送器集成，提供外部功能。</p><p id="cd14" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">好了，现在介绍了基本概念，让我们开始看看拦截器。</p><h2 id="f208" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">RetryAndFollowUpInterceptor</h2><p id="3769" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">顾名思义，这个拦截器负责失败的重试和重定向。<br/>可能触发重试或重定向的条件如下:</p><ul class=""><li id="3cd6" class="ni nj iq lq b lr mm lu mn lx nk mb nl mf nm mj nn no np nq bi translated">401:未经授权</li><li id="0585" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">407:代理未授权</li><li id="d080" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">503:服务未经授权</li><li id="a503" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">3xx:请求重定向</li><li id="cca6" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">408:请求超时</li><li id="d27a" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">以及一些I/O异常和其他连接故障</li></ul><p id="aa0a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">正如我们上面提到的，由于代理和DNS的原因，同一个URL可能有多个IP地址。连接时通过<code class="fe ne nf ng nh b">RouteSelector</code>选择合适的路由进行连接，所以这里的重试失败并不是指同一个IP地址有多个IP地址。重试是逐一尝试路由表中的地址。</p><p id="cd9c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果响应代码是401或407，则意味着请求没有通过身份验证。此时，请求被重新认证，然后认证的请求被返回。</p><p id="f3c1" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">响应代码是3xx，表示重定向。此时重定向地址在响应头的<code class="fe ne nf ng nh b">Location</code>字段，然后通过这个新地址和之前的请求构造一个新的请求并返回。</p><p id="125c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">响应代码503表示服务器错误，但这是暂时的，可能很快就会恢复，因此将直接返回之前的请求。</p><h2 id="b4b1" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">桥梁拦截器</h2><p id="f9b8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">BridgeInterceptor</code>是用户与网络之间的桥梁，负责将用户请求转化为网络请求，即形成网络头，并根据请求信息设置响应数据。</p><p id="c5ef" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">实际上，<code class="fe ne nf ng nh b">BridgeInterceptor</code>负责设置cookies和gzip。<br/>在发起网络请求之前，<code class="fe ne nf ng nh b">BridgeInterceptor</code>会先通过URL判断是否有cookie，如果有，就会把cookie带过来。</p><p id="2f7f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">请求结束后，还会判断响应头中是否包含Set-Cookie字段，保存下来下次使用。但是，存储cookies的操作将委托给<code class="fe ne nf ng nh b">CookieJar</code>。</p><p id="637d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">OkHttp默认提供一个空的<code class="fe ne nf ng nh b">CookieJar</code>对象，这意味着默认不执行任何操作，但是您可以在创建OkHttp时指定自己的<code class="fe ne nf ng nh b">CookieJar</code>来使用。</p><p id="c424" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果Accept-Encoding和Range字段不包括在请求请求报头中，则一个<code class="fe ne nf ng nh b">Accept-Encoding: gzip</code>请求报头将被添加到其中。接收到响应数据后，如果响应指示使用gzip，则响应数据会交给okio的<code class="fe ne nf ng nh b">GzipSource</code>解码。</p><h2 id="eb84" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">CacheInterceptor</h2><p id="6a2c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">CacheInterceptor</code>负责缓存响应数据。<br/>该方法首先尝试通过<code class="fe ne nf ng nh b">Cache</code>对象获取缓存数据，然后通过<code class="fe ne nf ng nh b">CacheStrategy</code>获取缓存策略。</p><p id="89cc" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">通过这个策略的计算结果，我们可以得到两个可空的对象:<code class="fe ne nf ng nh b">networkRequest</code>和<code class="fe ne nf ng nh b">cacheResponse</code>。</p><p id="a83e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">其中<code class="fe ne nf ng nh b">networkRequest</code>是原始请求，但可能为空。是否为空由<code class="fe ne nf ng nh b">CacheStrategy</code>控制。</p><p id="3917" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe ne nf ng nh b">cacheResponse</code>是通过<code class="fe ne nf ng nh b">Cache</code>得到的<code class="fe ne nf ng nh b">Response</code>，同上，也可能为空。<br/>然后你可以通过判断两个对象的为空性来处理缓存，逻辑如下:</p><ul class=""><li id="0cf7" class="ni nj iq lq b lr mm lu mn lx nk mb nl mf nm mj nn no np nq bi translated">如果两者都为空，则意味着既不允许使用网络请求，也不允许使用缓存或缓存未命中，直接返回504错误。</li><li id="cdfe" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">如果只有<code class="fe ne nf ng nh b">networkRequest</code>为空，说明网络请求被禁止，直接返回从缓存命中的响应。</li><li id="05e0" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">如果两者都不为空，则开始发出请求并获取响应数据。</li><li id="9e9d" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">如果此时<code class="fe ne nf ng nh b">cacheResponse</code>不为空，响应码为304，则直接返回<code class="fe ne nf ng nh b">cacheResponse</code>，用响应数据更新缓存。</li><li id="005e" class="ni nj iq lq b lr nr lu ns lx nt mb nu mf nv mj nn no np nq bi translated">如果<code class="fe ne nf ng nh b">cacheResponse</code>为空，响应数据将存储在<code class="fe ne nf ng nh b">Cache</code>中。<br/>返回响应数据。</li></ul><p id="b9fa" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">需要注意的是，上面提到的<code class="fe ne nf ng nh b">Cache</code>对象默认为空。如果为空，则不会执行与之相关的操作，并且<code class="fe ne nf ng nh b">cacheResponse</code>必须为空。</p><p id="4247" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们可以在<code class="fe ne nf ng nh b">OkHttpClient</code>中设置<code class="fe ne nf ng nh b">Cache</code>。</p><h2 id="f6ab" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">ConnectInterceptor</h2><p id="ae7b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">ConnectInterceptor</code>用于打开与服务器的连接。代码非常简单。它将通过<code class="fe ne nf ng nh b">Transmitter#newExchange</code>方法创建一个<code class="fe ne nf ng nh b">Exchange</code>对象，并调用<code class="fe ne nf ng nh b">Chain#process</code>方法。</p><p id="8e4d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在<code class="fe ne nf ng nh b">newExchange</code>方法中，它将首先尝试通过<code class="fe ne nf ng nh b">ExchangeFinder</code>在<code class="fe ne nf ng nh b">RealConnectionPool</code>中找到一个现有的连接。</p><p id="b1b5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果没有找到，它会重新创建一个<code class="fe ne nf ng nh b">RealConnection</code>并启动连接，然后存储在<code class="fe ne nf ng nh b">RealConnectionPool</code>中。</p><p id="5368" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这时，<code class="fe ne nf ng nh b">RealConnection</code>对象已经准备好，然后通过请求协议创建不同的<code class="fe ne nf ng nh b">ExchangeCodec</code>并返回。具体细节上面已经提到了，这里不再详细介绍。</p><p id="7e83" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">通过以上步骤创建了<code class="fe ne nf ng nh b">ExchangeCodec</code>后，基于它和其他参数创建一个交换对象并返回。</p><p id="b402" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe ne nf ng nh b">ConnectInterceptor</code>调用<code class="fe ne nf ng nh b">Chain#process</code>方法，将<code class="fe ne nf ng nh b">newExchange</code>方法返回的<code class="fe ne nf ng nh b">Exchange</code>对象作为参数。</p><h2 id="ad4f" class="ms kx iq bd ky mt mu dn lc mv mw dp lg lx mx my li mb mz na lk mf nb nc lm nd bi translated">CallServerInterceptor</h2><p id="0d10" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">CallServerInterceptor</code>负责读写数据。<br/>这是最后的拦截器。这里该准备的都准备好了。通过它，请求中的数据将被发送到服务器，获得的数据将被写入响应。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="14ce" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">所以OkHttp的源代码在这里分析的差不多了。其实还有很多事情没有提到。OkHttp是一个庞大的框架，涉及的东西太多了，包含了很多计算机网络的基础知识。谢谢！</p></div></div>    
</body>
</html>