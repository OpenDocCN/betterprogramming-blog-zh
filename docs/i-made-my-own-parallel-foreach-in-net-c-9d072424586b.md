# 我做了我自己的“平行。ForEach" in。NET C#

> 原文：<https://betterprogramming.pub/i-made-my-own-parallel-foreach-in-net-c-9d072424586b>

## 如何以最简单的方式创建自己的轻量级并行库

![](img/a3d53824c6e8d284d6d4e8e882861c51.png)

Jonathan Chng 在 [Unsplash](https://unsplash.com/s/photos/running-track?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

是的，是的，我知道。英寸网有一个[水货。对于每个从盒子里出来的东西。但是让我试着解释一下。我发现自己处于这样的情况，我需要一段更小的代码，简单地对一组输入执行一个动作(工作)。试图照顾太多，并准备处理许多随机情况，对我来说，那只是噪音。](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.foreach?view=net-6.0)

所以，我在想，如果我们写一个更小的库，简单地处理对一组并行输入的操作，让操作处理所有的事情(甚至错误处理)，并且让我的库尽可能的简单，会怎么样呢？

为什么？对我来说，这是最常见的情况。示例:“向这些用户中的每一个发送通知”或“调用此服务并将结果写入每个输入的文件中”。

基本上“为这些输入中的每一个做这个任务”，这些任务(工作)可以并行执行。

让我们以我目前的工作作为一个很适合这个图书馆的例子。我做 ETL，用几句话来概括我的工作:基于一个配置文件，我查询一个源系统并写入一些数据接收器。

例如，从配置文件中，我得到了一个很长的表列表，一个要处理的表所需的每个对象要么是通过阿迪框架创建的，要么是在需要时由某个工厂动态创建的。

考虑到这一点，我需要的是能帮我协调所有工作的东西。目前，我开发了两种算法，一种是基于信号量的主动算法，另一种是我将在这里展示的被动算法，它基于一个轻量级工具的思想，简单地执行一个接一个的任务。

# 简单 ForEach

根据我的要求，让我们为`IEnumerable<T>`创建一个扩展方法，让一个`Action<T>`在`Enumerable`的每一项上执行。

正如您在这个 for-each 中看到的，这可以简单到设置一个`Actions`的`List`，然后将每个作为`Task`启动，并利用`Task.WhenAll()`来确保它们全部运行完成。

要设置一个动作，我们必须使用传入的`Action`来配置一个`Actions`列表，每个列表对应一个输入。

一旦配置了一个`Action`，下一步就是在一个`Task`内触发它。

为了跟踪每个`Task`，我们将在`List<Task>`中保存他们的引用。这样我们就可以利用`Task.WhenAll()`，让呼叫者成为获奖者。

有效地只处理并行启动任务，而不处理其他事情。

# 线程感知 ForEach

如果我们需要限制程序可以使用的`Threads`的数量呢？可能是因为源系统不稳定，无法并行处理太多请求。在这种情况下，我们不能简单地开始所有的任务并抱最好的希望，我们必须跟踪活动任务的数量。

为此，我们可以改变已触发`Actions`的循环。再次初始化一个列表`Actions`，但是这次让我们初始化一个子集`Actions`。

我们将把这个子集命名为`workInProgress`。当有工作正在进行时，我们假设仍然有活动的`Tasks`并保持循环活动，等待`Tasks`完成，这次利用`Task.WhenAny()`。

在循环中有两件重要的事情让这个工作很好地进行，我们让程序阻塞等待`Task.WhenAny()`，一旦`WhenAny`让程序继续运行:

*   我们知道一个任务已经完成，所以，我们可以触发一个新的任务。
*   `WhenAny()`还返回一个对已完成的`Task`的引用，我们只需将`Remove`这个具体的`Task`从`workInProgress`的基础上引用即可。

一旦`workInProgress`为空，我们就知道输入列表中的每一项都已被处理。

# 最后的话

如您所见，我没有处理错误。在现实生活中，由于使用了像 IoC 和工厂这样的模式，我在多个地方负责日志记录和错误处理。

希望这些想法能对你的工作有用，让我们保持创意源源不断。