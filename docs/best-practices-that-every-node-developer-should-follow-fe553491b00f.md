# 每个节点开发人员都应该遵循的最佳实践

> 原文：<https://betterprogramming.pub/best-practices-that-every-node-developer-should-follow-fe553491b00f>

## 所有项目都应该遵循最佳实践来提高效率和质量

![](img/7c3569190e7c59d391dda489f9d79754.png)

[潘达夫坦克](https://unsplash.com/@soul_adorning_shades1?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照。

[Node.js](https://nodejs.org/en/) 作为一种用于后端开发的异步和事件驱动语言，在开发人员中很受欢迎。它的语法非常容易理解——即使对初学者来说也是如此。

无论您是使用 Node 的初学者还是经验丰富的开发人员，在开发面向生产的应用程序时，都必须遵循 Node.js 编程的最佳实践。

在本文中，我们将指出每个节点开发人员应该遵循的十个最佳实践。除了作为程序员应该遵循的一般最佳编码实践，这些将帮助您最大限度地利用 Node 的独特功能。

# 将确切的包版本保存到 package.json

在开发过程中，我们使用以下命令向应用程序添加一个新包:

```
npm install express --save
```

它将软件包及其安装版本保存到`package.json`文件，如下所示:

```
"express": "^4.17.1",
```

这里，使用脱字符号(`^`)表示应用程序接受了来自`“>=4.17.1 <5.0.0”`地区的版本包。

*注意:如果你想知道更多关于像插入符号这样的符号如何定义版本范围，请阅读* [*SemVar 文档*](https://semver.org/) *。*

当其他人使用我们创建的`package.json`文件来设置应用程序环境和安装依赖项(使用`npm install`命令)时，这就成问题了。

在这种情况下，npm 安装的不是我们用于开发的软件包版本，而是其他用户安装依赖项时可用的最新版本。如果最新版本与我们在初始实现中使用的版本不兼容，就会导致错误。特别是如果项目是开源的，我们需要注意这种可能性。

我们可以使用两种方法来防止包版本的冲突。

一种方法是每次安装并保存软件包到`package.json`文件时使用`--save-exact`:

```
npm install express --save --save-exact
```

或者，您可以使用以下命令配置 npmrc 文件一次，以便在默认情况下，安装的每个软件包的可接受版本都是其确切版本:

```
npm config set save-exact=true
```

这两种方法都保存安装到`package.json`文件中的每个新包，前面没有插入符号:

```
"express": "4.17.1",
```

现在，每当别人使用`package.json`文件安装依赖项时，npm 都会安装文件中提到的确切版本，而不是最新版本。

# 每次代码更改后，使用工具重新启动应用程序

在开发阶段，如果不使用其他工具，您将不得不停止并重新启动应用程序，以应用对代码库所做的简单更改。编码一段时间后，这变成了一个麻烦，不会让你完全专注于任务。

作为解决方案，您可以使用一个工具来监控应用程序的代码库，并在每次发生更改时自动重启应用程序。

适用于 Node 的一些流行的代码监控包有:

*   Nodemon:每当向代码中添加新的更改时，Nodemon 都会自动重启应用程序。你可以在命令行用`nodemon`代替`node`来初始化 Nodemon(比如用`nodemon` app 代替`node app`)。
*   Forever: Forever 还提供了 Nodemon 提供的自动重启特性，但是带有额外的配置选项。这些选项包括设置工作目录和将通常在`stdout`上打印的日志写入文件。
*   PM2: PM2 是另一个你可以使用的过程管理工具。与其他两种相比，它允许更多的控制和功能来管理生产中运行的流程。

你甚至可以在生产环境中使用这些工具——尤其是《永远》和《PM2》。这将保证应用程序在运行时出错后能够顺利恢复。它还将确保应用程序在运行它的服务器关闭的情况下尽快重启。

# 使用样式指南

当许多开发人员在同一个项目上工作时，不可避免地，他们的代码风格会有差异。不幸的是，程序员是一群非常固执己见的人。

如果您的代码风格不同于您目前从事的项目的前一位开发人员，您很可能会根据自己的喜好重新设置大括号的位置或用制表符替换空格。你将会在这个平凡而无用的任务上花费大量的时间，而这个任务对你内心的平静来说是非常必要的。

虽然程序员喜欢在空闲时间讨论什么是节点编程的最佳风格，但这种选择大多是主观的。因此，为了您的安心和工作效率，我们建议您在项目开始前选择并同意特定的风格指南。您甚至可以找到其他程序员使用的现有风格指南。

以下是一些受欢迎的科技公司使用的风格指南:

*   [谷歌](https://google.github.io/styleguide/javascriptguide.xml)
*   [Airbnb](https://github.com/airbnb/javascript)
*   [jQuery](https://contribute.jquery.org/style-guide/js/)

我们可以使用一些工具来确保所选风格指南的规则在整个项目中得以实施。我们可以使用 ESLint 来验证编写的代码，并使用更漂亮的工具来自动格式化。

# 使用 async/await 代替回调

当第一次引入 Node 时，它的异步特性是通过使用回调来保持的。但是任何节点开发人员都会从经验中知道，当回调一个接一个地嵌套时，用不了多久就会失控。这就是我们所说的回调地狱。此时，您的代码将非常难以阅读。

不过随着 ES6 中`async/await`的引入(以及之前的承诺)，Node 已经提供了解决这个问题的方案。因此，作为一名节点开发人员，您有责任利用这一新的引入，而不是在有办法避免回调的情况下又回到回调地狱。

这是一个温和版的回调地狱:

使用`async/await`，我们可以很容易地避免遇到这种情况:

作为节点编程的最佳实践，总是尝试用`async`和`await`替换回调函数。

# 使用合适的测井工具

首先，`console.log`不是一个合适的测井工具。忘记将它用于应用程序的每一个日志记录目的。在许多限制中，`console.log`没有为日志记录提供足够的配置选项，包括根据需要过滤它们的选项。

Node 有几个专用的日志框架，您可以在应用程序中使用。温斯顿、班扬和皮诺就是这类工具的几个例子。您可以测试并选择一个适合您的应用程序的需求。

除了简单的日志记录之外，它们还为您提供了定义日志记录级别的选项，如错误、警告、信息和调试。使用专用的日志记录工具，您还可以根据情况仅打开必要级别的日志，即使应用程序处于生产状态。

使用所选工具创建测井系统时，不要忘记遵循[最佳测井实践](https://livecodestream.dev/post/2020-09-14-you-built-your-node-app-but-are-you-logging/)。

# 总是尝试使用 const Over let

尽可能使用`const`在`let`上声明变量。

当你使用`const`声明一个变量时，你不能在第一次赋值后给它重新赋值。这可以防止您在多个场合重复使用同一个变量。因为`const`迫使你在不重用现有变量的情况下用适当的名字声明新变量，这使得你的代码更加干净和清晰。

但是有些情况下，您可能希望能够灵活地更改变量值。然后，您可以使用`let`来声明该变量，但前提是您已经正确地将它标识为一个改变其值的变量。例如，您必须使用`let`关键字在`for`循环中声明增量变量。

在 ES6 引入`let`之前，在 Node 中使用`var`来声明变量。一些开发人员出于习惯仍然在他们的代码中使用`var`。但是作为节点最佳实践，不要再在代码中使用`var`。

在使用这些关键字声明变量之前，注意它们的[范围也很重要——无论是`const`还是`let`。](https://levelup.gitconnected.com/understanding-variables-scope-and-hoisting-in-javascript-93018bf29190)

# 使用代码覆盖工具来跟踪未测试的代码

我们没有将[测试您的节点应用](https://medium.com/better-programming/testing-in-node-js-using-mocha-and-chai-part-1-d5a9e91f4b06)列为最佳实践之一，因为这是不言而喻的。然而，使用代码覆盖工具是作为节点开发人员应该遵循的最佳实践之一。

我们可以使用代码覆盖工具来确定程序中测试覆盖的级别。这种工具可以识别测试覆盖率是否下降，并突出测试不匹配。

[伊斯坦布尔/纽约市](https://github.com/istanbuljs/nyc)是一个很好的工具，你可以用它来达到这个目的。它提供了彩色的代码覆盖报告，帮助您轻松地识别您所编写的单元测试没有覆盖的区域。您可以轻松地设置 NYC 来使用您首选的测试框架。

首先，从 npm 安装软件包作为开发依赖项:

```
npm install nyc --save-dev
```

然后，添加脚本来运行 NYC 并生成代码覆盖率报告:

```
"scripts": {
    "test": "mocha",
    "coverage: "nyc npm run test"
}
```

现在您可以使用`npm coverage`命令来生成报告。

阅读我上面链接的文档，了解如何配置 NYC 以适应您的应用程序。

# 在==运算符上使用===运算符

在 Node 中，可以同时使用`===`运算符和`==`运算符来检查两个变量是否相等。虽然第一个更严格，但第二个也接受较弱的等式。

使用`===`运算符，两个变量除了值相似之外，还必须是同一类型:

```
1 === 1 //true
1 === "1" //false
false == 0 //false
0 === “” //false
“” === false //false
null === undefined //false
NaN === null //false
NaN === undefined //false
NaN === NaN //false
```

第二个操作符`==`接受两个值相等的变量，即使它们的类型不同。在执行比较之前，它将两个变量转换为一个通用类型(类型强制):

```
1 == 1 //true
1 == "1" //true
false == 0 //true
0 == “” //true
“” == false //true
null == undefined //true
NaN == null //false
NaN == undefined //false
NaN == NaN //false
```

正如你在这些例子中看到的，使用`==`操作符给出了不同于我们通常预期的答案。这是因为在类型强制期间，JavaScript 的行为违背了我们的直觉。如果你能记住所有奇怪的情况，并在使用`==`操作符编写程序时留意它们，这就不是问题了。

但是通过使用严格的等式操作符`===`进行比较，您可以很容易地避免担心这种不直观的行为。

# 不要从节点提供您的前端资产

就其本质而言，Node 只使用一个线程来处理向服务器发出的所有请求。我们必须注意最大化这个单线程的效率，否则，它会对应用程序的性能产生很大的影响。

如果我们使用节点服务器发送静态内容(如 HTML 或 CSS 文件)和图像，它们可能会占用单线程。这不公平地影响了应用程序的动态内容，因为它们实际上利用了应用程序的内部组件和逻辑。由于动态和静态内容之间的执行时间分配不平衡，我们的应用程序速度会大大降低。

为了避免这种不平衡，您可以将静态内容从节点服务器中移出，并使用 Nginx、S3 或 CDN 等专用中间件将它们提供给用户。然后，节点就有机会提供动态内容，这实际上利用了它的内部逻辑，并防止了静态内容导致的性能下降。

# 保持你的应用程序无状态

将您需要通过应用程序存储的任何类型的数据(例如，用户会话、用户数据、缓存)存储在外部数据存储中。不要在应用程序本身存储任何信息。

简而言之，让你的应用程序保持无状态。您应该能够每天关闭并重启服务器，而不会影响它为用户提供的服务。或者，您可以使用像 AWS Lambda 这样的无服务器平台，它在默认情况下强制实施无状态行为。

保持服务器无状态可以让应用程序在任何最终的系统故障中幸存下来，而不会损害其服务和性能。

# 结论

在本文中，我们讨论了作为节点开发人员应该遵循的十个最佳编码实践。这些实践帮助您编写更好的代码，以确保应用程序的最佳性能。

值得注意的是，这些是您应该遵循的实践，以及适用于任何编程语言的其他最佳编码实践。第一次尝试时，您可能无法使用所有这些实践。挑选一两个你认为最重要的，然后从那里开始。最终，在编写 Node.js 代码时，您将能够遵循所有这些原则。

感谢阅读！