<html>
<head>
<title>Best Practices for Versioning REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">版本化REST APIs的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-for-versioning-an-api-for-rest-apis-530a9398f311?source=collection_archive---------3-----------------------#2019-12-15">https://betterprogramming.pub/best-practices-for-versioning-an-api-for-rest-apis-530a9398f311?source=collection_archive---------3-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ed1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">版本控制通常是事后才想到的，但不应该这样</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5270657dbeea9c238afd62f5977c8e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K42A30Go8u1oBeLaMA-9tQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@spacex" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>提供</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8082" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="4763" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">API版本控制通常是开发过程中的事后想法，事实上，为了用户使用和易用性，它应该是设计API的最重要的部分。</p><p id="28e5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">作为一名API爱好者，我想写一篇简短的文章，描述目前可用的各种类型的API版本，以改善最终用户的API体验。</p><p id="c8ed" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我马上想到了几个选择:</p><ol class=""><li id="2c89" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">内嵌路由版本(我的最爱)。</li><li id="9833" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">查询字符串(草率)。</li><li id="1577" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">接受标题(在我看来，这是事后的想法)。</li></ol><p id="a6c9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">基本原则是这样的——为了管理你的API中的复杂性和突破性的变化，总是对你的API进行版本化。简而言之，API版本控制使您能够在发现重大变更时更快地迭代。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ee68" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">何时版本化</h1><p id="20b7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果您不想对API进行版本化，或者担心它会在构建过程中增加复杂性，我建议您考虑以下几点:</p><ul class=""><li id="8b84" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt nn nf ng nh bi translated">如果用户在API发布后遇到输出问题，您最终会更改响应数据以适应这些请求，还是保持原样并忽略用户反馈？</li><li id="42c9" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt nn nf ng nh bi translated">如果因为不再需要某个端点而不得不将其从API中完全删除，该怎么办？如果没有正确的版本控制，用户可能仍然会到达这个端点，却发现他们收到了一个404。像404这样的状态代码对于开发人员来说并不好玩，不管您是否更新了您的文档——这是开发人员需要采取的额外步骤。</li><li id="fc3c" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt nn nf ng nh bi translated">您的API现在需要一个额外的POST方法键。在你原来的API上，你不需要它；但是，在您的下一次迭代中，如果没有传递新的键，API将会中断。</li><li id="75e4" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt nn nf ng nh bi translated">由于语义和最佳实践，API的路由结构正在发生变化。这是最好的；然而，如果你不更新你的API，你将会给用户留下一个旧的API结构，甚至更糟，坏掉。</li></ul><p id="9cb0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我可以一直这样下去，但它的要点是，你应该始终版本化你的API，以确保开发人员有一个清晰和简洁的方式与不断变化和最新的API进行交流。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6ac3" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">如何版本化</h1><p id="33f7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在我的世界里，有三种可能的方法来正确地对API进行版本控制。按照我最喜欢的到最不喜欢的顺序，这些包括:</p><ol class=""><li id="b3a5" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">URL，也称为路由版本化(如<code class="fe no np nq nr b">/v1/:foo/:bar/:baz</code>)。</li><li id="c83e" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">通过自定义标题进行版本控制(例如<code class="fe no np nq nr b">Accept-Version: v2</code>)。</li><li id="ecd1" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">查询字符串参数(如<code class="fe no np nq nr b">/:foo/:bar/:baz?version=v2</code>)。</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="dcef" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">利弊</h1><p id="8ff9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">URL或路由版本是我个人的最爱。对于用户来说，他们正在使用哪个API是清楚而简明的，并且允许用户参考正确的文档。</p><p id="cc86" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">许多框架支持路由定义的版本控制，当它不支持时，您可以简单地构建您的API，以便它支持路由版本控制。正因为如此，它非常容易实现；然而，它确实增加了REST API路径的长度，这是不利的一面。</p><p id="f838" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在我的列表中，自定义头是下一个，因为它们做了它们应该做的事情——它们指定API的版本，服务器可以用正确的响应数据做出适当的响应，并动态解析传入的有效负载。</p><p id="1c41" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这听起来像是一个简单的解决方案；然而，考虑一下那些只想通过您的开源API提取数据而不提供自定义头的开发人员。</p><p id="eae6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">特别是，这造成了一个问题，因为用户不应该被迫发送自定义头来简单地指定API的版本。此外，在响应之前进行解析需要服务器开销，这可能会增加延迟。</p><p id="c089" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后但同样重要的是，还有查询字符串版本控制。这被许多开发人员称为不良实践；经常在制作中看到，让我畏缩。</p><p id="2ec0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它强调API开发，更重要的是，必需的参数和模式是事后才想到的。不惜一切代价远离这个。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="bb9d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">最后的想法</h1><p id="4725" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如有疑问，尽可能使用URL/路由版本控制。我保证它会简化你的开发过程，让使用你的API的开发者开心。</p><p id="fd43" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在以后的文章中，我将概述如何使用REST API和Express通过路由定义手工构建版本控制。同时，请在下面的评论中留下任何问题或想法。</p><p id="a3c9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下次见。编码快乐！</p></div></div>    
</body>
</html>