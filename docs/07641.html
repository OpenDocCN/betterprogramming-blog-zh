<html>
<head>
<title>Avoid ORM in Go — Use Pure SQL Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中避免ORM使用纯SQL代替</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/avoid-orm-in-go-use-pure-sql-instead-3ae7f0485b37?source=collection_archive---------3-----------------------#2021-02-04">https://betterprogramming.pub/avoid-orm-in-go-use-pure-sql-instead-3ae7f0485b37?source=collection_archive---------3-----------------------#2021-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ef29" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">停止<strong class="ak">学习每种语言的新ORM语法</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1505476c6e50d45d8f2f329d1df5fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6H36joIh9dyT3vEf"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗伯特·阿纳施在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="03ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是一名喜欢尝试许多不同语言和框架的软件工程师，您可能已经体验过为每种语言学习新ORM语法的痛苦。这是一个巨大的缺点，它会降低你最初的生产力或者耗尽你的动力。</p><p id="f078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果您已经了解SQL，那么您可以使用这些知识，并通过遵循一些提示或像本文这样的简单教程将其转换为许多不同的语言。</p><p id="2874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将设置我们的环境。为了遵循教程，您可以安装Postgres并让它在您的机器上运行。或者，您可以使用Docker。下面的docker-compose文件将使一切正常运行，而不必担心其他任何事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2f6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您将该文件放在项目的根目录下，您只需运行以下命令来设置所有内容:</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="4ab8" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">docker-compose</strong> up</span></pre><p id="323c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们在<code class="fe mf mg mh lv b">db</code>服务中定义了一个卷，它共享一个将在docker-compose启动时运行的SQL脚本。注意，您必须将它映射到<code class="fe mf mg mh lv b">docker-entrypoint-initdb.d</code> <strong class="ky ir"> </strong>目录，以便Postgres容器在启动时运行它。<code class="fe mf mg mh lv b">init.sql</code> <em class="mi"> </em>包括我们将在本教程中使用的数据库和表的定义，这只是todos数据库的一个示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库和表定义</p></figure><p id="abc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe mf mg mh lv b">db</code>容器启动时，它将运行上面的脚本并创建数据库和todos表(如果它们还没有被创建的话)。</p><p id="00ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们准备好了环境，我们将进入编码部分。</p><p id="8efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将定义Go应用程序如何配置对数据库的访问。我们唯一需要导入的包是postgres驱动程序。</p><p id="6511" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要遵循的第一个好的实践是从环境变量中获取我们所有的数据库凭证，因为我们不希望它们包含在我们的代码中，这样我们可能会向公众公开。</p><p id="37af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这不是绝对必要的，但我们将定义以下常量，以避免在代码的某些部分出现硬编码的字符串。请注意，环境变量的名称在现实场景中更具描述性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将使用这些常量来获取环境变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0337" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了所有这些，我们将在<code class="fe mf mg mh lv b">init()</code>函数中包含其余的代码。<strong class="ky ir"> </strong>在Go中，第一次使用一个包时会调用<code class="fe mf mg mh lv b">init</code>函数，即使该包在不同的包中使用，也不会再次调用。在这个函数中，我们将打开到数据库的连接，然后通过调用<code class="fe mf mg mh lv b">Ping()</code>方法检查数据库是否正常工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">建立数据库连接</p></figure><p id="f2c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将继续我们的模型。我们将使用道和DTO模式来定义我们的模型。</p><p id="3731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将在<code class="fe mf mg mh lv b">model/todos</code> <em class="mi"> </em>目录下创建<code class="fe mf mg mh lv b">todos_dto.go</code>文件<em class="mi"> </em>。DTO模式用于在应用程序的不同模块之间传输数据。本质上，它是一种抽象，信息通过它在DAO和业务服务之间传递。在Go中，您可以通过创建一个结构并定义如何在JSON中编码每个字段来实现它。注意，这个文件不应该包含您的应用程序可能包含的任何业务逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">托多斯DTO</p></figure><p id="c729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，DAO模式将业务逻辑与数据访问逻辑分离开来。它提供了创建、检索、更新和删除数据库中的数据的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">托多斯岛</p></figure><p id="0973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将使用预先准备好的语句直接调用<code class="fe mf mg mh lv b">Exec()</code> <em class="mi"> </em>或<em class="mi"> </em> <code class="fe mf mg mh lv b">Query()</code> <em class="mi"> </em>方法<em class="mi"> </em>。尽管对于为什么使用一种方法而不是另一种方法存在争议，但是有一些基准表明，预处理语句在Go中更有性能。</p><p id="53b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们用想要执行的查询调用了<code class="fe mf mg mh lv b">Prepare()</code> <em class="mi"> </em>方法，我们就检查返回的错误，然后推迟关闭准备好的语句。如果我们忘记这样做，它将永远与我们的联系捆绑在一起。因此，在准备好一条语句后，一定要推迟<code class="fe mf mg mh lv b">stmt.Close()</code> <em class="mi"> </em>方法调用，这一点很重要。</p><p id="d6db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们拥有了所有这些，在<code class="fe mf mg mh lv b">Save()</code>方法中，我们将执行<code class="fe mf mg mh lv b">QueryRow</code> <em class="mi"> </em>方法和<code class="fe mf mg mh lv b">Scan()</code> <em class="mi"> </em>返回的id。由于ID是由数据库自动生成的，所以在我们执行的<code class="fe mf mg mh lv b">INSERT</code>查询中将会缺少它。为了从数据库中检索它，一些数据库如MySQL提供了从查询结果中调用<code class="fe mf mg mh lv b">LastInsertId()</code> <em class="mi"> </em>方法的可能性。然而，由于我们使用Postgres，我们可以显式地声明我们的查询，我们希望返回生成的ID。</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="463b" class="lz ma iq lv b gy mb mc l md me">INSERT INTO todos(description, priority, status) VALUES($1, $2, $3) <strong class="lv ir">RETURNING id;</strong></span></pre><p id="239b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在检查没有出现错误之后，我们将获得的ID分配给我们的<code class="fe mf mg mh lv b">Todo</code>结构，这样就完成了插入。</p><p id="78d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们遵循了在插入查询中返回todo ID的方法，<code class="fe mf mg mh lv b">Get()</code> <em class="mi"> </em>方法过程将类似于<strong class="ky ir"> </strong>但更简单<strong class="ky ir">。</strong></p><p id="6c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试一切是否按预期工作，我们将使用下面的<code class="fe mf mg mh lv b">main.go</code> <em class="mi"> </em>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1c64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的main，它插入两个todo，然后检索ID为1的todo。考虑到我们已经添加到我们的DAO中的日志记录，这个main的输出应该类似于下面这样(注意，我得到的是id5和6，因为我之前已经执行过几次):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/1ff20c76405dc32c3a4c131e1b6a2525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVRAB8cFwa3lENUf3E_OJA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">main.go输出</p></figure><p id="c6dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您得到这样的输出，那么一切都工作正常，并且您已经成功地在不使用ORM的情况下与数据库进行了交互。你可以在这个<a class="ae kv" href="https://github.com/UxioAndrade/tutorials/tree/main/go-sql-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到本教程的代码。</p></div></div>    
</body>
</html>