<html>
<head>
<title>Closures in JavaScript for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的JavaScript闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/closures-in-javascript-for-beginners-a61c5162b599?source=collection_archive---------11-----------------------#2019-09-05">https://betterprogramming.pub/closures-in-javascript-for-beginners-a61c5162b599?source=collection_archive---------11-----------------------#2019-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/dbc50b164c47e58a4be93bc17d15b99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*enxHCgJXmLu3Mxj6_TXEgQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯汀娜·戈塔迪在<a class="ae kf" href="https://unsplash.com/search/photos/closure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2cd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您第一次开始学习JavaScript时，闭包看起来相当吓人，这并不奇怪。但是它们实际上非常简单——让我们看看如何实现。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e5f1" class="ln lo it lj b gy lp lq l lr ls">function outer(){<br/>  var a="From outer "<br/>    return function inner(){<br/>       var b="to inner"<br/>      console.log(a+b);<br/>    }<br/>}<br/>//outer();<br/>//outer()();<br/>//inner();</span></pre><p id="1ad5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你熟悉函数，闭包只不过是利用先前返回的外部函数中的变量的函数。首先，复制上面的代码，并在控制台中运行它。你认为调用各自的函数调用的结果会是什么？</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lt"><img src="../Images/29648a9cb716d77f1c175e3a3a40bc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swMrMRKs9gJRRY2Ov7-jtA.png"/></div></div></figure><p id="cffe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们调用<code class="fe lu lv lw lj b">outer()</code>、<em class="lx">、</em>时，我们得到了内部函数。当我们调用<code class="fe lu lv lw lj b">outer()()</code>，<em class="lx"> </em>时，我们在控制台上得到两个串接的字符串。当我们调用<code class="fe lu lv lw lj b">inner()</code>时，我们得到了一个错误。</p><p id="9f42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看另一个例子:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="029c" class="ln lo it lj b gy lp lq l lr ls">function outer(){<br/> var a=10;<br/>   return function inner(){<br/>     console.log(a*10);<br/>    }<br/>}<br/>outer()();</span></pre><p id="9714" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会发现使用<code class="fe lu lv lw lj b">()()</code> <em class="lx">调用函数很奇怪。但是这是闭包和嵌套函数在语法上的本质区别。</em></p><p id="9bb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的两个例子展示了两个不同的特征——一个是调用的方式，另一个是<em class="lx"/><code class="fe lu lv lw lj b">return</code>关键字的存在。它真正的意思是，在外部函数返回很久以后，内部函数还可以访问外部函数的变量。</p><p id="2c37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你想写一个简单的函数来乘两个数。一个显而易见的方法是:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8336" class="ln lo it lj b gy lp lq l lr ls">function multiply(a,b){<br/>    return a*b;<br/>}<br/>multiply(3,5);</span></pre><p id="f62a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们试试另一种方法。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="80eb" class="ln lo it lj b gy lp lq l lr ls">function multiply(a){<br/>   return function(b){<br/>     return a*b;<br/>   }<br/>}<br/>multiply(3)(5);</span></pre><p id="53a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二种方法利用了闭包，其中我们在封闭范围内引用局部绑定的特定实例，并返回内部函数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0ff6" class="ln lo it lj b gy lp lq l lr ls">function add(a){<br/>  function(b){<br/>     return a+b;<br/>  }<br/>}<br/>add(8)(7);</span></pre><p id="4ff4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您首先运行上面的代码，您会得到一个错误，说“函数语句需要一个函数名”，随后又是一个错误说“add(…)不是一个函数。”这是因为我们还没有返回内部函数。因此使用<code class="fe lu lv lw lj b">()()</code>进行调用是没有意义的。如果您删除一对<code class="fe lu lv lw lj b">()</code>，它将返回“undefined”，这是应该的，因为您实际上并没有返回任何东西。</p><p id="2f0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">差不多就是这样。它们是嵌套函数，内部函数利用外部函数的变量。并且记得在内部函数之前添加return关键字。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="d329" class="mf lo it bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated"><strong class="ak">让我们来看看闭包的实际应用</strong></h1><p id="4758" class="pw-post-body-paragraph kg kh it ki b kj nc kl km kn nd kp kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">闭包可以用来创建私有变量。私有变量是不能从外部修改的变量。</p><p id="e91b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看另一个例子来理解这一点。比方说，您想计算用户点击按钮的次数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="480e" class="ln lo it lj b gy lp lq l lr ls">&lt;button onclick="clickCount()"&gt;click me!&lt;/button&gt;</span></pre><p id="4b2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以使用一个全局变量<code class="fe lu lv lw lj b">(cnt)</code>来计数。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c5f0" class="ln lo it lj b gy lp lq l lr ls">var cnt=0;<br/>function clickCount(){<br/> cnt++;<br/>}</span></pre><p id="a377" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是这里有一个小问题:页面上的任何脚本都可以改变我们的变量<code class="fe lu lv lw lj b">cnt</code> <em class="lx"> </em>的值，甚至不用调用函数<code class="fe lu lv lw lj b">clickCount()</code>。</p><p id="f6fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是一个真正的问题——让我们在函数内部声明<code class="fe lu lv lw lj b">cnt</code> <em class="lx"> </em>就可以了。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="54ed" class="ln lo it lj b gy lp lq l lr ls">function clickCount(){<br/>var cnt=0;<br/>cnt++;<br/>}</span></pre><p id="767e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是现在每次调用那个函数，<code class="fe lu lv lw lj b">cnt</code>总是从0开始。所以让我们用嵌套函数来代替。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a963" class="ln lo it lj b gy lp lq l lr ls">function cntWrapper() {<br/>    var cnt = 0;<br/>    function clickCount() {<br/>    cnt++;<br/>    }<br/>    clickCount();    <br/>    return cnt; <br/>}</span></pre><p id="3b7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住嵌套函数可以访问它们上面的作用域。要调用内部函数，你必须调用外部函数，同样，你的计数器变量每次都从0开始。看来我们又回到起点了。如果我们能从外部调用内部函数就好了。</p><h2 id="373b" class="ln lo it bd mg nh ni dn mk nj nk dp mo kr nl nm ms kv nn no mw kz np nq na nr bi translated"><strong class="ak">输入结束(双关语)</strong></h2><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e41e" class="ln lo it lj b gy lp lq l lr ls">var updateCnt=(function() {<br/>    var cnt = 0;<br/>    return function() {<br/>    cnt++;<br/>    return cnt;<br/>}<br/>})();</span></pre><p id="bcb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了一个只运行一次的自调用函数，将<code class="fe lu lv lw lj b">cnt</code>初始化为0，并返回一个函数表达式。</p><p id="3ca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的函数绑定可以访问父作用域中的<code class="fe lu lv lw lj b">cnt</code> <em class="lx"> </em>。您会注意到，每次您调用<code class="fe lu lv lw lj b">updateCnt()</code>时，您的计数器都会将之前的值加1。如果你在控制台上输入<code class="fe lu lv lw lj b">cnt</code>，你会得到一个错误，说它没有被定义。因此，我们的<code class="fe lu lv lw lj b">cnt</code>变量，现在是安全的，本质上是一个私有变量，受匿名函数的保护。</p><p id="37e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是你需要知道的关于闭包的一切！</p></div></div>    
</body>
</html>