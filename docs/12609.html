<html>
<head>
<title>How (and when) to optimize performance in your React application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何(以及何时)优化React应用程序的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-and-when-to-optimize-performance-in-your-react-application-b0b8c8c66bb3?source=collection_archive---------4-----------------------#2022-06-16">https://betterprogramming.pub/how-and-when-to-optimize-performance-in-your-react-application-b0b8c8c66bb3?source=collection_archive---------4-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5712" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用备忘录、使用回调、使用备忘录、利用上下文等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/87d2f55dcbf3bab737217a9e2ebd5547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3_XJNVCGY11P4vSZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@tetrebbien?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> TETrebbien </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ea6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢让应用程序更好更快，尽可能为用户提供最好的体验。发表过<a class="ae kv" href="https://playbanggame.online/" rel="noopener ugc nofollow" target="_blank"> Play BANG等几个项目！在线</a>、<a class="ae kv" href="https://react-handbook.danajanoskova.sk/" rel="noopener ugc nofollow" target="_blank">React手册</a>、<a class="ae kv" href="https://vuex-but-for-react.netlify.app/" rel="noopener ugc nofollow" target="_blank"> vuex-but-for-react </a>、<a class="ae kv" href="https://blokep.netlify.app/" rel="noopener ugc nofollow" target="_blank"> Blokep </a>等。</p><p id="a7f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的职业生涯中，我曾多次被分配任务，以确定React应用程序中的性能瓶颈，并重写这些部分以使它们更快。这篇文章将总结出一些技巧，让你也能做到这一点。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="471f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">渲染瀑布</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/4fcf90fe1b62e6156881baacafbc6c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kV4ng8E7dD-Z6gsWsKPCDg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用渲染反应组件树</p></figure><p id="3574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React组件一直在渲染。如果组件的父组件渲染，那么它的所有子组件也会渲染。如果父对象渲染30次，那么每个子对象也会渲染30次——即使他们与最初导致父对象渲染的数据完全无关。</p><p id="98e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使渲染只是一个虚拟DOM比较，如果不必要的话，它仍然会降低用户的性能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/89386116fb82341803759bfa2aca63a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*heq1QUzU7MYD541dSJtAmA.png"/></div></div></figure><p id="a815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后想象一下——如果你不优化你的应用程序的性能，你的组件树越大,“实际渲染计数”的曲线就越陡。</p><p id="9f6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们创建了一个非常平坦的树，有一些渲染，在这个图表中，你已经可以看到，如果我们要保护组件免受不必要的渲染，我们将执行渲染的值减少了一半。你的应用程序规模越大，你就能通过正确使用<code class="fe mt mu mv mw b">memo</code><em class="mx"/>来减少更多不必要的渲染。</p><p id="fd4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在现实世界中，仅仅将每个组件包装在<code class="fe mt mu mv mw b">memo</code>中并完成它是不明智的。重要的是您选择哪个组件和数据来记忆，这些图像仅仅是指数瀑布的一个简单的可视化演示。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7a7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我先说:早期优化很重要</p><blockquote class="my mz na"><p id="7dc6" class="kw kx mx ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">“使用useMemo是一种不成熟的优化”<br/>“使用useMemo可能会损害应用程序的性能”<br/> -有些人，总是这样</p></blockquote><p id="5eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优化总是“过早”的，直到为时已晚。<br/>不使用memo、useMemo、useCallback比使用更伤性能。</p><p id="e700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总会有一些“我们没有预料到”和“我们不可能知道”的事情，会有一个巨大的数据集使你的UI渲染和反应极其缓慢，会有一个用户的机器不是最具性能的，他们会感谢你尽早优化。</p><p id="30b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实是，在正确的地方做这些检查并不会像不做那样让你付出更多的代价。一旦您开始在useMemo或useCallback中没有包装的部分中实现性能改进，您将不得不经历无数层未包装的功能，并且您将更有可能在已经存在的功能中引起错误。这需要花费精力和开发人员的时间，而且风险很大——如果这个应用程序是以UX为中心编写的，这是可以很容易避免的。</p><p id="13b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我加入一个已经在运行的项目时，这是我必须做好几次的事情，而且总是同样的故事。我写这些指南是希望它能帮助你在正确的地方进行合理的优化。</p><p id="e7e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将介绍以下各项的正确用法:</p><ul class=""><li id="82e7" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe mt mu mv mw b">React.memo</code> —将其用作组件(高阶组件)的包装器</li><li id="436f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe mt mu mv mw b">React.useMemo</code> —用它来记忆<em class="mx">功能组件的</em>体中的<em class="mx">值</em></li><li id="d056" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe mt mu mv mw b">React.useCallback</code> —用它来记忆<em class="mx">功能组件的</em>体中的<em class="mx">方法</em></li><li id="76f4" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe mt mu mv mw b">React.createContext</code> —使用它向树中较低的组件<em class="mx">提供值，作为使用props的替代方法</em></li><li id="11f4" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe mt mu mv mw b">React.useContext</code> —使用它来消耗所提供的上下文的值</li></ul><h1 id="0bf6" class="lz ma iq bd mb mc ns me mf mg nt mi mj jw nu jx ml jz nv ka mn kc nw kd mp mq bi translated">何时使用React.memo</h1><p id="5abd" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated"><code class="fe mt mu mv mw b">React.memo</code>是一个更高阶的组件，它实现了一个组件的props值的浅层比较，检查它们是否改变了，如果改变了就重新渲染。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/996ca2ab3072cd3453b379cecb80bdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bYDT2uw-wUxtIkRm9Yvwg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">何时使用React.memo</p></figure><p id="644a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不确定组件何时重新呈现，您可以将console.log直接放在其主体中。当您检测到组件中的某个操作导致显著延迟时，通常会这样做，以调试组件(及其子组件)渲染的次数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/2d6babd43c928717edd6e3fe2db03e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91PeT1zEEKVX5XBFsyKdOw.png"/></div></div></figure><h2 id="92b1" class="od ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">我使用备忘录<em class="op">的经验法则是:</em></h2><ul class=""><li id="bab5" class="ne nf iq ky b kz nx lc ny lf oq lj or ln os lr nj nk nl nm bi translated">在一个组件上使用它，该组件的父组件会重新渲染很多次(应该的，可能会有一些状态更新)，但是你的组件不会受到这些变化的影响</li><li id="6c70" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">只有当组件的属性是原始值或记忆值时才使用它，否则它不会产生积极的影响</li><li id="6d6a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当不必要的重新渲染会导致子组件的瀑布渲染时，在组件树的顶部使用它</li></ul><p id="88de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要记住的一些提示:</p><ul class=""><li id="0fcb" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">默认情况下，只要父组件渲染，组件就会渲染，即使它不包含任何属性。这意味着在组件中触发状态更新将(试图)呈现它的所有子组件，即使它们没有继承这个更新的数据实例。</li><li id="b2c2" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">不能因为一个通过props继承的数据是“相同的”，就说明它在内存中没有变化。当传递非原始数据类型时，比如数组、对象或函数，您必须确保它们不会被重新创建。如果这个数据是在我们组件的父组件中创建的，那么它需要包装在一个<code class="fe mt mu mv mw b">useMemo</code>或<code class="fe mt mu mv mw b">useCallback</code>中以确保记忆。如果非原始数据类型没有被包装，那么在我们的组件上使用<code class="fe mt mu mv mw b">memo()</code>不会有什么不同，只要它的父元素有所表现，它就会有所表现，因为那些道具会被重新创建。</li></ul><div class="kg kh ki kj gt ab cb"><figure class="ot kk ou ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/e81e9494eeb66698f3c01a8645891830.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*DVmt08jYUrOAi7sU0fEZHA.png"/></div></figure><figure class="ot kk oz ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/83a870ebf3690be53343eb7c53cb3cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*Fzfzzo_eCTmvaeVlakASfg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk pa di pb pc translated">左:memo()对非记忆道具没有帮助。正确:记忆道具是正确的选择！</p></figure></div><ul class=""><li id="27d8" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">当您使用React profiler并检查临界值时，或者只是在UI中单击并注意到某个动作的延迟时，您就会知道组件的渲染是昂贵的。</li><li id="8a9c" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">这个缓慢的动作很可能会在不直接依赖于这个动作结果的地方触发一个渲染瀑布。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/7f5d41aeff0601f0cad3b6b0c00e9d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTpFK0YpvKGPNk52RGTZ1g.png"/></div></div></figure><p id="4acd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以通过创建一个单独的<code class="fe mt mu mv mw b">useEffect</code>来调试一个道具是否改变。<code class="fe mt mu mv mw b">useEffect</code>会在依赖关系发生变化时通知您。</p><blockquote class="my mz na"><p id="ef21" class="kw kx mx ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">"我的道具没有改变，我的组件被包装在memo()中，当我更新父组件时，它仍然会重新呈现！"</p></blockquote><p id="7a9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果发生这种情况，请确保您的组件没有收到它不需要的其他道具。使用spread运算符时，有时会出现这种情况。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/c35349e8d9206f4a52ae5f5a19da1523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SquAuIz4R-36561KlelWQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">传播道具时要小心，你可能会传递孩子不需要或不期望的价值</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0501" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">何时使用React.useMemo</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/599ba3b3c775cf87f7111511e0149d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEKLull0Lpu9EUPvBS1nvA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">何时使用React.useMemo</p></figure><p id="a052" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用React的useMemo来记忆<em class="mx">值</em>。</p><pre class="kg kh ki kj gt pe mw pf pg aw ph bi"><span id="7c19" class="od ma iq mw b gy pi pj l pk pl">import { someHeavyFilteringLogic } from './helpers/filtering'</span><span id="ae72" class="od ma iq mw b gy pm pj l pk pl">const filteredUsers = useMemo(() =&gt; {<br/>  const users = someHeavyFilteringLogic(data, filter);<br/>  return users;<br/>}, [data, filter])</span></pre><p id="44ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mx">在这种情况下，我们依靠</em> <code class="fe mt mu mv mw b"><em class="mx">data</em></code> <em class="mx">和</em> <code class="fe mt mu mv mw b"><em class="mx">filter</em></code> <em class="mx">存储状态值，因此除非它们改变，否则不会重新创建。<br/> </em> <code class="fe mt mu mv mw b">someHeavyFilteringLogic</code> <em class="mx">是外部导入，所以不必作为依赖项提供。但是，如果你从一个道具中获得功能，它需要自己提供和记忆。</em></p><h2 id="1db9" class="od ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">我使用<em class="op">使用备忘录的经验法则是:</em></h2><ul class=""><li id="1e4b" class="ne nf iq ky b kz nx lc ny lf oq lj or ln os lr nj nk nl nm bi translated">使用它来计算除非必要否则不会改变的依赖关系</li><li id="e4fc" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当您将值作为道具或在上下文的提供者中传递时使用它</li><li id="be8c" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当您将值作为useCallback、useEffect、useMemo的依赖项提供时，请使用它</li></ul><blockquote class="my mz na"><p id="82db" class="kw kx mx ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">"我不能用memo()包装组件，而不是对其值使用useMemo吗？"</p></blockquote><p id="1a7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你完全确定用<code class="fe mt mu mv mw b">memo</code>包装你的组件可以防止所有不必要的渲染，从技术上来说，你可以。</p><p id="549f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你在一个公司环境中工作，你不能指望人们将来不扩展你的组件，也许提供一些会改变的适当值，这将触发一个渲染，这将触发你的计算值的重新创建。如果你向下传递，你会发现自己有一个渲染瀑布，即使你的组件被包装在<code class="fe mt mu mv mw b">memo</code>中。</p><p id="c3db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你需要这个值而不是不必要的重新创建，因为其他组件依赖它(被记忆)，使用<code class="fe mt mu mv mw b">useMemo</code>总是正确的选择。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bbc1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">何时使用React.useCallback</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/5d67f0dc04cd7031186bce2b3d437a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JYIBAtikdwFALqNKDhjQfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">何时使用React.useCallback</p></figure><p id="be03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用React的<code class="fe mt mu mv mw b">useCallback</code>来记忆<em class="mx">方法</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/959f63d24df5dcbd2b65aba3f36d346f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfVjagCCuRBlE6003yyVbw.png"/></div></div></figure><h2 id="67a2" class="od ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">我使用<code class="fe mt mu mv mw b">useCallback</code>的经验法则是:</h2><ul class=""><li id="3a77" class="ne nf iq ky b kz nx lc ny lf oq lj or ln os lr nj nk nl nm bi translated">当您在上下文的提供者中向下传递方法时使用它</li><li id="7b62" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当你把这个方法作为一个道具传递下去的时候使用它，如果需要的话，这会让在<code class="fe mt mu mv mw b">memo</code>包装孩子变得更简单</li><li id="5494" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">在多个深度级别中将该方法作为道具向下传递时使用它，以避免瀑布式重新渲染</li><li id="e71d" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当您在另一个<code class="fe mt mu mv mw b">useCallback</code>或<code class="fe mt mu mv mw b">useEffect</code>中将方法作为依赖项传递时使用它</li></ul><div class="kg kh ki kj gt ab cb"><figure class="ot kk pn ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/35b82b1788238c9ba095a9161e2147bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*NBH7D_h94sPSgZatw6aXtg.png"/></div></figure><figure class="ot kk po ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/7c78475f36bb7cb71fa4e9de3282de39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*2McZcjbq6VzKUH5CcQx8yg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk pp di pq pc translated">不正确的useEffect用法(左)和正确的useEffect + useCallback用法(右)</p></figure></div><p id="14ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您专业地从事React应用程序的工作，那么您有可能见过(并写过？)类似左边的<code class="fe mt mu mv mw b">useEffect</code>，这里缺少依赖项，eslint规则被有意注释掉了。</p><blockquote class="my mz na"><p id="d325" class="kw kx mx ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">“但是在这种情况下使用useCallback是一种矫枉过正/过早的优化”</p></blockquote><p id="848a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，使用<code class="fe mt mu mv mw b">useCallback</code>与<code class="fe mt mu mv mw b">useEffect</code>结合并不是“过早优化”，这是正确的用法(线程链接在文章底部)。React的创建者和贡献者不鼓励错误地使用<code class="fe mt mu mv mw b">useEffect</code>并忽略依赖关系——这是有充分理由的。</p><p id="0841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">右边的例子显示了<code class="fe mt mu mv mw b">useCallback</code>和<code class="fe mt mu mv mw b">useEffect</code>组合的正确用法，并提供了调用所依赖的<code class="fe mt mu mv mw b">userId</code>变量作为依赖项。如果<code class="fe mt mu mv mw b">userId</code>改变，获取用户功能将被再次调用——<em class="mx">,对于不同的用户使用不同的id。</em></p><p id="645a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，你的<code class="fe mt mu mv mw b">useEffect</code>太复杂和纠结，无法提供所有需要的依赖，违反规则似乎更容易。从长远来看，它将更难调试，并且将成为神奇代码的来源，并让您的后继开发人员感到沮丧。通常，这些难题可以通过正确的数据架构来解决——并且只需一点点<code class="fe mt mu mv mw b">useCallback</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b364" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">何时使用上下文</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/53a98db63855ad6b2f92143b4bb60b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHvgx0cTEbJhMfvy-wFPPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">何时使用React。语境</p></figure><p id="a137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用React的上下文API<em class="mx">将值向下传递给子节点</em>。</p><h2 id="27e4" class="od ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">我使用<code class="fe mt mu mv mw b">Context</code>的经验法则是:</h2><ul class=""><li id="c673" class="ne nf iq ky b kz nx lc ny lf oq lj or ln os lr nj nk nl nm bi translated">使用它将当前组件的值提供给树中的深层组件</li><li id="8bc0" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当属性钻取(将属性向下传递几层以将其传播给需要它的子对象)导致性能问题时使用它—当我们更改一个值时，它会触发对该值不感兴趣的组件的渲染，并且接收它只是为了将其进一步向下传递</li><li id="b36d" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当通过一个上下文的提供者提供一个非原始的计算值时，确保对它进行记忆，这样消耗它就不会导致重新呈现</li><li id="070e" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">不要将多个不相关的属性嵌套到一个上下文中——为每个逻辑片段创建一个新的上下文，以避免不必要的重新创建和重新呈现(不要将“当前登录用户”的上下文与“获取的博客文章”的上下文混合在一起)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/a5133731b86d7a34902413dd5ba07e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlSguHG0ad-d6h15mWG_mg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如果你正在进行道具训练，使用memo()是低效的</p></figure><p id="4dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有因为性能问题而想要<code class="fe mt mu mv mw b">memo()</code>的组件，确保它们不会仅仅为了传递它们而接受不必要的道具(道具训练)。</p><h2 id="1338" class="od ma iq bd mb oe of dn mf og oh dp mj lf oi oj ml lj ok ol mn ln om on mp oo bi translated">提示:</h2><p id="0365" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">如果您有一个保存状态值和该值的setter的组件，并且您希望将它们都提供给树中的一个子组件，那么为每个组件创建一个单独的上下文——setter不会重新创建，但是值会改变！将它们组合成一个单独的对象，然后向下提供，会导致只需要setter的组件也需要重新创建。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cdf2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">示例时间</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/b68a01f21398f62064a27a6e2d86bc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dHvQ1urhMCXKg-dt_-RCA.png"/></div></div></figure><p id="4cb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，组件<code class="fe mt mu mv mw b">&lt;MyComponent /&gt;</code>存储了一个<em class="mx">块</em>的数组，并且为这些块设置了一个setter。</p><p id="5e6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些块被包装在一个很重的包装里。我们没有把它们作为道具传递，而是把它们传递给<code class="fe mt mu mv mw b">BlockContext</code>的提供者，这样它们就可以在需要的地方被消耗掉。沉重的渲染包装，没有任何重新创建的道具，准备在<code class="fe mt mu mv mw b">memo()</code>中包装。</p><p id="8874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为状态设置器创建一个新的上下文，一个<code class="fe mt mu mv mw b">BlocksSetContext</code>。我们将setter传递给这个上下文的提供者，因此当需要时，它可以在较低的级别上被使用，独立于<em class="mx">块</em>的改变。</p><p id="f98d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后<code class="fe mt mu mv mw b">&lt;Blocks /&gt;</code>组件消耗<code class="fe mt mu mv mw b">BlockContext</code>。我们没有用<code class="fe mt mu mv mw b">memo()</code>包装它，因为它没有道具，而且<code class="fe mt mu mv mw b">blocks</code>值会经常改变。这意味着这种检查将是徒劳的，因为我们肯定知道无论什么时候<em class="mx">阻塞</em>变化，<code class="fe mt mu mv mw b">&lt;Blocks /&gt;</code>组件也是如此。</p><p id="1c11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而,<code class="fe mt mu mv mw b">&lt;BlockAdd /&gt;</code>组件将被包装在一个memo()中，因为它没有接收任何道具，而且很难呈现，因为用户正在那里搭建积木。它使用的<code class="fe mt mu mv mw b">BlocksSetContext</code>包含了状态设置器，它的引用在我们的渲染中不会改变。<br/>https://reactjs.org/docs/hooks-reference.html#usestate<a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dc75" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><ul class=""><li id="6530" class="ne nf iq ky b kz nx lc ny lf oq lj or ln os lr nj nk nl nm bi translated">将<code class="fe mt mu mv mw b">useCallback</code>用于<strong class="ky ir">功能</strong></li></ul><pre class="kg kh ki kj gt pe mw pf pg aw ph bi"><span id="7d4e" class="od ma iq mw b gy pi pj l pk pl">const handleClick = useCallback(() =&gt; {<br/>  console.log('Yay!')<br/>}, [])</span></pre><ul class=""><li id="31f2" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">使用<code class="fe mt mu mv mw b">useMemo</code>作为数值</li></ul><pre class="kg kh ki kj gt pe mw pf pg aw ph bi"><span id="5403" class="od ma iq mw b gy pi pj l pk pl">import { heavyFilteringFunction } from '../externalFile'</span><span id="f565" class="od ma iq mw b gy pm pj l pk pl">const filteredPosts = useMemo(() =&gt; {<br/>  return heavyFilteringFunction(posts, filter)<br/>}, [posts, filter])</span></pre><ul class=""><li id="42d2" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">将<code class="fe mt mu mv mw b">memo</code>用在重渲染或渲染次数过多的组件上，并且它们的道具是静态的或记忆的</li><li id="0e06" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">将一个<code class="fe mt mu mv mw b">console.log()</code>放入组件的主体中，看它何时重新呈现</li><li id="27a7" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">将组件分解成尽可能小的部分，确保它们不会继承它们不需要的道具</li><li id="658a" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">当您想要验证依赖关系何时改变时，创建一个包含控制台日志的<code class="fe mt mu mv mw b">useEffect</code></li></ul><pre class="kg kh ki kj gt pe mw pf pg aw ph bi"><span id="721c" class="od ma iq mw b gy pi pj l pk pl">useEffect(() =&gt; {<br/>  console.log('Blocks changed!')<br/>}, [blocks])</span><span id="9da1" class="od ma iq mw b gy pm pj l pk pl">useEffect(() =&gt; {<br/>  console.log('User changed!')<br/>}, [user])</span></pre><ul class=""><li id="7b05" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">如果有可能在组件之外定义一个方法(当它不直接依赖于组件的状态时)，这是确保它不会被重新创建的最简单的选择</li></ul><pre class="kg kh ki kj gt pe mw pf pg aw ph bi"><span id="4a55" class="od ma iq mw b gy pi pj l pk pl">const handleUsersFilter = (users, filter) =&gt; {<br/>  return ...<br/>}</span><span id="a67a" class="od ma iq mw b gy pm pj l pk pl">const Users = ({ filter }) =&gt; {<br/>  const [users, setUsers] = useState([...])</span><span id="0bd6" class="od ma iq mw b gy pm pj l pk pl">  // it only makes sense that when users or filter change,<br/>  // we want to re-compute the value</span><span id="751f" class="od ma iq mw b gy pm pj l pk pl">  const filteredUsers = useMemo(() =&gt; {<br/>    return handleUsersFilter(users, filter)<br/>  }, [users, filter])</span><span id="814a" class="od ma iq mw b gy pm pj l pk pl">  return (&lt;div /&gt;)<br/>}</span></pre><ul class=""><li id="6a67" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">如果你的组件渲染很重，并且它的道具改变了，你仍然可以将组件分割成多个部分，并且<code class="fe mt mu mv mw b">memo()</code>继承非重新创建道具的部分</li><li id="6ae0" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">如果你通过props或Context提供了一个非原语数据实例(一个数组，一个对象，一个函数)，把它包装在一个<code class="fe mt mu mv mw b">useCallback</code>或<code class="fe mt mu mv mw b">useMemo</code>中(除非它一直在变化:)</li><li id="69bc" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">为单独的逻辑片段创建单独的上下文</li><li id="cbcb" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">为<code class="fe mt mu mv mw b">useCallback</code>、<code class="fe mt mu mv mw b">useMemo</code>和<code class="fe mt mu mv mw b">useEffect</code>提供非原语依赖时要小心——它们也必须被记忆，这就是为什么在应用程序早期开始是好的</li><li id="b281" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">不要害怕使用依赖数组。如果您的实现在架构上是正确的，那么重新创建/重新执行是有意义的。</li></ul><pre class="kg kh ki kj gt pe mw pf pg aw ph bi"><span id="62db" class="od ma iq mw b gy pi pj l pk pl">import { apiCallUser } from './api'</span><span id="8ae4" class="od ma iq mw b gy pm pj l pk pl">const UserView = ({ userId }) =&gt; {<br/>  const [user, setUser] = useState(null)</span><span id="1cc7" class="od ma iq mw b gy pm pj l pk pl">  // when the userId changes, we will re-create the function</span><span id="edc3" class="od ma iq mw b gy pm pj l pk pl">  const handleUserFetch = useCallback(async () =&gt; {<br/>    const result = await apiCallUser(userId)<br/>    setUser(result)<br/>  }, [userId])</span><span id="69c9" class="od ma iq mw b gy pm pj l pk pl"><br/>  // when the dependency re-creates, we will execute the body again</span><span id="e89a" class="od ma iq mw b gy pm pj l pk pl">  useEffect(() =&gt; {<br/>    handleUserFetch()<br/>  }, [handleUserFetch])<br/>}</span></pre><ul class=""><li id="6ffc" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">React中没有过早优化这回事。当你的用户抱怨的时候，已经太晚了。</li><li id="efe5" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">优化的时候，从顶层开始。未优化的组件越高，渲染瀑布的指数越大。</li><li id="940c" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">没有一个用例需要在你的<code class="fe mt mu mv mw b">useEffect</code>或<code class="fe mt mu mv mw b">useCallback</code>中写<br/> <code class="fe mt mu mv mw b">// eslint-disable-next-line react-hooks/exhaustive-deps</code> <br/></li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="dde4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还没有筋疲力尽，并好奇为什么你不应该注释掉依赖？从比我聪明的人那里看看吧；</p><div class="pu pv gp gr pw px"><a href="https://github.com/facebook/create-react-app/issues/6880" rel="noopener  ugc nofollow" target="_blank"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd ir gy z fp qc fr fs qd fu fw ip bi translated">如何禁用react-hooks/exhaustive-deps规则？问题#6880 facebook/create-react-app</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">github.com</p></div></div><div class="qg l"><div class="qh l qi qj qk qg ql kp px"/></div></div></a></div></div></div>    
</body>
</html>