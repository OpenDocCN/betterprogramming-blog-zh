<html>
<head>
<title>8 Basic and Advanced React Router Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">8个基本和高级React路由器提示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-basic-and-advanced-react-router-tips-6993ece8f57a?source=collection_archive---------0-----------------------#2021-06-17">https://betterprogramming.pub/8-basic-and-advanced-react-router-tips-6993ece8f57a?source=collection_archive---------0-----------------------#2021-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd4f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">路由、404、链接、重定向、异步加载等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5bfa92e7a88eb52a9c3b4e571be2040e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtGY0CMgl2YEqCPkWvfHPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="7013" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多人认为React是构建web应用程序的最佳JavaScript框架。你需要掌握的基础知识之一是反应路由。</p><p id="c0f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank"> React Router </a>允许您的web应用程序被组织成不同URL上的页面，就像您习惯于互联网上的任何其他页面一样。因为React只是一个很大的JavaScript脚本，所以当用户单击一个链接时，所有页面都会立即加载并显示出来。</p><p id="91f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将介绍基础知识以及一些高级技巧，包括404页面、重定向、异步页面和站点地图。我用这些技术建立了我所有的网站，包括<a class="ae lu" href="https://www.7urtle.com/" rel="noopener ugc nofollow" target="_blank"> 7urtle </a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="86c2" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">React路由器简介</h1><p id="d026" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">React routes使用包<code class="fe nb nc nd ne b">react-router-dom</code>，所以从安装它开始:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="d723" class="nj mf it ne b gy nk nl l nm nn">npm i -D react-router-dom</span></pre><p id="8db1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我更喜欢函数式编程，所以我也在使用我的来自7urtle的@7urtle/lambda库，让我的代码更优雅。您可以重写这些示例，或者使用以下代码安装该库:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c7a4" class="nj mf it ne b gy nk nl l nm nn">npm i -D @7urtle/lambda</span></pre><p id="48dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我只会在这里用几次图书馆，所以不用担心。</p><p id="5872" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后在你的<code class="fe nb nc nd ne b">index.js</code>旁边创建<code class="fe nb nc nd ne b">Routes.js</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/20341138a0ff066d18291341c5f21c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*ibQNUEtfpQ9z3qocC4cvdw.png"/></div></figure><p id="b6f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个文件将保存您的<code class="fe nb nc nd ne b">Route</code>配置。包含两页的路由如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="847d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">配置是通过<code class="fe nb nc nd ne b">Switch</code>父标签下的<code class="fe nb nc nd ne b">children</code>标签完成的。</p><p id="0888" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">Route</code>标签包含您的所有路线:</p><ul class=""><li id="a059" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><code class="fe nb nc nd ne b">exact</code>参数确保只使用精确匹配。</li><li id="8988" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe nb nc nd ne b">path</code>参数包含页面的地址。</li><li id="53d0" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">然后<code class="fe nb nc nd ne b">component</code>保存React页面本身。</li></ul><p id="517d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个404页面，只需定义<code class="fe nb nc nd ne b">Route</code>而不需要任何将所有剩余请求发送到那里的路径。路由器从顶部开始依次检查所有路由，并使用找到的第一个匹配项。这意味着您的404需要在所有其他路由和重定向之后出现。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="b5ee" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">App.js中的React路由器</h1><p id="9435" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">然后必须在您的<code class="fe nb nc nd ne b">App.js</code>中使用<code class="fe nb nc nd ne b">Router</code>组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="7f28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<code class="fe nb nc nd ne b">Router</code>部分使用了我们在之前的文件中定义的<code class="fe nb nc nd ne b">Routes</code>。这就是路由发生的方式。</p><p id="bc5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">Routes</code>将只影响<code class="fe nb nc nd ne b">Routes</code>标签的区域。T2和周围的任何其他JSX都没有受到影响。这样，您可以在路由器上独立定义保持不变的菜单或页眉和页脚。</p><h2 id="dc19" class="nj mf it bd mg oe of dn mk og oh dp mo lh oi oj mq ll ok ol ms lp om on mu oo bi translated">路由器基本名称</h2><blockquote class="op oq or"><p id="aa85" class="ky kz os la b lb lc ju ld le lf jx lg ot li lj lk ou lm ln lo ov lq lr ls lt im bi translated">"所有位置的基本URL。如果您的应用程序是由服务器上的子目录提供的，您需要将其设置为该子目录。格式正确的basename应该有一个前导斜杠，但没有尾随斜杠。— <a class="ae lu" href="https://reactrouter.com/web/api/BrowserRouter" rel="noopener ugc nofollow" target="_blank">反应路由器的文件</a></p></blockquote><p id="f2c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我的React应用程序可以从某个子目录中使用时，我总是将这段代码与<code class="fe nb nc nd ne b">getBasename</code>函数一起使用。这将很好地定义正确的基本名。但是，如果您想要依赖于使用子目录路径的一些更复杂的路由，您可能想要进一步编辑它。</p><p id="046c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在你的情况下，你可能根本不需要这个。干脆删了，看看东西还能用吗。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f87c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">反应路由器页面</h1><p id="e61a" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">您可以像定义任何其他组件一样定义页面，因为它只不过是另一个组件。唯一的区别是React Router基于URL管理<code class="fe nb nc nd ne b">Route</code>组件的可见性。这是一个页面示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="b6d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样的，你可以定义任何其他的页面或者你的404页面。</p><p id="31e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">页面根据<code class="fe nb nc nd ne b">Routes.js</code>中使用的路径显示，页面组件代替<code class="fe nb nc nd ne b">App.js</code>中的<code class="fe nb nc nd ne b">Routes</code>组件显示。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="75a6" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">滚动长页面</h1><p id="430f" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">你会发现的一个挑战是，如果你滚动一个页面并重新打开它，用户将返回到滚动的位置，而不是顶部。如果您想确保页面在打开时总是滚动到顶部，只需创建一个父<code class="fe nb nc nd ne b">Page</code>组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="32e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们简单地使用React的<code class="fe nb nc nd ne b">useEffect</code>来触发即时滚动到顶部。</p><p id="7d5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以使用它来实现应该在每个页面上发生的任何其他行为，或者添加任何标签来装饰页面(如本例中的<code class="fe nb nc nd ne b">main</code>标签)。</p><p id="2f22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后通过添加标签作为父标签，在所有需要的页面中使用这个<code class="fe nb nc nd ne b">Page</code>,就像这个404页面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="5264" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">对页面的路由器链接做出反应</h1><p id="41d2" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">使用<code class="fe nb nc nd ne b">Link</code>组件链接到组件页面很简单。我们可以从404页面添加一个返回主页的链接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="1e3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">Link</code>标签非常简单，只需要与您从<code class="fe nb nc nd ne b">Routes.js</code>开始的路线相匹配的<code class="fe nb nc nd ne b">to</code>参数。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="acf3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">React路由器重定向路由</h1><p id="aaf4" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">您可能希望在您的应用程序中定义一些标准重定向，例如，总是将根路径<code class="fe nb nc nd ne b">/</code>重定向到您的登录页面<code class="fe nb nc nd ne b">/login</code>。您可以通过在您的<code class="fe nb nc nd ne b">Routes.js</code>中添加一个<code class="fe nb nc nd ne b">Redirect</code>组件来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="3ab2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nb nc nd ne b">Redirect</code>标签中，参数<code class="fe nb nc nd ne b">from</code>和<code class="fe nb nc nd ne b">to</code>都是路径。确保你的重定向定义高于你的404路由。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1285" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">React路由器重定向自代码</h1><p id="88b8" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">您可能还希望以编程方式从您的代码重定向到某个页面。您可以通过在组件中使用<code class="fe nb nc nd ne b">useHistory</code>来做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="f0ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们使用<code class="fe nb nc nd ne b">useEffect</code>来观察身份验证状态的变化，如果用户通过了身份验证，页面就会触发到<code class="fe nb nc nd ne b">/sub-page</code>的重定向。您的路径应该再次与您在<code class="fe nb nc nd ne b">Routes.js</code>中的路径相匹配。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="decc" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">React路由异步页面加载</h1><p id="6fe0" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">React只是一个很大的JavaScript脚本，所以所有页面总是加载您的第一页请求，然后链接立即工作，而不是对每个页面发出服务器请求。</p><p id="82f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果想让初始请求更小更快，可以异步加载一些页面。我在@7urtle/lambda上的<a class="ae lu" href="https://www.7urtle.com/javascript-functional-programming-advantages" rel="noopener ugc nofollow" target="_blank">学习页面</a>中使用了这种技术。你可以在那里测试一下，它还是相当快的。当然，页面只加载一次，所以所有后续访问都是即时的。</p><p id="cd09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将需要一个名为<code class="fe nb nc nd ne b">react-loadable</code>的新包:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="be52" class="nj mf it ne b gy nk nl l nm nn">npm i -D react-loadable</span></pre><p id="7963" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使页面异步加载，请将此定义添加到<code class="fe nb nc nd ne b">Routes.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="08d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意常量<code class="fe nb nc nd ne b">AsyncPages</code>，我用<code class="fe nb nc nd ne b">loadable</code>函数在这里放置了<code class="fe nb nc nd ne b">myAsyncSubPage</code>定义。</p><p id="b241" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我在<code class="fe nb nc nd ne b">Route</code>标签中以常规方式调用它。没有变化。</p><p id="4003" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还需要定义的一件事是在系统从您的服务器加载页面时显示加载信息的<code class="fe nb nc nd ne b">LoadingPage</code>组件。您可以像这样创建它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="4410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这再简单不过了。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="4c4e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">React路由器站点地图</h1><p id="9b1b" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我建议为你的网站维护一个站点地图。这对搜索引擎有好处，因为谷歌现在可以抓取React页面，而且它还可以帮助你管理你的网站。</p><p id="f992" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我所做的是在<code class="fe nb nc nd ne b">Routes.js</code>中定义一个<code class="fe nb nc nd ne b">SiteMap</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="e9a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到，它定义了链接所需的所有信息，并使用了<code class="fe nb nc nd ne b">Route</code>组件中的路径。</p><p id="31fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我在自己的<code class="fe nb nc nd ne b">Link7urtle</code>组件中利用<code class="fe nb nc nd ne b">SiteMap</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="96e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您自己的组件中，<code class="fe nb nc nd ne b">Link7urtle</code>只是用作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="99a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以看到我们简单地将<code class="fe nb nc nd ne b">SiteMap.HomePage</code>传递给<code class="fe nb nc nd ne b">Link7urtle</code>，一切都自动发生(或者我们也可以手动定义任何参数)。</p><p id="585c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的网站也要维护<code class="fe nb nc nd ne b">sitemap.xml</code>和<code class="fe nb nc nd ne b">robots.txt</code>。我手动维护这些，并确保它们与我的<code class="fe nb nc nd ne b">Routes.js</code>对齐。这是我的<code class="fe nb nc nd ne b">sitemap.xml</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="3335" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，您总是需要使用完整的URL，包括正确的协议。</p><p id="86cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我的<code class="fe nb nc nd ne b">robots.txt</code>就这样链接到它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="c50a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe nb nc nd ne b">Sitemap</code>，再次使用完整的URL。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="ad78" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">使用Netlify、AWS和其他服务对路由做出反应</h1><p id="dd44" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">这就是React Router本身，但是当您将新应用程序部署到生产环境中时，您可能很快就会发现，简单地调用应用程序的任何子页都可能不起作用。</p><p id="ffa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您从根目录开始时，路由将始终工作，因为路由器不调用您的服务器来导航，而是使用浏览器历史功能。所以对于大多数提供商来说，如果你调用你网站的任何URL，它都会失败。</p><p id="dd16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常的解决方案是确保所有的服务器请求总是被传递给索引。这个问题的解决方案总是取决于您正在使用的特定服务。</p><h2 id="d1e7" class="nj mf it bd mg oe of dn mk og oh dp mo lh oi oj mq ll ok ol ms lp om on mu oo bi translated">反应路由器与网络效率</h2><p id="a2fb" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">例如，如果您在Netlify上将React应用程序部署为无服务器，您需要在应用程序的根目录下添加一个<code class="fe nb nc nd ne b">_redirects</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np lw l"/></div></figure><p id="e6fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在一切都应该按照你期望的方式工作，你的路线将得到充分的支持。</p><h2 id="0a03" class="nj mf it bd mg oe of dn mk og oh dp mo lh oi oj mq ll ok ol ms lp om on mu oo bi translated">S3亚马逊网络服务反应路由器</h2><p id="c02a" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">如果你想通过S3使用亚马逊网络服务进行无服务器交付，也会出现同样的情况。我正在使用堆栈溢出的解决方案。</p><p id="b114" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以将<code class="fe nb nc nd ne b">index.html</code>放入错误文件框。去你的桶(实际有代码的那个——不是你用来重定向的那个)- &gt;属性- &gt;静态网站托管。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/4c574878f7d0b5a9285f1059801394b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8QdHVj3O3Y8vpNqC.png"/></div></div></figure><h2 id="d759" class="nj mf it bd mg oe of dn mk og oh dp mo lh oi oj mq ll ok ol ms lp om on mu oo bi translated">亚马逊网络服务CloudFront的React路由器</h2><p id="49b1" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">如果你正在使用Amazon Web Services CloudFront，请遵循Stack Overflow的建议。</p><p id="ea1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在CloudFront发行版中创建一个<a class="ae lu" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html" rel="noopener ugc nofollow" target="_blank">自定义错误页面(AWS Docs) </a>，将404错误路由到<code class="fe nb nc nd ne b">index.html</code>，并返回一个200响应代码。这样，您的应用程序将处理路由。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/5f3475d8ac0644d6df66bdce1f8d5446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fbei-yjrqVHuwx9j.png"/></div></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="a4dc" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="6c9d" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">React路由器非常强大，我在React内置的所有web应用程序中都使用了它。在这篇文章中，我透露了我在<a class="ae lu" href="http://www.7urtle.com" rel="noopener ugc nofollow" target="_blank"> 7urtle </a>上使用的设置的所有秘密。你可以看到它实时工作，包括一些异步加载。</p><p id="884d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你最终使用了我的解决方案，请让我知道，如果你成功了，或者如果你有任何问题需要帮助，请在评论中发表。</p><p id="d7df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看我的<a class="ae lu" href="https://www.meet-martin.com" rel="noopener ugc nofollow" target="_blank">网站</a>了解更多详情。</p></div></div>    
</body>
</html>