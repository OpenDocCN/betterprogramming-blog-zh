<html>
<head>
<title>Solidity 0.6.x Features: The Try/Catch Statement</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity 0.6.x特性:Try/Catch语句</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-0-6-x-features-try-catch-statement-8c4c1bb73309?source=collection_archive---------14-----------------------#2020-04-15">https://betterprogramming.pub/solidity-0-6-x-features-try-catch-statement-8c4c1bb73309?source=collection_archive---------14-----------------------#2020-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ae43" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最初发表于<a class="ae kf" href="https://solidity.ethereum.org/2020/01/29/solidity-0.6-try-catch/" rel="noopener ugc nofollow" target="_blank"> Solidity以太坊基金会博客</a></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/28d1dcb3760316cabad7e1844907a2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kewaJNAYCJSAfVMLsf-63A.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">吉姆·威尔逊在<a class="ae kf" href="https://unsplash.com/s/photos/require?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ea56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">0.6.0 中引入的<a class="ae kf" href="https://solidity.readthedocs.io/en/latest/control-structures.html#try-catch" rel="noopener ugc nofollow" target="_blank"> try/catch语法可以说是自v0.4.22中发布<code class="fe ls lt lu lv b">revert</code>和<code class="fe ls lt lu lv b">require</code>的原因字符串以来，错误处理能力在可靠性方面的最大飞跃。从v0.5.9 </a>开始，<code class="fe ls lt lu lv b">try</code>和<code class="fe ls lt lu lv b">catch</code>都是保留关键字<a class="ae kf" href="https://solidity.readthedocs.io/en/v0.5.9/miscellaneous.html#reserved-keywords" rel="noopener ugc nofollow" target="_blank">，现在我们可以使用它们来处理<code class="fe ls lt lu lv b">external</code>函数调用中的失败，而无需回滚整个事务(被调用函数中的状态更改仍会回滚，但调用函数中的不会)。</a></p><p id="f13f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在远离事务生命周期中最纯粹的要么全有要么全无的方法，这不符合我们经常想要的实际行为。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="75eb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">处理外部呼叫失败</h1><p id="847e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">try/catch语句允许您对失败的<em class="na">外部</em>调用和<em class="na">契约创建</em>调用做出反应，因此您不能将其用于<em class="na">内部</em>函数调用。注意，要用try/catch在同一个契约中包装一个公共函数调用，可以通过用<code class="fe ls lt lu lv b">this</code>调用函数在外部进行。</p><p id="67f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例演示了在协定创建可能失败的工厂模式中如何使用try/catch。下面的<code class="fe ls lt lu lv b">CharitySplitter</code>契约在其构造函数中需要一个强制的地址属性<code class="fe ls lt lu lv b">_owner</code>。</p><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="b1ef" class="nf me iq lv b gy ng nh l ni nj">pragma solidity ^0.6.1;</span><span id="34c7" class="nf me iq lv b gy nk nh l ni nj">contract CharitySplitter {<br/>    address public owner;<br/>    constructor (address _owner) public {<br/>        require(_owner != address(0), "no-owner-provided");<br/>        owner = _owner;<br/>    }<br/>}</span></pre><p id="33ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个工厂契约——<code class="fe ls lt lu lv b">CharitySplitterFactory </code>——用于创建和管理<code class="fe ls lt lu lv b">CharitySplitter</code>的实例。在工厂中，我们可以将<code class="fe ls lt lu lv b">new CharitySplitter(charityOwner)</code>包装在一个try/catch中，作为当构造函数可能因为传递一个空的<code class="fe ls lt lu lv b">charityOwner</code>而失败时的安全措施。</p><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="259f" class="nf me iq lv b gy ng nh l ni nj">pragma solidity ^0.6.1;<br/>import "./CharitySplitter.sol";<br/>contract CharitySplitterFactory {<br/>    mapping (address =&gt; CharitySplitter) public charitySplitters;<br/>    uint public errorCount;<br/>    event ErrorHandled(string reason);<br/>    event ErrorNotHandled(bytes reason);<br/>    function createCharitySplitter(address charityOwner) public {<br/>        try new CharitySplitter(charityOwner)<br/>            returns (CharitySplitter newCharitySplitter) <br/>        {<br/>            charitySplitters[msg.sender] = newCharitySplitter;<br/>        } catch {<br/>            errorCount++;<br/>        }<br/>    }<br/>}</span></pre><p id="cc1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，使用try/catch，只捕获外部调用本身内部发生的异常。表达式内部的错误不会被捕获——例如，如果<code class="fe ls lt lu lv b">new CharitySplitter</code>的输入参数本身是内部调用的一部分，它引发的任何错误都不会被捕获。</p><p id="fa98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">证明这种行为的一个例子是修改过的<code class="fe ls lt lu lv b">createCharitySplitter</code>函数。这里，<code class="fe ls lt lu lv b">CharitySplitter</code>构造函数的输入参数是从另一个函数<code class="fe ls lt lu lv b">getCharityOwner</code>中动态获取的。如果这个函数恢复，在这个例子中是用<code class="fe ls lt lu lv b">"revert-required-for-testing"</code>，那么try/catch语句不会捕捉到它。</p><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="3161" class="nf me iq lv b gy ng nh l ni nj">function createCharitySplitter(address _charityOwner) public {<br/>    try new CharitySplitter(getCharityOwner(_charityOwner, false))<br/>        returns (CharitySplitter newCharitySplitter)<br/>    {<br/>        charitySplitters[msg.sender] = newCharitySplitter;<br/>    } catch (bytes memory reason) {<br/>        ...<br/>    }<br/>}<br/>function getCharityOwner(address _charityOwner, bool _toPass)<br/>        internal returns (address) {<br/>    require(_toPass, "revert-required-for-testing");<br/>    return _charityOwner;<br/>}</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="5747" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">正在检索错误消息</h1><p id="c9af" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们可以进一步扩展<code class="fe ls lt lu lv b">createCharitySplitter</code>函数中的try/catch逻辑，以便在失败的<code class="fe ls lt lu lv b">revert</code>或<code class="fe ls lt lu lv b">require</code>发出错误消息时检索错误消息，并在事件中发出错误消息。有两种方法可以实现这一点:</p><h2 id="f394" class="nf me iq bd mf nl nm dn mj nn no dp mn lf np nq mp lj nr ns mr ln nt nu mt nv bi translated">1.使用'<code class="fe ls lt lu lv b">catch Error(string memory reason)'</code></h2><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="1101" class="nf me iq lv b gy ng nh l ni nj">function createCharitySplitter(address _charityOwner) public {<br/>    try new CharitySplitter(_charityOwner) returns (CharitySplitter newCharitySplitter) <br/>    { <br/>        charitySplitters[msg.sender] = newCharitySplitter;<br/>    }<br/>    catch Error(string memory reason) <br/>    {<br/>        errorCount++;<br/>        CharitySplitter newCharitySplitter = new<br/>            CharitySplitter(msg.sender);<br/>        charitySplitters[msg.sender] = newCharitySplitter;<br/>        // Emitting the error in event<br/>        emit ErrorHandled(reason);<br/>    }<br/>    catch <br/>    {<br/>        errorCount++;<br/>    }<br/>}</span></pre><p id="5f3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在失败的构造函数要求错误上发出以下事件:</p><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="3b05" class="nf me iq lv b gy ng nh l ni nj">CharitySplitterFactory.ErrorHandled(<br/>    reason: 'no-owner-provided' (type: string)<br/>)</span></pre><h2 id="b0f2" class="nf me iq bd mf nl nm dn mj nn no dp mn lf np nq mp lj nr ns mr ln nt nu mt nv bi translated">2.使用'<code class="fe ls lt lu lv b">catch (bytes memory reason)'</code></h2><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="dd6a" class="nf me iq lv b gy ng nh l ni nj">function createCharitySplitter(address charityOwner) public {<br/>    try new CharitySplitter(charityOwner)<br/>        returns (CharitySplitter newCharitySplitter) <br/>    {<br/>        charitySplitters[msg.sender] = newCharitySplitter;<br/>    } <br/>    catch (bytes memory reason) {<br/>        errorCount++;<br/>        emit ErrorNotHandled(reason);<br/>    }<br/>}</span></pre><p id="e3c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在失败的构造函数要求错误上发出以下事件:</p><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="a5c9" class="nf me iq lv b gy ng nh l ni nj">CharitySplitterFactory.ErrorNotHandled(<br/>  reason: hex'08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000116e6f2d6f776e65722d70726f7669646564000000000000000000000000000000' (type: bytes)</span></pre><p id="b491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述两种检索错误字符串的方法产生了类似的结果。不同之处在于，第二种方法不对错误字符串进行ABI解码。第二种方法的优点是，如果ABI解码错误字符串失败或者没有提供原因，也会执行第二种方法。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="fd60" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">未来计划</h1><p id="b542" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们计划发布对错误类型的支持，这意味着我们将能够以类似于事件的方式声明错误，从而允许我们捕捉不同类型的错误，例如:</p><pre class="kh ki kj kk gt nb lv nc nd aw ne bi"><span id="338b" class="nf me iq lv b gy ng nh l ni nj">catch CustomErrorA(uint data1) { … }<br/>catch CustomErrorB(uint[] memory data2) { … }<br/>catch {}</span></pre></div></div>    
</body>
</html>