<html>
<head>
<title>Server-Side Rendering: How Resumable Beats Hydration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端渲染:可恢复性如何战胜水合作用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-resumable-beats-hydration-f845bfebc31e?source=collection_archive---------3-----------------------#2022-12-26">https://betterprogramming.pub/how-resumable-beats-hydration-f845bfebc31e?source=collection_archive---------3-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b5d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可恢复性vs水合作用——一场不公平的战争？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7de2dd8b9ef28030eb668ec3e0e56440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4lvWPYrF2Uc2hhZpM7tqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e4ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在服务器端呈现中，服务器根据用户的请求和呈现页面所需的任何数据，动态生成网页的HTML。然后，这个HTML被传送到客户端的web浏览器，它会像使用传统的客户端呈现方法一样呈现页面。</p><p id="7e44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只是第一步。服务器呈现的页面需要具有交互性。水合作用是恢复互动性的唯一方法。经过多年的改进，现在我们有一些不同的水合技术可以使用。</p><p id="ee6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，我们看到一个概念被应用到SSR:可持续性。长期以来，它一直用于操作系统级别的长期运行任务，甚至用于下载。但是，它如何应用于SSR呢？它的优点是什么？怎么能开始玩呢？</p><p id="35bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将检查什么是最新的SSR水合技术，它们与is相比如何，以及SSR可恢复技术如何。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b7be" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">SSR现代掺水技术</h1><p id="2492" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">SSR水合技术不是银弹。尽管它通过发布服务器渲染的HTML提升了<code class="fe my mz na nb b">First Contentful Paint</code>和<code class="fe my mz na nb b">Largest Contentful Paint</code>指标，但它仍然需要下载、解析和执行大量的JavaScript。</p><p id="f1f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这对<code class="fe my mz na nb b">Time To Interactive</code>指标产生了影响。当页面对点击没有反应时，它变得令人沮丧。补水怎么对抗？有各种各样的:</p><h2 id="2f2f" class="nc mc it bd md nd ne dn mh nf ng dp ml lh nh ni mn ll nj nk mp lp nl nm mr nn bi translated">1.选择性水合</h2><p id="9688" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这是<code class="fe my mz na nb b">React 18</code>通过选择性水合功能解决的问题之一。现在HTML可以流式传输，而不仅仅是转储<code class="fe my mz na nb b">renderToString</code>方法的结果。怎么会？通过使用以下新API:</p><pre class="kj kk kl km gt no nb np bn nq nr bi"><span id="9f8e" class="ns mc it nb b be nt nu l nv nw">// opting to streaming HTML<br/>import { pipeToNodeWritable } from ‘react’;</span></pre><p id="5146" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">组件可以在服务器端使用<code class="fe my mz na nb b">lazy-loaded</code>，并通过使用它们的<code class="fe my mz na nb b">Suspense</code>特性来发布最少的JavaScript。</p><p id="b025" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，当用户与非水合组分交互时，它将被优先化。多亏了并发模式，这一切才成为可能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/1f24d185ea2d98072726f6bc3cb1692e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oPg_kUGK_k5qXAwQStRZiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的完全水合与选择性水合方案</p></figure><h2 id="1928" class="nc mc it bd md nd ne dn mh nf ng dp ml lh nh ni mn ll nj nk mp lp nl nm mr nn bi translated">2.部分水合</h2><p id="2bda" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这是一个概念，其中并不是所有的成分总是水合的。有些成分可能对补水没有任何好处，那么为什么要这样做呢？这与杰森·米勒的想法<code class="fe my mz na nb b">Island Architecture</code>产生了共鸣。它在很大程度上是由<code class="fe my mz na nb b">Astro</code>元框架实现的。</p><p id="37f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe my mz na nb b">React Server Components</code>是<code class="fe my mz na nb b">React</code>团队对此事的看法。这些组件将运送任何JavaScript代码，甚至被水合，除非在那里呈现一个<code class="fe my mz na nb b">Client Component</code>。只有在这种情况下，才会发布一些JavaScript。像<code class="fe my mz na nb b">NextJs</code>或<code class="fe my mz na nb b">Gatsby</code>这样的框架在这个特性上投入了大量资金。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/e60d5e9778f48722f2269c14a6c6479a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfB_glKkemcGxZ0I-5_sFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的完全水合与部分水合方案</p></figure><h2 id="7f87" class="nc mc it bd md nd ne dn mh nf ng dp ml lh nh ni mn ll nj nk mp lp nl nm mr nn bi translated">3.渐进水合</h2><p id="cebc" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当构建web应用程序时，我们总是能够区分关键组件和不太重要的组件。我们可以有条件地呈现那些我们发现能带来更多价值的。这个概念是在Google I/O 2019上推出的。</p><p id="cf7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以延迟视口之外的组件的执行。很像<code class="fe my mz na nb b">lazy-loading</code>本地支持的浏览器技术。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f34a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">如何恢复击败他们所有人</h1><p id="93d7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这些年来，水合过程已经用上面提到的技术进行了改进。然而，它的缺点总是一样的:仅仅是重新呈现已经在服务器上构建的树就需要大量的JavaScript。如何才能摆脱这种多余的瓶颈？</p><p id="c25d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe my mz na nb b">Resumable</code>概念似乎是完美的解决方案。它减少了对水合作用的需求，因此浏览器不需要下载大量的JavaScript。这怎么可能？产生的SSR HTML包含必要信息的序列化，以立即恢复其在浏览器上的执行。很可爱，不是吗？</p><p id="7812" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看下面的图表，它展示了浏览器需要做的工作是多么少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cf9d7f31e0f69dc2fb90398bab45ef67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R1OPMed-9JHEytEm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自qwik.builder.io的水合作用与可恢复性说明</p></figure><p id="59bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe my mz na nb b">Resumable</code>概念的主要玩家是<code class="fe my mz na nb b">Qwik</code>。它如何序列化整个应用服务器端的执行？通过解决四个主要问题:</p><ul class=""><li id="ffba" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated"><strong class="la iu"> Listeners: </strong>它将延迟加载的事件监听器序列化并生成到DOM中。每个处理程序都被序列化到自己的块中。<code class="fe my mz na nb b">Qwikloader</code>设置一个全局事件监听器来按需下载每个块。<br/>它负责函数闭包、DOM引用、承诺、映射、集合和URL对象序列化。开发人员需要记住一些限制，比如流的序列化。</li></ul><pre class="kj kk kl km gt no nb np bn nq nr bi"><span id="2d2b" class="ns mc it nb b be nt nu l nv nw">&lt;button on:click="./chunk.js#handler_symbol"&gt;click me&lt;/button&gt;</span></pre><ul class=""><li id="a0c5" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated"><strong class="la iu">组件树:</strong>在SSR/SSG时间，Qwik收集并序列化关于组件和商店以及订阅的关系的信息。这将使它能够在需要时更新/重新呈现相关组件。因为所有的成分边界现在都被传输，所以不需要任何水合过程。这是如何实现的？大多通过HTML <code class="fe my mz na nb b">&lt;!-- comments --&gt;</code></li><li id="9bb4" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated"><strong class="la iu">应用状态:</strong> Qwik提供了一个状态管理实现。应用程序状态将与HTML响应一起序列化为类型为<code class="fe my mz na nb b">qwik/json</code>的<code class="fe my mz na nb b">&lt;script /&gt;</code>。</li><li id="a160" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated"><strong class="la iu">特定于客户端的代码:</strong>既然没有水化，那么特定于客户端的代码什么时候运行？有一个<code class="fe my mz na nb b">useClientEffect$</code>抽象。这将在组件可见时运行JavaScript回调。</li></ul><p id="0d80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，<code class="fe my mz na nb b">Qwik</code>的主要优势在于它能够序列化服务器上的执行，因此可以在客户机上继续执行。然后，它能够通过只下载相关的JavaScript逐步使应用程序具有交互性。最初，在客户端，我们只需要内联的<code class="fe my mz na nb b">QwikLoader</code>的代码，权重在<code class="fe my mz na nb b">1kb</code>左右。</p><p id="d190" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论应用程序有多复杂，这都将使初始应用程序的执行速度快如闪电。这就是为什么它被称为第一个<code class="fe my mz na nb b">O(1)</code>页面加载时间框架的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/d4ef07d4ea5c4c5f27a736b6f702ee19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JE3mJXd34Mid3HmJozLLyw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的Qwik执行模式</p></figure><p id="f042" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">交付更少的JavaScript代码不仅更好，因为我们使用的带宽更少。这也意味着我们需要更少的耗电客户端，因为需要解析和执行的代码会更少。我们也不会在客户可能需要的代码上浪费CPU周期。细粒度的延迟加载意味着我们将只执行客户端需要的JavaScript代码。</p><p id="babf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也意味着应用程序将变得越来越具有交互性。随着用户与应用程序的交互越来越多，将会下载更多的代码。</p><p id="cb32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">团队的实现令人着迷，并将改变我们编写web应用程序的方式。然而，这并不是免费的。我们将不得不转向更加以中心为中心的方法。我们也将被锁定在一个供应商，不得不使用他们的状态和路由方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4937" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">包裹</h1><p id="89c5" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">事实证明，速度是设计网站时的一个关键因素。时间就是金钱。有一些指标显示了页面加载时很少的<code class="fe my mz na nb b">100ms</code>增量对客户转化的影响。</p><p id="1f02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">减少JavaScript代码似乎是最有效的技术。最新的水合技术已经考虑到了这个目标。我们还在一些最流行的元框架上看到了JavaScript减少的趋势，比如<code class="fe my mz na nb b">NextJs</code>。</p><p id="ae0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种可恢复的战略似乎已经落地并持续下去。当我们看到它如何成熟时，我们肯定会看到它的采用率如何飙升。这只是开始。有更多的优化可以与它结合，作为慢速网络的预取。</p><p id="1a45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，Qwik几乎还没有达到Beta里程碑。然而，由于预计只有少数突破性的变化，因此值得考虑将其用于生产。</p></div></div>    
</body>
</html>