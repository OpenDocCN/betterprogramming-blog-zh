<html>
<head>
<title>Learn to Build CLI Automation Tools With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习使用Node.js构建CLI自动化工具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-to-build-cli-automation-tools-with-node-js-fcca4c0418cb?source=collection_archive---------9-----------------------#2020-09-09">https://betterprogramming.pub/learn-to-build-cli-automation-tools-with-node-js-fcca4c0418cb?source=collection_archive---------9-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa6f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在节点中使用oclif构建一个重量跟踪CLI工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/191d29ea5e3786a0ac6af3619cfe91ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJoXSpRBqw-FBVlrbnL6rg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@morningbrew?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">晨酿</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="4e76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员喜欢CLI工具！以至于我确信我们会欣然接受这个机会，在一台舒适的命令行电脑上做任何事情。为什么不这样做呢？在现代库和框架的帮助下，构建我们自己的CLI只需几个小时甚至几分钟。尤其是在Node中，您可以使用<a class="ae ky" href="https://oclif.io/" rel="noopener ugc nofollow" target="_blank"> oclif </a>框架轻松构建令人兴奋的命令行界面。</p><p id="1b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将创建一个简单的CLI工具来帮助我们跟踪体重随时间的变化。它具有简单的功能，如添加新的体重记录和显示过去的记录。</p><p id="a7e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们使用oclif来轻松完成这个任务，那么让我们试着去理解它到底是什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="edda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Oclif是什么？</h1><p id="fdcc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Oclif是一个用于在Node中创建CLI工具的框架。它支持JavaScript和TypeScript实现。Oclif提供了一组丰富的特性来设计和实现命令行程序，这些程序很容易用插件和钩子来扩展。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d589" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单命令与多命令</h1><p id="010f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以在Oclif中创建两种类型的命令行工具:单命令和多命令。单命令CLI只提供一个命令选项(类似于Linux中的<code class="fe mz na nb nc b">ls</code>和<code class="fe mz na nb nc b">curl</code>命令)。多命令程序支持执行主命令的子命令。<code class="fe mz na nb nc b">git</code>和<code class="fe mz na nb nc b">npm</code>是多命令工具的好例子。</p><p id="4193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们正在构建一个多命令程序，该程序支持<code class="fe mz na nb nc b">add</code>和<code class="fe mz na nb nc b">show</code>子命令来添加新的重量记录和显示旧的记录。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7a77" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初始化项目</h1><p id="e8fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用一个简单的命令来初始化项目:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2446" class="nh md it nc b gy ni nj l nk nl">npx oclif multi [project name]</span></pre><p id="d824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用npm包运行程序<code class="fe mz na nb nc b">npx</code>，用oclif初始化项目。命令<code class="fe mz na nb nc b">multi</code>指定我们的项目是一个多命令CLI。当您运行这个命令时，您将被提示输入关于这个项目的几个细节，这将帮助oclif创建初始项目文件，包括<code class="fe mz na nb nc b">package.json</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/12c330dff450243afb89bc7413709390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*31Arcf78JsgjAO-u.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">oclif项目生成器</p></figure><p id="446b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在这个项目中使用JavaScript，所以确保在TypeScript字段中输入“No”。</p><p id="f93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这一步完成时，您将看到oclif已经为我们的项目创建了一个新目录，包含以下子目录:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="21d2" class="nh md it nc b gy ni nj l nk nl">├── README.md<br/>├── bin<br/>│   ├── run<br/>│   └── run.cmd<br/>├── package.json<br/>├── node_modules<br/>├── src<br/>│   ├── commands<br/>│   │   └── hello.js<br/>│   └── index.js<br/>├── test<br/>│   ├── commands<br/>│   │   └── hello.test.js<br/>│   └── mocha.opts<br/>└── package-lock.json</span></pre><p id="5b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是oclif为我们创建的初始CLI。我们可以添加新的命令将它转换成我们需要的程序。如您所见，我们的项目已经有了一个预定义的命令<code class="fe mz na nb nc b">hello</code>。我们可以使用命令行运行以下命令:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1bb5" class="nh md it nc b gy ni nj l nk nl">./bin/run hello</span></pre><p id="c731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想使用<code class="fe mz na nb nc b">oclif_cli</code>命令(这是我们CLI的项目名称)从全局范围访问这个应用程序，请使用<code class="fe mz na nb nc b">npm link</code>命令:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6690" class="nh md it nc b gy ni nj l nk nl">npm link</span></pre><p id="5a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在命令行上使用<code class="fe mz na nb nc b">oclif_cli</code>命令运行我们的应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/2b93ebaba1459ffd71703957985b6ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmrtXuj7Xx-SigcLRaSMxw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行oclif应用程序</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3bcd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向我们的应用程序添加新命令</h1><p id="9af5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我前面提到的，我们的体重跟踪工具有两个主要命令:add和show。<code class="fe mz na nb nc b">add</code>命令让我们添加新的<code class="fe mz na nb nc b">weight</code>记录，而<code class="fe mz na nb nc b">show</code>命令显示过去的<code class="fe mz na nb nc b">weight</code>记录。</p><p id="b901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建这些命令时，您会遇到诸如标志和参数之类的术语。我们先明确一下这些术语的含义。</p><h2 id="4863" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">标志和参数</h2><p id="b8a5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您有一些使用命令行程序的经验，您可能已经知道什么是标志和参数。</p><p id="3f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标志提供了一种方式来指定运行特定命令的选项。例如，考虑以下命令:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2d4d" class="nh md it nc b gy ni nj l nk nl">npm install -g oclif</span></pre><p id="2439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用标志<code class="fe mz na nb nc b">-g</code>来指定我们需要全局安装oclif。但是没有必要在每个命令中都包含这个标志。如果你想激活它所代表的选项，你只需要使用一个标志。</p><p id="163d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数由外部提供，通常由用户提供。在上面的npm命令中，oclif是用户提供的参数。当我们将它作为参数传递时，我们告诉命令行运行<code class="fe mz na nb nc b">npm install</code>命令来安装所提供的包。类似地，我们可以在命令中接受参数，并在运行程序时将它们用作输入或目标。</p><h2 id="cecd" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">创建应用程序的第一个命令</h2><p id="15fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用以下命令向我们的程序添加新命令:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c52d" class="nh md it nc b gy ni nj l nk nl">npx oclif command [command-name]</span></pre><p id="39c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它创建新命令所需的所有文件，并更新自述文件。</p><p id="1655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将按照以下格式添加第一个命令<code class="fe mz na nb nc b">add</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f2a4" class="nh md it nc b gy ni nj l nk nl">npx oclif command add</span></pre><p id="22eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向CLI添加新命令就是这么简单。现在，<code class="fe mz na nb nc b">oclif_cli</code> <code class="fe mz na nb nc b">add</code>命令可以使用了。但是，我们还是要实现它的内在逻辑。为此，我们应该更改src目录中已经创建的<code class="fe mz na nb nc b">add.js</code>文件。</p><p id="a33f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完全实现的<code class="fe mz na nb nc b">add</code>命令应该能够接受指定用户体重的参数，并用时间戳记录下来。因此，代码应该能够读取一个<code class="fe mz na nb nc b">weight</code>参数，并将其保存在一个文件中，其中包含添加记录的日期和时间。</p><p id="97cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们更改了<code class="fe mz na nb nc b">AddCommand</code>类(已经由oclif定义)以包含以下实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们对<code class="fe mz na nb nc b">add</code>命令进行了描述，并定义了它接受的参数。我们声明了参数名(<code class="fe mz na nb nc b">weight</code>)并添加了一个描述，向用户说明如何传递参数。由于我们已经将参数定义为“required”，如果不提供权重值，用户将无法运行<code class="fe mz na nb nc b">oclif_cli add</code>命令。</p><p id="9f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现中最重要的部分是异步<code class="fe mz na nb nc b">run</code>函数内部的代码。每次用户运行<code class="fe mz na nb nc b">add</code>命令时都会调用它。它读取命令传递的参数，并使用<code class="fe mz na nb nc b">Weight</code>类的<code class="fe mz na nb nc b">add</code>方法(我们将在后面实现)将数据保存到文件中。保存成功完成后，它会向控制台记录一条成功消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a3c6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建显示命令</h1><p id="52af" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们创建程序的第二个命令:<code class="fe mz na nb nc b">show</code>。它用于在命令行上显示已经保存在文件中的重量数据。</p><p id="3079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像创建<code class="fe mz na nb nc b">add</code>命令一样创建<code class="fe mz na nb nc b">show</code>命令:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1ae9" class="nh md it nc b gy ni nj l nk nl">npx oclif command show</span></pre><p id="dda8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们像以前一样执行<code class="fe mz na nb nc b">show</code>命令。这里唯一的区别是<code class="fe mz na nb nc b">show</code>命令接受一个可选标志。这个可选标志允许用户指定他们想要查看多少过去的记录。</p><p id="298e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样定义标志(名为<code class="fe mz na nb nc b">count</code>):</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="062b" class="nh md it nc b gy ni nj l nk nl">ShowCommand.flags = {<br/>  count: flags.string({char: 'c', description: 'count of past records to be displayed'}),<br/>  help: flags.help({char: 'h'})<br/>}</span></pre><p id="5cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用创建新标志的<code class="fe mz na nb nc b">flags.string</code>函数，我们可以传递一个用于标志的字符和描述。当使用string函数创建标志时，用户可以传递一个参数。对于我们的程序，我们已经声明这个参数是必需的。因此，当使用<code class="fe mz na nb nc b">count</code>标志时，这个参数是必不可少的。</p><p id="f81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在官方文档中找到更多关于oclif的不同类型的标志和接受的选项。</p><p id="e391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还使用oclif内置的<code class="fe mz na nb nc b">flags.help</code>函数创建了一个帮助标志，这样用户就可以使用该命令获得帮助。</p><p id="8734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们程序的完整的<code class="fe mz na nb nc b">showCommand</code>类如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="efd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，在<code class="fe mz na nb nc b">run</code>函数中，我们定义了当用户运行这个命令时会发生什么。它解析我们传递的标志(如果有的话)，并读取用<code class="fe mz na nb nc b">count</code>标志传递的参数。它调用<code class="fe mz na nb nc b">Weight</code>类的<code class="fe mz na nb nc b">show</code>方法来检索必要数量的过去记录。最后，它根据记录创建时间以降序将检索到的数据记录到控制台。</p><h2 id="6a94" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">实现权重类</h2><p id="3547" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在之前的实现中，我们在程序中使用了来自<code class="fe mz na nb nc b">Weight</code>类的两个方法。我们现在将在src目录中一个名为<code class="fe mz na nb nc b">api</code>的新目录中创建这个类。在<code class="fe mz na nb nc b">api</code>目录中，我们还创建了一个名为<code class="fe mz na nb nc b">weightTracker</code>的文件夹来保存JSON文件，我们在其中存储我们的体重记录。JSON文件被命名为<code class="fe mz na nb nc b">weights.json</code>。</p><p id="22ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个类是如何实现的，我就不赘述了。抽象地说，我们在这里所做的是:</p><ul class=""><li id="8f1a" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">读取<code class="fe mz na nb nc b">weights.json</code>文件的内容，并在类构造函数中将它解析成一个数组。</li><li id="2fd0" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">向<code class="fe mz na nb nc b">weights</code>数组添加新的重量记录，并调用<code class="fe mz na nb nc b">saveWeight</code>方法在<code class="fe mz na nb nc b">add</code>方法中保存新的记录数组。</li><li id="b145" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">在<code class="fe mz na nb nc b">show</code>方法中返回所有或给定数量的过去记录(作为<code class="fe mz na nb nc b">count</code>参数传递)。</li><li id="d7d5" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">将对象数组转换成JSON，并在<code class="fe mz na nb nc b">saveWeight</code>方法中将其写入<code class="fe mz na nb nc b">weights.json</code>文件。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="334c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试我们的体重跟踪CLI工具</h1><p id="2601" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在已经完全实施了我们的计划。剩下要做的就是摆弄它，看看它是如何协同工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/9e9ccfb7da29f0f1f39c89e862cf833d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vn_XJE5si5LD1Dx3ajba_Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试我们的重量跟踪器应用程序</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b05d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="6a2e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我们在本教程中看到的，oclif使我们最喜欢的编程语言中的任务自动化变得非常容易。它自己处理枯燥的部分，如文档，并让我们在命令的实际实现中获得乐趣。</p><p id="ee4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我希望我已经说服你给oclif一个机会，让它成为你在Node中最喜欢的CLI框架。如果你更深入地研究这个主题，你将能够意识到一个CLI框架oclif是多么强大。</p><p id="b785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次你计划自动化一个无聊的任务时，记得使用oclif。不要忘记通过在npm 上发布您的包来与世界<a class="ae ky" href="https://medium.com/better-programming/publish-your-first-node-library-using-npm-ee6bb7052187" rel="noopener">分享它。</a></p><p id="fe41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>