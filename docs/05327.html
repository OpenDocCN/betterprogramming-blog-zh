<html>
<head>
<title>Lodash: Create React App’s Built-in Library for Debounce and Throttle With Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lodash:创建React应用程序的内置库，用于反跳和用钩子节流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8?source=collection_archive---------2-----------------------#2020-06-30">https://betterprogramming.pub/lodash-create-react-apps-built-in-library-for-debounce-and-throttle-with-hooks-3418087f44d8?source=collection_archive---------2-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用useCallback、useMemo、useRef和自定义挂钩展示去抖和节流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/351605b43e336088fc6b276666c61b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08LF-xcl6Mmedd1VB24z3Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@tavi004?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Octavian Rosca </a>在<a class="ae ky" href="/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="793c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继我们的<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener">关于Create React App的10个有趣事实</a>之后，今天我们呈现关于Create React App的第11个有趣事实:它内置了Lodash，这是一个JavaScript库，为数组、数字、对象和字符串提供了实用函数。</p><p id="9b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然许多功能可以被ES2015+取代，但Lodash仍然是一个具有额外便利实用程序的超级套件。我们可以利用内置的Lodash用钩子探索<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cf77" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Lodash、去抖和节流</h1><p id="0f24" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们之前的项目中，Lodash总是一个需要安装的实用程序包。通过运行<code class="fe lv lw lx ly b">npm i lodash</code>，在<code class="fe lv lw lx ly b">package.json</code>中<code class="fe lv lw lx ly b">lodash</code>包成为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">dependencies</a></code>的一部分。</p><p id="bd6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式随着Create React应用程序而改变。调用<code class="fe lv lw lx ly b">npx create-react-app my-app</code>后，Lodash就可以使用了。根本不需要安装。<code class="fe lv lw lx ly b">lodash</code>不在<code class="fe lv lw lx ly b">package.json</code>里，而是在<code class="fe lv lw lx ly b">package-lock.json</code>里，和其他包一起安装。</p><p id="72e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lodash可以导入为:<code class="fe lv lw lx ly b">import _ from “lodash”;</code>然后和下划线一起使用。以下是<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>的定义和用途:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7057" class="nh mh it ly b gy ni nj l nk nl">/** <br/> * Creates a debounced function that delays invoking <!-- -->func<!-- --> until<br/> * after <!-- -->wait<!-- --> milliseconds have elapsed since the last time the<br/> * debounced function was invoked.<br/> */<br/>_.debounce(func, [wait=0], [options={}])</span><span id="89e4" class="nh mh it ly b gy nm nj l nk nl">/** <br/> * Creates a throttled function that only invokes <!-- -->func<!-- --> at most <br/> * once per every <!-- -->wait<!-- --> milliseconds.<br/> */<br/>_.throttle(func, [wait=0], [options={}])</span></pre><p id="3f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lodash也可以单独导入，使用时不带下划线。事实上，这是允许Webpack的<a class="ae ky" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">树摇动</a>创建更小的包的推荐方式。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="165d" class="nh mh it ly b gy ni nj l nk nl">import debounce from "lodash/debounce";<br/>import throttle from "lodash/throttle";</span><span id="16d6" class="nh mh it ly b gy nm nj l nk nl">debounce(func, [wait=0], [options={}])<br/>throttle(func, [wait=0], [options={}])</span></pre><p id="50c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们需要<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>？它们是出于性能原因而引入的。以用户输入为例。如果每次击键都调用后台调用来检索信息，我们可能会使整个系统崩溃。相反，我们给出一个等待时间来减少负载。<code class="fe lv lw lx ly b">debounce</code>等待，直到用户在等待期间停止输入，然后发出更新请求。<code class="fe lv lw lx ly b">throttle</code>有点不同——它将更新频率控制在等待<code class="fe lv lw lx ly b">throttle</code>限制之下。</p><p id="6b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个简单的用户界面来说明这个概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/2f7ea20e864d2c81b868d1a3687556cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*8hrxNGOW6lzQvM1xr07tYg.png"/></div></div></figure><p id="8410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的输入字段中，用户输入<code class="fe lv lw lx ly b">123456</code>。如果用户收听<code class="fe lv lw lx ly b">onChange</code>并对每个输入值响应<code class="fe lv lw lx ly b">console.log</code>，这些原始值是<code class="fe lv lw lx ly b">1</code>、<code class="fe lv lw lx ly b">12</code>、<code class="fe lv lw lx ly b">123</code>、<code class="fe lv lw lx ly b">1234</code>、<code class="fe lv lw lx ly b">12345</code>和<code class="fe lv lw lx ly b">123456</code>。如果没有<code class="fe lv lw lx ly b">debounce</code>或<code class="fe lv lw lx ly b">throttle</code>，它会在短时间内调用六个后端调用。</p><p id="f7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，用户可能不太关心中间结果。用户关心的是当输入停止时<code class="fe lv lw lx ly b">123456</code>的最终结果。<code class="fe lv lw lx ly b">debounce</code>将是这种情况下的最佳选择。它只在打字停止一个滴答(等待时间)时处理数据。当用户快速键入<code class="fe lv lw lx ly b">123456</code>时，只有一个去抖动值<code class="fe lv lw lx ly b">123456</code>。</p><p id="987e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">throttle</code>工作方式略有不同。用户可能希望以受控的速率(等待时间)得到响应。默认情况下，它打印出第一次击键，<code class="fe lv lw lx ly b">1</code>。其他中间节流值取决于等待时间和用户的打字速度。但保证最终结果<code class="fe lv lw lx ly b">123456</code>会输出。</p><p id="5b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将原始值、去抖值和节流值放在一起，下面是一个示例输出。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="21dd" class="nh mh it ly b gy ni nj l nk nl">Original Value = 1<br/>Throttled Value = 1<br/>Original Value = 12<br/>Original Value = 123<br/>Original Value = 1234<br/>Original Value = 1234<br/>Original Value = 12345<br/>Original Value = 123456<br/>Throttled Value = 123456<br/>Debounced Value = 123456</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bb0f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">错误的方法</h1><p id="ee5b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们在Create React App环境中用<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>实现输入示例。<code class="fe lv lw lx ly b">src/App.js</code>修改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe lv lw lx ly b">npm start</code>并在输入栏快速输入<code class="fe lv lw lx ly b">123456</code>。控制台显示以下结果:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1378" class="nh mh it ly b gy ni nj l nk nl">Original Value = 1<br/>Throttled Value = 1<br/>Original Value = 12<br/>Throttled Value = 12<br/>Original Value = 123<br/>Throttled Value = 123<br/>Original Value = 1234<br/>Throttled Value = 1234<br/>Original Value = 12345<br/>Throttled Value = 12345<br/>Debounced Value = 1<br/>Original Value = 123456<br/>Throttled Value = 123456<br/>Debounced Value = 12<br/>Debounced Value = 123<br/>Debounced Value = 1234<br/>Debounced Value = 12345<br/>Debounced Value = 123456</span></pre><p id="9aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>都打印出每一次击键的变化。发生了什么事？</p><p id="cd00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反应重新渲染是由状态或道具的变化引起的。在上面的方法中，当用户击键时，<code class="fe lv lw lx ly b">onChange</code>触发<code class="fe lv lw lx ly b">handleInputChange</code>(第8-18行)。第11行设置了一个新的状态值，这将导致新的呈现显示该值(第22行)。</p><p id="d53a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每一次击键，都会生成一个新的<code class="fe lv lw lx ly b">debounce</code>函数(第12-14行)和一个新的<code class="fe lv lw lx ly b">throttle</code>函数(第15-17行)。这就是为什么他们简单地用<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>表示每一个值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f85d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">正确的方法</h1><p id="d5bd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了使<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>行为正确，我们需要创建在渲染之间被记忆的函数。记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</p><p id="05eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useCallback</code>是个不错的人选。它返回回调的记忆版本。只有当其中一个依赖关系发生变化时，此函数才会发生变化。<code class="fe lv lw lx ly b">useCallback(fn, deps)</code>有条件地保留功能<code class="fe lv lw lx ly b">fn</code>。</p><p id="3f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是应用<code class="fe lv lw lx ly b">useCallback</code>来记忆<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>功能的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8-13行，<code class="fe lv lw lx ly b">debounceHandler</code>是由<code class="fe lv lw lx ly b">useCallback</code>记忆的<code class="fe lv lw lx ly b">debounce</code>功能。因为它有一个空的依赖数组，所以它在组件的整个生存期内都被保留。</p><p id="e94a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第15-20行，<code class="fe lv lw lx ly b">throttleHandler</code>是由<code class="fe lv lw lx ly b">useCallback</code>记忆的<code class="fe lv lw lx ly b">throttle</code>功能。因为它有一个空的依赖数组，所以它在组件的整个生命周期内都是保留的。</p><p id="430b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这种方法奏效了。</p><p id="cc87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">useCallback</code>返回一个记忆化的回调时，<code class="fe lv lw lx ly b">useMemo</code>返回一个记忆化的值。<code class="fe lv lw lx ly b">useCallback(fn, deps)</code>相当于<code class="fe lv lw lx ly b">useMemo(() =&gt; fn, deps)</code>，其中函数被记忆为一个值。</p><p id="e94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">src/App.js</code>中使用<code class="fe lv lw lx ly b">useMemo</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="37db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8-14行，<code class="fe lv lw lx ly b">debounceHandler</code>是由<code class="fe lv lw lx ly b">useMemo</code>记忆的<code class="fe lv lw lx ly b">debounce</code>函数。因为它有一个空的依赖数组，所以它在组件的整个生命周期内都是保留的。</p><p id="2b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第16-22行，<code class="fe lv lw lx ly b">throttleHandler</code>是由<code class="fe lv lw lx ly b">useMemo</code>记忆的<code class="fe lv lw lx ly b">throttle</code>功能。因为它有一个空的依赖数组，所以它在组件的整个生存期内都被保留。</p><p id="29fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法也有效。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="54f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/better-programming/most-things-you-want-to-know-about-react-refs-29901ebf28c6" rel="noopener">你想知道的关于React Refs的一切</a>中，我们对<code class="fe lv lw lx ly b">useRef</code>进行了详细的描述。它返回一个可变的ref对象，该对象的<code class="fe lv lw lx ly b">.current</code>属性被初始化为传递的参数。返回的对象将在组件的整个生存期内保持不变。</p><p id="4205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe lv lw lx ly b">useRef</code>来记忆<code class="fe lv lw lx ly b">src/App.js</code>中的<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8-13行，<code class="fe lv lw lx ly b">debounceHandler</code>被<code class="fe lv lw lx ly b">debounce</code>函数初始化。它在组件的整个生命周期内保持在<code class="fe lv lw lx ly b">current</code>值中，因为它没有被重新分配。第26行的调用需要调用<code class="fe lv lw lx ly b">current</code>值。</p><p id="080c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第13-18行，<code class="fe lv lw lx ly b">throttleHandler</code>由<code class="fe lv lw lx ly b">throttle</code>函数初始化。它在组件的整个生命周期内保持在<code class="fe lv lw lx ly b">current</code>值中，因为它没有被重新分配。第27行的调用需要调用<code class="fe lv lw lx ly b">current</code>值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0bf2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">定制钩子接近</h1><p id="6d4b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">前面的方法是可行的。我们要为每个用例构建<code class="fe lv lw lx ly b">debounce</code>或<code class="fe lv lw lx ly b">throttle</code>处理程序吗？</p><p id="b2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定制钩子是一种重用编程逻辑的机制。让我们看看如何为<code class="fe lv lw lx ly b">debounce</code>和<code class="fe lv lw lx ly b">throttle</code>构建定制钩子。</p><p id="f0f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将定制钩子和用法放在同一个文件中。理想情况下，它们应该被归类为单独的文件。这是修改后的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="45df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第5-8行定义了一个定制钩子，<code class="fe lv lw lx ly b">useDebouncedCallback</code>。它需要一个回调和等待时间，然后相应地生成一个<code class="fe lv lw lx ly b">debounce</code>函数。因为第6行用<code class="fe lv lw lx ly b">useCallback</code>和一个空的依赖列表将它包围起来，所以这个<code class="fe lv lw lx ly b">debouncedFunction</code>在钩子的整个生命周期中不会改变。</p><p id="24cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第18-21行初始化<code class="fe lv lw lx ly b">useDebouncedCallback</code>，由第33行使用。</p><p id="0d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第10-13行定义了一个定制钩子<code class="fe lv lw lx ly b">useThrottledCallback</code>。这需要一个回调和等待时间，然后相应地生成一个<code class="fe lv lw lx ly b">throttle</code>函数。因为第11行用<code class="fe lv lw lx ly b">useCallback</code>和一个空的依赖列表将它包围起来，所以这个<code class="fe lv lw lx ly b">throttledFunction</code>在钩子的整个生命周期中不会改变。</p><p id="1439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第23-26行初始化<code class="fe lv lw lx ly b">useThrottledCallback</code>，由第34行使用。</p><p id="f046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法适用于可重用的定制钩子。</p><p id="afac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了反跳或抑制回调，我们还可以编写自定义钩子来反跳或抑制值。呼叫者可以为各种用途编程这些值。</p><p id="0026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是修改后的<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第5-9行定义了一个定制钩子，<code class="fe lv lw lx ly b">useDebouncedValue</code>。它需要一个初始值和一段等待时间。在内部，它保持原始值，并为去抖值生成一个<code class="fe lv lw lx ly b">debounce</code>函数。因为第7行用<code class="fe lv lw lx ly b">useCallback</code>和一个空的依赖列表将它包围起来，所以这个<code class="fe lv lw lx ly b">debouncedFunction</code>在钩子的整个生命周期中不会改变。这个自定义钩子返回一个数组，其中包含去抖动值和去抖动函数来更新该值。</p><p id="1fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第19行初始化<code class="fe lv lw lx ly b">useDebouncedValue</code>。第33行使用<code class="fe lv lw lx ly b">debounceHandler</code>来更新值。第33-35行监听<code class="fe lv lw lx ly b">debouncedValue</code>变化，并相应打印出去抖值。</p><p id="f02b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第11-15行定义了一个定制钩子，<code class="fe lv lw lx ly b">useThrottledValue</code>。它需要一个初始值和一段等待时间。在内部，它保持原始值，并为调节值生成一个<code class="fe lv lw lx ly b">throttle</code>函数。因为第13行用<code class="fe lv lw lx ly b">useCallback</code>和一个空的依赖列表将它包围起来，所以这个<code class="fe lv lw lx ly b">throttledFunction</code>在钩子的整个生命周期中不会改变。这个定制钩子返回一个带有throttled值的数组和throttled函数来更新该值。</p><p id="b03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第20行初始化<code class="fe lv lw lx ly b">useThrottledValue</code>。第33行使用<code class="fe lv lw lx ly b">throttleHandler</code>来更新值。第37-39行监听<code class="fe lv lw lx ly b">throttledValue</code>的变化，并相应地打印出节流值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="22f4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不受控制的方法</h1><p id="27df" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在所有以前的方法中，我们使用由React团队推荐的<a class="ae ky" href="https://medium.com/better-programming/to-be-or-not-to-be-2c372198a01c" rel="noopener">受控组件</a>。</p><p id="20f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于去抖和节流的用例，使用不受控制的元件更容易。</p><p id="5ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">debounce</code>的改版<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ea93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">17行直接用<code class="fe lv lw lx ly b">debounceHandler</code>，在10-13行定义。</p><p id="2be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以将<code class="fe lv lw lx ly b">src/App.js</code>修改为<code class="fe lv lw lx ly b">throttle</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d01c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第17行直接使用<code class="fe lv lw lx ly b">throttleHandler</code>，在第10-13行定义。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b539" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="ac38" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Create React应用程序中内置的Lodash为我们提供了函数式编程和数组、数字、对象和字符串操作的便利。</p><p id="755b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">探索去抖和节流的用法很有趣，还有钩子——试试吧！</p><p id="870b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，我希望它是有帮助的。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>