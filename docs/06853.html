<html>
<head>
<title>Making Redux in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在铁锈中制造Redux</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/redux-in-rust-d622822085fe?source=collection_archive---------6-----------------------#2020-11-11">https://betterprogramming.pub/redux-in-rust-d622822085fe?source=collection_archive---------6-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f30f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Rust中重建GitHub最受欢迎的库之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b71059afa6b02b888201dbc6501e03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mst-ZDeqOdJgLaZ1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">菲利克斯·布伦德勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e8a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>是一种令人惊叹的语言，号称速度堪比C，抽象性堪比C#或TypeScript等高级语言。几年前，它激起了我的兴趣——但这是我目前为止所做的(仅仅是感兴趣)。我有一个相当坚实(和狂热的功能)的JavaScript背景，但我总是觉得我只是默认的前端开发人员。在我搜索的指尖上有如此高可用性的经典web技术指南！我最近做了一点程序性的自我反省，试图找到我的定位，并真正建立一些东西。而且由于铁锈几乎可以到任何地方(？)学什么语言比较好？</p><p id="d103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我将继续在Rust上学习。我仍然可以夸耀一些很棒的JS技能，这些技能可能在未来几年都需要，但我认为Rust在不久的将来会成为主要玩家。</p><p id="9a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之。我的假设是，我的读者，你也处于类似的境地。你来自JS，热爱网络技术；你听说过铁锈，并渴望更多。好了，我已经帮你准备好了，因为今天我要写一些和大多数JS开发者相关的东西Rust中的Redux！</p><p id="be67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>，那也没关系。Redux是一个简单的状态管理机器，它</p><ol class=""><li id="3df1" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">持有某种状态，</li><li id="3f71" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">基于称为<em class="lv">reducer</em>的纯函数更新该状态。</li></ol><p id="968d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反正那是最基础的版本。这是一个由脸书人推广的消息系统的实现，被称为<a class="ae ky" href="https://facebook.github.io/flux/docs/overview" rel="noopener ugc nofollow" target="_blank"> Flux </a>。Redux可能是Flux最简单的实现。不过，在我们的示例中，我们要做的不仅仅是保存状态并更新它。除了纯粹的功能状态缩减器，我们还将引入处理副作用的能力，并提供回溯状态历史的方法。</p><p id="8106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旁注:一个<em class="lv">纯函数</em>是不执行任何副作用的函数。也就是说，如果你给它同样的输入，它将永远产生同样的输出，永远不会改变外部状态。</p><p id="cefb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要一些状态来操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/40225f5fa14275b4f2e22a98b563ccf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00wi4Nvf_G49Zz1kwTLuXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从基础开始。</p></figure><p id="17d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这几乎是我们能够管理的最简单的状态。不过，对于我们的例子来说，这应该足够了。因为我们希望我们的状态变化是不可变的步骤，我们可能还应该在这里派生一些特征:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/143d33f005f7dae10bab99aaccf782c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3kIRGoaUjjouL8ppdVWiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用<code class="fe ml mm mn mo b">derive</code>添加一些免费功能。</p></figure><p id="3394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ml mm mn mo b">Copy</code>和<code class="fe ml mm mn mo b">Clone</code>让我们通过堆栈上的值来传递我们的结构。让我们在没有新函数的情况下初始化我们的类型。<code class="fe ml mm mn mo b">PartialEq</code>允许我们用<code class="fe ml mm mn mo b">==</code>和<code class="fe ml mm mn mo b">!=</code>来比较我们的结构。当我们实现我们的状态存储时，我们将享受这些特征的特性。</p><p id="2988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们需要做的是为我们的状态定义一个包装器。这个包装器就是所谓的商店。您可以将存储视为对其包含的状态的唯一引用。在存储区中，您的状态只存在一个当前副本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/b37e8dfe31df6c75a165a24cb185def5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_6mER3-YUzq7aOF8y7I0w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定义一个简单的状态缩减存储。</p></figure><p id="5354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…这很快变得复杂起来。这需要一些解释。Store是具有几个字段的通用类型。</p><ol class=""><li id="ef6f" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">它包装了我们的状态<code class="fe ml mm mn mo b">T</code>，它可以是实例化时的任何类型。</li><li id="da18" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">它将一个trait对象作为它的<code class="fe ml mm mn mo b">reducer</code>字段。这个字段允许我们传递一个函数作为<code class="fe ml mm mn mo b">reducer</code>的值。<code class="fe ml mm mn mo b">Box</code>仅仅是一个指向堆分配项的指针，我们的函数必须是这样的，因为它的大小在编译时是未知的。我们期望这个函数采用<code class="fe ml mm mn mo b">Fn(T, Msg) -&gt; T</code>的形式。</li></ol><p id="dc37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是打住，什么是<code class="fe ml mm mn mo b">Msg</code>？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/382ef51c713179cc73b2d14ce590f24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6EsYLfLeEhCFWyyklpfYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这将保存我们的消息类型。</p></figure><p id="9b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，那是<code class="fe ml mm mn mo b">Msg</code>。如果你熟悉JavaScript的Redux库，这就是你通常所说的<em class="lv">动作</em>。<code class="fe ml mm mn mo b">Msg</code>最终将扩展到覆盖我们的应用程序的所有可能的动作——或者至少是我们将为这一个状态执行的所有动作。现在我们已经有了一些东西，让我们开始实现吧。我们将实现存储结构的功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/cbaef44c801d23ae847ff67430e91999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHz4UNHSTR6hDDVCGvrcjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用惯用的new构建商店。</p></figure><p id="4537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在我们的<code class="fe ml mm mn mo b">impl</code>块中添加了一些<em class="lv">特征界限</em>。<code class="fe ml mm mn mo b">where</code>指定以下类型参数必须实现所提供的特征。除了格式之外，还列出了必须在我们的数据结构上实现的特征。还记得我们从我们的国家结构<code class="fe ml mm mn mo b">MyState</code>中得到的特征吗？这些特征界限允许我们利用已经提供给状态的特征，这样编译器就知道我们正在做的事情有先决条件，只要满足那些PRs就可以了。这让我们可以做一些事情，比如调用通用参数<code class="fe ml mm mn mo b">T</code>的<code class="fe ml mm mn mo b">default()</code>函数——编译器知道<code class="fe ml mm mn mo b">T</code>必须实现<code class="fe ml mm mn mo b">Default</code>特征。让我们暂时忽略构造函数的reducer参数。我们刚才已经讨论了堆分配的trait对象的情况，随着我们向前推进并利用这些字段，这将比讨论它在内存中如何工作更有意义。</p><p id="8508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加更多的功能。流量模式的核心是调度程序的概念。虽然我可以(在更高级的场景中，可能会)让dispatcher有自己的结构，但我会选择Redux路线，只让<code class="fe ml mm mn mo b">dispatch</code>成为Store的一个方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/3492d8fc46ea136b418163ac51bee9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vx0vpNw0WPVNw-AeCwXXqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新我们状态的唯一方法是通过调度。</p></figure><p id="0844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个愚蠢的简单且非常幼稚的解决方案，但是现在让我们先用它运行一下——不管怎样，它应该可以编译。<code class="fe ml mm mn mo b">dispatch</code>函数接受一个<code class="fe ml mm mn mo b">Msg</code>类型的对象。我们所做的就是获取当前状态，并将其重新分配给reducer函数的结果，传入当前状态和调度的<code class="fe ml mm mn mo b">Msg</code>参数。好的，但是减速器呢？我们仍未尝试构建商店，但当我们这样做时，我们将需要一个符合我们<code class="fe ml mm mn mo b">new</code>签名的reducer。首先，让我们定义一个表示状态更改请求的操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/b98047f4696305eadd1f6d3365d59847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnld_7JEEPIezg7mUoMZUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个实际的行动。</p></figure><p id="3751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经为我们的<code class="fe ml mm mn mo b">Msg</code>类型添加了一个变体。现在，我们可以在状态缩减器中使用一些东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/5c9f87af9eddad4ebd4b4edb68c7ede3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfymcP7ICBnkAOx3xMHQOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">减压器的基本功能。</p></figure><p id="2a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是一个非常简单的减速器，伴随着我们非常简单的状态结构。reducer通常是这样工作的:它匹配收到的消息，然后根据收到的消息中的数据返回一个全新的状态对象。我们当前的消息非常简单，它们没有任何有效载荷数据，它们仅仅是标志。我们的减速器现在只需要匹配一个案例；在所有其他情况下，我们传递回原始状态。现在我们可以试用我们的机器了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/0996efba17f0cc1790785beb1a324345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAekAODXVCkALkHYiW9fJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个什么都不做的商店。还没有。</p></figure><p id="0d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了…但是，嗯…我能用它做什么呢？没什么！我不能记录我的状态，查看我的状态，或者做任何事情，除了发送我的增量消息到众所周知的空处，希望它们产生正确的状态对象！</p><p id="1312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将我们引向通量模式的另一个重要部分:隔离副作用。计算机科学世界的一个副作用是，你几乎想用一个应用程序做任何事情。登录？副作用。保存数据？副作用。Web请求？又有副作用了。唯一没有副作用的是一个纯函数——给定相同的输入，每次都会产生相同的输出。副作用是必须控制的必要的混乱！</p><p id="ef7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于副作用不是我们的纯状态缩减器的一部分，并且可能改变所提供的参数之外的变量，所以最好将它们从纯代码中分离出来，以便可以轻松地改变或删除它们。因此，为了处理这些副作用，我选择了为中间件提供一个钩子的方法——作为调度机制的一部分，函数执行副作用。首先，我们必须添加一个指向函数的指针向量，其形式为<code class="fe ml mm mn mo b">Fn(Msg) -&gt; Msg</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/bc637652926c37cc3370934421da0eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIO2rhztXmgR4mR9D_OofQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为我们的商店增加一个新领域。</p></figure><p id="028b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用了一个函数向量，因为我想允许在商店中使用多个中间件函数。这将允许我们稍后编写我们的侧面影响函数。现在我们需要添加一些实现来利用我们的新字段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/21037d4db9ad3b4305f70fd36d296faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YXnq2AEN3n8aZQoKmNZFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">支持中间件。</p></figure><p id="5fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两个新函数要添加到我们的<code class="fe ml mm mn mo b">impl</code>存储块中。<code class="fe ml mm mn mo b">use_middleware</code>向我们的中间件管道注册一个函数。<code class="fe ml mm mn mo b">middleware_strategy</code>是一个助手，我们将在<code class="fe ml mm mn mo b">dispatch</code>内部调用它(我稍后会描述)。由于我们不能在第一个for循环中再次可变地借用<code class="fe ml mm mn mo b">self</code>，我们的策略将结果(类型为<code class="fe ml mm mn mo b">Msg</code>)收集到一个<code class="fe ml mm mn mo b">Vec</code>中，然后遍历这些结果，允许我们再次借用<code class="fe ml mm mn mo b">self</code>来调度每个<code class="fe ml mm mn mo b">Msg</code>。现在我们只需要将这个中间件钩子插入到我们的<code class="fe ml mm mn mo b">dispatch</code>函数中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/7c0504cfe15de59fea465bd038576978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Ky-xYqFox5zYyduwG-XFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">noop-终止调度程序。</p></figure><p id="0528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了一个助手函数，<code class="fe ml mm mn mo b">is_empty</code>，它接收一条消息并确定它是否是<code class="fe ml mm mn mo b">Msg</code>的<code class="fe ml mm mn mo b">Noop</code>变体。我将通过一系列步骤解释它的重要性:</p><ul class=""><li id="f2ef" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mp mc md me bi translated">当我们的<code class="fe ml mm mn mo b">dispatch</code>触发时，我们立即启动中间件循环。</li><li id="80fe" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mp mc md me bi translated">每个中间件返回一个新消息，然后分发该消息。</li><li id="7235" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mp mc md me bi translated"><code class="fe ml mm mn mo b">dispatch</code>触发，我们开始中间件循环。</li><li id="bb94" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mp mc md me bi translated">现在我们无限循环。</li></ul><p id="6656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了避免无限循环，我们必须有某种非传播动作，通过不触发新的<code class="fe ml mm mn mo b">dispatch</code>来终止中间件循环。这就是我们的<code class="fe ml mm mn mo b">Noop</code>变体在这里最有用的地方。让我们编写一个中间件来记录商店收到的消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/70af32c01703e1b5b75a2d43637f580c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpgLNr3BOtqM0c0eHcm9_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最后，一些见解。</p></figure><p id="5039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那现在应该记录我们的<code class="fe ml mm mn mo b">Increment</code>消息两次。好吧！我们正在用我们的Flux实现做一些“有用”的事情。注意我们必须如何在<code class="fe ml mm mn mo b">logger_mw</code>中返回<code class="fe ml mm mn mo b">Noop</code>消息来停止分派过程。</p><p id="2796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了中间件的工作原理，让我们编写一个在现实生活中更有用的中间件。我将通过改变一些东西来引入一个条件消息拆分器。首先，我们应该把最初的<code class="fe ml mm mn mo b">dispatch</code>消息看作是一个请求，它可能产生成功或失败:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/df967eaee7e8bb353571e5636da197f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnDe2Cy5CfogBHzGLcVEqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拆分消息，第1部分。</p></figure><p id="fde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们发送<code class="fe ml mm mn mo b">TryIncrement</code>消息，我们将有一个中间件来处理这个情况。现在让我们编写我们的拆分器中间件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/f978ef2c97c69ccbcc4d9ca6161c94d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bl0YthLjX2tgZq3V9hvmoQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拆分消息，第2部分。</p></figure><p id="edec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们引入了一些任意的规则——如果我们调用状态<code class="fe ml mm mn mo b">Increment</code>超过十次，那么<code class="fe ml mm mn mo b">Increment</code>就会失败。现在，如果我们用<code class="fe ml mm mn mo b">use_middleware</code>把它插上，它应该可以拆分消息。如果我们更新我们的日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/128e101151c5e190d8115e259c2b9ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLTLWv4ezi2lzwX0XtszKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录我们的新信息。</p></figure><p id="e7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后它还应该告诉我们发送了什么消息。如果我们调用它超过十次，它应该记录<code class="fe ml mm mn mo b">IncrementFailed</code>消息，</p><p id="6280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们称这个实验完成之前，我们应该实现一种方法来查看状态的历史。让我们添加一些片段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/515803801a167c9c033d109472f74b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgbs3b7WUo-qpWwYVvtlog.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/4fdb251138736e04acdeb6a875d32f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mAQ01UgAdxjsaS2qHQzcg.png"/></div></div></figure><p id="10b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了一些事情:</p><ol class=""><li id="d635" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我们已经添加了字段来将历史表示为所提供类型<code class="fe ml mm mn mo b">T</code>的<code class="fe ml mm mn mo b">Vec</code>。</li><li id="74f5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们修改了我们的非终结分派分支，以包括捕获先前的状态并将其存储在我们的<code class="fe ml mm mn mo b">history</code> <code class="fe ml mm mn mo b">Vec</code>中。最后，这是我们将<code class="fe ml mm mn mo b">PartialEq</code>添加到我们的特征界限的原因——它允许我们使用一个简单的<code class="fe ml mm mn mo b">!=</code>操作符来比较前一个和下一个状态。基于该比较的结果，我们可以确定状态是相等的并且不添加到状态改变历史中，或者我们确定状态是不相等的，随后将先前的状态添加到历史中。</li><li id="e792" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们还需要一个函数来检索历史。<code class="fe ml mm mn mo b">bactrace</code>根据请求回顾尽可能多的步骤，返回一个包含最多<code class="fe ml mm mn mo b">steps</code>个状态变化的<code class="fe ml mm mn mo b">Vec</code>，前提是已经发生了足够多的变化。</li></ol><p id="a01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想这就差不多结束了。我们已经了解了Redux/Flux实现如何分离纯代码和不纯代码。我们学习了如何制作模块化的功能中间件来执行副作用。我们实现了简单的日志记录和状态回溯。我们都是在铁锈中完成的！</p><p id="0a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f06cbe4d78b239f2faeebeb8f2e39cc6" rel="noopener ugc nofollow" target="_blank">这是铁锈游乐场的链接。</a></p><p id="c3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到下一集我的Rust之旅，FP上乡亲们！</p></div></div>    
</body>
</html>