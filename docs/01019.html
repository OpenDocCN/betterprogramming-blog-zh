<html>
<head>
<title>Everything You Need to Know About Polymorphism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于多态性你需要知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-need-to-know-about-polymorphism-7a7976ca8987?source=collection_archive---------3-----------------------#2019-08-07">https://betterprogramming.pub/everything-you-need-to-know-about-polymorphism-7a7976ca8987?source=collection_archive---------3-----------------------#2019-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc23" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多元主义的用途和好处</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f38508eda00b68fe27ccb18fd1071b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgbZQ6iuHGCXCtPo_naQ8w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/shapes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@delilaziebart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Delila Ziebart </a>拍摄的照片</p></figure><p id="a2db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看你需要知道的关于多态性的一切。这个名字可能会让你觉得它很难，但事实上，多态性很容易理解。</p><p id="511c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态确实需要对继承的理解，这篇文章的代码样本是用C++写的，所以如果你不确定什么是继承，那么等你熟悉了之后再回来阅读这篇文章。</p><p id="47b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些听说过这个概念但需要复习的人，我将在进入多态之前提供一个快速回顾。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="49c0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">快速夺回遗产</h1><p id="d1c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">继承是一个允许我们通过is-a关系重用代码的概念。我们有一个类<code class="fe mz na nb nc b">Soldier</code>，它有特定的行为和状态。它可能有健康、耐力和行为，如行走、逃跑和射击。一个类可以从基类<code class="fe mz na nb nc b">Soldier</code>继承这些行为，同时也包含自己的行为。我们可以拥有一个继承自<code class="fe mz na nb nc b">Soldier</code>的<code class="fe mz na nb nc b">JetpackSoldier</code>类。<code class="fe mz na nb nc b">JetpackSoldier</code>能做<code class="fe mz na nb nc b">Soldier</code>能做的一切，除了有自己的行为，比如会飞。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以覆盖基类中定义的行为。例如，如果我们希望一个jetpack士兵从玩家身边飞走，而不是像一个普通士兵那样逃跑，我们可以通过重写jetpack soldier类中的fly方法来实现这一点。</p><p id="47c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这仍然没有多大意义，在继续本文之前，您可能需要对继承进行更多的研究。慢慢来；你回来的时候这篇文章还会在这里。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a274" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是多态性？</h1><p id="1189" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">多态性描述了有多种形式的事物。在计算机科学中，这指的是具有多种形式的功能和对象。</p><h2 id="eaa8" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">功能多态性</h2><p id="78f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<strong class="lb iu">重载</strong>实现函数多态性。重载允许函数共享相同的名称，同时传入不同的类型和/或不同数量的参数。一个函数有多种形式。</p><p id="aaa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，考虑一个对两个数求和的函数。我们可以有一个接受两个整数并返回一个int的sum函数，以及另一个接受两个float作为参数并返回一个float的sum函数。当我们调用sum传递两个数字时，编译器会根据我们传递的参数计算出实际需要调用哪个方法。在这两种情况下，当调用共享相同名称的方法时，根据我们传递的参数，我们可以获得不同的行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="da76" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">对象多态性</h2><p id="aa56" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关于对象的多态性略有不同。这就是继承发挥作用的地方。对于任何有基类的对象，比如我们的<code class="fe mz na nb nc b">JetpackSoldier</code>类，它的基类是<code class="fe mz na nb nc b">Soldier</code>，我们可以把它当作一个<code class="fe mz na nb nc b">Soldier</code>。任何处理与<code class="fe mz na nb nc b">Soldier</code>对象相关的代码也可以处理<code class="fe mz na nb nc b">JetpackSoldier</code>对象。有一个例子可以很好地说明这些好处:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="951f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们假设我们的游戏中有车辆，并且我们有一个<code class="fe mz na nb nc b">Jeep</code>类，我们希望在这个类中存储一个对驾驶这辆车的士兵的引用。假设我们的jeep最多存储四个人；我们如何在代码中做到这一点？多态很容易处理这个问题。</p><p id="71c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理这个问题的一个简单方法是为吉普车中的每个座位引用<code class="fe mz na nb nc b">Soldier</code>，两个在前，两个在后。因为多态性使我们能够将对象视为其他对象，将<code class="fe mz na nb nc b">JetpackSoldier</code>视为<code class="fe mz na nb nc b">Soldier</code>，所以我们可以将<code class="fe mz na nb nc b">JetpackSoldier</code>和<code class="fe mz na nb nc b">Soldier</code>对象都添加到<code class="fe mz na nb nc b">Jeep</code>类中。如果我们在游戏中加入更多的士兵，只要他们继承了<code class="fe mz na nb nc b">Soldier</code>的血统，他们也可以被加入到吉普职业中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续前面的例子，如果我们想要存储不同的士兵类型，我们必须添加额外的成员变量和方法来支持它。我们还需要更多的检查才能把一个士兵放进吉普车。</p><p id="1a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你可能已经猜到的，随着我们的游戏变得越来越复杂，我们有许多<code class="fe mz na nb nc b">Soldier</code>的变体，当我们试图支持所有不同的士兵进入车辆时，<code class="fe mz na nb nc b">Jeep</code>职业将变得越来越复杂。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e15" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多态性的好处</h1><p id="3041" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从上一节中，我们可以看到多态性的一个优点是它允许我们重用现有的代码，这可以使事情更容易阅读和维护。</p><p id="8265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，另一个我们只简单提到的大优势是，多态允许我们“通过一个公共接口与一组不同的类交互来隐藏实现细节。”这意味着我们可以拥有一个与许多对象交互的类，这些对象通过这些对象共享的方法继承自同一个基类。共享的方法被称为接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="686d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的是，仅仅因为我们在所有的<code class="fe mz na nb nc b">Soldier</code>对象上调用相同的方法，并不意味着它们都做相同的事情。回想一下，当对类型为<code class="fe mz na nb nc b">JetpackSoldier</code>的对象调用escape时，它们将通过飞走而不是奔跑来逃离，因为它们覆盖了基类Soldier中的<strong class="lb iu"> </strong>方法。</p><p id="fef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用共享接口与对象交互的好处是我们已经讨论过的所有事情，同时也限制了我们的类之间的耦合量。耦合是指我们的代码可以紧密地链接在一起，这使得在不破坏内容的情况下很难进行更改。如果我们在游戏中增加了额外的士兵，只要士兵类型共享相同的界面，我们的指挥官职业就不需要改变。</p><p id="dc57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果我们增加或减少接口，依赖于该接口的类如SquadCommander需要改变，要么适应新的行为，要么删除不再需要的行为。重要的是，我们可以添加额外的士兵类型，而不必改变任何东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f41b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多态性和性能</h1><p id="52ca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">然而，尽管多态性如此美妙，但也有一个缺点，那就是它对性能的潜在影响。</p><p id="0451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经讨论了多态如何允许我们通过一个接口调用所有从某个基类继承的对象，同时还允许我们调用特定于该类的方法。如果我们在类型为<code class="fe mz na nb nc b">Soldier</code>的变量中存储了一个<code class="fe mz na nb nc b">JetpackSolider</code>类，并调用<code class="fe mz na nb nc b">Flee()</code>，士兵仍然会飞走而不是逃跑，即使它被存储为<code class="fe mz na nb nc b">Soldier</code>。</p><p id="fdf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">允许这种行为的同样的事情也会导致我们代码的性能问题。</p><p id="d06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会详细讨论多态在C++中是如何实现的。我在这篇文章的底部留下了几个链接，如果有人感兴趣，可以很好地解释。</p><p id="eba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的目的，您需要知道的是多态行为在C++中是通过使用一种叫做虚拟表的东西来实现的。虚拟表是一个数组，它存储一个类的所有虚函数的地址。当对虚拟函数进行调用时，代码必须导航到虚拟表，查找要调用的函数，然后转到地址并调用该函数。对于一个普通的非虚函数，我们只需访问函数的地址。在计算机已经在做大量工作的某些情况下，这些额外的步骤会降低速度。</p><p id="a344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我说在某些情况下，我的意思是在某些情况下。一般来说，使用多态性可能引起的性能问题不会引起关注。但我认为这是值得一提的；为了完全理解多态性，理解任何优点和缺点是很重要的。为了性能而失去对象多态性带来的灵活性是不值得的，除非你知道这会引起问题。最好拥抱多态性，只有当它成为问题时才考虑移除它。这是通过剖析表现出来的，而不仅仅是通过思考</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0300" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="3953" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">多态性本来就好。它指的是有多种形式的东西，既指对象，也指方法。多态性允许您对接口进行编码，减少耦合，增加可重用性，并使您的代码更容易阅读。在某些情况下，使用多态性可能会降低性能，但这并不意味着我们应该避免它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0337" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步阅读</h1><ul class=""><li id="2c04" class="nr ns it lb b lc mu lf mv li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Polymorphism _(computer _ science)</a></li><li id="4ca2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.ianswer4u.com/2017/09/oops-polymorphism-advantages.html" rel="noopener ugc nofollow" target="_blank">https://www . ians wer 4u . com/2017/09/oops-polymorphism-advantages . html</a></li><li id="daed" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">【https://en.wikipedia.org/wiki/Virtual_method_table T4】</li><li id="800c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.learncpp.com/cpp-tutorial/125-the-virtual-table/" rel="noopener ugc nofollow" target="_blank">https://www . learn CPP . com/CPP-tutorial/125-the-virtual-table/</a></li></ul></div></div>    
</body>
</html>