<html>
<head>
<title>Exploring Next.js 13 Server Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Next.js 13服务器组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fun-with-next-js-13-server-components-fd5f886c31f3?source=collection_archive---------2-----------------------#2022-11-25">https://betterprogramming.pub/fun-with-next-js-13-server-components-fd5f886c31f3?source=collection_archive---------2-----------------------#2022-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c526" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Next.js 13测试版特性的快速概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fff2a9321ff4f3ae83086696407195fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PUhd76SCsegKBsYc.png"/></div></div></figure><p id="3d5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Next.js 13以一种有些令人困惑的方式登陆。增加了许多显著的东西；不过，好的部分还是Beta。尽管如此，Beta特性给了我们关于Next.js的未来将如何形成的重要信号，所以有很好的理由密切关注它们，即使你打算等待采用它们。</p><p id="f60c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文是关于Beta特性的系列体验的一部分。今天我们来玩一下服务器组件。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="f466" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将服务器组件作为默认选项可以说是Next.js 13中最大胆的改变。服务器组件的目标是通过只在服务器端保存组件代码来减少发送到客户机的JS的大小。即，呈现发生并且仅发生在服务器端，即使组件的加载是在客户端触发的(通过客户端路由)。这是一个相当大的范式转变。</p><p id="ce68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我第一次知道React服务器组件是在一年多以前，通过这个视频(以后再看，它很长):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="bed9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那时候感觉相当“研究性”，所以当我看到Next.js现在已经把自己的未来押在它身上时，我感到震惊。时光飞逝，React的工程师们一定做了一些非常棒的工作，所以我创建了一个闪亮的新Next.js 13项目来玩它。</p><pre class="kg kh ki kj gt lw lx ly bn lz ma bi"><span id="e051" class="mb mc iq lx b be md me l mf mg">npx create-next-app@latest --experimental-app --ts --eslint next13-server-components</span></pre><p id="f575" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们玩这个项目玩得开心点。你可以在这里找到完整的项目代码<a class="ae mh" href="https://stackblitz.com/edit/nextjs-8mmekk" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="87fb" class="mi mc iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">服务器组件</h1><p id="cd92" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">注意到的第一个不同是一个新的<code class="fe ne nf ng lx b">app</code>文件夹现在和我们的老朋友<code class="fe ne nf ng lx b">page</code>放在一起。我将把路由更改保存到另一篇文章中，但现在值得一提的是，默认情况下，<code class="fe ne nf ng lx b">app</code>文件夹下的每个组件都是服务器组件，这意味着它呈现在服务器端，其代码保留在服务器端。</p><p id="fc94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们创建我们的第一个服务器组件:</p><pre class="kg kh ki kj gt lw lx ly bn lz ma bi"><span id="2140" class="mb mc iq lx b be md me l mf mg">// app/server/page.tsx<br/><br/>export default function Server() {<br/>    console.log('Server page rendering: this should only be printed on the server');<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Server Page&lt;/h1&gt;<br/>            &lt;p&gt;My secret key: {process.env.MY_SECRET_ENV}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="ff27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您访问<code class="fe ne nf ng lx b">/server</code>路由，无论是通过新的浏览器加载还是客户端路由，您都只能在服务器控制台中看到该行日志，而不能在浏览器控制台中看到。环境变量值也是从服务器端获取的。</p><p id="8aa3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在浏览器中查看网络流量，您会看到服务器组件的内容是通过远程调用加载的，该调用返回渲染结果的JSON数据的八位字节流:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/dae24d124bf488edac51a4b84bd3f293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*efJv6wbmbZRzA6yP.png"/></div></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">服务器组件网络流量</p></figure><pre class="kg kh ki kj gt lw lx ly bn lz ma bi"><span id="f3ac" class="mb mc iq lx b be md me l mf mg">{<br/>    ...<br/>    "childProp": {<br/>        "current": [<br/>            [<br/>                "$",<br/>                "div",<br/>                null,<br/>                {<br/>                    "children": [<br/>                        ["$", "h1", null, { "children": "Server Page" }],<br/>                        [<br/>                            "$",<br/>                            "p",<br/>                            null,<br/>                            {<br/>                                "children": ["My secret key: ", "abc123"]<br/>                            }<br/>                        ]<br/>                    ]<br/>                }<br/>            ]<br/>        ]<br/>    }<br/>}</span></pre><p id="adcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">呈现服务器组件实际上是一个API调用，用于获取序列化的虚拟DOM，然后在浏览器中将其具体化。</p><p id="c87b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要记住的最重要的事情是，服务器组件是用来呈现非交互式内容的，所以没有事件处理程序、没有React挂钩，也没有浏览器专用的API。</p><p id="24a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最大的好处是你可以自由地访问服务器组件中的任何后端资源和秘密。更安全(数据不泄露)，更快(代码不泄露)。</p><h1 id="1f80" class="mi mc iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">客户端组件</h1><p id="cfbe" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">要创建一个客户端组件，您需要用<code class="fe ne nf ng lx b">use client</code>明确地标记它:</p><pre class="kg kh ki kj gt lw lx ly bn lz ma bi"><span id="4b58" class="mb mc iq lx b be md me l mf mg">// app/client/page.tsx<br/><br/>'use client';<br/><br/>import { useEffect } from 'react';<br/><br/>export default function Client() {<br/>    console.log(<br/>        'Client page rendering: this should only be printed on the server during ssr, and client when routing'<br/>    );<br/><br/>    useEffect(() =&gt; {<br/>        console.log('Client component rendered');<br/>    });<br/><br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Client Page&lt;/h1&gt;<br/>            {/* Uncommenting this will result in an error complaining about inconsistent<br/>            rendering between client and server, which is very true */}<br/>            {/* &lt;p&gt;My secret env: {process.env.MY_SECRET_ENV}&lt;/p&gt; */}<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="54c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您可能已经预料到的，这为您提供了与以前的Next.js版本类似的行为。</p><p id="d6ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当页面第一次加载时，它是由SSR呈现的，所以您应该在服务器控制台中看到第一个日志；在客户端路由期间，两个日志消息都将出现在浏览器控制台中。</p><h1 id="058c" class="mi mc iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">混合搭配</h1><p id="36d4" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">服务器组件和SSR最大的区别之一就是SSR是页面级的，而服务器组件顾名思义是组件级的。这意味着你可以在一个渲染树中随意混合和匹配服务器和客户端组件。</p><pre class="kg kh ki kj gt lw lx ly bn lz ma bi"><span id="7367" class="mb mc iq lx b be md me l mf mg">// A server page containing client component and nested server component<br/><br/>// app/mixmatch/page.tsx<br/>import Client from './client';<br/>import NestedServer from './nested-server';<br/><br/>export default function MixMatchPage() {<br/>    console.log('MixMatchPage rendering');<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Server Page&lt;/h1&gt;<br/>            &lt;div className="box"&gt;<br/>                &lt;Client message="A message from server"&gt;<br/>                    &lt;NestedServer /&gt;<br/>                &lt;/Client&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><pre class="nm lw lx ly bn lz ma bi"><span id="54be" class="mb mc iq lx b be md me l mf mg">// app/mixmatch/client.tsx<br/>'use client';<br/><br/>import { useEffect } from 'react';<br/><br/>export default function Client({<br/>    message,<br/>    children,<br/>}: {<br/>    message: string;<br/>    children: React.ReactNode;<br/>}) {<br/>    console.log('Client component rendering');<br/><br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h2&gt;Client Child&lt;/h2&gt;<br/>            &lt;p&gt;Message from parent: {message}&lt;/p&gt;<br/>            &lt;div className="box-red"&gt;{children}&lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><pre class="nm lw lx ly bn lz ma bi"><span id="3a1d" class="mb mc iq lx b be md me l mf mg">// app/mixmatch/nested-server.tsx<br/><br/>export default function NestedServer() {<br/>    console.log('Nested server component rendering');<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h3&gt;Nested Server&lt;/h3&gt;<br/>            &lt;p&gt;Nested server content&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/8fae774fc03f95ff535ae56cfe312d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p5YOd15gLd__rakZ.png"/></div></div><p class="ni nj gj gh gi nk nl bd b be z dk translated">在页面中混合服务器和客户端组件</p></figure><p id="b5c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这样的混合场景中，服务器和客户端组件独立呈现，结果由React运行时组装。从服务器组件传递到客户机组件的属性在网络上是序列化的(并且需要是可序列化的)。</p><h1 id="a684" class="mi mc iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">服务器组件可能会退化</h1><p id="cb53" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">您需要注意的一点是，如果一个服务器组件被直接导入到客户机组件中，它会悄悄地退化为客户机组件。</p><p id="696e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们稍微修改一下前面的例子来观察它:</p><pre class="kg kh ki kj gt lw lx ly bn lz ma bi"><span id="5aba" class="mb mc iq lx b be md me l mf mg">// app/degenerate/page.tsx<br/><br/>import Client from './client';<br/><br/>export default function DegeneratePage() {<br/>    console.log('Degenerated page rendering');<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Degenerated Page&lt;/h1&gt;<br/>            &lt;div className="box-blue"&gt;<br/>                &lt;Client message="A message from server" /&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><pre class="nm lw lx ly bn lz ma bi"><span id="51b0" class="mb mc iq lx b be md me l mf mg">// app/degenerate/client.tsx<br/><br/>'use client';<br/><br/>import NestedServer from './nested-server';<br/><br/>export default function Client({ message }: { message: string }) {<br/>    console.log('Client component rendering');<br/><br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h2&gt;Client Child&lt;/h2&gt;<br/>            &lt;p&gt;Message from parent: {message}&lt;/p&gt;<br/>            &lt;div className="box-blue"&gt;<br/>                &lt;NestedServer /&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><pre class="nm lw lx ly bn lz ma bi"><span id="0f8c" class="mb mc iq lx b be md me l mf mg">// app/degenerated/nested-server.tsx<br/><br/>export default function NestedServer() {<br/>    console.log('Nested server component rendering');<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h3&gt;Degenerated Server&lt;/h3&gt;<br/>            &lt;p&gt;Degenerated server content&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="5f58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你查看日志，你会看到<code class="fe ne nf ng lx b">NestedServer</code>已经“退化”,现在由浏览器渲染。</p><h1 id="44c6" class="mi mc iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">是更好的未来吗？</h1><p id="e93d" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">Next.js正在尽一切努力将东西转移到服务器端，这正是二十年前人们进行web开发的方式。所以现在我们完成了一个完整的循环，但大大改善了开发体验和最终用户体验。</p><p id="44ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于最终用户来说，这是一个明显的胜利，因为服务器端的计算更快、更可靠。结果将是更快速的第一内容绘制。</p><p id="3a7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于开发人员来说，范式转换将是精神上的挑战，混合着困惑、错误和反模式。这将是一次地狱般的旅行。</p><p id="2043" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。</p><pre class="kg kh ki kj gt lw lx ly bn lz ma bi"><span id="8ac0" class="mb mc iq lx b be md me l nn mg">Want to Connect?<br/><br/>I'm the creator of <a class="ae mh" href="https://zenstack.dev/?utm_campaign=medium&amp;utm_medium=organic&amp;utm_content=nextjs_server_components" rel="noopener ugc nofollow" target="_blank">ZenStack</a>, a toolkit that supercharges<br/>Prisma ORM with a powerful access control layer and <br/>unleashes its full potential for full-stack development.<br/>Our goal is to let you save time writing boilerplate code <br/>and focus on building what matters - the user experience.</span></pre></div></div>    
</body>
</html>