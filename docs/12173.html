<html>
<head>
<title>Create the Classic Ping-pong Game With Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java创建经典的乒乓球游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-the-classic-ping-pong-game-3aea1f7b16e6?source=collection_archive---------4-----------------------#2022-05-17">https://betterprogramming.pub/create-the-classic-ping-pong-game-3aea1f7b16e6?source=collection_archive---------4-----------------------#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fcd2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Java和处理库教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/ec91cc81bdf738047938109a9cf4926f.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/1*D03gtwOfjTPb6TLb7hW2BA.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">一个GIF展示了这篇文章中的乒乓球游戏。</p></figure><p id="913b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你正在寻找一个解释如何重现经典乒乓球游戏的教程吗？然后，不要再看了，本文主要关注使用处理库和Java重新创建游戏。我还写了另一篇文章，关于如果你想创建另一个游戏，如何重新创建经典的贪吃蛇游戏。</p><h1 id="8ada" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">1.下载和安装处理</h1><p id="f5d1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要下载处理程序，请前往processing.org/download的<a class="ae ln" href="https://processing.org/download" rel="noopener ugc nofollow" target="_blank">并选择与首选平台匹配的版本。</a></p><h1 id="3557" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">2.什么是加工？</h1><p id="df9d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Processing提供了一个图形库和一个集成开发环境(IDE ),它使用编程语言Java (Wikipedia，2022a)。</p><h1 id="e007" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">3.游戏要求</h1><p id="ff22" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">该游戏的要求分为两个不同的部分。第一部分描述了与表现球员、球和环境相关的视觉要求。第二部分描述了不同对象和应用程序应该如何表现的功能需求。</p><h2 id="9ae7" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">3.1视觉要求</h2><ul class=""><li id="87ed" class="mx my iq kt b ku mg kx mh la mz le na li nb lm nc nd ne nf bi translated">玩家对象应该用一个矩形来表示。</li><li id="bbac" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">球对象应该用一个圆来表示。</li><li id="87bb" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">游戏应该包含两个显示每个玩家分数的文本元素。</li></ul><h2 id="dcff" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">3.1功能要求</h2><ul class=""><li id="b6bb" class="mx my iq kt b ku mg kx mh la mz le na li nb lm nc nd ne nf bi translated">玩家对象应该只能在y轴上移动。</li><li id="b0f3" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">球对象应该能够在x轴和y轴上移动。</li><li id="7386" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">如果球对象与玩家对象重叠，它应该在x轴上将其方向更改为相反的方向。</li><li id="b08c" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">如果球对象在y轴上移动到屏幕之外，它应该将其在y轴上的方向改变到相反的方向。</li><li id="295a" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">如果球对象在x轴上移出屏幕，它的位置和方向应该被重置。</li><li id="f783" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">每当球移出对面的屏幕，一名球员就得一分。</li><li id="6f78" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">第一个播放器应该由键盘控制，第二个播放器由电脑控制。</li></ul><h1 id="704e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">4.游戏对象</h1><p id="e813" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">该游戏将包含两个不同的类，一个表示球员对象，另一个表示球对象。图1显示了包含这两个类的UML类图。对于那些从未听说过UML类图的人来说，它仅仅是一个包含系统的类、属性、方法和关系的图表(Wikipedia，2022b)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/472ba30c56a68139bb1bf05eb886a8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6QWaNLHKy_FDdIDqwSp3A.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="bd nq">图1: </strong>一个UML类图，展示了乒乓球游戏中使用的两个类。</p></figure><h2 id="2aea" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">4.1玩家对象</h2><p id="3315" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">player类将用于为两个玩家创建对象，因此，重要的是位置和y方向对于每个玩家都是唯一的，但是可以说宽度、高度和边界可以是静态变量，因为所有对象上的值都是相同的。图2说明了运动员的定位和他们运动的界限背后的想法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ad1cf6db7f57a8e975bbdd78570f90fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/1*zkqNiw_HBiFvZdsjUhMswQ.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="bd nq">图2: </strong>一个GIF显示了每个玩家的属性以及他们可以移动的路径(红线)。</p></figure><p id="890b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 4.1.1。玩家属性</strong></p><p id="e816" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该类需要五个属性(见图1)，每个属性都有以下用途:</p><ul class=""><li id="67c2" class="mx my iq kt b ku kv kx ky la ns le nt li nu lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">position</code> —定义玩家x和y位置的<code class="fe nv nw nx ny b">PVector</code>。</li><li id="7c43" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">yDir</code> —一个<code class="fe nv nw nx ny b">float</code>，定义玩家移动的方向和速度。</li><li id="2ecd" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">w</code>—<code class="fe nv nw nx ny b">float</code>定义玩家矩形的宽度。</li><li id="8b00" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">h</code>—<code class="fe nv nw nx ny b">float</code>定义玩家矩形的高度。</li><li id="d2f2" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">b</code>—<code class="fe nv nw nx ny b">float</code>定义玩家移动的边界。</li></ul><p id="71fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">player类中属性的实现如图3所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图3: </strong>展示了player类中属性的实现。</p></figure><p id="fdf7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 4.1.2。玩家方法</strong></p><p id="5ee7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该类还需要五个方法(见图1)，每个属性都有以下用途:</p><ul class=""><li id="47e9" class="mx my iq kt b ku kv kx ky la ns le nt li nu lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">update()</code> —一种void方法，用于更新与移动、边界检查和绘制可视对象相关的玩家行为。</li><li id="b482" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">setDirection(yDir)</code> —用于更新y轴上玩家对象方向的setter方法。</li><li id="9bb1" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">getPosition()</code> —返回玩家对象位置的getter方法。</li><li id="bcf2" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">getHeight()</code> —返回玩家对象高度的getter方法。</li><li id="6652" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">getWidth()</code> —返回播放器对象宽度的getter方法。</li></ul><p id="2877" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Player类还需要一个构造函数来设置y轴上位置和方向的初始值。构造函数的参数被设计成用<code class="fe nv nw nx ny b">floats</code>来表示开始位置，在构造函数中它被用来为玩家的位置创建一个新的<code class="fe nv nw nx ny b">PVector</code>对象的实例。</p><p id="aec7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将确保玩家对象不会引用内存中的同一个<code class="fe nv nw nx ny b">PVector</code>对象，如果几个玩家对象在实例化时被赋予同一个<code class="fe nv nw nx ny b">PVector</code>对象，就会出现这种情况。</p><p id="2c81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">方向的getter方法允许在类外的对象上设置方向，位置、高度和宽度的setter方法允许在类外的对象上读取这些属性(参见图4中的实现)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图4: </strong>显示了播放器构造函数、getter和setter方法的实现。</p></figure><p id="e0ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">玩家类中需要的最后一个方法是<code class="fe nv nw nx ny b">update()</code>方法。图5显示了该方法的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图5: </strong>展示了播放器更新方法的实现。</p></figure><p id="0719" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其行为可描述如下:</p><ul class=""><li id="b121" class="mx my iq kt b ku kv kx ky la ns le nt li nu lm nc nd ne nf bi translated">第10行——如果<code class="fe nv nw nx ny b">ydir</code>的值为正，该行将增加玩家的y位置，如果<code class="fe nv nw nx ny b">ydir</code>的值为负，该行将减少玩家的y位置。</li><li id="3cd4" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">第14行—第一行检查玩家的y位置是否小于用于定义玩家移动边界的<code class="fe nv nw nx ny b">b</code>的值。或者换句话说，如果玩家已经到达屏幕顶部的边界。</li><li id="1bb8" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">第16行——将玩家的y位置重置为值<code class="fe nv nw nx ny b">b</code>,以防止其进一步向屏幕顶部移动。</li><li id="df1f" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">第19行——类似于第14行的检查，但是检查玩家是否已经到达屏幕的底部。该检查包括玩家的身高和<code class="fe nv nw nx ny b">b</code>的值，以确保矩形停在正确的位置(参见图6的解释)。</li><li id="703d" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">第21行——在屏幕底部重置玩家的y位置，以防止其在y轴上移出屏幕。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8804ffc492f3fd10bc4a8ce1afe24c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*P0PDw4bywL3o9TFGWNP42A.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="bd nq">图6: </strong>玩家对象在锚点(position属性的值)移动，因此它应该在屏幕高度减去<code class="fe nv nw nx ny b">b</code>和<code class="fe nv nw nx ny b">h</code>后停止，以确保矩形在其底边到达边界时停止。</p></figure><p id="948b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">玩家类的最后一个例子可以在<a class="ae ln" href="https://gist.github.com/niiicolai/132af98673f96ea33671593c769ad389" rel="noopener ugc nofollow" target="_blank">这个链接中找到。</a></p><h2 id="a631" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">4.2球对象</h2><p id="b2f8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">ball类与player类非常相似，但是它可以在x轴和y轴上移动。图7展示了球在移动时位置和方向的值是如何变化的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1f79b327530b741c970fe9cfa0720859.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/1*eZVYlENJnOsIzNCrzmgOzw.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="bd nq">图7: </strong>显示球对象属性的GIF。</p></figure><p id="73f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 4.1.1。球的属性</strong></p><p id="aa7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图1显示了ball类需要四个属性，可以描述如下:</p><ul class=""><li id="6d04" class="mx my iq kt b ku kv kx ky la ns le nt li nu lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">position</code>—<code class="fe nv nw nx ny b">PVector</code>定义球的x和y位置。</li><li id="0173" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">direction</code>—<code class="fe nv nw nx ny b">PVector</code>定义球运动的方向和速度。</li><li id="fb03" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">d</code>—<code class="fe nv nw nx ny b">float</code>定义了球的圆的直径。</li><li id="ca8e" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">s</code>—<code class="fe nv nw nx ny b">float</code>定义球的开始速度。</li></ul><p id="d091" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">球的属性的实现可以在图8中看到。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图8: </strong>球类中属性的实现。</p></figure><p id="9700" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 4.1.2。球法</strong></p><p id="6a00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ball类也应该像player类一样有五个方法，如下所述:</p><ul class=""><li id="3278" class="mx my iq kt b ku kv kx ky la ns le nt li nu lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">update()</code> —更新球的移动、边界和视觉效果的无效方法。</li><li id="f050" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">getPosition()</code> —返回球的位置的getter方法。</li><li id="fcce" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">resetMovement()</code> —将球的位置重置到屏幕中心并将其方向重置为随机值的无效方法。</li><li id="82f8" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">setDirection(x)</code>—设置球的x方向的setter方法。</li><li id="cfcb" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated"><code class="fe nv nw nx ny b">overlapsWith(player)</code> —如果球与给定球员重叠，布尔方法返回true。</li></ul><p id="5c2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">球的构造函数和方法<code class="fe nv nw nx ny b">getPosition()</code>、<code class="fe nv nw nx ny b">resetMovement()</code>、<code class="fe nv nw nx ny b">setDirection(x)</code>和<code class="fe nv nw nx ny b">update()</code>的实现如图9所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图9: </strong>球的构造函数的实现，以及方法getPosition()、resetMovement()、invertDirectionX()和update()。</p></figure><p id="a360" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 4.1.2。碰撞方法</strong></p><p id="83c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该在ball类中实现的最后一个方法是<code class="fe nv nw nx ny b">overlapsWith(player)</code>方法。在展示实现之前，我想简单描述一下解决方案背后的数学思想。</p><p id="7b67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图10显示了在一个坐标系中绘制的球，锚点位于origo。锚点等于球的<code class="fe nv nw nx ny b">position</code>属性。</p><p id="5f39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图中的每个向量/箭头都指向相对于锚点的一个点，该点应该在碰撞检查中使用。可以通过将角度转换为弧度的公式和旋转矩阵来计算这些点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/962aafda2ef626479faa21d8519c51ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*05icJeA0UlSR3Mk6PZIWqg.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="bd nq">图10: </strong>图为在一个坐标系内绘制的球。锚点是球的位置，每个向量/箭头指向相对于球的锚点的一个点。每个向量旋转45度。</p></figure><p id="2674" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将角度转换为弧度的公式可以定义为(Wikipedia，2022c):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/fc7c1b62d9e2d1a5fd6340527336f520.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*IDZl8L7VZiMOIll7-eXLsg.png"/></div></figure><p id="8dcf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">旋转矢量<strong class="kt ir"> <em class="of"> v，</em> </strong> θ弧度的公式可以定义为(维基百科，2022d):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8b911b546b661f805d4e4f1faee3f010.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*sCz_s5D6xkReNbq_lmQgVQ.png"/></div></figure><p id="d83c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用上面的公式计算出的点被用来检查其中一个是否在一个球员的角点之间，这意味着球与该球员重叠(见图11)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d53f802773be6eb13790f1ee072cb612.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*mwHzxTiDzaf0Ew1JIq8kVw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="bd nq">图11: </strong>图中显示了一个球员对象与球对象重叠。它还根据玩家的位置、宽度和高度属性显示每个角点。</p></figure><p id="52d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图12中的第24行显示了用于将角度转换为弧度的公式的实现，图12中的第28–29行显示了用于将2D矢量旋转45度的旋转矩阵的实现。</p><p id="e45c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">图12中的第33–34行显示了如果点在玩家的角点内，则检查返回true。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图12: </strong>该图显示了‘overlapsWith(player)’方法的实现。</p></figure><p id="4738" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">球类的最后一个例子可以在<a class="ae ln" href="https://gist.github.com/niiicolai/b7bf280f984e6902c4a4573db6987864" rel="noopener ugc nofollow" target="_blank">这个链接中找到。</a></p><h1 id="5956" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">5.设置处理控制流</h1><p id="243c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">应用程序需要三种处理方法，一旦应用程序启动就执行的<code class="fe nv nw nx ny b">setup()</code>方法(Processing.org，2022a)，每帧执行一次直到停止的<code class="fe nv nw nx ny b">draw()</code>方法(Processing.org，2022b)，以及当按键被按下时执行的<code class="fe nv nw nx ny b">keyPressed()</code>方法(Processing.org，2022c)。</p><h2 id="7945" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">5.1全局属性</h2><p id="adba" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这个游戏需要几个全局属性来引用球员对象、球对象、速度和球员得分(参见图13)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图13: </strong>展示了游戏全局属性的实现。</p></figure><h2 id="648e" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">5.2设置</h2><p id="32d5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><code class="fe nv nw nx ny b">setup()</code>方法用于初始化球员和球实例，并设置屏幕尺寸(参见图14)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图14: </strong>展示了游戏的设置方法的实现。</p></figure><h2 id="64ac" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">5.3抽签</h2><p id="9cae" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><code class="fe nv nw nx ny b">draw()</code>方法用于游戏的重复逻辑。图15中的第20–33行显示了一个if-和else if-语句，用于检查球是否在屏幕之外，如果是，其中一名球员将得到一分，球的位置和方向将被重置。图14中的第36–29行显示了一个检查，如果其中一个玩家与反转球的x方向的球重叠，则该检查评估为真。图14中的第43–58行显示了计算机如何控制其球员对象(<code class="fe nv nw nx ny b">p2</code>)的一个小实现，第61–64行显示了球员得分文本的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图15: </strong>展示了游戏的draw方法的实现。</p></figure><h2 id="4dc4" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">5.4按键</h2><p id="54bd" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">游戏需要的最后一个代码是用于处理移动<code class="fe nv nw nx ny b">p1</code>对象的键盘事件的功能(参见图16)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><strong class="ak">图16: </strong>展示了游戏的按键方法的实现。</p></figure><h1 id="e487" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">6.摘要</h1><p id="5ed0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">本文中的乒乓球游戏是使用处理库和Java创建的。它包含两个类，一个用于表示球员对象的<code class="fe nv nw nx ny b">Player</code>类和一个用于表示球对象的<code class="fe nv nw nx ny b">Ball</code>类。</p><p id="bd35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些类在Processing的<code class="fe nv nw nx ny b">setup()</code> <code class="fe nv nw nx ny b">draw()</code>和<code class="fe nv nw nx ny b">keyPressed()</code>方法中一起使用来设置游戏的连续行为和结构。第一个玩家对象可以使用<code class="fe nv nw nx ny b">s</code>和<code class="fe nv nw nx ny b">w</code>通过键盘控制，第二个玩家由电脑控制。</p><p id="6aaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整游戏的例子可以在<a class="ae ln" href="https://gist.github.com/niiicolai/246eba2b9d8c76355e5e89b5d8af6d95" rel="noopener ugc nofollow" target="_blank">这个链接中找到。</a></p><h1 id="e9f9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">文献学</h1><p id="4508" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">En.wikipedia.org(2022年)。<em class="of">处理(编程语言)—维基百科</em>。[在线]见:&lt;<a class="ae ln" href="https://en.wikipedia.org/wiki/Processing_(programming_language)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Processing _(programming _ language)</a>&gt;【2022年4月30日访问】。</p><p id="131a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">En.wikipedia.org(2022 b)。<em class="of">类图——维基百科</em>。[在线]可在:&lt;<a class="ae ln" href="https://en.wikipedia.org/wiki/Class_diagram" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Class_diagram</a>&gt;【2022年5月16日访问】。</p><p id="59c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">En.wikipedia.org。<em class="of">弧度—维基百科</em>。[在线]可在:&lt;<a class="ae ln" href="https://en.wikipedia.org/wiki/Radian" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Radian</a>&gt;【2022年5月17日访问】。</p><p id="ba59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">En.wikipedia.org。(2022d)。<em class="of">旋转矩阵—维基百科</em>。[在线]可在https://en.wikipedia.org/wiki/Rotation_matrix&gt;【2022年5月17日】的&lt; <a class="ae ln" href="https://en.wikipedia.org/wiki/Rotation_matrix" rel="noopener ugc nofollow" target="_blank">找到。</a></p><p id="c4b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Processing.org(2022年)。设置()[在线]可在:【https://processing.org/reference/setup_.html&gt;【2022年4月30日访问】&lt;<a class="ae ln" href="https://processing.org/reference/setup_.html" rel="noopener ugc nofollow" target="_blank">获得。</a></p><p id="4588" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Processing.org(2022 b)。draw()[在线]可在:&lt;<a class="ae ln" href="https://processing.org/reference/draw_.html" rel="noopener ugc nofollow" target="_blank">https://processing.org/reference/draw_.html</a>&gt;【2022年4月30日访问】。</p><p id="a755" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Processing.org。keyPressed在线]可在:&lt;<a class="ae ln" href="https://processing.org/reference/keyPressed_.html" rel="noopener ugc nofollow" target="_blank">https://processing.org/reference/keyPressed_.html</a>&gt;【2022年4月30日获取】。</p></div></div>    
</body>
</html>