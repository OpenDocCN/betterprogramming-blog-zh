<html>
<head>
<title>Merge Sort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的合并排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/merge-sort-in-javascript-ce6e0e8b8fb2?source=collection_archive---------9-----------------------#2020-01-30">https://betterprogramming.pub/merge-sort-in-javascript-ce6e0e8b8fb2?source=collection_archive---------9-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="317a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释、要点和例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f16c0863bbe5f29368513db0c73edecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsrBZUZOqN1G_wJwlJJTnw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.pxfuel.com/en/free-photo-eyedi" rel="noopener ugc nofollow" target="_blank"> Pxfuel </a>提供</p></figure><p id="57a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只想要密码？向下滚动到代码的三个版本:</p><ol class=""><li id="ae50" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">不带注释(即插即用)。</li><li id="cf4f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">另一个用注释来理解代码。</li><li id="fbcd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">另一个包含控制台日志和一个示例，以了解一切是如何工作的。</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bf47" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么是合并排序？</h1><p id="fc16" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">合并排序是一种排序算法，它将一个问题分解成两个或更多类似的子问题，直到最初的问题变得足够容易直接解决。</p><p id="7fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Merge sort会将一个输入数组分成两半，并一直这样做，直到它变成一个元素。然后，它会合并两半，同时对它们进行排序，直到我们只到达一个数组。这是一个合并排序的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/048ffb64a290ca6feaaadf98d552220b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*5N_oJ40Yheaqh3lX5cvpJg.png"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f025" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">使用合并排序对数组进行排序的步骤</h1><p id="b4f5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">最简单的实现是使用递归函数。下面是我们排序数组需要采取的步骤。</p><ol class=""><li id="7e83" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">检查传入数组的长度是否为1——如果是，我们返回元素并开始合并。</li><li id="406c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">否则，我们继续将数组一分为二，直到它与步骤1中的条件匹配。</li><li id="0d49" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当组合时，我们有两个数组:左数组或右数组。我们总是假设两个数组都已经排序了，所以我们可以比较每个数组的起始索引，然后加上最小的数字。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/4300dee9f0581fef7cba45352ba7de79.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*opwN0BhtH4zvPF697fPlow.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示合并排序的GIF</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f51f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">JavaScript中的合并排序(带递归)</h1><p id="7a02" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们从main函数开始，在这个函数中，我们将未排序的数组拆分成只有一个元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/2df66ceba3c7d361897c0f6125c9de86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_H3JLIewBai2XyLjf3D4QQ.png"/></div></div></figure><p id="ef0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">取一个未排序的数组，首先检查它的长度，看它是否只有一个元素。如果有，我们就原样返回数组。</p><p id="9b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，我们找到中点(在哪里拆分数组)并将数组一分为二，左和右。</p><p id="5358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这部分有点棘手，我们想合并两个数组，但首先我们要组织左和右，并在合并前按顺序排序。为此，我们使用递归并再次调用main函数，这将一直进行下去，直到只剩下一个元素。在这个例子中，它已经被排序了，所以我们开始合并两个数组。</p><p id="9a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要编写合并两个数组的函数——假设它们已经按顺序排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/cf8e3cba1a526188c810a7ea0e09a28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spXQEpOT2vA-nykFdAnOzg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/62c63faae378f9e224a55cf47643039d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39vxrLgq7w7Iqjf9Vc70Mw.png"/></div></div></figure><p id="a80d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有两个数组:左数组和右数组。我们假设一切都已经从最低到最高排序。在开始之前，我们需要三个变量:一个将信息推入的结果数组和两个跟踪每个数组需要哪个索引位置的索引。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6156" class="nx mr it nt b gy ny nz l oa ob">let resultArray = [];<br/>let leftIndex = 0, rightIndex = 0;</span></pre><p id="e89e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们有一个<code class="fe oc od oe nt b">while</code>循环，它将一直运行，直到其中一个索引超出了它所跟踪的数组的边界。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="3207" class="nx mr it nt b gy ny nz l oa ob">while (leftIndex &lt; leftArr.length &amp;&amp; rightIndex &lt; rightArr.length)</span></pre><p id="104e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们比较两个数组，看哪一个更小。一旦我们找到它，我们将把这个值放入结果中，并增加数组的索引跟踪器。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="cf6f" class="nx mr it nt b gy ny nz l oa ob">if (leftArr[leftIndex] &lt; rightArr[rightIndex]) { <br/>  resultArray.push(leftArr[leftIndex]);   leftIndex++;  <br/>} else {   <br/>  resultArray.push(rightArr[rightIndex]);   rightIndex++;  <br/>}</span></pre><p id="9cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将一直循环下去，直到其中一个数组的值用完为止(超出界限)。之后，我们要将未完成数组中的所有值相加，并将其推入我们的结果中。我们通过在push中使用spread操作符来实现这一点。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c81f" class="nx mr it nt b gy ny nz l oa ob">if (leftArr[leftIndex]) {   <br/>  var unaddedElements = leftArr.slice(leftIndex)<br/>  resultArray.push(...unaddedElements);  <br/>} else {  <br/>  var unaddedElements = rightArr.slice(rightIndex)<br/>  resultArray.push(...unaddedElements);  <br/>}</span></pre><p id="97ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在spread操作符之前使用JavaScript，您可以使用<code class="fe oc od oe nt b">concat</code>来代替。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="5a47" class="nx mr it nt b gy ny nz l oa ob">if (leftArr[leftIndex]) {   <br/>  var unaddedElements = leftArr.slice(leftIndex)<br/>  resultArray = resultArray.concat(unaddedElements);<br/>} else {  <br/>  var unaddedElements = rightArr.slice(rightIndex)<br/>  resultArray = resultArray.concat(unaddedElements);<br/>}</span></pre><p id="feac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，你只需要返回结果数组，就大功告成了。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a216" class="nx mr it nt b gy ny nz l oa ob">return resultArray;</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e992" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">就为了密码吗？</h1><p id="cede" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里有一个<a class="ae ky" href="https://gist.github.com/Tonylil/92a73135a9478d04727d7ca12c69209e" rel="noopener ugc nofollow" target="_blank">链接</a>到GitHub gist，三个文件合二为一。</p><h2 id="279f" class="nx mr it bd ms of og dn mw oh oi dp na li oj ok nc lm ol om ne lq on oo ng op bi translated">版本1:只有函数，没有任何注释</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="2ea7" class="nx mr it bd ms of og dn mw oh oi dp na li oj ok nc lm ol om ne lq on oo ng op bi translated">版本2:带注释</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="2050" class="nx mr it bd ms of og dn mw oh oi dp na li oj ok nc lm ol om ne lq on oo ng op bi translated">版本3:带有控制台日志和测试示例</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure></div></div>    
</body>
</html>