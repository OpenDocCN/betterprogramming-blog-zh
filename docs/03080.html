<html>
<head>
<title>Pass Variables As Values and As References in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中将变量作为值和引用传递</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pass-variables-as-a-value-vs-as-a-reference-in-javascript-6956f5d93f7e?source=collection_archive---------8-----------------------#2020-01-19">https://betterprogramming.pub/pass-variables-as-a-value-vs-as-a-reference-in-javascript-6956f5d93f7e?source=collection_archive---------8-----------------------#2020-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="112d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有什么区别？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cab8d808061a8e50c224cb8e20a305cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckWxE4b3zxi1bgZoJFFxOw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@casparrubin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae kv" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="26bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，极客们！</p><p id="76c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你学过一些低级语言，比如C/C++，就像我在大学学的那样，你可能已经知道变量既可以作为值传递，也可以作为引用传递(当然，也可以作为指针传递，但我们不要深究这些细节)。</p><p id="9e36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在C++中，您需要显式地定义它，而在JavaScript中，这种逻辑是内置的。这就是为什么不是所有开始使用JavaScript的开发人员都知道这一关键的差异，这可能会导致许多意想不到的错误。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5a1d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">首先，让我们弄清楚这一切意味着什么</h1><ul class=""><li id="885a" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated"><em class="nc">传值</em>表示新变量只采用初始变量的实际值。即变量不相互依赖，一个变量的变化不会影响另一个变量。</li><li id="7674" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated"><em class="nc">引用传递</em>表示新变量采用初始变量的内存地址。因为两个变量都指向同一个内存地址，所以一个变量的变化会影响另一个变量。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/ca1d8aedd5b3bad0a10469a83a66e939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*n_ZY5LYn2OOKxLiW7ofXJg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我喜欢苹果🍎 🍏</p></figure><p id="6c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，所有原始数据类型(字符串、数字、布尔值)都由<em class="nc">值</em>传递，复杂数据类型如数组和对象由<em class="nc">引用</em>传递。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1657" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">现在我们将使用一些简单的例子来研究它</h1><p id="0c80" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">这里我们使用另一个<code class="fe nm nn no np b">foo</code>变量初始化<code class="fe nm nn no np b">bar</code>变量。因为原始数据类型(在我们的例子中是字符串)是通过值传递的，所以新变量的变化不会影响初始变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="452a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在将变量传递给函数参数时也是如此。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7084" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当我们试图传递一个复杂的变量(例如Object)时，它的行为会完全不同。</p><p id="eaa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我们可以看到，当我们将一个对象传递给另一个变量或函数时，它是作为一个引用来传递的，一个变量的变化会影响到引用同一个内存地址的所有其他变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8eaa" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">但是怎么才能克服默认行为呢？</h1><p id="d668" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">JavaScript不允许显式选择如何传递变量，所以我们需要制定变通办法来改变默认行为。</p><h2 id="ca1f" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">将原始变量作为引用传递</h2><p id="e864" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">除了把原始变量包装成一个对象或数组，然后析构之外，我没有找到其他方法来传递原始变量作为引用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cbdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是从性能的角度来看，这没有任何意义，因为我们需要创建和析构一个复杂的变量。</p><p id="7923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你找到了更好的解决方案，请分享给我们。</p><h2 id="2f54" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">将复杂变量作为值传递</h2><p id="58aa" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">为了将一个复杂变量作为一个值传递，我们只需要复制它。有多种方法可以做到这一点。</p><p id="b524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于对象:</p><ul class=""><li id="27a0" class="mr ms iq ky b kz la lc ld lf oe lj of ln og lr my mz na nb bi translated"><code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noopener ugc nofollow" target="_blank">Object.create()</a></code> —使用现有对象创建新对象。</li><li id="bd5b" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated"><code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank">Object.assign()</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"> </a> —将所有属性从源对象复制到目标对象，并返回结果对象。</li><li id="f12d" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated"><code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" rel="noopener ugc nofollow" target="_blank">Object.entries()</a></code>+<code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" rel="noopener ugc nofollow" target="_blank">Object.fromEntries()</a></code><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" rel="noopener ugc nofollow" target="_blank"/>—<code class="fe nm nn no np b">entries</code>方法将一个对象转换成一个[键，值]对的数组，<code class="fe nm nn no np b">fromEntries</code>方法将它转换回一个新的对象。</li><li id="b521" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a> —创建一个对象的副本。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="710d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于数组:</p><ul class=""><li id="de5b" class="mr ms iq ky b kz la lc ld lf oe lj of ln og lr my mz na nb bi translated"><code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">Array.map()</a></code>-创建包含已定义修改(或不包含已定义修改)的副本。</li><li id="1563" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated"><code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">Array.slice()</a></code> —创建数组一部分的副本(如果调用时不带参数，则创建整个数组的副本)。</li><li id="5754" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated"><code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" rel="noopener ugc nofollow" target="_blank">Array.from()</a></code> —创建数组的副本。</li><li id="e9e5" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展运算符</a> —创建数组的副本。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ff30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我必须警告你，所有这些方法都有一个重要的细节——它们只创建了一个初始变量的浅表副本。这意味着如果在你的数组或对象中有嵌套的复杂变量，它们仍然会被引用复制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="85b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有几种方法可以生成深层副本:</p><ul class=""><li id="a0a4" class="mr ms iq ky b kz la lc ld lf oe lj of ln og lr my mz na nb bi translated"><code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="noopener ugc nofollow" target="_blank">JSON.stringify()</a></code>+<code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" rel="noopener ugc nofollow" target="_blank">JSON.parse()</a></code>—<code class="fe nm nn no np b">stringify</code>方法将变量转换成字符串，然后<code class="fe nm nn no np b">parse</code>方法将字符串转换回变量。</li><li id="429b" class="mr ms iq ky b kz nd lc ne lf nf lj ng ln nh lr my mz na nb bi translated">创建您自己的深度复制方法或使用库方法。如<a class="ae kv" href="https://lodash.com/docs/4.17.15#cloneDeep" rel="noopener ugc nofollow" target="_blank">洛达什的</a> <code class="fe nm nn no np b"><a class="ae kv" href="https://lodash.com/docs/4.17.15#cloneDeep" rel="noopener ugc nofollow" target="_blank">cloneDeep()</a></code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d66a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="dbf2" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">还有最后一个重要通知。使用处理数组和对象的内置方法或库方法时要小心，总是要检查它们是改变了初始变量还是产生了新的变量。</p><p id="d3c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank">Array.pop()</a></code>方法将从初始数组中移除最后一个元素，而<code class="fe nm nn no np b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">Array.filter()</a></code>将产生新的元素。</p></div></div>    
</body>
</html>