<html>
<head>
<title>Create the Match Match/Memory Game in React and Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React和Vue.js中创建匹配匹配/记忆游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-the-match-match-memory-game-in-react-and-vue-js-1026f1df000e?source=collection_archive---------14-----------------------#2020-02-13">https://betterprogramming.pub/create-the-match-match-memory-game-in-react-and-vue-js-1026f1df000e?source=collection_archive---------14-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8dbc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异同用两种不同的框架构建同一个游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/023edf9a3d4c578f8875f981f36cf4a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fHN0GV5VmFGMAtNnTMYHnQ.gif"/></div></div></figure><p id="52c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个孩子，我喜欢比赛比赛的游戏，又名浓度。这是一个很容易理解的纸牌游戏，但是一旦你开始玩，你会很快意识到记住你碰到的每张牌是很困难的。</p><p id="e76e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你玩这个游戏只需要一副牌。规则很简单。所有的牌都面朝下放在一个平面上，每一轮翻两张面朝上。游戏的目的是翻转成对的匹配卡片。</p><p id="e0da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一部分中，我们将在React和Vue中构建匹配匹配的游戏。</p><p id="3e29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在这两个框架中都有经验，我想如果我在每个框架中记录构建相同应用程序的过程可能会有所帮助。目的是向您展示这两种流行的JavaScript框架在代码方面的异同。我不想构建一个标准的应用程序，因为我认为构建一个游戏会更有趣！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="c333" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">应该是什么样子？</h1><p id="ec77" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">上面的图像是这个项目应该的结果。我们不会太注重让它看起来漂亮。如果你愿意，你可以添加额外的CSS。本文的主要目的是让您深入了解React和Vue在代码方面的异同。请随意添加改进或新功能。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a95d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">该开始了！</h1><p id="31ee" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们正在从头开始构建我们的Match Match项目，所以我们需要先创建一个应用程序。在React中，这可以通过以下命令完成:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9e9b" class="mz ly it mv b gy na nb l nc nd">npx create-react-app match-match</span></pre><p id="8f13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ne">注意，我们为此使用了</em><a class="ae nf" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"><em class="ne">Create React App</em></a><em class="ne">项目。</em></p><p id="6ee3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们对Vue使用相同的方法。我们通过<a class="ae nf" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue CLI </a>创建我们的项目:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="688b" class="mz ly it mv b gy na nb l nc nd">vue create match-match</span></pre><p id="1062" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦您启动并运行了您的项目，您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/a547fc150ed8aaf1e4eaa9bf78b12776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENbCQ_s9jSjH4_JDicBMVw.jpeg"/></div></div></figure><p id="15c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那很容易，不是吗？这就是入门的全部！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ad0a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">项目文件结构</h1><p id="5e2a" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">现在我们已经创建了React和Vue项目，我们可以看看文件结构。注意，这是<em class="ne">完成的</em>项目的文件结构。但是，文件夹的结构保持不变。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn ni nj nk nl nm paragraph-image"><img src="../Images/1c13d523092d7b72946b420bf4f8de05.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*1rXP4eHislId19le-ZlmVA.png"/></figure><figure class="nh kn nn nj nk nl nm paragraph-image"><img src="../Images/34760b9720ba7a0c6c8520c400d789c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*Xg2CBnV_HN8xeta4T4GGcQ.png"/></figure></div><p id="61b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两个项目都有一个<code class="fe no np nq mv b">public</code>、<code class="fe no np nq mv b">src</code>和<code class="fe no np nq mv b">node_modules</code>文件夹。不同的是，Vue项目在<code class="fe no np nq mv b">src</code>文件夹中有子文件夹。组件存储在<code class="fe no np nq mv b">components</code>文件夹中，图像等资产存储在<code class="fe no np nq mv b">assets</code>文件夹中。默认情况下，React项目没有子文件夹，但是如果需要，您可以创建子文件夹。</p><p id="830d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，Vue项目的结构更好，文件比React项目少。部分原因是Vue项目中不需要单独的样式表。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0233" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我们需要什么？</h1><p id="bbb5" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">首先，我们需要一个操场。然后，我们需要一副配对卡片。</p><p id="b46d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从我们要制作的第一个组件——<code class="fe no np nq mv b">playfield</code>开始。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn nr nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/bb9fd275fb97cebf286819e6c1b9db96.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*G3AeFrGqZvX7TkDvd0gS6g.png"/></div></figure><figure class="nh kn ns nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c0ebab847b1dab9513cbfa059e571b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*OG4X1_Y64CTvdhqEBN5hnQ.png"/></div></figure></div><p id="dc49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是React和Vue中基本组件的外观。我们已经可以在这个例子中发现一些不同之处。在我们的React组件中，我们通过使用<code class="fe no np nq mv b">import</code>来包含一个样式表。我们的Vue组件的风格包含在组件的其余逻辑中。Vue中不需要单独的样式表。</p><p id="6050" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个微妙的区别是，在React中向元素添加类是由<code class="fe no np nq mv b">className</code>属性而不是<code class="fe no np nq mv b">class</code>完成的，因为<em class="ne">类</em>是一个保留关键字。</p><p id="47ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，您可以使用SCSS来代替CSS。为了简单起见，我选择在这个项目中使用CSS。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4599" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">传递道具</h1><p id="30b7" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">你可能已经注意到了<code class="fe no np nq mv b">Playfield</code>组件有一个叫做<code class="fe no np nq mv b">pairs</code>的道具。它现在还没有被使用，但是这个道具会告诉<code class="fe no np nq mv b">Playfield</code>组件它应该在棋盘上放多少副牌。</p><p id="c6fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两个项目都有一个<code class="fe no np nq mv b">App</code>组件，它是最顶层的组件。这将呈现<code class="fe no np nq mv b">Playfield</code>组件，并通过道具传递对子的数量。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn nt nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ccc1b8c51fca07f693849b78200033df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*4E8zvNyIVkOJd_Er6R2BDA.png"/></div></figure><figure class="nh kn nu nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/0ada72c5b500651f33f82e13e862f4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*OG4X1_Y64CTvdhqEBN5hnQ.png"/></div></figure></div><p id="5410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe no np nq mv b">App</code>组件中呈现<code class="fe no np nq mv b">Playfield</code>组件的方式几乎是相同的。</p><p id="456d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意在Vue例子中的<code class="fe no np nq mv b">pairs</code> prop之前使用的冒号。如果使用冒号，属性的内容将被视为Javascript如果没有，就是一串。通过使用冒号，<code class="fe no np nq mv b">pairs</code>属性被计算为一个数字。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="97cd" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">为卡提取数据</h1><p id="a9c2" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">所有的卡片都需要一个图像。由于卡片的数量是可变的(我们给Playfield组件添加了<code class="fe no np nq mv b">pairs</code>道具),我们不知道我们需要多少张图片。这就是为什么我们要使用一个API来获取一些图像。</p><p id="5f77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用Axios，您可以使用<code class="fe no np nq mv b">npm install axios</code>安装它。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn nv nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/aa6ca11bea2dd374f3376921446db6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Jh-0ZEiJrLPd_e5Uvj9iJg.png"/></div></figure><figure class="nh kn nw nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/252982e12eb50e29ebfd1c89db0cd248.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*8sfKih8BdXCCjGOoFRCUug.png"/></div></figure></div><p id="578d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只想在组件挂载后从API获取图像。Vue对此有一个<code class="fe no np nq mv b">mounted</code>钩子，我们从这里调用<code class="fe no np nq mv b">getImages</code>函数。在React中你可以使用<code class="fe no np nq mv b">useEffect</code>钩子。</p><p id="29e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用这个钩子，你告诉React你的组件需要在渲染之后做一些事情。如果你不指定第二个参数，<code class="fe no np nq mv b">useEffect</code>钩子将在每次渲染后运行。</p><p id="9e9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你只想在初始渲染后运行给<code class="fe no np nq mv b">useEffect</code>的函数，你可以给它一个空数组作为第二个参数。</p><h2 id="e959" class="mz ly it bd lz nx ny dn md nz oa dp mh ld ob oc mj lh od oe ml ll of og mn oh bi translated">功能</h2><p id="b41d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">React组件中的函数被存储为<code class="fe no np nq mv b">const</code>变量。另一方面，在Vue中，它们被定义在<code class="fe no np nq mv b">methods</code>对象中。</p><h2 id="5922" class="mz ly it bd lz nx ny dn md nz oa dp mh ld ob oc mj lh od oe ml ll of og mn oh bi translated">变异数据</h2><p id="9784" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">一旦我们从API获取了我们的图像，我们想要改变我们之前存储的数据。默认情况下，<code class="fe no np nq mv b">images</code>变量是空的——现在我们已经获取了图像，我们想改变这一点。</p><p id="baf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是React和Vue的一个关键区别。Vue的工作非常简单。本质上，它创建了一个<code class="fe no np nq mv b">data</code>对象，其中的数据可以自由更新。另一方面，React创建了一个state对象，在这个对象中执行更新需要更多的努力。</p><p id="581f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React要求您有充分的理由做出这种额外的努力——我们将很快深入探讨这一点。但首先，让我们来看看以下片段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b8a68cd6fcaaa9750f04a7d1143b6db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1gmM5fhYmEP1JEORkEz0w.png"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated">使用状态挂钩的React状态变量</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/013c5f63bb56171df5f5b639c0023608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2pADJwE7_PKwVSk_bB1Aw.png"/></div></div><p class="oj ok gj gh gi ol om bd b be z dk translated">Vue的数据对象</p></figure><p id="8634" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以看到我们将同一个<code class="fe no np nq mv b">images</code>数组传递给了两者。在React中，状态变量的默认值作为第一个参数传递给<code class="fe no np nq mv b">useState</code>函数。在Vue中，只需在<code class="fe no np nq mv b">data</code>对象中给它赋值即可。</p><p id="6622" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们之前提到的，我们如何着手改变这些数据在不同的框架中是不同的。你可能已经注意到了，我们可以直接在Vue中更新<code class="fe no np nq mv b">data</code>对象。在<code class="fe no np nq mv b">getImages</code>函数中，我们直接将图像推送到数组中。</p><p id="82a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React需要多一点努力。如果我们想更新<code class="fe no np nq mv b">images</code>状态变量，我们必须使用<code class="fe no np nq mv b">setImages</code>函数。所以我们不能简单地调用<code class="fe no np nq mv b">images.push(..)</code>并期望状态更新，与Vue相反。</p><p id="1346" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有什么路可走？</p><p id="6fe0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们再来看看<code class="fe no np nq mv b">getImages</code>功能。我们将所有图像存储在一个临时数组中，称为<code class="fe no np nq mv b">fetchedImages</code>。一旦我们获取了所有的图像，我们调用<code class="fe no np nq mv b">setImages</code>函数，将<code class="fe no np nq mv b">fetchedImages</code>作为它的参数。</p><p id="22cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一开始钩子可能很难掌握——如果你想了解更多，我强烈推荐你阅读<a class="ae nf" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4750" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">生成卡片组</h1><p id="be5f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在我们开始生成卡片组之前，我们需要等到所有的图像都被获取。在React中，我们可以通过使用<code class="fe no np nq mv b">useEffect</code>钩子来做到这一点，就像我们开始获取图像一样。这里不同的是我们提供了<code class="fe no np nq mv b">images</code>变量，而不是一个空数组。这意味着这个钩子只有在<code class="fe no np nq mv b">images</code>变量被更新时才会被调用。</p><p id="91f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Vue中，有一种不同的方式对数据变化做出反应:观察属性。每当<code class="fe no np nq mv b">images</code>变量改变时，就会调用图像观察函数。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn oo nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3828e0024aa79c03c6b23d7b4f8a168a.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*6KHGWUEAwXxtgfWuOESgBQ.png"/></div></figure><figure class="nh kn op nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/eda3ab0e515cc15485ce9b60e94c6781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*Xal8aCjgCrzG4kY1-MUrzA.png"/></div></figure></div><p id="0ddd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe no np nq mv b">generateCards</code>功能本身并不令人兴奋。我们给每张卡一个唯一的数字、一对数字、一个图像和两个布尔值:开和匹配。</p><p id="72cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里唯一不同的是状态更新的方式。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn oq nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/293c088cc9299413eb4d1431042563f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*_GaWIiZ589xY6mDZUsW4uA.png"/></div></figure><figure class="nh kn or nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/d7ec09f20d321b447bde9c4226eb8636.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*6gcAnicsEeQiIx6rnXwn0w.png"/></div></figure></div><p id="d30e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还增加了一个<code class="fe no np nq mv b">shuffleDeck</code>功能，随机排列卡片组中的卡片。这两个项目的函数看起来是一样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/64c3e3747a13352db8605007e64edf7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwgaBbztPh4Ra-DtTfw3XA.png"/></div></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2311" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">添加微调器</h1><p id="b800" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">由于<code class="fe no np nq mv b">getImages</code>函数是异步的，获取数据可能需要几秒钟——特别是当您有很多对时，因为每对都发送一个请求。为了让事情变得更加用户友好，我们可以添加一个微调器来显示我们的游戏正在加载。</p><p id="fefc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在前面的例子中，你可能已经注意到我们偷偷放入了一个<code class="fe no np nq mv b">loading</code>变量，默认情况下是<code class="fe no np nq mv b">true</code>。一旦卡片生成，该变量被设置为<code class="fe no np nq mv b">false</code>。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn ot nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/81df7a33de47d7a436adfd9fcc07a808.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*LDPQTBiWuE2d3iDp4HANBQ.png"/></div></figure><figure class="nh kn ou nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/eab65dac3ff0c5ffb569aaceaa1934a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*n-x-NeZAVJPWIdsBvJdf4A.png"/></div></figure></div><p id="a281" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在React中，无法在组件的<code class="fe no np nq mv b">return</code>中创建<em class="ne"> if-else </em>构造。这导致两个独立的检查:<code class="fe no np nq mv b">loading</code>和<code class="fe no np nq mv b">!loading</code>。在Vue中，可以通过使用<code class="fe no np nq mv b">v-if</code>和<code class="fe no np nq mv b">v-else</code>进行<em class="ne"> if-else </em>构造。</p><p id="e766" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，注意React中的数组循环是通过使用<code class="fe no np nq mv b">map</code>函数来完成的。Vue对此有自己的指令:<code class="fe no np nq mv b">v-for</code>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="37c6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">该卡组件</h1><p id="7152" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如前所述，我们还需要一副牌。但是我们还没有一个<code class="fe no np nq mv b">Card</code>组件。这是我们这个项目需要的最后一个组件。</p><p id="6dd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每张牌可以有三种不同的状态:开放、关闭或匹配。如果匹配，我们可以把卡藏起来。当卡片合上时，我们显示一个问号，如果它打开了，我们显示图像。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn ov nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/81fb25f8345f289b5a73650ef157ba30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*i2wYI_K2R5tTRopxtZO-Bg.png"/></div></figure><figure class="nh kn ow nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/724990bdbe175b4772fcf279291b4dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*YIxEkCzD3c-Lc2DpVS_-fQ.png"/></div></figure></div><p id="dd19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们不能在React组件的<code class="fe no np nq mv b">return</code>中执行正确的逻辑，我选择创建一个额外的函数<code class="fe no np nq mv b">getCard</code>来完成这项工作。</p><p id="72c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React组件有一个附加属性<code class="fe no np nq mv b">onCardOpen</code>。这是从<code class="fe no np nq mv b">Playfield</code>组件传递的回调函数。这是React从子节点调用父节点函数的方式。</p><p id="1b26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一点在Vue中有所不同。这可以通过向父级发出自定义事件来实现。在我们的例子中，我们将事件称为<code class="fe no np nq mv b">onCardOpen</code>，并将<code class="fe no np nq mv b">this.card</code>作为参数传递。</p><p id="b2c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在父组件(即<code class="fe no np nq mv b">Playfield</code>组件)中监听该事件，并采取相应的行动。在挂载的钩子中，我们监听<code class="fe no np nq mv b">onCardOpen</code>事件。一旦该事件被触发，回调将被执行，这将调用<code class="fe no np nq mv b">openCard</code>函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/ab32203fce98ad9d8abe721223f9de83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpusE0gyup46fum93SxTng.png"/></div></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="da16" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">检查是否匹配</h1><p id="2b01" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">一旦我们打开了两张卡，我们要检查它们是否匹配。下面的例子中只有一个新概念，你能发现吗？</p><div class="kj kk kl km gt ab cb"><figure class="nh kn ox nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3005a2525fb4991614e08d8fc5ed02c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*o9PFKC50g4M5e61v4y8Gfg.png"/></div></figure><figure class="nh kn oy nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/b611386d6ab890b6654675d5ba822401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*eli1gV84Uqnbiy5_YlpB1w.png"/></div></figure></div><p id="d0e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们唯一没有触及的是下面一行:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e4f4" class="mz ly it mv b gy na nb l nc nd">let newDeck = [...deck]</span></pre><p id="2c65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要检测这个数组状态变量的变化，您不能简单地做以下事情:<code class="fe no np nq mv b">let newDeck = deck</code>。因为更新的卡片组看起来很像旧的卡片组，所以我们需要使用spread操作符来分配它，以便React可以检测到数组中的变化。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="b717" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">处理可能的匹配</h1><div class="kj kk kl km gt ab cb"><figure class="nh kn oz nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c991be0f9b1fea78f01d87b537dd484b.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*IGYjJxVW1W7Uje2meFx5NQ.png"/></div></figure><figure class="nh kn pa nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/bcffe866436d0d90d65ef7627e7caca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*V4teTAm5LL0NdR3QZdX3xQ.png"/></div></figure></div><p id="38f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想在游戏中加入竞争元素，所以我引入了一个回合数计数器。为了给用户更多的信息，我们还将提供匹配的配对数量。这段代码几乎是相同的。</p><div class="kj kk kl km gt ab cb"><figure class="nh kn pb nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/4639429ce8f5ef116399edbb5c35dab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*lkFey9HFz37P4esBafOq8Q.png"/></div></figure><figure class="nh kn pc nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a8c090a606db0b9760f7fceecccf1b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*9MqjD-2icBRJ7bjQ4-z84Q.png"/></div></figure></div><p id="93c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦用户匹配了所有配对，我们希望用户能够开始一个新的游戏，所以我们也添加了这个功能。看到这段代码应该不会再让你震惊了！</p><div class="kj kk kl km gt ab cb"><figure class="nh kn pd nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/f020d5e945f8867e4304d3f287880a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*1i4gpszHxO3-quj0zXgQ6A.png"/></div></figure><figure class="nh kn pe nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c9c276e75a2dafe335de8d62a1d24ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*j7b5kZcBUdg9VM0zXIrq-g.png"/></div></figure></div></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ee3f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">最佳化</h1><p id="a724" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">游戏开始前需要几秒钟。这是由获取图像的方式造成的。我用过的<a class="ae nf" href="https://picsum.photos/" rel="noopener ugc nofollow" target="_blank"> Lorem Picsum API </a>，不支持批量渲染小图片。有一个选项可以让你下载图像列表，但它不允许你控制图像的大小。</p><p id="496d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我尝试过批量获取图像，因此只发送一个请求，而不是每对图像都发送一个请求。这导致游戏加载速度非常快。然而，游戏变得几乎无法玩，因为一些图像超过5MB。对于这个例子，我牺牲了一些初始加载速度来提高游戏性。</p><p id="2651" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题可以用多种方法解决。第一个是在你的项目中添加一个图像集，这样你就不用每次想开始一个新游戏的时候都去获取它。那就没那么有趣了——当前的解决方案为你提供了每场比赛的随机图像。解决这个问题的第二个方法是找到一个API，让您可以批量获取小图像。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="425d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">多走一步</h1><p id="bf0a" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果你真的想更进一步，你可以建立一个界面，让用户为游戏设置一些选项，比如对子的数量和难度。您可以通过调整一对可见的时间来调整难度级别(变量<code class="fe no np nq mv b">pairVisibleInMilliseconds</code>)。</p><p id="a458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看一下<a class="ae nf" href="https://github.com/daanfl/match-match-react" rel="noopener ugc nofollow" target="_blank"> React GitHub repo </a>和<a class="ae nf" href="https://github.com/daanfl/match-match-vue" rel="noopener ugc nofollow" target="_blank"> Vue GitHub repo </a>，这样如果你不想的话就不必从头开始构建。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="e597" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">系列的一部分</h1><p id="f645" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我正在考虑制作一系列包含像这篇文章一样的内容的作品。在本系列的每一篇文章中，我都将做一个小的编码项目，深入研究某些编程语言、框架或技术之间的差异。</p><p id="dac7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您对本系列的下一部分有任何建议，请告诉我。</p><p id="5163" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常感谢您的反馈！</p></div></div>    
</body>
</html>