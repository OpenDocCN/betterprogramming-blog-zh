<html>
<head>
<title>Elevate Your RESTful API: 4 Must-Know Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升你的RESTful API: 4个必须知道的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-best-practices-of-restful-api-you-should-know-d3c752debd88?source=collection_archive---------3-----------------------#2022-11-21">https://betterprogramming.pub/4-best-practices-of-restful-api-you-should-know-d3c752debd88?source=collection_archive---------3-----------------------#2022-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6aa4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些技巧来打造一个可靠的RESTFUL设计</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db3b4099e2368e12317bfe82be5176cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9u15fO-WocDg0g_PTd3iw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cifilter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">香农·波特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/web?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">REST是一种广泛用于构建API的架构风格。它以直观、灵活和易于学习而闻名，这使得它成为开发人员的热门选择。</p><p id="ed24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，尽管REST很简单，但它也可能被误解，并不总是被使用它的人完全理解。虽然大多数开发人员可能都有一些REST方面的经验，但是很少有人真正认为自己是使用REST的专家。</p><p id="4b7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论REST API的一些最佳实践:</p><p id="421b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向前跳:</p><ul class=""><li id="63ec" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#64fa" rel="noopener ugc nofollow">选择RESTful端点的正确粒度</a></li><li id="cee6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#6ccd" rel="noopener ugc nofollow">不要基于数据库表构建您的API</a></li><li id="7ad0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#7ad4" rel="noopener ugc nofollow">使用HATEOAS数据，让您的客户端更加智能</a></li><li id="4db1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#391b" rel="noopener ugc nofollow">以一致的模式处理错误</a></li></ul><h1 id="64fa" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">选择RESTful端点的正确粒度</h1><p id="1dac" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">粒度是对API公开的资源范围的相对度量。细粒度API公开少量(或单个)资源，而粗粒度API在单个请求中返回来自许多资源的信息。</p><p id="9ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="c980" class="nl mk it nh b be nm nn l no np"># coarse-grained<br/>/v1/user/1/blog<br/>{<br/> “posts”: […],<br/> “comments”: […],<br/> “profile”: { “name”: “user 1” }<br/>}<br/># fine-grained<br/>/v1/user/1/posts<br/>/v1/user/1/comments<br/>/v1/user/1/profile</span></pre><p id="3166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择正确的粒度非常重要。太细粒度的API将导致喋喋不休的API调用、性能问题、复杂的架构和增加的维护成本。在上面的例子中，我们需要发出三个请求:<code class="fe nq nr ns nh b">/user/{userID}/posts</code>、<code class="fe nq nr ns nh b"> /user/{userID}/comments</code>和<code class="fe nq nr ns nh b">/user/{userID}/profile </code>来获取用户博客的信息。相比之下，单次调用<code class="fe nq nr ns nh b">/user/{userID}/blog</code>将提供相同数量的信息。</p><p id="12a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，过于粗粒度的API将缺乏灵活性，存在可伸缩性问题，并且难以重用。</p><p id="021d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当优先考虑性能时，首选粗粒度API。对于<code class="fe nq nr ns nh b">Get </code>请求，使用粗粒度API使得通过一次调用获得所有需要的信息成为可能。这意味着web服务器上的负载减少了，带宽延迟也更小了。</p><p id="4e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">细粒度API的典型用例包括移动应用和<code class="fe nq nr ns nh b">Post/Put</code>请求。</p><p id="43a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于API粒度，没有放之四海而皆准的规则。设计选择是几个经常冲突的因素之间的平衡，包括以下因素:</p><ul class=""><li id="d5c3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">响应负载的大小</li><li id="b1ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">API调用的次数</li><li id="8b87" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可维护性和可重用性</li><li id="486b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">可量测性</li><li id="026d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">业务需求</li></ul><p id="088a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界的项目中，您会发现结果通常是细粒度和粗粒度API的混合。底线是做出决策是为了满足业务需求和其他技术考虑。一个设计良好的API将足够细粒度以暴露必要的细节，但又不会粒度太细以至于不能使用。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="6ccd" class="mj mk it bd ml mm oa mo mp mq ob ms mt jz oc ka mv kc od kd mx kf oe kg mz na bi translated">不要基于数据库表构建API</h1><p id="30dd" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Restful API是围绕资源设计的。资源可以松散地链接到业务实体，而不是数据库表。</p><p id="f579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于内部数据库表镜像API端点是很容易的。例如，对于以下数据结构</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="5c79" class="nl mk it nh b be nm nn l no np">Orders<br/>---------<br/>id (integer)<br/>customer_id (integer)<br/>status (string)<br/><br/>OrderItems<br/>---------<br/>id (integer)<br/>order_id (integer)<br/>product_id (integer)</span></pre><p id="123e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于这些表构建API可能很有吸引力，比如</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="8cae" class="nl mk it nh b be nm nn l no np">GET /orders<br/>POST /orders<br/>GET /orders/{id}<br/>...<br/><br/>GET /orders/{id}/items<br/>POST /orders/{id}/items<br/>GET /orders/{id}/items/{item_id}<br/>...</span></pre><p id="ab89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这种方法有几个问题。首先，它暴露了太多关于底层数据库结构的信息。我们在API接口和数据库实现之间建立了紧密的耦合。这只会使API难以维护。因此，我们不应该向客户公开(泄露)内部数据库结构。</p><p id="586e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，它要求客户端发出多个请求来检索订单的所有信息(例如，订单细节和订单项目)。这可能是低效和缓慢的。</p><p id="84d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是设计一个更粗粒度的API，在一个请求中提供所有必要的信息:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="9537" class="nl mk it nh b be nm nn l no np">GET /orders?customer_id={customer_id}&amp;status={status}<br/>POST /orders<br/>GET /orders/{id}<br/>...</span></pre><p id="8a64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当设计一个REST API时，我们如何将领域概念从底层数据存储中分离出来？</p><p id="cf17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键是摆脱数据库驱动的思维模式，抵制快速进入实现细节的诱惑。以下是一些供思考的建议:</p><ul class=""><li id="7d1d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从业务领域的角度考虑REST API，而不是数据库。收集业务需求以建立API的边界上下文。问很多问题，比如，我们为什么需要API？将提供哪些新功能？用户是谁？有哪些用例？</li><li id="8307" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将API接口与底层实现细节隔离开来。一个好的API设计是一个稳定的API，它可以在实现改变时持续很长时间。例如，数据库模式将会发展或用不同的数据库重新实现。如果API是用适当的抽象设计的，这些内部变化不会影响API接口。</li><li id="708d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">单一责任原则。一个好的REST API应该专注于一个业务领域，并把它做好。创建一个管理多个职责的API会使它变得不必要的复杂和难以维护。</li></ul></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="7ad4" class="mj mk it bd ml mm oa mo mp mq ob ms mt jz oc ka mv kc od kd mx kf oe kg mz na bi translated">消费HATEOAS数据，让您的客户端变得更加智能</h1><p id="d5f0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">HATEOAS(作为应用程序状态引擎的超媒体)是REST API的一个接口，它在API响应中提供了到相关端点的可导航链接。REST的一个原则是，API应该是自描述的，任何消费者都应该能够使用提供的链接发现API并与之通信。</p><p id="d9c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HATEOAS是一种表达当前资源和其他资源之间关系的直观方式。下面是一个用户博客API端点<code class="fe nq nr ns nh b">/v1/user/1/blog</code>的示例响应。如您所见，帖子和评论的相关链接嵌入其中。</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="100f" class="nl mk it nh b be nm nn l no np">{<br/> “id”: 1,<br/> “name”: “John Duggan’s Blog”,<br/> “links”: [<br/>  {<br/>   “href”: “1/posts”,<br/>   “rel”: “posts”,<br/>   “type” : “GET”<br/>   }, <br/>  {<br/>   “href”: “1/comments”,<br/>   “rel”: “comments”,<br/>   “type” : “GET”<br/>   }<br/> ]<br/>}</span></pre><p id="bae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了HATEOAS，客户端可以发现它可以继续执行的下一个动作。与客户端中硬编码的URL链接相比，HATEOAS链接使客户端代码更加动态和灵活。</p><p id="416d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从架构的角度来看，HATEOAS允许一个松散耦合的系统。当客户机使用HATEOAS实现动态链接时，服务器可以在不更新客户机代码的情况下更改URL。</p><p id="d030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Martin Fowler关于REST Richardson成熟度模型的<a class="ae ky" href="https://martinfowler.com/articles/richardsonMaturityModel.html#level3" rel="noopener ugc nofollow" target="_blank">文章中，当实现HATEOAS以实现可发现性时，REST API被认为是第三级。不幸的是，尽管HATEOAS被认为是REST设计中必不可少的一部分，但它在现实世界的项目中经常被遗忘。</a></p><p id="f985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然不是每个REST API项目都有HATEOAS的用例，但是如果用在正确的地方，它会是一个非常强大的特性。我处理过的一些好的用例包括:</p><ul class=""><li id="3473" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Workflow App: HATEOAS返回的链接可以代表当前的状态，即链接的集合代表下一步可用的所有可能的动作。好处是服务器管理所有的业务逻辑，而客户机变得被动。</li><li id="2061" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">管理用户权限:HATEOAS链接是传递资源权限的一种自然方式。例如，客户端应用程序将在加载新屏幕时发送Get请求，Get响应中的链接表示当前用户允许的操作。因此，客户端可以相应地对用户权限做出反应(显示/隐藏按钮等)。).</li></ul></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="391b" class="of mk it bd ml og oh dn mp oi oj dp mt li ok ol mv lm om on mx lq oo op mz oq bi translated">用一致的模式处理错误</h2><p id="aa7c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在REST API中，处理错误和处理成功的响应一样重要。有了可靠的错误处理，开发人员会发现故障排除更容易，应用程序也更容易维护。</p><p id="4195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个可靠的错误处理框架必须有一个全局错误处理程序来捕获和处理错误。根据错误的性质，我们应该使用适当的HTTP状态代码，并将错误映射到可读的信息性错误消息。全局错误处理程序将确保错误得到处理，并返回一致而简洁的错误消息。</p><p id="35ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该键具有项目的标准错误响应结构。错误响应应该至少包含“代码”和“消息”键-值对，并且应该能够容纳多个错误。下面是一个简单的例子:</p><pre class="kj kk kl km gt ng nh ni bn nj nk bi"><span id="8364" class="nl mk it nh b be nm nn l no np">{<br/> “errors”: [<br/>   {<br/>   “code”: “10003”,<br/>   “message”: “invalid address field”<br/>   },<br/>   {<br/>   “code”: “10004”,<br/>   “message”: “birthday field is requried”<br/>   }<br/>   ]<br/> }</span></pre><p id="6a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，代码和消息字段不应是直接来自服务器的技术错误代码和消息。由于来自API的响应是向客户端公开的，所以它们需要被翻译成用户友好的、可读的消息，并且您不希望泄漏不必要的技术细节。</p><p id="4987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，你可以根据自己的需要添加更多的属性。一些常见属性包括:</p><ul class=""><li id="0bd4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nq nr ns nh b">severity</code>:可以是<code class="fe nq nr ns nh b">error</code> | <code class="fe nq nr ns nh b">warning</code> | <code class="fe nq nr ns nh b">info</code></li><li id="5ef0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nq nr ns nh b">suberrorcode</code>:低级错误代码</li><li id="32d7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nq nr ns nh b">traceId</code>:识别错误来源的id</li><li id="ea61" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nq nr ns nh b">correclationId</code>:复杂流日志中要跟踪的内部ID。</li><li id="940f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nq nr ns nh b">stacktraces</code>:发生错误时的活动堆栈帧。通常在生产中应该禁用它。使用该字段时，注意不要暴露敏感信息。</li></ul><p id="d969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个有用的参考是<a class="ae ky" href="https://www.rfc-editor.org/rfc/rfc7807" rel="noopener ugc nofollow" target="_blank">RFC 7807</a>:HTTP API的问题细节。它提供了关于如何在HTTP响应中携带机器可读的错误细节的指南。</p><p id="8f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端可以使用一致的错误响应消息结构来有效地对错误做出反应。也能让开发者的日子更轻松。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="9172" class="mj mk it bd ml mm oa mo mp mq ob ms mt jz oc ka mv kc od kd mx kf oe kg mz na bi translated">摘要</h1><p id="e3f8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">REST APIs相对容易上手，尤其是在使用成熟的框架时。只需几个步骤，您就可以创建一个简单的“hello world”服务。然而，构建一个可靠的REST API并不总是简单的，因为没有严格的规则可循。相反，它需要平衡技术考虑、约束和业务需求来创建设计良好的API。不容易，但为了能带来的好处，值得。</p><p id="3124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你能从这篇文章中学到一二。</p><p id="e80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>