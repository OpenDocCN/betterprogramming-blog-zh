<html>
<head>
<title>C++ constexpr: What It Really Is?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++ constexpr:它到底是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/c-constexpr-what-it-really-is-d6ca81023dcd?source=collection_archive---------5-----------------------#2022-03-08">https://betterprogramming.pub/c-constexpr-what-it-really-is-d6ca81023dcd?source=collection_archive---------5-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5eeb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过理解什么是constexpr以及它与C++中的const有何不同来避免初学者的错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/173a356fd5563946c4f99a4b071eba60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WPkDyef6SuGECmQv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="87dd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">概观</h1><p id="0bca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">constexpr</code>说明符是在<code class="fe mn mo mp mq b">C++11</code>中引入的，对于初学者来说很容易混淆，因为它类似于<code class="fe mn mo mp mq b">const</code>限定符。</p><p id="db8a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">constexpr</code>代表常量表达式，用于指定一个变量或函数可以用在常量表达式中，一个可以在编译时求值的表达式。</p><p id="a2b1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">constexpr</code>的关键点在于它可以在编译时执行。您的代码可能在运行之前就已经被执行了。这才是重点。</p><p id="e7df" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们可以在变量、函数——包括构造函数和if语句上使用<code class="fe mn mo mp mq b">constexpr</code>。我们将在下面的章节中看到细节。</p><h1 id="a8ab" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">变量</h1><p id="f230" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我已经在另一篇文章中写了关于<code class="fe mn mo mp mq b">const</code>限定符的所有细节:</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-all-the-details-of-c-const-4d2a4b714b63"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">理解C++ Const的所有细节</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">理解const限定符的细节非常重要，有助于提高您的代码质量和代码质量。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">better编程. pub</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ks mz"/></div></div></a></div><p id="de69" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们使用<code class="fe mn mo mp mq b">const</code>限定符向编译器和其他程序员表达我们的意图，我们希望变量是只读的，任何修改它的尝试都会导致编译错误。</p><p id="e46a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，<code class="fe mn mo mp mq b">constexpr</code>类似于<code class="fe mn mo mp mq b">const</code>，因为它暗示了一个<code class="fe mn mo mp mq b">const</code>。这也是无法改变的。不同之处在于，<code class="fe mn mo mp mq b">const</code>可以在编译时和运行时进行计算，这取决于我们如何初始化它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d203" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这个例子中,<code class="fe mn mo mp mq b">val</code>是在编译时计算的。当我们执行代码时，<code class="fe mn mo mp mq b">val</code>总是等于<code class="fe mn mo mp mq b">3</code>。然而，在下面的例子中，<code class="fe mn mo mp mq b">val</code>是在运行时计算的，因为它涉及到调用一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="099d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">由于第一个例子是在编译时计算的，我们可以用<code class="fe mn mo mp mq b">constexpr</code>替换它，没有任何区别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2da1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">但这并不适用于第二个例子。我们将得到一个编译错误，因为它在编译时不能再被计算。</p><pre class="kj kk kl km gt nq mq nr ns aw nt bi"><span id="4eaa" class="nu la it mq b gy nv nw l nx ny">error: call to non-‘constexpr’ function ‘int Sum(int, int)’</span></pre><p id="8dde" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">对于这个例子，我们可以将我们的函数转换成一个<code class="fe mn mo mp mq b">constexpr</code>函数来解决这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5df7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">代码看起来是一样的，但是现在是在编译时执行的。在运行时，编译器将我们的代码修改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="044d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我没有在那里写<code class="fe mn mo mp mq b">const</code>或<code class="fe mn mo mp mq b">constexpr</code>,因为一旦程序运行，它们就不再被使用。<code class="fe mn mo mp mq b">const</code>和<code class="fe mn mo mp mq b">constexpr</code>都只在编译时使用。</p><h1 id="1d34" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">函数和构造函数</h1><p id="852e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">constexpr</code>也可以用在函数和构造函数上。就像上面的例子一样，我们可以指定一个函数或构造函数为<code class="fe mn mo mp mq b">constexpr</code>函数。</p><p id="8522" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">constexpr</code>功能灵活。相同的函数可以在编译时或运行时计算。取决于他们是如何称呼的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1160" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这个例子中，我们有一个名为<code class="fe mn mo mp mq b">Sum</code>的<code class="fe mn mo mp mq b">constexpr</code>函数，我们在第<code class="fe mn mo mp mq b">6</code>和<code class="fe mn mo mp mq b">8</code>行调用它。第<code class="fe mn mo mp mq b">6</code>行在编译时求值，与上一节中的例子相同，但是第<code class="fe mn mo mp mq b">8</code>行在运行时求值，因为它涉及一个名为<code class="fe mn mo mp mq b">var</code>的非<code class="fe mn mo mp mq b">const</code>变量。</p><p id="c593" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">你可以看到一个<code class="fe mn mo mp mq b">constexpr</code>函数非常有用，我们可以让编译器决定是在编译时还是运行时评估我们的函数。为了在编译时对其进行评估，必须满足许多条件。详见此<a class="ae ky" href="https://en.cppreference.com/w/cpp/language/constexpr" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h1 id="d913" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">If语句</h1><p id="1269" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然<code class="fe mn mo mp mq b">C++17</code>我们也可以指定<code class="fe mn mo mp mq b">constexpr</code> if语句。如果日常工作中不处理泛型代码，可能不会经常使用。为了理解为什么这是必要的，我们需要理解C++模板元编程中SFINAE(替换失败不是错误)的概念。</p><h2 id="e7f3" class="nu la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">SFINAE和std::enable_if</h2><p id="9c0c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当你在代码中调用一个函数时，编译器必须执行一些检查来知道调用哪个函数，记住你可以写多个同名的函数——函数重载。概括地说，这些步骤是:</p><ul class=""><li id="70b9" class="ok ol it lt b lu mr lx ms ma om me on mi oo mm op oq or os bi translated">名称查找</li><li id="6d0b" class="ok ol it lt b lu ot lx ou ma ov me ow mi ox mm op oq or os bi translated">模板参数演绎</li><li id="7691" class="ok ol it lt b lu ot lx ou ma ov me ow mi ox mm op oq or os bi translated">模板参数替换</li><li id="3b1a" class="ok ol it lt b lu ot lx ou ma ov me ow mi ox mm op oq or os bi translated">过载分辨率</li></ul><p id="648e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">前三个步骤将生成一组将在重载决策过程中使用的重载函数。重载决策将选择一个参数最匹配的函数。</p><p id="4adc" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">SFINAE发生在步骤3，模板参数替换中，它表示当一个候选函数没有通过替换测试时，不会产生编译错误，它只是从候选列表中删除。让我们看看下面的例子。</p><p id="ff38" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们想写一个名为<code class="fe mn mo mp mq b">Square()</code>的通用函数，它接受算术类型和用户定义的类型。用户定义的类型是如下所示的类模板。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0a23" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果不是为了支持这个类模板，我们可以很容易地如下实现我们的函数模板。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b9b4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">但是当我们传递给这个函数模板一个类型为<code class="fe mn mo mp mq b">Number&lt;int&gt;</code>的对象时，它就不起作用了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fbc6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">第<code class="fe mn mo mp mq b">9</code>行将无法编译，因为<code class="fe mn mo mp mq b">Number&lt;int&gt;</code>没有实现<code class="fe mn mo mp mq b">operator*</code>。</p><p id="20be" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">解决方案是，我们需要知道传递给我们的函数模板<code class="fe mn mo mp mq b">Square()</code>的类型，并让if-else检查它，这个if-else应该在编译时计算，如下面的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dca7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">但是这种解决方案不起作用，因为当我们用一个<code class="fe mn mo mp mq b">int</code>调用这个函数时，它会试图寻找不存在的<code class="fe mn mo mp mq b">int.value</code>。为了看得更清楚，这是模板实例化的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a5c8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在很清楚为什么它不起作用了，因为else部分没有从函数中删除。这是我们得到的编译错误。</p><pre class="kj kk kl km gt nq mq nr ns aw nt bi"><span id="4150" class="nu la it mq b gy nv nw l nx ny">error: request for member ‘value’ in ‘t’, which is of non-class type ‘const int’</span></pre><p id="7143" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">解决方案是用两个函数模板来检查我们传入的类型是否是算术类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0b34" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在我们有两个函数模板，一个用于算术类型，另一个用于非算术类型。如果我们将值<code class="fe mn mo mp mq b">true</code>传递给它，那么<code class="fe mn mo mp mq b">std::enable_if</code>有一个公共成员typedef <code class="fe mn mo mp mq b">::type</code>，否则它没有公共成员typedef。</p><p id="559e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当我们将<code class="fe mn mo mp mq b">Number&lt;int&gt;</code>传递到<code class="fe mn mo mp mq b">Square()</code>时，第一个函数模板替换失败，第二个成功。第一个函数没有抛出错误，只是从<em class="oy">函数候选列表</em>中移除了<strong class="lt iu">。然后编译器选择第二个函数。这就是它起作用的原因。</strong></p><p id="f338" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">通过使用两个或更多带有<code class="fe mn mo mp mq b">std::enable_if</code>的函数模板，我们在模拟编译时if-else。</p><h2 id="c1e1" class="nu la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">constexpr if语句如何改进SFINAE</h2><p id="714b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然很管用，应用也很广泛，但是SFINAE和<code class="fe mn mo mp mq b">std::enable_if</code>的组合不是很直观。代码很冗长，如果你不熟悉它，语法可能很难读懂。</p><p id="ae7e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">从<code class="fe mn mo mp mq b">C++17</code>开始，我们可以使用<code class="fe mn mo mp mq b">constexpr</code> if语句使其更具可读性。我们可以在单个函数中拥有真正的编译时if-else，而不是用<code class="fe mn mo mp mq b">std::enable_if</code>使用多个函数来模拟它。下面是我们如何用<code class="fe mn mo mp mq b">constexpr</code> if语句实现的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2ed6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">我们不仅只有一个函数模板，而且它非常接近我们熟悉的if-else语句。这是可行的，因为编译器只接受带有<code class="fe mn mo mp mq b">true</code>条件的分支，而丢弃其他分支。</p><h1 id="ec34" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关键要点</h1><ul class=""><li id="6522" class="ok ol it lt b lu lv lx ly ma oz me pa mi pb mm op oq or os bi translated"><code class="fe mn mo mp mq b">constexpr</code>用于变量时隐含着<code class="fe mn mo mp mq b">const</code>，但这不是重点，重点是<code class="fe mn mo mp mq b">constexpr</code>变量在编译时被求值</li><li id="abfe" class="ok ol it lt b lu ot lx ou ma ov me ow mi ox mm op oq or os bi translated"><code class="fe mn mo mp mq b">constexpr</code>说明符也可用于函数和构造函数，与返回<code class="fe mn mo mp mq b">const</code>的函数不同，<code class="fe mn mo mp mq b">constexpr</code>在此上下文中用于允许函数和构造函数在编译时被评估(如果可能的话)</li><li id="5fb0" class="ok ol it lt b lu ot lx ou ma ov me ow mi ox mm op oq or os bi translated">最后一部分是，<code class="fe mn mo mp mq b">constexpr</code>可以用于编译时if-else来提高我们代码的可读性，我们通常使用SFINAE和<code class="fe mn mo mp mq b">std::enable_if</code>来模拟它</li></ul></div></div>    
</body>
</html>