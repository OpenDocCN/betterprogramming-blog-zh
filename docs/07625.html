<html>
<head>
<title>Simplicity and Complexity Needn’t Be Mutually Exclusive In Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在您的代码中，简单性和复杂性不必相互排斥</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/simplicity-and-complexity-neednt-be-mutually-exclusive-in-your-code-cb07154f77db?source=collection_archive---------14-----------------------#2021-02-02">https://betterprogramming.pub/simplicity-and-complexity-neednt-be-mutually-exclusive-in-your-code-cb07154f77db?source=collection_archive---------14-----------------------#2021-02-02</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="defa" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">你的代码只有在你创造它的时候才是复杂的</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d049b6550265f0e09710d940b606a0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJTFp9XD3pOYCv2l3H3OYg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@nedlevart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼斯·波波夫</a>在<a class="ae kz" href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="279b" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">好建议</h1><p id="c919" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">我给新软件开发人员的第一条建议是:“<a class="ae kz" href="https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view" rel="noopener ugc nofollow" target="_blank">代码反对抽象，而不是实现。</a>”</p><p id="8792" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">但紧随其后的是遵循单一责任原则。</p><p id="8c5c" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><a class="ae kz" href="https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view" rel="noopener ugc nofollow" target="_blank">单一责任原则</a> (SRP)是<a class="ae kz" href="http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" rel="noopener ugc nofollow" target="_blank">面向对象编程的五个坚实原则</a>中的第一个。这可能也是最重要的一点。遵循它，你可以避免各种各样的恶作剧、悲伤和麻烦。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="4455" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">单一责任原则</h1><p id="d833" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">SRP正式声明如下:</p><blockquote class="nf ng nh"><p id="6d72" class="ls lt ni lu b lv mo jv lx ly mp jy ma nj mq md me nk mr mh mi nl ms ml mm mn in bi translated">一个类应该只有一个改变的理由。</p></blockquote><p id="5a1f" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">现在，我对这个定义非常不满意。一个类可以有各种各样的理由去改变——你可能会找到一个更好的实现，你可能会修复一个bug，你甚至可能决定它需要一个额外的参数或者依赖。这些都是一个类改变的好理由。</p><p id="d2e0" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">但是一个类<em class="ni">不应该做的事情</em>是尝试做多件事情。它应该有一个单一的责任，不再承担更多的责任。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="b95c" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">震惊的</h1><p id="163f" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">我记得有一天，我坐在办公桌前工作，被这个概念的深刻性所震撼:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nm"><img src="../Images/60fa700609bd8a5b18e2ebb79174d122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyDf6BmZ2jrFQo7SFswl8Q.png"/></div></div></figure><blockquote class="nf ng nh"><p id="8584" class="ls lt ni lu b lv mo jv lx ly mp jy ma nj mq md me nk mr mh mi nl ms ml mm mn in bi translated">软件中如此多的复杂性来自于试图让一件事做两件事。—瑞安·辛格</p></blockquote><p id="4620" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">这句话给了我当头一棒。千真万确，让我头疼。</p><p id="235b" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我们都经历过——你会遇到一些<code class="fe nn no np nq b">WidgetManager</code> <em class="ni"> </em>或<code class="fe nn no np nq b">SprocketEngine</code> <em class="ni"> </em>类，它们做14种不同的事情。当有人决定给一个类添加另一个责任时，这一切就开始了。很快，这个类就变成了吸引功能的磁铁，在你知道之前，它已经做了所有的事情，并且成为了<a class="ae kz" href="https://en.wikipedia.org/wiki/God_object" rel="noopener ugc nofollow" target="_blank">神类</a>。</p><p id="b697" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">看在糖宝·埃尔维斯的份上，别那么做！为新的职责建立一个新的类。</p><p id="7192" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">辛格的文字之美让我思考什么是复杂，什么是简单。我意识到，如果你不想建立一个复杂的系统，就不要创造任何复杂的个体事物。</p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><h1 id="1922" class="la lb iu bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">一块手表</h1><p id="da04" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">一方面，手表是一个复杂的系统，但另一方面，它不是。它由独立的部分组成，这些部分本身很简单:齿轮是一个简单的东西，有一个责任，就像表圈、表带和秒针一样。每个部分都很简单。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nr"><img src="../Images/a6c4d586cc378054bf5f1e0c0ba07cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3rKmdcez8khAv1km"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">迪米塔尔·斯特夫切夫在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b971" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">尽管如此，复杂性的存在是因为简单的部分相互作用提供了一些惊人的功能。齿轮转动指针，主发条推动一个齿轮，齿轮带动其他齿轮，等等。每个组件与其他几个组件相互作用，创建一个强大的系统。然而，由于部件之间的基本接口，整个机制非常简单。</p><p id="b33e" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我们的软件也是如此。所有有意义或有用的软件在功能上都将是复杂的。然而，它不必由复杂的东西组成。正如一块手表可以被分解成几个组成部分，每个部分服务于一个单一的目的，你的软件也应该由简单的交互类组成。</p><p id="d447" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">你应该能够将你的软件分解成独立的类，这些类本身并不复杂<em class="ni"/>。每个班级应该做一件事情。只有通过依赖注入和干净、分离的接口与其他类交互，复杂性才会出现。</p><p id="4dbc" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">正如Singer指出的，当类之间的绑定变得如此紧密，以至于任何给定的类都做得太多时，我们实际代码中的复杂性就来了。想象一下，在一个老爷钟里有一个钟摆，它不仅来回摆动来驱动整个引擎，而且还负责旋转那个小小的月相指示器。人们甚至无法想象这需要什么阴谋诡计，但是我们一直在软件中做这种事情。</p><p id="5e79" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">所以听听瑞安·辛格。让他的话的赤裸裸的深刻冲刷你，永远不要让一个班做一件以上的事情。</p></div></div>    
</body>
</html>