<html>
<head>
<title>Deploy a Full-Stack Go and React App on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上部署全栈Go and React应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deploy-a-full-stack-go-and-react-app-on-kubernetes-4f31cdd9a48b?source=collection_archive---------6-----------------------#2020-01-06">https://betterprogramming.pub/deploy-a-full-stack-go-and-react-app-on-kubernetes-4f31cdd9a48b?source=collection_archive---------6-----------------------#2020-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6dba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用minikube和kubectl在Kubernetes上部署Gin-Gonic的Go后端和React web应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dd41a2105f8b465ffd0a0f2225423beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHchtcOYJDVcoVcWPoarnA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/4I41IQtmSs0" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/4I41IQtmSs0</a></p></figure><p id="6575" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建部署所需的Docker映像，并将它们推送到Docker Hub。</p><p id="c136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从后端容器开始。在您的根目录中，创建一个名为api的目录，它将包含所有与后端相关的文件。由于我们将使用<a class="ae kv" href="https://gin-gonic.com/" rel="noopener ugc nofollow" target="_blank"> Gin-Gonic </a>作为我们的Go框架，我们将创建一个<code class="fe ls lt lu lv b">go.mod</code>文件(注意，您应该更改模块的名称):</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5790" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">module</strong> github.com/uxioandrade/go-react-kubernetes-tutorial</span><span id="8d37" class="ma mb iq lv b gy mg md l me mf"><strong class="lv ir">go</strong> 1.13</span><span id="44ad" class="ma mb iq lv b gy mg md l me mf"><strong class="lv ir">require</strong> github.com/gin-gonic/gin v1.5.0</span></pre><p id="d3ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经设置好了<code class="fe ls lt lu lv b">go.mod</code>文件，让我们创建一个<code class="fe ls lt lu lv b">main.go</code> <em class="mh"> </em>文件，它本质上是一个基本的Gin-Gonic服务器示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gin-Gonic基本服务器</p></figure><p id="3a92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与后端相关的最后一步是创建Dockerfile <em class="mh">。</em>同样，这将是一个极简方案，只需要运行我们的服务器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">API Dockerfile文件</p></figure><p id="93d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将运行两个命令将我们的Docker映像推送到Docker Hub。请注意，要使这些命令生效，您必须登录到Docker Hub。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="01dd" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">docker</strong> build -t uxioandrade/tutorial-api</span><span id="a43d" class="ma mb iq lv b gy mg md l me mf"><strong class="lv ir">docker</strong> push uxioandrade/tutorial-api</span></pre><p id="a82f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经准备好了我们的后端，让我们继续到React应用程序。导航到项目的根目录，并运行以下命令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6fa2" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">npx</strong> create-react-app client</span></pre><p id="fcaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们会尽量保持代码简单。然而，我们将安装<code class="fe ls lt lu lv b">axios</code>库来发出请求。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5d3c" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">npm</strong> i axios  --save</span></pre><p id="fc5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，导航到客户端文件夹，打开<code class="fe ls lt lu lv b">src/App.js</code> <strong class="ky ir"> </strong>文件——我们需要修改的唯一文件。在App组件中，我们向后端发出一个请求，以测试一切都正常工作。以下代码将满足我们的需求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">App.js</p></figure><p id="a189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们为客户机创建一个docker文件。如我们所见，它看起来与后端相似:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">客户文档文件</p></figure><p id="d5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们对后端映像所做的那样，让我们将它推送到Docker Hub:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="feed" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">docker</strong> build -t uxioandrade/tutorial-client</span><span id="4d4e" class="ma mb iq lv b gy mg md l me mf"><strong class="lv ir">docker</strong> push uxioandrade/tutorial-client</span></pre><p id="8144" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经具备了在Kubernetes上部署应用所需的一切。事实上，我们可以运行两个容器，看看它们是否工作。</p><p id="e46b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，为了让两个容器能够相互通信，我们需要做一些修改。例如，一个简单的解决方案(尽管不是最优雅的)是在<code class="fe ls lt lu lv b">App.js</code>文件中改变GET请求的端点。另一种选择是将docker-compose与NGINX容器一起使用，但这对于我们的用例来说是一个完全不切实际的解决方案。</p><p id="fa3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将使用minikube和kubectl，所以您需要在您的计算机上安装这两个工具。安装后，运行以下命令来运行minikube:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a536" class="ma mb iq lv b gy mc md l me mf">minikube start</span></pre><p id="366e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦有了这些，创建一个名为<code class="fe ls lt lu lv b">k8s</code> <em class="mh">，</em>的文件夹，我们将在其中分配与Kubernetes部署相关的所有文件。此外，我将添加一个<code class="fe ls lt lu lv b">postgres</code>服务，这将有助于展示如何创建一个<a class="ae kv" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷声明</a>。</p><p id="4743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先创建与API和客户机部署相关的配置文件。但是首先，让我们明确一下在这个上下文中我们所说的部署是什么意思。部署是一种维护一组相同pod的对象，确保它们具有正确的配置。记住这一点，让我们看看我们的部署文件会是什么样子。</p><p id="1e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在API部署(<code class="fe ls lt lu lv b">api-deployment.yaml</code>)中，我们添加了一些与Postgres服务相关的环境变量。注意，在真实的场景中，我们想要创建一个<a class="ae kv" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">秘密</a>来存储postgres密码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">API部署</p></figure><p id="8e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端部署(<code class="fe ls lt lu lv b">client-deployment.yaml</code>)将看起来像上一个的简化版本，因为我们没有使用任何<code class="fe ls lt lu lv b">env</code>变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">客户端部署</p></figure><p id="c846" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，我们还需要postgres服务的部署。然而，我们必须在此之前创建某种持久存储服务，否则，一旦pod关闭，我们将丢失所有数据。出于这个目的，我们将使用一个按体积索赔，正如我之前提到的。<code class="fe ls lt lu lv b">database-persistent-volume-claim.yaml</code>文件将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库永久卷声明</p></figure><p id="ea84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，1Gi的大小是任意的，因此我们可以将其更改为更适合我们需要的任何数字。</p><p id="e233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在了解了数据库的持久性之后，我们必须编写的部署再次与前一个类似，除了我们必须添加持久性卷声明部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Postgres部署</p></figure><p id="b31c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成这些之后，我们就完成了所有需要的部署。然而，这些部署是孤立的，它们不能与任何外部服务通信。为了实现任何通信，我们将使用一个名为<code class="fe ls lt lu lv b">ClusterIP</code>的新服务。三个部署的<code class="fe ls lt lu lv b">ClusterIP</code>将具有完全相同的结构，我们只需要修改一些参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">api-cluster-ip-service.yaml</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">客户端群集ip部署. yaml</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">postgres-cluster-IP-service . YAML</p></figure><p id="b2d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们快完成了！</p><p id="ce9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一要做的就是创建最后一个服务:入口服务。这管理对集群中服务的外部访问。更具体地说，我们将使用NGINX入口控制器。查看<a class="ae kv" href="https://kubernetes.github.io/ingress-nginx/deploy/#minikube" rel="noopener ugc nofollow" target="_blank">本指南</a>了解如何启用它。然而，在我们的例子中，我们可以用两个命令来完成:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f380" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">kubectl</strong> apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml</span><span id="1ed6" class="ma mb iq lv b gy mg md l me mf"><strong class="lv ir">minikube</strong> addons enable ingress</span></pre><p id="e955" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经准备好编写最后一个配置文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ingress-service.yaml</p></figure><p id="76b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经做到了这一步，那么恭喜您，您已经准备好运行所有配置了。为此，只需从项目的根目录运行以下命令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9316" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">kubectl</strong> apply -f k8s</span></pre><p id="72c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要检查一切是否按预期运行，您可以运行以下一些命令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="59cd" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">kubectl</strong> get all</span><span id="a2b0" class="ma mb iq lv b gy mg md l me mf"><strong class="lv ir">minikube</strong> dashboard</span></pre><p id="8883" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行第一个，您应该检查三个pod是否正在运行，并且您创建的ClusterIPs也在其中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/faf98cf21b90eb6d54256918d885bb92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kN22CE6gA5_t5W_xKSLdyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">kubectl获取所有输出</p></figure><p id="78a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果您选择第二个命令，您可以以直观的方式导航minikube仪表板，并检查Kubernetes集群是否相应地运行。</p><p id="b09d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们看看我们的应用程序是否确实在运行。使用以下命令在您的本地计算机中获取minikube的ip:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4a69" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">minikube</strong> ip</span></pre><p id="ecfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在您的首选浏览器中导航到该IP。如果您看到类似下面的内容，那么您已经在Kubernetes上成功部署了一个全栈Golang和React应用程序！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/eca38bb2e2f2cdfd4c8da0c66a0e4304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kW_vHQQ52AiygTuaSAWnMg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完成部署</p></figure><p id="04fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有任何疑问，或者认为你可能犯了一些错误，你可以在这个<a class="ae kv" href="https://github.com/UxioAndrade/tutorials/tree/main/go-react-kubernetes" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到代码。</p></div></div>    
</body>
</html>