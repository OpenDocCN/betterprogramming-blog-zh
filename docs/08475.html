<html>
<head>
<title>Why I Still Don’t Like Classes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我仍然不喜欢JavaScript中的类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-i-still-dont-like-classes-in-javascript-994132f914c0?source=collection_archive---------12-----------------------#2021-05-04">https://betterprogramming.pub/why-i-still-dont-like-classes-in-javascript-994132f914c0?source=collection_archive---------12-----------------------#2021-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0843" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个参数、类的隐私只是几个陷阱。工厂函数可能是更好的选择。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14042b754908bda83f9dff9b5c5c8e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hKmDIGxM3ZVaYpQ0e1YEQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="ee86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几年前，我写过一篇文章，指出了我不喜欢JavaScript中的类，而更喜欢使用工厂函数的原因。三年后，我仍然可以说我不喜欢JavaScript中的类，我只是在别无选择的情况下才使用它们。</p><p id="7262" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好消息是许多与课程相关的问题已经解决了。这很好，因为仍然有应用程序在使用它们，所以现在需要担心的事情更少了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d00" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">班级隐私</h1><p id="7b08" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">默认情况下，类属性是公共的。这意味着我们可以访问和修改用类创建的<a class="ae lu" href="https://medium.com/dailyjs/15-fundamentals-you-should-know-on-javascript-objects-90f57cc9d78d" rel="noopener">对象</a>的任何属性。然而，散列(<code class="fe mz na nb nc b">#</code>)前缀现在允许我们定义私有属性。</p><p id="316e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">#</code>是属性名的一部分。它用于声明和访问这样的字段。</p><p id="c3cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">私有字段只能在<a class="ae lu" href="https://medium.com/programming-essentials/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15" rel="noopener">类</a>中访问。下面是一个封装了<code class="fe mz na nb nc b">count</code>字段的<code class="fe mz na nb nc b">Counter</code>类的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="226c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/did-you-know-that-almost-everything-is-an-object-in-javascript-f06c3f69faf1">对象</a>被创建，内部的<code class="fe mz na nb nc b">#count</code>可以仅使用公共方法来改变。</p><p id="0bb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">内部私有<code class="fe mz na nb nc b">#count</code>字段不能直接修改。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="6594" class="nj md it nc b gy nk nl l nm nn">stack.#count = 0;<br/>//Private field '#count' must be declared in an enclosing class</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8e0f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法内部的内部函数</h1><p id="c5e2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">正如您可能已经知道的，在方法内部定义的内部函数中有一些关于<code class="fe mz na nb nc b">this</code>参数的问题。</p><p id="610c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">this</code>取决于调用函数的方式，而不是函数的定义位置。例如，如果我们使用函数表达式定义回调，这就会产生问题。</p><p id="a043" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看下面的<code class="fe mz na nb nc b">print</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="83a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为回调发送给<code class="fe mz na nb nc b">setTimeout</code>实用程序的匿名函数作为一个函数被调用，并且不指向与<code class="fe mz na nb nc b">print</code>方法相同的对象。</p><p id="fe74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很高兴我们可以通过使用arrow语法创建内部函数来避免这些问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4610" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">箭头函数没有自己的<code class="fe mz na nb nc b">this</code>参数。这意味着箭头函数使用父方法中的<code class="fe mz na nb nc b">this</code>参数。</p><p id="2e8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，一些问题仍然存在。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="33e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法可以被重新定义</h1><p id="a663" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">私有字段不能从<a class="ae lu" href="https://medium.com/dailyjs/15-fundamentals-you-should-know-on-javascript-objects-90f57cc9d78d" rel="noopener">对象</a>之外进行修改，但是公共方法可以修改。</p><p id="4946" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以从客户端代码重新定义公共方法。下面是一个改变<code class="fe mz na nb nc b">increment</code>方法的例子。新的<code class="fe mz na nb nc b">increment</code>方法没有任何作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="00cb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这个参数可以改变上下文</h1><p id="0b4c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">由于<code class="fe mz na nb nc b">this</code>参数的工作方式，仍然有边缘情况会导致问题。</p><p id="2535" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个使用析构赋值语法的例子。因为<code class="fe mz na nb nc b">increment</code>现在作为一个函数被调用，<code class="fe mz na nb nc b">this</code>不再引用我们的对象，我们得到一个错误:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="79ab" class="nj md it nc b gy nk nl l nm nn">const { increment, decrement } = new Counter();<br/>increment();<br/>//Cannot read property '#count' of undefined at increment</span></pre><p id="2656" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是另一个例子，其中<code class="fe mz na nb nc b">increment</code>作为一个函数而不是方法被调用。由于这个原因，<code class="fe mz na nb nc b">this</code>没有引用我们的对象，我们收到一个错误:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1744" class="nj md it nc b gy nk nl l nm nn">const counter = new Counter();<br/>setTimeout(counter.increment, 0);<br/>//Cannot read private member #count from an object whose class did not declare it</span></pre><p id="41de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免前面的问题，我们需要确保<code class="fe mz na nb nc b">increment</code>作为一个方法被调用:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3c79" class="nj md it nc b gy nk nl l nm nn">const counter = new Counter();<br/>setTimeout(() =&gt; counter.increment(), 0);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="17cd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">工厂功能</h1><p id="33c6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">工厂函数提供了构建<a class="ae lu" href="https://medium.com/dailyjs/15-fundamentals-you-should-know-on-javascript-objects-90f57cc9d78d" rel="noopener">对象</a>的替代方法，类似于用类创建的对象，但是没有与<code class="fe mz na nb nc b">this</code>相关的问题，并且具有冻结的接口。</p><p id="e435" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个概念是由道格拉斯·克洛克福特首创的。这是它的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9699" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">Counter</code>是一个函数，返回一个只包含函数的冻结对象。</p><p id="09ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在JavaScript中，函数可以在其他函数中定义。内部函数可以从父函数中访问变量。即使在父函数执行之后，它们也可以访问这些变量。从父函数访问变量的内部函数被称为<a class="ae lu" href="https://medium.com/programming-essentials/you-will-finally-understand-what-closure-is-13ba11825319" rel="noopener">闭包</a>。</p><p id="370a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">increment</code>和<code class="fe mz na nb nc b">decrement</code>是闭包。它们都从外部函数<code class="fe mz na nb nc b">Counter</code>访问同一个变量<code class="fe mz na nb nc b">count</code>。</p><p id="6cf7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们冻结返回的对象，这样客户端代码就不能改变它的方法。</p><p id="772e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们甚至可以用<code class="fe mz na nb nc b">new</code>操作符:<code class="fe mz na nb nc b">new Counter()</code>调用工厂函数。当像函数<code class="fe mz na nb nc b">Counter()</code>一样被调用时，它仍然返回相同的对象:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="bd66" class="nj md it nc b gy nk nl l nm nn">const counter = new Counter();</span></pre><p id="052f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">count</code>变量是私有的。不能从对象外部直接修改它:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="b7aa" class="nj md it nc b gy nk nl l nm nn">const counter = Counter();<br/>counter.count = 0;<br/>//Cannot add property count, object is not extensible</span></pre><p id="0a74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">客户端代码不能像以前使用<a class="ae lu" href="https://medium.com/programming-essentials/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15" rel="noopener">类</a>构建对象时那样重新定义对象的公共方法:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="85d1" class="nj md it nc b gy nk nl l nm nn">const counter = new Counter();<br/>counter.increment = function(){};<br/>//Cannot assign to read only property 'increment' of object</span></pre><p id="bcdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当析构这些方法并像调用函数一样调用它们时没有问题:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="ee5c" class="nj md it nc b gy nk nl l nm nn">const {increment, decrement } = Counter();<br/>increment();<br/>//1</span></pre><p id="1b2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当方法作为回调发送并像函数一样被调用时，没有任何问题:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="f11f" class="nj md it nc b gy nk nl l nm nn">const counter = new Counter();<br/>setTimeout(counter.increment, 0);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc98" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="cc9e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">对类行为进行了改进。使用<code class="fe mz na nb nc b">#</code>前缀我们不可能有隐私。我们可以通过使用箭头函数来避免方法中的<code class="fe mz na nb nc b">this</code>参数的问题。</p><p id="4095" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当事情不像预期的那样工作时，我们仍然会遇到令人困惑的问题。由于这个原因，我使用工厂函数。当创建数千个使用工厂函数而不是类似的类构建的对象时，会有内存损失，但是在应用程序中只有少数对象是使用工厂函数创建的——而不是数千个。在这种情况下，差别是微不足道的。以这种方式创建的对象具有私密性，并且没有与<code class="fe mz na nb nc b">this</code>参数相关的问题，原因很简单，因为根本没有使用<code class="fe mz na nb nc b">this</code>。</p><p id="8492" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们从JavaScript语言中移除关键字<code class="fe mz na nb nc b">this</code>会发生什么，你可以看看没有“this”的<a class="ae lu" href="https://medium.com/programming-essentials/removing-javascripts-this-keyword-makes-it-a-better-language-here-s-why-db28060cc086" rel="noopener"> JavaScript看起来像一种更好的函数式编程语言</a>。</p><p id="4003" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。</p></div></div>    
</body>
</html>