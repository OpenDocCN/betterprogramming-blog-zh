<html>
<head>
<title>Getting Started With RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-rxjs-1b6260dd184b?source=collection_archive---------12-----------------------#2020-02-12">https://betterprogramming.pub/getting-started-with-rxjs-1b6260dd184b?source=collection_archive---------12-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4151" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果你是一个新手或者经验丰富的JavaScript开发人员，你可能听说过RxJS。让我们开始吧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71df7d3451976adcb19f624bffa2750b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CxEk8T5gUdP7AVu0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@jenrielzany?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zany Jadraque </a>拍摄的照片。</p></figure><p id="23a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一个新手或者经验丰富的JavaScript开发人员，你可能听说过RxJS。</p><p id="f166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJS是目前最流行的JavaScript库之一。这篇文章将介绍它是什么以及如何在应用程序中使用它的基本步骤。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="afa6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">历史</h1><p id="95d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所以在我开始之前，了解RxJS背后的历史是有帮助的。</p><p id="9ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切都始于<a class="ae ky" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">反应式延伸</a>(或ReactiveX)。ReactiveX是一个最初由埃里克·梅耶尔发明的概念。这是观察者模式<a class="ae ky" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">的一个实现。在它被开发出来之后，随后的编程库围绕着像。NET和JavaScript。</a></p><p id="59f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJS是JavaScript的反应式扩展的实现。<a class="ae ky" href="https://github.com/ReactiveX/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJS项目</a>最初是由<a class="ae ky" href="https://github.com/mattpodwysocki" rel="noopener ugc nofollow" target="_blank"> Matthew Podwysocki </a>等人作为一个独立的开源项目启动的。大约从RxJS版本5开始，<a class="ae ky" href="https://github.com/benlesh" rel="noopener ugc nofollow" target="_blank"> Ben Lesh </a>和其他人改进了这个项目，使其更接近今天的样子。</p><p id="4ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJS库实现了<a class="ae ky" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="noopener ugc nofollow" target="_blank">迭代器模式</a>。</p><p id="ba77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJS库也使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>来实现操作符和函数来管理事件序列(流)。关于函数式编程的精彩介绍，我强烈推荐观看Russ Olsen在GOTO 2018上的演示视频。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="681d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">命令式与陈述式</h1><p id="e5c6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你听到人们讨论RxJS时，你通常会听到他们提到命令式和声明式编码。</p><p id="017e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令式指的是以特定方式编写的代码。这是你手动控制流程的代码，类似于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>工作的方式。</p><p id="9b4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明性是指使用声明的函数来执行动作。这里，您依赖于可以定义事件流的“纯”函数。在RxJS中，你可以看到<a class="ae ky" href="https://rxjs.dev/guide/observable" rel="noopener ugc nofollow" target="_blank">观察值</a>和<a class="ae ky" href="https://rxjs.dev/guide/operators" rel="noopener ugc nofollow" target="_blank">运算符</a>的形式。</p><p id="f520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些定义将在本文的后面变得更加明显，但是在这里介绍它们是有好处的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed90" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">看得见的</h1><p id="81ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在解释RxJS时，通常最简单的方法是首先显示代码。</p><p id="21ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数人通常都熟悉如下实现的承诺:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/a1ddd7dbb74123d09cc82fa413abc4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/0*2bJQZNiZGCl1Wwau"/></div></div></figure><p id="9add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有什么特别令人兴奋的——只是使用了标准的“解决/拒绝”语法。承诺完成后，输出消息被写入控制台。</p><p id="1067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在比较一下这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8da2a3d17ca0b63f6f7b7bb5d005c739.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*3mm30sgqLr4g3qgt"/></div></figure><p id="05e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇哦。那是什么？嗯，那就是RxJS！如果你注意到，当可观察对象首先被定义，然后观察者中的不同钩子与<code class="fe nb nc nd ne b">next</code>、<code class="fe nb nc nd ne b">error</code>和<code class="fe nb nc nd ne b">complete</code>一起使用时，声明性实践被使用。</p><p id="bd7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章的后面我会回到这个例子，但我想先介绍一下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f8c0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RxJS是怎么工作的？</h1><p id="b286" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，从RxJS开始，首先有几个定义会有所帮助:</p><ul class=""><li id="b92d" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">可观察的=一系列确定的事件</li><li id="c34f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">Subscription =表示事件的实际执行流(发起订阅基本上是“启动”执行)</li><li id="94f3" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">Operators =是“纯”函数，可以调用带有订阅的流。这些有不同的形式，可以创建一个流或复制一个管道流的流。</li><li id="2521" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">Subject =可用于多播的事件发射器。这些是特殊的，所以你可以在你的程序中注入发射器。</li><li id="64ed" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">调度器=这些有助于并发性，实际上是一个更高级的RxJS主题。为了完整起见，我将它们包含在这里。</li></ul><p id="a564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如需更多信息和示例，请在此处参考<a class="ae ky" href="https://rxjs.dev/guide/overview" rel="noopener ugc nofollow" target="_blank">官方RxJS入门指南</a>。</p><p id="f40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些词汇，现在我们可以正式讨论我之前介绍的例子了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a57" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可观察的(再次)</h1><p id="6f65" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们回到我之前展示的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/074052c91632cfaf784f40d46918cbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*DjSCTUraRIHKIF9u"/></div></figure><p id="bab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的例子，因为它向您展示了一个实现的可观察对象。</p><p id="6469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你注意到了，首先你用<code class="fe nb nc nd ne b">next</code>和<code class="fe nb nc nd ne b">complete</code>定义了可观测值。然后当我用<code class="fe nb nc nd ne b">subscribe</code>开始执行流程时，我包含了对执行流程做什么的定义:</p><ul class=""><li id="9a50" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">next =对从流中返回的内容执行一个<code class="fe nb nc nd ne b">console.log</code></li><li id="d3ea" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">error =如果流中出现错误，则执行<code class="fe nb nc nd ne b">console.log</code></li><li id="6040" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">complete =执行完成时将<code class="fe nb nc nd ne b">done</code>写入控制台</li></ul><p id="39ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是直接定义可观测值的一种方法。每个观察者都有三个钩子<code class="fe nb nc nd ne b">next</code>、<code class="fe nb nc nd ne b">error</code>和<code class="fe nb nc nd ne b">complete</code>，您可以用它们来定义执行行为。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58cf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">经营者</h1><p id="f40f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可观测量很棒，但是RxJS也提供了操作符，这使得定义可观测量更加容易。</p><p id="439d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种类型的运算符:</p><ul class=""><li id="9cfd" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">创建运算符=具有预定义行为的生成的可观察值</li><li id="0191" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">可管道操作符=使用语法<code class="fe nb nc nd ne b">.pipe</code>返回其他观察值的观察值</li></ul><p id="155b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个正在运行的创建操作符:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0b9f1576810757cb69cb059006b8f16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/0*bgYRTtvEbO81lUSN"/></div></figure><p id="0ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用<code class="fe nb nc nd ne b">of</code>操作符在一个序列中发出<code class="fe nb nc nd ne b">10</code>、<code class="fe nb nc nd ne b">20</code>和<code class="fe nb nc nd ne b">30</code>的值。这是非常基本的，但是它让您知道如何使用它在流中发出一组值，而不需要手动定义观察器挂钩。</p><p id="8774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个可管道化的操作器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2cf689a3224b5c8386f26c6400dc5139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*y0DtXf3vTOTG9bU7"/></div></figure><p id="c45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这里，有点复杂，但我想你能搞清楚。</p><ol class=""><li id="cf36" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated">我们使用我之前提到的创建操作符<code class="fe nb nc nd ne b">of</code>来生成值流<code class="fe nb nc nd ne b">a</code>、<code class="fe nb nc nd ne b">b</code>、<code class="fe nb nc nd ne b">c</code>。</li><li id="248d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">接下来，我们将来自<code class="fe nb nc nd ne b">of</code>的输出放入管道操作符<code class="fe nb nc nd ne b">mergeMap</code>。</li><li id="772e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">然后我们让<code class="fe nb nc nd ne b">mergeMap</code>创造一个新的可观察对象，并把它传送到<code class="fe nb nc nd ne b">interval</code>。</li><li id="ba14" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">然后<code class="fe nb nc nd ne b">interval</code>在一秒钟的延迟后取每个值的输出和<code class="fe nb nc nd ne b">console.log</code>。</li></ol><p id="c17e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以基本上，这就用<code class="fe nb nc nd ne b">pipeable</code>操作符创建了一个流。原始源可观测值用于重新创建添加了逻辑的新可观测值。</p><p id="1cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一种更简单的方式来思考这个问题:这里定义了一个<code class="fe nb nc nd ne b">stream</code>。与流一起使用的每个管道都增加了价值。</p><p id="5bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对可管道化操作符的一种更字面的理解是，当水流过一组管道时。每根管子都增加了水的价值，直到它离开水流。</p><p id="9c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从视觉上看，您可以在下图中看到这种流动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/625c95e06613c8a7ff1e8913aed2a637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3-XCovpTaZapLGd9"/></div></div></figure><p id="6c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地观察RxJS的流程，许多人依赖大理石图。起初它们有点令人生畏，但是如果你学会了如何用RxJS指南阅读它们，它们真的很有帮助。我建议查看操作页面底部的<a class="ae ky" href="https://rxjs.dev/guide/operators" rel="noopener ugc nofollow" target="_blank"> RxJS指南</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b91a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">订阅和内存泄漏</h1><p id="d3a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，开发人员在使用RxJS时遇到的一个大挑战是订阅时的内存泄漏。</p><p id="c265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存泄漏是指您忘记“取消订阅”某个流，而该过程继续运行，耗尽了您的内存。内存泄漏会很快耗尽浏览器的内存，降低应用程序的速度。</p><p id="f009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的解决办法是确保你有一个<code class="fe nb nc nd ne b">.unsubscribe</code>可以观察到的东西。你也可以依赖框架中的预建机制，比如Angular的<code class="fe nb nc nd ne b">async</code>管道。</p><p id="c4a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些导致内存泄漏的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e662f15b245f03f7f58e460d69da3aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/0*VnkOWj4Vy144nrRp"/></div></figure><p id="3abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加一个<code class="fe nb nc nd ne b">setTimeout</code>可以很容易地修复这个代码，它会在设定的时间间隔后取消订阅流，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1c01666e97917407d94ece6f879d7fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/0*nNiZaC5ooquMHBya"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e8ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">高级主题</h1><p id="3432" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们已经讨论了一些基本的执行流程。如果结合使用RxJS操作符，就可以用少量代码定义一些非常复杂的工作。</p><p id="ecf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你从一个单独的可观测值创建一组可观测值时，挑战就来了。这被称为高阶可观测值。RxJS有一些运算符可以帮助您消除这些情况，包括:</p><p id="5d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算在这里深入探讨高阶可观测性的例子，因为我认为这超出了一篇介绍性文章的范围。然而，我强烈推荐查看关于操作员的RxJS指南,该指南对此进行了更详细的讨论。</p><p id="55d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的博客文章“从承诺到观察”中，我还谈到了一个更高级的话题。在这种情况下，我通过设置一个<code class="fe nb nc nd ne b">scan</code>操作符来组合几个HTTP调用。</p><p id="82c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我推荐阅读<a class="ae ky" href="https://dev.to/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJS DEVTO博客网站</a>上的帖子，了解更多可观察的案例和讨论。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4e6e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步阅读</h1><p id="0e02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我在这篇文章中的讨论只是覆盖了你能用RxJS做什么的表面。网上还有许多很棒的材料和视频，提供了深入的演练和示例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="97c8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="507c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">希望这对你学习RxJS有所帮助。在这篇文章中，我介绍了RxJS是什么以及如何在程序中使用它。</p><p id="db67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章！</p></div></div>    
</body>
</html>