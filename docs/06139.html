<html>
<head>
<title>What Are Micro Frontends? Is It Even Necessary to Use Them?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是微前端？有必要使用它们吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-micro-frontends-is-it-even-necessary-to-use-them-f1393d65ef2f?source=collection_archive---------4-----------------------#2020-09-04">https://betterprogramming.pub/what-are-micro-frontends-is-it-even-necessary-to-use-them-f1393d65ef2f?source=collection_archive---------4-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b95" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用小部件构建复杂的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f0e73f46721669f498dc438bd4169903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhck0WCVgO26Y5ynslwdEg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:<a class="ae ku" href="https://medium.com/js-dojo/micro-frontends-using-vue-js-react-js-and-hypernova-af606a774602" rel="noopener">https://medium . com/js-Dojo/micro-frontends-using-vue-js-react-js-and-hypernova-af 606 a 774602</a></p></figure><p id="f7f4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">微前端架构是一种架构类型，在这种架构中，web应用程序被视为由独立的团队所拥有的功能的组合。这种方法最适合复杂的应用程序，因为随着时间的推移，应用程序会变得有点混乱，难以维护。</p><p id="352e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们深入研究为什么要使用它们之前，让我们先来看看所使用的基本架构类型。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9941" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用的架构模式的基本类型</h1><ul class=""><li id="ef18" class="mq mr it kx b ky ms lb mt le mu li mv lm mw lq mx my mz na bi translated"><strong class="kx iu"> Monolith </strong> —在这种类型的架构中，程序员通常是全栈开发人员。他们倾向于在前端和后端都工作。</li><li id="c7aa" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">FE/BE</strong>——这里有一个独立的程序员团队，他们关注前端开发，通常被称为前端开发人员/工程师。另一组从事后端和数据库工作，被称为后端开发人员/工程师。</li><li id="900c" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">微服务</strong> —微服务是一种架构风格，其中应用程序被分解为松散耦合的服务，并且有特定的团队研究每项服务，因为逻辑太复杂，为了易于使用，必须对其进行细粒度处理。</li><li id="2f5b" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">微前端</strong> —服务器逻辑趋于变得更加复杂。如今，随着应用程序的增长，甚至前端团队也需要类似的方法。简单来说，这些就是前端的微服务。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="912d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">选择这种方法的主要优势</h1><ul class=""><li id="72ea" class="mq mr it kx b ky ms lb mt le mu li mv lm mw lq mx my mz na bi translated"><strong class="kx iu">独立团队</strong> —每个团队都可以独立于其他团队工作，因为团队之间没有依赖性。整个团队负责开发一组特性，包括开发、测试和部署过程。</li><li id="bf7d" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">技术不可知论</strong> —不管其他团队用什么，每个团队都可以用自己的技术。说一个团队可以用React，一个团队可以用Angular，一个团队可以用vanilla JS，以此类推。</li><li id="5728" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">简单测试</strong> —测试变得相当简单，即使是很小的变化，因为我们不必去测试整个应用程序——我们只需要测试团队的模块。</li><li id="59f0" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">更好的维护</strong> —通过使用这种方法，维护应用程序代码变得非常容易，因为它很容易部署在小部件中，并且您还缩短了构建时间。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="477f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">用于实现微前端的流行技术</h1><ul class=""><li id="03c9" class="mq mr it kx b ky ms lb mt le mu li mv lm mw lq mx my mz na bi translated"><strong class="kx iu">元框架</strong> —有很多框架，其中一个就是单个单页面应用(SPA)。这个框架允许您在运行时组合多个JavaScript框架/库，而无需刷新页面。</li><li id="07f5" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">不同URL上的多个SPAs</strong>——这是目前最简单的拥有多个微前端的方式——当访问不同的URL时，有单独的SPAs呈现。应用程序使用npm组件来共享功能。</li><li id="0d8c" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu">iframe</strong>—这里应用程序使用iframe来共享功能。iFrames共享由其父窗口展示的API，例如，Window.postMessage API可用于在微前端之间进行协调。</li><li id="4443" class="mq mr it kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated"><strong class="kx iu"> Web组件</strong> —在这种方法中，我们使用一个JavaScript包装器将Angular/React或任何其他组件转换成Web组件，并将它们并排提供。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8c59" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">我应该在什么时候选择这种方法？</h1><p id="fef7" class="pw-post-body-paragraph kv kw it kx b ky ms ju la lb mt jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">答案相当简单。这取决于您的应用程序有多复杂。如果您认为您的应用程序很简单，那么您可以坚持使用单一的方法。</p><p id="f30e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是，如果您正在构建一个大型应用程序，如果您正在与大量人员/团队一起工作，或者如果您使用微服务作为后端架构，那么选择这种微前端方法是非常有益的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="166d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="1e64" class="pw-post-body-paragraph kv kw it kx b ky ms ju la lb mt jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">现在有很多方法可以接近微前端。我建议您在开始实现这种方法之前，检查各种模式和解决方案。目前还没有任何实现微前端的标准。通过选择这种方法，与单一方法相比，您肯定会有很多优势。</p><p id="df7b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我希望这篇文章能让你对微前端有一个简单的了解。感谢阅读！</p></div></div>    
</body>
</html>