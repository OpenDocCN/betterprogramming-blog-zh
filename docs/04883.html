<html>
<head>
<title>3 Essential Questions About Hashable in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python中Hashable的3个基本问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-essential-questions-about-hashable-in-python-33e981042bcb?source=collection_archive---------4-----------------------#2020-05-19">https://betterprogramming.pub/3-essential-questions-about-hashable-in-python-33e981042bcb?source=collection_archive---------4-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="915a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从一般讨论到具体实施</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abdb4a462966c5e1a6daf42ba39e7edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eL1s2Ik6LMju82xU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@omgitsyeshi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">石页·康让</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a4a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一种通用编程语言，Python为各种用例提供了大量内置数据类型。</p><p id="c6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你学会了这些基础知识，你可能会在某些时候遇到提到<em class="lv"> hashable </em>的情况。例如，您可能会看到<code class="fe lw lx ly lz b">dict</code>中的键需要是可散列的(参见下面代码片段中的一个小例子)。</p><p id="0886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子，提到了<code class="fe lw lx ly lz b">set</code>中的元素需要是可散列的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道hashable到底是什么意思？哪些对象是可散列的，哪些是不可散列的？如果我们使用不可哈希的对象作为字典的键，会发生什么？诸如此类。可以问很多相关的问题。</p><p id="ac0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将回顾一些关于hashability的要点，这样你将学会如何解决这些问题。最后，你可能会发现，这些问题其实一点也不难，不像你最初想的那样。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3332" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">哪些对象是可散列的，哪些是不可散列的？</h1><p id="1035" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们开始任何机械解释之前，我们想要解决的第一个问题是，哪些对象是可散列的，哪些是不可散列的。</p><p id="74f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们知道Python明确要求<code class="fe lw lx ly lz b">set</code>中的元素应该是可散列的，所以我们可以通过简单地将对象添加到<code class="fe lw lx ly lz b">set</code>中来测试对象的可散列性。成功插入表示对象是可散列的，反之亦然。</p><pre class="kj kk kl km gt ng lz nh ni aw nj bi"><span id="d425" class="nk mk it lz b gy nl nm l nn no">&gt;&gt;&gt; <strong class="lz iu"># Create an empty set object</strong><br/>&gt;&gt;&gt; elements = set()<br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; <strong class="lz iu"># The list of objects with each to be inserted to the set</strong><br/>&gt;&gt;&gt; items = [1, 0.1, 'ab', (2, 3), {'a': 1}, [1, 2], {2, 4}, None]</span></pre><p id="0d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，我创建了一个名为<code class="fe lw lx ly lz b">elements</code>的<code class="fe lw lx ly lz b">set</code>变量和一个名为<code class="fe lw lx ly lz b">items</code>的<code class="fe lw lx ly lz b">list</code>变量，其中包含了最常用的内置数据类型:<code class="fe lw lx ly lz b">int</code>、<code class="fe lw lx ly lz b">float</code>、<code class="fe lw lx ly lz b">str</code>、<code class="fe lw lx ly lz b">tuple</code>、<code class="fe lw lx ly lz b">dict</code>、<code class="fe lw lx ly lz b">list</code>、<code class="fe lw lx ly lz b">set</code>和<code class="fe lw lx ly lz b">NoneType</code>。</p><p id="b9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将运行的实验是将每个<code class="fe lw lx ly lz b">items</code>添加到<code class="fe lw lx ly lz b">elements</code>中。在这种情况下，我不会使用<code class="fe lw lx ly lz b">for</code>循环，因为任何可能的<code class="fe lw lx ly lz b">TypeError</code>都会停止迭代。相反，我将只使用索引来检索单个项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的代码片段中看到的，这里是实验结果的快速总结。</p><h2 id="bc7b" class="nk mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">对部门问题的回答</strong></h2><ul class=""><li id="9836" class="oa ob it lb b lc nb lf nc li oc lm od lq oe lu of og oh oi bi translated">可哈希数据类型:<code class="fe lw lx ly lz b">int</code>、<code class="fe lw lx ly lz b">float</code>、<code class="fe lw lx ly lz b">str</code>、<code class="fe lw lx ly lz b">tuple</code>、<code class="fe lw lx ly lz b">NoneType</code>。</li><li id="3bac" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">不可隐藏的数据类型:<code class="fe lw lx ly lz b">dict</code>、<code class="fe lw lx ly lz b">list</code>和<code class="fe lw lx ly lz b">set</code>。</li></ul><p id="ccec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是Python编程的新手，您可能已经注意到这三种不可哈希的数据类型本质上都是可变的，而这五种可哈希的数据类型都是不可变的。</p><p id="030f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，这些可变数据是其值在创建后可以更改的对象，而不可变对象的值在创建后不能更改。</p><p id="b8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据可变性是一个独立的主题，我在之前的另一篇<a class="ae ky" href="https://medium.com/swlh/6-things-to-understand-python-data-mutability-b52f5c5db191" rel="noopener">文章</a>中已经讨论过。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="a226" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Hashable是什么意思？</h1><p id="f7af" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">您现在已经知道哪些对象是可散列的，哪些不是，但是可散列到底是什么意思呢？</p><p id="829c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，你可能听过很多类似的与hashable相关的计算机术语，比如hash value、hashing、hash table和hashmap。从本质上讲，它们共享相同的基本过程——散列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8fc0aea9f4e89e3570e64738066c9bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*DMk42PdjZOSHPyqynP1M-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈希的一般流程(<a class="ae ky" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">维基百科</a>，公共领域)</p></figure><p id="f1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示了散列的一般过程。我们从一些原始数据值开始(在图中称为<em class="lv">键</em>)。</p><p id="c3b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时被称为<em class="lv">散列器</em>的散列函数将执行特定的计算并输出原始数据值的散列值(在图中被称为<em class="lv">散列值</em>)。</p><p id="d8af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希及其相关概念需要一整本书来阐明，这超出了本文的范围。然而，一些重要的方面已经在我的<a class="ae ky" href="https://medium.com/better-programming/what-is-hashable-in-swift-6a51627f904" rel="noopener">上一篇文章</a>中简要讨论过了。</p><p id="7fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将只强调与当前讨论相关的一些要点。</p><ol class=""><li id="7623" class="oa ob it lb b lc ld lf lg li op lm oq lq or lu os og oh oi bi translated">散列函数应该是<em class="lv">计算健壮的</em>，使得不同的对象应该具有不同的散列值。当不同的对象具有相同的哈希值时，就会发生冲突(如上图所示)，应该进行处理。</li><li id="a0ca" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu os og oh oi bi translated">散列函数应该<em class="lv">一致</em>，使得相同的对象将总是导致相同的散列值。</li></ol><p id="dca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python实现了内置的散列函数，为其对象生成散列值。具体来说，我们可以通过使用内置的<code class="fe lw lx ly lz b">hash()</code>函数来检索对象的哈希值。下面的代码展示了一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们能够获得哈希值——<code class="fe lw lx ly lz b"> int</code>和<code class="fe lw lx ly lz b">tuple</code>对象的整数。</p><p id="c177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lw lx ly lz b">list</code>对象和<code class="fe lw lx ly lz b">dict</code>对象都没有哈希值。这些结果与我们在上一节中对可哈希对象和不可哈希对象的区分是一致的。</p><h2 id="7b50" class="nk mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">对部门问题的回答</strong></h2><ul class=""><li id="9a53" class="oa ob it lb b lc nb lf nc li oc lm od lq oe lu of og oh oi bi translated">hashable:Python对象的一个特性，用于指示对象是否具有哈希值，这允许对象充当字典中的键或集合中的元素。</li></ul></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="8722" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">如何定制Hashability？</h1><p id="f8e5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Python作为通用编程语言的灵活性主要来源于它对创建自定义类的支持。有了自己的类，许多相关的数据和操作可以以一种更有意义和可读性的方式进行分组。</p><p id="d10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是，Python已经进化得足够智能，使得我们的定制对象在大多数情况下都是默认可散列的。</p><p id="45fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子。我们创建了一个定制类<code class="fe lw lx ly lz b">Person</code>，它允许我们通过指定一个人的姓名和社会保险号来创建实例。</p><p id="1e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，我们使用f-string方法覆盖了默认的<code class="fe lw lx ly lz b">__repr__()</code>函数，这将允许我们显示具有更多可读信息的对象，如代码片段的最后一行所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，我们可以通过使用内置的<code class="fe lw lx ly lz b">hash()</code>函数来找出创建的对象<code class="fe lw lx ly lz b">person0</code>的哈希值。重要的是，我们能够将<code class="fe lw lx ly lz b">person0</code>对象作为一个元素包含在<code class="fe lw lx ly lz b">set</code>对象中，这很好。</p><p id="dd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们想向集合中添加更多的<code class="fe lw lx ly lz b">Person</code>实例，会发生什么呢？更复杂但可能的情况是，我们构造同一个人的多个<code class="fe lw lx ly lz b">Person</code>对象，并尝试将它们添加到<code class="fe lw lx ly lz b">set</code>对象中。</p><p id="5091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请参见下面的代码。我创建了另一个<code class="fe lw lx ly lz b">Person</code>实例<code class="fe lw lx ly lz b">person1</code>，它有相同的名字和社会保险号——本质上是同一个自然人。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们将这个人添加到<code class="fe lw lx ly lz b">set</code>对象<code class="fe lw lx ly lz b">persons</code>时，两个<code class="fe lw lx ly lz b">Person</code>对象都在<code class="fe lw lx ly lz b">set</code>中，这是我们不希望发生的。</p><p id="cc1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为，按照设计，我们希望<code class="fe lw lx ly lz b">set</code>对象存储唯一的自然人。与包含在<code class="fe lw lx ly lz b">set</code>对象中的两个人一致，我们发现这两个<code class="fe lw lx ly lz b">Person</code>实例确实不同。</p><p id="4761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示我们如何使自定义类<code class="fe lw lx ly lz b">Person</code>更智能的代码，以便它知道哪些人是相同的，哪些人是不同的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="7890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们通过覆盖<code class="fe lw lx ly lz b">__hash__</code>和<code class="fe lw lx ly lz b">__eq__</code>函数更新了自定义类<code class="fe lw lx ly lz b">Person</code>。</p><p id="f5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前提到过<code class="fe lw lx ly lz b">__hash__()</code>函数用于计算对象的哈希值。<code class="fe lw lx ly lz b">__eq__()</code>函数用于比较一个对象和另一个对象是否相等，并且要求比较相等的对象应该具有<a class="ae ky" href="https://docs.python.org/3.5/reference/datamodel.html#object.__hash__" rel="noopener ugc nofollow" target="_blank">相同的哈希值</a>。</p><p id="5223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，定制类实例通过使用内置的<code class="fe lw lx ly lz b">id()</code>函数比较它们的身份来进行比较(通过参考<a class="ae ky" href="https://medium.com/better-programming/use-id-to-understand-6-key-concepts-in-python-73e0bbd461ec" rel="noopener">本文</a>来了解关于<code class="fe lw lx ly lz b">id()</code>函数的更多信息)。</p><p id="3219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了更新的实现，我们可以看到，当我们试图创建一个由两个<code class="fe lw lx ly lz b">Person</code>对象组成的<code class="fe lw lx ly lz b">set</code>对象时，调用了<code class="fe lw lx ly lz b">__hash__()</code>函数，使得set对象只保留具有唯一哈希值的对象。</p><p id="3216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要注意的事情是，当Python检查<code class="fe lw lx ly lz b">set</code>对象中的元素是否有唯一的哈希值时，它会通过调用<code class="fe lw lx ly lz b">__eq__()</code>函数来确保这些对象不相等。</p><h2 id="8c69" class="nk mk it bd ml np nq dn mp nr ns dp mt li nt nu mv lm nv nw mx lq nx ny mz nz bi translated"><strong class="ak">对该部门问题的回答</strong></h2><p id="e6f1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">定制:为了在可散列性和平等性方面提供定制的行为，我们需要在我们的定制类中实现<code class="fe lw lx ly lz b">__hash__</code>和<code class="fe lw lx ly lz b">__eq__</code>函数。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6c65" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="f85d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在本文中，我们回顾了Python中hashable/hashability的概念。</p><p id="dd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，通过解决这三个重要的问题，我希望您对Python中的hashability有更好的理解。如果适用，您可以为自己的定制类实现定制的hashability行为。</p></div></div>    
</body>
</html>