<html>
<head>
<title>How To Operationalize a Model on Google Cloud’s Vertex AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在谷歌云的顶点人工智能上操作一个模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-operationalize-a-model-on-google-clouds-vertex-ai-53298b530703?source=collection_archive---------8-----------------------#2021-06-15">https://betterprogramming.pub/how-to-operationalize-a-model-on-google-clouds-vertex-ai-53298b530703?source=collection_archive---------8-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4511" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为顶点人工智能上的模型提供服务，以产生在线预测和解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7f24184c590a836fd8c2242d7b8f420d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*aeXlwnOS3DvVHiMVgBZbpQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">顶点AI(来源:<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">谷歌云</a>)</p></figure><h1 id="fe23" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">顶点AI教程系列</h1><ol class=""><li id="c095" class="ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330">在谷歌云的顶点人工智能上训练模型的逐步指南</a></li><li id="e0a9" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595">在谷歌云的顶点人工智能上调整模型的逐步指南</a></li><li id="bb39" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated">如何在Google Cloud的Vertex AI上操作一个模型(本文)</li><li id="62b2" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-automl-on-google-clouds-vertex-ai-27f8778239ea">如何在Google Cloud的Vertex AI上使用AutoML</a></li><li id="5d6c" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-bigquery-ml-on-google-clouds-vertex-ai-23b1ca0b635">如何在Google Cloud的Vertex AI上使用big query ML</a></li><li id="382a" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-pipeline-on-google-clouds-vertex-ai-863b429c811f">如何在Google Cloud的Vertex AI上使用Pipeline</a></li></ol><h1 id="9da8" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">背景</h1><p id="25d4" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">这是<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">顶点AI </a>教程系列的第三集。在<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330">第一篇</a>中，我们训练了我们的第一个模型。在<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595">第二篇</a>中，我们对其进行了优化。现在是时候利用它了。在本文中，我们将在Vertex AI上部署该模型，并查询它以进行预测和解释。</p><p id="bfd3" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">简单回顾一下，我们正在解决的问题是一个图像分类问题。该模型在<a class="ae ku" href="https://www.tensorflow.org/datasets/catalog/cifar10" rel="noopener ugc nofollow" target="_blank"> CIFAR10 </a>数据集上进行训练，该数据集包含10个类别的60，000个32x32图像。在之前的文章中，我们训练并导出了我们的最佳模型到Google云存储文件夹中。</p><h1 id="8bc8" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">模型部署</h1><p id="0cac" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">模型部署的第一步是将模型导入Vertex AI。这听起来可能有点令人困惑。即使该模型是在Vertex AI上训练的，并保存到Google云存储中，但在我们将其作为模型资源导入之前，它还没有正式在Vertex AI中。使用以下命令导入模型。查看文档了解其他可用的预制集装箱图像。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1bef" class="nh kw it nd b gy ni nj l nk nl">gcloud beta ai models upload --region=us-central1 \<br/>--display-name=e2e-tutorial-model \<br/>--container-image-uri=us-docker.pkg.dev/vertex-ai/prediction/tf2-cpu.2-3:latest \<br/>--artifact-uri=GCS_PATH_FOR_SAVED_MODEL</span></pre><p id="72e4" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">接下来，让我们在顶点AI中创建一个端点。端点将是模型的前端。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="503b" class="nh kw it nd b gy ni nj l nk nl">gcloud beta ai endpoints create --region=us-central1 \<br/>--display-name=e2e-tutorial-ep</span></pre><p id="256f" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们需要为后续命令找到模型和端点id。最简单的方法是在UI上查找它们:顶点AI -&gt;模型和顶点AI -&gt;端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/224fa6d6420d987daf297e2aa3fa731b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehjRn2O4C3getZ0DxjyOZA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">模型ID的视图</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nr"><img src="../Images/28960f57022c4a90699f3fc695f7b6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6qAs6CHzlBc5oe_fIifQQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">端点ID的视图</p></figure><p id="8421" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">现在我们可以将模型部署到端点。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e157" class="nh kw it nd b gy ni nj l nk nl">gcloud beta ai endpoints deploy-model ENDPOINT_ID \<br/>--region=us-central1 --model=MODEL_ID \<br/>--machine-type=n1-standard-2 --min-replica-count=1 \<br/>--max-replica-count=1 --traffic-split=0=100 \<br/>--display-name=e2e-tutorial-dp</span></pre><p id="45e5" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">这里有一些事情需要注意:首先，机器类型需要与我们用来导入模型的容器图像相匹配。例如，如果您使用CPU容器映像导入模型，那么您不能使用GPU机器类型将模型部署到端点。其次，流量分割允许您在同一端点后面的多个模型之间分配流量。在我们的示例中，我们总是将100%的流量定向到最新的模型部署。最后，您选择的机器类型可能在该地区不可用，并且在部署模型时似乎会出现一些不稳定的问题。您可能需要迭代并重试几次。</p><p id="eb8d" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们可以在UI上检查模型是否确实部署到了端点。在模型的详细页面上，我们可以看到相关的端点。在端点的详细页面上，我们可以看到模型部署。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ns"><img src="../Images/980913ac9ba90613b3fa60a4d770bb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lxb3dEtt5p1osTyiaJmtgA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">与模型关联的端点</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/b9ffe22ef429acfb57bfabed25bce37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlRNcQE5g_lopji5rIfFkw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">端点包含的模型</p></figure><h1 id="d648" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">在线预测</h1><p id="453e" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">我们现在可以向查询预测发送实时请求。我们需要首先准备输入数据。端点需要一个JSON输入，其中的一个<code class="fe nu nv nw nd b">instances</code>列表包含模型的输入张量。让我们从测试数据集中加载第一个测试图像和标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">获取测试图像</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/135be995875b5c71be17678b25d21841.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*cwbrJ0zhb9RS5ftPh0auKw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">测试图像</p></figure><p id="f18a" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">然后，我们将图像标准化，并将其写入一个<code class="fe nu nv nw nd b">prediction_request.json</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">准备预测请求</p></figure><p id="0781" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">最后，让我们发送预测请求。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fa41" class="nh kw it nd b gy ni nj l nk nl">gcloud beta ai endpoints predict ENDPOINT_ID \<br/>--region=us-central1 --json-request=prediction_request.json</span></pre><p id="79e3" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">响应是模型的输出，是每个类的概率。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="143d" class="nh kw it nd b gy ni nj l nk nl">[[0.0139101977, 0.000138922522, 0.0321449339, 0.760269284, 0.000860376749, 0.132355079, 0.0505387783, 0.00525797112, 0.00383508834, 0.000689392502]]</span></pre><p id="1e9b" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们可以看到第四个概率0.76最大，类名中第四个类是“猫”。因此，该模型正确地对图像进行了分类。</p><h1 id="d0a5" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">用于解释的模型部署</h1><p id="d97d" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">得到结果很好，但我们也很好奇为什么模型认为它是一只猫，更具体地说，是哪些输入区域导致了“猫”的分类Vertex AI支持多种归因方式。我们将使用<a class="ae ku" href="https://www.tensorflow.org/tutorials/interpretability/integrated_gradients" rel="noopener ugc nofollow" target="_blank">综合渐变</a>方法来突出显示输入图像上的“重要”区域，试图解释模型行为。</p><p id="90cb" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">不幸的是，为了能够使用顶点AI解释，我们需要在模型导入期间指定解释配置。这意味着我们需要重新开始。</p><p id="c479" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">这里我就省略一些重复的细节了。与上面的工作流程相比，有几个地方我们需要做出改变。</p><p id="0948" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">首先，我们将以下解释元数据准备到解释元数据<code class="fe nu nv nw nd b">.json</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">解释元数据</p></figure><p id="dcd9" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated"><code class="fe nu nv nw nd b">inputTensorName</code>和<code class="fe nu nv nw nd b">outputTensorName</code>对应于模型的输入和输出层。如果你不确定你的模型，你可以用<code class="fe nu nv nw nd b">saved_model_cli</code>来检查它们，它预装在Vertex AI笔记本上。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="347a" class="nh kw it nd b gy ni nj l nk nl">saved_model_cli show --dir GCS_PATH_FOR_SAVED_MODEL  --tag_set serve --signature_def serving_default</span></pre><p id="80a3" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">它输出以下信息。其中列出了输入和输出张量的名称。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="21ec" class="nh kw it nd b gy ni nj l nk nl">The given SavedModel SignatureDef contains the following input(s):<br/>  inputs['conv2d_input'] tensor_info:<br/>    dtype: DT_FLOAT<br/>    shape: (-1, 32, 32, 3)<br/>    name: serving_default_conv2d_input:0</span><span id="38c8" class="nh kw it nd b gy oa nj l nk nl">The given SavedModel SignatureDef contains the following output(s):<br/>  outputs['dense_1'] tensor_info:<br/>    dtype: DT_FLOAT<br/>    shape: (-1, 10)<br/>    name: StatefulPartitionedCall:0</span><span id="1c69" class="nh kw it nd b gy oa nj l nk nl">Method name is: tensorflow/serving/predict</span></pre><p id="3f07" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们在新模型导入期间指定解释元数据。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="d30b" class="nh kw it nd b gy ni nj l nk nl">gcloud beta ai models upload --region=us-central1 \<br/>--display-name=e2e-tutorial-model-explanable \<br/>--container-image-uri=us-docker.pkg.dev/vertex-ai/prediction/tf2-cpu.2-3:latest \<br/>--artifact-uri=GCS_PATH_FOR_SAVED_MODEL \<br/>--explanation-method=integrated-gradients \<br/>--explanation-step-count=50 \<br/>--explanation-metadata-file=explanation-metadata.json</span></pre><p id="d2ef" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">然后，我们对之前创建的端点执行相同的模型部署。您可以在UI: Vertex AI -&gt; Models上确认新的可解释模型与端点相关联。您还可以在UI上确认:Vertex AI -&gt; Endpoints，除了我们之前附加的模型之外，该端点还附加了新的可解释模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nr"><img src="../Images/db2b4721b351bfa22fccfd165933df52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQPkiTAx60r2F5asq5azww.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">新模型关联的端点</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ob"><img src="../Images/7231709bb636f4049652b39aaba3c347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1gv1_RvViuKKBPWL5D08A.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">端点包含的模型</p></figure><h1 id="35c6" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">在线解释</h1><p id="f29e" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">现在，我们可以向新的可解释模型发送与我们发送预测请求相同的请求，并期待一个归因图像来突出输入的“重要”区域。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fd63" class="nh kw it nd b gy ni nj l nk nl">gcloud beta ai endpoints explain ENDPOINT_ID \<br/>--region=us-central1 --json-request=prediction_request.json</span></pre><p id="cb0a" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">响应包含一个<code class="fe nu nv nw nd b">featureAttributions</code>结构，在其中我们可以找到base64编码的属性JPEG图像。然后我们解码并在原始图像旁边显示图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">显示属性地图</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oc"><img src="../Images/91e775ab9e7024c44f176985aecab8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAlpkaLjPUJ7CKupKX7PxA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">属性地图图像</p></figure><p id="54cb" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">它真的能解释模型行为吗？我将让读者来判断。</p><h1 id="e4d8" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">包裹</h1><p id="dcb6" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">到目前为止，我们已经在第一篇文章中构建了模型，在第二篇文章中优化了模型，并在本文中部署和使用了模型。这已经是一段很长的旅程了。但这还没有结束。推出第一个可用的模型仅仅是个开始。我们将在以后的文章中探讨我们将何去何从。</p></div></div>    
</body>
</html>