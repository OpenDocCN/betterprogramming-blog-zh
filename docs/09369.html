<html>
<head>
<title>How To Capture In-App Screenshots In Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中捕捉应用内截图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-capture-in-app-screenshots-in-android-567548eb78a2?source=collection_archive---------5-----------------------#2021-08-16">https://betterprogramming.pub/how-to-capture-in-app-screenshots-in-android-567548eb78a2?source=collection_archive---------5-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79a2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看一看<code class="fe ki kj kk kl b">getDrawingCache and </code> PixelCopy API实现</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/115cda554f58f2b471049e5a3bd9d3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q_nSk49RsoF88AkA"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3dfc" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在本文中，我们将学习一种广泛使用的截图方法，并解决其实时性问题。然后探索一个简单的解决方案，使用canvas进行基于视图的屏幕截图。</p><h1 id="3b13" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">介绍</h1><p id="1187" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">说到移动应用，截图的一个常见用法是提供更好的客户支持。我们通常更需要截图来更好地理解用户遇到的问题的背景。</p><p id="aae5" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">除了更好的服务之外，截图还被用于许多事情，比如当涉及到教育技术应用程序时，可以在屏幕上分享你的问题，或者从电子商务应用程序向你的家人发送入围购物项目的列表。</p><p id="930c" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我最近开始寻找一个完美的解决方案来拍摄应用程序内截图。我遇到了很多解决方案，但大多数都不能在不同Android版本或定制操作系统的设备上运行。但我最终找到了一个解决方案，它不涉及不赞成使用的方法，并且可以完美地与Android Canvas API一起工作。</p><p id="a04b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">没有任何延迟，让我们开始吧:</p><h1 id="24c5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">传统getDrawingCache</h1><p id="9b0d" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><code class="fe ki kj kk kl b">getDrawingCache</code>是视图类中的一个函数，其返回类型是表示视图的非缩放位图，如果缓存被禁用，则返回null<em class="mw">。</em>看一下代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">通过<code class="fe ki kj kk kl b">getDrawingCache</code>截图</p></figure><p id="c679" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">基本上，它是视图类的一个扩展函数。首先，我们通过date创建了一个具有唯一名称的文件，然后通过<code class="fe ki kj kk kl b">getDrawingCache</code>获得视图的位图。一旦我们有了位图和文件，我们使用我创建的<code class="fe ki kj kk kl b">saveFile</code>扩展函数来保存文件。看看<code class="fe ki kj kk kl b">saveFile</code>功能:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">将位图保存到文件系统中</p></figure><p id="404b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这种方法非常有效，但是有两个缺点:</p><ol class=""><li id="40e1" class="mz na it lf b lg lh lj lk lm nb lq nc lu nd ly ne nf ng nh bi translated">在Android 8及以上设备上就不行了</li><li id="991c" class="mz na it lf b lg ni lj nj lm nk lq nl lu nm ly ne nf ng nh bi translated">如果在视图上禁用缓存，则返回类型将为null，实时用例可以在webview上禁用缓存。</li></ol><h1 id="e913" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">新的PixelCopy API</h1><p id="4c32" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">我看到大多数人建议使用的一个解决方案是PixelCopy API。它很容易使用，而且大多数时候都有效。看一下代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">通过PixelCopy API的视图截图</p></figure><p id="6032" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，我们用视图的尺寸创建一个空位图，然后在屏幕上定位视图，并开始将像素复制到位图中。这里我们想传递一个Kotlin函数，它将bitmap作为输入参数。这个函数用于将位图保存到一个文件中。看一看:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="60c3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">PixelCopy API做得相当不错，但我看到在很多情况下它并不起作用。因此，我还需要另一个标准解决方案，这就引出了下面这个问题。</p><h1 id="efcd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">强大的旧帆布抢救</h1><p id="97fd" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">当我遇到一个基于canvas的解决方案时，我很满意。Canvas类保存“绘制”调用。要绘制一些东西，您需要四个基本组件:一个保存像素的位图、一个托管绘制调用(写入位图)的画布、一个绘图原语(例如，Rect、Path、text、bitmap)和一个paint(描述绘图的颜色和样式)。</p><p id="7ce0" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，我们需要根据视图的尺寸创建一个位图。这里的逻辑相当简单，我们使用视图上的canvas和draw函数来创建位图。看一下代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">拍摄view va画布的屏幕截图</p></figure><p id="d48f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">就我而言，这就像一个没有任何操作系统或基于视图的限制的魔咒。如果您发现任何问题，请在评论中添加它们，以便我们可以一起改进解决方案。</p><h1 id="ef33" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">奖金</h1><p id="791d" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">我最近看到了Satya Pavan Kantamani 发表的这篇关于Jetpack视图绑定的优秀文章。强烈建议:</p><div class="nn no gp gr np nq"><a rel="noopener  ugc nofollow" target="_blank" href="/android-jetpack-view-binding-c0947f7a6e9e"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">在Android中用Jetpack视图绑定替换已弃用的Kotlin合成</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">如果科特林合成材料正在消失，是时候转向替代品了吗？</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">better编程. pub</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kw nq"/></div></div></a></div></div></div>    
</body>
</html>