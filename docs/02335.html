<html>
<head>
<title>4 Dangerous Problems in JavaScript Easily Solved by the Builder Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建器设计模式轻松解决JavaScript中的4个危险问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-dangerous-problems-in-javascript-easily-solved-by-the-builder-design-pattern-7f0eb5b4455c?source=collection_archive---------1-----------------------#2019-11-24">https://betterprogramming.pub/4-dangerous-problems-in-javascript-easily-solved-by-the-builder-design-pattern-7f0eb5b4455c?source=collection_archive---------1-----------------------#2019-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b385" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用构建器模式建立您对代码的信心</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fbac2f127b88896cc3c8a43d9177bfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxvYXPsAMb88ADt3zP_PZw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">瑞安·昆塔尔在Unsplash上拍摄的照片</em></p></figure><p id="03b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你用JavaScript开发应用程序时，你有时会发现很难构造复杂的对象。一旦它在你的代码中达到这一点，它就变得更加重要，因为随着你的应用程序变大，它会变得更加复杂。</p><p id="4869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种复杂性有几种形式。一种可能是，当你试图创建某些对象的不同变体时，你的代码变得重复。</p><p id="3466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个可能是，试图创建这些对象的变体可能会变得很长，因为你必须在某个巨大的块中执行逻辑，就像在<a class="ae lv" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank">类</a>的<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" rel="noopener ugc nofollow" target="_blank">构造器</a>块中一样。</p><p id="c2e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将讨论这些问题，并向您展示JavaScript中的构建器设计模式将如何使这些问题变得不那么严重。</p><p id="4571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，builder模式能<em class="lw">轻松</em>解决哪些问题呢？</p><p id="2f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先看一个没有构建器模式的示例<em class="lw">，然后看一个有</em>构建器模式的示例<em class="lw">，这样在我们进行的过程中，我不是唯一一个想到可视化代码示例的人。</em></p><p id="064d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码示例中，我们定义了一个<code class="fe lx ly lz ma b">Frog</code>类。我们将假设，为了让<code class="fe lx ly lz ma b">Frog</code>职业完全有能力在野外生存和冒险而不出问题，他们将需要<em class="lw">两只眼睛，所有的四条腿，一种气味，一条舌头和一颗心</em>。</p><p id="0141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，很明显，在现实世界中，有更多的东西牵涉其中，需要一种<em class="lw">气味</em>才能生存听起来很荒谬，但我们只会让它简单有趣，而不是对所有事情都完全真实。</p><p id="764d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在另一个时间的另一篇文章中得到100%正确的事实。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1711" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">如果没有生成器模式</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b3f4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用构建器模式</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这似乎有点矫枉过正，因为构建器模式示例的代码更长。</p><p id="9df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您更深入地研究在潜在的frog应用程序的开发过程中可能出现的所有情况，您将会看到，通过查看这两个示例，应用了builder模式的代码示例将会慢慢地提高简单性、可维护性，并为实现健壮的功能提供更多的机会。</p><p id="35f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是生成器设计模式在JavaScript中可以轻松解决的四个问题。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="f237" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.代码混乱和困惑</h1><p id="7cfa" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在开发大尺寸的功能块时，由于不小心而导致的错误和事故并不少见。另外，当单个块中有<em class="lw">太多事情在</em>进行的时候，就<em class="lw">容易搞混</em>。</p><p id="1827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，当函数块中有太多的事情发生时，你会陷入什么样的情况，比如<em class="lw">构造函数</em>？</p><p id="cbee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的第一个代码示例，在没有生成器模式的情况下实现了<em class="lw">，让我们假设我们必须添加一些额外的逻辑来接受传入的参数，然后再将它们应用到实例:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="88f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的构造函数有点长，在某些情况下，它甚至看起来不需要很多逻辑。处理不同参数的逻辑使它变得混乱。这可能会令人困惑，尤其是如果我们已经很久没有查看它的源代码了。</p><p id="82a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们开发一个frog应用程序并希望实例化一个<code class="fe lx ly lz ma b">Frog</code>的实例时，缺点是我们必须确保每个参数都接近100%完美，以符合函数签名或在构造阶段会抛出的东西。</p><p id="31bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要在某个时候再次检查<code class="fe lx ly lz ma b">eyes</code>的类型，我们将不得不扫描杂乱的代码以找到我们要找的代码。</p><p id="148b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您最终找到了您正在寻找的代码行，但随后意识到还有另一行代码引用并影响了仅50行以上的<em class="lw">相同的</em>参数，您会感到困惑吗？</p><p id="f8a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你必须回过头去浏览这些，以便能够理解将会发生什么。</p><p id="9387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们再看一下前面例子中的<code class="fe lx ly lz ma b">FrogBuilder</code>构造函数，我们可以简化构造函数，让它看起来更自然，同时消除混淆。</p><p id="1717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然会做额外的验证，它只是被隔离到它们自己的小方法中，这是构建器模式的核心和灵魂。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="8b61" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.可读性</h1><p id="6621" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如果我们看一下最近的代码示例，它已经变得有点难以阅读，因为我们必须同时处理这些不同的处理方式。</p><p id="30ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有别的办法，如果我们想创建一个<code class="fe lx ly lz ma b">Frog</code>的实例，只有立刻理解整个<em class="lw">的事情。</em></p><p id="3de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们必须提供一些文档，否则我们不知道为什么<code class="fe lx ly lz ma b">tongueWidth</code>要改名为<code class="fe lx ly lz ma b">width</code>。这太荒谬了！</p><p id="b7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将示例转换为使用构建器模式，我们可以使内容更易于阅读:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获得了以几种方式使我们的代码更具可读性的能力:</p><h2 id="ad67" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">1.这些方法的名字足够<em class="ky">不言自明</em></h2><p id="f2a5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><code class="fe lx ly lz ma b">updateTongueWidthFieldName</code>很容易向我们解释它做了什么以及<em class="lw">为什么</em>它要这么做。</p><p id="d887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道它在更新字段名。我们也知道<em class="lw">为什么是</em>，因为单词<em class="lw"> update </em>已经意味着更新！这个自文档化的代码帮助我们假设一个字段名称是旧的，需要修改以使用新的字段名称。</p><h2 id="9606" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">2.构造函数简短而简化</h2><p id="35c8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">稍后设置其他属性完全没问题！</p><h2 id="f872" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">3.启动新的f <code class="fe lx ly lz ma b">rog</code>时清楚了解每个参数</h2><p id="81a6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">就像读英语一样。很明显你在设置眼睛，腿等。，最后调用build方法创建一个<code class="fe lx ly lz ma b">Frog</code>。</p><h2 id="c255" class="nh mj it bd mk ni nj dn mo nk nl dp ms li nm nn mu lm no np mw lq nq nr my ns bi translated">4.每个逻辑现在都被隔离在单独的块中，我们可以很容易地理解</h2><p id="ba0d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当你做一些改变时，你只需要关注一件事，那就是在功能块中被隔离的东西。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3003" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.缺乏控制</h1><p id="9a10" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这个列表中最重要的一个是受益于对实现的更多控制。</p><p id="e3b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建器示例之前，可以在构造器中编写更多的代码，但是您尝试放入的代码越多，可读性就越差，从而导致混乱。</p><p id="7fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们能够将实现细节隔离到它们各自的功能块，我们现在可以在许多方面进行更好的控制。</p><p id="7334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是我们可以在不增加更多问题的情况下添加验证，这使得构建阶段更加健壮:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1e26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们利用了这样一个事实，即通过添加验证和一个<code class="fe lx ly lz ma b">validate</code>方法来隔离构造函数的每个部分，以确保在最终构建<code class="fe lx ly lz ma b">Frog</code>之前已经设置了所有必需的字段。</p><p id="ce16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以利用这些开放的机会来添加更多的自定义输入数据类型，以构建参数的原始返回值。</p><p id="14f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以添加更多调用方可以传入<code class="fe lx ly lz ma b">eyes</code>的自定义方式，为他们提供比我们之前提供的更加方便的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d5c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，呼叫者可以更容易地选择他们想要的任何输入类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e794" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.样板文件(通过模板解决)</h1><p id="c095" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们将来可能会遇到的一个问题是，我们最终会得到一些重复的代码。</p><p id="8f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，回头看看我们的<code class="fe lx ly lz ma b">Frog</code>类，你认为当我们想要创造某种类型的青蛙时，它们中的一些会有完全相同的特征吗？</p><p id="3895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界中，青蛙有不同的变种。例如，蟾蜍是青蛙的一种，但并不是所有的青蛙都是蟾蜍。所以，这告诉我们，蟾蜍有一些与众不同的特性，不应该属于正常的青蛙。</p><p id="1b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蟾蜍和青蛙的一个区别是，蟾蜍大部分时间呆在陆地上，而正常的青蛙大部分时间呆在水里。此外，蟾蜍也有干燥凹凸不平的皮肤，而正常青蛙的皮肤有点黏糊糊的。</p><p id="ad93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们必须确保每次青蛙被实例化时，<em class="lw">只有一些值</em>可以通过，而一些值<em class="lw">必须</em>通过。</p><p id="419f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到我们的<code class="fe lx ly lz ma b">Frog</code>构造函数，添加两个新参数:<code class="fe lx ly lz ma b">habitat</code>和<code class="fe lx ly lz ma b">skin</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对这个构造函数做两个简单的修改已经有点令人困惑了！这就是为什么建议使用构建器模式的原因。</p><p id="1989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把<code class="fe lx ly lz ma b">habitat</code>和<code class="fe lx ly lz ma b">skin</code>参数放在最后，可能会导致错误，因为<code class="fe lx ly lz ma b">weight</code>和<code class="fe lx ly lz ma b">height</code>可能是未定义的，因为它们都是可选的！</p><p id="e382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，由于它们是可选的，如果调用者没有传入它们，那么<code class="fe lx ly lz ma b">habitat</code>和<code class="fe lx ly lz ma b">skin</code>将被错误地用于它们。呀！</p><p id="286c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编辑<code class="fe lx ly lz ma b">FrogBuilder</code>以支持<code class="fe lx ly lz ma b">habitat</code>和<code class="fe lx ly lz ma b">skin</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们假设我们需要创建两个不同的蟾蜍和一只正常的青蛙:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这里面的重复代码在哪里呢？</p><p id="0054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们仔细观察，会注意到我们必须重复toad的<code class="fe lx ly lz ma b">habitat</code>和<code class="fe lx ly lz ma b">skin</code>设置器。如果再有五只蟾蜍专用的塞特犬会怎样？每次创建蟾蜍时，我们都必须手动应用这个模板——对于普通的青蛙也是如此。</p><p id="351d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能做的是创建一个<em class="lw">模板</em>，按照惯例，它通常被称为<em class="lw">导演</em>。</p><p id="cd80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导演负责执行创建对象的步骤——通常在构建最终对象时会有一些可以预先定义的公共结构，就像在这种情况下，我们的<em class="lw"> toad </em>。</p><p id="ad7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以让导演为我们生成模板，而不必手动设置蟾蜍之间的独特属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2a4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您可以避免实现所有蟾蜍共有的样板文件，并且可以只关注您需要的属性。当有更多专属于蟾蜍的属性时，这变得更加有用。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0b95" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="7404" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这就是这首曲子的结尾！我希望你发现这是有价值的，并期待在未来更多。</p></div></div>    
</body>
</html>