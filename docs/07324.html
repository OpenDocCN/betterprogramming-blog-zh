<html>
<head>
<title>Animation in SwiftUI: Get to Know Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的动画:了解交易</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/animation-in-swiftui-get-to-know-transactions-7cd57cfb299f?source=collection_archive---------10-----------------------#2021-01-04">https://betterprogramming.pub/animation-in-swiftui-get-to-know-transactions-7cd57cfb299f?source=collection_archive---------10-----------------------#2021-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="908e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">制作复杂的动画非常容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72473eb39d78b2c6a2266fa379dc818f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8eQ0KMBcBKeWLFh5TrBX8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="4396" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用程序设计中最重要的一个方面是动画。您可能需要使用复杂的动画来增加应用程序的用户体验。令人欣慰的是，在SwiftUI中创建高度复杂的动画相当容易:改变您的状态，SwiftUI会自动在您的视图中制作动画。</p><p id="46ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将向您展示如何以最好的方式在SwiftUI中创建动画。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="90b5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">基础</h1><p id="d6e8" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在动画显示SwiftUI元素之前，必须更改该元素的属性。例如，如果我们想用动画改变UI元素的位置，我们首先需要一个存储该元素位置信息的属性。该属性也必须是一个<code class="fe my mz na nb b">@State</code>属性。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="20fe" class="ng mc it nb b gy nh ni l nj nk">// MARK: - Properties<br/><strong class="nb iu">@State private var</strong> isTapped = <strong class="nb iu">false</strong></span></pre><p id="a780" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要使用<code class="fe my mz na nb b">onTapGesture</code>修改器通过触摸来移动我们的元素，并且<code class="fe my mz na nb b">isTapped</code>值应该在这个修改器中改变。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="dc50" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">struct</strong> ContentView: View {<br/>    <br/>    // MARK: - Properties<br/>    <strong class="nb iu">@State private var</strong> isTapped = <strong class="nb iu">false</strong><br/>    <br/>    // MARK: - UI Elements<br/>    <strong class="nb iu">var</strong> body: <strong class="nb iu">some</strong> View {<br/>        Circle()<br/>            .fill(Color.red)<br/>            .offset(y: isTapped ? 200 : -200)<br/>            .animation(.spring())<br/>            .onTapGesture {<br/>                isTapped.toggle()<br/>            }<br/>    }<br/>}</span></pre><p id="89e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，我们使用<code class="fe my mz na nb b">offset</code>修改器来改变<code class="fe my mz na nb b">Circle</code>元素的位置。当<code class="fe my mz na nb b">isTapped</code>属性为<code class="fe my mz na nb b">true</code>时取<code class="fe my mz na nb b">200</code>，当<code class="fe my mz na nb b">false</code>时取<code class="fe my mz na nb b">-200</code>。</p><p id="d95a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在子视图上使用动画修改器有一个缺点:我们不能完全控制动画。例如，我们不能用“线性”动画替换“弹簧”动画。我们可以使用事务来覆盖<code class="fe my mz na nb b">onTapGesture</code>中子视图中定义的动画。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="2d89" class="ng mc it nb b gy nh ni l nj nk">// MARK: - UI Elements<br/><strong class="nb iu">var</strong> body: <strong class="nb iu">some</strong> View {<br/>    Circle()<br/>        .fill(Color.red)<br/>        .offset(y: isTapped ? 200 : -200)<br/>        .animation(.spring())<br/>        .onTapGesture {<br/>            <strong class="nb iu">var</strong> transaction = Transaction(animation: .linear)<br/>            transaction.disablesAnimations = <strong class="nb iu">true</strong></span><span id="3da4" class="ng mc it nb b gy nl ni l nj nk">            withTransaction(transaction) {<br/>                isTapped.toggle()<br/>            }<br/>        }<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/20d04dd7b44f9a53e483832c09c8f7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wij883JPSw_i_vH_2TK9gQ.gif"/></div></div></figure><p id="5a0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢<code class="fe my mz na nb b">withTransaction</code>修饰符，我们可以运行我们想要的事务，同时改变我们想要的属性。新事务禁用视图层次结构中定义的所有动画，并启用线性动画。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b1fc" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">交易修改量</h1><p id="5416" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">多亏了<code class="fe my mz na nb b">transaction</code>修饰符，可以用比上面例子更简单的方式使用定制事务。此外，您的代码层次结构会变得更好。让我们看看如何通过改变上面的例子来使用修饰语。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="58a6" class="ng mc it nb b gy nh ni l nj nk">// MARK: - UI Elements<br/><strong class="nb iu">var</strong> body: <strong class="nb iu">some</strong> View {<br/>    Circle()<br/>        .fill(Color.red)<br/>        .offset(y: isTapped ? 200 : -200)<br/>        .animation(.spring())<br/>        .transaction { transaction <strong class="nb iu">in</strong><br/>            transaction.disablesAnimations = <strong class="nb iu">true</strong><br/>            transaction.animation = .linear<br/>        }<br/>        .onTapGesture {<br/>            isTapped.toggle()<br/>        }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/111885d4f35c9ae8c00dc5a29d522128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y7kNlgntBZbPRybqyD1hyg.gif"/></div></div></figure><p id="b993" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您会注意到，我们首先关闭所有交易:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="571b" class="ng mc it nb b gy nh ni l nj nk">transaction.disablesAnimations = <strong class="nb iu">true</strong></span></pre><p id="547e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们通过将事务元素的动画属性定义为线性来定义什么是事务:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="fb66" class="ng mc it nb b gy nh ni l nj nk">transaction.animation = .linear</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="560f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">手势更新</h1><p id="4395" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">SwiftUI为我们提供了一个特定的属性包装器来跟踪手势的状态:<code class="fe my mz na nb b">@GestureState</code>。</p><p id="2dab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然您可以使用<code class="fe my mz na nb b">@State</code>属性包装器，但是<code class="fe my mz na nb b">@GestureState</code> <em class="nn"> </em>增加了在手势结束时自动将属性设置回初始值的能力。</p><p id="1d94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可能想要创建一个可以拖动视图的手势。为此，我们首先需要像这样创建一个<code class="fe my mz na nb b">@GestureState</code> <em class="nn"> </em>属性。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="f7ae" class="ng mc it nb b gy nh ni l nj nk">// MARK: - Properties<br/><strong class="nb iu">@GestureState private var</strong> offsetValue: CGSize = .zero</span></pre><p id="2811" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">UI元素将在其运动结束后返回该值。</p><p id="5a01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们会附加一个<code class="fe my mz na nb b">offset</code>修饰符，这样我们的视图就会随着<code class="fe my mz na nb b">offsetValue</code>中的任何值而移动:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="fc3a" class="ng mc it nb b gy nh ni l nj nk">// MARK: - UI Elements<br/><strong class="nb iu">var</strong> body: <strong class="nb iu">some</strong> View {    <br/>    Circle()<br/>        .frame(width: 100, height: 100)<br/>        .offset(offsetValue)}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3d14a722f819755e6c3e6f999e4f42a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVl7sDNQnCqTQ9fiYQJhag.png"/></div></div></figure><p id="5dea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们使用<code class="fe my mz na nb b">gesture</code>修改器使我们的<code class="fe my mz na nb b">Circle</code>元素可以根据<code class="fe my mz na nb b">offsetValue</code>拖动。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="cb9e" class="ng mc it nb b gy nh ni l nj nk">// MARK: - UI Elements<br/><strong class="nb iu">var</strong> body: <strong class="nb iu">some</strong> View {<br/>    Circle()<br/>        .frame(width: 100, height: 100)<br/>        .offset(offsetValue)<br/>        .gesture(<br/>            DragGesture()<br/>                .updating($offsetValue) { value, state, transaction <strong class="nb iu">in</strong><br/>                    state = value.translation<br/>                    transaction.animation = .interactiveSpring()<br/>                }<br/>        )<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/5ae346cd0faccdfce4dd8925e1b533b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UBvpqan0rfh42-TxVibhaw.gif"/></div></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0bf0" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">粘合剂</h1><p id="f17c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们还可以在绑定更新期间使用绑定上的<code class="fe my mz na nb b">transaction</code> <em class="nn"> </em>函数提供一个自定义事务。让我们看一个例子来说明这一点。</p><p id="b9f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，考虑一个按下时会改变大小的按钮。为此，让我们创建一个名为<code class="fe my mz na nb b">CircleView</code>的UI组件。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="0b68" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">struct</strong> CircleView: View {<br/>    <br/>    // MARK: - Properties<br/>    <strong class="nb iu">@Binding var</strong> animatedBinding: <strong class="nb iu">Bool</strong></span><span id="416f" class="ng mc it nb b gy nl ni l nj nk">    // MARK: - UI Elements<br/>    <strong class="nb iu">var</strong> body: <strong class="nb iu">some</strong> View {<br/>        Circle()<br/>            .fill(Color.blue)<br/>            .scaleEffect(animatedBinding ? 0.5 : 1)<br/>            .animation(.spring())<br/>    }<br/>}</span></pre><p id="aca4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以像这样在我们的主<code class="fe my mz na nb b">View</code>元素中使用<code class="fe my mz na nb b">CircleView</code>元素。<code class="fe my mz na nb b">animatedBinding</code>是输出类型为<code class="fe my mz na nb b">Binding&lt;Bool&gt;</code>的计算属性。这个计算的属性就像一个函数一样工作:如果<code class="fe my mz na nb b">scale</code>对象的值改变，它可以改变它的输出。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="a0b3" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">struct</strong> CircleView: View {<br/>    <br/>    // MARK: - Properties<br/><strong class="nb iu">    @State private var</strong> scale = <strong class="nb iu">false</strong></span><span id="7718" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">    private</strong> <strong class="nb iu">var</strong> animatedBinding: Binding&lt;<strong class="nb iu">Bool</strong>&gt; {<br/>        <strong class="nb iu">var</strong> transaction = Transaction(animation: .interactiveSpring())<br/>        transaction.disablesAnimations = <strong class="nb iu">true</strong><br/>        <strong class="nb iu">return</strong> $scale.transaction(transaction)<br/>    }</span><span id="c508" class="ng mc it nb b gy nl ni l nj nk">    // MARK: - UI Elements<br/>    <strong class="nb iu">var</strong> body: <strong class="nb iu">some</strong> View {<br/>        CircleView(animatedBinding: animatedBinding)<br/>            .onTapGesture {<br/>                scale.toggle()<br/>            }<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/981f89da664eb9b48b507be5d519da3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*723XOH3L507ScKhpttPSsg.gif"/></div></div></figure><p id="093b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在已经看到我们可以使用<code class="fe my mz na nb b">@Binding</code>对象运行事务！您可以在Xcode中自己运行这些代码并查看结果。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d572" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="8215" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">有了SwiftUI，你几乎可以把你想象的任何动画都变成现实！如果你有任何问题，请在评论区告诉我。</p><p id="e93a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在下面访问我们在本文中创建的项目:</p><div class="np nq gp gr nr ns"><a href="https://github.com/canbalkya/Transactions-in-SwiftUI" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">canbalkya/swift ui中的交易</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">这个项目是为我的文章创建的。你可以在这里看我的文章…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="4f66" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">My Other Articles<br/></strong>-<strong class="nb iu"> </strong><a class="ae oh" rel="noopener ugc nofollow" target="_blank" href="/build-a-textfield-for-numbers-in-swiftui-21030b58a41">Build a TextField for Numbers in SwiftUI</a><br/>- <a class="ae oh" rel="noopener ugc nofollow" target="_blank" href="/programmers-should-learn-how-to-learn-51800061ae12">Programmers Should Learn How to Learn</a><br/>- <a class="ae oh" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-onboarding-screens-in-your-ios-app-e41b518db31f">How to Create Onboarding Screens in Your iOS App</a></span></pre><p id="e6d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想见我或有关于iOS开发等问题。你可以在这里和我进行一对一的会谈<a class="ae oh" href="https://superpeer.com/canbalkya" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>