<html>
<head>
<title>Build a Board Game Without the Politics (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个没有政治的棋盘游戏(第4部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-board-game-without-the-politics-part-4-92ea2ddd78b?source=collection_archive---------22-----------------------#2020-04-09">https://betterprogramming.pub/build-a-board-game-without-the-politics-part-4-92ea2ddd78b?source=collection_archive---------22-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="adb8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过拖放使用SwiftUI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/200ddec9653e6326d1f9db4539a0c2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2XT_xaNLtpmVfEmy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@mvdheuvel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马腾·范登赫维尔</a>拍摄的照片。</p></figure><p id="010c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文基于iOS 11.4和2020年3月下旬发布的Swift 5的一个版本。警告:如果你还没有更新你的iDevice和/或Xcode，它显然不会工作。</p><p id="b3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简短的系列文章通过几个例子介绍了新的拖放协议的构建。最终目标是创建一个迷你数独板，然后您可以填充它。我们的目标只是创建一个你可以拖动棋子的板子。当然，它可以是你想尝试和构建的任何棋盘游戏的任何棋盘。</p><p id="ac16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一部分中，我希望展示我们如何通过使用struct而不是raw类型来改进我们的代码。</p><p id="27e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，有两件事一直困扰着我。第一个是当你玩游戏时，你经常发现自己在最后一轮被束缚住了。你早几步就做出了错误的决定，这已经让你自食其果了。</p><p id="3275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，当我实现了对缺失腿筋问题的解决方案时，我开始意识到我忽略MVC规则有点太多了，现在它也赶上了我。</p><p id="5c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现一个步进器功能，让你逆转你所做的决定。如果你愿意的话，一个撤销(长期记忆)功能。然后，让我们后退一步，重新编写应用程序，以改进我们应该已经到位的模型，看看我们还可以改进多少代码。</p><p id="a8f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于步进器，首先将以下代码添加到主界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们引入了两个新的变量:</p><ul class=""><li id="d283" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">一个<code class="fe mg mh mi mj b">sliderDB</code>数组，包含你移动时的数据。</li><li id="17cd" class="lx ly it lb b lc mk lf ml li mm lm mn lq mo lu mc md me mf bi translated">一个跟踪他们的<code class="fe mg mh mi mj b">sliderValue</code>。</li></ul><p id="993c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还编写了一个快速助手函数来帮助管理这些值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，您需要将变量添加到主循环中，并在正确的位置调用对新结构的引用。</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="0059" class="mt mu it mj b gy mv mw l mx my">@State private var sliderDB = [(Int?,String?,Color?)](repeating: (nil,nil,nil), count: 100)<br/>@State private var sliderValue: Int = 0</span></pre><p id="d9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新<code class="fe mg mh mi mj b">DropDelegate</code>链接，我们将在其中引用这个方法和我们的怪物矩阵。这是代码。将此块添加到测试下的矩阵中，看看<code class="fe mg mh mi mj b">self.poke !</code> = ":</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="418d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而这挡到了<code class="fe mg mh mi mj b">DropDelegate</code>法。不要忘记在方法的开头绑定两个新变量:</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="086d" class="mt mu it mj b gy mv mw l mx my">self.sliderDB[Int(self.sliderValue)] =  (self.textID,text,backgrounds[(Int(text)! - 1)])<br/>self.sliderValue = self.sliderValue + 1</span></pre><p id="66df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，你应该准备好了。编译并运行。现在你可以添加方块到你的游戏中，玩到一半时，使用步行者返回和前进的路径。</p><p id="6c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抱歉，我差点忘了:你应该在用户关闭磁贴时删除历史记录。这个代码也属于怪物矩阵。我包括了其他陈述，以便您可以确保在正确的位置得到它:</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="7518" class="mt mu it mj b gy mv mw l mx my">self.sliderDB[Int(self.sliderValue)] = (nil,nil,nil)<br/>self.textText[fCalc(c: column, r: row, x: self.textValue.count)] = ""<br/>self.textColors[fCalc(c: column, r: row, x: self.textValue.count)] = Color.clear</span></pre><p id="0e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回顾我的代码，我认为公平地说，我对MVC的解释是创建一个“大规模视图控制器”——而不是一个模型、视图和控制器，就像它本来应该的那样。</p><p id="e19d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我试图将一些方法分解成更简单的方法时，这变得更加明显。让我们回顾一下刚刚输入的代码。我们怎样才能做得更好？我首先把我添加到矩阵中的新代码剪下来，放入它自己的函数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对函数的调用如下所示。没那么简单吧。</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="c19c" class="mt mu it mj b gy mv mw l mx my">cellHistory(column: column, row: row, tVcount: self.textValue.count, poke: self.poke, sliderValue: &amp;self.sliderValue, sliderDB: &amp;self.sliderDB, textText: &amp;self.textText, textColors: &amp;self.textColors)</span></pre><p id="7692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的一个问题是，虽然我的历史记录的数据结构(一个元组)比我用于瓷砖上的文本和颜色(它们是分开的)的简单的双数组更有效，但它看起来和感觉起来仍然像一顿狗的晚餐。</p><p id="fe25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过定义一个适当的结构(不是元组)并通过代码中的一行引用它来使它更清楚:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="e2c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们在<code class="fe mg mh mi mj b">ContentView</code>中将它定义为<code class="fe mg mh mi mj b">ObservedObject</code>:</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="91f6" class="mt mu it mj b gy mv mw l mx my">@ObservedObject var stepperInst:StepperData</span></pre><p id="f653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并重新定义它与<code class="fe mg mh mi mj b">DropDelegate</code>、<code class="fe mg mh mi mj b">cellHistory</code>和<code class="fe mg mh mi mj b">cellsUsed</code>方法的关系:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="13c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi mj b">DropDelegate</code>的召唤:</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="9dd6" class="mt mu it mj b gy mv mw l mx my">let dropDelegate = TheDropDelegate(textID: $textID, textText: $textText, rect: $rect, textColors: $textColors, startStop: $startStop, stepperInst: stepperInst)</span></pre><p id="22d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi mj b">DropDelegate</code>本身:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="20f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe mg mh mi mj b">performDrop</code>中的这一小段代码:</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="38d9" class="mt mu it mj b gy mv mw l mx my">let newRec = stepperSteps(stepIndex: self.textID, stepText: text, stepColor: backgrounds[Int(text)! - 1])<br/>self.stepperInst.stepperDB[self.stepperInst.stepperValue] = newRec<br/>self.stepperInst.stepperValue = self.stepperInst.stepperValue + 1</span></pre><p id="caa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进行更改并进行测试。你发现窃听器了吗？如果您先放置一个图块，然后在上面放置另一个图块，它会记录这两个动作。我们需要解决这个问题。这里有一个新的<code class="fe mg mh mi mj b">cellHistory</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a99c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，就是这样。我希望你同意这是一个更干净的解决方案。让我们以同样的方式为瓷砖实现一个。我们从<code class="fe mg mh mi mj b">rect</code>数组开始。这是一个新的<code class="fe mg mh mi mj b">InsideView</code>，它将数据归档到我们的<code class="fe mg mh mi mj b">stepperInst</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="203e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个新的<code class="fe mg mh mi mj b">DropTarget</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="156e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，您需要对代码进行修改，这些代码引用了具有相同名称的其他版本，但是新版本以“v”结尾。</p><p id="3d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你可以再次简化对<code class="fe mg mh mi mj b">DropTarget</code>的调用:</p><pre class="kj kk kl km gt mp mj mq mr aw ms bi"><span id="d49e" class="mt mu it mj b gy mv mw l mx my">let dropDelegate = TheDropDelegate(textID: $textID, textText: $textText, textColors: $textColors, startStop: $startStop, stepperInst: stepperInst)</span></pre><p id="b16d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我继续走这条路，重写/重新定义了大多数方法，以使用新发布的struct。我不打算回顾我所做的所有修改，因为我不认为这会使阅读变得有趣。如果你准备好迎接挑战，我建议不要把显示的文字/颜色和选择的文字/颜色混淆。我的最终结构如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="326d" class="ng mu it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">结论</h1><p id="0286" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">我本可以做得不同，只保存一个文本/颜色和一个标志来决定它是否应该显示，但我没有。说到这里，我想是时候开始新的项目了。</p></div></div>    
</body>
</html>