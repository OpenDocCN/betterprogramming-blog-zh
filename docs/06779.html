<html>
<head>
<title>Delving Into Docker Container Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究Docker容器动作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/delving-into-docker-container-actions-588332af5869?source=collection_archive---------17-----------------------#2020-11-03">https://betterprogramming.pub/delving-into-docker-container-actions-588332af5869?source=collection_archive---------17-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f74" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概述了在GitHub中何时使用Docker容器动作而不是JavaScript动作，并深入探讨了如何构建Docker容器动作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a6678ce9857c3609d5b11916335d7c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5s6jU-76APeNdG0LkhLwbQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">资料来源:github.com和docker.com</p></figure><p id="5126" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的<a class="ae lq" href="https://medium.com/better-programming/a-deep-dive-into-github-actions-51e234da0c50" rel="noopener">上一篇文章</a>中，我详细描述了GitHub动作背后的动机、它们的架构、事件如何流经GitHub，以及如何使用JavaScript从头开始创建一个定制的GitHub动作。</p><p id="cc49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我讨论了两种类型的动作:JavaScript动作和Docker容器动作。我所探索的许多开源动作都是使用Javascript动作构建的——可能是出于以下原因:</p><ol class=""><li id="d7ff" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">他们可以利用一个方便的GitHub <a class="ae lq" href="https://github.com/actions/toolkit" rel="noopener ugc nofollow" target="_blank">工具包</a>，它提供了对动作输入的库访问，以及一个可以用令牌配置的GitHub客户端。</li><li id="b455" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">所有GitHub运行者都支持Node 12开箱即用，这使得基于这个版本的Node编写动作变得非常简单。不需要额外的配置。要了解GitHub Runner环境支持哪些软件，请看一下文档。</li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="5f79" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">什么时候使用Docker容器动作？</h1><p id="7faf" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">Docker容器动作在一些情况下很出色。</p><h2 id="8e4e" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">当使用JavaScript不是一个选项时</h2><ul class=""><li id="717a" class="lr ls it kw b kx ne la nf ld nv lh nw ll nx lp ny lx ly lz bi translated">也许你的团队熟悉其他语言或框架。</li><li id="f106" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp ny lx ly lz bi translated">也许你更喜欢保持所有工具的一致性。也许您在Go中编写了所有的工具，并且愿意继续这样做。</li><li id="4577" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp ny lx ly lz bi translated">也许您想利用Node中没有的实用程序或库。例如，您的团队已经编写了一个用于管理或解析数据的Python脚本，但您不想将其移植到JavaScript。</li></ul><h2 id="589a" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><strong class="ak">当u </strong> sing节点(12)的特定版本不可选项</h2><p id="9c99" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">也许您想让您的操作基于不同的节点版本。</p><p id="d452" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使您使用Node 12的受支持版本来构建您的操作，使用Docker容器操作仍然对您有好处，原因如下:</p><ol class=""><li id="9f43" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">你不再需要将<code class="fe nz oa ob oc b">node_modules</code>文件夹直接包含在你的动作报告中。您可以使用一个<code class="fe nz oa ob oc b">package.json</code>文件来枚举依赖项，并让Docker容器在操作运行时下拉依赖项。</li><li id="e015" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">将运行动作所需的环境与动作本身捆绑在一起，可以防止在GitHub runner环境的软件升级过程中可能出现的破坏性变化。</li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="34ac" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">创建Docker容器操作</h1><p id="8deb" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在寻找有趣的动作时，我在还没有完全充实的<a class="ae lq" href="http://github.com/storybookjs" rel="noopener ugc nofollow" target="_blank">故事书GitHub组织</a>中偶然发现了<a class="ae lq" href="https://github.com/storybookjs/action/" rel="noopener ugc nofollow" target="_blank">这个动作</a>！</p><p id="c1d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个旨在构建故事书站点并将其部署到GitHub页面或AWS S3存储桶的操作。在本文中，我将介绍如何为这个用例构建一个GitHub Docker容器动作。</p><p id="6aa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于Docker容器动作的hello world介绍，请查看GitHub文档。</p><h2 id="ab45" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">定义行动</h2><p id="2667" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我们首先在存储库根目录下的一个<code class="fe nz oa ob oc b">action.yml</code>文件中定义动作的接口——它的输入、输出和环境:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="4092" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><strong class="ak">动作的输入</strong></h2><p id="2d4e" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我们为GitHub动作指定以下输入:</p><ol class=""><li id="3ba8" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe nz oa ob oc b">access-token</code>:推送至存储库特定分支所需的GitHub个人访问令牌。</li><li id="8df5" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe nz oa ob oc b">branch</code>:story book站点部署到的目标分支。</li></ol><h2 id="61ad" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><strong class="ak">动作的Docker图像</strong></h2><p id="c026" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">Docker容器动作指定用于启动容器的图像，动作代码在该容器中运行。对于Docker动作，我们使用<code class="fe nz oa ob oc b">docker</code>指定要运行的动作。<code class="fe nz oa ob oc b">image</code>可以用两种方式之一来表示:</p><p id="55f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1.通过使用动作库中的<code class="fe nz oa ob oc b">Dockerfile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bcb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们在示例中使用的内容。</p><p id="dffc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.通过使用公共Docker注册表中的图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="9559" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated"><strong class="ak">将输入传递给Docker容器</strong></h2><p id="973d" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">理想情况下，我希望为Docker动作指定的输入在它启动时自动传递给Docker容器。然而，这样做还需要一个额外的步骤。<code class="fe nz oa ob oc b">args</code>指定当作业运行程序运行动作时，要传递给Docker容器的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1649" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当容器启动时，作业运行程序将参数传递给容器的<code class="fe nz oa ob oc b">ENTRYPOINT</code>。</p><h2 id="bcb5" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">创建Dockerfile文件</h2><p id="6610" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我们遵循编写docker文件的标准语法和原则，并在文档中列出了一些针对GitHub实现的注意事项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="95c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个动作的Dockerfile使用<code class="fe nz oa ob oc b">alpine</code> Linux作为映像的基础，添加Node和Git，并指示Docker在容器开始使用这个映像时运行<code class="fe nz oa ob oc b">entrypoint.sh</code>。</p><p id="f89b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GitHub runner将从我们的docker文件构建一个映像，使用这个映像启动一个容器，并在容器启动时运行<code class="fe nz oa ob oc b">entrypoint.sh</code>中的代码。</p><p id="766b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GitHub作业运行器使用以下命令启动容器，该命令将许多必需的参数传递给容器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/c81c9a3854ac81a67a90d97e4d915af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rVUwvT5DTtX-tl95.png"/></div></div></figure><p id="8588" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些重要的是:</p><ol class=""><li id="211c" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe nz oa ob oc b">--workdir /github/workspace</code>:它将容器的工作目录设置为runner工作区(在本例中，存储库应该已经被克隆)。这个目录也作为<code class="fe nz oa ob oc b">GITHUB_WORKSPACE</code>环境变量传递。</li><li id="545b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">在<code class="fe nz oa ob oc b">action.yml</code>中指定的<code class="fe nz oa ob oc b">args</code>作为最后一个参数传递:</li></ol><ul class=""><li id="5398" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp ny lx ly lz bi translated"><code class="fe nz oa ob oc b">Deborah-Digges:***</code>:混淆的GitHub令牌</li><li id="71b1" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp ny lx ly lz bi translated"><code class="fe nz oa ob oc b">gh-pages</code>:推送到仓库上的分支</li></ul><h2 id="57e7" class="nj mn it bd mo nk nl dn ms nm nn dp mw ld no np my lh nq nr na ll ns nt nc nu bi translated">在容器中运行代码！</h2><p id="3c2b" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">我们已经指定我们的<code class="fe nz oa ob oc b">ENTRYPOINT</code>是一个bash脚本，我们可以运行一个节点脚本，一个Python模块，或者几乎任何我们想要的东西！</p><p id="aa96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们将使用<a class="ae lq" href="https://github.com/storybookjs/storybook-deployer" rel="noopener ugc nofollow" target="_blank"> storybook-deployer </a>，而不是编写代码来构建故事书站点并将其推送到GitHub pages。对不起出轨了！它并不完整，因为，如你所见，它假设了项目的许多事情(例如，它使用npm而不是yarn)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c943" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">部署故事书站点的步骤如下:</p><ol class=""><li id="91db" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">安装<code class="fe nz oa ob oc b">storybook-deployer</code>依赖项。</li><li id="615e" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">使用正确的分支和令牌参数运行<code class="fe nz oa ob oc b">storybook-deployer</code>。</li></ol><p id="878f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在GitHub 上查看已完成动作<a class="ae lq" href="https://github.com/Deborah-Digges/publish-storybook-action" rel="noopener ugc nofollow" target="_blank">的代码。</a></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="dd2e" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">在GitHub工作流程中使用Docker容器动作</h1><p id="8b23" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">让我们看看如何在一个使用Storybook构建Storybook站点并在每次push to master时将story book站点部署到GitHub的<code class="fe nz oa ob oc b">gh-pages</code>分支中。</p><p id="9997" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要在位于<code class="fe nz oa ob oc b">.github/workflows</code>的存储库中创建一个工作流文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="832f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们指定希望这个工作流在每个<em class="ok">推</em>到<em class="ok">主</em>分支时运行。该工作流有一个名为<code class="fe nz oa ob oc b">build</code>的作业，有三个步骤:</p><ol class=""><li id="d22a" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">使用<code class="fe nz oa ob oc b">actions/checkout@v2</code>动作签出存储库。</li><li id="d39c" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">通过运行脚本安装依赖项。</li><li id="b28b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">使用我们刚刚创建的操作将Storybook站点部署到GitHub页面。</li></ol><p id="e8a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用语法<code class="fe nz oa ob oc b">deborah-digges/deploy-storybook-action@v13.0</code>引用一个动作，包括:</p><ol class=""><li id="c1fd" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">所有者或组织名称</li><li id="e6d7" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">存储库名称</li><li id="7a26" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">版本可以是存储库中的标记或提交ID</li></ol><p id="9c78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在<a class="ae lq" href="https://github.com/Deborah-Digges/test-storybook-action/actions/runs/334499434" rel="noopener ugc nofollow" target="_blank">动作</a>(没有双关语)中查看这个工作流，请查看<a class="ae lq" href="https://github.com/Deborah-Digges/test-storybook-action" rel="noopener ugc nofollow" target="_blank">这个</a>存储库，它使用我们刚刚构建的动作将一个故事书站点部署到<a class="ae lq" href="https://deborah-digges.github.io/test-storybook-action/" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="6cac" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">你需要GitHub动作吗？</h1><p id="e8c0" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">思考我们是否需要一个单独的GitHub动作来封装一个步骤中的逻辑，或者它是否可以在工作流本身中执行，这是一个很好的练习。</p><p id="0b94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地理解这一点，记住工作流中的一个步骤可以是:</p><ol class=""><li id="ff50" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">一种动作，它封装了使用所需输入调用的一些逻辑。</li><li id="3197" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">bash命令在工作流本身中运行。</li></ol><p id="5c90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们刚刚构建的动作中可重用逻辑的数量可以忽略不计，并且该动作只是已经存在的<code class="fe nz oa ob oc b">deploy-storybook</code>工具的一个薄薄的包装。我们也可以直接在工作流程中运行这个工具。</p><p id="221d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更改工作流文件以运行工作流文件中的操作代码可以完成相同的工作，而不必创建和维护一个全新的操作存储库！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="33b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开始编写独立的GitHub动作之前，我们真正应该回答的问题是“其他人会从这个抽象中受益吗？”</p><p id="633b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果答案是否定的，我们很可能不需要编写新的GitHub动作。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="a422" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">包扎</h1><p id="ef33" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在本文中，我们学习了何时使用Docker容器动作，如何编写一个动作，以及何时编写一个单独的动作，而不是在工作流本身中执行内联步骤。</p><p id="b691" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想快速复习什么是GitHub动作，为什么它们有用，或者如何编写JavaScript动作，请查看我的前一篇文章。</p></div></div>    
</body>
</html>