<html>
<head>
<title>Sign In With Apple: A Node.js Back-End Implementation for iOS Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">登录Apple:面向iOS开发人员的Node.js后端实现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sign-in-with-apple-node-js-backend-implementation-for-ios-developers-25a54b79aa68?source=collection_archive---------0-----------------------#2020-06-02">https://betterprogramming.pub/sign-in-with-apple-node-js-backend-implementation-for-ios-developers-25a54b79aa68?source=collection_archive---------0-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将Apple的新登录功能添加到您的应用程序和服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/540ce28fa9c7708e6d106bb5cf0faf73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AR0EUtx2FY3xaBNe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="f516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS 13(最近的主要版本)最有趣的一个方面是，它给了我们一个工具来为我们的iOS应用程序创建我们自己的基于授权的后端服务器。当然，我们有“登录脸书、谷歌等”以前，但是对于一个独立项目来说，“登录苹果”<em class="lv"> </em>更容易和更快地实现——无论是在客户端还是服务器端。</p><p id="e8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以下面的场景为例(当然是基于我的经验):你是一个iOS开发人员，有一个以你自己的名字发布的小应用。您想添加一个依赖于服务器的特性，但是您要么还没有后端，要么只有一个简单的后端，没有用户管理系统。您的功能需要用户管理。您希望保留与应用程序用户相关的特定项目。您不希望创建一个基于用户/密码的系统，不希望管理jwt，并且希望将iOS代码保持在最少。</p><p id="6b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是没人谈论的。“登录Apple”正是基于这一特定的使用案例而创建的。</p><p id="c199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们弄清楚一些方面:在本文中，我们不会讨论iOS实现。这在无数的文章和教程中都有涉及。我花了不到八个小时的时间在SwiftUI应用中编写客户端代码。<a class="ae ky" href="https://www.raywenderlich.com/4875322-sign-in-with-apple-using-swiftui" rel="noopener ugc nofollow" target="_blank">Raywenderlich.com</a>应该提供你需要的一切。它也不包括部署Node.js后端。你可以在谷歌上找到很多教程。使用Express部署一个节点服务器只需10分钟。这里有一个例子。</p><p id="483c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在您准备好iOS代码，并且iOS APIs为您提供了用户的电子邮件以及Apple的用户标识符和认证JWT之后继续。</p><p id="f926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先创建一条新路线，<code class="fe lw lx ly lz b">/authenticate</code>:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="3dd9" class="me mf it lz b gy mg mh l mi mj">app.post('/authenticate', async (req, res) =&gt; {<br/>   const { token, email, apple_id } = req.body;<br/>});</span></pre><p id="d27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，我们将探讨为什么我们称之为<code class="fe lw lx ly lz b">/authenticate</code>并且有一个单一的路线，而不是<code class="fe lw lx ly lz b">/register</code>和<code class="fe lw lx ly lz b">/login</code>。</p><p id="ff01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经从请求体中提取了<code class="fe lw lx ly lz b">token</code>、<code class="fe lw lx ly lz b">email</code>和<code class="fe lw lx ly lz b">apple_id</code> <strong class="lb iu"> <em class="lv"> </em> </strong>变量。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="436c" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">登录流程</h1><p id="7ba6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们要做的第一件事是查询我们的数据库，看我们是否有那个用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在在数据库上调用<code class="fe lw lx ly lz b">getUser</code>,回调要么传递给我们一个用户，要么传递给我们一个错误。错误完全出在DB通信中。我通过将它返回给客户机来处理它。客户端将显示一个弹出窗口给用户，他们可以截屏，并发送给我进行调试。这是我的选择。你想怎么处理都行。这并不意味着我们没有用户。意味着查询数据库失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到我只把<code class="fe lw lx ly lz b">apple_id</code> <em class="lv"> </em>传递给了<code class="fe lw lx ly lz b">fakeDB</code>而不是整个用户。这与“登录苹果<em class="lv">”的隐私功能之一有关</em>如果您已经编写了客户端实现，您应该已经看到并读到了这一点，即<a class="ae ky" href="https://forums.developer.apple.com/thread/121496#379297" rel="noopener ugc nofollow" target="_blank"> SiwA <em class="lv"> </em>仅在用户第一次使用您的应用时提供用户凭证</a>。</p><p id="5450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常重要，重要的原因是因为这一点，您需要编写一些特定的逻辑来使用户的凭证与服务器和客户端同步。这适用于电子邮件和姓名(如果您向Apple请求)。</p><p id="3828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有一个用户，我们跳到下一步。我们现在检查是否收到了包含我们请求的电子邮件:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="dced" class="me mf it lz b gy mg mh l mi mj">if (<strong class="lz iu">email </strong>...)</span></pre><p id="bd1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这又是SiwA的一个怪癖或边缘案例。请这样想:</p><ol class=""><li id="e068" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">用户第一次使用你的app。SiwA为您提供用户的电子邮件。你坚持下去。</li><li id="5aeb" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">用户卸载你的应用。</li><li id="ace1" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">用户再次安装您的应用程序，并再次登录Apple。SiwA不向您提供电子邮件。</li></ol><p id="50d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您通过用户的<code class="fe lw lx ly lz b">apple_id</code> <em class="lv"> </em>在数据库中找到了该用户，而这次您没有收到包含您的请求的电子邮件，那么您需要将当前电子邮件从您的数据库发送到客户端。</p><p id="f4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那个<code class="fe lw lx ly lz b">if</code>中的下一个验证检查当前请求的电子邮件是否与我们存储在数据库中的相同:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="b286" class="me mf it lz b gy mg mh l mi mj">if (...<strong class="lz iu"> email !== user.email</strong>)</span></pre><p id="1334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，边缘情况:</p><ol class=""><li id="6918" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">用户第一次使用你的app。SiwA为您提供用户的真实邮箱。你坚持下去。</li><li id="5480" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">用户进入iCloud并从登录中移除您的应用程序。</li><li id="6d2b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">用户打开您的应用程序，并决定再次登录。</li><li id="8f9e" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当SiwA提示用户时，他们选择隐藏他们的电子邮件。您现在收到的是gibberish@appleservices.com，而不是之前收到的first.lastname@gmail.com。</li></ol><p id="3d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，你需要尊重用户的选择。他们决定隐藏他们的电子邮件。您现在需要在客户端和服务器端更新它。</p><p id="6757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果验证失败:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="5c20" class="me mf it lz b gy mg mh l mi mj">if (email &amp;&amp; email !== user.email)</span></pre><p id="a261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在数据库中更新用户的电子邮件:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="5a6f" class="me mf it lz b gy mg mh l mi mj">fakeDB.updateUser(req.body);</span></pre><p id="0000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将用户作为响应发送回来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是登录流程。我们在数据库中有一个提供了苹果标识符的用户，如果需要，我们更新他们的个人信息，一旦完成，我们发送一个成功的响应。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="71ee" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">注册流程</h1><p id="251f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果我们在数据库中没有找到用户，这意味着这是用户第一次登录我们的应用程序，因此我们需要处理令牌验证并在数据库中创建用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="40eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我在一个不同的文件中创建了一个令牌服务。它的职责是验证在请求体中收到的JWT令牌。为此，我们将需要<code class="fe lw lx ly lz b">jose</code>和<code class="fe lw lx ly lz b">request</code> npm模块:</p><pre class="kj kk kl km gt ma lz mb mc aw md bi"><span id="31a1" class="me mf it lz b gy mg mh l mi mj">npm -i jose<br/>npm -i request</span></pre><p id="4c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算深入探究JWT验证是如何工作的，但是你可以在Sarun 上找到一个很好的解释<a class="ae ky" href="https://sarunw.com/posts/sign-in-with-apple-3/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的验证服务实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ad35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果验证失败，我们会将错误返回给用户(您希望如何处理这是您的选择)。</p><p id="319f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果验证通过，我们现在可以使用指定的<code class="fe lw lx ly lz b">apple_id</code> <strong class="lb iu"> <em class="lv"> </em> </strong>和电子邮件将用户添加到我们的数据库中。</p><p id="8f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在成功地将他们添加到数据库中后，我们将用户发送回带有所提供的<code class="fe lw lx ly lz b">apple_id</code> <em class="lv"> </em>和电子邮件的客户端。</p><p id="5399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！此时，您的用户身份验证已经实现。你的后端现在只需从你的iOS应用程序中给<code class="fe lw lx ly lz b">/authenticate</code>打一个电话就可以登录或注册用户。</p><p id="47a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一些问题，我准备了一些在开发过程中困扰我的问题的答案。</p><h2 id="c88e" class="me mf it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated"><strong class="ak">我的授权和刷新令牌在哪里？</strong></h2><p id="dfc8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">好吧，如果你打算只支持SiwA，他们是不需要的。苹果在iOS上提供了一个简单的API，可以直接在应用中检查会话。根据<a class="ae ky" href="https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_rest_api/verifying_a_user" rel="noopener ugc nofollow" target="_blank">官方文件</a>:</p><blockquote class="oo op oq"><p id="27bd" class="kz la lv lb b lc ld ju le lf lg jx lh or lj lk ll os ln lo lp ot lr ls lt lu im bi translated">“验证身份令牌后，您的应用负责管理用户会话。您可以将会话的生存期与Apple设备上成功的getCredentialState(for userid:completion:)调用联系起来。这是一个本地的、廉价的、非网络呼叫，由Apple ID系统启用，该系统将设备上的Apple ID状态与Apple服务器保持同步。</p><p id="2c2a" class="kz la lv lb b lc ld ju le lf lg jx lh or lj lk ll os ln lo lp ot lr ls lt lu im bi translated">每当请求新的身份令牌时，都需要用户交互。用户会话在设备上是长期存在的，因此在每次启动时调用新的身份令牌，或者一天调用一次以上，可能会导致您的请求由于限制而失败。</p><p id="57a8" class="kz la lv lb b lc ld ju le lf lg jx lh or lj lk ll os ln lo lp ot lr ls lt lu im bi translated">如果用户的Apple ID在系统中发生了变化，调用getCredentialState(for userid:completion:)表示用户发生了变化。假设不同的用户已经登录并注销应用程序当前已知的用户。</p><p id="10dd" class="kz la lv lb b lc ld ju le lf lg jx lh or lj lk ll os ln lo lp ot lr ls lt lu im bi translated">对于在其他系统上运行的应用程序，使用刷新令牌的定期成功验证来确定用户会话的生存期。"</p></blockquote><p id="bfc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当你的应用程序完成启动时，你可以(也应该)使用<code class="fe lw lx ly lz b">getCredentialState</code>来验证相同的用户登录到设备上，并且他们没有撤销你的应用程序的SiwA。如果他们撤销了，您应该在设备上执行注销流程(比如从设备上删除保存的用户凭证和<code class="fe lw lx ly lz b">apple_id</code>),并在需要时显示正确的SiwA屏幕。</p><h2 id="d3e0" class="me mf it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">为什么只调用一次/authenticate，而不是分别调用/login和/register？</h2><p id="88b5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">因为原则在这里不适用。和上面的答案一样，您可以使用本地的<code class="fe lw lx ly lz b">getCredentialState</code> API来验证当前用户，因此不需要对后端进行新的调用。这意味着您需要执行登录的唯一用例是用户在设备上手动注销之后。</p><p id="4503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您可以创建<code class="fe lw lx ly lz b">/login</code>和<code class="fe lw lx ly lz b">/register</code>，并在后端的两个端点中将逻辑从<code class="fe lw lx ly lz b">/authenticate</code>中分离出来，但是您会在客户端的两个方法中复制相同的代码——一个调用登录端点，另一个调用<code class="fe lw lx ly lz b">register</code>。你还需要在客户端检查用户是否第一次登录苹果。我们在服务器端做过检查，记得吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="e712" class="me mf it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">为什么我必须将用户从服务器传递回客户端？</h2><p id="4c93" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">你不知道。我在应用程序的屏幕上显示用户的电子邮件。这就是我坚持的原因。如果用户退出，重新登录，并从SiwA中选择另一个电子邮件地址，我希望在屏幕上显示正确的地址(就像他们上次使用SiwA时一样)。如果您不需要电子邮件或用户的电子邮件，就没有必要将它们保存在客户端或后端。</p><p id="94cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，<strong class="lb iu"> </strong>用从JWT令牌解码的邮件来验证来自请求主体的邮件是一个很好的实践，也更安全。因此，如果用户第一次登录，或者是在他们撤销你的应用程序后的后续登录，我的建议是将电子邮件发送到你的后端进行验证。</p><h2 id="7649" class="me mf it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">如何测试注册流程？</h2><p id="64bb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">你需要撤销对你的应用程序的访问权限。</p><p id="8c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的iOS设备上，前往iCloud &gt;密码与安全&gt; Apple ID登录&gt; *您的应用* &gt;停止使用Apple ID。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="307f" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="0e2d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正如你所看到的，苹果设置了一个系统，对于你想要一个没有密码或其他第三方认证提供者的简单登录系统的用例非常有益，我们应该使用它。在我看来，它打开了许多大门。</p><p id="7d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>