<html>
<head>
<title>K8s: A Closer Look at Kube-Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s:近距离观察Kube-Proxy</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/k8s-a-closer-look-at-kube-proxy-372c4e8b090?source=collection_archive---------0-----------------------#2021-01-13">https://betterprogramming.pub/k8s-a-closer-look-at-kube-proxy-372c4e8b090?source=collection_archive---------0-----------------------#2021-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fa1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个展示kube-proxy如何使用iptables的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e08ab1c642e3f03e97b0fd20195207b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1A1_V0QWR688-E9MJBY0-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iptables规则的示例。作者照片。</p></figure><p id="513d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kubernetes网络代理(又名kube-proxy)是运行在每个节点上的守护进程。它基本上反映了集群中定义的服务，并管理规则以对服务后端单元的请求进行负载平衡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/98527e35d9eecf18c6e7121b107790a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*domcyQgFDDpdZHVMOXWn-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务在后端pod之间对传入的请求进行负载平衡。作者照片。</p></figure><p id="dea5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个简单的例子:假设我们有几个API微服务在集群中运行，这些副本由一个服务公开。当一个请求到达服务虚拟IP时，该请求是如何被转发到一个底层pod的？嗯……简单地使用kube-proxy创建的规则。好吧，这并不那么简单，但我们在这里得到了大局。</p><p id="160a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">kube-proxy可以在三种不同的模式下运行:</p><ul class=""><li id="226b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">iptables(默认模式)</li><li id="d431" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">ipv</li><li id="170d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">用户空间(“遗留”模式，不再推荐)</li></ul><p id="ebad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然iptables模式对于许多集群和工作负载来说完全没问题，但是当服务数量很重要(超过1，000)时，ipv可能会很有用。事实上，由于iptables规则是按顺序读取的，如果集群中存在许多服务，它的使用会影响路由性能。</p><p id="5549" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="mj mk ep" href="https://medium.com/u/f88429157bbf?source=post_page-----372c4e8b090--------------------------------" rel="noopener" target="_blank">Tigera</a>(<a class="ae ml" href="https://projectcalico.org" rel="noopener ugc nofollow" target="_blank">Calico</a>网络解决方案的创造者和维护者)在<a class="ae ml" href="https://www.tigera.io/blog/comparing-kube-proxy-modes-iptables-or-ipvs/" rel="noopener ugc nofollow" target="_blank">这篇伟大的文章</a>中详细介绍了iptables和ipvs模式的区别。它还提供了这两种模式之间的高级比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/0e30e61fc64fa89672b4f89df48ee960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjAW5GqOmrE4k0V8pLZoMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iptables和ipvs模式之间的高级比较。信用:Tigera。</p></figure><p id="c473" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将关注iptables模式(下一篇文章将专门讨论ipvs模式),从而说明kube-proxy如何定义iptables规则。</p><p id="aaec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将使用我刚刚使用<code class="fe mn mo mp mq b">kubeadm</code>创建的双节点集群:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="92a8" class="mv mw it mq b gy mx my l mz na"><strong class="mq iu">$ kubectl get nodes<br/></strong>NAME    STATUS   ROLES                  AGE   VERSION<br/>k8s-1   Ready    control-plane,master   57s   v1.20.0<br/>k8s-2   Ready    &lt;none&gt;                 41s   v1.20.0</span></pre><p id="b027" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一部分中，我们将使用部署资源部署一个简单的应用程序，并通过类型为<code class="fe mn mo mp mq b">NodePort</code>的服务公开它。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="10ad" class="ni mw it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">部署示例应用程序</h1><p id="6b19" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">首先，我们基于<a class="ae ml" href="https://hub.docker.com/_/ghost" rel="noopener ugc nofollow" target="_blank"> ghost映像</a> (ghost是一个免费的开源博客平台)创建一个部署，并指定两个副本:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="e84c" class="mv mw it mq b gy mx my l mz na">$ kubectl create deploy ghost --image=ghost --replicas=2</span></pre><p id="acf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们使用<code class="fe mn mo mp mq b">NodePort</code>类型的服务来公开pod:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="d104" class="mv mw it mq b gy mx my l mz na">$ kubectl expose deploy/ghost \<br/>  --port 80 \<br/>  --target-port 2368 \<br/>  --type NodePort</span></pre><p id="626a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们获得与这个新创建的服务相关的信息:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="58c8" class="mv mw it mq b gy mx my l mz na"><strong class="mq iu">$ kubectl describe svc ghost<br/></strong>Name:                     ghost<br/>Namespace:                default<br/>Labels:                   app=ghost<br/>Annotations:              &lt;none&gt;<br/>Selector:                 app=ghost<br/>Type:                     NodePort<br/>IP:                       <strong class="mq iu">10.98.141.188</strong><br/>Port:                     &lt;unset&gt;  80/TCP<br/>TargetPort:               2368/TCP<br/>NodePort:                 &lt;unset&gt;  <strong class="mq iu">30966</strong>/TCP<br/>Endpoints:                <strong class="mq iu">10.44.0.3:2368,10.44.0.4:2368</strong><br/>Session Affinity:         None<br/>External Traffic Policy:  Cluster<br/>Events:                   &lt;none&gt;</span></pre><p id="32bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里需要注意的重要事项是:</p><ul class=""><li id="05cb" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">分配给服务的虚拟IP地址(VIP ): 10 . 98 . 141 . 188。</li><li id="c14b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe mn mo mp mq b">NodePort</code> 30966 <strong class="la iu"> </strong>已分配给该服务。通过此端口，我们可以从群集的任何节点访问ghost web界面(此示例中使用的群集节点的IP地址为192.168.64.35和192.168.64.36):</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a44ac0e2277507c9527d3ecd678ce852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KqnDjqEavQNk6mMG_ewgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从群集的一个节点访问Ghost界面。</p></figure><ul class=""><li id="e707" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe mn mo mp mq b">Endpoints</code>属性显示服务公开的pod的IP地址。换句话说，到达端口80上的服务的虚拟IP (10.98.141.188)的每个请求将以循环方式被转发到端口2368上的一个底层pods的IP (10.44.0.3或10.44.0.4)。</li></ul><p id="7e2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:也可以使用标准的<code class="fe mn mo mp mq b">kubectl get</code>命令检索端点:</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="dce7" class="mv mw it mq b gy mx my l mz na"><strong class="mq iu">$ kubectl get endpoints<br/></strong>NAME         ENDPOINTS                       AGE<br/>ghost        10.44.0.3:2368,10.44.0.4:2368   4m<br/>kubernetes   192.168.64.35:6443              6m</span></pre><p id="02e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将仔细研究kube-proxy创建的iptables规则，它将请求路由到后端pod。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="7864" class="ni mw it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">iptables的进一步研究</h1><p id="c50a" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">每次创建/删除服务或修改端点时(例如，如果底层pod的数量由于相关部署的扩展而发生变化)，kube-proxy负责更新集群每个节点上的iptables规则。让我们看看如何使用我们之前定义的服务来实现这一点。</p><p id="e6a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于有很多iptables链，我们将只考虑路由请求所涉及的主要链，该请求在<code class="fe mn mo mp mq b">NodePort</code>上被发送到底层的一个pods:</p><p id="1c03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，<code class="fe mn mo mp mq b">KUBE-NODEPORTS</code>链考虑了进入<code class="fe mn mo mp mq b">NodePort</code>类型服务的数据包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/de363d508f0bc5b8671d14d4b9350652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9nUsOaMUEBt-MKn50rnOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KUBE-诺波特连锁酒店</p></figure><p id="e7b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，来自端口30966的每个数据包首先由<code class="fe mn mo mp mq b">KUBE-MARK-MASQ</code>处理，它用0x4000标记数据包。</p><p id="fb19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="og">注意:只有当负载平衡使用IPVS模式时，才会考虑此标记(因此iptables不会这样做)。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/f995427848c93bb0c2f44f53f0dd1213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7TwyH7sNbIVuwP-X7-FpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KUBE-马克-MASQ链</p></figure><p id="2cb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，数据包由<code class="fe mn mo mp mq b">KUBE-SVC-4XJR4EADNBDQKTKS</code>链处理(参考上面的<code class="fe mn mo mp mq b">KUBE-NODEPORTS</code>链)。如果我们仔细看看这个，我们可以看到另外两个iptables链:</p><ul class=""><li id="d048" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe mn mo mp mq b">KUBE-SEP-7I5NH52DVZSA3QHP</code></li><li id="b750" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe mn mo mp mq b">KUBE-SEP-PSCUKR75MU2ULAEX</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/40e70b2f450502b2056fa2a84753ac9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EnViHHeSgtntRhQkwxk_-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务iptables链接负载平衡请求。</p></figure><p id="ab9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为有了<code class="fe mn mo mp mq b">statistic mode random probability 0.5</code>语句，进入<code class="fe mn mo mp mq b">KUBE-SVC-4XJR4EADNBDQKTKS</code>链的每个数据包都是:</p><ul class=""><li id="fb8f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">50%的时间由<code class="fe mn mo mp mq b">KUBE-SEP-7I5NH52DVZSA3QHP</code>处理，因此50%的时间被忽略。</li><li id="8e81" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">由<code class="fe mn mo mp mq b">KUBE-SEP-PSCUKR75MU2ULAEX</code>处理50%的时间(当被第一个链忽略时)。</li></ul><p id="d351" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们检查这两个链，我们可以看到它们定义了到运行ghost应用程序的底层pod之一的路由:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9455c2e488a8d169beaf10495033eaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oP9LIsvdMgCF8p6RNqPFGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">朝向pod 10.44.0.3的链路线。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9f4dc021ddd0ef935352da4404b35491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZyo-aQEa9_HwNE4b8gg_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">朝向pod 10.44.0.4的链路线。</p></figure><p id="1faf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用几个iptables链，我们就能够理解请求从到达节点端口到到达底层pod的过程。很酷，对吧？</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="07f2" class="ni mw it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">结论</h1><p id="0a68" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">在这篇简短的文章中，我希望我能够阐明kube-proxy在使用iptables模式(默认模式)时的工作方式。在接下来的一篇文章中，我们将会看到在ipvs模式下完成负载平衡时，路由是如何完成的。</p></div></div>    
</body>
</html>