<html>
<head>
<title>How to Do Speech Recognition With a Dynamic Time Warping Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用动态时间弯曲算法进行语音识别</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-do-speech-recognition-with-a-dynamic-time-warping-algorithm-159c2a1bb83c?source=collection_archive---------4-----------------------#2020-07-02">https://betterprogramming.pub/how-to-do-speech-recognition-with-a-dynamic-time-warping-algorithm-159c2a1bb83c?source=collection_archive---------4-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解动态时间弯曲算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5996b68064a6876d0a49e61a1fe48550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*diHvdoqjV__xZht0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@morningbrew?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">晨酿</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="03ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语音识别是分析音频信号以识别说话者所说的单词的过程。自1952年以来，语音识别已经成为我们生活的一部分。我们都在日常生活的许多领域使用这项技术。数字助理Siri就是这种技术的一个例子。</p><p id="6eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由苏联研究人员在1970年发明的动态时间弯曲(DTW)算法被用于语音识别。随着时间的推移，新的算法取代了它，但它仍然是一种流行的技术。</p><p id="2bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态时间弯曲算法是一种动态规划算法，是语音识别中非常流行的技术。为什么DTW算法是语音识别的合适方法？今天我们将看到这项技术是如何用于语音识别的。让我们一起来学习这个。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b64" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">理解问题</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/2273b2b1e1f88e465b61d5a23d138066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4TJGZhIE8ik3YnWS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗斯·斯奈登在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="47d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">专注于解决方案而没有完全理解问题是我们可能犯的最大错误之一。我们先来了解一下问题。语音识别的问题之一是速度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/f040453811168c43249e38281078718f.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*gXkjdmZt9ghXjCqu8zZ69g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:两个不同的人说同样的话的音频信号(图片来源:<a class="ae ky" href="https://databricks.com/blog/2019/04/30/understanding-dynamic-time-warping.html" rel="noopener ugc nofollow" target="_blank"> Databricks博客</a>)</p></figure><p id="735c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">音频信号产生时间序列。上面我们看到两个不同的人的两个音频信号(所以是两个时间序列)。欧几里德匹配是一种传统的时间序列匹配方法。两者之间的时间不匹配。那为什么呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/54305a53103fb362aaa5d60ca85e8af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*iK4eS0ZVSXZ4fafzHCpTAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:欧几里德距离</p></figure><p id="0d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们不匹配，因为在这种方法中，计算的是两个元素值之间的绝对距离。当两个音频信号之间的时间问题如此明显时，这样做是不可靠的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/6ceff1aad32c5d5a29fe0f6f804c1300.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*d-MqJ5w2gfmK14sEIR3pzg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:依赖于时间的序列</p></figure><p id="9393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将时间序列形象化，以便更好地理解。我们可以把时间序列想象成一系列的数字。这两个时间序列对比的时候，会因为时间差而看起来不一样。但是，它们是一样的，只是有一个时间问题。DTW会为我们解决这个问题。那么它是如何解决这个问题的呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="74d0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态时间扭曲的工作原理</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/e139a9e696af62e21595347bda543358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bQiseFLOQ6dLoKIA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">肖恩·奥尔登多夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="155c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将音频信号(即时间序列)划分成相等部分的解决方案，实际上是将问题分解成子问题。当我们为每个子问题找到最佳路径(最短路径)时，我们就为我们的主问题找到了最佳解决方案。</p><p id="7e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DTW创建一个时间偏移，并将一个序列中的每个元素映射到另一个序列中最近的元素。换句话说，DTW在做这个映射的时候找到了元素之间的最佳距离(这里的最佳距离是最短的距离)。所以会产生一个时间偏移。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/19fc92319a6023b0650557a3cc14aeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*C3quTtOmEG8ISpdGXtNumg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:与DTW的时光转移(图片来源:<a class="ae ky" href="https://databricks.com/blog/2019/04/30/understanding-dynamic-time-warping.html" rel="noopener ugc nofollow" target="_blank">数据博客</a></p></figure><p id="1a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些点之间的距离存储在一个表中。这叫做<em class="mz">记忆</em>。然后添加最短路径，这是我们在两个时间序列之间的相似性度量。记住，我们试图检测两个信号之间的相似性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8c55aea6508fefaa5113d9825b001573.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*YxnhoDbjKzg2nY3qdTvKNA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:时间序列x和时间序列y</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/8b5789dffa3593788b20f7b3ce71bfdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*Dog62vAAYvhlFZqsVrhjoQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:扭曲路径</p></figure><p id="0469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一切发生的同时，一条被称为<em class="mz">扭曲路径</em>的路径被创建。时间按照这条路径移动，因此这两个序列达到相同的时间水平。随着弯曲路径变小，两个时间序列之间的相似性增加。扭曲路径根据一些规则出现。扭曲函数代表这些规则。翘曲函数适用于两个系列。时间校准以这种方式发生。该函数包含一些限制:单调性、连续性、边界条件和扭曲窗口。由于这些限制，可以尝试的途径有限。</p><p id="1d76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我举个例子。我们有两个时间序列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/6897ae30917aa70b4a7e1ff0bcff846f.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*qwBqdcRqaa6eNMrZW50kKg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/576a5240b7787cd4a975a3c641f300df.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*e7IGyNLA96he3-B_03PwDQ.png"/></div></figure><p id="f279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们根据时间序列的长度创建一个矩阵。在这个例子中，它是一个8×8的矩阵。我们将时间序列中的值放在x和y平面上。我们使用一个公式来计算一个序列中的每个元素与另一个序列中的每个元素之间的距离:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b4f50ab9accba57c3045db46ac490c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*WaF5tUwPS2-ukkXB_RJXvQ.png"/></div></figure><p id="8f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算完距离后，我们确定了变形路径。最小距离之和为我们提供了两个时间序列之间相似性的度量。</p><p id="9093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有两个不同的人说同一句话的录音。他们会在不同的时间说同样的话。这里使用DTW算法来解决时间偏移是合适的。我们说过，一个音频信号产生一个时间序列。因此，要衡量我们拥有的两个时间序列之间的相似性，我们必须做以下工作:</p><ol class=""><li id="900f" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">将两个时间序列分成相等的部分。</li><li id="8618" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">将时间序列中的一个点与其他时间序列中的每个点进行比较，并将距离存储在表中。(这是记忆化部分。)</li><li id="fbe5" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">对时间序列中的每个点执行步骤2。</li><li id="9359" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">然后对第二个时间序列执行步骤2和步骤3。</li><li id="9b4b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">创建扭曲路径。</li><li id="935c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">将所有最小距离相加。这是对两个时间序列之间相似性的一种度量。</li></ol><p id="7f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不以这种方式创建时间偏移，两个相似的时间序列将显示为不同的序列，因为单词不是同时说出的。</p><p id="e4b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的复杂度是O(N*M ),其中N和M代表每个序列的长度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">使用DTW算法的单词识别</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/ca54c6fc94f67590e5c5241e31fab196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yY0xN33n8L1LbTZQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@grievek1610begur?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文悲伤</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="f3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单词定义有两种方法:信号频谱图的比较或信号的直接比较。</p><p id="787c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经解释了上面信号的直接比较。但是，序列中的数值可能非常高。在这种情况下，数值应该以一定的灵敏度减小。如果时间序列包含大量元素，这可能会导致一些问题。例如，进行许多距离计算。有一种方法就是为解决这类问题而开发的:FastDTW。</p><p id="2dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信号频谱图的比较也具有相同的逻辑。声谱图是用来根据时间分析声音的图表。数字信号被分成一定的范围。这称为<em class="mz">窗口</em>。对每个窗口应用变换(快速傅立叶变换)，并将它们存储在矩阵中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4d0a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态编程的痕迹</h1><p id="175c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">将一个复杂的问题分成子问题并记忆是动态编程的逻辑。因为它隐藏了每个子问题的解，所以在遇到同一个子问题时，不必再次求解。这样，就节省了时间。但是，因为存储了每个子问题的解，所以需要更多的空间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ceae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4e38" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在我们明白了为什么DTW算法适用于语音识别。我们已经知道DTW是如何被用来定义单词和处理音频信号的。我们已经看到它是如何完成这一过程的。我们也看到了与欧几里德的不同，欧几里德是一种传统的匹配方法。</p><p id="74c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来是一个相当复杂的问题，但它并没有那么难，对不对？记住，如果你明白问题是什么，解决方案对你来说更有意义。大家干得好！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3bfb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="314a" class="nf ng it lb b lc nt lf nu li ny lm nz lq oa lu ob nl nm nn bi translated"><a class="ae ky" href="https://www.researchgate.net/publication/26569937_Dynamic_Programming_Algorithms_in_Speech_Recognition" rel="noopener ugc nofollow" target="_blank">https://www . research gate . net/publication/26569937 _ Dynamic _ Programming _ Algorithms _ in _ Speech _ Recognition</a></li><li id="8126" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu ob nl nm nn bi translated"><a class="ae ky" href="https://databricks.com/blog/2019/04/30/understanding-dynamic-time-warping.html" rel="noopener ugc nofollow" target="_blank">https://databricks . com/blog/2019/04/30/understanding-dynamic-time-warping . html</a></li></ul></div></div>    
</body>
</html>