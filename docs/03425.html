<html>
<head>
<title>How I Use StackOverflow With Just My Terminal in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中使用StackOverflow和我的终端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-use-stackoverflow-with-just-a-terminal-go-17548716ab61?source=collection_archive---------9-----------------------#2020-02-09">https://betterprogramming.pub/how-i-use-stackoverflow-with-just-a-terminal-go-17548716ab61?source=collection_archive---------9-----------------------#2020-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cde1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不用离开终端就能得到我的编程问题的答案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1325ec078513d84861387021b252a6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*R8Ccfk6kobJ8FMtATv3BxQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">使用Canva制作</p></figure><p id="7e04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大约一个月前，我遇到了一个用Python创建的项目，<a class="ae lq" href="https://github.com/gleitz/howdoi" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> howdoi </em> </a>。老实说，这太神奇了，不用打开浏览器就能找到基本问题的解决方案是一个救命稻草，所以我想为自己创建一个。我的主要目标之一是速度，所以我选择了Golang。</p><p id="76a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，今天，让我向您展示如何仅使用终端来使用堆栈溢出。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="f9e5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创造一个良好的环境</h1><p id="8044" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">关于如何安装go或者目录结构应该是什么样子，我就不赘述了。你可以在官方页面和文档中找到一切。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="2809" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我们需要什么</h1><ul class=""><li id="b464" class="mw mx it kw b kx mr la ms ld my lh mz ll na lp nb nc nd ne bi translated">使用搜索查询获取帖子的刮刀。</li><li id="ef8a" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">获取每个问题内容的刮刀。</li><li id="ffb0" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">显示解决方案的用户界面。</li></ul></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="4787" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">获取搜索查询的结果</h1><p id="64a7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">一般的堆栈溢出搜索URL如下所示:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ec38" class="np ma it nl b gy nq nr l ns nt"><a class="ae lq" href="https://stackoverflow.com/search?q=how+to+add+2+numbers" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/search?q=how+to+add+2+numbers</a></span></pre><p id="5f73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使得我们很容易得到结果，因为我们每次需要改变的只是<code class="fe nu nv nw nl b">search?q=</code> <em class="lr">之后的部分。</em></p><p id="1923" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获取页面内容后，我们的下一项工作是从正确的元素中获取内容，如标题、描述、帖子链接和up-votes。为此，首先我们需要创建一个结构来存储这些数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b5ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了获取页面的内容，我们将使用<a class="ae lq" href="https://github.com/PuerkitoBio/goquery" rel="noopener ugc nofollow" target="_blank"> goquery </a>库。</p><p id="f828" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从搜索中获取数据的代码片段是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="ad26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在检查源代码时，我发现这个问题存储在一个带有类<code class="fe nu nv nw nl b">question-summary</code>的div中。因此，我们将用这个类迭代每个元素，并从div中获取所需的细节。</p><p id="98cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">的类别:</p><ul class=""><li id="d6e3" class="mw mx it kw b kx ky la lb ld nz lh oa ll ob lp nb nc nd ne bi translated">帖子链接是<code class="fe nu nv nw nl b">.result-link</code>。</li><li id="6f5f" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">问题描述为<code class="fe nu nv nw nl b">.excerpt</code>。</li><li id="24dd" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">票数最多的是<code class="fe nu nv nw nl b">.vote-count-post</code>。</li><li id="5555" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">标题和链接标签是一样的，我们所需要的是获取标签的文本。</li></ul><p id="5e5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获得所有内容后，我们将把数据存储在一个post结构列表中。</p><p id="8ae8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获取数据的最终源代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="460c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这之后，我们就完成了获取搜索页面的内容并将其存储在我们的数组中。下一部分将获取每个问题的内容，并将其存储在另一个数组中。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="3209" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">获取每个帖子的内容</h1><p id="e64d" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们在前面的数组中存储了每篇文章的URL，我们下一步的工作是访问每个链接，从该页面获取内容，并将其存储在另一个数组中。</p><p id="9b22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答案的堆栈溢出页面有两个部分，一个问题部分和一个解决方案列表。</p><p id="e759" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将获得每个解决方案，并将其存储在另一个数组中，然后将答案与接受的答案一起返回。这将与前一部分相同。我们将为这部分使用的结构是:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="66d0" class="np ma it nl b gy nq nr l ns nt">type solution struct {<br/>	description string<br/>	upvotes     string<br/>}</span></pre><p id="d852" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，问题的类别是<code class="fe nu nv nw nl b">.question</code>，而被接受的答案的类别是<code class="fe nu nv nw nl b">accepted-answer</code>。</p><p id="2a19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在此之后，将使用相对div从接受的答案div中刮出剩余的答案。</p><p id="fde6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获取问题内容的代码是:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d54e" class="np ma it nl b gy nq nr l ns nt">var answers []solution<br/>	question := res.Find(".question").Find(".post-layout")<br/>	answers = append(answers, solution{strings.Trim(question.Find(".post-text").Text(), "\n"), question.Find(".js-vote-count").Text()})</span></pre><p id="c144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获得可接受答案的代码是:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5260" class="np ma it nl b gy nq nr l ns nt">acceptedContainer := res.Find(".accepted-answer").Find(".post-layout")<br/>	acceptedAnswer := solution{strings.Trim(acceptedContainer.Find(".post-text").Text(), "\n"), acceptedContainer.Find(".js-vote-count").Text()}</span></pre><p id="1818" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，为了得到剩下的答案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="df7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，综合所有因素后，我们会得到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5f44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有我们需要的一切，从搜索页面的问题列表，然后每个帖子的解决方案。</p><p id="76a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要在UI中显示内容。我们将试图获得两部分，一部分是问题，另一部分是问题的描述。大概是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi oc"><img src="../Images/50d569b7c364a1a11be6ea239ee0ec26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mB0E7NRuFWhlN-oO.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi oc"><img src="../Images/12893415317d138548739b54d3044a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3vVRRIVTS-bsEoNc.png"/></div></div></figure><p id="8cea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用的图书馆是<a class="ae lq" href="https://github.com/gizak/termui" rel="noopener ugc nofollow" target="_blank"> termui </a>。我们的UI将有三个部分，一个是问题列表，另一个是问题描述，最后一个是可能的解决方案。</p><p id="ebda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将一次显示两个部分。我不会涵盖整个图书馆，因为我们只需要它的一部分。</p><p id="6e85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了创建一个包含段落的框，我们已经在库中提供了一个小部件，但它的问题是我们不能滚动它，因此，我们将创建自己的段落小部件。</p><p id="c351" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">小部件的源代码如下。</p><p id="1fa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f37c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">剩下的代码库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8ffb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，解释整个代码将是另一篇文章，但为了给你一个要点，它基本上采取我们指定的样式并创建单元格，然后它采取整个文本并将其分成行。</p><p id="fac4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，它遍历每一行，将它绘制到我们上面指定的单元格中，并将其放置在正确的位置。</p><p id="f52f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="98b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这部分处理内容滚动，我们提供两个值，一个是开始，另一个是结束。</p><p id="582d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，它使用这些值来分割数组，这样我们在屏幕上只绘制了整个内容的一部分。这个开始和结束值将在每次按键时改变，因此内容看起来像是在滚动。</p><p id="0163" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一部分的其余部分非常简单，我们将使用这个新创建的小部件并创建三个包含不同内容的框。</p><p id="bfbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会在这里显示这部分的代码，因为它会使文章不必要的长，相反，我会解释流程。所以，我们将首先创建三个段落。</p><p id="11b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3c6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后唯一的任务就是在正确的按键上呈现正确的框。所以，termui提供了一些功能，像<em class="lr">渲染、</em>渲染一个特定的元素和一个完整的键盘绑定来引用每个键。示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="03a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果有人按下<em class="lr"> q </em>或<em class="lr"> CTRL + c </em>，这将处理UI的关闭，我们可以添加其他情况来呈现按键上的正确框。</p><p id="c6e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一件事大概是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c145fd481f881c00b1476b48e039f5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*wwoc-WeJz0f-MaM4.gif"/></div></figure><p id="bff5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在GitHub 上找到完整的<a class="ae lq" href="https://github.com/pr4k/howto" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><p id="456f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编码快乐！</p></div></div>    
</body>
</html>