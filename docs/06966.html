<html>
<head>
<title>Learn the Basics of RxJava in Kotlin Basics in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在10分钟内学习Kotlin基础知识中的RxJava基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjava-kotlin-basics-in-10-minutes-cf7d931cafe2?source=collection_archive---------2-----------------------#2020-11-21">https://betterprogramming.pub/rxjava-kotlin-basics-in-10-minutes-cf7d931cafe2?source=collection_archive---------2-----------------------#2020-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3ae5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的Android应用添加反应功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/87b68048e9a84664ab2d0a62d48b3636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIuMuqMi9BWg6279pSDz0w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿什·埃德蒙兹在Unsplash<a class="ae kv" href="https://unsplash.com/s/photos/abstract?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上拍摄的照片</a></p></figure><p id="cff9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RxJava是一个库，通过使用可观察序列和函数式操作符创建异步和基于事件的代码，允许通过调度程序执行。"</p><p id="8a23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RxJava本质上简化了异步程序的开发，它允许代码对新的数据流或异步事件做出反应，并以顺序的方式进行处理。</p><h1 id="ddcd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">异步编程快速入门:</strong></h1><p id="668e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设您正在设备上执行一系列任务:</p><ul class=""><li id="b9b0" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">按钮开关</li><li id="234d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在屏幕上观看动画</li><li id="6731" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">从互联网下载大照片</li><li id="d9f7" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">将少量数据保存到磁盘</li><li id="5d09" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">播放音频</li></ul><p id="012a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些事件显然是同时发生的，每当键盘在你的屏幕上播放动画时，你的应用程序中的音频直到动画结束才淡出，对吗？</p><p id="187e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你程序的所有不同部分不会互相阻碍执行，对吗？通常，我们在不同的线程上执行不同的工作，并在设备CPU的不同内核上执行它们。</p><p id="b28f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写真正并行运行的代码相当复杂。尤其是当我们处理处理同一份数据的不同代码时，很难确定执行的顺序。</p><p id="020a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RxJava以被动的方式处理所有这些问题。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="5b7e" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">反动宣言</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/6b262c8d7bbba77937a38653bae7a692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfenLxslHKmAKGBA7o0DLw.png"/></div></div></figure><p id="96e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“反应式系统”是一个相当抽象的术语，涵盖表现出大部分或所有这些品质的应用程序:</p><ul class=""><li id="e2da" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">响应式:</strong>始终保持UI最新，代表最新的应用状态。</li><li id="82ab" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">弹性:每种行为都是独立定义的，并提供灵活的错误恢复。</li><li id="fe7e" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">弹性:</strong>代码处理不同的工作负载，经常实现一些特性，比如懒惰的拉驱动数据。</li><li id="ee13" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">消息驱动:</strong>组件使用基于消息的通信来提高可重用性和隔离性，分离类的生命周期和实现</li></ul><p id="5152" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，反应式系统以灵活和一致的方式对用户和其他事件做出反应。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="422e" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">什么是可观察对象、运算符和调度程序？</h1><h2 id="b80f" class="nq lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated"><strong class="ak">可观测量</strong></h2><p id="78d4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe oc od oe of b">Observable&lt;T&gt;</code>类提供了Rx代码的基础:异步产生一系列事件的能力，这些事件可以“携带”数据t的不可变快照。</p><p id="15f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它允许一个或多个观察者对任何事件做出实时反应，并更新应用程序和使用新的和传入的数据。</p><p id="c4e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe oc od oe of b">Observable</code> <strong class="ky ir"> </strong>(实现了上面的接口)只能发出(并且观察者可以接收)三种类型的事件:</p><ul class=""><li id="3993" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">下一个事件:</strong>“携带”最新(或下一个)数据值的事件。这是观察者“接收”值的方式。</li><li id="6d7a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">完整事件:</strong>该事件成功终止事件序列。这意味着<code class="fe oc od oe of b">Observable</code>成功完成了它的生命周期，不会排放。</li><li id="979f" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><strong class="ky ir">错误事件:</strong><code class="fe oc od oe of b">Observable</code>因错误而终止，不会发出其他事件。</li></ul><p id="c391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当谈到随时间发出的异步事件时，您可以在时间轴上可视化一个可观察到的整数序列，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/559a03d48962ba5da34e996055af45d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5T4c1li_uiFjDNYpOMq-3Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd oh">可观测数据流</strong></p></figure><p id="e67d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">蓝框是由<code class="fe oc od oe of b">Observable</code>发出的下一个事件。右边的竖线代表完整的事件。时间线上的x表示一个错误事件。</p><p id="7b3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为可观察契约没有对<code class="fe oc od oe of b">Observable</code>或<code class="fe oc od oe of b">Observer</code>的性质做出任何假设，所以使用事件序列是最终的解耦实践。你永远不需要使用回调来允许你的类之间相互交流。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/bdc4a7a6a59482e3c03cadfe6b53719e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJ8nymh5HkIhW2azsfgLfg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd oh">解耦观测器</strong></p></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="9f22" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated"><strong class="ak">冷热对比</strong></h1><p id="6f25" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">热可观测序列:</strong>一些可观测序列发出零个、一个或多个值，并且在稍后的时间点，要么成功终止，要么错误终止。</p><p id="d7db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该工作流程准确描述了典型可观察对象的生命周期。看看下面的相关代码:</p><pre class="kg kh ki kj gt oj of ok ol aw om bi"><span id="a3dc" class="nq lt iq of b gy on oo l op oq">API.download(file = "<a class="ae kv" href="http://www" rel="noopener ugc nofollow" target="_blank">http://www</a>...")<br/>  .subscribeBy(<br/>    onNext = {<br/>      // append data to a file<br/>    },<br/>    onComplete = {<br/>      // use downloaded file<br/>    },<br/>    onError = {<br/>      // display error to user<br/>    }<br/>  )</span></pre><p id="4a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑上面从互联网下载文件的代码:</p><ul class=""><li id="21ca" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">首先，您开始下载并开始观察传入的数据。</li><li id="767e" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">然后，随着文件的一部分进入，您会重复地收到大量数据。</li><li id="2990" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">如果网络连接中断，下载将停止，连接将超时并出现错误。</li><li id="6b4f" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">或者，如果代码下载了文件的所有数据，它将成功完成。</li></ul><p id="e170" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">冷可观察序列:</strong>与文件下载或类似活动不同，它们被认为是自然或强制终止的，还有其他序列是无限的。通常，UI事件就是这样无限可观察的序列。</p><p id="a036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑您需要对应用程序中的开关切换做出反应的代码:</p><ul class=""><li id="f811" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">你给你想听的开关加一个<code class="fe oc od oe of b">OnCheckedChangedListener</code>。</li></ul><p id="1897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你需要给OnCheckedChangedListener一个lambda回调，它查看<code class="fe oc od oe of b">isChecked</code>值并相应地更新应用状态。</p><ul class=""><li id="0305" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">这种开关检查变化的顺序没有自然的结束。只要屏幕上有一个开关，就可能有一系列开关检查更改。此外，因为序列实际上是无限的，所以在你开始观察它的时候总是有一个初始值，也就是说，不管开关是开还是关。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/132754345c1cf259b130d2e511066d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PEDcjFzNiOQMDx-iK42bJA.png"/></div></div></figure><p id="bf76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能发生的情况是，用户从来没有切换开关，但这并不意味着事件序列被终止。这只是意味着没有事件发出。</p><p id="0707" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在RxJava中，您可以编写这样的代码来对开关变化做出反应:</p><pre class="kg kh ki kj gt oj of ok ol aw om bi"><span id="35ad" class="nq lt iq of b gy on oo l op oq">switch.checkedChanges()<br/>  .subscribeBy(<br/>    onNext = { isOn -&gt;<br/>      if (isOn) {<br/>        // toggle a setting on<br/>      } else {<br/>        // toggle a setting off<br/>     }</span></pre><p id="191e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oc od oe of b">checkedChanges()</code>是<code class="fe oc od oe of b">CompoundButton</code>上即将被发现的扩展方法，它产生了一个<code class="fe oc od oe of b">Observable&lt;Boolean&gt;</code>。<br/>你订阅<code class="fe oc od oe of b">checkedChanges()</code>返回的<code class="fe oc od oe of b">Observable</code>，根据当前开关状态更新app设置。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="9e0c" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">经营者</h1><p id="afa8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe oc od oe of b">ObservableSource&lt;T&gt;</code>和<code class="fe oc od oe of b">Observable</code>类的实现包含了大量的方法，这些方法抽象了异步工作的离散部分，可以组合在一起实现更复杂的逻辑。<br/>因为它们是高度解耦和可组合的，所以这些方法通常被称为操作符。由于这些操作符主要接受异步输入，并且只产生输出而不会引起副作用，因此它们可以很容易地组合在一起，就像拼图一样，并努力构建一个更大的画面。例如，以下面的数学表达式为例:</p><p id="3e1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">(5+6)* 10–2。</strong></p><p id="dcbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以一种清晰、确定的方式，您可以将操作符<code class="fe oc od oe of b">*</code>、<code class="fe oc od oe of b">( )</code>、<code class="fe oc od oe of b">+</code>和<code class="fe oc od oe of b"> —</code>以它们预定义的顺序应用于作为它们输入的数据，获取它们的输出，并继续处理表达式，直到它被解析。</p><p id="3098" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以有点类似的方式，您可以将<code class="fe oc od oe of b">Rx</code>操作符应用于由<code class="fe oc od oe of b">Observable</code>发出的输入片段，以确定性地处理输入和输出，直到表达式被解析为最终值，然后您可以使用该值来产生副作用。<br/>这是之前关于观察开关变化的例子，调整后使用一些常见的Rx操作符:</p><pre class="kg kh ki kj gt oj of ok ol aw om bi"><span id="4c73" class="nq lt iq of b gy on oo l op oq">switch.checkedChanges()<br/>  .filter { it == true }<br/>  .map { "We've been toggled on!" }<br/>  .subscribeBy(<br/>    onNext = { message -&gt;<br/>      updateTextView(message)<br/>    }<br/>  )</span></pre><p id="0b6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次<code class="fe oc od oe of b">checkedChanges()</code>产生真或假值时，<code class="fe oc od oe of b">Rx</code>将对发出的数据应用过滤器和映射操作符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/fabad2e487f3513458c8f74cbb069a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BW4U-TkDuKeV1Mt2cpzNHg.png"/></div></div></figure><p id="80e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，过滤器只会让真值通过。如果开关被关闭，订阅代码将不会被执行，因为过滤器将限制这些值。</p><p id="9d6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是真值，map运算符将接受布尔类型输入并将其转换为字符串输出，即文本“我们已经打开！”</p><p id="0c41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，用<code class="fe oc od oe of b">subscribeBy</code>订阅产生的下一个事件，这次携带一个<code class="fe oc od oe of b">String</code>值，并调用一个方法用屏幕上的文本更新一些文本视图。</p><p id="9ebc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">操作符也是高度可组合的。它们总是接受数据作为输入并输出结果，因此您可以很容易地以许多不同的方式将它们链接起来，实现比单个操作者单独所能实现的要多得多的功能！</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="b0f9" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated"><strong class="ak">调度程序</strong></h1><p id="2779" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">调度器类似于你在普通Java和Kotlin代码中看到的<code class="fe oc od oe of b">ThreadPools</code>。如果你不熟悉<code class="fe oc od oe of b">ThreadPools</code>，你可以把它们想象成一个线程的集合，所有的线程都连接在一起并可供使用。RxJava附带了许多预定义的调度器，它们覆盖了99%的用例。希望这意味着你永远不必创建自己的调度程序。</p><p id="acad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，调度程序非常强大。</p><p id="c7d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您可以指定希望观察IO调度程序上的后续事件，这使得您的Rx代码在后台线程池中运行。如果您要从网络下载文件或将某些内容保存到数据库，您可能需要使用此计划程序。</p><p id="23bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为繁重的计算任务保留的一组单独线程上的订阅。</p><p id="71d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">借助RxJava，您可以在不同的调度器上调度同一订阅的不同工作，以获得最佳性能。</p><p id="332d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样结束了！</p></div></div>    
</body>
</html>