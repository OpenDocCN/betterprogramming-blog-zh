<html>
<head>
<title>Graphene-Django Input Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">石墨烯-Django输入验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/validate-graphene-django-inputs-like-a-pro-e362cfc74372?source=collection_archive---------8-----------------------#2022-07-01">https://betterprogramming.pub/validate-graphene-django-inputs-like-a-pro-e362cfc74372?source=collection_archive---------8-----------------------#2022-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="688f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">防止恶意攻击</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3c8329b8a1662fc37b611cf6a7303ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yJTYdLTgWyWch567"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3ce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API的输入验证是必须的，怎么强调都不为过。在本文中，我将向您展示如何使用协作式多重继承来验证您的石墨烯输入。</p><h1 id="009f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">到底什么是输入验证？</h1><p id="8a4c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">输入验证是对用户提供的任何输入进行测试，以防止恶意数据进入API。</p><h1 id="3914" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如果不验证用户输入会发生什么？</h1><p id="1a2a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这可能导致SQL注入攻击、内存泄漏和系统受损。在本文中，我们将使用白名单来通知我们的API什么样的数据是可接受的，其他任何数据都将被拒绝。这是一个非常有效的激进策略。</p><h2 id="23a5" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">我的第一次尝试</strong></h2><p id="c4e6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我第一次编写正则表达式验证<strong class="ky ir"> <em class="nb">装饰</em> </strong>时，它完成了工作，但我不是很满意，它看起来很粗糙，而且每当我遇到新的边缘情况时，我的白名单就会越来越长。</p><p id="84df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">石墨烯实际上提供了验证输入的完美框架。Django models接受任意嵌套对象(JSONField ),但是在graphene中，无论对象的嵌套程度如何，每个键值对都是一个标量或枚举实例。</p><p id="e470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很自然，我认为如果<code class="fe nc nd ne nf b">graphene</code>包定义了一个<code class="fe nc nd ne nf b">Descriptor</code>作为标量的基类，我的工作就完成了一半。所以我在我的环境里钓鱼。根本没有！</p><blockquote class="ng nh ni"><p id="1d14" class="kw kx nb ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">给graphene devs的消息——为标量定义一个描述符，或者更好，添加一个正则表达式验证参数，就像我在这里做的那样。我们用户会为此感谢你的。</p></blockquote><p id="8dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要么单独子类化标量(String、Float、Int、ID、Boolean ),要么直接子类化基本标量类，并与具体标量处于同一级别，这就是我们将在下面看到的。</p><p id="6cb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是自定义标量的外观</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bb7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用自定义标量字符串之前，应该了解它的一些行为。</p><ol class=""><li id="76b6" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">连续为每个实例调用Dunder init。实例一次流入一个，并对它们调用init。</li><li id="cd60" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">在调用静态方法之前，所有的实例都将被初始化。所以，这不像一个实例被初始化，静态方法同步调用它的值，不。如果这个类是自上而下同步的，这实际上很容易，但它不是，所以我们必须弄脏我们的手。</li><li id="4048" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">如果值是Python数据类型，将调用<code class="fe nc nd ne nf b">parse_value</code>方法</li><li id="3502" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">如果值是GraphQL文字，将调用<code class="fe nc nd ne nf b">parse_literal</code>方法。</li><li id="1472" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">当类返回值时，将调用<code class="fe nc nd ne nf b">serialize</code>方法。这对我们的用例来说无关紧要，但是我们的类必须实现它才能与基类(标量)合作。</li><li id="6fde" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">重要的是，由于类中的方法是静态方法，为了捕获我们的参数(您将在下面看到),我们需要将它们存储在类的外部。这样，当用一个值调用一个静态方法时，我们可以验证它。</li></ol><p id="744c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将如何使用这个类？</p><p id="4ba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="30fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">石墨烯标量只有两个参数</p><ul class=""><li id="4853" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr oc nu nv nw bi translated"><code class="fe nc nd ne nf b">required</code>孰真孰假</li><li id="fde7" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated"><code class="fe nc nd ne nf b">description</code>该字段的描述。</li></ul><p id="09c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我添加了第三个参数，<code class="fe nc nd ne nf b"><em class="nb">validate</em></code>。这是一个正则表达式模式，它将为每个字段定义，以通知我们的Stringy类什么类型的数据对于该特定字段是可接受的</p><p id="75b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:第30行的name和email都是Stringy的一个实例，它们将被一个接一个地初始化。在它们都被初始化之后，静态方法将用值来调用。这对一些人来说可能是显而易见的，但不是所有人。</p><h1 id="6e77" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">哪个是价值，哪个是论点？</strong></h1><ul class=""><li id="84c5" class="no np iq ky b kz mk lc ml lf od lj oe ln of lr oc nu nv nw bi translated">值是从浏览器发送的输入，并且</li><li id="4aa5" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated">参数是在实例化过程中传递给标量的内容。分别是<code class="fe nc nd ne nf b">required</code>、<code class="fe nc nd ne nf b">description</code>和<code class="fe nc nd ne nf b">validate</code>。</li></ul><p id="8c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何验证输入呢？</p><p id="868b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很高兴你问了！</p><p id="e455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下文件:</p><ul class=""><li id="d6a2" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr oc nu nv nw bi translated">顶部的pattern_list用于捕获我们的验证正则表达式模式。</li><li id="a984" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated">在init方法中，我们从<code class="fe nc nd ne nf b">kwargs</code>中移除了validate键，并将其添加到pattern_list中以备后用。</li><li id="b5ea" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated">在parse_ value和parse_literal方法中，我们遍历pattern_list，看看是否有任何模式与值匹配。</li><li id="0e2c" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated">我们将迭代的范围增加了pattern_list的长度加1。因此，如果迭代命中<code class="fe nc nd ne nf b">IndexError</code>，我们将知道没有模式匹配我们的值，因此它是无效的。</li></ul><p id="0e06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，验证密钥不能传递给石墨烯，这就是为什么我们使用pop来删除它。这被称为关键字参数剥离，是<a class="ae kv" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" rel="noopener ugc nofollow" target="_blank">合作多重继承范例</a>中的一个巧妙技巧。</p><h2 id="845e" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">白名单</h2><p id="e9b6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们本质上所做的是将我们的API将接受的所有可接受的模式列入白名单，因此如果pattern_list中没有模式匹配，我们将拒绝输入。</p><p id="9885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是输入验证的本质，但是我们定义的只是一个标量，字符串标量。我们需要对Float、Int、Boolean和ID标量做同样的事情。</p><p id="1893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，让我们将验证迭代移到类之外。</p><p id="d07b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像这样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="150f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干净多了！</p><p id="ee9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们必须为所有自定义标量(Stringy、Inty等)定义<code class="fe nc nd ne nf b">serialize</code>、<code class="fe nc nd ne nf b">parse_value</code>和<code class="fe nc nd ne nf b">parse_literal</code>方法，这就不会枯燥了。</p><p id="cd9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案？</p><p id="17db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个中间初始化器类来保存标量的方法，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那更好。</p><p id="92da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是完整的标量用法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="f891" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">这种方法的好处？</h1><ul class=""><li id="c764" class="no np iq ky b kz mk lc ml lf od lj oe ln of lr oc nu nv nw bi translated">Pattern_list是动态构建的，它非常小，因为它一次只用于一个变异类。</li><li id="56cf" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated">这种方法让您可以对允许进入API的数据进行细粒度的控制。</li><li id="d5a5" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated">当添加新字段时，您不必担心测试，因为我们验证的是字段，而不是类或函数。所以只要使用像<a class="ae kv" href="http://regextester.com" rel="noopener ugc nofollow" target="_blank">regextester.com</a>这样的工具来测试这个新领域的正则表达式。</li><li id="417f" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oc nu nv nw bi translated">您可以验证自定义类型和自定义输入，方式非常类似:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="2a67" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="779d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不要将标量命名为“字符串”、“浮点”、“整数”、“布尔”或“ID”。如果您这样做，实例调用将绕过您的自定义类，直接进入同名的graphene标量，并且您将得到一个传递validate regex模式的错误。我不确定为什么会有这种行为。给它们起一个独特的名字，如Stringy，Floaty等。</p><blockquote class="ng nh ni"><p id="60d8" class="kw kx nb ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">请注意，我的用例只是突变，因此，如果出于某种原因，您想将它用于查询，您将需要确保您的初始化器类是可序列化的。</p></blockquote><p id="ccf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有它！</p><p id="f689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要错过下一个重要的操作方法。</p><p id="f8e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>