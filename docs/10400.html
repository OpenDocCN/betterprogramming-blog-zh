<html>
<head>
<title>Kotlin Multiplatform Mobile: The Definitive Cross-platform Bridge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin多平台手机:权威的跨平台桥梁</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-multiplatform-mobile-is-it-a-comfortable-bridge-fb724a9f3a0c?source=collection_archive---------12-----------------------#2022-01-04">https://betterprogramming.pub/kotlin-multiplatform-mobile-is-it-a-comfortable-bridge-fb724a9f3a0c?source=collection_archive---------12-----------------------#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="51af" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我使用KMM构建Android和iOS的最初印象</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d9b906f19e096158647224cf23038497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tzzBGonF0BxK1QBS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@elli19?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃琳娜·科劳彭伯格</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="af2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一下:你是一名Android开发者，没有Swift、Dart、Xamarin和React原生背景。你介意在3个月内为Android和iOS平台开发一款应用吗？</p><p id="0fff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果应用程序只包含Hello World屏幕，你不会介意。但是，如果您希望构建一个真实世界的应用程序，事情会变得棘手。本文讨论了一个完全非多平台的软件工程师如何在两个平台之间架起桥梁。</p><p id="a953" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多年来，已经有一些有希望的替代方法来构建多平台应用程序，如Flutter、React Native等。Net毛伊岛，本地脚本，科特林多平台移动等。这些框架中的每一个对于多平台应用程序开发都是可靠的——并且提供了一个构造良好的桥梁，让您可以无缝地跨平台切换。</p><p id="9feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，原生android开发者必须熟悉Kotlin或Java。目前，为了遵循推荐的Android开发最佳实践，Android开发人员从Java迁移到Kotlin至关重要。Kotlin不仅使用起来简单高效，而且有着光明的前景。换句话说，我们可以说，它确实是一种为“步行者”提供多种用途的桥梁。</p><p id="1740" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，我不打算在这里谈论Kotlin对Android开发的好处。相反，我们将把重点放在Kotlin为多平台开发提供的产品上，这些产品目前处于Alpha状态。尽管如此，我对Kotlin多平台移动平台的探索还是带来了一些惊人的结果。</p><h1 id="0ccc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">共享逻辑</h1><p id="d896" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，共享逻辑的能力是我们需要关注Kotlin多平台移动未来的原因。</p><p id="baf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为具有相同逻辑的不同平台构建一个应用程序而工作两次，这当然很烦人。此外，对于那些可能是SwiftUI编码新手的人来说，考虑到新的学习曲线，构建端到端iOS应用可能需要一段时间。</p><p id="e022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，提供的共享逻辑非常有用，因为所需的业务逻辑只需创建和测试一次，如下图所示。</p><p id="7291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">commonMain</code>文件夹是创建共享逻辑的地方，而<code class="fe mp mq mr ms b">androidMain</code>和<code class="fe mp mq mr ms b">iosMain</code>文件夹用于每个平台的<code class="fe mp mq mr ms b">actual</code>逻辑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/9f181e50241fa44e514136cca6ffa404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDvlSBWexbTk8JfVzcYGvg.png"/></div></div></figure><p id="a1f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ktor和SQLDelight是目前用来接触app API和本地数据库的主要武器。</p><p id="ea2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为两个依赖项对于每个平台都有不同的构建配置，所以它们是内置的<code class="fe mp mq mr ms b">androidMain</code>和<code class="fe mp mq mr ms b">iosMain</code>。因此，如下图所示，用于创建本地数据库的<code class="fe mp mq mr ms b">createDriver()</code>的<code class="fe mp mq mr ms b">actual</code>函数没有方法体。他们将为每个平台运行不同的方法体，使用<code class="fe mp mq mr ms b">expect</code>函数调用。</p><p id="f240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦调用其实际方法(在本例中为<code class="fe mp mq mr ms b">createDriver()</code> ) <code class="fe mp mq mr ms b">shared</code> database builder，就会触发以下<code class="fe mp mq mr ms b">expect</code>函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/1f43a0a0581f4eb8af2c642ff9053461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsRpM68YwIYIBR5He_VMkg.png"/></div></div></figure><h1 id="cbd8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">声明式用户界面</h1><p id="e388" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">提供基于Kotlin的Jetpack Compose作为声明性UI是一个非常酷的想法。</p><p id="6b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里很酷的是，那些使用Jetpack Compose开发Android UI的人天生就在学习如何使用SwiftUI编码。</p><p id="1574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，基于Kotlin的开发人员不会花太多时间来学习SwiftUI和开发iOS UI，因为他们已经处理了声明性UI的基本工作流。令人惊奇不是吗？</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="2c2d" class="mz lt iq ms b gy na nb l nc nd">//Jetpack Compose (Android)<br/>@Composable<br/>fun MainScreen(){<br/>    Text("Hello World")<br/>}</span><span id="994e" class="mz lt iq ms b gy ne nb l nc nd">//SwiftUI (iOS)<br/>struct MainScreen: View{<br/>    var body: some View{<br/>        Text("Hello Wrold")<br/>    }<br/>}</span></pre><p id="0819" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码示例简单地展示了如何为两个平台设计类似的声明性方法。</p><p id="896f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我在不到3个月的时间内开发的Kotlin多平台移动项目UI的预览，注意，我没有任何Swift经验。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/207877598467d2a26812ead7d94973c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CSOFetLKi7UpfrVL3bvobQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS (SwiftUI)和Android (Jetpack Compose) — Kotlin多平台移动项目</p></figure><p id="0ce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的预览图中，我们可以看到尽管框架不同，但两个平台的UI看起来很像。关键是，只要UI区域是可设计的，Jetpack Compose或SwiftUI的声明式UI开发就可以使它们彼此相似。</p><p id="b256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两者都仍然缺乏必要的组件，但我们仍然可以使用旧式的UI开发，使用XML for Android和UIKit for iOS来弥补这些差距。</p><p id="2ed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图是在声明式UI (Jetpack Compose和SwiftUI)方法中实现Google Map API的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/6b8c4df93ba04f9301fe6d96c8a23acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YuruliADa0n0H9l6uXGFgw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS (SwiftUI)和Android (Jetpack Compose)中的Google地图API—kot Lin多平台移动项目</p></figure><p id="6e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是UIKit如何帮助在SwiftUI中实现Google Map API的。UIKit的UI表示可以是多种多样的，这取决于我们将要显示的视图类型。</p><p id="0bf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，它在Android View如何帮助Jetpack Compose显示当前不支持的视图方面发挥了作用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a5a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中，Android视图在UIKit的UI可表示性如何帮助SwiftUI显示Google Map API方面发挥了作用。</p><p id="1b84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个例子，说明Jetpack Compose如何提供一种替代方案来支持任何不支持的视图配置，比如基于XML的视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="8cb4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="2323" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，令人兴奋的是使用共享逻辑，我们只需要利用Kotlin多平台移动作为桥梁，让每个平台调用它们必要的代码。</p><p id="6f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这种桥梁仍在改进中，一些实验方法仍然令人担忧，因为它可以突然拆除。</p><p id="a82c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，作为一名Kotlin开发人员，我的观点是，使用这种多平台方法就像踢足球一样，规则只是有一点不同，但踢球的方式并没有太大的不同。希望你喜欢这篇文章。感谢阅读和快乐编码。</p></div></div>    
</body>
</html>