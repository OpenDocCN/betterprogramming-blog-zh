<html>
<head>
<title>Lifecycle Methods in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的生命周期方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/view-life-cycle-methods-in-swiftui-b7fa9f0e8dfb?source=collection_archive---------0-----------------------#2020-05-02">https://betterprogramming.pub/view-life-cycle-methods-in-swiftui-b7fa9f0e8dfb?source=collection_archive---------0-----------------------#2020-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cee3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">丢失的手册</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f9093fee7561bd1da90a4a09da978def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tn6rmdkJEExNZCz4MOEadQ.png"/></div></div></figure><p id="0f7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">UIKit开发人员可能听说过术语<em class="ln">视图生命周期</em>方法。好吧，如果你是UIKit开发人员，在我们深入主题之前，让我问几个问题。</p><p id="bb8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能在不接触Xcode的情况下列出ViewController中所有的视图循环方法吗？</p><p id="8028" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，你能以正确的顺序列出在两个ViewControllers之间导航时的视图循环方法吗？😅</p><p id="acb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的，如果你答对了上面的问题，这对你来说就很容易了。在iPad上以PageSheet或FormSheet的形式呈现ViewController时，您能列举出同样的事情吗？</p><p id="5ac3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有点复杂，对！也许至少对我来说是这样🤯</p><p id="9452" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在ViewControllers中有许多视图生命周期方法，它们将根据我们的设计以不同的顺序被调用。当我们在单个屏幕上使用<strong class="kt ir"> ContainerView </strong>定制UI时，这可能会更加复杂。</p><p id="577b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在SwiftUI中很简单。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="0f89" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">SwiftUI中的生命周期方法</h1><p id="e186" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">据我所知，苹果文档中有<strong class="kt ir"> <em class="ln">没有官方的文字</em> </strong>，比如SwiftUI中视图的View life方法，但是我们确实有一些东西可以和UIKit生命周期方法相比。</p><p id="892a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的，让我们看看SwiftUI中有哪些等价的东西，以及它有多简单。通常，每当视图在UIKit中出现或消失时，我们都会使用视图生命周期方法来做一些事情。<em class="ln">例如:API命中或清除数据。</em></p><p id="4318" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在SwiftUI中，没有<em class="ln">视图控制器</em>，一切都是视图。<em class="ln">纯观点</em>。当用户打开你的app时，你会初始化一个视图，并显示在屏幕中；屏幕之间的导航由名为<strong class="kt ir"> <em class="ln"> NavigationView的视图执行；</em> </strong>选项卡功能由一个名为<strong class="kt ir">选项卡视图</strong>等的视图管理</p><p id="9b00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与UIKit不同，我们在SwiftUI中只有两个简单的实例方法，可以作为视图生命周期方法。它们是:</p><p id="3e36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">.onAppear()<br/>.onDisappear()</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">内容视图. swift</p></figure><p id="a2ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请检查上述<code class="fe ms mt mu mv b">ContentView.swift</code> <strong class="kt ir"> </strong>文件中的代码并继续。我为不同的视图添加了<code class="fe ms mt mu mv b">onAppear()</code>和<code class="fe ms mt mu mv b">onDisappear()</code>，并在控制台中添加了不同的表情符号进行视觉识别。</p><p id="27bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nc" href="https://github.com/karthironald/ViewLifeCycleMethods" rel="noopener ugc nofollow" target="_blank"> Github回购链接</a>用于工作演示。</p><p id="3be4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">🔴=导航视图<br/> 🟢 =列表视图<br/> 🟠 =滑动视图</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="7db7" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">。onAppear(): </strong></h1><p id="2afa" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">当视图出现在屏幕上时，触发<code class="fe ms mt mu mv b">.onAppea()</code>。</p><p id="7680" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以将这种方法与UIKit中的<code class="fe ms mt mu mv b">viewDidAppear()</code>进行对比。每当视图出现时，我们可以使用这个方法来执行一个动作。从本地或远程数据库获取数据。</p><p id="3852" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ms mt mu mv b">ContentView.swift</code>文件中有多个视图，但是只关注我添加了<code class="fe ms mt mu mv b">onAppear()</code>和<code class="fe ms mt mu mv b">onDisappear()</code>方法的视图。</p><p id="a50c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有逻辑来展示三观(🔴🟢和🟠)在一个屏幕和两个视图中(🔴&amp; 🟢)会在用户导航到屏幕时立即出现。所以，这两个可见视图中的<code class="fe ms mt mu mv b">onAppear()</code>将立即按照<code class="fe ms mt mu mv b">parent(🔴) </code>到<strong class="kt ir"> </strong> <code class="fe ms mt mu mv b">children(🟢)</code>的顺序被调用。</p><p id="69f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3号view's(🟠) <code class="fe ms mt mu mv b">onAppear()</code> <em class="ln"> </em>将<em class="ln"> </em>仅在屏幕上可见时调用。我只在用户打开开关时显示了滑块。当开关关闭时，滑块在屏幕上不可见，因此它的<code class="fe ms mt mu mv b">onAppear()</code>不会被调用。</p><p id="d104" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们连续打开和关闭切换开关，滑块view's(🟠) <code class="fe ms mt mu mv b">onAppear()</code>和<code class="fe ms mt mu mv b">onDisappear()</code>将被多次调用。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="fa28" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">。onDisappear(): </strong></h1><p id="39be" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">当视图从屏幕上消失时，触发<code class="fe ms mt mu mv b">.onDisappear()</code>。</p><p id="f808" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以将这种方法与UIKit中的<code class="fe ms mt mu mv b">viewDidDisappear()</code>进行对比。每当一个视图消失时，我们可以使用这个事件来执行一个动作。<em class="ln">例如:清除数据。</em></p><p id="4884" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我添加了一个演示，使用<code class="fe ms mt mu mv b">NavigationView</code> <strong class="kt ir"> </strong>和<strong class="kt ir"> </strong> <code class="fe ms mt mu mv b">TabView</code> <strong class="kt ir">从一个视图导航到另一个视图。</strong>大多数子视图的<code class="fe ms mt mu mv b">onAppear()</code>和<code class="fe ms mt mu mv b">onDisappear()</code>在<code class="fe ms mt mu mv b">NavigationView</code>和<code class="fe ms mt mu mv b">TabView</code> <strong class="kt ir"> </strong>导航中的调用顺序相同。</p><p id="a613" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，导航到DetailsView时不会调用NavigationView的<code class="fe ms mt mu mv b">onDisappear()</code>，因为NavigationView仍然出现在DetailsView中。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="0a30" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">推送视图:</h1><p id="2597" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">当你使用导航视图推送到另一个视图时，目标视图的<code class="fe ms mt mu mv b">onAppear()</code> <strong class="kt ir"> <em class="ln"> </em> </strong>将被首先调用，然后源视图的<code class="fe ms mt mu mv b">onDisappear()</code>将被调用。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="b355" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">展示观点:</h1><p id="0ed2" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">当您使用工作表呈现另一个视图时，目标视图的<code class="fe ms mt mu mv b">onAppear()</code> <strong class="kt ir"> <em class="ln"> </em> </strong>将被调用，而源视图的<code class="fe ms mt mu mv b">onDisappear()</code>将不会被调用，因为您在所呈现视图的背景中有源视图。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9176" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论:</h1><p id="37ea" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">通过使用视图中的<em class="ln"> </em> <code class="fe ms mt mu mv b">onAppear()</code>和<code class="fe ms mt mu mv b">onDisappear()</code>实例方法，我们可以实现视图在屏幕上出现或消失的需要。</p><p id="c8d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你在屏幕上有多个嵌套视图时，我们需要找到一个完美的视图来添加<code class="fe ms mt mu mv b">onAppear()</code>和<code class="fe ms mt mu mv b">onDisappear()</code> <strong class="kt ir"> <em class="ln"> </em> </strong>动作来运行你的自定义逻辑。</p><p id="dfb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">SwiftUI是一个比UIKit更有趣、超级容易开发app的框架。一有时间就玩玩。</p><p id="843e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nc" href="https://github.com/karthironald/ViewLifeCycleMethods" rel="noopener ugc nofollow" target="_blank">演示项目的Github回购链接</a>。</p><p id="a292" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谢谢👨🏻‍💻</p></div></div>    
</body>
</html>