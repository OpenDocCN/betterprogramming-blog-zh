<html>
<head>
<title>How To Implement Dark Mode in Your React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在你的React应用中实现黑暗模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-dark-mode-in-your-react-app-63c1a0c5e337?source=collection_archive---------8-----------------------#2019-12-05">https://betterprogramming.pub/how-to-implement-dark-mode-in-your-react-app-63c1a0c5e337?source=collection_archive---------8-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4047" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让用户的眼睛休息一下</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/9155e31d9ee2ffd5e458a5fb3af2a8cc.png" data-original-src="https://miro.medium.com/v2/1*Z7UQUmu2IOPVWiiE62pHQw.gif"/></div></figure><p id="4e17" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在开发React应用程序时，我想实现一个日/夜模式功能，允许用户选择他们是否想要使用亮或暗的主题。黑暗模式在应用程序和软件设计中越来越受欢迎。除了看起来很酷之外，黑暗模式还有助于设备节能和减轻眼睛疲劳。更多关于黑暗模式背后的科学，请看【观察者】的<a class="ae lm" href="https://observer.com/2019/03/dark-mode-app-trend-psychological-effects/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="92a6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇文章中，我将展示在我的React应用中实现这种新的设计趋势是多么容易。我的应用程序中涉及了更多的CSS，但是为了保持简洁，我将只提供与我的日间/夜间模式功能相关的CSS。首先，让我提供一些背景。</p><p id="7657" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我的React应用是一个在线文本编辑器。我的<code class="fe lo lp lq lr b">App</code>组件有一个白色的背景和黑色的字体颜色。这是贯穿我的应用程序的一致的配色方案。我真的在挑战当代网页设计的极限。</p><p id="c394" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是我的<code class="fe lo lp lq lr b">App</code>组件。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="f42d" class="lw lx it lr b gy ly lz l ma mb">import React, {Component} from 'react';<br/>import './App.css';<br/>import SizeContainer from './components/SizeContainer.js';<br/>import {withRouter} from 'react-router-dom';<br/>import { connect } from 'react-redux'; </span><span id="dec9" class="lw lx it lr b gy mc lz l ma mb">const App = (props) =&gt; {     <br/>   return (      <br/>      &lt;div className={!props.mode ? "App" : 'night'}&gt;        <br/>         &lt;h1 style={{height: 50, marginBottom: 0, padding: 5}}&gt;<br/>           React Editor<br/>         &lt;/h1&gt;        <br/>         &lt;SizeContainer mode={props.mode}/&gt;      <br/>      &lt;/div&gt;    <br/>   );<br/>} </span><span id="b195" class="lw lx it lr b gy mc lz l ma mb">const mapStateToProps = (state) =&gt; {  <br/>   return {      <br/>      mode: state.mode  <br/>   };<br/>} </span><span id="d3f9" class="lw lx it lr b gy mc lz l ma mb">export default withRouter(connect(mapStateToProps) (App));</span></pre><p id="995c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如你所见，我的<code class="fe lo lp lq lr b">App</code>组件通过<code class="fe lo lp lq lr b">mapStateToProps</code>访问<code class="fe lo lp lq lr b">mode</code>道具。这个道具存储在我的reducer中，我选择用<code class="fe lo lp lq lr b">connect</code>导出的任何组件都可以访问它。虽然Redux对于这个功能来说不是必需的，但我发现它确实使应用样式的过程变得更容易，同时保持了我的组件的精简和平均。有关Redux的更多信息，请查看<a class="ae lm" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="9b15" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是我的减速器:</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="503d" class="lw lx it lr b gy ly lz l ma mb">export default function rootReducer(state={mode: false}, action){<br/>   switch(action.type){      <br/>      case "CHANGE_MODE":      <br/>         var mode = !state.mode        <br/>         return {...state, mode}      <br/>      default:        <br/>         return state    <br/>    }   <br/>}</span></pre><p id="6fad" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当调用<code class="fe lo lp lq lr b">CHANGE_MODE</code>时，需要做的就是获取我的减速器状态中<code class="fe lo lp lq lr b">mode</code>的当前值(真/假),并赋予它与当前值相反的值。</p><p id="f296" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果<code class="fe lo lp lq lr b">state.mode</code>为真，那么<code class="fe lo lp lq lr b">!state.mode</code>将等于假，反之亦然。此操作不需要有效负载。既然我们已经看到了这在reducer中是如何处理的，那么让我们看看actions文件中的<code class="fe lo lp lq lr b">CHANGE_MODE</code>动作。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="fd6b" class="lw lx it lr b gy ly lz l ma mb">export function changeMode(){  <br/>   return {    <br/>      type: "CHANGE_MODE"  <br/>   }<br/>}</span></pre><p id="37a6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为没有有效负载，切换操作发生在reducer中，所以我们需要做的就是在我们的一个组件中调用这个函数，每当我们想要切换应用程序的主题时。这让我想到了我的下一个组件:<code class="fe lo lp lq lr b">SizeContainer</code>。</p><p id="0ea5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为我将从<code class="fe lo lp lq lr b">App</code>向<code class="fe lo lp lq lr b">SizeContainer</code>传递<code class="fe lo lp lq lr b">props.mode</code>，所以<code class="fe lo lp lq lr b">SizeContainer</code>中的子元素也可以访问<code class="fe lo lp lq lr b">props.mode</code>。这对于一个子组件尤其重要:<code class="fe lo lp lq lr b">Buttons</code>。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="3585" class="lw lx it lr b gy ly lz l ma mb">import React from 'react';<br/>import {FaFileCode, FaLightbulb} from "react-icons/fa";<br/>import {withRouter} from 'react-router-dom';<br/>import { connect } from 'react-redux';<br/>import { changeMode } from './../actions'</span><span id="cec1" class="lw lx it lr b gy mc lz l ma mb">const Buttons  = (props) =&gt; {</span><span id="ccd6" class="lw lx it lr b gy mc lz l ma mb">    var {mode, changeMode} = props;</span><span id="919b" class="lw lx it lr b gy mc lz l ma mb">    return(<br/>      &lt;div className='buttonsContainer' &gt;<br/>         &lt;div&gt;<br/>           &lt;div className='buttons' onClick={changeMode}&gt;<br/>              &lt;FaLightbulb/&gt;<br/>              &lt;span className="tooltiptext"&gt;<br/>                 {mode ? "Day Mode" : "Night Mode"}<br/>              &lt;/span&gt;<br/>            &lt;/div&gt;<br/>            &lt;div className='buttons'&gt;<br/>               &lt;FaFileCode/&gt;<br/>               &lt;span className="tooltiptext"&gt;<br/>                   Download Code<br/>                &lt;/span&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>       &lt;/div&gt;<br/>    )<br/>};</span><span id="3091" class="lw lx it lr b gy mc lz l ma mb">export default withRouter(connect(null, {changeMode}) (Buttons))</span></pre><p id="98c3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上面的代码将呈现下面的两个按钮——一个有灯泡图标，另一个是代码文件图标。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi md"><img src="../Images/2b87249fedf1af651aec989bb39237d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:184/format:webp/1*2e4bYouDgOlzz-EphjftnA.png"/></div></figure><p id="bc4f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如你可能猜到的，带有灯泡图标的按钮将控制黑暗模式的切换。现在不用担心第二个按钮。注意下面的线。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="1b6d" class="lw lx it lr b gy ly lz l ma mb">import { changeMode } from './../actions'</span></pre><p id="a0a9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是从我们的操作中导出的<code class="fe lo lp lq lr b">changeMode</code>函数。该功能添加了灯泡按钮作为<code class="fe lo lp lq lr b">onClick</code>事件。单击按钮，并执行更改模式的操作。简单，不是吗？</p><p id="b334" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果<code class="fe lo lp lq lr b">props.mode</code>为真(意味着黑暗模式被激活)，灯泡按钮的工具提示将显示“白天模式”，如果为假(黑暗模式被关闭)，它将显示“夜晚模式”。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi me"><img src="../Images/675c1c834264a33a276cc3b5e1c5563c.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*w9qRN_ecCF-yWPx4c9FJZQ.png"/></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">在这种情况下，黑暗模式尚未启动，因此出现了白色背景和“夜间模式”工具提示</p></figure><p id="1602" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们已经设置好了React应用程序，让我们来看看CSS。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="3ee1" class="lw lx it lr b gy ly lz l ma mb">.App {  <br/>   text-align: center;  <br/>   height: 100%; <br/>   transition: background-color 0.3s, color 0.3s;<br/>}</span></pre><p id="2d09" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当没有选择黑暗模式时，我们的CSS非常简单。由于白色是默认的背景色，黑色是HTML默认的字体颜色，所以我们不需要在这里指定它们。</p><p id="03c6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们需要指定的只是<code class="fe lo lp lq lr b">App</code>(我们希望它占据整个页面)和<code class="fe lo lp lq lr b">transition</code>的高度和宽度。</p><p id="6352" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过指定背景色和颜色过渡(都是0.3s)，这将确保我们从白天到夜晚模式的过渡是平滑的。否则，它看起来更像是不和谐的闪光，而不是从白天到夜晚的平稳过渡。</p><p id="0b27" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们有了默认的样式，让我们开始讨论黑暗模式CSS。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="f99d" class="lw lx it lr b gy ly lz l ma mb">.night {<br/>  text-align: center;<br/>  height: 100%;<br/>  width: 100%;  <br/>  background-color: black;<br/>  transition: background-color 0.3s, color 0.3s;<br/>}</span></pre><p id="3219" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们声明了<code class="fe lo lp lq lr b">.night</code>类名的样式，并明确声明了背景颜色和颜色，以防止HTML使用默认值。这个还有一个<code class="fe lo lp lq lr b">transition: background-color 0.3s, color 0.3s;</code>这将确保当我们从暗背<strong class="ks iu"> </strong>过渡到亮模式时，过渡将保持平滑。</p><p id="4c31" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您还记得本文前面的内容，我们的<code class="fe lo lp lq lr b">App</code>组件的<code class="fe lo lp lq lr b">className</code>是由<code class="fe lo lp lq lr b">props.mode</code>的值决定的。如果<code class="fe lo lp lq lr b">props.mode</code>为假，则使用<code class="fe lo lp lq lr b">className="App"</code>；否则，使用<code class="fe lo lp lq lr b">className="night"</code>。</p><p id="17cb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上面的CSS满足了我们的<code class="fe lo lp lq lr b">App</code>组件的主题变化，但是为了确保它将必要的样式应用到所有的子元素，我们需要添加几行代码。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="c884" class="lw lx it lr b gy ly lz l ma mb">.night h1, .night h2, .night div, .night textarea{<br/>  background-color: black;<br/>  color: white;<br/>  transition: background-color 0.3s, color 0.3s;<br/>}</span></pre><p id="e89d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将对我们的<code class="fe lo lp lq lr b">App</code>组件中的任何<code class="fe lo lp lq lr b">h1</code>、<code class="fe lo lp lq lr b">h2</code>、<code class="fe lo lp lq lr b">p</code>、<code class="fe lo lp lq lr b">div</code>和<code class="fe lo lp lq lr b">textarea</code>元素应用背景颜色和文本颜色的更改。</p><p id="b817" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些元素包括应用程序的文本编辑器部分(<code class="fe lo lp lq lr b">textarea</code>)和它们的标题(<code class="fe lo lp lq lr b">h2</code>)。<code class="fe lo lp lq lr b">h1</code>是应用程序本身的名称，几乎所有东西都放在它自己的或者父代的<code class="fe lo lp lq lr b">div</code>容器中。</p><p id="2d5e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过将<code class="fe lo lp lq lr b">.night</code>放在所有这些元素的前面，我们可以在更改主题时将这些特定的子标签作为目标。</p><p id="afe5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同样值得注意的是，这里我们使用了一个后代选择器，由<code class="fe lo lp lq lr b">.night</code>和一个HTML标签之间的空格标识。这将选择属于<code class="fe lo lp lq lr b">.night</code>的元素的所有子实例。我们不使用子选择器<code class="fe lo lp lq lr b">&gt;</code>，因为它只会选择元素的直接子元素。我们也不使用<code class="fe lo lp lq lr b">+</code>，相邻兄弟选择器，它只会选择兄弟。关于CSS组合子的更多内容，请查看这篇非常棒的文章。</p><p id="1654" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们差不多完成了，但是还有一些事情需要考虑。首先，有几个元素不想改变颜色或背景色(至少现在不想)，比如海军蓝按钮。无论是暗模式还是亮模式，我都希望它们保持海军蓝和白色图标。为了确保<code class="fe lo lp lq lr b">className</code>开关不会影响这些按钮，我可以添加以下CSS。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="97cb" class="lw lx it lr b gy ly lz l ma mb">.night .buttons{  background-color: navy;}</span></pre><p id="8dcd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过将这一行放到我的<code class="fe lo lp lq lr b">App.css</code>文件中，我可以防止前面提到的CSS改变按钮的样式。以前，我认为这一行必须放在最初的<strong class="ks iu"/>CSS之后，因为CSS在设计上是级联的，并且使用<a class="ae lm" href="https://css-tricks.com/precedence-css-order-css-matters/" rel="noopener ugc nofollow" target="_blank">优先级</a>来确定应用于元素的样式。</p><p id="6679" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">实际上，我把这条线放在哪里并不重要。因为我们使用了一个类选择器来定位按钮，所以不会应用<code class="fe lo lp lq lr b">.night div</code>样式，因为特异性级别低于<code class="fe lo lp lq lr b">.night .buttons</code>。如需了解更多信息，请阅读<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" rel="noopener ugc nofollow" target="_blank">关于特殊性的MDN文档</a>。</p><p id="3695" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上述逻辑也适用于我的最后一个元素，我希望它独立于黑暗模式:我的输出容器。这个部分的类名为<code class="fe lo lp lq lr b">.view</code>，是用户代码(由上面的三个部分组合而成)将要运行的地方，由于输出区域应该只反映用户编写的代码，我们应该确保默认样式得到执行，除非用户在CSS部分键入新的样式。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="84c4" class="lw lx it lr b gy ly lz l ma mb">.night .view {  background-color: white;}</span></pre><p id="fd14" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">输出的其余部分将被插入到一个<code class="fe lo lp lq lr b">iframe</code>中，它是<code class="fe lo lp lq lr b">.view</code>的子节点。这意味着用户的风格将完全独立于我的应用程序的风格。只需要保留输出容器的背景色。</p><p id="07a8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://medium.com/@adamlyth" rel="noopener"> Adam Lyth </a>指出，虽然上述内容适用于react应用程序，但原生应用程序需要更多的CSS。要实现这一点，您可以在这个媒体查询中使用wrap样式。</p><pre class="ki kj kk kl gt ls lr lt lu aw lv bi"><span id="f36a" class="lw lx it lr b gy ly lz l ma mb">@media (prefers-color-scheme: dark) {<br/>      /*YOUR DARK STYLE HERE*/<br/>}</span></pre><p id="6799" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是我们的最终结果。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/2ae5a2f90f0c7e4e09ea4d1953374655.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*c-Ql-O6ajktoCGBcHjMMfQ.gif"/></div></figure><p id="8552" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这就是了。只需几行额外的CSS和一点点道具逻辑，你的React应用程序就可以高效地实现黑暗模式。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="6a6c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://matt-croak.medium.com/membership" rel="noopener"> <em class="ln">在此处将您的免费媒体会员升级为付费会员</em> </a> <em class="ln">，每月只需5美元，您就可以收到各种出版物上数千名作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="7fc4" class="mr lx it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">参考</h1><div class="ni nj gp gr nk nl"><a href="https://observer.com/2019/03/dark-mode-app-trend-psychological-effects/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">黑暗模式的阴暗面:最新的应用趋势是否正在耗尽我们屏幕上的生命？</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">应用程序和软件设计有一个新趋势，叫做黑暗模式。如果你还没看过，基本的转折是它…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">observer.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ko nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://redux.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">为JS应用程序还原一个可预测的状态容器</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">JS应用程序的可预测状态容器</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">JS Appsredux.js.org的可预测状态容器</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz ko nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://medium.com/better-programming/understanding-css-combinators-a36e013b1bed" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">理解CSS组合子</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">如何使用它们，为什么</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz ko nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://css-tricks.com/precedence-css-order-css-matters/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">CSS中的优先级(当CSS的顺序很重要时)</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">在你写CSS的普通日子里，你可能甚至不会考虑CSS中的优先级。它没有出现整个赫克…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">css-tricks.com</p></div></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">特征</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">特异性是浏览器决定哪些CSS属性值与某个元素和……最相关的手段</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">developer.mozilla.org</p></div></div><div class="nu l"><div class="oc l nw nx ny nu nz ko nl"/></div></div></a></div></div></div>    
</body>
</html>