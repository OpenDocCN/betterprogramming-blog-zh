<html>
<head>
<title>Role Based Authorization in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中基于角色的授权</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/role-based-authorization-in-react-c70bb7641db4?source=collection_archive---------1-----------------------#2017-01-20">https://betterprogramming.pub/role-based-authorization-in-react-c70bb7641db4?source=collection_archive---------1-----------------------#2017-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d0583278930e30969f6e950599910658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*du_jHWvWDSCaAVxlMhfwYA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jeshoots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kf" href="https://unsplash.com/search/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5bc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">身份验证和授权都是编写应用程序时常见的问题。认证回答“你是谁？”，而授权则回答了这个问题，“你被允许看那个吗？”</p><p id="dfb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近有人问如何使用<a class="ae kf" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和React Router来完成基于角色的授权，并链接到<a class="ae kf" href="http://frontendinsights.com/role-based-authorization-using-react-router/" rel="noopener ugc nofollow" target="_blank">一个帖子</a>描述了一种实现方法。本质上，这篇文章建议简单地传递一个允许查看给定路由的角色列表，并检查当前登录的用户是否是路由处理程序中的角色之一。</p><p id="e4b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那会有用，但是我看到它有一些问题。</p><ul class=""><li id="a0d8" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">违反单一责任原则。</li><li id="c5f9" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">不必要地通过React路由器传递数据。</li><li id="aecd" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">没有可重用的代码。</li></ul><p id="dc09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，我们如何应用授权，让每个组件只做一项工作，是自包含的，并且是可重用的呢？</p><p id="513d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以改进上述博客代码的一个方法是将授权逻辑封装在它自己的组件中——用一个<a class="ae kf" href="https://discuss.reactjs.org/t/children-as-a-function-render-callbacks/626" rel="noopener ugc nofollow" target="_blank">子功能</a>来防止组件在用户未被授权的情况下被挂载——并从您的路由处理程序中呈现出来。</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="16de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这为我们提供了可重用的授权逻辑，这是朝着正确方向迈出的一步。我们甚至可以让授权组件加载用户本身，因此它所需要的只是允许的角色。但是每个路由仍然“拥有”授权正在发生的事实，这感觉不太对。</p><p id="ade5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是还有另一个选择。一个<a class="ae kf" href="https://facebook.github.io/react/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>——通常缩写为HOC——可以将授权逻辑完全移出路由处理器。假设授权特设自行加载当前登录的用户，它可能如下所示:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="663b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我几乎没有包括authorization HOC的实现，因为它取决于您使用什么来存储您的数据，您是否希望显示错误消息或在失败时重定向到其他地方，您使用的是哪个路由器，等等。有很多未知，我想把重点放在模式而不是实现细节上。重要的是，它检查当前登录的用户，并呈现包装的组件，因为他们有足够的角色。</p><p id="0621" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<em class="ly">何时应用HOC并不重要，所以我们可以将该函数调用移到路由器配置中。</em></p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="bb2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新:已经有人指出，在render中将一个组件封装在一个HOC中会导致很多问题，作为一条规则，不应该这样做。在任何情况下，替换<code class="fe lz ma mb mc b">component={}</code>内的内联函数调用都应该替换为将其分配给render方法之外的变量。</p><pre class="ls lt lu lv gt md mc me mf aw mg bi"><span id="b36b" class="mh mi it mc b gy mj mk l ml mm">const RouteWithAuthorization = Authorization(YourRoute, ['roles'])</span></pre><p id="b89a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要进一步了解为什么这是个坏主意，请查看<a class="ae kf" href="https://reactjs.org/docs/higher-order-components.html#dont-use-hocs-inside-the-render-method" rel="noopener ugc nofollow" target="_blank"> React文档</a>。回到原帖。</p><p id="ead3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！现在，在我们的路由处理程序中有一个授权逻辑的提示，没有任何东西通过React Router传递，我们所有允许的角色都定义在一个文件中。但是你知道吗，如果我们有很多路由，那将意味着很多重复的角色定义。</p><p id="6cab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们做两个改变——颠倒我们给HOC的参数的顺序，并“<a class="ae kf" href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch4.html" rel="noopener ugc nofollow" target="_blank"> curry </a>”这个函数。我们的特设成为一个函数，返回特设。如果您使用Redux，这种类型的函数调用应该看起来很熟悉，因为它与<code class="fe lz ma mb mc b">connect</code>使用的机制相同。</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c229" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以用不同级别的允许角色“播种”我们的授权特设，消除了一次又一次定义允许角色的需要。</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="bf43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，这样好多了。现在，我们可以预先定义一定数量的角色，我们可以有这样的路由器配置:</p><figure class="ls lt lu lv gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="611d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户可以看到所有人，经理可以编辑用户，管理员可以添加新用户。通过查看用法可以清楚地看出意图是什么，并且代码的每个部分都有一个单独的职责。</p><p id="b32f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编辑:重申上面的话，在render <a class="ae kf" href="https://reactjs.org/docs/higher-order-components.html#dont-use-hocs-inside-the-render-method" rel="noopener ugc nofollow" target="_blank">中创建高阶组件会导致React如何计算差异</a>的问题。在上面的最后一个例子中，<code class="fe lz ma mb mc b">User(User)</code>、<code class="fe lz ma mb mc b">Manager(EditUser)</code>和<code class="fe lz ma mb mc b">Admin(CreateUser)</code>部分应该从render方法中提取出来并分配给变量。</p><p id="8052" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，客户端授权只是其中的一部分。后端也应该总是执行用户角色，因为客户机上的所有数据都可以从devtools中更改。</p><p id="61dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是最佳实践，这是一个我认为可以解决人们在现实世界中面临的问题的想法。我把这个作为博文而不是库来发表，因为每个人的用例都不一样。</p><p id="1560" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许在您的应用程序中，authorization HOC将当前角色作为道具传递给它所包装的组件。也许其中一个约定俗成的参数是授权失败时要呈现的组件。可能不是一个更高级的组件，而是一个具有function子组件的组件，它获取角色和授权是否成功作为参数。也许您传递的不是一组允许的角色，而是一个带有签名<code class="fe lz ma mb mc b">user =&gt; bool</code>的函数。</p><p id="fb98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，React有许多习惯用法，一旦你熟悉了它们，你就能写出真正有表现力的、简洁的代码。高阶组件、子函数和(基本)currying是代码非常简单的概念:它们中的每一个都只需要几行代码，但是一旦你弄清楚它们解决的是什么类型的问题，你就可以将它们组合起来，使它们变得非常强大。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="4ee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读！我在Twitter上的名字是<a class="ae kf" href="https://mobile.twitter.com/vcarl_" rel="noopener ugc nofollow" target="_blank"> @vcarl_ </a>(但在其他大多数地方我都是vcarl)。我主持了React开发者聊天室<a class="ae kf" href="http://join.reactiflux.com/" rel="noopener ugc nofollow" target="_blank">React flux</a>和节点聊天室<a class="ae kf" href="https://discordapp.com/invite/vUsrbjd" rel="noopener ugc nofollow" target="_blank"> Nodeiflux </a>。JS开发者。如果您有任何问题或建议，请联系我们！</p></div></div>    
</body>
</html>