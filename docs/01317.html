<html>
<head>
<title>RxJS: Error Handling With forkJoin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS:用forkJoin处理错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjs-error-handling-with-forkjoin-3d4027df70fc?source=collection_archive---------0-----------------------#2019-09-01">https://betterprogramming.pub/rxjs-error-handling-with-forkjoin-3d4027df70fc?source=collection_archive---------0-----------------------#2019-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a51b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">组合静态方法的错误处理，如forkJoin、concat和zip</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9f4737311a143fcf3c0340b4e616ceb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emZVDTbl5L_ZnXh95z51LQ.png"/></div></div></figure><p id="615f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你是Angular开发者，你已经熟悉了<a class="ae ln" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>，或者，至少，你知道，在与<code class="fe lo lp lq lr b">HttpClient</code>的服务通话之后，你应该订阅。</p><p id="4d52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果对反应式扩展有更深入的了解，您总是可以获得更多。</p><p id="cc12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有一些操作符，如果使用正确，可以使事情变得更容易，这不同于只知道如何订阅。这正是RxJS不得不<a class="ae ln" href="https://rxjs-dev.firebaseapp.com/guide/operators" rel="noopener ugc nofollow" target="_blank">对运营商</a>说的话:</p><blockquote class="ls"><p id="60e3" class="lt lu iq bd lv lw lx ly lz ma mb lm dk translated">" RxJS主要是对它的操作者有用，尽管可观测性是基础."</p></blockquote><p id="181e" class="pw-post-body-paragraph kr ks iq kt b ku mc jr kw kx md ju kz la me lc ld le mf lg lh li mg lk ll lm ij bi translated">有时，当处理可观测量时，你最终不得不将它们结合起来。RxJS为您提供了组合操作符和静态方法，帮助您处理这些情况，但是生活并不是一片美好。</p><p id="f231" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们组合多个可观察对象时，试图处理错误就成了一个真正的问题，RxJS方法通常不会如你所愿。</p><p id="f4f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看一个例子，以及我写这篇文章的主要原因。</p><pre class="kg kh ki kj gt mh lr mi mj aw mk bi"><span id="0bac" class="ml mm iq lr b gy mn mo l mp mq">const todo1$ = this.myService.getTodo(1);<br/>const error$ = this.myService.getTodo(201);<br/>const todo2$ = this.myService.getTodo(2);</span><span id="f3b1" class="ml mm iq lr b gy mr mo l mp mq">forkJoin([todo1$, error$, todo2$])<br/>  .subscribe(<br/>    next =&gt; console.log(next),<br/>    error =&gt; console.log(error)<br/>  );</span></pre><p id="0880" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的示例代码中，我使用一个服务来存储对<a class="ae ln" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>的open API的<code class="fe lo lp lq lr b">GET</code>调用，每个调用都应该通过其<code class="fe lo lp lq lr b">id</code>返回一个<code class="fe lo lp lq lr b">todo</code>的可观察对象。</p><p id="341c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我使用<code class="fe lo lp lq lr b">forkJoin</code>合并这些观察值，它并行执行这些调用。</p><p id="f0d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有些人可能会说，如果您需要合并请求，那么您这样做是错误的，或者您的后端是错误的。</p><p id="7dfc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，您在前端处理的数据可能实际上来自数据库中的两个不同集合，或者您可能需要对表单中的每个修改对象执行请求，删除所有操作，等等。</p><p id="844c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">forkJoin</code>将订阅传递的观察值，因此发出<code class="fe lo lp lq lr b">HTTP GET</code>请求。</p><p id="4a9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据JSONPlaceholder网站的信息，他们有200个待办事项，所以我特意设置了一个<code class="fe lo lp lq lr b">error$</code>变量，用<code class="fe lo lp lq lr b">201</code>作为<code class="fe lo lp lq lr b">id</code>来调用<code class="fe lo lp lq lr b">todo</code>。</p><p id="25a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将返回一个错误，但是当我订阅时，我将如何接收信息呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/95e47fbb4bad3ac1edcd93e88d26c279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crILPmRgZkFpCraNOdTVfg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">由forkJoin的错误记录到控制台</p></figure><p id="e5ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">检查控制台，我们只看到一条错误消息，由来自subscribe的<code class="fe lo lp lq lr b">onError</code>回调捕获并记录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3864e06e228004365f672fcc06651fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*dDt_9alBoUqGskx7ztcWPw.png"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">Chrome DevTools网络标签</p></figure><p id="583a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是等等……如果我们检查一下DevTools中的network选项卡，我们会看到所有三个<code class="fe lo lp lq lr b">GET</code>都被调用了。<code class="fe lo lp lq lr b">todo1$</code>和<code class="fe lo lp lq lr b">todo2$</code>成功返回，那么他们在哪里？</p><p id="9374" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据<a class="ae ln" href="https://rxjs-dev.firebaseapp.com/api/index/function/forkJoin" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a>，原来<code class="fe lo lp lq lr b">forkJoin</code>是这样工作的:</p><blockquote class="ls"><p id="80a7" class="lt lu iq bd lv lw lx ly lz ma mb lm dk translated">如果在某个时间点出现任何输入可观察到的错误，forkJoin也会出错，并且所有其他可观察到的错误都会立即取消订阅</p></blockquote><p id="7a29" class="pw-post-body-paragraph kr ks iq kt b ku mc jr kw kx md ju kz la me lc ld le mf lg lh li mg lk ll lm ij bi translated">所以，你只是丢失了从<code class="fe lo lp lq lr b">todo1$</code>和<code class="fe lo lp lq lr b">todo2$</code>取回的信息。</p><p id="6b14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，如果你是一个Angular开发者，这次使用的是<a class="ae ln" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>，也许你已经担心<em class="my">不会让你的可观察对象死去。</em></p><p id="5937" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为，当在一个<code class="fe lo lp lq lr b">Effect</code>内部管道化时，如果你没有正确处理一个错误，如果你再次调度它处理的动作，你的<code class="fe lo lp lq lr b">Effect</code>可能会死亡并且不能被执行。</p><p id="ada8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，这里的关键是单独处理错误，就像对每个可观察到的。</p><p id="2f36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用<code class="fe lo lp lq lr b">catchError</code>操作符管道化这个可观察值将处理错误，并将其映射到另一个值。您可以找到符合您需求的最佳方式，但这里有一些示例:</p><pre class="kg kh ki kj gt mh lr mi mj aw mk bi"><span id="a026" class="ml mm iq lr b gy mn mo l mp mq">const error$ = this.myService.getTodo(201)<br/>  .pipe(<br/>    catchError(err =&gt; of(err.status)),<br/>  );</span><span id="c2be" class="ml mm iq lr b gy mr mo l mp mq">...</span><span id="f84c" class="ml mm iq lr b gy mr mo l mp mq">const error$ = this.myService.getTodo(201)<br/>  .pipe(<br/>    catchError(err =&gt; of({isError: true, error: err})),<br/>  );</span><span id="775a" class="ml mm iq lr b gy mr mo l mp mq">...</span><span id="14f2" class="ml mm iq lr b gy mr mo l mp mq">const error$ = this.myService.getTodo(201)<br/>  .pipe(<br/>    catchError(err =&gt; of(undefined)),<br/>  );</span></pre><p id="31ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，一旦<code class="fe lo lp lq lr b">error$</code>抛出一个错误，它将被内部处理，一个新的值将被返回给外部的可观察对象。您可以将错误映射到所示的任何其他值，如状态代码、未定义、全新的对象等。</p><p id="376b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们检查控制台，它将显示一个数组，包含两个<code class="fe lo lp lq lr b">todo</code>对象和一个<code class="fe lo lp lq lr b">string</code>，来自<code class="fe lo lp lq lr b">error$</code>的状态代码。</p><p id="02d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这一切都由<code class="fe lo lp lq lr b">forkJoin.subscribe(next =&gt; {})</code>处理，因为<code class="fe lo lp lq lr b">forkJoin</code>不知道有错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/e4ad0459d821a635af7070890215217e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWI3B2o1Y2Gq936IfzxQ-A.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">通过forkJoin的onNext登录到控制台</p></figure><p id="6b74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样的方法可以用于<code class="fe lo lp lq lr b">concat</code>。根据其<a class="ae ln" href="https://rxjs-dev.firebaseapp.com/api/index/function/concat" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="na nb nc"><p id="e605" class="kr ks my kt b ku kv jr kw kx ky ju kz nd lb lc ld ne lf lg lh nf lj lk ll lm ij bi translated">创建一个输出可观察对象，该输出可观察对象依次发出给定可观察对象的所有值，然后继续下一个。</p><p id="6175" class="kr ks my kt b ku kv jr kw kx ky ju kz nd lb lc ld ne lf lg lh nf lj lk ll lm ij bi translated">如果链中的任何可观察对象出错，concat也将立即出错，而不是将控制权传递给下一个可观察对象。在发出错误的观察对象之后订阅的观察对象永远不会被订阅。"</p></blockquote><pre class="kg kh ki kj gt mh lr mi mj aw mk bi"><span id="3a21" class="ml mm iq lr b gy mn mo l mp mq">concat([todo1$, error$, todo2$])<br/>  .subscribe(<br/>    next =&gt; console.log(next),<br/>    error =&gt; console.log(error)<br/>  );</span></pre><p id="350a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们不应用我们的可观察的死亡预防，<code class="fe lo lp lq lr b">concat</code>将发送<code class="fe lo lp lq lr b">todo1$</code>的值，然后发送错误，不订阅<code class="fe lo lp lq lr b">todo2$</code>。</p><p id="fc5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们在内部处理<code class="fe lo lp lq lr b">error$</code>错误，那就是我们返回的值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/77520f2eceb7bd423f2f0ade1e387bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxv6Z1jHwitQOxxWN75tOg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">通过concat的onNext登录到控制台</p></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="47e5" class="no mm iq bd np nq nr ns nt nu nv nw nx jw ny jx nz jz oa ka ob kc oc kd od oe bi translated"><strong class="ak"> <em class="of">结论</em> </strong></h1><p id="7a06" class="pw-post-body-paragraph kr ks iq kt b ku og jr kw kx oh ju kz la oi lc ld le oj lg lh li ok lk ll lm ij bi translated">嗯，这里的关键是，如前所述，<em class="my">不要让你的可观察对象死去</em>。</p><p id="fb6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">外部可观察对象不需要知道内部可观察对象抛出了一个错误，您可以返回重要的数据来找出哪个失败了。</p><p id="9481" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这适用于其他情况，不仅是服务调用，还有其他组合方法甚至运算符。使用管道时，你可能会得到一个更高阶的可观测值，而不处理它的误差可能会导致真正的头痛。</p><p id="a7c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这有所帮助。</p></div></div>    
</body>
</html>