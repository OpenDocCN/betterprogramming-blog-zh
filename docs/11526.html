<html>
<head>
<title>How to Write Useful Tests for Angular Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为角度组件编写有用的测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-reach-100-test-coverage-without-testing-anything-64d07d226bff?source=collection_archive---------8-----------------------#2022-03-28">https://betterprogramming.pub/how-to-reach-100-test-coverage-without-testing-anything-64d07d226bff?source=collection_archive---------8-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9d95" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松实现几乎100%的代码覆盖率</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/76cefc268710a630772fe8a3dc7c2154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_5eWMxlfjrU1efxG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="6dcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在不同的项目中用不同的语言和不同的框架进行了多年的开发之后，我以为我什么都见过了。但在我们的行业中，唯一自然不变的是，你一直面临着你从未见过的东西。我最近的一个项目仍然打动着我，我想和你分享我的想法。这是关于我们为角度应用程序编写组件测试的方式。</p><p id="8304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所知，您可以使用angular cli生成新组件，angular cli会在组件旁边为我们生成一个规格文件。如果仔细查看，您会发现有一个<code class="fe ls lt lu lv b">TestBed</code>用于为组件创建一个测试工具。但是如果我们比较不同的编写组件测试的方法，我们会发现有一种非常简单的方法叫做组件类测试(<a class="ae kv" href="https://angular.io/guide/testing-components-basics" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/testing-components-basics</a>)。https://angular.io/guide/testing-components-scenarios中描述了一个更加详细的测试策略。如果我看一下这两种情况下的文档数量，我会觉得有点像丹尼尔·卡内曼的“快速和慢速思维”。但是今天属于慢思考的范畴，明天可能会是快思考。这是一个练习和动机的问题。</p><p id="f11e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">够哲学化了。让我们来看看一些代码。假设我们想要编写一个自定义表单控件，它的行为应该像一个非常基本的选择框(为了本文的目的而简化)。有用户可以选择的选项，选择的值应该反映在<code class="fe ls lt lu lv b">FormControl</code>中。下面是实现所需的<code class="fe ls lt lu lv b">ControlValueAccessor</code>的组件类型脚本代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="95da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是相应的html模板</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="983d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们想测试我们的代码，以便达到100%的测试覆盖率。以下是完整的规范文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8ac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是测试覆盖报告的结果:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="84eb" class="mc md iq lv b gy me mf l mg mh">Statements   : 100% ( 32/32 )<br/>Branches     : 100% ( 2/2 )<br/>Functions    : 100% ( 14/14 )<br/>Lines        : 100% ( 29/29 )</span></pre><p id="5488" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！我们有100%的代码覆盖率。每一行，每一个函数的每一个分支。这怎么可能这么容易达成？</p><ul class=""><li id="be19" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">首先，你可能注意到使用了组件类测试方法。组件构造函数被直接调用。唯一的参数应该是一个<code class="fe ls lt lu lv b">NgControl</code>实例。因为我们没有这样一个对象，我们只是提供了一个模拟。</li><li id="0798" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">模板被完全忽略。</li><li id="19ea" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">组件中有许多私有的函数和属性。为了避免编译器错误，组件必须被转换成<code class="fe ls lt lu lv b">any</code>，这样我们就可以在编译期间访问这些函数和属性。</li><li id="4a89" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">每一个被调用的函数都用一个spy来测试——例如，测试检查函数是否被调用。</li><li id="05b2" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">不要在意你是否正在调用框架应该调用的函数(例如<code class="fe ls lt lu lv b">registerOnTouch</code>)——记住我们想要达到100%的测试覆盖率。</li></ul><p id="28e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试的实现非常简单:从顶部开始，为每个函数创建一个测试，并通过一个间谍检查被调用的方法是否存在于被测试的函数中。为了模拟真实的测试，只需检查函数中被改变的一些属性。如果函数或属性是私有的——不要在意——只需将您的组件转换为<code class="fe ls lt lu lv b">any</code>,您就可以做任何事情。它会编译。在运行时，私有不存在。</p><p id="e104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你对此有意见吗？不客气——我也是。</p><h1 id="9b92" class="mw md iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">这里到底发生了什么？</h1><p id="815e" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">测试是测试组件实现的方式，而不是期望的行为。让我们检查一下，如果我们在实现级别更改某些东西，会发生什么情况:</p><ul class=""><li id="3589" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">如果模板代码被改变，测试仍然通过。最后，可以删除完整的模板代码，测试将会通过——因为它不是测试的一部分。所以每一个改变都可能破坏组件行为。</li><li id="317f" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">如果有人删除了构造函数中的行(<code class="fe ls lt lu lv b">ngControl.valueAccessor = this;</code>)。该组件不再可用作控件。但是测试还是通过了。</li><li id="b44f" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">如果从代码中删除了<code class="fe ls lt lu lv b">updateSelection</code>函数，并使用了一个设置器来确保<code class="fe ls lt lu lv b">selectedOption</code>和<code class="fe ls lt lu lv b">viewModel</code>同步，测试将不会通过。这不会改变组件的行为，但会改变实现。(4测试因运行时错误而失败)</li><li id="3453" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">如果<code class="fe ls lt lu lv b">optionClicked</code>函数的实现被改变，并且确保每次调用<code class="fe ls lt lu lv b">onChange</code>时输出<code class="fe ls lt lu lv b">selectionChanged</code>发出值，测试将不会通过。同样，这不会改变行为，但会改变组件的实现方式。(2测试失败，因为回调函数不再是在<code class="fe ls lt lu lv b">registerOnChange</code>函数中传递的函数，并且<code class="fe ls lt lu lv b">emit</code>不再被调用，因为对<code class="fe ls lt lu lv b">onChange</code>函数的窥探)</li><li id="1733" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">如果<code class="fe ls lt lu lv b">onChange</code>功能的名称被更改，测试将会中断。IDE也不能确保函数在测试中被重命名，因为存在到<code class="fe ls lt lu lv b">any</code>的强制转换。(3个测试因运行时错误而失败)</li></ul><p id="aec6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想自己试验一下，找到新的方法在不改变行为的情况下破坏测试:下面是代码<a class="ae kv" href="https://github.com/mseemann/testing-with-100-percent-testcoverage" rel="noopener ugc nofollow" target="_blank">https://github . com/mseemann/testing-with-100-percent-test coverage</a>。</p><p id="3993" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么这个问题的原因是什么呢？测试被绑定到实现。如果您想要或者需要更改实现，您的测试将会中断。现在你必须调整你的测试。但结果是这些测试完全没有用——它们不能阻止我们打破想要的行为。这种类型的测试确实确保了在不改变或修复测试代码的情况下，实现不会被改变。更糟糕的是:由于对<code class="fe ls lt lu lv b">any</code>的过度使用，编译器无能为力，测试将因运行时错误而失败。如果熟悉角形控制api，这在本例中可能很容易。但是如果事情更复杂，你必须付出巨大的努力来修复这些错误。</p><p id="900a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们说清楚:</p><p id="f26c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ns">期望的行为是我们代码的不变量——实现不是。有价值的测试是测试不变量。绝对没有理由做相反的事情。</em></p><h1 id="67be" class="mw md iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">我们怎样才能做得更好？</h1><p id="27a8" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">如果您不想编写与模板交互的测试。那么就根本不要编写任何组件测试。只需将组件代码中的业务逻辑提取到纯函数中。并测试这些功能。但是不要写测试来确保你的实现不被改变。<em class="ns">这是没有用的，会导致维护成本成倍增加</em>。</p><p id="b768" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写测试行为而不是实现的测试。这需要您与组件的输入和输出进行交互。组件的输入和输出是什么？当然，这些是<code class="fe ls lt lu lv b">@Input</code>和<code class="fe ls lt lu lv b">@Output</code>属性和事件。但事实上，真正的输入和输出是你的模板中呈现的内容，以及用户可以用你的模板做什么。</p><p id="9c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个如何测试组件行为的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6a94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只是为了强调几件事:</p><ul class=""><li id="76f2" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">一个特殊的<code class="fe ls lt lu lv b">TestComponent</code>用于与被测组件交互。这也是一个很好的文档，因为组件的用户可以看到应该如何使用组件。</li><li id="4845" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">测试用例的数量只有5个而不是10个。</li><li id="935e" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">每个测试都检查组件的预期行为，而不是实现。</li><li id="1b60" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">模板被渲染——模板中的突破性变化会破坏测试。</li><li id="b890" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">完整代码中绝对没有<code class="fe ls lt lu lv b">any</code>关键字与被测组件交互(实际上angular test API中有一些隐藏类型)。</li></ul><p id="0d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看报道:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="613a" class="mc md iq lv b gy me mf l mg mh">Statements   : 100% ( 30/30 )<br/>Branches     : 100% ( 2/2 )<br/>Functions    : 84.61% ( 11/13 )<br/>Lines        : 100% ( 27/27 )</span></pre><p id="01b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几乎和以前一样。我没有包括无用的测试<code class="fe ls lt lu lv b">(component as any).onTouched()</code>。这段代码只是为了确保<code class="fe ls lt lu lv b">onTouched</code>成员永远不会为空或未定义。这样我就可以避免在每次需要调用时检查<code class="fe ls lt lu lv b">onTouched</code>成员是否被设置。这是覆盖率报告中缺失的两个功能——谁在乎呢。</p><p id="b0da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对了！我上面列出的每一个改变都可以在不破坏测试的情况下进行，因为组件的行为没有改变。这个版本在github也有:<a class="ae kv" href="https://github.com/mseemann/testing-with-100-percent-testcoverage/tree/not-100-percent-but-valuable-test" rel="noopener ugc nofollow" target="_blank">https://github . com/mseemann/testing-with-100-percent-test coverage/tree/not-100-percent-but-valued-test</a>。</p><h1 id="9a7d" class="mw md iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">我们能做得更好吗？</h1><p id="a614" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">是的，肯定的。</p><ul class=""><li id="eeed" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">可以引入一个<code class="fe ls lt lu lv b">option</code>组件，之后，测试中的一些css查询也可以删除。之后，有人可以改变组件的风格，而不会潜在地破坏测试。</li><li id="8e7e" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">页面对象模式可以用来避免冗余的代码片段——因此测试甚至可以变得更加干涩和不那么脆弱。</li><li id="6a95" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">我们可以为我们的组件提供测试工具。你可以看看这篇关于如何使用它们的文章。</li><li id="7d0d" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">如果你关心性能。从karma切换到jest是可能的——<code class="fe ls lt lu lv b">jsdom</code>可能比浏览器中的真实dom快一点，测试可以并行运行。如果你想更进一步，你可以切换到<code class="fe ls lt lu lv b">nrwl</code> <code class="fe ls lt lu lv b">nx</code>，只运行受代码变更影响的测试。</li></ul><h1 id="89a4" class="mw md iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">结论</h1><p id="421b" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我承认——我也沉迷于绿色徽章。但正如你所看到的，获得绿卡的方式可能会非常不同。将来，在我再次编写测试用例以达到100%的代码覆盖率之前，我会三思而行。如果我怀疑测试是否真的在测试行为，我最好在开始测试实现之前省略代码。</p><p id="fc23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，编写正确的测试需要更多的努力，但是只有在那个时候，代码才被首先创建。在每一个需要的改变上，你将从这种努力中获得巨大的回报，并且你的测试是有价值的，因为它们测试了期望的行为。</p><p id="937d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一句，如果在实现完成之前编写测试，这整个问题就不会出现——这是我需要考虑的一个方面。</p></div></div>    
</body>
</html>