<html>
<head>
<title>5 Optimization Tips for Better Python Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Python性能的5个优化技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-optimization-tips-for-better-python-performance-f1f9b1d63c13?source=collection_archive---------5-----------------------#2022-12-14">https://betterprogramming.pub/5-optimization-tips-for-better-python-performance-f1f9b1d63c13?source=collection_archive---------5-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ce3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将代码的效率提升到一个新的水平</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5e8589d894da389f6d6790454bd6353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SU7AN0WYRsCSXijtl-MtA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">戴勒</p></figure><p id="5404" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python作为一种编程语言在最近十年变得很出名。这是一个优秀的工具，不仅有助于后端开发，也有助于数据科学和自动化。</p><p id="462d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种简单的语言允许任何人开始学习。Python有一个简单明了的语法，这对构建软件很有帮助。</p><p id="cac4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，这里有很多陷阱，低效的代码会显著降低性能。</p><p id="37ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好消息是可以避免这些问题。Python提供了一些关于如何提高代码速度的建议。那些是什么？我们来探索一下。</p><h1 id="6961" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">采用内置函数</h1><p id="bcc5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Python开发人员试图在最常见的操作上表现最佳。他们已经实现了覆盖这些操作的函数。例如，我们有<code class="fe mr ms mt mu b">min()</code>、<code class="fe mr ms mt mu b">max()</code>、<code class="fe mr ms mt mu b">sum()</code>和许多更方便的功能。</p><p id="a403" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它们是内置的，无需任何额外的导入即可使用。它们表现出良好的性能。</p><p id="7a4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，每次需要对数组中的所有元素求和时，考虑使用内置函数<code class="fe mr ms mt mu b">sum()</code>而不是实现自己的算法。</p><h1 id="7801" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">利用集合进行高效搜索</h1><p id="02c9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">集合是另一种经常被遗忘的数据结构。软件工程师积极使用列表和字典，但很少使用集合。</p><p id="abad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在寻找集合中的独特元素或快速检查包含性时，set表现出了极高的性能。</p><pre class="kj kk kl km gt mv mu mw bn mx my bi"><span id="d397" class="mz lv it mu b be na nb l nc nd">collection = [x for x in range(100_000)]<br/>exists = 1000 in collection<br/>&gt;&gt; Duration: 0.000015020<br/><br/>collection = set(x for x in range(100_000))<br/>exists = 1000 in collection<br/>&gt;&gt; Duration: 0.000001907</span></pre><p id="86fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们看到检查一个元素在集合中的存在比在列表中快7倍。</p><h1 id="c169" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">使用枚举而不是范围来访问索引</h1><p id="d529" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果需要遍历集合并建立索引，最好的方法是使用<code class="fe mr ms mt mu b">enumerate</code>。</p><p id="60de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该选项比循环通过<code class="fe mr ms mt mu b">range</code>更快。此外，我们不需要通过索引来访问条目，因为<code class="fe mr ms mt mu b">enumerate</code>为我们做了这些。</p><pre class="kj kk kl km gt mv mu mw bn mx my bi"><span id="7bb6" class="mz lv it mu b be na nb l nc nd">collection = range(0, 1_000_000)<br/>for i in range(len(collection)):<br/>  print(collection[i])<br/>&gt;&gt; Duration: 0.114128828<br/><br/>collection = range(0, 1_000_000)<br/>for i, number in enumerate(collection):<br/>  print(number)<br/>&gt;&gt; Duration: 0.062491894</span></pre><p id="f93b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到，在这个例子中，使用<code class="fe mr ms mt mu b">enumerate</code>的情况比使用<code class="fe mr ms mt mu b">range</code>的情况几乎快两倍。这是因为<code class="fe mr ms mt mu b">enumerate</code>内部生成了一个特殊的枚举对象。它在一次运行中有效地返回项目和索引。</p><h1 id="d408" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">应用列表理解来创建列表</h1><p id="6bf7" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">列表理解是Python中一个广泛使用的特性。遍历列表和转换元素只能在一行中完成。</p><p id="25ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是额外的一点是它有不错的性能。我们来对比一下常规的<code class="fe mr ms mt mu b">for</code>循环。</p><pre class="kj kk kl km gt mv mu mw bn mx my bi"><span id="eb99" class="mz lv it mu b be na nb l nc nd">collection = range(0, 1_000_000)<br/>newlist = []<br/>for item in collection:<br/>    newlist.append(item)<br/>&gt;&gt; Duration: 0.065476894<br/><br/>collection = range(0, 1_000_000)<br/>newlist = [item for item in collection]<br/>&gt;&gt; Duration: 0.024003267</span></pre><p id="7c0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子证明了列表理解速度快了三倍。</p><p id="77ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">初学者通常会纠结于这个特性的语法，尤其是当有几个嵌套层的时候。但是一旦他们掌握了它，他们就会到处应用它。</p><h1 id="6475" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">使用Join代替“+”来连接字符串</h1><p id="f87f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当我们考虑字符串连接时，首先想到的是操作符<code class="fe mr ms mt mu b">+</code>。因为直观。当第一弦是<code class="fe mr ms mt mu b">'hello,'</code>第二弦是<code class="fe mr ms mt mu b">'world'</code>时。要组合它们，我们需要编写<code class="fe mr ms mt mu b">'hello,' + 'world'</code>。</p><p id="260c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">字符串连接方式问题是性能。在每一次<code class="fe mr ms mt mu b">+</code>操作中，都会创建一个新的字符串。以这种方式组合两个字符串没什么大不了的。但是当涉及到更大数量的字符串时，您会看到性能下降。</p><p id="8333" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">连接字符串的有效方法是使用<code class="fe mr ms mt mu b">join()</code>函数。</p><pre class="kj kk kl km gt mv mu mw bn mx my bi"><span id="662f" class="mz lv it mu b be na nb l nc nd">strings = ["Python", "is", "amazing", "when", "you", "follow", "pro", "tips", "and", "advice"]<br/>string_concat = ""<br/>for s in strings:<br/>    string_concat += s<br/>&gt;&gt; Duration: 0.000010014<br/><br/>strings = ["Python", "is", "amazing", "when", "you", "follow", "pro", "tips", "and", "advice"]<br/>string_concat = "".join(strings)<br/>&gt;&gt; Duration: 0.000002861</span></pre><p id="486b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种性能已经在少数琴弦上显现出来。但是随着要连接的字符串数量的增加，这种差异会变得更大。</p><h1 id="b5cd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="d9ac" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">可以提高Python代码性能的列表还会增加。有些建议可能只属于特定的场景。</p><p id="67c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在本文中介绍的技巧被认为是Python中的最佳实践。您可能不会注意到小数据集上的任何差异。但是，当您需要处理的数据量足够大时，您会看到显著的性能提升。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt mv mu mw bn mx my bi"><span id="0c0e" class="mz lv it mu b be na nb l nl nd"><strong class="mu iu">Want to become a better software developer?</strong><br/><br/>Do you want to grow professionally as a software engineer?<br/>Are you curious about how to achieve the next level in your career? <br/><br/>My book "<a class="ae nm" href="https://www.amazon.com/dp/B098LNMFCJ/" rel="noopener ugc nofollow" target="_blank">Unlock the Code</a>" offers a comprehensive list of steps to boost <br/>your professional life.</span></pre></div></div>    
</body>
</html>