<html>
<head>
<title>Higher-Order Functions in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的高阶函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/higher-order-functions-in-swift-13c31a769c0c?source=collection_archive---------2-----------------------#2020-06-09">https://betterprogramming.pub/higher-order-functions-in-swift-13c31a769c0c?source=collection_archive---------2-----------------------#2020-06-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a8a6" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在代码中引入“map”、“reduce”、“filter”、“flatMap”和“compactMap”</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/bd03e87fd1671b579c4b3defa9962d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0Ve4jk_XRvWkC_SS1S79w.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@chuklanov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Avel Chuklanov </a>在<a class="ae kz" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><a href="https://raulferrer.dev"><div class="gi gj la"><img src="../Images/4559de80fb63bfa9a7c3d7a9ceaa962f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JG2ALPF7dH51wuAxTnReEQ.png"/></div></a></figure><p id="3d4a" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在之前的文章中，我们已经看到了如何通过<a class="ae kz" href="https://medium.com/be-developer/design-patterns-in-software-b5fc4baa9595" rel="noopener">设计模式</a>和<a class="ae kz" href="https://medium.com/better-programming/solid-principles-application-to-swift-development-1de8d7c57fdf" rel="noopener">坚实原则</a>的使用来改进我们代码的架构。现在我们将看看如何用高阶函数来改进我们的Swift代码。当然，您已经不止一次地使用过它们，但是它们是什么，您如何用高阶函数来改进您的Swift代码呢？</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="adf9" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">Swift高阶函数</h1><p id="cdd1" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated"><em class="nb">高阶函数</em>是以其他函数或闭包为自变量，返回一个函数或闭包的函数。这些函数与数组、集合和字典一起使用，并作用于它们包含的元素(这是通过使用point语法应用于集合元素的方法来完成的)。</p><p id="14e1" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">一些最著名的函数是<code class="fe nc nd ne nf b">map</code>、<code class="fe nc nd ne nf b">compactMap</code>、<code class="fe nc nd ne nf b">flatMap</code>、<code class="fe nc nd ne nf b">reduce</code>、<code class="fe nc nd ne nf b">filter</code>、<code class="fe nc nd ne nf b">contains</code>、<code class="fe nc nd ne nf b">sorted</code>、<code class="fe nc nd ne nf b">forEach</code>和<code class="fe nc nd ne nf b">removeAll</code>。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="93d8" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">'地图'</h1><p id="ab12" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated"><code class="fe nc nd ne nf b">map</code>函数的工作方式是对一个集合的所有元素执行操作，并返回一个包含该操作结果的新集合。</p><p id="89bd" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">例如，假设我们有一个数组，里面有几个单词，所有的字母都是小写的，我们想获得一个新的数组，每个单词都是大写的。我们可以用一个<code class="fe nc nd ne nf b">for</code> … <code class="fe nc nd ne nf b">in</code>循环来实现:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="f2ff" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">让我们看看如何用<code class="fe nc nd ne nf b">map</code>函数来实现。如<a class="ae kz" href="https://developer.apple.com/documentation/swift/array/3017522-map" rel="noopener ugc nofollow" target="_blank">苹果文档</a>所示，声明为:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="3573" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated"><code class="fe nc nd ne nf b">transform</code>接受集合或序列中的元素作为参数，并返回相同类型或不同类型的转换值。</p><p id="0625" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在本例中，我们看到应用如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="c568" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">它所做的是遍历整个元素数组，对每个元素应用<code class="fe nc nd ne nf b">uppercased()</code>方法，并返回一个包含这些值的新数组。</p><p id="53b6" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">无论如何，我们可以通过使用简写参数<code class="fe nc nd ne nf b">$0</code>来简化这个表达式，它引用数组的任何元素:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="c120" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">'紧凑地图'</h1><p id="1a0d" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">现在假设在前一个例子的数组中有<code class="fe nc nd ne nf b">nil</code>值。如果我们使用该函数，我们必须考虑要作用的值是否是<code class="fe nc nd ne nf b">nil</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="a9ed" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">但是如果我们真正想要的是得到新的数组，但是没有<code class="fe nc nd ne nf b">nil</code>值，那该怎么办呢？为了实现这一点，我们使用了<code class="fe nc nd ne nf b">compactMap</code>功能。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="8309" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">因此，在本例中，我们看到:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="5ff1" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">换句话说，<code class="fe nc nd ne nf b">compactMap</code>遍历数组中的所有元素，并将该方法应用于非<code class="fe nc nd ne nf b">nil</code>值，并在数组中返回它们，在本例中是类型<code class="fe nc nd ne nf b">String</code>(也就是说，<code class="fe nc nd ne nf b">String</code>的值不是可选的)。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="f11c" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">'平面地图'</h1><p id="41df" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated"><code class="fe nc nd ne nf b">flatMap</code>函数允许我们将一组数组转换成包含所有元素的单个集合。正如苹果在其<a class="ae kz" href="https://developer.apple.com/documentation/swift/sequence/2905332-flatmap" rel="noopener ugc nofollow" target="_blank">文档</a>中所宣称的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="2094" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">例如，让我们先来看看如果没有<code class="fe nc nd ne nf b">flatMap</code>我们会怎么做:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="f442" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">但是使用<code class="fe nc nd ne nf b">flatMap</code>，我们可以将代码简化如下:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="097d" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">'减少'</h1><p id="f597" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated"><code class="fe nc nd ne nf b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/array/2298686-reduce" rel="noopener ugc nofollow" target="_blank">reduce</a></code>是一个函数，当应用于一个集合时，返回该集合的元素的组合结果:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="4da7" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">例如，如果我们有一个数字为1-10的数组，并且我们想要获得它们的和，我们可以通过以下方式实现，而不使用reduce函数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="9a29" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">使用<code class="fe nc nd ne nf b">reduce</code>，我们只需执行以下操作:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="f57a" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在第一次迭代中，<em class="nb"> x </em>的值是0(正如我们在函数中指出的)，而<em class="nb"> y </em>的值是1。所以<em class="nb"> x + y </em>的结果将是1。在第二次迭代中，<em class="nb"> x </em>为1，<em class="nb"> y </em>为2。所以结果会是3。诸如此类。</p><p id="50a4" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">用一种更简单的方式，我们可以写:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="bf46" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">'过滤器'</h1><p id="f368" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">顾名思义，<code class="fe nc nd ne nf b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/sequence/3018365-filter" rel="noopener ugc nofollow" target="_blank">filter</a></code>函数过滤集合的内容并返回一个新的集合，该集合包含满足特定条件的元素:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="0fda" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">例如，假设我们有第一个例子中的单词集合，我们想得到一个包含字母<code class="fe nc nd ne nf b">o</code>的新单词集合。如果没有过滤功能，我们可以用下面的方法:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="a2a6" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这种情况下，我们没有使用<code class="fe nc nd ne nf b">contains</code>函数，因为，正如我们将在后面看到的，它也是一个高阶函数。</p><p id="15ca" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">现在我们将使用<code class="fe nc nd ne nf b">filter</code>函数来简化这段代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="9765" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">但它不必应用单一条件；我们可以应用几个条件。例如，在前面的例子中，我们可以让它返回包含元音字母<code class="fe nc nd ne nf b">o</code>并且长度为<code class="fe nc nd ne nf b">5</code>个字符或更多的单词:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="ead0" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">包含</h1><p id="d6d9" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">在前面的例子中，我们使用了<code class="fe nc nd ne nf b">contains</code>函数来确定一个单词是否包含元音<code class="fe nc nd ne nf b">o</code>。嗯，<code class="fe nc nd ne nf b">contains</code>是一个高阶函数，允许你检查是否有满足某个条件的元素，并根据它们是否满足条件返回<code class="fe nc nd ne nf b">true</code>或<code class="fe nc nd ne nf b">false</code>。</p><p id="6415" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">正如Apple在它的<a class="ae kz" href="https://developer.apple.com/documentation/swift/array/2945493-contains" rel="noopener ugc nofollow" target="_blank">文档</a>中指出的，<code class="fe nc nd ne nf b">contains</code>返回一个布尔值，表明序列是否包含给定的元素。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="650c" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">'已排序'</h1><p id="c6e4" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">在许多情况下，我们会找到一些想要以某种方式显示的元素。例如，在到目前为止看到的单词数组示例中，这些单词不是按字母顺序排列的。</p><p id="3868" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">但是如果我们想按字母顺序排序呢？我们可以使用一些算法，比如:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="bf26" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我们可以使用<code class="fe nc nd ne nf b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/array/2893281-swapat" rel="noopener ugc nofollow" target="_blank">swapAt</a></code>方法减少这段代码，它允许我们交换序列中两个元素的位置:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="656e" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了进一步减少这段代码，我们可以使用<code class="fe nc nd ne nf b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/array/2945003-sorted" rel="noopener ugc nofollow" target="_blank">sorted</a></code> <em class="nb"> </em>功能。该函数返回按升序排序的序列元素(只要集合的元素采用<code class="fe nc nd ne nf b">Comparable</code>协议):</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="a536" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">另一方面，如果我们想使用我们自己的条件对集合进行排序，我们使用函数<code class="fe nc nd ne nf b">sorted(by:)</code>，正如Apple在其<a class="ae kz" href="https://developer.apple.com/documentation/swift/array/2296815-sorted" rel="noopener ugc nofollow" target="_blank">文档</a>中指出的，该函数返回序列的元素，使用作为元素之间的比较给出的谓词进行排序。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="2838" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">例如，如果我们希望单词按反字母顺序排列，我们可以这样做:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="705c" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这种情况下，通过指示符号<code class="fe nc nd ne nf b">&gt;</code>，我们以降序对集合进行排序。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="5e9b" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">' forEach '</h1><p id="7f08" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">在<code class="fe nc nd ne nf b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/array/1689783-foreach" rel="noopener ugc nofollow" target="_blank">forEach</a></code>里面<code class="fe nc nd ne nf b">continue</code>和<code class="fe nc nd ne nf b">break</code>都不能用，只能用<code class="fe nc nd ne nf b">return</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="656b" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">'全部删除'</h1><p id="7c6a" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">高阶函数<code class="fe nc nd ne nf b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/array/3017530-removeall" rel="noopener ugc nofollow" target="_blank">removeAll(where:)</a></code>允许我们从满足特定条件的序列中删除元素:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="9858" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">例如，如果我们想从一个序列中删除所有偶数，我们可以使用<code class="fe nc nd ne nf b">removeAll</code>执行以下操作:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="2ddf" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在Apple在其文档中展示的例子中，可以更清楚地看到<code class="fe nc nd ne nf b">removeAll(where:)</code>的威力，在这个例子中，它使用它来删除一个短语的元音:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="7aad" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">函数串联</h1><p id="d6a3" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">一阶函数可以连续、级联应用。例如，我们可以获取一个包含数字数组的数组，并计算它们的和:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ng nh l"/></div></figure><p id="d2f1" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">首先，我们应用<code class="fe nc nd ne nf b">flatMap</code>函数获得一个包含所有数字的数组。然后我们应用<code class="fe nc nd ne nf b">reduce</code>函数来添加它们。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="f063" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结论</h1><p id="b781" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">我们刚刚通过一些例子看到了一些最常用的高阶函数及其威力。这些函数允许我们，一方面，减少代码量，另一方面，使我们的代码更加清晰和简洁。</p></div></div>    
</body>
</html>