<html>
<head>
<title>Diving Deep into SwiftUI (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入SwiftUI(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/diving-deep-into-swiftui-a-simple-custom-tab-bar-part-1-of-5-680d05d7f99b?source=collection_archive---------8-----------------------#2019-12-17">https://betterprogramming.pub/diving-deep-into-swiftui-a-simple-custom-tab-bar-part-1-of-5-680d05d7f99b?source=collection_archive---------8-----------------------#2019-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="856a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用GeometryReader构建自定义选项卡栏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3c1984a0b0554c44bb3b4b50ecf03d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEJ2m1ysf7cF1yc7sUUH4A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在创建简单的自定义选项卡栏的过程中。</p></figure><h1 id="a0ed" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="f606" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这个由五部分组成的系列中，我们将介绍<code class="fe mj mk ml mm b">GeometryReader</code>和SwiftUI中的一个新概念:视图首选项。我们将在实现自定义选项卡栏时这样做。我为我们的例子选择了一个自定义标签栏，因为在<a class="ae mn" href="https://medium.com/better-programming/working-around-the-shortfalls-of-swiftuis-tabview-ac9aa2a9d894" rel="noopener">之前的一篇文章</a>中，我写了SwiftUI的<code class="fe mj mk ml mm b">TabView</code>错误，这使得它在五个标签之外不再有用。您可以使用UIKit中的<code class="fe mj mk ml mm b">UITabBarController</code>,但是您将无法通过SwiftUI访问导航控制器。</p><p id="e148" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这篇文章的主题很高级。如果你还没有接触过这些概念，我强烈推荐你去看看Javier关于  <code class="fe mj mk ml mm b"><a class="ae mn" href="https://swiftui-lab.com/geometryreader-to-the-rescue/" rel="noopener ugc nofollow" target="_blank">GeometryReader</a></code> <strong class="lp ir">的文章以及那篇文章之后的三篇文章。</strong></p><ul class=""><li id="d0cb" class="mt mu iq lp b lq mo lt mp lw mv ma mw me mx mi my mz na nb bi translated"><strong class="lp ir">在第1部分中，我们将设置自定义标签栏项目，不使用视图首选项，只是简单使用了</strong> <code class="fe mj mk ml mm b"><strong class="lp ir">GeometryReader</strong></code> <strong class="lp ir">。我们将模仿默认iOS标签栏的功能。</strong></li><li id="213f" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">在第2部分的<a class="ae mn" href="https://medium.com/@ardactugay/diving-deep-into-swiftui-using-view-preferences-part-2-of-5-ebd8a91d6c3e" rel="noopener">中，我们将更深入地探讨如何使用视图首选项，并使我们的视图层次结构更像SwiftUI。</a></li><li id="bfca" class="mt mu iq lp b lq nc lt nd lw ne ma nf me ng mi my mz na nb bi translated">在<a class="ae mn" href="https://medium.com/better-programming/diving-deep-into-swiftui-part-3-853173868f07" rel="noopener">第三部</a>中，我们将看看用锚偏好来替换我们的一些视图偏好。</li></ul><p id="431a" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><em class="nh">快速提示:最初，我打算把这个系列分成5部分，但是自从写了这些文章，我就转向了Flutter。然而，这些文章的所有3个部分中的信息仍然是相关的，所以如果您想了解更多关于SwiftUI的信息，请继续阅读！</em></p><p id="bb45" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">您将在这个存储库中找到提交的链接，其中也包含最终产品。我们开始吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1d3a9991f59f5cc01c286c5669d87514.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*s1M-g008HUAWP5fyPuVeiw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">到本文结束时，您将获得什么！</p></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="3db9" class="kv kw iq bd kx ky nq la lb lc nr le lf jw ns jx lh jz nt ka lj kc nu kd ll lm bi translated">项目设置</h1><p id="928e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先创建一个新项目。转到文件&gt;项目。选择“单视图应用程序”，并给它起一个你喜欢的名字(我用的是“SwiftUICustomTabBar”)。确保选择“Swift”作为您的语言，选择“SwiftUI”作为用户界面。完成后，单击“下一步”,将项目保存到您选择的位置。我们准备开始编码了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/542fd32ce9de4af09478d0654617f697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOFIeXDqLpgrY4J97AyzGg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Xcode的项目选项。</p></figure><p id="6c1f" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">第一项工作是切换iOS目标版本。使用iOS <code class="fe mj mk ml mm b">13.1</code>来避免在13.2中引入的<a class="ae mn" href="https://forums.developer.apple.com/thread/124757" rel="noopener ugc nofollow" target="_blank">错误，当在<code class="fe mj mk ml mm b"> NavigationBarItems</code>中使用<code class="fe mj mk ml mm b">NavigationLink</code>时会出现</a>。最新的发行说明(写这篇文章时是Xcode 13.3)，没有提到对的修复，所以最好稳扎稳打，用<code class="fe mj mk ml mm b">13.1</code>。注意:这里的<em class="nh">是</em>对这个bug的一个变通办法，所以如果你一定要针对iOS 13.2+，检查一下<a class="ae mn" href="https://stackoverflow.com/a/59162996/4548148" rel="noopener ugc nofollow" target="_blank">这个</a>(我没有尝试过这个变通办法，所以不能保证它会工作)。</p><p id="8e00" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这是包含到目前为止所有内容的提交。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="05b5" class="kv kw iq bd kx ky nq la lb lc nr le lf jw ns jx lh jz nt ka lj kc nu kd ll lm bi translated">创建标签栏</h1><p id="34a0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们首先简单地创建标签栏，不用担心如何显示这些标签栏的内容。苹果的标签栏看起来像这样——我们要模仿它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/18e2937be9baf70215bcb03d13bdc60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*cTQeI4ssQlvosTNpeHF9Dg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS标签栏。摘自苹果公司的<a class="ae mn" href="https://developer.apple.com/design/human-interface-guidelines/ios/bars/tab-bars/" rel="noopener ugc nofollow" target="_blank">人机界面指南</a>。</p></figure><h2 id="9883" class="nx kw iq bd kx ny nz dn lb oa ob dp lf lw oc od lh ma oe of lj me og oh ll oi bi translated">创建选项卡栏项目</h2><p id="42df" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">打开<code class="fe mj mk ml mm b">ContentView.swift</code>，添加以下内容:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="8f3f" class="nx kw iq mm b gy on oo l op oq">import SwiftUI<br/><br/>struct ContentView: View {<br/>    var body: some View {<br/>        VStack {<br/>            Image(systemName: "clock.fill") // 1<br/>            Text("Recents")<br/>                .font(.caption) // 2<br/>        }.foregroundColor(Color(UIColor.systemGray)) // 3<br/>    }<br/>}<br/><br/>struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        ContentView()<br/>    }<br/>}</span></pre><p id="effb" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>图片使用苹果公司提供的图标。要找到这些图标的<code class="fe mj mk ml mm b">systemName</code>，使用苹果提供的<a class="ae mn" href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/" rel="noopener ugc nofollow" target="_blank"> SF Symbols App </a>。你也可以自由使用你自己的图标！</p><p id="e1aa" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//2</code> <strong class="lp ir"> </strong>将字体大小设置为系统默认<code class="fe mj mk ml mm b">.caption</code>，与苹果的tab栏紧密匹配。</p><p id="3c0a" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//3</code> <strong class="lp ir"> </strong>这里使用<code class="fe mj mk ml mm b">UIColor</code>是因为SwiftUI框架中的<code class="fe mj mk ml mm b">Color</code>还没有系统颜色选项。</p><p id="edcc" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在，如果您运行预览，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/90dbdec8bbd7ff6d1d89212414631c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*bgmL01mHhNcGJu871FQphg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">屏幕中央的一个选项卡栏项目。</p></figure><p id="b3b2" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">你会注意到它在屏幕的中央，但是现在还可以。我们稍后会修理它。</p><p id="1b5c" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这里是提交,包含到这里为止的所有内容。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="a310" class="kv kw iq bd kx ky nq la lb lc nr le lf jw ns jx lh jz nt ka lj kc nu kd ll lm bi translated">重构并添加更多选项卡项目</h1><p id="9eb6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在您已经有了一个简单的选项卡栏项目，将其重构为自己的<code class="fe mj mk ml mm b">View</code>并添加更多的选项卡项目。首先，创建一个新的SwiftUI视图文件，并将其命名为<code class="fe mj mk ml mm b">CustomTabBarItem.swift</code>。然后，添加以下代码:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="f9cb" class="nx kw iq mm b gy on oo l op oq">import SwiftUI<br/><br/>struct CustomTabBarItem: View {<br/>    let iconName: String<br/>    let label: String<br/>    <br/>    var body: some View {<br/>        VStack {<br/>            Image(systemName: iconName)<br/>            Text(label)<br/>                .font(.caption)<br/>        }<br/>        .foregroundColor(Color(UIColor.systemGray))<br/>        .frame(maxWidth: .infinity) // 1<br/>    }<br/>}<br/><br/>struct CustomTabBarItem_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        CustomTabBarItem(iconName: "clock.fill", label: "Recents")<br/>            .previewLayout(.fixed(width: 80, height: 80)) // 2<br/>    }<br/>}</span></pre><p id="52ea" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>实际上是将<code class="fe mj mk ml mm b">ContentView.swift</code>中的内容剪切并粘贴到这里，并添加了两个新的实例变量，它们可以由<code class="fe mj mk ml mm b">CustomTabBarItem</code>视图的调用者定制。</p><p id="0642" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//2</code>这是一个通过将<code class="fe mj mk ml mm b">maxWidth</code>设置为<code class="fe mj mk ml mm b">.infinity</code>来让视图占据其父视图中所有可用空间的技巧。你可以对高度做同样的事情，但是在这种情况下，这是不必要的。为什么会这样？因为在SwiftUI中，孩子们需要占用多少空间就占用多少空间。既然孩子被告知，它可以想占多少空间就占多少空间(最多“无限”)，而不贪婪，它就这么做了。</p><p id="e868" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">将预览的大小设置得小一些，因为您只需要看到一个选项卡栏项目是如何单独显示的——它在整个设备屏幕上的行为并不重要，因为它永远不会在没有选项卡栏的情况下使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/979e0d50d94bb4881200568dc8df02c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:308/format:webp/1*Lu9XAlB5Gh6wcyywFgBmsg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与。框架(最大宽度:。无穷大)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/2876ba31ac06c5bec9624a25040f02dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*eQHhZU3MkenOYdO8NGbrqg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有。框架(最大宽度:。无穷大)</p></figure><p id="ccda" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">如果你想知道上面的<code class="fe mj mk ml mm b">frame</code>设置到底是做什么的，点击你代码中的方法。您的预览应该突出显示整个框架，如图所示。现在，移除对<code class="fe mj mk ml mm b">frame</code>的调用，再次点击您的视图。请注意，视图的框架已经收缩了！</p><p id="4b74" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在是使用这个新视图的时候了。返回到<code class="fe mj mk ml mm b">ContentView.swift</code>，将其内容更改为:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="a9cd" class="nx kw iq mm b gy on oo l op oq">struct ContentView: View {<br/>    var body: some View {<br/>        HStack(alignment: .lastTextBaseline) {<br/>            CustomTabBarItem(iconName: "star.fill", label: "Favorites")<br/>            CustomTabBarItem(iconName: "clock.fill", label: "Recents")<br/>            CustomTabBarItem(iconName: "person.crop.circle", label: "Contacts")<br/>            CustomTabBarItem(iconName: "circle.grid.3x3.fill", label: "Keypad")<br/>            CustomTabBarItem(iconName: "recordingtape", label: "Voicemail")<br/>        }.frame(maxWidth: .infinity) // 1<br/>    }<br/>}<br/><br/>// Preview hasn't changed...</span></pre><p id="cbf1" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>此处增加相同的<code class="fe mj mk ml mm b">frame</code>设置。然而，这并不是绝对必要的——您可以删除它，并看到没有任何变化。这是因为你告诉所有的子视图——<code class="fe mj mk ml mm b">CustomTabBarItem</code>s——它们可以占据所有它们需要的空间。由于他们都想要所有的可用空间，SwiftUI的布局系统会自动为他们所有人分配相同的空间。</p><p id="98f6" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在，当您运行预览时，您将在屏幕中央看到所有选项卡栏项目:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/dfa6630c2a97fa68d2eedbf046a762db.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*jEhFLkZ2q5G_SrWxaej4tA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">选项卡栏项目，全部显示在设备屏幕的中央。</p></figure><p id="9081" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这里是提交，包含到这里为止的所有内容。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="a0a2" class="kv kw iq bd kx ky nq la lb lc nr le lf jw ns jx lh jz nt ka lj kc nu kd ll lm bi translated">粘性标签栏和背景(简介<code class="fe mj mk ml mm b">GeometryReader)</code></h1><p id="6969" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">标签栏看起来不错，但是它在屏幕的中央，没有地方显示它的内容。我们可以通过将标签栏移动到底部，给它添加背景，并为标签栏内容留出一些空间来解决这个问题。</p><p id="77ca" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">再次在<code class="fe mj mk ml mm b">ContentView.swift</code>中，将其内容更改为如下:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="74bf" class="nx kw iq mm b gy on oo l op oq">struct ContentView: View {<br/>    var body: some View {<br/>        VStack {<br/>            HStack(alignment: .lastTextBaseline) {<br/>                CustomTabBarItem(iconName: "star.fill", label: "Favorites")<br/>                CustomTabBarItem(iconName: "clock.fill", label: "Recents")<br/>                CustomTabBarItem(iconName: "person.crop.circle", label: "Contacts")<br/>                CustomTabBarItem(iconName: "circle.grid.3x3.fill", label: "Keypad")<br/>                CustomTabBarItem(iconName: "recordingtape", label: "Voicemail")<br/>            }<br/>            .frame(maxWidth: .infinity)<br/>            .background(<br/>                GeometryReader { parentGeometry in // 2<br/>                    Rectangle()<br/>                        .fill(Color(UIColor.systemGray2))<br/>                        .frame(width: parentGeometry.size.width, height: 0.5) // 3<br/>                        .position(x: parentGeometry.size.width / 2, y: 0) // 4<br/>                }<br/>            )<br/>            .background(Color(UIColor.systemGray6)) // 5<br/>        }.frame(maxHeight: .infinity, alignment: .bottom) // 1<br/>    }<br/>}<br/><br/>// Preview hasn't changed...</span></pre><p id="638e" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这里发生了很多事情，这是你第一次和<code class="fe mj mk ml mm b">GeometryReader </code>打交道——所以让我们深入了解一下发生了什么。</p><p id="50b3" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>注意，您将包含标签栏所有项目的<code class="fe mj mk ml mm b">HStack</code>包装在一个<code class="fe mj mk ml mm b">VStack</code>中。你需要一个方法来告诉这个<code class="fe mj mk ml mm b">VStack</code>的内容去拥抱底部，你可以用<code class="fe mj mk ml mm b">frame</code>方法做到。首先，将<code class="fe mj mk ml mm b">maxHeight</code>设置为<code class="fe mj mk ml mm b">.infinity</code>，以便<code class="fe mj mk ml mm b">VStack</code>占据整个屏幕高度(因为那是它的“直接父代”)。还有一个新的设定叫做<code class="fe mj mk ml mm b">alignment</code>。<a class="ae mn" href="https://developer.apple.com/documentation/swiftui/vstack/3278357-frame" rel="noopener ugc nofollow" target="_blank">让我们看看文件是怎么说的:</a></p><blockquote class="ov ow ox"><p id="6a11" class="ln lo nh lp b lq mo jr ls lt mp ju lv oy mq ly lz oz mr mc md pa ms mg mh mi ij bi translated">此视图在结果框架内的对齐方式。<code class="fe mj mk ml mm b">alignment</code>如果此视图小于结果框架给出的尺寸，则适用。</p></blockquote><p id="e32d" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">在这种情况下，这意味着<code class="fe mj mk ml mm b">VStack</code>中的所有视图都将与底部对齐，这正是您想要的。它还告诉你框架包围了你调用<code class="fe mj mk ml mm b">frame</code>方法的视图。所以你可以把它看作是另一个包装你的<code class="fe mj mk ml mm b">VStack</code>的视图。</p><p id="d338" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//2</code> <strong class="lp ir"> </strong>在这里，您可以更好地控制视图的布局。<code class="fe mj mk ml mm b">background</code>方法允许您以SwiftUI <code class="fe mj mk ml mm b">View</code>的形式添加自定义背景。</p><p id="da7c" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">如果你还没有阅读我在本文开头链接的部分，看看 <code class="fe mj mk ml mm b"><a class="ae mn" href="https://developer.apple.com/documentation/swiftui/geometryreader" rel="noopener ugc nofollow" target="_blank">GeometryReader</a></code>的<a class="ae mn" href="https://developer.apple.com/documentation/swiftui/geometryreader" rel="noopener ugc nofollow" target="_blank">文档:</a></p><blockquote class="ov ow ox"><p id="92b1" class="ln lo nh lp b lq mo jr ls lt mp ju lv oy mq ly lz oz mr mc md pa ms mg mh mi ij bi translated">将内容定义为其自身大小和坐标空间的函数的容器视图。</p></blockquote><p id="1d66" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">不幸的是，这不是很有帮助。但是如果你仔细阅读文档，它确实告诉我们一些事情:即<code class="fe mj mk ml mm b">GeometryReader</code>也是一种类型的<code class="fe mj mk ml mm b">View</code>，当初始化它时，你得到一个<code class="fe mj mk ml mm b">GeometryProxy</code>结构作为参数(<code class="fe mj mk ml mm b">init(content: (GeometryProxy) -&gt; Content</code>)，这个<code class="fe mj mk ml mm b">GeometryProxy</code>给你关于这个视图的大小和坐标空间的信息，相对于它的父视图。</p><p id="1043" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b"><a class="ae mn" href="https://developer.apple.com/documentation/swiftui/geometryproxy" rel="noopener ugc nofollow" target="_blank">GeometryProxy</a></code>为您提供视图的<code class="fe mj mk ml mm b">size</code>，在本例中是<code class="fe mj mk ml mm b">HStack</code>的大小。在第1部分中，我们不会担心如何协调空间工作。</p><p id="25e6" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">你在这里画的<code class="fe mj mk ml mm b">Rectangle</code>模拟了标签栏顶部的一条较暗的线。不幸的是，虽然可以像<code class="fe mj mk ml mm b">Rectangle</code>一样在<code class="fe mj mk ml mm b">Shape</code>上设置边框，但是没有办法指定要绘制哪些边框，所以这是一个解决这个缺点的方法。这里的<code class="fe mj mk ml mm b">frame</code>设置定义了“边框”的大小，其宽度与<code class="fe mj mk ml mm b">HStack</code>视图相同，高度仅为<code class="fe mj mk ml mm b">0.5</code>。</p><p id="cea1" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//4</code><code class="fe mj mk ml mm b"><a class="ae mn" href="https://developer.apple.com/documentation/swiftui/view/3278632-position" rel="noopener ugc nofollow" target="_blank">position</a></code>方法有据可查。它将视图的中心放在特定的坐标上。在SwiftUI中，视图只能相对于它们的中心定位——不幸的是没有办法改变这一点，所以当你移动更大的视图时，你必须考虑到这一点。这就是为什么<code class="fe mj mk ml mm b">parentGeometry.size.width / 2</code>用于<code class="fe mj mk ml mm b">x</code>位置的原因。</p><p id="0b64" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">最后，你将标签栏的整个背景颜色设置为比边框更浅的灰色。</p><p id="24d5" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">注意，为<code class="fe mj mk ml mm b">HStack</code>视图设置了两个背景。您可以设置任意多的背景。这些背景按照您在代码中看到的顺序添加到屏幕上:从上到下。也就是说，代码中最上面的背景是屏幕上最后面的背景。如果您更改背景的顺序，您将看不到边框。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/a092680e1ece4794acd4edfa06e61ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*einy7AzvfOLMHmSgIccDFw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标签栏顶部外出血的图标。</p></figure><p id="c4a0" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">那是许多信息！但是我们还没有完成。如果您运行预览，您会注意到标签栏项目在标签栏外出血。在模拟器中运行应用程序，并检查视图层次结构(通过转到Debug &gt; View Debugging &gt; Capture View Hierarchy来完成)，以查看可能发生的情况。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/ad9299ff2a8a57a14e75698fd49842a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*SurTzXiUkMw6POe_7Ut1nw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图标大于给定的界限。</p></figure><p id="2bef" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">单击选项卡栏中的任何图像，您会看到视图的框架以蓝色边框突出显示。请注意，这个蓝色边框小于图标的边界(用浅蓝色背景突出显示)。</p><p id="5f72" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">我猜测这是一个bug，但是在不知道<code class="fe mj mk ml mm b">Image</code>内部工作原理的情况下很难判断。这可能只是因为苹果正在为图标设置一个固定的大小，因为在SwiftUI中，孩子们可以拥有他们想要的任何大小，它会流血。此外，如果你想了解更多关于框架和边界在SwiftUI中如何工作的信息，请查看本文<a class="ae mn" href="https://swiftui-lab.com/frame-behaviors/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b8da" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">幸运的是，这个问题有一个简单的解决方法。转到<code class="fe mj mk ml mm b">CustomTabBarItem.swift</code>并添加以下代码:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="66bf" class="nx kw iq mm b gy on oo l op oq">struct CustomTabBarItem: View {<br/>    let iconName: String<br/>    let label: String<br/>    <br/>    var body: some View {<br/>        VStack(alignment: .center) {<br/>            Image(systemName: iconName)<br/>                .frame(minWidth: 25, minHeight: 25) // 1<br/>            Text(label)<br/>                .font(.caption)<br/>        }<br/>        .padding([.top, .bottom], 5) // 2<br/>        .foregroundColor(Color(UIColor.systemGray))<br/>        .frame(maxWidth: .infinity)<br/>    }<br/>}<br/><br/>// Preview hasn't changed...</span></pre><p id="4823" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>指定图像框架的最小宽度将有助于克服图像边界超出框架的问题(记住，发生这种情况是因为子视图可以占用尽可能多的空间，即使大小超出了父视图提供的范围)。数字<code class="fe mj mk ml mm b">25</code>不是一个神奇的数字——它是基于<a class="ae mn" href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/custom-icons/" rel="noopener ugc nofollow" target="_blank">苹果为标签栏项目</a>定制的图标指南(那篇文章只显示了2x大小，即50px乘50px。1x我们用25px)。</p><p id="d2ef" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">也添加一些填充，这样所有的标签栏项目周围都有一些空间，并且不会包围它们的边界。</p><p id="4fe7" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在，如果你回到<code class="fe mj mk ml mm b">ContentView.swift</code>，你会看到标签栏看起来和苹果的几乎一模一样！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/faae0f4d2c11bbbc86801fcc1a8a52ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*nK2oDTaYeOafIC5FXBjY8Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">标签栏已修复，图标不再溢出边框。</p></figure><p id="3147" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><a class="ae mn" href="https://github.com/tugayac/swiftui-custom-tab-bar-tutorial/commit/e563b282a083c10430e615ea36f1d9426cefca2e" rel="noopener ugc nofollow" target="_blank">这是提交</a>，包含了到目前为止的所有内容。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="55f6" class="kv kw iq bd kx ky nq la lb lc nr le lf jw ns jx lh jz nt ka lj kc nu kd ll lm bi translated">简单的内容视图实现</h1><p id="6f60" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">从需要为每个选项卡栏项目显示的内容的简单实现开始。您所需要做的就是根据所选择的选项卡栏项目来更改内容。</p><p id="dc57" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">首先，定义内容是什么——打开<code class="fe mj mk ml mm b">ContentView.swift</code>并添加以下方法:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="2e0a" class="nx kw iq mm b gy on oo l op oq">struct ContentView: View {<br/>    // Our existing code is here...<br/><br/>    private func favoritesContent() -&gt; some View {<br/>        return Text("Favorites Content")<br/>    }<br/>    <br/>    private func recentsContent() -&gt; some View {<br/>        return Text("Recents Content")<br/>    }<br/>    <br/>    private func contactsContent() -&gt; some View {<br/>        return Text("Contacts Content")<br/>    }<br/>    <br/>    private func keypadContent() -&gt; some View {<br/>        return Text("Keypad Content")<br/>    }<br/>    <br/>    private func voicemailContent() -&gt; some View {<br/>        return Text("Voicemail Content")<br/>    }<br/>}</span></pre><p id="1627" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">因为这只是一个例子，所以只返回内容的简单文本就足够了。但是，您可以返回您喜欢的任何内容视图——不仅限于文本！</p><p id="a4ff" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">返回类型<code class="fe mj mk ml mm b">some View</code>是Swift家族的新成员，被称为“不透明返回类型”本质上，它让实现决定返回类型，并受到一些约束(你可以在这里阅读更多关于它的内容<a class="ae mn" href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="ad9d" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在你有了你的内容，是时候让它显示出来了。首先，去<code class="fe mj mk ml mm b">CustomTabBarItem.swift</code>做一些改变:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="61b7" class="nx kw iq mm b gy on oo l op oq">struct CustomTabBarItem: View {<br/>    let iconName: String<br/>    let label: String<br/>    var onTap: () -&gt; Void = {} // 1<br/>    <br/>    var body: some View {<br/>        VStack(alignment: .center) {<br/>            Image(systemName: iconName)<br/>                .frame(minWidth: 25, minHeight: 25)<br/>            Text(label)<br/>                .font(.caption)<br/>        }<br/>        .padding([.top, .bottom], 5)<br/>        .foregroundColor(Color(UIColor.systemGray))<br/>        .frame(maxWidth: .infinity)<br/>        .contentShape(Rectangle()) // 3<br/>        .onTapGesture { // 2<br/>            self.onTap()<br/>        }<br/>    }<br/>}<br/><br/>// Preview hasn't changed...</span></pre><p id="15d5" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>一个新的变量，可以选择性地传递到一个新的标签栏项目中，用于处理点击手势。</p><p id="ae7e" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//2</code>点击，处理手势，调用自定义点击方法。</p><p id="13bc" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//3</code> <code class="fe mj mk ml mm b">contentShape()</code>允许您设置框架内内容的形状以进行点击测试(在本例中，为点击手势)。如果你不设置这个为<code class="fe mj mk ml mm b">Rectangle</code>，只有图标和文本上的点击会被注册，但是你想让用户更容易点击标签栏上的项目。</p><p id="1d85" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在再次在<code class="fe mj mk ml mm b">ContentView.swift</code>中，添加一个新的<code class="fe mj mk ml mm b">@State</code>变量，并相应地处理所有标签栏项目上的点击手势:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="2347" class="nx kw iq mm b gy on oo l op oq">struct ContentView: View {<br/>    @State private var selection: Int = 0 // 1<br/>    <br/>    var body: some View {<br/>        VStack(alignment: .center, spacing: 0) { // 2<br/>            ZStack { // 3<br/>                if (selection == 0) {<br/>                    favoritesContent()<br/>                } else if (selection == 1) {<br/>                    recentsContent()<br/>                } else if (selection == 2) {<br/>                    contactsContent()<br/>                } else if (selection == 3) {<br/>                    keypadContent()<br/>                } else if (selection == 4) {<br/>                    voicemailContent()<br/>                }<br/>            }.frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .center)<br/>            HStack(alignment: .lastTextBaseline) {<br/>                CustomTabBarItem(iconName: "star.fill",<br/>                                 label: "Favorites",<br/>                                 onTap: { self.selection = 0 }) // 4<br/>                CustomTabBarItem(iconName: "clock.fill",<br/>                                 label: "Recents",<br/>                                 onTap: { self.selection = 1 })<br/>                CustomTabBarItem(iconName: "person.crop.circle",<br/>                                 label: "Contacts",<br/>                                 onTap: { self.selection = 2 })<br/>                CustomTabBarItem(iconName: "circle.grid.3x3.fill",<br/>                                 label: "Keypad",<br/>                                 onTap: { self.selection = 3 })<br/>                CustomTabBarItem(iconName: "recordingtape",<br/>                                 label: "Voicemail",<br/>                                 onTap: { self.selection = 4 })<br/>            }<br/>            .frame(maxWidth: .infinity)<br/>            .background(<br/>                GeometryReader { parentGeometry in<br/>                    Rectangle()<br/>                        .fill(Color(UIColor.systemGray2))<br/>                        .frame(width: parentGeometry.size.width, height: 0.5)<br/>                        .position(x: parentGeometry.size.width / 2, y: 0)<br/>                }<br/>            )<br/>            .background(Color(UIColor.systemGray6))<br/>        }.frame(maxHeight: .infinity, alignment: .bottom)<br/>    }<br/> <br/>  // Content methods below here...   <br/>}<br/><br/>// Preview hasn't changed...</span></pre><p id="ff60" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>创建一个新的<code class="fe mj mk ml mm b">@State</code>变量，跟踪哪个选项卡被选中。</p><p id="5352" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//2</code>将<code class="fe mj mk ml mm b">spacing</code>设置为<code class="fe mj mk ml mm b">0</code>，使内容视图(<code class="fe mj mk ml mm b">ZStack</code>)和标签栏(<code class="fe mj mk ml mm b">HStack</code>)之间没有空间。另外，将<code class="fe mj mk ml mm b">alignment</code>设置为<code class="fe mj mk ml mm b">VStack</code>的默认值，因为不设置<code class="fe mj mk ml mm b">alignment</code>就不能设置<code class="fe mj mk ml mm b">spacing</code>。</p><p id="70ce" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//3</code>使用一个<code class="fe mj mk ml mm b">ZStack</code>作为内容视图。<code class="fe mj mk ml mm b">ZStack</code>在内容布局方面更加灵活，这也是为什么在这里使用它的原因，但是你也可以使用任何其他的栈。在<code class="fe mj mk ml mm b">ZStack</code>中有控制语句，根据用户的选择来选择呈现哪个内容视图。</p><p id="7e86" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//4</code>为每个标签栏项目传递一个自定义的点击手势处理程序，它根据用户点击的标签栏项目设置适当的选择值。</p><p id="e29f" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">现在运行实时预览，您将能够点击标签栏项目并观察内容变化:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/9247523f2047e96a2b7115e1f88cf29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/1*mQMqWrWk3btpk89Cvuug3g.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当点击不同的标签栏项目时，内容会发生变化。</p></figure><p id="f7b7" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这里是提交，包含到这里为止的所有内容。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="4e2c" class="kv kw iq bd kx ky nq la lb lc nr le lf jw ns jx lh jz nt ka lj kc nu kd ll lm bi translated">突出显示当前选定的选项卡栏项目</h1><p id="1eed" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通过将当前选中的选项卡栏项目突出显示为蓝色，再添加一个关键特性来显示选中了哪个选项卡栏项目。</p><p id="839a" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">首先，转到<code class="fe mj mk ml mm b">CustomTabBarItem.swift</code>并进行一些更改:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="f920" class="nx kw iq mm b gy on oo l op oq">struct CustomTabBarItem: View {<br/>    let iconName: String<br/>    let label: String<br/>    let selection: Binding&lt;Int&gt; // 1<br/>    let tag: Int // 2<br/>    <br/>    var body: some View {<br/>        VStack(alignment: .center) {<br/>            Image(systemName: iconName)<br/>                .frame(minWidth: 25, minHeight: 25)<br/>            Text(label)<br/>                .font(.caption)<br/>        }<br/>        .padding([.top, .bottom], 5)<br/>        .foregroundColor(fgColor()) // 4<br/>        .frame(maxWidth: .infinity)<br/>        .contentShape(Rectangle())<br/>        .onTapGesture {<br/>            self.selection.wrappedValue = self.tag // 3<br/>        }<br/>    }<br/>    <br/>    private func fgColor() -&gt; Color {<br/>        return selection.wrappedValue == tag ? Color(UIColor.systemBlue) : Color(UIColor.systemGray)<br/>    }<br/>}<br/><br/>struct CustomTabBarItem_Previews: PreviewProvider {<br/>    static var selection: Int = 0<br/>    static var selectionBinding = Binding&lt;Int&gt;(get: { selection }, set: { selection = $0 })<br/>    <br/>    static var previews: some View {<br/>        CustomTabBarItem(iconName: "clock.fill", label: "Recents", selection: selectionBinding, tag: 0)<br/>            .previewLayout(.fixed(width: 80, height: 80))<br/>    }<br/>}</span></pre><p id="01b1" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//1</code>这个实例变量将用于与父视图中的<code class="fe mj mk ml mm b">@State</code>变量通信，并让标签栏项目知道它是否被选中</p><p id="45da" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//2</code>这个实例变量将告诉标签栏项目它被分配的选择值是什么。如果该标签与选择值匹配，则表明选项卡栏项目被选中。</p><p id="dbcf" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//3</code>function参数已移除，现在您只需将选项卡栏项目的标签分配给选择绑定，这将自动更新父视图中的状态。这更像SwiftUI的方式，而不是在参数中传递函数。</p><p id="b498" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">//4</code>将前景色重构为一个方法，该方法应该根据选项卡栏项目是否被选中来返回它的颜色。如果选中，颜色为蓝色，否则，像以前一样为灰色。</p><p id="2a19" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">在<code class="fe mj mk ml mm b">ContentView.swift</code>中，你只需要改变<code class="fe mj mk ml mm b">CustomTabBarItem</code>初始化器调用来传递选择和它们的标签:</p><pre class="kg kh ki kj gt oj mm ok ol aw om bi"><span id="f6e3" class="nx kw iq mm b gy on oo l op oq">// inside var body: some View<br/><br/>HStack(alignment: .lastTextBaseline) {<br/>    CustomTabBarItem(iconName: "star.fill",<br/>                     label: "Favorites",<br/>                     selection: $selection,<br/>                     tag: 0)<br/>    CustomTabBarItem(iconName: "clock.fill",<br/>                     label: "Recents",<br/>                     selection: $selection,<br/>                     tag: 1)<br/>    CustomTabBarItem(iconName: "person.crop.circle",<br/>                     label: "Contacts",<br/>                     selection: $selection,<br/>                     tag: 2)<br/>    CustomTabBarItem(iconName: "circle.grid.3x3.fill",<br/>                     label: "Keypad",<br/>                     selection: $selection,<br/>                     tag: 3)<br/>    CustomTabBarItem(iconName: "recordingtape",<br/>                     label: "Voicemail",<br/>                     selection: $selection,<br/>                     tag: 4)<br/>}<br/><br/>// Nothing else has changed...</span></pre><p id="976c" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><code class="fe mj mk ml mm b">$selection</code>符号获取<code class="fe mj mk ml mm b">@State</code>变量的底层<code class="fe mj mk ml mm b">Binding</code>。</p><p id="ae36" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">这是包含到目前为止所有内容的提交。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="c6b5" class="kv kw iq bd kx ky nq la lb lc nr le lf jw ns jx lh jz nt ka lj kc nu kd ll lm bi translated">一个工作的自定义标签栏</h1><p id="870a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">至此，您已经有了一个简单的、可工作的定制选项卡栏实现。</p><p id="90ea" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated">继续第2部分，在那里我们将了解视图偏好以及如何让我们的代码看起来更“SwiftUI-ish”。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="f8c5" class="pw-post-body-paragraph ln lo iq lp b lq mo jr ls lt mp ju lv lw mq ly lz ma mr mc md me ms mg mh mi ij bi translated"><em class="nh">注意到问题了吗？认为有更好的方法来做我上面列出的事情吗？请务必在下方留下评论或发送私信，以便我们讨论。感谢阅读——我希望你今天学到了新东西！</em></p></div></div>    
</body>
</html>