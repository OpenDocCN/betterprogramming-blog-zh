<html>
<head>
<title>15 Tips to Building Quality Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建高质量软件的15个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-quality-software-63eb8a5f73ca?source=collection_archive---------5-----------------------#2021-11-26">https://betterprogramming.pub/building-quality-software-63eb8a5f73ca?source=collection_archive---------5-----------------------#2021-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f57" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">手动开发人员测试，隔离临时代码，等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/743d8515b5d3a08bb797a30a680617c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_5g0Kg4FrhIahzGR9x__g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">gears——照片来自<a class="ae kv" href="https://www.wonderopolis.org/wonder/who-invented-gears" rel="noopener ugc nofollow" target="_blank">wonderopolis.org</a></p></figure><p id="8c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始讨论如何构建高质量的软件之前，让我们先来定义它。高质量的软件是健壮的，可维护的，有最小的错误，并提供良好的UX。</p><p id="6e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的大部分评论都是适用于软件开发的一般概念；然而，其中一些更具体地适用于Android开发。</p><p id="33f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一开始就把重点放在质量上会带来巨大的回报。随着代码质量的提高，您可以增加开发人员的吞吐量，增加容量，并减少交付时间，这反过来会给您更多的时间来反思/改进您自己的过程。</p><h1 id="986f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">坚实的原则</h1><p id="1012" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个由5个字母组成的首字母缩略词概括了有助于增强代码健壮性的通用软件设计原则。点击<a class="ae kv" href="https://medium.com/swlh/solid-design-principles-the-simplest-explanation-8df7164308f5" rel="noopener">这里</a>和<a class="ae kv" href="https://medium.com/litslink/solid-software-design-principles-ac5be34a6cd5" rel="noopener">这里</a>了解更多信息。</p><p id="ce2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论何时编写代码，都要记住这些事情。这些原则有助于使您的代码可维护，从长远来看，这是非常有价值的。</p><p id="c279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对所有原则有一个“坚实”的理解将被证明是非常有价值的。</p><h1 id="a208" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">给自己时间做计划</h1><p id="4f91" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当处理一个大的特性时，要花足够的时间来考虑如何有效地设计这个特性。考虑所有组件将如何通信。</p><p id="d5f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有没有已经解决了相同/相似问题的现有设计模式？如果将来这个特性需要改变，我该如何构建它以使改变变得又快又容易？即在做出改变时最小的波纹效应。</p><p id="f5ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当构建一个中大型的特性时，有时我会花大约4个小时来规划架构。如果它是一个非常大的功能，我甚至会花一整天甚至更多的时间来设计一个健壮的设计。</p><h1 id="06fd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">按功能打包</h1><p id="eb79" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">组织代码的两种主要方式是按层打包和按特性打包。通过逐层打包，您实际上是将类放在它们所属的架构层中。例如，您可以将所有的定制视图类放在一个包中，将所有的存储库类放在另一个包中，将所有的模型类放在另一个包中，等等。</p><p id="7628" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用“按特性打包”,您可以将特性所需的所有类放在同一个包中。这有这么多好处！较低的复杂性，较高的类内聚力，较低的包间耦合。需要更新功能或删除功能吗？您需要的所有东西都在一个地方——不需要去搜索构成特性的所有类！</p><p id="dd39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也使得项目更容易维护，因为未来的开发人员也将更容易使用该特性，因为所有的东西都在一个地方。</p><p id="a1e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，像通用工具类这样的东西可能更适合在特性包之外。</p><h1 id="8e78" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不要跨功能共享自定义组件</h1><p id="22c3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">例如，如果您为特性A创建了一个定制视图，那么即使特性B需要一个相似(或相同)的视图，您最好不要<strong class="ky ir">重用特性B的定制视图。</strong></p><p id="6189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因如下。假设您创建了一个定制的卡片视图，它被四个不同屏幕上的列表使用<em class="mp">(特性A、B、C和D) </em>。今天，四个不同屏幕上的所有卡片视图显示相同的信息。如果将来只针对特性A和B的需求发生了变化，该怎么办？那你会怎么做？通常是两种情况之一:</p><ol class=""><li id="6877" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">向自定义视图添加一些条件和/或更多属性，以便它可以满足所有屏幕的所有要求。</li><li id="46da" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">断开特征，并使用修改后的需求创建一个新的自定义视图。</li></ol><p id="4b93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个选择很可能是一个糟糕的决定，因为这样做会增加自定义视图的复杂性。如果您一直这样做，随着时间的推移，您将最终得到一个与不同特性紧密耦合的整体类。现在，如果你想重构这个类，将会花费很长时间，因为它与如此多的特性紧密耦合，并且复杂性增加。你可能会打破其中一个功能的东西。<em class="mp">此外，请记住，随着复杂性的增加，开发人员的吞吐量会下降。</em></p><p id="ad3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个选择是更好的选择，但是，如果您为每个特性都创建了单独的视图，那么第一个选择就没有必要了。</p><p id="fab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一点需要注意。如果有一个非常小的自定义视图，我非常确定它不会改变，我可能会把它放在一个通用视图包中，并在不同的特性中使用。这可能类似于在每个卡片视图中使用的小型自定义用户图像视图。相反，卡片视图可能包含各种信息，这使得它更有可能被改变。</p><h1 id="7267" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">仔细考虑边缘案例</h1><p id="6051" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在开发特性时，花些时间仔细考虑所有的边缘情况。您应该了解您所处理的代码的每个部分可能会出现什么问题。</p><p id="e7de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如API错误是否处理得当？如果用户正在打电话，但失去了网络连接，会发生什么情况？如果用户在长时间运行的操作中终止了应用程序，然后在稍后恢复，该怎么办？如果用户点击一个按钮，让一个API请求非常快速地重复，会怎么样？</p><p id="1c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不能立即解决边缘情况，那么一定要以某种方式跟踪它们。<em class="mp">例如，你可以留下待办事宜的注释。不过，在您考虑功能是否完整之前，请务必解决边缘情况！</em></p><p id="94de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Android Studio/IntelliJ IDEA有一个很好的特性，你可以看到一个包中所有的TODO注释。关于如何在Android Studio中查看TODO评论，请参见<a class="ae kv" href="https://stackoverflow.com/a/23384888/1159930" rel="noopener ugc nofollow" target="_blank">这篇SO帖子</a>。</p><h1 id="e410" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">IntelliJ Live模板</h1><p id="a50b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://www.jetbrains.com/help/idea/using-live-templates.html" rel="noopener ugc nofollow" target="_blank">实时模板</a>是Android Studio/IntelliJ IDEA中的一项功能，允许你快速插入样板代码。这是一个非常强大的功能，可以提高您的工作效率(同时减少复制/粘贴错误)。</p><p id="c357" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您可以在执行重复性任务时使用它，如创建自定义视图、设置视图绑定、编写单元测试等。使用变量可以自定义实时模板。</p><p id="e107" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">详见<a class="ae kv" href="https://www.raywenderlich.com/4979242-live-templates-in-android-studio-getting-started" rel="noopener ugc nofollow" target="_blank">本帖</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/8b1ccd91eaf5d24c8af41137a6a299e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KW62A87vbwQY9FkwJSYQMQ.gif"/></div></div></figure><h1 id="456c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">总是澄清不确定性</h1><p id="9a00" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通常，开发人员处理由产品经理创建的票证。该标签将包含您正在处理的给定特性的详细信息(以及验收标准)。</p><p id="d0f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在制作这些特色票时，最好澄清票中任何不清楚的地方。不要假设。你这样做会节省时间。我们最不想做的事情就是做出错误的假设，然后需要重做一些本可以在早些时候澄清的事情。</p><p id="83a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我目前的组织中，我们都为Slack中特定主题频道的特定功能编写了通信。该功能的相关人员将是Slack渠道的一部分(后端工程师、前端工程师、产品经理等)。</p><p id="e8d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持条理，我通常会把我对某张票的所有问题作为一个单独的评论贴出来。然后，每个问题都可以在该特定问题的线程中得到回答。我用松弛的表情符号来表示问题是否被回答。如果有任何悬而未决的问题，我use❓to指出这一点。如果这个问题已经被完全回答了，那么我用✅来表示这个状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/9f2324b5d86029978a2dcfe026dfca21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThbpryW_Sy95QGY0Ft9oqQ.png"/></div></div></figure><h1 id="29d6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不要匆忙</h1><p id="adc9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不管这个特性有多重要，重要的是一步一步来，把所有的事情都考虑清楚。即使你“落后”，也不要让它影响你。如果你试图尽可能快地运行，很有可能你会留下一些错误或者错过一些本可以避免的情况。</p><p id="2487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使你“走得很快”,回来解决问题和偷工减料也需要更多的时间。从长远来看，保持冷静和从容会节省时间。第一次就把事情做对，比发现一些bug后修复五次要便宜。</p><p id="c27b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你感到有压力，休息一下或者去散步。</p><p id="f909" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使在生产中有一个严重的错误，你仍然需要一步一步来，在解决问题之前理解发生了什么。如果修复这个问题需要很长时间，那么你可以在修复的时候回滚到以前的版本。</p><h1 id="c753" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">隔离临时代码</h1><p id="5f1b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设您想要快速启动一个正在进行的新活动来测试它，或者您可能想要在代码中模拟某种临时条件。</p><p id="c274" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管你想写的代码量有多小，如果你不想让它留在代码中，那么它应该被隔离到它自己的方法中。否则，它可能会与其他代码混合在一起，您可能会忘记它！至少用一个孤立的方法会更容易识别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/14bb57a2078d8e43338cffebb214d8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*XMUTsoo_EOuI7aJnVlKyJw.png"/></div></figure><h1 id="66f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">首先解决困难/阻塞问题</h1><p id="0230" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">集成点是潜在障碍的一个例子。假设您正在开发一个需要API集成的新客户端特性。假设完成API需要一天，完成客户端工作需要5天。即使您还没有完成UI的构建，在过程的早期测试API也是一个好主意。</p><p id="0c2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您等到完全构建好特性之后才测试API，或者更糟的是，根本不测试它，而只是简单地将构建抛给QA，那么您就冒着延长特性交付周期的风险。通过与后端团队保持密切沟通，并在完成特性构建之前帮助测试API，您可以帮助减少总体交付时间。</p><h1 id="b9ee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">手动开发者测试</h1><p id="79ee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当您完成构建特征时，您应该尝试中断它。做一些你自己的手动开发测试，以确保你没有错过任何边缘情况，事情会像你期望的那样工作。这将有助于缩短反馈回路。</p><p id="7f3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，我们完全跳过做我们自己的开发人员测试，简单地把构建扔给QA。然后QA发现一个bug，然后发回给你修复。同时，您已经将上下文切换到另一个票证。然后你回去把QA里发现的bug修好。想象这种情况在QA和你之间再发生一轮。</p><p id="b075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您能看到这种事情如何轻易地将一个票据的开发时间延长几天吗(上下文切换+在同一个票据上花费更多时间)？尽管在将构建移交给QA之前进行一些手工开发人员测试可能看起来很乏味，但从长远来看，这将节省您的时间。</p><h1 id="ae08" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">单元测试</h1><p id="5288" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">理想情况下，您构建的每个功能都应该有单元测试。如果代码是不可测试的，那么它需要被改进以使它是可测试的。</p><p id="eb08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的单元测试通过持续集成在每次提交到您的开发/主分支时运行，那就更好了。</p><h1 id="d0dd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码审查</h1><p id="87c2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">标准代码评审是另一个捕捉错误和潜在改进的好方法。彻底的代码审查比简单地点击批准按钮更有价值。</p><h1 id="821f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">监控崩溃报告</h1><p id="9ba5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在一个版本发布后，密切关注崩溃报告可能会有所帮助。当您能够在错误变得太大之前识别并修复它们时，这种感觉非常好。</p><h1 id="834a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使回滚变得容易</h1><p id="e287" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果/当您需要回滚到以前的版本时，标记您发布的提交将使您的生活变得容易。我使用类似于<code class="fe nh ni nj nk b">release/1.2.3–456</code>的标签来表示版本号。</p><p id="d0b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您需要回滚时，您可以轻松地签出标记的commit，修改版本，并发布构建。即使您的项目使用子模块，此方法也有效。</p></div></div>    
</body>
</html>