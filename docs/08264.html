<html>
<head>
<title>A Look at the Tree Data Structure in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的树形数据结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-at-the-tree-data-structure-in-c-49a33bc841eb?source=collection_archive---------4-----------------------#2021-04-12">https://betterprogramming.pub/a-look-at-the-tree-data-structure-in-c-49a33bc841eb?source=collection_archive---------4-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="599b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">树可以解决各种各样的计算机科学问题</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/637094064dbde0ce08a031b8f565ed8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-7lvI61a8B_AynL0"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kw" href="https://unsplash.com/@veeterzy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> veeterzy </a>拍摄的照片</p></figure><p id="c741" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">树<em class="lt"> </em>是计算机科学中最有趣的数据结构之一。除了有常见的名字如<em class="lt">兄弟姐妹、树叶、父母、孩子、</em>等。，来表示它们，树可以用来解决计算机科学中一些最具挑战性的问题。</p><p id="0804" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们深入了解树的基本概念，它们在C++中的用法，以及它们在一些最重要问题上的应用。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="5d85" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">树木背后的概念</h1><p id="59cf" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">树属于非线性数据结构类。不同于线性数据结构，如堆栈或列表，<em class="lt"> </em>其中元素以线性顺序存储<em class="lt">，</em>非线性数据结构分层存储元素。因此，树或图的遍历不能在一次运行中完成。</p><p id="0cfc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是一个典型的树的例子。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi my"><img src="../Images/015221fc54e9a28b0e7d2fdae70b5e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*QtjD5Vfc0ZFyUXO4He9bwQ.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">二叉树的例子</p></figure><p id="a86f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">圆圈内的元素称为树的<em class="lt">节点</em>。二叉树是一种数据结构，其中每个节点最多有两个子节点。最顶端的节点称为<em class="lt">根</em>节点。没有孩子的节点称为<em class="lt">叶</em>。这里的根节点是27。14处的节点是节点27的左子节点，35处的节点是右子节点。类似地，父节点14的左右孩子分别是10和19。上例中的叶子是10、19、31和42。树的高度被定义为从根到叶子的最长路径。在上面的例子中，树的高度是2。</p><p id="153a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">树的优点是可以有效地利用内存。在堆栈的情况下，删除中间的元素是困难的，因为我们必须将元素移到堆栈的右边。但是在树的情况下，我们可以删除节点<em class="lt"> x </em>并修改其父节点以指向<em class="lt"> x </em>的子节点。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="633b" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">树的类型</h1><p id="3d2e" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated"><strong class="kz ir">全二叉树:</strong>如果每个节点都有0或2个子节点，那么二叉树就是全二叉树。</p><p id="b414" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">完全二叉树:</strong>一棵二叉树是一棵完全二叉树，如果所有的层次都被完全填充，除了可能的最后一层，并且最后一层有尽可能多的所有键。</p><p id="f4d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">完美二叉树:</strong>如果一棵二叉树的所有内部节点都有两个子节点，并且所有叶节点都在同一层，那么它就是完美二叉树。</p><p id="2f84" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">平衡二叉树</strong>:如果树的高度为O(Log n)则二叉树是平衡的，其中<em class="lt"> n </em>是节点数。</p><p id="baad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">二叉查找树:</strong>在二叉查找树中，节点左子节点的值必须小于其父节点的值，节点右子节点的值必须大于其父节点的值。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="1038" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated"><strong class="ak">编码树</strong></h1><p id="66e7" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">用C++表示树<em class="lt"> </em>的代码如下所示。它由一个数据部分和分别对左右节点的引用组成。</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="9917" class="ne mc iq na b gy nf ng l nh ni">struct node {<br/>   int data;   <br/>   struct node *left; //Reference to left child<br/>   struct node *right; //Reference to right child<br/>};</span></pre><p id="3895" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了简单起见，让我们考虑一个二叉查找树(BST)。可以在这个树形数据结构上执行的基本操作是插入、搜索和遍历。</p><h2 id="90ff" class="ne mc iq bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">将元素插入BST</h2><p id="cf6f" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">在下面的例子中，我们将值为<code class="fe nu nv nw na b">val</code> <em class="lt"> </em>的元素插入到树中。如果<code class="fe nu nv nw na b">val</code>小于根值，树的遍历继续向左，因为<code class="fe nu nv nw na b">val</code>需要被插入到左边的子树中。如果<code class="fe nu nv nw na b">val</code>大于根值，我们继续右子树遍历，将<code class="fe nu nv nw na b">val</code>插入右边。如果<code class="fe nu nv nw na b">val</code>等于根键，我们简单地返回根键以避免重复。如果树是空的或者树遍历到了末尾没有结果，那么我们调用<code class="fe nu nv nw na b">getNewNode</code>函数来获得一个新的节点。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="4396" class="ne mc iq bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">在BST中遍历树并搜索元素</h2><p id="d6b0" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">为了在二叉查找树中搜索关键字<em class="lt"> </em>，我们检查根值是否等于<code class="fe nu nv nw na b">NULL</code>。如果树是空的，或者如果树遍历到达末尾而没有找到键，就会发生这种情况。如果密钥不存在，我们返回<code class="fe nu nv nw na b">NULL</code>。</p><p id="4ad5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果根值等于键值，我们返回根地址。</p><p id="8e48" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在所有其他情况下，如果键值小于根值，我们执行左树遍历，如果键值大于根值，我们执行右树遍历。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="58db" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">树木的应用</h1><p id="ac22" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">树可以用来表示数据中的层次和结构关系。此外，当插入和搜索的时间复杂度为O(h)时，它们是有效的，其中<em class="lt"> h </em>是树的高度。与列表和数组等其他数据结构不同，子树可以轻松地移动。</p><h2 id="d424" class="ne mc iq bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">操作系统</h2><p id="00a0" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">最流行的操作系统之一，Linux，<em class="lt"> </em>利用树形结构来表示它的层次文件系统。Linux中的文件系统以如下所示的树形结构排列。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nz"><img src="../Images/6e30736215cdb994b5399cf8df49f682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dba45cSp977C5v6ghWJqGA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">Linux中的文件系统</p></figure><h2 id="5bcd" class="ne mc iq bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">编译程序</h2><p id="f4a1" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated"><em class="lt">语法树</em>是用编程语言编写的源代码的抽象语法结构的树表示。树的每个节点表示源代码中出现的一个构造。</p><p id="3159" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">编译器在语法分析阶段构建语法树。该树用于检查在编写计算机程序时是否遵循了正确的语法。</p><h2 id="139d" class="ne mc iq bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">网桥和路由器</h2><p id="7fa1" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated"><em class="lt">最小权重生成树</em> <strong class="kz ir"> </strong>是连接的、边加权无向图的边的子集，该图将所有顶点连接在一起，没有任何圈并且具有最小可能的总边权重。这种树用于计算机网络的网桥和路由器中的数据包路由。</p><h2 id="81df" class="ne mc iq bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">特里</h2><p id="f966" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">一个<em class="lt"> trie </em>是一种高效的信息检索数据结构。使用trie，搜索复杂性可以达到最佳极限(密钥长度)。如果我们在二叉查找树中存储关键字，我们需要与M * log N成比例的时间，其中M是最大字符串长度，N是树中关键字的数量。使用trie，我们可以在O(M)时间内搜索密钥。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="a3b4" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated"><strong class="ak">结论</strong></h1><p id="15db" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated"><em class="lt"> B树</em>，也称为<em class="lt">自平衡树</em>，用于在数据库中建立索引，以实现高效的信息检索。</p><p id="a6d6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">计算机科学中有几种树可以用于多种目的。树是每个开发人员都需要知道的最重要的工具之一。这使得解决问题变得更快更容易，尤其是对于处理层次结构的问题。</p></div></div>    
</body>
</html>