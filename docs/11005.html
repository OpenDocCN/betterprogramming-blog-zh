<html>
<head>
<title>3 Simple Ways To Get Started With GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub操作的3种简单入门方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-simple-ways-to-get-started-with-github-actions-5c511cfa1744?source=collection_archive---------20-----------------------#2022-02-09">https://betterprogramming.pub/3-simple-ways-to-get-started-with-github-actions-5c511cfa1744?source=collection_archive---------20-----------------------#2022-02-09</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="da86" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">从GitHub中自动化您的开发人员工作流程</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/935b8715d93ebe4a71e4319713f04e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BAvtnmutQE6-6Sy_"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">罗曼·辛克维奇在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="aacc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">GitHub Actions是在2020年向GitHub上的每个用户开放的，所以它们还是相对较新的。你知道你每个月有2000分钟的空闲时间用于你的私人存储库吗？更好的是，公共存储库免费获得<strong class="ld iw">无限分钟。</strong></p><p id="584c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你甚至不需要自己构建大部分动作，GitHub有一个充满免费动作的市场供你使用。那么，你可以利用空闲时间做些什么简单的事情呢？</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="09f1" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">代码林挺</h1><p id="295c" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">林挺允许你自动检查你的代码的编程和风格问题。如果代码以一致的方式编写，会更容易阅读，所以linters旨在为您的代码提供一致的风格。</p><p id="dc41" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在PR合并到主分支之前运行代码林挺是GitHub动作的一个极好的用例，而且做起来超级简单！下面是我对Ruby存储库的做法:</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="ceb1" class="ng mf iv nc b gy nh ni l nj nk">name: Ruby<br/><br/>on:<br/>  pull_request:<br/>  workflow_dispatch:<br/><br/>jobs:<br/>  lint:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>    - uses: actions/checkout@v2<br/>    - name: Set up Ruby<br/>      uses: ruby/setup-ruby@v1<br/>      with:<br/>        ruby-version: '2.7.1'<br/>        bundler-cache: true<br/>    - name: Run Rubocop Linting<br/>      run: bundle exec rubocop</span></pre><p id="98b3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">GitHub动作是用YAML定义的。由于这是我们看到的第一个GitHub动作，我将一步一步地介绍:</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="83dc" class="ng mf iv nc b gy nh ni l nj nk">name: Ruby</span></pre><p id="b146" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">从简单开始，这是这个特定GitHub动作的名称。</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="9076" class="ng mf iv nc b gy nh ni l nj nk">on:<br/>  pull_request:<br/>  workflow_dispatch:</span></pre><p id="ac25" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">接下来，我们定义哪些事件应该触发GitHub动作。在这种情况下，我们选择在打开、重新打开或提交请求时运行这个操作。这些是默认的，但是您可以在许多与拉请求相关的事件上触发事件，您可以在这里看到<a class="ae la" href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7f31" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们指定的第二个事件是workflow dispatch，它允许我们从存储库的Actions选项卡中手动运行操作。我发现这在测试一个动作时特别有用。</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="a773" class="ng mf iv nc b gy nh ni l nj nk">jobs:<br/>  lint:<br/>    runs-on: ubuntu-latest</span></pre><p id="e221" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">既然我们已经定义了操作应该何时运行，我们可以指定操作应该做什么。动作被分解成作业(每个动作可以定义多个)。在本例中，我们有一个名为lint的作业，我们必须定义在什么环境中运行GitHub操作。</p><p id="befd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我选择了Linux，但也有Windows和macOS。这些跑步者都由GitHub托管，使得每个人都可以非常容易地访问它们，但是如果你需要更强大的跑步者，或者需要特定的硬件或工具，你可以<a class="ae la" href="https://docs.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners" rel="noopener ugc nofollow" target="_blank">自托管跑步者</a>。</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="e7f3" class="ng mf iv nc b gy nh ni l nj nk">- uses: actions/checkout@v2<br/>- name: Set up Ruby<br/>  uses: ruby/setup-ruby@v1<br/>    with:<br/>      ruby-version: '2.7.1'<br/>      bundler-cache: true<br/>- name: Run Rubocop Linting<br/>  run: bundle exec rubocop</span></pre><p id="58cd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">每个作业可以有多个步骤，定义为一个列表。大多数操作总是从由GitHub构建的checkout操作开始，它会将您的存储库签出到runner中。</p><p id="334f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后我们进入这个行动的细节。首先，我们必须安装Ruby，这也是一个可以使用的预配置动作。我们可以将参数传递给动作，比如Ruby版本。bundler-cache参数将安装依赖项(Ruby中的gems)。</p><p id="612d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，我们可以lint我们的代码。Rubocop是Ruby的linter，一旦运行，要么产生一个0退出代码(成功)动作通过，要么产生一个1退出代码(失败)动作失败。如果有失败，可以在运行器的输出中查看。你可以在这里看到一个跑步者跑<a class="ae la" href="https://github.com/apeacock1991/devise/actions/runs/1802066006" rel="noopener ugc nofollow" target="_blank">的例子。</a></p><h2 id="c8e8" class="ng mf iv bd mg nl nm dn mk nn no dp mo lk np nq mq lo nr ns ms ls nt nu mu nv bi translated">使用GitHub动作作为状态检查</h2><p id="7140" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">如果我们只是在后台运行这个动作，也没多大用。工程师在合并他们的PR之前查看Actions选项卡的机会非常小。</p><p id="e639" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然而，GitHub允许你定义拉请求的<a class="ae la" href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks" rel="noopener ugc nofollow" target="_blank">状态检查</a>。可以将这些状态检查配置为仅在通过所有状态检查后才允许合并。</p><p id="712c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，工程师不必记得检查动作，我们可以确保林挺在PR被合并之前通过。这里有一个<a class="ae la" href="https://github.com/apeacock1991/devise/pull/1" rel="noopener ugc nofollow" target="_blank">公关</a>的例子，目前由于林挺失败而被封锁。</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="461b" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">测试应用程序</h1><p id="a824" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">如今，大多数应用程序和库都有某种形式的自动化测试。有很多工具可以运行您的测试，但是为什么不使用GitHub操作呢？</p><p id="0553" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下面是我如何为一个m C#存储库运行我的测试:</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="3776" class="ng mf iv nc b gy nh ni l nj nk">name: .NET<br/><br/>on:<br/>  push:<br/>    branches: [ main ]<br/><br/>jobs:<br/>  build:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>    - uses: actions/checkout@v2<br/>    - name: Setup .NET<br/>      uses: actions/setup-dotnet@v1<br/>      with:<br/>        dotnet-version: 3.1.x<br/>    - name: Restore<br/>      run: dotnet restore<br/>    - name: Build<br/>      run: dotnet build --no-restore<br/>    - name: Test<br/>      run: dotnet test --no-build --verbosity normal</span></pre><p id="2c80" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我不会像上次一样重复每一步，因为我们现在知道了动作的基本结构。尽管如此，还是有一些不同之处:</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="5882" class="ng mf iv nc b gy nh ni l nj nk">on:<br/>  push:<br/>    branches: [ main ]</span></pre><p id="5dea" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">首先，我们在每次推送时都运行测试——所以即使没有发出拉取请求，我们仍然在运行测试。这是非常宝贵的，因为工程师们通常希望在提交PR之前看到测试结果。</p><p id="b346" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">虽然我建议在每个分支的每次推送中都运行它，只是为了展示GitHub操作的灵活性，但是我已经指定了该操作只应该在主分支上运行。您还可以<a class="ae la" href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore" rel="noopener ugc nofollow" target="_blank">指定路径</a>，导致该操作仅在某些文件被更改时运行。</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="41c2" class="ng mf iv nc b gy nh ni l nj nk">- name: Setup .NET<br/>  uses: actions/setup-dotnet@v1<br/>    with:<br/>     dotnet-version: 3.1.x<br/>- name: Restore<br/>  run: dotnet restore<br/>- name: Build<br/>  run: dotnet build --no-restore<br/>- name: Test<br/>  run: dotnet test --no-build --verbosity normal</span></pre><p id="b61d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">第一步是安装。GitHub自己也为其提供了一个动作。那个动作使。NET CLI，我们可以在那里构建和运行我们的测试。</p><p id="bca4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">与上面的林挺类似，相关的退出代码将根据测试是通过还是失败而返回。<a class="ae la" href="https://github.com/apeacock1991/sustainable-api-architecture/actions/runs/1802057704" rel="noopener ugc nofollow" target="_blank">这里有一个例子</a>它运行和传递。与林挺类似，我们可以使用状态检查来确保只有通过绿色测试的分支才能被合并。</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="97d3" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">扫描应用程序的漏洞</h1><p id="f48d" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">最后，我要介绍的最后一个简单用例是扫描您的存储库的漏洞。这次我们将利用<a class="ae la" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> GitHub市场</a>的力量，因为使用动作的一大卖点是你可以立即使用的免费动作越来越多。</p><p id="f737" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我将使用<a class="ae la" href="https://github.com/marketplace/actions/snyk" rel="noopener ugc nofollow" target="_blank"> Snyk的GitHub动作</a>，因为我发现它很容易设置，并且提供对许多语言的支持——包括Node，。NET，Scala和Docker。</p><p id="1fef" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你可以在这里注册一个免费的Snyk账户<a class="ae la" href="https://snyk.io/plans/" rel="noopener ugc nofollow" target="_blank">来开始(更大的组织可以使用付费计划)。您需要一个帐户来访问您的API令牌。一旦有了API令牌，设置动作就很简单了:</a></p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="9299" class="ng mf iv nc b gy nh ni l nj nk">name: Synk Security Checks</span><span id="f400" class="ng mf iv nc b gy nw ni l nj nk">on:<br/>  push:</span><span id="f021" class="ng mf iv nc b gy nw ni l nj nk">jobs:<br/>  security:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: actions/checkout@master<br/>      - name: Run Snyk to check for vulnerabilities<br/>        uses: snyk/actions/node@master<br/>        env:<br/>          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}</span></pre><p id="e572" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我以Node为例，但是您可以将动作更改为任何支持的语言。这个动作引入了一个新概念，那就是环境变量。</p><p id="ac42" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了运行，这个动作需要设置<code class="fe nx ny nz nc b">SNYK_TOKEN</code>环境变量。我们不想在存储库中以纯文本形式存储机密，但是您可以设置机密，方法是转到存储库，单击“设置”，然后在左侧菜单中，选择“机密”和“操作”。</p><p id="86f9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在该页面中，您可以定义由机密名称及其相应值组成的键-值对。一旦保存，您就可以使用<code class="fe nx ny nz nc b">${{ secrets.YOUR_SECRET_NAME }}</code>访问正在运行动作的存储库的所有机密。</p></div><div class="ab cl lx ly hz lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="io ip iq ir is"><h1 id="1cbb" class="me mf iv bd mg mh mi mj mk ml mm mn mo kb mp kc mq ke mr kf ms kh mt ki mu mv bi translated">最后的想法</h1><p id="cf7b" class="pw-post-body-paragraph lb lc iv ld b le mw jw lg lh mx jz lj lk my lm ln lo mz lq lr ls na lu lv lw io bi translated">希望您现在对GitHub操作有了基本的了解。这只是一个开始，随着采用的增加，我希望可用操作的数量会显著增加。</p><p id="996a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们在本文中看到的操作非常简单——但是非常有效——但是我知道有些公司在GitHub Actions上运行他们的整个部署管道，所以更复杂的用例也适合他们。如果你被说服了，我建议你去看看GitHub的完整文档。</p><pre class="kl km kn ko gt nb nc nd ne aw nf bi"><span id="07fa" class="ng mf iv nc b gy nh ni l nj nk"><strong class="nc iw">Want to Connect?</strong></span><span id="cb73" class="ng mf iv nc b gy nw ni l nj nk">I run a free newsletter providing fortnightly technical book recommendations, including my key takeaways from the books. Interested? <a class="ae la" href="https://subscribe.technicalbookclub.com/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=simplegithubactions" rel="noopener ugc nofollow" target="_blank">Sign up here!</a></span></pre></div></div>    
</body>
</html>