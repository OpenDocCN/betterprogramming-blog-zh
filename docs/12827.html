<html>
<head>
<title>An In-Depth Analysis of the MVCC Principle of MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL MVCC原理的深入分析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/in-depth-analysis-of-the-mvcc-principle-of-mysql-c4a5529e4f5?source=collection_archive---------6-----------------------#2022-07-05">https://betterprogramming.pub/in-depth-analysis-of-the-mvcc-principle-of-mysql-c4a5529e4f5?source=collection_archive---------6-----------------------#2022-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4580" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MySQL和MVCC</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9eba21aa806e1f5b15932f01597c72ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_BXFDpZe3efZyHJJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lianamikah?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莉安娜·米卡</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="27e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当多个事务对同一行数据进行操作时，会出现各种并发问题。MySQL通过四个隔离级别解决了这些问题。</p><p id="3d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">read uncommitted隔离级别是最松的，基本上不做隔离，所以实现起来非常简单。</p><p id="7a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读-提交隔离级别是每次执行一条语句(包括查询和更新语句)，都会生成一个一致的视图，以确保当前事务可以看到其他事务提交的数据。</p><p id="1d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可重复读取隔离级别的实现是每个事务在打开时都会生成一个一致的视图。提交其他事务时，不会影响当前事务中的数据。为了保证这一点，MySQL是通过多版本控制机制MVCC来实现的。</p><p id="0f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可序列化隔离级别的隔离级别比较高，是通过锁来实现的，所以MySQL有一套锁机制。</p><p id="db16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读提交和可重复读隔离级别都依赖于MVCC多版本控制机制的实现。今天我们将讨论MySQL中的MVCC多版本控制机制。</p><h1 id="7e23" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">MVCC多版本控制机制</h1><p id="02f3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">MVCC机制使用了<code class="fe ms mt mu mv b">read-view</code>机制和<code class="fe ms mt mu mv b">undo log</code>版本链比较机制，使得不同的事务会根据数据版本链比较规则读取版本链上相同数据的不同版本。</p><h2 id="d3b9" class="mw lw it bd lx mx my dn mb mz na dp mf li nb nc mh lm nd ne mj lq nf ng ml nh bi translated"><strong class="ak"> <em class="ni">撤销日志版本链</em> </strong></h2><p id="efe9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">交易开通时，会先申请一个交易id: <code class="fe ms mt mu mv b">transaction-id</code></p><p id="a60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当事务修改一行数据时，Mysql会保留修改前数据的撤销回滚日志，并将transaction id: transaction id赋给版本记录中的字段<code class="fe ms mt mu mv b">trx_id</code>。</p><p id="9090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些撤销日志串联起来，形成一个历史版本链，如图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/b713c3622ba386c8891ac3fbeb10fab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5N2NF4rnpHhLOaBb-W5V-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="e298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这里记录的版本并不是真实的物理存在。真实物理存在的只有最新的记录，其他历史记录都来源于回滚日志。</p><h2 id="652c" class="mw lw it bd lx mx my dn mb mz na dp mf li nb nc mh lm nd ne mj lq nf ng ml nh bi translated"><strong class="ak"> <em class="ni">阅读-查看机制</em> </strong></h2><p id="1ae0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">可重复读取隔离级别和提交读取隔离级别是通过生成一致的视图(即读取视图)来实现的。</p><p id="8a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是一致的观点？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/aa51b0ac05c87807b1ae3fc247ddc4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSiOdNLS54ajiXzSSKpfYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="2107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个事务启动时，InnoDB为该事务构建一个数组，以存储该事务启动时所有活动的事务id。活动意味着它已启动，但尚未提交。</p><p id="671c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组中id的最小值为低位，最大值+ 1记录为高位，这是一致性视图。</p><p id="4839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个事务在进行查询时，会根据一致性视图的可见性规则，推导出撤销日志版本链中相应的数据。</p><h1 id="6cf2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> <em class="ni">一致视图的可见性规则</em> </strong></h1><ul class=""><li id="67d4" class="nl nm it lb b lc mn lf mo li nn lm no lq np lu nq nr ns nt bi translated">如果当前事务<code class="fe ms mt mu mv b">id</code>落在紫色部分，说明这个版本是提交的事务或者是当前事务自己生成的，这个数据是可见的。</li><li id="ac78" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">如果当前事务<code class="fe ms mt mu mv b">id</code>落在蓝色部分，说明这个版本是未来开始的一个事务生成的，肯定是看不见的。</li><li id="6ad5" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">如果当前交易<code class="fe ms mt mu mv b">id</code>属于橙色部分，则包括两种情况:</li></ul><p id="965b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">A.如果行<code class="fe ms mt mu mv b">trx_id</code>在数组中，说明这个版本是由一个还没有提交的事务生成的，不可见。</p><p id="83a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">B.如果行<code class="fe ms mt mu mv b">trx_id</code>不在数组中，意味着这个版本是由提交的事务生成的，可见。</p><h1 id="a054" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">案例1 </strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/7ed8570bfce9d4c2b155004d90187b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iw4odjLy_QmYxIVGxAj_lA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="0e18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图中交易A查询的<code class="fe ms mt mu mv b">i</code>是什么？先来分析一下。</p><p id="3e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照从上到下打开事务的顺序，每一个事务对应的一致性视图如下:</p><p id="0e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">transaction A [11]</code>的一致性视图数组</p><p id="773a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">transaction B [11,12]</code>的一致性视图数组</p><p id="ad4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">transaction C [11, 12, 13]</code>的一致性视图阵列</p><p id="08be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当查询事务A时，撤销日志版本链是:</p><pre class="kj kk kl km gt oa mv ob oc aw od bi"><span id="4557" class="mw lw it mv b gy oe of l og oh">{trx_id=11,id=1,i=10,roll_pointer=0}&gt;&gt;&gt;{trx_id=13,id=1,i=11,roll_pointer=1}&gt;&gt;&gt;{trx_id=12,id=1,i=12,roll_pointer=2}</span></pre><p id="a18e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">{}</code>代表版本记录。</p><p id="ca47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">&gt;&gt;&gt;</code>代表回滚日志undo log。</p><p id="5e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询交易A时，交易B和交易C属于未来交易，对交易A不可见。</p><p id="1aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以交易A查询的数据是通过最新的数据记录:<code class="fe ms mt mu mv b">i = 10</code>按照<code class="fe ms mt mu mv b">undo log</code>连续前滚和回滚得到的数据。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h1 id="32cc" class="lv lw it bd lx ly op ma mb mc oq me mf jz or ka mh kc os kd mj kf ot kg ml mm bi translated"><strong class="ak">案例二</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f10ce460343d87bc83a47cfa132b6952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DX6EgEn41BH1rZuymP50oQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="bd79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交易A查询1的结果是什么？</p><p id="c1ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交易A查询2的结果是什么？</p><p id="0601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据一致性视图可见性规则分析，对于事务A，事务B是未来事务，对事务A是不可见的，所以查询结果i=10。</p><p id="465e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询2的结果是<code class="fe ms mt mu mv b">i = 12</code>，为什么？我们先来看两个概念。</p><p id="b89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在可重复读取隔离级别中，通过回滚日志来查找相应版本记录的读取方法是一致读取。</p><p id="a5f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是回滚，你只需要读取记录的最新版本就是当前读取的。</p><p id="0e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果事务中有update语句，update语句以当前读取模式读取版本记录中的最新数据，然后执行更新操作，所以上图中的查询结果是<code class="fe ms mt mu mv b">i = 12</code>。</p><p id="8ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下两种查询方法也是当前读取的:</p><pre class="kj kk kl km gt oa mv ob oc aw od bi"><span id="63a6" class="mw lw it mv b gy oe of l og oh">select k from t where id=1 lock in share mode;<br/><br/>select k from t where id=1 for update;</span></pre><p id="a34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是MVCC机制。根据其规则，该机制仅在可重复读取隔离级别和读取提交隔离级别下可用。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="34b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ov">感谢您阅读这篇文章。</em></p><p id="fe99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ov">敬请关注。</em></p></div></div>    
</body>
</html>