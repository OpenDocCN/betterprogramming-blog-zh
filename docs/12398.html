<html>
<head>
<title>Should You Use ForEach or InjectInto in Eclipse Collections?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Eclipse集合中应该使用ForEach还是InjectInto？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-use-foreach-or-injectinto-in-eclipse-collections-5f7f791022e2?source=collection_archive---------10-----------------------#2022-06-02">https://betterprogramming.pub/should-you-use-foreach-or-injectinto-in-eclipse-collections-5f7f791022e2?source=collection_archive---------10-----------------------#2022-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="771d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习<a class="ae kj" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中的<code class="fe kf kg kh ki b">forEach</code>和<code class="fe kf kg kh ki b">injectInto</code>模式。</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/a40abd0bf31688c9802db038434f1a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUH6ML6i-ArCODyDbXOh4A.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">Eclipse集合中的许多forEach / injectInto模式</p></figure><h1 id="41e8" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">是forEach还是injectInto？</h1><p id="ef5d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在<a class="ae kj" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>、<code class="fe kf kg kh ki b">forEach</code>和<code class="fe kf kg kh ki b">injectInto</code>都是内部迭代器，提供了最基本的迭代模式。开发人员可以使用这两种模式来完成大量的迭代任务。作为内部迭代器，这些方法封装了“如何”迭代集合元素的实现细节，并让开发人员使用lambda来指定应该应用于集合中每个元素的行为。</p><p id="81e9" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe kf kg kh ki b">forEach</code>和<code class="fe kf kg kh ki b">injectInto</code>模式可以用作许多其他迭代模式的构建模块(例如<code class="fe kf kg kh ki b">select</code>、<code class="fe kf kg kh ki b">reject</code>、<code class="fe kf kg kh ki b">collect</code>等)。).这两种模式都从集合的开头到结尾遍历集合，并执行一些接收集合的每个元素作为参数的操作。<code class="fe kf kg kh ki b">forEach</code>和<code class="fe kf kg kh ki b">injectInto</code>模式都不能有效地用于实现任何短路模式(例如<code class="fe kf kg kh ki b">detect</code>、<code class="fe kf kg kh ki b">anySatisfy</code>、<code class="fe kf kg kh ki b">allSatisfy</code>、<code class="fe kf kg kh ki b">noneSatisfy</code>)。</p><p id="8c51" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe kf kg kh ki b">forEach</code>和<code class="fe kf kg kh ki b">injectInto</code>的功能总结如下。</p><ul class=""><li id="62aa" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><code class="fe kf kg kh ki b">forEach</code>接受一个参数<code class="fe kf kg kh ki b">Procedure</code>并返回<code class="fe kf kg kh ki b">void</code>。集合中的每个元素都被传递给<code class="fe kf kg kh ki b">Procedure</code>。</li><li id="1719" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><code class="fe kf kg kh ki b">injectInto</code>举一反二<code class="fe kf kg kh ki b">Function2</code>。一个值作为<code class="fe kf kg kh ki b">Function2</code>的第一个参数和集合的每个元素一起被注入。该方法返回最后一个元素处理后<code class="fe kf kg kh ki b">Function2</code>返回的最终结果。</li></ul><p id="702a" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这两种模式都有专门化。<code class="fe kf kg kh ki b">injectInto</code>模式比<code class="fe kf kg kh ki b">forEach</code>有更多的原语专门化，因为<code class="fe kf kg kh ki b">injectInto</code>返回某种类型，它可能返回八种原语类型之一，或<code class="fe kf kg kh ki b">Object</code>。<code class="fe kf kg kh ki b">forEach</code>模式总是返回<code class="fe kf kg kh ki b">void</code>。</p><p id="b79f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe kf kg kh ki b">injectInto</code>能做而<code class="fe kf kg kh ki b">forEach</code>不能做的事情之一是执行一个<a class="ae kj" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">副作用</a>自由操作。有了<code class="fe kf kg kh ki b">forEach</code>，副作用总会在某个地方发生。这就是它的目的——让这个系列的元素产生副作用。可能有一个突变应用于集合的一个元素，或者一个lambda范围内的一个变量的突变，或者这个元素被打印到<code class="fe kf kg kh ki b">System.out</code>等等。</p><p id="c90d" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">使用<code class="fe kf kg kh ki b">injectInto</code>，可以执行无副作用的操作，因为它注入、返回和重新注入来自双参数<code class="fe kf kg kh ki b">Function</code>的一些结果。注入和返回的值可能是不可变的，比如一个<code class="fe kf kg kh ki b">String</code>或<code class="fe kf kg kh ki b">Integer</code>或一个原始值。</p><p id="9d14" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我将展示一些使用<code class="fe kf kg kh ki b">forEach</code>和<code class="fe kf kg kh ki b">injectInto</code>解决类似问题的例子。这应该开始清楚地表明，什么时候一种模式比另一种模式更合适或更理想。一个比另一个更好的答案将留给你，读者。在某些情况下，<code class="fe kf kg kh ki b">forEach</code>会更具可读性。在许多情况下，<code class="fe kf kg kh ki b">injectInto</code>将更加灵活、安全和/或高效。</p><p id="ef06" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">以下是我将展示的例子:</p><ul class=""><li id="a91e" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">数数</li><li id="5a17" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">总和</li><li id="0779" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">转换为集合</li></ul><h1 id="ddf9" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">示例:计数</h1><p id="4798" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在下面的例子中，我将对a <code class="fe kf kg kh ki b">MutableList&lt;Integer&gt;</code>和<code class="fe kf kg kh ki b">MutableIntList</code>中包含的偶数整数进行计数。在Eclipse集合中的对象和原始集合上都定义了一个名为<code class="fe kf kg kh ki b">count</code>的方法，该方法将一个<code class="fe kf kg kh ki b">Predicate</code>作为参数。这些例子的目的是展示使用<code class="fe kf kg kh ki b">forEach</code>或<code class="fe kf kg kh ki b">injectInto</code>模式实现<code class="fe kf kg kh ki b">count</code>的一些选项。</p><h2 id="bb06" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">1.计数:forEach(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nt"><img src="../Images/9102ebbce577b3aee510331fc143a447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9ANuasC8B28jn30ngHMKQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用forEach计算对象列表中的偶数</p></figure><p id="a709" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我必须创建一个可变的<code class="fe kf kg kh ki b">Counter</code>来记录偶数值的总数。我使用三元运算符编写了一个简化的if表达式，以确定是将值<code class="fe kf kg kh ki b">1</code>还是<code class="fe kf kg kh ki b">0</code>添加到<code class="fe kf kg kh ki b">Counter</code>中。</p><h2 id="8e13" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">2.计数:forEach(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nu"><img src="../Images/bb8a94e0e712746fdc4548746051fde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnuKkSFSocNVgbyjmuN70Q.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用forEach计算基元列表中的偶数</p></figure><p id="d571" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对象和原语列表上的<code class="fe kf kg kh ki b">forEach</code>之间的唯一区别是原语<code class="fe kf kg kh ki b">List</code>中的<code class="fe kf kg kh ki b">int</code>值不需要像对象<code class="fe kf kg kh ki b">List</code>中的<code class="fe kf kg kh ki b">Integer</code>值那样取消装箱。这种方法仍然需要有一个有效的final可变的<code class="fe kf kg kh ki b">Counter</code>对象在lambda中递增。</p><h2 id="be64" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">3.计数:注入(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nv"><img src="../Images/693d96cc720c2db0850df2efa0886808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8m9DAoQdHuwmXyVx6r2IA.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto计算对象列表中的偶数</p></figure><p id="f848" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这种实现是无副作用的。我们从初始<code class="fe kf kg kh ki b">Integer</code>值<code class="fe kf kg kh ki b">0</code>开始，如果结果是偶数，则为每个元素添加一个<code class="fe kf kg kh ki b">1</code>或<code class="fe kf kg kh ki b">0</code>。这里有很多取消装箱和自动装箱的操作，因为每个函数的结果都会取消装箱值，然后自动装箱结果。</p><h2 id="7245" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">4.计数:injectInto(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nw"><img src="../Images/fd3c7d19023973812652f4a5d575ca18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISt861r1w0eBa5FM4d0FOQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto计算基元列表中的偶数</p></figure><p id="045f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">本例使用了一个<code class="fe kf kg kh ki b">MutableIntList</code>，它不会将<code class="fe kf kg kh ki b">List</code>中的<code class="fe kf kg kh ki b">int</code>值装箱。<code class="fe kf kg kh ki b">injectInto</code>的结果仍然是一个对象，所以每个元素的结果都是自动装箱的。</p><h2 id="cdc2" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">5.计数:injectIntoInt(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nw"><img src="../Images/3ef2db696eb48afa832f6002771580f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BRkuqLH09SJVpVr4YQuhg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectIntoInt计算对象列表中的偶数</p></figure><p id="d946" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">专门化<code class="fe kf kg kh ki b">injectIntoInt</code>允许将<code class="fe kf kg kh ki b">0</code>的<code class="fe kf kg kh ki b">int</code>值注入到迭代中，并作为结果返回。这里不会对结果进行自动装箱，但是会对值进行取消装箱，以便测试它们是否相等。这种解决方案既没有副作用，又不会导致自动装箱。然而，整数<code class="fe kf kg kh ki b">List</code>中的值仍然被装箱，因为它是一个<code class="fe kf kg kh ki b">MutableList&lt;Integer&gt;</code>。</p><h2 id="1105" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">6.count:injection point(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nx"><img src="../Images/3b6a430220f05cd574e11e011f58e0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7MV8PLO4zRwh-Ggl5mGmg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectIntoInt计算基元列表中的事件数</p></figure><p id="f4ef" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对<code class="fe kf kg kh ki b">MutableIntList</code>的特殊化<code class="fe kf kg kh ki b">injectIntoInt</code>允许实现无副作用的计数，没有将<code class="fe kf kg kh ki b">int</code>值装箱到列表或计算中的<code class="fe kf kg kh ki b">Integer</code>对象。</p><h1 id="4a23" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">示例:总和</h1><p id="de75" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在下面的例子中，我将对包含在一个<code class="fe kf kg kh ki b">MutableList&lt;Integer&gt;</code>和<code class="fe kf kg kh ki b">MutableIntList</code>中的整数求和。在Eclipse集合中，在对象集合上定义了一个名为<code class="fe kf kg kh ki b">sumOfInt</code>的方法，而在原始集合上只定义了<code class="fe kf kg kh ki b">sum</code>。这些例子的目的是展示使用<code class="fe kf kg kh ki b">forEach</code>或<code class="fe kf kg kh ki b">injectInto</code>模式实现<code class="fe kf kg kh ki b">sum</code>的一些选项。</p><h2 id="bfd1" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">1.Sum: forEach(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ny"><img src="../Images/ef9ea1710be87c9cc0928fcb2ce8933a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZCQpkeIG8-KHfSG-FzreQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用forEach对对象列表中的数字求和</p></figure><p id="78bd" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我使用来自JDK的<code class="fe kf kg kh ki b">LongAdder</code>来累加总和。在<code class="fe kf kg kh ki b">LongAdder</code>上有一个<code class="fe kf kg kh ki b">add</code>方法接受一个<code class="fe kf kg kh ki b">long</code>。整数列表中的每个<code class="fe kf kg kh ki b">Integer</code>对象都被取消装箱并转换为一个<code class="fe kf kg kh ki b">long</code>。</p><h2 id="7d7d" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">2.Sum: forEach(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1364c3872d174201cb8daf6e2b6097d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*33xj6U4RHrX_QvpxJuUFRA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用forEach对原始列表中的数字求和</p></figure><p id="e03b" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">带有<code class="fe kf kg kh ki b">forEach</code>的sum的原始版本本质上与对象版本相同，只是不需要在调用<code class="fe kf kg kh ki b">LongAdder</code>上的<code class="fe kf kg kh ki b">add</code>时取消<code class="fe kf kg kh ki b">Integer</code>对象的装箱。</p><h2 id="9c0a" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">3.Sum: injectInto(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oa"><img src="../Images/eafd47edd772e53ca47acff9a2524396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aqVtPVdkDrhg5NKL8d28CQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto对对象列表中的数字求和</p></figure><p id="cdf9" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">通过注入一个初始值<code class="fe kf kg kh ki b">Long.valueOf(0)</code>，返回类型<code class="fe kf kg kh ki b">injectInto</code>将会是一个<code class="fe kf kg kh ki b">Long</code>。我使用了将两个<code class="fe kf kg kh ki b">long</code>值作为参数的<code class="fe kf kg kh ki b">Long::sum</code>方法引用。结果从<code class="fe kf kg kh ki b">Long</code>解装箱到<code class="fe kf kg kh ki b">long</code>并且<code class="fe kf kg kh ki b">List</code>中的<code class="fe kf kg kh ki b">Integer</code>值解装箱并转换到<code class="fe kf kg kh ki b">long</code>。</p><h2 id="0e5b" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">4.Sum: injectInto(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ob"><img src="../Images/d68b28bc63d4f7aceb2fed403ac387f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4m8nS2T4aSjX2EeGOjnTg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto对原始列表中的数字求和</p></figure><p id="9593" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">sum使用<code class="fe kf kg kh ki b">injectInto</code>使用<code class="fe kf kg kh ki b">Long</code>作为注入值的原始版本与对象版本本质上是一样的。一个区别是不需要对<code class="fe kf kg kh ki b">Integer</code>对象进行拆箱。</p><h2 id="ff5d" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">5.sum:inject long(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ob"><img src="../Images/be77ac38856b6fae7b4445f8a2a1aa21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPdzY6TNP515FxS9h199Hg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectIntoLong对对象列表中的数字求和</p></figure><p id="178b" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在对象列表上使用<code class="fe kf kg kh ki b">injectIntoLong</code>并注入初始的<code class="fe kf kg kh ki b">long</code>值<code class="fe kf kg kh ki b">0L</code>，那么<code class="fe kf kg kh ki b">injectIntoLong</code>的返回类型就是原语<code class="fe kf kg kh ki b">long</code>。我使用了将两个<code class="fe kf kg kh ki b">long</code>值作为参数的<code class="fe kf kg kh ki b">Long::sum</code>方法引用。结果作为<code class="fe kf kg kh ki b">long</code>传入，列表中的<code class="fe kf kg kh ki b">Integer</code>值被取消装箱并转换为<code class="fe kf kg kh ki b">long</code>。</p><h2 id="af42" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">6.sum:inject long(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oc"><img src="../Images/aacf45e80598403f9d02e0c55ab1c046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSq4FoVabKgNowCRLJO8aQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectIntoLong对原始列表中的数字求和</p></figure><p id="8b9e" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在原语列表上使用<code class="fe kf kg kh ki b">injectIntoLong</code>并注入<code class="fe kf kg kh ki b">0L</code>的初始<code class="fe kf kg kh ki b">long</code>值，<code class="fe kf kg kh ki b">injectIntoLong</code>的返回类型是原语<code class="fe kf kg kh ki b">long</code>。我使用了Long::sum方法引用，它将两个<code class="fe kf kg kh ki b">long</code>值作为参数。结果以long形式传入，原语列表中的<code class="fe kf kg kh ki b">int</code>值被转换为<code class="fe kf kg kh ki b">long</code>。</p><h1 id="b8a7" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">示例:转换为集合</h1><p id="4ba3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在下面的例子中，我将把包含在一个<code class="fe kf kg kh ki b">MutableList&lt;Integer&gt;</code>或<code class="fe kf kg kh ki b">MutableIntList</code>中的整数加到一个<code class="fe kf kg kh ki b">MutableSet&lt;Integer&gt;</code>或<code class="fe kf kg kh ki b">MutableIntSet</code>中。我还将展示如何使用<code class="fe kf kg kh ki b">injectInto</code>添加到<code class="fe kf kg kh ki b">ImmutableSet&lt;Integer&gt;</code>或<code class="fe kf kg kh ki b">ImmutableIntSet</code>中。</p><p id="fa10" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对象和原语集合上有用于从一种类型的容器转换到另一种类型的转换器方法(例如，<code class="fe kf kg kh ki b">toSet</code>、<code class="fe kf kg kh ki b">toImmutableSet</code>)。这些例子的目的是展示使用<code class="fe kf kg kh ki b">forEach</code>或<code class="fe kf kg kh ki b">injectInto</code>模式实现<code class="fe kf kg kh ki b">toSet</code>和<code class="fe kf kg kh ki b">toImmutableSet</code>的一些选项。</p><h2 id="bdfc" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">1.到可变集:forEach(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi od"><img src="../Images/591bde50774068a39b429be6e0358e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qajLt4SQKDWExixSlOcczQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用forEach向可变集合添加列表元素</p></figure><p id="b957" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我创建了一个名为<code class="fe kf kg kh ki b">set</code>的<code class="fe kf kg kh ki b">MutableSet&lt;Integer&gt;</code>来保存我想从<code class="fe kf kg kh ki b">integers</code>转移的元素。然后使用forEach，我传递方法引用<code class="fe kf kg kh ki b">set::add</code>。这段代码非常简单明了。</p><h2 id="f8e4" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">2.To可变Int Set: forEach(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oe"><img src="../Images/8d8702d3d0462399569940ee2c979a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iR4tylsB2uqNLCebHtRiQw.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用forEach将MutableIntList的元素添加到MutableIntSet中</p></figure><p id="94a1" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">原始版本与目标版本基本相同，目标<code class="fe kf kg kh ki b">set</code>为<code class="fe kf kg kh ki b">MutableIntSet</code>。</p><h2 id="b152" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">3.To MutableSet: injectInto(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi of"><img src="../Images/d5222523028803d1c0923e3039c018ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvxqy0wLD6R_xN_QO1xtEw.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto将可变列表的元素添加到可变集合中</p></figure><p id="1b11" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">使用<code class="fe kf kg kh ki b">injectInto</code>，我注入<code class="fe kf kg kh ki b">MutableSet&lt;Integer&gt;</code>作为<code class="fe kf kg kh ki b">Function2</code>的第一个参数。我使用了与<code class="fe kf kg kh ki b">Function2</code>所需的双参数类型相匹配的<code class="fe kf kg kh ki b">MutableSet::with</code>方法引用。</p><p id="b633" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">第一个参数类型是<code class="fe kf kg kh ki b">MutableSet&lt;Integer&gt;</code>，第二个参数类型是集合中每个元素的类型(<code class="fe kf kg kh ki b">Integer</code>)。</p><p id="1a16" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">Eclipse集合中任何<code class="fe kf kg kh ki b">MutableCollection</code>上的<code class="fe kf kg kh ki b">with</code>的返回类型是集合类型本身，因为<code class="fe kf kg kh ki b">with</code>调用<code class="fe kf kg kh ki b">add</code>然后返回<code class="fe kf kg kh ki b">this</code>。</p><h2 id="679b" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">4.To MutableIntSet: injectInto(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi og"><img src="../Images/5d1b4c1892025d89ea86c1e66fb2f652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QiRgb2PVbfruhRSJP3NMxA.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto将MutableIntList的元素添加到MutableIntSet中</p></figure><p id="68e3" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">原语版本与对象版本基本相同，目标<code class="fe kf kg kh ki b">set</code>为<code class="fe kf kg kh ki b">MutableIntSet</code>。</p><h2 id="6973" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">5.To ImmutableSet: injectInto(对象列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oh"><img src="../Images/3178bb0b92c01a3dcf99e7b328c03630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2Tm8HBpU8mXXXBqa3fWUg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto将可变列表的元素添加到不可变集合中</p></figure><p id="28b5" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">将一个<code class="fe kf kg kh ki b">MutableList</code>转换成一个<code class="fe kf kg kh ki b">ImmutableSet</code>是展示<code class="fe kf kg kh ki b">injectInto</code>相对于<code class="fe kf kg kh ki b">forEach</code>的灵活性的另一个例子。一只<code class="fe kf kg kh ki b">ImmutableSet</code>没有变异方法。没有像<code class="fe kf kg kh ki b">MutableSet</code>那样的<code class="fe kf kg kh ki b">add</code>方法。有一个<code class="fe kf kg kh ki b">newWith</code>方法，它通过复制原始集合并添加一个元素来创建一个新的<code class="fe kf kg kh ki b">ImmutableSet</code>，从而创建一个新的<code class="fe kf kg kh ki b">ImmutableSet</code>。我将一个空的<code class="fe kf kg kh ki b">ImmutableSet</code>和一个对<code class="fe kf kg kh ki b">ImmutableSet::newWith</code>的方法引用一起传递给<code class="fe kf kg kh ki b">injectInto</code>。</p><h2 id="dd16" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">6.到不可变的Int Set: injectInto(原始列表)</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oi"><img src="../Images/033ff2478635d8390dddd410f7c6f740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-4BSIFvflmSK6lViUa0bA.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">使用injectInto将MutableIntList的元素添加到ImmutableIntSet中</p></figure><p id="bc7f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">原语版本与对象版本基本相同，目标<code class="fe kf kg kh ki b">set</code>为<code class="fe kf kg kh ki b">MutableIntSet</code>。</p><h1 id="4042" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">forEach的其他示例</h1><p id="0525" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">有时候你可能需要一个索引。谢天谢地，在Eclipse集合中，有用于这个目的的<code class="fe kf kg kh ki b">forEachWithIndex</code>。这里有一个博客描述了提供索引的方法，包括<code class="fe kf kg kh ki b">forEachWithIndex</code>。</p><div class="oj ok gp gr ol om"><a href="https://medium.com/javarevisited/i-need-an-index-with-this-list-iteration-method-1e339fd55ed7" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">我需要这个列表迭代方法的索引</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">使用外部和内部迭代器通过索引在Java中对列表进行迭代</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ku om"/></div></div></a></div><p id="de68" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">还有一个博客描述了一种叫做<code class="fe kf kg kh ki b">forEachInBoth</code>的<code class="fe kf kg kh ki b">forEach</code>的专门形式。自从这篇博客开始写以来，我已经将<code class="fe kf kg kh ki b">forEachInBoth</code>直接添加到Eclipse集合中的对象和原始<code class="fe kf kg kh ki b">List</code>容器中。</p><div class="oj ok gp gr ol om"><a href="https://donraab.medium.com/mysterious-eclipse-collections-apis-foreachinboth-2102912f1eee" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">神秘的Eclipse集合API:forEachInBoth</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">有时API很长时间都没有被发现</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">donraab.medium.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ku om"/></div></div></a></div><h1 id="b388" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">注入的其他示例</h1><p id="7649" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">有几个博客涵盖了更多关于<code class="fe kf kg kh ki b">injectInto</code>的例子以及<code class="fe kf kg kh ki b">injectInto</code>的特殊形式，比如<code class="fe kf kg kh ki b">injectIntoKeyValue</code>。下面的博客涵盖了一些<code class="fe kf kg kh ki b">injectInto</code>的一般例子。</p><div class="oj ok gp gr ol om"><a href="https://donraab.medium.com/ec-by-example-injectinto-923a35c3b0cd" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">EC示例:注入</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">了解Eclipse集合中最通用、最灵活、最难理解的迭代模式之一。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">donraab.medium.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa ku om"/></div></div></a></div><p id="2178" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">下面的博客描述并展示了使用Eclipse集合中的地图和原始地图的例子。这篇博客是由艾米莉·罗比查德写的。</p><div class="oj ok gp gr ol om"><a href="https://emilie-robichaud.medium.com/injectintokeyvalue-in-eclipse-collections-8b29c9a4830d" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">Eclipse集合中的InjectIntoKeyValue</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在Eclipse Collections 11.1.0版本中，引入了一个新的API！最近，我致力于这个问题，以实现…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">emilie-robichaud.medium.com</p></div></div><div class="ov l"><div class="pf l ox oy oz ov pa ku om"/></div></div></a></div><h1 id="ac7e" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">关于forEach和injectInto的一些最终想法</h1><p id="569f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我发现用<code class="fe kf kg kh ki b">forEach</code>开始思考问题非常容易。如果你需要引起一些基本的副作用，<code class="fe kf kg kh ki b">forEach</code>是一个非常简单的去方法。</p><p id="d503" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">有时候在我用<code class="fe kf kg kh ki b">forEach</code>写了一些东西后，我想知道如果我用<code class="fe kf kg kh ki b">injectInto</code>同样的代码会是什么样子。如果我想要一个没有副作用的操作，或者在我传递给<code class="fe kf kg kh ki b">injectInto</code>的<code class="fe kf kg kh ki b">Function2</code>的上下文中完全控制任何副作用，我将使用<code class="fe kf kg kh ki b">injectInto</code>。</p><p id="a730" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">那么在Eclipse集合中应该使用<code class="fe kf kg kh ki b">forEach</code>还是<code class="fe kf kg kh ki b">injectInto</code>？与许多事情一样，最好的解决方案可能是主观的，我建议使用您认为最容易阅读和理解的代码。</p><p id="d81c" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你真的学会了如何将<code class="fe kf kg kh ki b">injectInto</code>添加到你的锦囊妙计中，你可能会开始对它的力量和灵活性感到惊讶，即使它的神秘从未完全消失。</p><h1 id="ec67" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">示例来源</h1><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="pg ph l"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">本博客中示例的来源要点</p></figure><pre class="kl km kn ko gt pi ki pj pk aw pl bi"><span id="b6a8" class="nh lb iq ki b gy pm pn l po pp"><strong class="ki ir">Want to Connect?</strong></span><span id="5e8e" class="nh lb iq ki b gy pq pn l po pp">I am a Project Lead and Committer for the <a class="ae kj" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank">Eclipse Collections</a> OSS project at the <a class="ae kj" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank">Eclipse Foundation</a>. <a class="ae kj" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank">Eclipse Collections</a> is open for <a class="ae kj" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank">contributions</a>. If you like the library, you can let us know by starring it on GitHub.</span></pre></div></div>    
</body>
</html>