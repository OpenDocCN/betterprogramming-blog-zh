<html>
<head>
<title>Docker Tips: All About the Build Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:关于构建上下文的所有内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-tips-about-the-build-context-dbc76505e178?source=collection_archive---------0-----------------------#2018-10-19">https://betterprogramming.pub/docker-tips-about-the-build-context-dbc76505e178?source=collection_archive---------0-----------------------#2018-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e7cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解什么是构建上下文以及如何优化它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eca4dbd8749c87fcbb9f799791d60da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0kUuptN7h1sCb5JAqL5Zg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们来看看这个构建上下文的东西！</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="a2c0" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是构建上下文？</h1><p id="9d56" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">让我们从用于构建Docker映像的命令开始:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3be5" class="my lg it mu b gy mz na l nb nc">$ docker build [OPTIONS] PATH | URL | -</span></pre><p id="b65f" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">构建上下文是位于指定路径或URL的一组文件。这些文件在构建过程中被发送到Docker守护进程，这样它就可以在映像的文件系统中使用它们。</p><p id="549a" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">让我们来说明这一点。</p><h2 id="4f7b" class="my lg it bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv ns bi translated">使用路径</h2><p id="e4a5" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">假设我在文件夹<code class="fe nt nu nv mu b">/Users/luc/src/github.com/lucj/genx</code>中，其中包含了genx应用程序的源代码(简单的<a class="ae nw" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>应用程序，生成虚拟数据)。</p><p id="b1bc" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">通常，我们使用如下所示的命令来构建图像，Dockerfile位于项目文件夹的根目录下:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="efce" class="my lg it mu b gy mz na l nb nc">$ docker image build -t genx:1.0 .</span></pre><p id="7025" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">在这种情况下，构建上下文是当前文件夹的内容(“.”指定为命令的最后一个元素)。</p><h2 id="c1c4" class="my lg it bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv ns bi translated">使用URL</h2><p id="c1b1" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">同一个genx项目在<a class="ae nw" href="http://gitlab.com/lucj/genx" rel="noopener ugc nofollow" target="_blank"> GitLab </a>中管理，因此可以在本地构建引用GitLab存储库的映像:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="318c" class="my lg it mu b gy mz na l nb nc">$ docker image build -t genx:1.0 <a class="ae nw" href="mailto:git@gitlab.com" rel="noopener ugc nofollow" target="_blank">git@gitlab.com</a>:lucj/genx.git</span></pre><p id="11c0" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">在这种情况下，构建上下文是<code class="fe nt nu nv mu b">gitlab.com/lucj/genx</code>中的一组文件。</p><p id="7685" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">基本上，构建上下文至少包含将被复制到映像文件系统的应用程序代码，但是它通常包含映像中可能需要或不需要的许多其他内容。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="4a05" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">我应该过滤构建上下文吗？</h1><p id="2db2" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">是的，我们最好确保构建上下文只包含它真正需要的文件和文件夹。</p><p id="abd3" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">在一个由Git处理源代码的项目中，我们使用一个<code class="fe nt nu nv mu b">.gitignore</code>文件来确保私有数据保存在本地，而不是发送到GitHub/GitLab/BitBucket/etc。</p><p id="35aa" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">同样的事情也适用于Docker映像的构建阶段，因为守护进程使用一个<code class="fe nt nu nv mu b">.dockerignore</code>文件来过滤掉在构建上下文中不应该考虑的文件和文件夹。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="5046" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">如果我不使用. dockerignore呢？</h1><p id="3c3f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">然后，您将向Docker守护进程发送大量它不需要的内容，这些内容可以复制到映像文件系统中。</p><h2 id="a727" class="my lg it bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv ns bi translated">构建上下文中的巨大文件</h2><p id="4cb0" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">让我们考虑下面的Dockerfile。它使用一个<code class="fe nt nu nv mu b">nginx:1.14.0</code>基础映像，将当前文件夹的内容(<em class="nx">index.html</em>、<em class="nx"> css </em>、<em class="nx"> js、img </em>)复制到<a class="ae nw" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank">NGINX</a>(<em class="nx">/usr/share/NGINX/html</em>)提供的默认位置。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5a5b" class="my lg it mu b gy mz na l nb nc">FROM nginx:1.14.0<br/>COPY . /usr/share/nginx/html/</span></pre><p id="1667" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">当前文件夹的内容如下:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8953" class="my lg it mu b gy mz na l nb nc">$ tree -ah<br/>.<br/>├── [  48]  Dockerfile<br/>├── [  64]  css<br/>├── [  64]  images<br/>├── [  39]  index.html<br/>├── [  64]  js<br/>└── [1.8G]  ubuntu-18.04.1-desktop-amd64.iso</span></pre><p id="9a68" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">注意:你有没有注意到这个文件夹里的Ubuntu安装ISO(误放在这里)？当构建映像时，这个巨大的家伙被发送到守护进程并复制到映像中…显然，这不是我们想要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/ee4f826f48d631dbbb953abb586c9551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MAdNi7-1FNRqBgEF8vvqHw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当前文件夹内容被发送到守护程序(2G被发送到守护程序并被复制到图像层中)</p></figure><p id="1d22" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">注意:我不建议遵循这个例子。Docker守护进程一点也不喜欢它…<em class="nx"/>。(后来我甚至需要在MacBook Pro上重启它)。</p><p id="4a4f" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">但是，如果我们真的需要这个文件(只是为了好玩)，我们只需要创建一个<code class="fe nt nu nv mu b">.dockerignore</code>文件并在其中添加它的名字。我们应该加上<code class="fe nt nu nv mu b">*.iso</code>以防我们下载其他iso。</p><p id="9eb7" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">这样做，我们可以确保没有ISO文件将被发送到守护进程。</p><p id="69b6" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">好的，一个2 GB的ISO文件不太可能出现在当前的文件夹中，但是……该项目的Git历史呢，它也可能非常大。</p><h2 id="e4e2" class="my lg it bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv ns bi translated">Git历史</h2><p id="c7d4" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">让我们删除ISO文件，开始用Git处理这个项目。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="da40" class="my lg it mu b gy mz na l nb nc"><strong class="mu iu">$ git init</strong></span><span id="9fcb" class="my lg it mu b gy nz na l nb nc"><strong class="mu iu">$ tree -a</strong><br/>.<br/>├── .git<br/>│   ├── HEAD<br/>│   ├── branches<br/>│   ├── config<br/>│   ├── description<br/>│   ├── hooks<br/>│   │   ├── applypatch-msg.sample<br/>│   │   ├── commit-msg.sample<br/>│   │   ├── fsmonitor-watchman.sample<br/>│   │   ├── post-update.sample<br/>│   │   ├── pre-applypatch.sample<br/>│   │   ├── pre-commit.sample<br/>│   │   ├── pre-push.sample<br/>│   │   ├── pre-rebase.sample<br/>│   │   ├── pre-receive.sample<br/>│   │   ├── prepare-commit-msg.sample<br/>│   │   └── update.sample<br/>│   ├── info<br/>│   │   └── exclude<br/>│   ├── objects<br/>│   │   ├── info<br/>│   │   └── pack<br/>│   └── refs<br/>│       ├── heads<br/>│       └── tags<br/>├── Dockerfile<br/>├── css<br/>├── images<br/>├── index.html<br/>└── js</span></pre><p id="2bd1" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">然后我们创建图像:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6c7a" class="my lg it mu b gy mz na l nb nc"><strong class="mu iu">$ docker image build -t www:1.0 .<br/></strong>Sending build context to Docker daemon 40.96kB<br/>Step 1/2 : FROM nginx:1.14.0<br/> — -&gt; 86898218889a<br/>Step 2/2 : COPY . /usr/share/nginx/html/<br/> — -&gt; 973188e5d7a3<br/>Successfully built 973188e5d7a3<br/>Successfully tagged www:1.0</span></pre><p id="2361" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">看看里面有什么:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f1d6" class="my lg it mu b gy mz na l nb nc"><strong class="mu iu">$ docker run -ti www:1.0 bash<br/></strong>root@5d91b258bdc3:/# cd /usr/share/nginx/html/<br/>root@5d91b258bdc3:/usr/share/nginx/html# ls<br/>50x.html Dockerfile css images index.html js<br/>root@5d91b258bdc3:/usr/share/nginx/html# find .git/<br/>.git/<br/>.git/description<br/>.git/config<br/>.git/refs<br/>.git/refs/tags<br/>.git/refs/heads<br/>.git/hooks<br/>.git/hooks/applypatch-msg.sample<br/>.git/hooks/pre-push.sample<br/>.git/hooks/pre-rebase.sample<br/>.git/hooks/prepare-commit-msg.sample<br/>.git/hooks/post-update.sample<br/>.git/hooks/pre-applypatch.sample<br/>.git/hooks/update.sample<br/>.git/hooks/fsmonitor-watchman.sample<br/>.git/hooks/pre-commit.sample<br/>.git/hooks/commit-msg.sample<br/>.git/hooks/pre-receive.sample<br/>.git/objects<br/>.git/objects/pack<br/>.git/objects/info<br/>.git/HEAD<br/>.git/branches<br/>.git/info<br/>.git/info/exclude<br/>root@5d91b258bdc3:/usr/share/nginx/html#</span></pre><p id="caee" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">那里有一个<code class="fe nt nu nv mu b">.git</code>文件夹，包含了项目的版本历史，这可能是一个很大的文件夹。我们需要图像中的整个Git历史吗？不这么认为。然后我们应该创建一个<code class="fe nt nu nv mu b">.dockerignore</code>，并在里面添加<code class="fe nt nu nv mu b">.git</code>。</p><h2 id="f218" class="my lg it bd lh ni nj dn ll nk nl dp lp mg nm nn lr mk no np lt mo nq nr lv ns bi translated">资格证书</h2><p id="cad8" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">假设我在一个<a class="ae nw" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>应用程序上工作，该应用程序需要连接到一个外部<a class="ae nw" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>数据库。</p><p id="5ef8" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">当应用程序部署在swarm或Kubernetes集群上时，建议通过secret提供连接字符串。(如果想了解更多，可能会对这篇文章感兴趣:<a class="ae nw" href="https://medium.com/lucjuggery/from-env-variables-to-docker-secrets-bc8802cacdfd" rel="noopener"> <em class="nx">从env变量到Docker秘密</em> </a>)。)</p><p id="a56f" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">但是，在开发阶段，我们可能在当前文件夹中有这些凭证来测试应用程序。</p><p id="64e5" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">在我们的项目中有一个<code class="fe nt nu nv mu b">creds</code>文件夹怎么样？这很难看，但可以帮助，对不对？好吧，至少如果我们确保它不会到处复制。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="58c0" class="my lg it mu b gy mz na l nb nc"><strong class="mu iu">$ tree</strong><br/>.<br/>├── .git<br/>├── .gitignore<br/>├── Dockerfile<br/>├── app.js<br/>├── creds<br/>│ ├── mongo-preprod &lt;-- mongodb://user:pass@prep.db.com:27017/mydb<br/>│ ├── mongo-prod    &lt;-- mongodb://user:pass@prod.db.com:27017/mydb<br/>│ └── mongo-test    &lt;-- mongodb://user:pass@test.db.com:27017/mydb<br/>├── node_modules<br/>│ ├── ...<br/>└── package.json</span></pre><p id="7378" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">我有下面的<code class="fe nt nu nv mu b">.gitignore</code>文件<em class="nx">，</em>没问题，我的密码不会去GitHub:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a9e3" class="my lg it mu b gy mz na l nb nc">creds<br/>node_modules</span></pre><p id="2408" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">但是，我没有任何<code class="fe nt nu nv mu b">.dockerignore</code> <em class="nx">。然后，我的凭证文件将被传送到映像中。</em></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="63d9" class="my lg it mu b gy mz na l nb nc"># Building the image<br/><strong class="mu iu">$ docker build -t myapp:1.0 .</strong></span><span id="0c2f" class="my lg it mu b gy nz na l nb nc"># Checking what's inside the image's filesystem<br/><strong class="mu iu">$ docker run -ti myapp:1.0 sh<br/></strong>/app # ls<br/>Dockerfile         app.js             creds              node_modules       package-lock.json  package.json<br/>/app # find creds/<br/>creds/<br/>creds/mongo-test<br/>creds/mongo-prod<br/>creds/mongo-preprod<br/>/app # cat creds/mongo-prod<br/>mongodb://user:<a class="ae nw" href="mailto:pass@prod.db.com" rel="noopener ugc nofollow" target="_blank">pass@prod.db.com</a>:27017/mydb<br/>/app #</span></pre><p id="a0b5" class="pw-post-body-paragraph lx ly it lz b ma nd ju mc md ne jx mf mg nf mi mj mk ng mm mn mo nh mq mr ms im bi translated">我们应该已经创建了一个<code class="fe nt nu nv mu b">.dockerignore</code>文件，并在其中添加了我们不想公开的文件夹的名称(<code class="fe nt nu nv mu b">creds</code>)。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="c85f" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">摘要</h1><p id="f73e" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">这些简单(且夸张)的例子表明，用一个<code class="fe nt nu nv mu b">.dockerignore</code>文件过滤构建上下文的内容非常简单，也非常重要。你总是确保你的构建环境被正确处理吗？</p></div></div>    
</body>
</html>