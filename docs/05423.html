<html>
<head>
<title>One Browser Extension to Rule Them All</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个浏览器扩展来管理它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/one-browser-extension-to-rule-them-all-3118dc7f9c9b?source=collection_archive---------9-----------------------#2020-07-07">https://betterprogramming.pub/one-browser-extension-to-rule-them-all-3118dc7f9c9b?source=collection_archive---------9-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Platypush web扩展如何使定制浏览器和连接东西变得容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec82f700f8d1d0384f7aceaa7c29759e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bv2qrFwXh4icCx3Ssn68QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Platypush浏览器扩展在浏览器中部署自定义脚本和动作。</p></figure><p id="8e4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">这篇文章的更新版本可以在</em> <a class="ae lv" href="https://blog.platypush.tech/article/One-browser-extension-to-rule-them-all" rel="noopener ugc nofollow" target="_blank"> <em class="lu"> Platypush博客</em> </a> <em class="lu">上找到。</em></p><p id="1c6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">曾几何时，在万维网上，web扩展仍然是新玩物，支持它们的主要浏览器(即Firefox和Chrome)并不介意为它们提供非常广泛的内部访问和API来做(或多或少)他们喜欢的任何事情。他们的想法是，这些浏览器插件/应用程序/扩展(当时它们之间的界限还很模糊)可以成为一种强大的方式，在浏览器内(甚至在本地，不连接到另一个网站)运行用户想要运行的任何软件。</p><p id="15d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个强大的扩展诞生的时代，这些扩展也可以深刻地改变浏览器中的许多东西(比如现在已经失效的<a class="ae lv" href="http://vimperator.org/" rel="noopener ugc nofollow" target="_blank"> Vimperator </a>可以完全重新设计浏览器的UI，使其看起来和行为都像vim)，而<a class="ae lv" href="https://en.wikipedia.org/wiki/Userscript" rel="noopener ugc nofollow" target="_blank">用户脚本</a>是一种强大的方式，用户可以利用它在他们喜欢的任何地方运行他们喜欢的任何东西。我过去经常使用Vimperator自定义脚本来将我想要的任何按键序列映射到我想要的任何自定义动作——只是建模为普通的JavaScript。我过去也经常使用用户脚本——那些仍然存在，但是比以前有更多的限制。</p><p id="cbef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">网络扩展和应用的狂野西部时代现在已经一去不复返了。没过多久，恶意行为者就意识到，给予web扩展的自由使它们成为直接在浏览器中运行恶意软件/间谍软件的完美载体，在许多情况下，它们可以绕过几个反恶意软件层。web扩展的产生还有另一个关于碎片的问题。Firefox和Chrome都开发了自己的API(比如Mozilla的<a class="ae lv" href="https://www.zdnet.com/article/mozilla-changes-firefox-apis-developers-unhappy/" rel="noopener ugc nofollow" target="_blank"> XUL </a>和<a class="ae lv" href="https://blog.chromium.org/2016/08/from-chrome-apps-to-web.html" rel="noopener ugc nofollow" target="_blank"> Chrome Apps </a>),没有太多重叠。这使得开发针对多种浏览器的web扩展成为一种非常昂贵的体验，而且许多扩展和应用程序只适用于特定的浏览器。</p><p id="533d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对更高安全性、关注点分离和更少碎片的需求推动了向现代<a class="ae lv" href="https://wiki.mozilla.org/WebExtensions" rel="noopener ugc nofollow" target="_blank"> WebExtension API </a>的迁移。2017年底左右，<a class="ae lv" href="https://www.zdnet.com/article/mozilla-changes-firefox-apis-developers-unhappy/" rel="noopener ugc nofollow" target="_blank"> Mozilla </a>和<a class="ae lv" href="https://blog.chromium.org/2016/08/from-chrome-apps-to-web.html" rel="noopener ugc nofollow" target="_blank"> Google </a>都在各自的浏览器中结束了对之前API的支持。他们还对商店上未批准的插件和脚本增加了更多限制(Firefox的最新版本只允许你永久安装商店上发布的扩展)，并在审查过程中增加了更多限制和检查。</p><p id="e2a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的API使恶意行为者更难通过浏览器攻击用户，也大大降低了开发跨浏览器扩展所需的障碍。然而，另一方面，它也大大减少了提供给扩展的自由度。几个需要与浏览器深度集成的扩展(如Vimperator和Postman)决定要么迁移到独立的应用程序，要么放弃他们的努力。用户脚本已经变得更加小众，比第三方扩展提供的限制更多，如<a class="ae lv" href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/" rel="noopener ugc nofollow" target="_blank">grease monkey</a>/<a class="ae lv" href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en" rel="noopener ugc nofollow" target="_blank">Tampermonkey</a>。Firefox最近的<a class="ae lv" href="https://www.ghacks.net/2019/03/27/firefox-support-user-scripts-api/" rel="noopener ugc nofollow" target="_blank">用户脚本API </a>是复兴过去浪潮力量的一个有希望的选择，但是到目前为止它只被Firefox支持。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="7b37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一名超级用户，虽然我理解浏览器开发者决定对扩展进行更多防护/沙箱化的所有动机，但我仍然怀念那些我们可以深度定制浏览器以及它可以按照我们喜欢的方式做什么的时候。多年来，我构建了<a class="ae lv" href="https://github.com/Blacklight/platypush" rel="noopener ugc nofollow" target="_blank"> Platypush </a>来解决我对后端无止境的可扩展性和定制的需求，一切都由一个统一一致的API和平台提供(对于那些还不熟悉它的人，请查看<a class="ae lv" href="https://github.com/Blacklight/platypush" rel="noopener ugc nofollow" target="_blank">自述文件</a>或GitHub页面上的Wiki中引用的中型文章来开始)。我认为将同样的哲学应用到我的web浏览器环境中是很自然的下一步。通过Platypush web扩展，我试图为许多高级用户面临的多种需求构建一个解决方案。</p><p id="5d2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们有几个后端解决方案来运行事物，还有智能家居设备来做事情和传递信息。但亲爱的ol '桌面网络浏览器在自动化的这一进步中往往被落在了后面，即使许多人仍然通过桌面设备在网络上花费大量时间。大多数云/家庭自动化的前端解决方案都来自移动应用。一些自动化解决方案提供了一个web应用程序/面板(Platypush也是如此)，但在一个日益以移动为中心的世界中，web面板越来越不受重视。</p><p id="65ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使你的解决方案提供了一个web应用，还有另一个重要因素需要考虑:行动的时间。从你想到“我想在那个设备上运行这个操作”到在那个设备上实际执行这个操作之间过了多长时间？请记住，尤其是对于智能设备而言，“智能”方式下的行动时间(就像你远程开关灯泡)永远不应该比“笨”方式下的行动时间(就像你站起来开关)长。这是你的底线。</p><p id="5487" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我在笔记本电脑上工作时，我有时可能想在另一台设备上运行一些操作，例如向我的手机发送链接，打开灯或风扇，在我的媒体中心播放笔记本电脑上当前播放的视频，在我的卧室或客厅播放Spotify播放列表，等等。当然，对于其中的一些问题，有一个Platypush/home assistant/open hab/big corp Inc .的前端解决方案，但这通常需要你将手从笔记本电脑上拿开以抓住你的手机，或者使用你的平台提供的web应用程序打开/切换到标签，搜索正确的菜单/选项，滚动一点，然后运行该操作。语音助手是另一种选择(Platypush <a class="ae lv" href="https://medium.com/better-programming/building-your-custom-voice-assistants-an-overview-of-the-current-solutions-and-integrations-d8db227a325" rel="noopener">提供集成</a>，让你接触到周围的许多语音技术)，但一天中用你的方式运行任何事情还不是许多人想要的无摩擦和快速的过程——也不应该是唯一的<em class="lu">方式。对我来说，最小化动作时间意味着能够从任何选项卡或工具栏本身运行该动作(理想情况下最多三次点击或击键)，而不管该动作。</em></p><p id="48e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，有一些网络扩展可以解决这些问题。但这通常包括:</p><ul class=""><li id="aabd" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">依靠别人的解决方案来解决你的问题，而这个解决方案对于你的用例来说不一定是最优的。</li><li id="3889" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">用大量的扩展来污染你的浏览器，以便执行不同类型的动作。向其他设备发送链接可能涉及安装push pullet/Join扩展、在Kodi的另一个扩展上播放媒体、在Chromecast的另一个扩展上播放媒体、保存到Instapaper/Evernote/Pocket或其他扩展的链接、在Twitter/脸书上分享更多扩展、控制智能家居中枢的又一个扩展……等等，直到浏览器的工具栏挤满了图标，而你甚至无法回忆起其中一些是做什么的——这违背了从web浏览器的上下文中优化操作时间的整个目的。</li><li id="4051" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">当然，安装太多的扩展会增加针对您的浏览器的潜在攻击面——这是WebExtensions API最初应该解决的问题。</li></ul><p id="e62f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我首先通过构建一个简单的web扩展开始了这段旅程，我可以使用它通过web API/websocket/MQTT快速调试在我家周围的其他RaspberryPis和智能设备上执行的Platypush命令。然后，我意识到我可以使用相同的解决方案来解决我的优化行动时间的问题，即“当我在笔记本电脑上处理我的中型文章时，我想现在就开灯，而不用拿起我的手机或切换标签或站起来。”这意味着要么从工具栏本身(最好将所有操作都分组在同一个扩展按钮和UI下)，要么通过右键单击上下文菜单，如本地浏览器操作。从我的浏览器在任何远程设备上运行任何Platypush动作的能力意味着我可以从同一界面控制任何设备或远程API，只要有Platypush插件与该设备/API交互。</p><p id="33b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这个目标对我来说还不够。并不是所有我想从浏览器中的任何位置运行的动作都可以转换成原子的Platypush动作。Platypush远程过程肯定有助于在后端运行更复杂的逻辑，但我希望该扩展也涵盖我的需要与浏览器上下文交互的用例——比如“在我的Chromecast上播放该视频(是的，即使我在Firefox上)”，“翻译该页面并确保结果看起来不像1997年的网站(是的，即使我在Firefox上)”，“直接在我的NAS上下载该Magnet链接”，等等。一直到自定义事件挂钩，这些事件挂钩可以对浏览器中运行自定义逻辑的其他设备触发的Platypush事件做出反应，比如“如果另一个Platypush设备发送<code class="fe mr ms mt mu b"><a class="ae lv" href="https://platypush.readthedocs.io/en/latest/platypush/events/clipboard.html" rel="noopener ugc nofollow" target="_blank">ClipboardEvent</a></code>，则同步笔记本电脑上的剪贴板”，“当Google Assistant插件触发<code class="fe mr ms mt mu b"><a class="ae lv" href="https://platypush.readthedocs.io/en/latest/platypush/events/assistant.html#platypush.message.event.assistant.ResponseEvent" rel="noopener ugc nofollow" target="_blank">ResponseEvent</a></code>时，向浏览器发送带有语音文本的通知”，或者当传感器超过某个阈值时，等等。</p><p id="f49d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望能够通过类似于Greasemonkey/Tampermonkey提供的JavaScript本地API来定义所有这些操作。但是，虽然这些扩展提供的大多数用户脚本只能在网页的上下文中运行，但我希望将我的脚本片段从网页中分离出来，并构建一个API来提供对浏览器上下文、任何其他远程设备上可用的Platypush操作的访问，以运行后台代码来响应自定义事件，并轻松地跨设备同步配置。所以让我们简单地浏览一下这个扩展，看看你能用它做些什么。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3c41" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">安装和使用</h1><p id="9c8a" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">首先，您需要一个在某个地方运行的Platypush服务。如果您以前没有尝试过，请参考前面几节中的任何链接开始(我保证安装、配置和启动一个基础环境不会超过五分钟:)。另外，确保您在<code class="fe mr ms mt mu b">config.yaml</code>中启用了<a class="ae lv" href="https://platypush.readthedocs.io/en/latest/platypush/backend/http.html" rel="noopener ugc nofollow" target="_blank"> HTTP后端</a>，因为webserver是扩展用来与服务器通信的通道。一旦在RaspberryPi、另一台服务器或您的笔记本电脑上运行了Platypush实例，请获取web扩展:</p><ul class=""><li id="6aab" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated"><a class="ae lv" href="https://addons.mozilla.org/en-US/firefox/addon/platypush/" rel="noopener ugc nofollow" target="_blank">火狐链接</a></li><li id="f834" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated"><a class="ae lv" href="https://chrome.google.com/webstore/detail/platypush/aphldjclndofhflbbdnmpejbjgomkbie?hl=en-GB&amp;authuser=0" rel="noopener ugc nofollow" target="_blank"> Chrome链接</a></li></ul><p id="631c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您也可以从源代码构建一个扩展。首先，确保您已经安装了<code class="fe mr ms mt mu b">npm</code>,然后克隆repo:</p><pre class="kj kk kl km gt ns mu nt nu aw nv bi"><span id="0bae" class="nw mw it mu b gy nx ny l nz oa">git clone <a class="ae lv" href="https://github.com/BlackLight/platypush-webext" rel="noopener ugc nofollow" target="_blank">https://github.com/BlackLight/platypush-webext</a></span></pre><p id="2a35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装依赖项并构建扩展:</p><pre class="kj kk kl km gt ns mu nt nu aw nv bi"><span id="c248" class="nw mw it mu b gy nx ny l nz oa">npm install<br/>npm run build</span></pre><p id="f0fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个过程的最后，您应该有一个带有<code class="fe mr ms mt mu b">manifest.json</code>的<code class="fe mr ms mt mu b">dist</code>文件夹。</p><ul class=""><li id="4a05" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">在Chrome(或任何基于Chrome的浏览器)中，进入扩展-&gt;加载解包并选择<code class="fe mr ms mt mu b">dist</code>文件夹。</li><li id="e767" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">在Firefox中，进入<code class="fe mr ms mt mu b">about:debugging</code>-&gt;This Firefox-&gt;Load Temporary Add-on，选择<code class="fe mr ms mt mu b">manifest.json</code>文件。</li></ul><p id="d625" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，Firefox <a class="ae lv" href="https://blog.mozilla.org/addons/2018/02/22/removing-support-unpacked-extensions/" rel="noopener ugc nofollow" target="_blank">的最新版本仅支持</a>通过<code class="fe mr ms mt mu b">about:debugging</code>解压的扩展(即Firefox附加组件网站上未加载的任何扩展)。这意味着当浏览器重新启动时，任何临时扩展都将丢失——然而，在重新安装时恢复Platypush扩展的配置是一个非常快速的过程。</p><p id="8c3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦安装在浏览器中，扩展图标将出现在工具栏中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/9685da3b05a81b1d017f1dfe51976fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*hakroN1Gpr6xbHvJ_ZA4Sg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全新安装时的板状延伸</p></figure><p id="0fb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单击可用链接打开扩展配置选项卡，并在配置中添加您的Platypush设备。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d18a3f706595a52d5bcc68f968d06356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*VfoSfo1k4g7Ry6f8xNjIMA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设备配置</p></figure><p id="9fe9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">添加设备后，从菜单中单击其名称，然后选择运行操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6ca0ee8a374d985057f6e7d64996d74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PV9ArM40fZLUdLS32BvNOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在动作/请求模式下运行/调试/保存Platypush动作</p></figure><p id="e586" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“运行”选项卡有两种模式:请求和脚本模式。在请求模式下，你可以通过一个动态界面直接在一个远程的Platypush设备上运行动作。您已经有了一个带有自动完成菜单的表单，该菜单显示了您的设备上所有可用的操作，选择后，该表单会预填充该操作的所有可用参数、它们的默认值和描述。这个界面非常类似于Platypush web panel提供的execute选项卡，它使在另一台主机上快速测试和运行命令变得非常容易。</p><p id="5dce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只要安装并配置了插件，您就可以使用该界面在任何远程设备上运行任何操作——文件系统管理、媒体中心控制、语音助手、摄像头、开关、从传感器获取数据、管理云服务，等等。您还可以运行存储在远程设备上的过程——它们的动作名称以<code class="fe mr ms mt mu b">procedure</code>开头——您还可以通过使用特殊变量<code class="fe mr ms mt mu b">$URL$</code>作为动作值，将活动选项卡中的URL作为参数传递给动作。例如，您可以使用它创建一个动作，通过<code class="fe mr ms mt mu b"><a class="ae lv" href="https://platypush.readthedocs.io/en/latest/platypush/plugins/pushbullet.html#platypush.plugins.pushbullet.PushbulletPlugin.send_note" rel="noopener ugc nofollow" target="_blank">pushbullet.send_note</a></code>将当前URL发送到您的移动设备，同时将<code class="fe mr ms mt mu b">body</code>和<code class="fe mr ms mt mu b">url</code>设置为<code class="fe mr ms mt mu b">$URL$</code>。一旦您对您的操作满意，您可以保存它，以便它在工具栏和浏览器上下文菜单中都可用。</p><p id="4d6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你只需要一种从你的浏览器远程执行Platypush动作的方法，这就是你所需要的。该操作现在可从扩展工具栏中获得:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ecf0f5776591e1fddd18bfabf0872ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*qnHPph1kKBOGTJSAg7uWQg.png"/></div></figure><p id="d721" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上下文菜单中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ad0a53502b26af5ecaa252272e2d63d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEw_OUMMhzhMKb4O_3Q-PA.png"/></div></div></figure><p id="bec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以从扩展的配置页面中的stored action选项卡轻松地调试/编辑存储的操作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="6a59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种(也是最强大的)定义定制动作的方法是通过脚本。脚本可以用来将Platypush API(或任何其他API)和浏览器API粘合在一起。</p><p id="ed56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<em class="lu">运行动作</em>选项卡顶部的选择器中选择<code class="fe mr ms mt mu b">Script</code>。您将看到一个带有预加载脚本模板的JavaScript编辑器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/8c857bc5f757865a882ffbc6c862b9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*7JtqcDCr6JLyzvgFyvHDZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Platypush扩展中的脚本模式</p></figure><p id="f2b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该页面还提供了一个链接，链接到显示所有可用API示例的要点。简而言之，这些是您可以用来构建用户脚本的最重要的部分:</p><ul class=""><li id="c789" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">args</code>包含脚本的相关上下文信息，比如目标Platypush <code class="fe mr ms mt mu b">host</code>、<code class="fe mr ms mt mu b">tabId</code>和<code class="fe mr ms mt mu b">target</code>元素，如果动作是从页面上的上下文菜单调用的话。</li><li id="d8ac" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">app</code>公开脚本可用的API。</li></ul><p id="87c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mr ms mt mu b">app</code>曝光的方法中:</p><ul class=""><li id="4a49" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">app.getURL</code>返回活动标签中的URL。</li><li id="74d7" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">app.setURL</code>改变当前标签中的URL，而<code class="fe mr ms mt mu b">app.openTab</code>在新标签中打开一个URL。</li><li id="ccfd" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">app.notify(message, title)</code>显示浏览器通知。</li><li id="ba37" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">app.run</code>在远程Platypush设备上执行操作。</li></ul><p id="39dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，这是将YouTube视频播放到默认Chromecast设备的可能操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="3613" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">app.axios.[get|post|put|delete|patch|head|options]</code>:该API还公开了<a class="ae lv" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a> API来执行对远程端点的定制AJAX调用。例如，如果您想要将当前URL保存到您的Instapaper帐户:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="3e38" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated"><code class="fe mr ms mt mu b">app.getDOM</code>返回当前页面的DOM/内容(作为<code class="fe mr ms mt mu b">Node</code>元素)，而<code class="fe mr ms mt mu b">app.setDOM</code>替换页面的DOM/内容(作为字符串给出)。例如，您可以将提供的DOM API与<a class="ae lv" href="https://platypush.readthedocs.io/en/latest/platypush/plugins/google.translate.html" rel="noopener ugc nofollow" target="_blank"> Platypush翻译插件</a>结合起来，即时翻译网页:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="55be" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">扩展API还公开了<a class="ae lv" href="https://github.com/postlight/mercury-parser" rel="noopener ugc nofollow" target="_blank"> Mercury Reader API </a>来简化/提炼网页内容。您可以将目前看到的元素合并到一个脚本中，该脚本可以简化网页的内容，以获得更好的可读性，或者使其更便于打印:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="6ee8" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">最后，如果您通过上下文菜单运行操作(例如，右键单击页面上的一个项目)，您可以访问<code class="fe mr ms mt mu b">target</code>元素。由于WebExtensions API的限制(只能传递JSON-serializable对象)，<code class="fe mr ms mt mu b">target</code>元素作为字符串在<code class="fe mr ms mt mu b">args</code>上传递，但是您可以通过<code class="fe mr ms mt mu b">app.HTML2DOM</code>方法轻松地将其转换为DOM对象(并且您可以将任何HTML转换为DOM)。例如，您可以将最初的YouTube扩展到Chromecast用户脚本，以播放页面上出现的任何音频或视频项目:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="a89a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些基本块，您应该能够创建任何您想要的自定义浏览器操作。一些例子:</p><ul class=""><li id="7f1e" class="md me it la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">通过<a class="ae lv" href="https://platypush.readthedocs.io/en/latest/platypush/plugins/http.webpage.html" rel="noopener ugc nofollow" target="_blank"> Platypush网页简化插件</a>将当前网页转换为PDF，并通过<a class="ae lv" href="https://platypush.readthedocs.io/en/latest/platypush/plugins/google.mail.html" rel="noopener ugc nofollow" target="_blank"> Platypush GMail插件</a>将其作为附件发送到您的Kindle。</li><li id="5da3" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">向某人发送包含页面上所选文本的电子邮件。</li><li id="4a2d" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">即时翻译页面上选定的一些文本。</li><li id="ba3c" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">分享当前到Twitter/脸书/LinkedIn的链接(抛弃所有其他分享到社交的扩展)。</li><li id="e22e" class="md me it la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">将页面上的magnet/torrent链接直接下载到您的NAS。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d1e6" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">配置备份和恢复</h1><p id="60d5" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">最后，您可以通过<em class="lu">配置</em>选项卡轻松编辑、备份和恢复扩展配置。配置既可以加载/复制到文件，也可以从Platypush设备恢复/远程备份到Platypush设备(看ma，没有云！)，或者从URL加载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/cc7e5791f9ded22b12f595cf5e39b9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXyDCK6ft3oN2nOjDwTnKg.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8d59" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">正在进行的工作</h1><p id="fc50" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">该扩展仍在开发中，我对建议、票证和<a class="ae lv" href="https://github.com/BlackLight/platypush-webext" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>上的请求持开放态度。具体来说，我的路线图上接下来有两个功能:</p><h2 id="ffa6" class="nw mw it bd mx ok ol dn nb om on dp nf lh oo op nh ll oq or nj lp os ot nl ou bi translated">与Platypush web套接字协议集成</h2><p id="cb54" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">这将允许许多有趣的功能，例如检查远程设备的健康状态，传输更大块的数据(如来自远程设备的音频/视频流)，最重要的是，设置事件挂钩——当平板推送设备触发事件时自动运行的脚本，如语音助手响应处理、媒体状态改变、灯光场景改变、接收到新的传感器数据等。</p><h2 id="2410" class="nw mw it bd mx ok ol dn nb om on dp nf lh oo op nh ll oq or nj lp os ot nl ou bi translated">通过API支持第三方库</h2><p id="f8c2" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">到目前为止，脚本API公开了<code class="fe mr ms mt mu b">axios</code>和<code class="fe mr ms mt mu b">mercury</code>解析器库，但是我相信为了灵活性，应该可以通过简单的方式在用户脚本中导入外部库:</p><pre class="kj kk kl km gt ns mu nt nu aw nv bi"><span id="f2fd" class="nw mw it mu b gy nx ny l nz oa">const jquery = app.loadScript('https://some.cdn/jquery.min.js');</span></pre><p id="7608" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终，如果这个项目获得足够的支持，我很乐意创建一个用户可以分享他们的创作的资源库——只要我们都记住，能力越大，责任越大:)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4533" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="9927" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">我理解导致采用WebExtensions API的安全性和一致性问题。但我也理解为什么许多依赖于与浏览器更深层次集成的扩展拒绝与新的API妥协，并在此期间停止使用。</p><p id="9081" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我自己用新的API开发了这个扩展，因为当前的WebExtensions API创建了许多沙箱，它只让特定上下文(如后台脚本、内容脚本或弹出上下文)可以访问信息片段，它迫使需要信息和功能的开发人员设置复杂的消息传递系统来传递数据。它还对哪些代码可以在哪里执行进行了严格的限制(祝你在代码中使用<code class="fe mr ms mt mu b">eval</code>时好运)。通过Platypush web扩展，我试图填补以前的扩展/应用程序/附加组件API的废弃所留下的空白，并为高级用户提供一个层来深度定制他们浏览器的行为。我还想构建一个扩展，可以让我从同一个用户界面和同一个按钮上轻松访问我周围越来越分散的智能设备世界。我也厌倦了看到工具栏上的空间被成吨的扩展图标吞噬，这些图标只能执行一个特定的任务！</p></div></div>    
</body>
</html>