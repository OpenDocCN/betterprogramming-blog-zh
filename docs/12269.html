<html>
<head>
<title>12 Linux Commands Worth Remembering for Log File Operations (With Examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对于日志文件操作，值得记住的12个Linux命令(带示例)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/12-linux-commands-worth-remembering-for-log-file-operations-with-examples-4a861b6faaa3?source=collection_archive---------1-----------------------#2022-05-24">https://betterprogramming.pub/12-linux-commands-worth-remembering-for-log-file-operations-with-examples-4a861b6faaa3?source=collection_archive---------1-----------------------#2022-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">系统管理员和支持工程师喜欢的工具列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2473b7acfabc1de320db3b9827a73de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFOByS0LgpKWZi8o17Baqw.png"/></div></div></figure><p id="fe50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文包括一组工具，您可以使用这些工具来提高在Linux环境中处理文件操作(尤其是日志文件)的效率。如果你有更多的建议，请在评论中提及。享受阅读吧！</p><p id="d8e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">先稍微介绍一下<code class="fe lq lr ls lt b">tree</code>(见上图)。是一个很棒的工具，用于在Linux环境下快速列出文件、文件夹和子文件夹。有很多工具可以用来进行文件操作，比如<code class="fe lq lr ls lt b">du</code>、<code class="fe lq lr ls lt b">split</code>、<code class="fe lq lr ls lt b">shred</code>、<code class="fe lq lr ls lt b">tail</code>、<code class="fe lq lr ls lt b">head</code>、<code class="fe lq lr ls lt b">less</code>、<code class="fe lq lr ls lt b">cat</code>、<code class="fe lq lr ls lt b">tac</code>、<code class="fe lq lr ls lt b">nl</code>、<code class="fe lq lr ls lt b">sort</code>、<code class="fe lq lr ls lt b">uniq</code>、<code class="fe lq lr ls lt b">column</code>。让我们在本帖中讨论它们吧！</p><h1 id="ef83" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.du和树-du(估计深度水平的空间使用)</h1><p id="c68c" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated"><code class="fe lq lr ls lt b">du</code>是一个流行的工具，可以快速列出特定深度的文件、文件夹和子文件夹(使用<code class="fe lq lr ls lt b">--max-depth=N</code>或<code class="fe lq lr ls lt b">-d N</code>)，包括它们的大小和其他信息。这里，<code class="fe lq lr ls lt b">-a</code>可以用来包括文件和文件夹。<code class="fe lq lr ls lt b">-h</code>将大小转换为更易于阅读的格式(例如，<code class="fe lq lr ls lt b">M</code>兆字节，<code class="fe lq lr ls lt b">K</code>千字节)。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="c349" class="mv lv it lt b gy mw mx l my mz">$ du -ah --max-depth=2<br/>7.5M    ./payments/dist<br/>64K     ./payments/lib<br/>74M     ./payments/node_modules<br/>28K     ./payments/src<br/>60K     ./payments/test<br/>82M     ./payments<br/>...<br/>108K    ./transaction_engine/dist<br/>44K     ./transaction_engine/lib<br/>62M     ./transaction_engine/node_modules<br/>16K     ./transaction_engine/src<br/>0       ./transaction_engine/test<br/>62M     ./transaction_engine</span></pre><p id="a231" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我个人觉得<code class="fe lq lr ls lt b">du</code>的输出有些杂乱，我更喜欢使用修改过的<code class="fe lq lr ls lt b">tree</code>命令和<code class="fe lq lr ls lt b">--du</code>和<code class="fe lq lr ls lt b">-h</code>来查看更有组织的树状结构中的相同信息。这里，深度也可以用<code class="fe lq lr ls lt b">-L N</code>表示:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="cc0d" class="mv lv it lt b gy mw mx l my mz">$ tree -L 2 --du -h<br/>.<br/>├── [ 36K]  payments<br/>│   ├── [2.4K]  deploy.sh<br/>│   ├── [4.0K]  dist<br/>│   ├── [4.0K]  lib<br/>│   ├── [4.0K]  node_modules<br/>│   ├── [1.5K]  package.json<br/>│   ├── [ 356]  readme.md<br/>│   ├── [4.0K]  src<br/>│   ├── [4.0K]  test<br/>│   └── [ 406]  tsconfig.json<br/>│ ......<br/>└── [ 30K]  transaction_engine<br/>    ├── [2.4K]  deploy.sh<br/>    ├── [4.0K]  dist<br/>    ├── [4.0K]  lib<br/>    ├── [4.0K]  node_modules<br/>    ├── [ 570]  package.json<br/>    ├── [ 658]  readme.md<br/>    ├── [4.0K]  src<br/>    └── [ 397]  tsconfig.json</span></pre><blockquote class="na"><p id="39c0" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">提示:在`. bashrc `文件中使用自定义别名来简化`<code class="fe lq lr ls lt b">tree</code>`。</p></blockquote><pre class="nk nl nm nn no mr lt ms mt aw mu bi"><span id="4ea2" class="mv lv it lt b gy mw mx l my mz">$ alias t="tree --du -h -L"<br/>$ t 2<br/>.<br/>├── [ 36K]  payments<br/>│   ├── [2.4K]  deploy.sh<br/>│   ├── [4.0K]  dist<br/>│   ├── [4.0K]  lib<br/>│   ├── [4.0K]  node_modules<br/>│   ├── [1.5K]  package.json<br/>│   ├── [ 356]  readme.md<br/>│   ├── [4.0K]  src<br/>│   ├── [4.0K]  test<br/>│   └── [ 406]  tsconfig.json<br/>│ ......<br/>└── [ 30K]  transaction_engine<br/>    ├── [2.4K]  deploy.sh<br/>    ├── [4.0K]  dist<br/>    ├── [4.0K]  lib<br/>    ├── [4.0K]  node_modules<br/>    ├── [ 570]  package.json<br/>    ├── [ 658]  readme.md<br/>    ├── [4.0K]  src<br/>    └── [ 397]  tsconfig.json</span></pre><h1 id="9a85" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.(将文件分割成碎片)</h1><p id="6bfc" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated"><code class="fe lq lr ls lt b">split</code>允许您根据不同的标准将文件分割成多个部分，例如块的数量(<code class="fe lq lr ls lt b">-n</code>)、每个块的行数(<code class="fe lq lr ls lt b">-l</code>)等。当您需要快速减小大型日志文件的大小时，这非常有用。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="52d8" class="mv lv it lt b gy mw mx l my mz"><em class="np">// Split by number of equal chunks</em></span><span id="fbde" class="mv lv it lt b gy nq mx l my mz">$ split -n 2 test test_copy_</span><span id="b633" class="mv lv it lt b gy nq mx l my mz">$ nl test_copy_aa<br/>     1  Hello<br/>$ nl test_copy_ab<br/>     1  World</span><span id="6b16" class="mv lv it lt b gy nq mx l my mz"><em class="np">// Split by number of lines per chunk</em></span><span id="cd62" class="mv lv it lt b gy nq mx l my mz">$ split -l 100 logFileWith250Lines log_</span><span id="64a1" class="mv lv it lt b gy nq mx l my mz">$ nl log_aa | tail -n 1<br/>     100  I'm Log Line #100<br/>$ nl log_ab | tail -n 1<br/>     100  I'm Log Line #200<br/>$ nl log_ac | tail -n 1<br/>     50  I'm Log Line #250<br/>$ nl log_aa log_ab | tail -n 1<br/>     200  I'm Log Line #200<br/>$ nl log_aa log_ab log_ac | tail -n 1<br/>     250  I'm Log Line #250</span></pre><h1 id="1e1a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.` shred '(` RM '的安全替代)</h1><p id="6231" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">当你要在Linux上删除一个文件时，首先想到的是<code class="fe lq lr ls lt b">rm</code>(或者如果你有GUI访问，按下<code class="fe lq lr ls lt b">DELETE</code>按钮)。</p><p id="3126" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，问题是，当使用<code class="fe lq lr ls lt b">rm</code>(或<code class="fe lq lr ls lt b">DELETE</code>)时，它更新了对操作系统知道的文件的引用，因此，该文件将从当前位置消失，使其对用户隐藏。但是该文件仍将在硬盘上驻留一段时间，高级用户将能够非常容易地恢复和访问这些数据。</p><p id="6bba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您希望您删除的文件以不可恢复的方式从您的系统中完全删除，特别是当它们包含敏感信息时，您可以使用<code class="fe lq lr ls lt b">shred</code>，这是一个可以覆盖您的文件以隐藏其内容的工具，也可以选择删除它(<code class="fe lq lr ls lt b">-u</code>删除文件)。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="d6ef" class="mv lv it lt b gy mw mx l my mz"><em class="np">// Commonly-used approach (not recommended)</em><br/>$ rm passwords.txt</span><span id="6d37" class="mv lv it lt b gy nq mx l my mz"><em class="np">// Basic usage - shred</em><br/>$ shred -u passwords.txt</span><span id="4f02" class="mv lv it lt b gy nq mx l my mz"><em class="np">// Useful options - shred</em><br/>$ shred -zvu -n 5 passwords.txt</span><span id="bacd" class="mv lv it lt b gy nq mx l my mz">-z: add a final overwrite with zeros to hide shredding<br/>-v: show progress (i.e. verbose)<br/>-u: truncate and remove file after overwriting<br/>-n: overwrite N times instead of the default (3)</span></pre><p id="8f3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="np">注意:</em> </strong> <em class="np"> </em> <code class="fe lq lr ls lt b"><em class="np">shred</em></code> <em class="np">是一个漂亮简单的快速删除敏感文件的工具。此外，在特殊情况下，您可能需要使用其他高级工具。</em></p><p id="3114" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="np">(请在使用前做一些研究，看看它们是否符合您的需求)</em></p><p id="3ffe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="np">例如</em> <code class="fe lq lr ls lt b"><em class="np">wipe</em></code> <em class="np">(用于从磁性存储器中安全擦除文件)</em> <code class="fe lq lr ls lt b"><em class="np">srm (secure-delete)</em></code> <em class="np">(使用高级选项删除)</em></p><h1 id="37c1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.`&gt; file.txt `(刷新文件中的内容)</h1><p id="6057" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">需要保存一个终端输出还是重复登录同一个文件？您可以使用<code class="fe lq lr ls lt b">&gt; log.txt</code>而不是运行非常基本的<code class="fe lq lr ls lt b">rm log.txt &amp;&amp; touch log.txt</code>。这个命令会刷新文件中的所有内容，并为您提供一个新的副本。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="c27d" class="mv lv it lt b gy mw mx l my mz">$ cat <!-- -->user_logins.csv<br/>user_A,8.19AM,US North<br/>user_B,8.22AM,UK<br/>user_C,8.32AM,Australia</span><span id="0ef9" class="mv lv it lt b gy nq mx l my mz">$ &gt; <!-- -->user_logins.csv</span><span id="adda" class="mv lv it lt b gy nq mx l my mz">$ cat <!-- -->user_logins.csv<br/>// ... file is empty now ...</span></pre><h1 id="b47d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">5.` cat `(连接文件和打印)和` tac `(逆序` cat `)</h1><p id="79db" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated"><code class="fe lq lr ls lt b">cat</code>广泛用于连接文件并在标准输出上打印内容。现在，如果你想改变<code class="fe lq lr ls lt b">cat</code>的输出顺序，那么你可以使用<code class="fe lq lr ls lt b">tac</code>。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="e936" class="mv lv it lt b gy mw mx l my mz">$ cat <!-- -->user_logins.csv<br/>user_A,8.19AM,US North<br/>user_B,8.22AM,UK<br/>user_C,8.32AM,Australia</span><span id="d2f9" class="mv lv it lt b gy nq mx l my mz">$ tac <!-- -->user_logins.csv<br/>user_C,8.32AM,Australia<br/>user_B,8.22AM,UK<br/>user_A,8.19AM,US North</span></pre><h1 id="417d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">6.` nl `(带编号行的标准输出)</h1><p id="d183" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">为了在<code class="fe lq lr ls lt b">cat</code>命令的输出中有编号的行，您可以使用<code class="fe lq lr ls lt b">cat -n</code>或简单地说— <code class="fe lq lr ls lt b">nl</code>，它更短并且专用于确切的目的。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="4e42" class="mv lv it lt b gy mw mx l my mz">$ cat test.txt<br/>Hello<br/>World</span><span id="96b1" class="mv lv it lt b gy nq mx l my mz">$ cat -n test.txt <br/>     1  Hello<br/>     2  World</span><span id="c0f6" class="mv lv it lt b gy nq mx l my mz">$ nl test.txt<br/>     1  Hello<br/>     2  World</span><span id="8171" class="mv lv it lt b gy nq mx l my mz">$ nl .bash_history | grep netstat<br/>  1577  netstat -tulnp | grep 1383<br/>  1915  netstat -tulnp | grep 1383<br/>  1916  netstat -tulnp | grep 6379</span></pre><p id="5f96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="np">注:</em> </strong> <em class="np">如果需要用</em> <code class="fe lq lr ls lt b"><em class="np">less</em></code> <em class="np">编号的行，可以简单使用</em> <code class="fe lq lr ls lt b"><em class="np">less -N &lt;fileName&gt;</em></code> <em class="np">。要用</em> <code class="fe lq lr ls lt b"><em class="np">vi</em></code> <em class="np">编辑编号行，先用</em> <code class="fe lq lr ls lt b"><em class="np">vi</em></code> <em class="np"> ( </em> <code class="fe lq lr ls lt b"><em class="np">vi &lt;fileName&gt;</em></code> <em class="np">)打开文件，用</em> <code class="fe lq lr ls lt b"><em class="np">:set nu</em></code> <em class="np">。</em></p><p id="b12c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="np">如果你在打开文件前知道行号，只要在文件打开时输入</em> <code class="fe lq lr ls lt b"><em class="np">vi +12 &lt;fileName&gt;</em></code> <em class="np">就可以直接跳转到那一行(如</em> <code class="fe lq lr ls lt b"><em class="np">12</em></code> <em class="np">)。</em></p><h2 id="742b" class="mv lv it bd lw nr ns dn ma nt nu dp me ld nv nw mg lh nx ny mi ll nz oa mk ob bi translated">7.` sort `(对文件中的内容进行排序)</h2><p id="7f05" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">如果您想对文件中的行进行排序，这个工具正好可以做到这一点。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="df44" class="mv lv it lt b gy mw mx l my mz">$ cat zip_codes.txt<br/>94801 Richmond<br/>94112 San Francisco<br/>90210 Beverly Hills<br/>94102 San Francisco <br/>95812 Sacramento<br/>94112 San Francisco</span><span id="5b96" class="mv lv it lt b gy nq mx l my mz">$ sort zip_codes.txt<br/>90210 Beverly Hills<br/>94102 San Francisco<br/>94112 San Francisco<br/>94112 San Francisco<br/>94801 Richmond<br/>95812 Sacramento</span></pre><h1 id="9be2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">8.` uniq `(省略重复内容，仅显示唯一的行)</h1><p id="d7a0" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">如果您对将输出减少到唯一的行或者只获得副本感兴趣(<code class="fe lq lr ls lt b">-d</code> ), <code class="fe lq lr ls lt b">uniq</code>为此提供了许多选项。这里，<code class="fe lq lr ls lt b">-c</code>提供每个重复行的出现次数。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="eb20" class="mv lv it lt b gy mw mx l my mz">$ sort zip_codes.txt | uniq -c<br/>1 90210 Beverly Hills<br/>1 94102 San Francisco<br/>2 94112 San Francisco<br/>1 94801 Richmond<br/>1 95812 Sacramento</span><span id="89b0" class="mv lv it lt b gy nq mx l my mz">$ sort zip_codes.txt | uniq -c -d<br/>2 94112 San Francisco</span></pre><h1 id="b556" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">9.` head `(显示文件的开头)和` tail `(显示文件的结尾)</h1><p id="14a1" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">您想从文件的开头/结尾看到一定数量的行吗？<code class="fe lq lr ls lt b">head</code>和<code class="fe lq lr ls lt b">tail</code>用于此目的。您可以使用<code class="fe lq lr ls lt b">-n</code>指定首选行数，使用<code class="fe lq lr ls lt b">-f</code>显示文件动态增长时的附加数据(即，不停止打印，也称为跟随)。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="2dba" class="mv lv it lt b gy mw mx l my mz">$ head -n 2 <!-- -->user_logins.csv<br/>user_A,8.19AM,US North<br/>user_B,8.22AM,UK</span><span id="e746" class="mv lv it lt b gy nq mx l my mz">$ tail -n 2 <!-- -->user_logins.csv<br/>user_B,8.22AM,UK<br/>user_C,8.32AM,Australia</span></pre><h1 id="4ab5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">10.` column -t` [将内容格式化为列]</h1><p id="4dcf" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">当您有一组行，每一行都由空白或某种分隔符(例如<code class="fe lq lr ls lt b">,</code>、<code class="fe lq lr ls lt b">|</code>、<code class="fe lq lr ls lt b">_</code>)分隔成某种顺序时，您可以使用<code class="fe lq lr ls lt b">column -t</code>将它们打印到带有列的标准输出中——就像一个表格(<code class="fe lq lr ls lt b">-t</code>)。在这种情况下，默认分隔符是空白(例如<code class="fe lq lr ls lt b">mount | column -t</code>)，但是您可以使用<code class="fe lq lr ls lt b">-s</code>指定任何其他字符(例如<code class="fe lq lr ls lt b">cat user_logins.csv | column -t -s,</code>)。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="8fd2" class="mv lv it lt b gy mw mx l my mz">// with delimiter</span><span id="640c" class="mv lv it lt b gy nq mx l my mz">$ cat <!-- -->user_logins.csv<br/>user_A,8.19AM,US North<br/>user_B,8.22AM,UK<br/>user_C,8.32AM,Australia</span><span id="77a5" class="mv lv it lt b gy nq mx l my mz">$ <!-- -->cat user_logins.csv | column -t -s,<br/>user_A     8.19AM     US North<br/>user_B     8.22AM     UK<br/>user_C     8.32AM     Australia</span><span id="ef65" class="mv lv it lt b gy nq mx l my mz">// without delimiter (default to whitespace)</span><span id="c513" class="mv lv it lt b gy nq mx l my mz">$ mount<br/>/dev/sdb on / type ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)<br/>tmpfs on /mnt/wsl type tmpfs (rw,relatime)<br/>tools on /init type 9p (ro,relatime,dirsync,aname=tools;fmask=022,loose,access=client,trans=fd,rfd=6,wfd=6)<br/>...</span><span id="d5e9" class="mv lv it lt b gy nq mx l my mz">$ mount | column -t<br/>/dev/sdb     on  /                          type  ext4         (rw,relatime,discard,errors=remount-ro,data=ordered)<br/>tmpfs        on  /mnt/wsl                   type  tmpfs        (rw,relatime)<br/>tools        on  /init                      type  9p           (ro,relatime,dirsync,aname=tools;fmask=022,loose,access=client,trans=fd,rfd=6,wfd=6)<br/>....</span></pre><h1 id="c76d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">11.` less `(显示文件内容)</h1><p id="37e4" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">是一个非常广泛使用的工具，以可滚动和可过滤的方式显示大文件的内容。它有如此多的模式搜索和高级导航功能。以下是您可以开始使用的一些最常用的选项。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="8296" class="mv lv it lt b gy mw mx l my mz">$ less -N file.txt<br/>-N - Show line numbers<br/>&amp;pattern - display only lines with pattern</span><span id="34bb" class="mv lv it lt b gy nq mx l my mz">? - search a pattern backward e.g. ?/src/payments/<br/>/ - search a pattern forward e.g. /\/src\/payments\/<br/>n - jump to the next match forward<br/>N - jump to the previous match backward<br/>G – jump to the end of file<br/>g - jump to the start of file<br/>10j – jump 10 lines forward<br/>10k – jump 10 lines backward</span></pre><h1 id="894d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">12.用于文件操作的其他有用的Linux命令</h1><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="9e43" class="mv lv it lt b gy mw mx l my mz"><strong class="lt iu">pwd</strong> =  print working directory</span><span id="fee1" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">cd</strong> <strong class="lt iu">&lt;directory&gt;</strong> = change directories and navigate the file system (e.g. cd ~/logs/)<br/><strong class="lt iu">cd </strong>=<strong class="lt iu"> </strong>jump to user's home directory <strong class="lt iu"><br/>cd ..</strong> = <!-- -->jump to upper directory level <br/><strong class="lt iu">cd ../../..</strong> = jump 3 directory levels up<br/><strong class="lt iu">cd - </strong>= jump back to the previous directory</span><span id="51b4" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">ls</strong> = list files and folders in current directory<br/><strong class="lt iu">ls -alh</strong> = -a: include hidden (e.g. .ssh), -l: log listing detailed info, -h: size in human-readable format (e.g. MB, KB)<br/><strong class="lt iu">ls -s </strong>= -s: sort by size<br/><strong class="lt iu">ls -t </strong>= -t: sort by time</span><span id="3eee" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">touch &lt;file1&gt;</strong> = create an empty file (e.g. touch file.txt)</span><span id="22ca" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">mv &lt;location1/file1&gt; &lt;location2/&gt; </strong>= move file between locations (file1 goes inside location2)<br/><strong class="lt iu">mv &lt;location1/file1&gt; &lt;location2/file2&gt; </strong>= move file between locations and rename (file1 goes inside location2 and becomes file2)<br/><strong class="lt iu">mv &lt;location1/file1&gt; .</strong> = move file to current directory (file1 goes inside current directory location)<br/><strong class="lt iu">mv &lt;location1/*&gt; &lt;location2/&gt;</strong> = move all content inside one location to another location (content inside location1 goes inside location2)<br/><strong class="lt iu">mv &lt;existing_folder1/&gt; &lt;existing_folder2/&gt; </strong>= move folder location (existing_folder1 goes inside existing_folder2)<br/><strong class="lt iu">mv &lt;existing_folder1/&gt; &lt;new_folder/&gt; </strong>= rename folders (existing_folder1 becomes new_folder)<strong class="lt iu"><br/>mv &lt;existing_file1&gt; &lt;new_file&gt; </strong>= rename files (existing_file1 becomes new_file)<br/><strong class="lt iu">mv &lt;location1/file1&gt; &lt;location2/&gt;</strong> = copy file between locations (a copy of file1 goes inside location2)</span><span id="517b" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">mkdir folder1</strong> = create a folder in current directory<br/><strong class="lt iu">mkdir -p folder1/folder2/folder3</strong> = create entire folder path if it doesn't exist</span><span id="3c48" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">rm file1 </strong>= remove a file<br/><strong class="lt iu">rm -rf folder1</strong> = remove an entire folder</span><span id="c25a" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">find -name file1</strong> = search files inside current folder and its subfolders by file name<br/><strong class="lt iu">find &lt;location1&gt; -name file1</strong> = search files inside some location by file name<br/><strong class="lt iu">find -size +100M</strong> = search files inside current folder and its subfolders by file size<br/><strong class="lt iu">find -user root</strong> = search files inside current folder and its subfolders by file owner</span><span id="5b1a" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">locate file1</strong> = search files across the entire system</span><span id="a01c" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">sudo !!</strong> - rerun the last command as root</span><span id="3929" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">&lt;cmd1&gt; | xargs &lt;cmd2&gt;</strong> = pass output from one command to arguments of another<br/><strong class="lt iu">&lt;cmd1&gt; | tee file1</strong> = send output of a command/script to both standard output on terminal and a specific file<br/><strong class="lt iu">&lt;cmd1&gt; &gt; file1 </strong>= send output of a command only to a specific file</span><span id="b67f" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">ln</strong> <strong class="lt iu">&lt;location1/file1&gt; link</strong> = create a symbolic link from on file to current location (link goes inside current directory)</span><span id="c455" class="mv lv it lt b gy nq mx l my mz"><strong class="lt iu">df</strong> = display size of free disk space</span></pre><h1 id="dc03" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">快捷键</h1><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="c399" class="mv lv it lt b gy mw mx l my mz">CTRL + L = clear the currently-typing screen and get a fresh terminal (similar to typing `clear`)<br/>CTRL + U = clear the currently-typing command and get a fresh line<br/>CTRL + R = reverse-search the past commands recorded in bash history</span></pre><blockquote class="na"><p id="ef79" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">提示:使用<a class="ae oc" href="http://man-db.nongnu.org/" rel="noopener ugc nofollow" target="_blank"> man-db </a>(或类似工具)来探索上述工具的所有可用选项。</p></blockquote><pre class="nk nl nm nn no mr lt ms mt aw mu bi"><span id="603f" class="mv lv it lt b gy mw mx l my mz">$ sudo apt install man-db</span><span id="75a9" class="mv lv it lt b gy nq mx l my mz">$ man du<br/>$ man tree<br/>$ man tail<br/>$ man sort <br/>$ man less</span></pre></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="0ea9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="np">敬请关注下一个编程技巧。在那之前，祝你黑客生涯愉快！</em></p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h2 id="1425" class="mv lv it bd lw nr ns dn ma nt nu dp me ld nv nw mg lh nx ny mi ll nz oa mk ob bi translated">如果你喜欢这篇文章，你可能也会喜欢读这些:</h2><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/application-logging-best-practices-a-support-engineers-perspective-b17d0ef1c5df"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">企业应用程序日志记录最佳实践(支持工程师的视角)</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">大家来写点大家都爱的有意义的日志吧！</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/23-linux-server-security-tips-and-best-practices-b8c59b9b9e3e"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">23个Linux服务器安全提示和最佳实践</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">系统管理员应该遵循的清单</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://medium.com/platform-engineer/microservices-design-guide-eca0b799a7e8" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">微服务设计指南</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">大家都听说过微服务。但是你知道怎么设计一个吗？</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>