<html>
<head>
<title>SwiftUI Concurrency: Understand Cooperative Task Cancellation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI并发性:理解协作任务取消</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-concurrency-understand-cooperative-task-cancellation-b71cc69483e0?source=collection_archive---------7-----------------------#2021-07-15">https://betterprogramming.pub/swiftui-concurrency-understand-cooperative-task-cancellation-b71cc69483e0?source=collection_archive---------7-----------------------#2021-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">取消任务变得简单多了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81f5bfdda70d7c6d8ffe095ccbe2f1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EPGrZuIipmOLx0MiGMPcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标题图片基于苹果公司SF符号中的<code class="fe ky kz la lb b">xmark.circle.fill</code></p></figure><p id="eac2" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Swift的新并发特性使得编写正确的并发代码变得更加容易。这是通过多种方式实现的，最突出的是通过向Swift语言本身添加async/await等功能，允许编译器执行流分析，并向开发人员提供有意义的反馈。</p><p id="b3da" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">正如Doug在Swift论坛上的本帖中所指出的，“Swift一直被设计为默认安全”，并且“Swift 6的并发性工作的一个明确目标是让默认安全也扩展到数据竞争。”</p><p id="fe86" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在这一系列文章和视频中，我的目标是向您介绍Swift新并发模型的关键方面，您在构建SwiftUI应用时需要这些方面。<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/getting-started-with-async-await-in-swiftui-for-ios-15-f627eb722a4b">上次</a>，我展示了如何使用<code class="fe ky kz la lb b">URLSession</code>从异步API获取数据，async/await如何帮助我们摆脱末日金字塔，以及如何从同步上下文中调用异步代码。</p><p id="97b5" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">今天，我想重点谈谈任务取消。这是Swift并发模型中的一个重要特性，使我们能够避免应用程序中的意外行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="2997" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">无序的搜索结果</h1><p id="61e0" class="pw-post-body-paragraph lc ld it le b lf mt ju lh li mu jx lk ll mv ln lo lp mw lr ls lt mx lv lw lx im bi translated">为了理解为什么这很重要，让我们来看看我为本文构建的示例应用程序(可在本系列的<a class="ae ly" href="https://github.com/peterfriese/SwiftUI-Concurrency-Essentials" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中获得)。这是一个简单的搜索屏幕，利用了SwiftUI新的<code class="fe ky kz la lb b">searchable</code>视图修改器。搜索字段被绑定到视图模型的<code class="fe ky kz la lb b">searchTerm</code> published属性，我们使用<code class="fe ky kz la lb b">onReceive</code>视图修饰符来监听这个属性的任何变化。在闭包内，我们创建一个新的异步任务，并在视图模型上调用<code class="fe ky kz la lb b">executeQuery</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ma l"/></div></figure><p id="5988" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这意味着每当用户输入一个字符时，我们就运行查询，这实质上给了我们一种实时搜索的体验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/9793a266ef54832e322b56c18f9b68ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HZlVL28aLp4uP7mn.gif"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ma l"/></div></figure><p id="86f7" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你密切关注应用程序的记录，你会注意到一些奇怪的事情:用户键入一个搜索词(“搭便车”)，过了一会儿，这个搜索词的结果就会出现。但是不久之后，搜索结果被替换为不同的搜索结果，这有点出乎意料。如果你仔细观察，你会注意到第二个结果是搜索“搭便车”</p><p id="3062" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是为什么呢？</p><p id="1f24" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">嗯，事实证明<a class="ae ly" href="https://openlibrary.org/developers" rel="noopener ugc nofollow" target="_blank"> OpenLibrary API </a>的响应时间相当慢(这就是为什么它是我们例子的一个很好的展示)。此外，较短的搜索词似乎需要更长的时间来获取，这就是为什么较早(较短)搜索词的结果在较长搜索词的结果之后到达。</p><p id="946f" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，当搜索词“搭便车”的结果到达时，对所有其他先前搜索词的请求仍然是突出的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/71454701749e16d497f495c4a5a08c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*gsAG3g97FIgGW0Y3.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">无序到达的请求</em></p></figure><p id="e924" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当它们最终完成时，花费较长时间完成的将覆盖较快的。这导致了意外的UX，我们肯定需要解决这个问题。OpenLibrary API可能是一个极端的例子，因为它的响应时间很慢，但是您也会在许多其他API中观察到类似的行为。</p><h1 id="0ff8" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">我们能解决这个问题吗？</h1><p id="470d" class="pw-post-body-paragraph lc ld it le b lf mt ju lh li mu jx lk ll mv ln lo lp mw lr ls lt mx lv lw lx im bi translated">现在，如果您以前使用过Combine，您可能会回忆起操作符——只有在两个事件之间经过了指定的时间后，该操作符才会发布事件。由于发布的属性是组合发布者，使用<code class="fe ky kz la lb b">debounce</code>操作符实际上非常简单，所以让我们看看这是否解决了问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ma l"/></div></figure><p id="1d5e" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过这种改变，当用户停止输入0.8秒时，<code class="fe ky kz la lb b">debounce</code>操作符将只发送<code class="fe ky kz la lb b">searchTerm</code>属性的最新值给接收者(在本例中是闭包)。</p><p id="c788" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">事实上，这确实解决了用户不停顿地输入搜索词的问题。但是如果他们开始输入，然后停下来想一会儿，然后在结果出来之前继续输入，我们会再次遇到同样的问题。</p><p id="c0bc" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，尽管这更好(主要是因为我们减少了发送给API的请求数量，这也有助于防止系统颠簸)，但它并不完美。</p><h1 id="1df5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">刮这个</h1><p id="0f76" class="pw-post-body-paragraph lc ld it le b lf mt ju lh li mu jx lk ll mv ln lo lp mw lr ls lt mx lv lw lx im bi translated">为了真正提高应用程序的UX，我们需要确保在发送新请求之前取消所有未完成的请求。</p><p id="3f10" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Swift的新并发功能使我们只需增加几行代码就能实现这一点。在<code class="fe ky kz la lb b">executeQuery</code>中，我们使用<code class="fe ky kz la lb b">async { }</code>(在Swift 5.5 goes GA之前将被替换为<code class="fe ky kz la lb b">Task { }</code>)从同步上下文中启动一个新的异步任务。查看源代码可以发现，<code class="fe ky kz la lb b">async</code>是一个返回<code class="fe ky kz la lb b">Task.Handle</code>的函数:</p><pre class="kj kk kl km gt nc lb nd ne aw nf bi"><span id="e378" class="ng mc it lb b gy nh ni l nj nk">public func async&lt;T&gt;(priority: Task.Priority? = nil, operation: @escaping @Sendable () async -&gt; T) -&gt; Task.Handle&lt;T, Never&gt;</span></pre><p id="6429" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe ky kz la lb b">Task.Handle</code>是与活动任务交互的启示(<a class="ae ly" href="https://developer.apple.com/documentation/swift/task/3851218-cancel" rel="noopener ugc nofollow" target="_blank">参见文档</a>)。例如，我们可以使用任务句柄来取消任务。</p><p id="6490" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">下面是更新后的<code class="fe ky kz la lb b">executeQuery</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ma l"/></div></figure><ul class=""><li id="b376" class="nl nm it le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated">为了实现这一点，我们创建了一个私有属性来保存对一个<code class="fe ky kz la lb b">Task.Handle&lt;Void, Never&gt;</code>的引用。这意味着我们的任务不返回值，并且永远不会失败(也就是说，它不会抛出)。</li><li id="2564" class="nl nm it le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">在<code class="fe ky kz la lb b">executeQuery</code>函数中，我们首先取消任何之前启动的任务。</li><li id="c940" class="nl nm it le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">接下来，我们将为新搜索请求创建的任务存储在<code class="fe ky kz la lb b">searchTask</code>属性中(这样，如果需要，我们可以在以后取消它)。</li></ul><p id="5ca2" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">基本上就是这样了！这是因为<code class="fe ky kz la lb b">URLSession</code>的异步方法支持Swift的新并发模型。要了解更多关于在URLSession中使用async/await的信息，请查看苹果官方<a class="ae ly" href="https://developer.apple.com/videos/play/wwdc2021/10095/?time=284" rel="noopener ugc nofollow" target="_blank"> WWDC视频</a>。</p><p id="d0a9" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">注意，我们通过检查当前任务是否已被取消来防止更新<code class="fe ky kz la lb b">isSearching</code>属性。该属性用于驱动UI上的进度微调器，我们希望确保只要有任何搜索请求未完成，微调器就可见。这就是为什么只有当搜索请求成功完成或者搜索项为空时，我们才可以将该属性设置为<code class="fe ky kz la lb b">false</code>。</p><p id="cb62" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果您正在使用参与协作任务取消的API，那么现在一切都准备好了。然而，如果您自己是一个API的作者，那么您需要采取一些额外的步骤来确保您的代码参与协作任务取消。</p><h1 id="d9d1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">合作任务取消</h1><p id="512b" class="pw-post-body-paragraph lc ld it le b lf mt ju lh li mu jx lk ll mv ln lo lp mw lr ls lt mx lv lw lx im bi translated"><code class="fe ky kz la lb b"><a class="ae ly" href="https://developer.apple.com/documentation/swift/task/3851218-cancel" rel="noopener ugc nofollow" target="_blank">cancel</a></code>的文档包含非常重要的注释:</p><blockquote class="nz oa ob"><p id="bf65" class="lc ld oc le b lf lg ju lh li lj jx lk od lm ln lo oe lq lr ls of lu lv lw lx im bi translated">这个函数是否有任何作用取决于任务。</p><p id="a4c6" class="lc ld oc le b lf lg ju lh li lj jx lk od lm ln lo oe lq lr ls of lu lv lw lx im bi translated">对于考虑取消的任务，它必须在运行时合作检查取消。许多任务在开始它们的“实际工作”之前会检查取消，但是这不是一个要求，也不能保证任务通常如何以及何时检查取消。"</p></blockquote><p id="eb5f" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这意味着当调用者请求取消您的代码正在运行的任务时，您有责任尽快停止任何工作。</p><p id="4ac2" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">考虑下面的代码片段。它是计算第n个斐波那契数的函数的迭代实现。我通过在内部循环中添加<code class="fe ky kz la lb b">Task.sleep()</code>人为地减慢了算法的速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ma l"/></div></figure><p id="98c8" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">通过调用<code class="fe ky kz la lb b">Task.checkCancellation()</code>，该函数检查调用者是否请求取消任务。<code class="fe ky kz la lb b">Task.checkCancellation()</code>会检查<code class="fe ky kz la lb b">Task.isCancelled</code>是否为真，如果为真就会抛出<code class="fe ky kz la lb b">Task.CancellationError</code>。这样，<code class="fe ky kz la lb b">fibonacci</code>函数可以在其内部循环的每次迭代后停止任何正在进行的工作。</p><p id="e57e" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果您不想抛出<code class="fe ky kz la lb b">Task.CancellationError</code>，您可以使用<code class="fe ky kz la lb b">Task.isCancelled</code>来检查当前任务是否已经被取消，并停止任何正在进行的工作。</p><p id="27ae" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">抛出错误只是响应取消的一种方式。根据代码执行的工作类型，您应该选择以下哪个选项效果最好:</p><ul class=""><li id="33be" class="nl nm it le b lf lg li lj ll nn lp no lt np lx nq nr ns nt bi translated">抛出一个错误(如上所示)</li><li id="64b9" class="nl nm it le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">返回<code class="fe ky kz la lb b">nil</code>或空集合</li><li id="e3d5" class="nl nm it le b lf nu li nv ll nw lp nx lt ny lx nq nr ns nt bi translated">返回部分完成的工作</li></ul><h1 id="4b4a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">SwiftUI的新任务()视图修改器</h1><p id="c386" class="pw-post-body-paragraph lc ld it le b lf mt ju lh li mu jx lk ll mv ln lo lp mw lr ls lt mx lv lw lx im bi translated">SwiftUI具有一个新的视图修饰符，允许您在视图一出现就在异步任务中运行代码。一旦视图消失，它将自动取消任务。</p><p id="aa72" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是本系列上一篇文章<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/getting-started-with-async-await-in-swiftui-for-ios-15-f627eb722a4b">中示例的一个片段:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my ma l"/></div></figure><p id="85f2" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果您需要在视图出现时调用异步代码，最好使用<code class="fe ky kz la lb b">task { }</code>而不是<code class="fe ky kz la lb b">onAppear</code> / <code class="fe ky kz la lb b">onDisappear</code>。</p><h1 id="ffee" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">生产的</h1><p id="17a3" class="pw-post-body-paragraph lc ld it le b lf mt ju lh li mu jx lk ll mv ln lo lp mw lr ls lt mx lv lw lx im bi translated">最后一条建议:如果你正在编写计算密集型代码，你应该时不时地调用<code class="fe ky kz la lb b">Task.yield()</code>向系统让步，让它有机会执行任何其他工作，比如更新UI。如果你不这样做，你的应用对用户来说可能看起来是冻结的，即使它正在运行一些计算密集型代码。</p><h1 id="0709" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">关闭</h1><p id="5b0a" class="pw-post-body-paragraph lc ld it le b lf mt ju lh li mu jx lk ll mv ln lo lp mw lr ls lt mx lv lw lx im bi translated">Swift的新并发模型使得编写以可预测和结构化的方式处理并发的结构良好的应用程序变得容易。就个人而言，我喜欢以特定领域的方式将概念添加到语言中的方式——这与Swift的许多其他领域也使用DSL方法(例如SwiftUI本身)是一致的。</p><p id="3282" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我希望这篇文章能帮助你理解如何使用任务取消来使你的用户界面更加可预测，并增加它们的可用性。</p><p id="55f4" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">请记住，Swift的结构化并发仍然是一项正在进行的工作，它的一些功能正在经历<a class="ae ly" href="https://twitter.com/dgregor79/status/1412944336572932096" rel="noopener ugc nofollow" target="_blank">一些</a> <a class="ae ly" href="https://github.com/apple/swift/commit/a7eed56988d7675e693692b1a97d4a34c7eac334" rel="noopener ugc nofollow" target="_blank">波动</a>。为了掌握最新情况，我建议关注相关提案并关注Swift论坛上的讨论:</p><div class="og oh gp gr oi oj"><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">苹果/swift-进化</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">是一种用于编写自然、高效的异步代码的语言机制。异步函数(引入于…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://forums.swift.org/t/swift-concurrency-feedback-wanted/49336" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">快速并发:需要反馈！</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">今天苹果发布了Xcode 13的首个测试版。这包括Swift 5.5，支持本地语言并发…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">forums.swift.org</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><p id="121f" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">感谢阅读！</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="86b2" class="pw-post-body-paragraph lc ld it le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="oc">原载于</em><a class="ae ly" href="https://peterfriese.dev/swiftui-concurrenct-essentials-part2/" rel="noopener ugc nofollow" target="_blank"><em class="oc">https://peterfriese . dev</em></a><em class="oc">。</em></p></div></div>    
</body>
</html>