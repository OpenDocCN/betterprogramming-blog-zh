<html>
<head>
<title>3 Modern Ways To Tackle Assisted Injection for ViewModels in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决Android中视图模型辅助注入的3种现代方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-modern-ways-to-tackle-assisted-injection-for-viewmodels-in-android-ce817b3b8f47?source=collection_archive---------0-----------------------#2021-05-17">https://betterprogramming.pub/3-modern-ways-to-tackle-assisted-injection-for-viewmodels-in-android-ce817b3b8f47?source=collection_archive---------0-----------------------#2021-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d438" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Dagger和SavedStateHandle保存您的状态</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/64514c91112ded46416915df534070a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*scgAFyqu05GfQ4Zg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="5e0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在使用<a class="ae kv" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank"> Dagger </a>作为依赖注入(DI)框架，那么您很可能已经面临无法提供所有依赖的情况。</p><p id="cc0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从一个简单的例子开始。首先，我们希望创建一个需要存储库来运行的管理器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要用Dagger提供存储库依赖，您最终会得到这样的结果(假设在某个<code class="fe lu lv lw lx b">Module</code>中提供了<code class="fe lu lv lw lx b">Repository</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们假设您需要一个标识符来从存储库中获取特定的资源。您需要将这个标识符传递给管理器，让注入的存储库查询所需的资源:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ff08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为Dagger不能提供这个运行时参数，所以您可以从构造函数中提取它，并通过以下方式之一手动提供它:</p><ul class=""><li id="9fbb" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">使用<code class="fe lu lv lw lx b">lateinit</code>并祈祷管理器在使用它之前收到它的值，否则应用程序将崩溃:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><ul class=""><li id="79ea" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">声明标识符可空并处理可空性，虽然这没有意义(因为没有它管理器就不能操作):</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><ul class=""><li id="e906" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">创建一个包含所有可注入参数的工厂，然后通过一个<code class="fe lu lv lw lx b">create</code>方法给出运行时参数:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么你就需要注入<code class="fe lu lv lw lx b">Factory</code>而不是经理。最后，您将使用<code class="fe lu lv lw lx b">create</code>方法传入标识符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，所有这些解决方案都是可行的，但是它们都有局限性。此外，我们还有两个未解决的问题:</p><ol class=""><li id="e575" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr mh me mf mg bi translated">提供一个<code class="fe lu lv lw lx b">ViewModel</code>并不像上面的例子那样简单。</li><li id="83d7" class="ly lz iq ky b kz mi lc mj lf mk lj ml ln mm lr mh me mf mg bi translated">我们还没有解决如何在<code class="fe lu lv lw lx b">ViewModel</code>中存储我们的状态。</li></ol></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="d227" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">提供保存状态的视图模型</h1><p id="8306" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">如前所述，<code class="fe lu lv lw lx b">ViewModel</code>的DI不像其他对象那样工作。即使您可以让Dagger提供您的构造函数参数，您仍然需要使用一个<code class="fe lu lv lw lx b">ViewModelProvider</code>来创建一个<code class="fe lu lv lw lx b">ViewModel</code>实例。</p><p id="eb65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提供者希望拥有者和工厂都可以传递注入的参数:</p><pre class="kg kh ki kj gt nr lx ns nt aw nu bi"><span id="4643" class="nv mv iq lx b gy nw nx l ny nz">ViewModelProvider(owner, factory).get(MyViewModel::class.java)</span></pre><p id="0985" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有者定义了<code class="fe lu lv lw lx b">ViewModel</code>的范围。根据它，系统将知道是创建一个新的<code class="fe lu lv lw lx b">ViewModel</code>还是检索一个现有的满足所有者的。大多数时候，它要么是一个<code class="fe lu lv lw lx b">Activity</code>，要么是一个<code class="fe lu lv lw lx b">Fragment</code>。</p><p id="1744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">复杂的部分是工厂自带的。当向您的<code class="fe lu lv lw lx b">ViewModel</code>提供参数时，您需要将这些参数传递给扩展androidX <code class="fe lu lv lw lx b">ViewModelProvider.Factory</code>的定制工厂。</p><p id="7e33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会详述，因为有很多方法可以做到这一点——手动或利用<a class="ae kv" href="https://blog.kotlin-academy.com/understanding-dagger-2-multibindings-viewmodel-8418eb372848" rel="noopener ugc nofollow" target="_blank">匕首多绑定</a>。</p><p id="bd5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于保存状态，androidX给出了一个基于<code class="fe lu lv lw lx b">SavedStateHandle</code>对象的机制。它接受一个<code class="fe lu lv lw lx b">Bundle</code>，您可以将想要存储的数据放在这里，并直接从您的<code class="fe lu lv lw lx b">ViewModel</code>中检索。</p><p id="932f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的例子中，我们将标识符插入到一个<code class="fe lu lv lw lx b">Bundle</code>中，并将其传递给一个<code class="fe lu lv lw lx b">SavedStateHandle</code>实例。这里，我公开了一个静态的<code class="fe lu lv lw lx b">map</code>方法来从标识符参数中创建<code class="fe lu lv lw lx b">SavedStateHandle</code>，并且我可以在任何时候从<code class="fe lu lv lw lx b">ViewModel</code>中检索它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="25e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要在项目中包含这种依赖关系:</p><pre class="kg kh ki kj gt nr lx ns nt aw nu bi"><span id="5e08" class="nv mv iq lx b gy nw nx l ny nz">implementation("androidx.lifecycle:lifecycle-viewmodel-savedstate:${latest_version}")</span></pre></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="b9c4" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">辅助注射抢救</h1><p id="21ba" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">我们试图找到一个解决方案，让我们的DI用提供的参数和运行时参数构建一个对象。此外，我们还想在<code class="fe lu lv lw lx b">ViewModel</code>内保存我们的状态。</p><p id="38e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过多次实验后，我向您展示了三种可行的替代方案及其优缺点。</p><p id="8fb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，选择一个解决方案主要取决于您的项目设置。</p><p id="82d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，我们的候选人来了！</p><h2 id="83a3" class="nv mv iq bd mw oa ob dn na oc od dp ne lf oe of ng lj og oh ni ln oi oj nk ok bi translated">1.优雅的视图模型注入库</h2><p id="0756" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">我本来可以先给大家展示一下Square制作的<a class="ae kv" href="https://github.com/cashapp/InflationInject" rel="noopener ugc nofollow" target="_blank">辅助注射</a>库。然而，<a class="ol om ep" href="https://medium.com/u/105afd7f0a0b?source=post_page-----ce817b3b8f47--------------------------------" rel="noopener" target="_blank">乔丹·汉森</a>走得更远，在方形图书馆的顶部创建了一个<a class="ae kv" href="https://github.com/hansenji/ViewModelInject" rel="noopener ugc nofollow" target="_blank">图书馆</a>。它提供了一个简洁的API:</p><ul class=""><li id="1def" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">通过自定义的<code class="fe lu lv lw lx b">@ViewModelInject</code>注释生成<code class="fe lu lv lw lx b">ViewModel</code>工厂。</li><li id="a50b" class="ly lz iq ky b kz mi lc mj lf mk lj ml ln mm lr md me mf mg bi translated">接受带有方形<code class="fe lu lv lw lx b">@Assisted</code>注释的<code class="fe lu lv lw lx b">SavedStateHandle</code>参数。</li></ul><p id="d675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很棒，对吧？它解决了我们所有的需求，没有任何样板文件。这就是我们前面的例子使用这个库的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="902c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，你需要为每个Gradle模块创建一个Dagger模块<em class="on">。</em>和它的命名有关。假设我正在名为<code class="fe lu lv lw lx b">awesome-module</code>的Gradle模块中创建<code class="fe lu lv lw lx b">ViewModel</code>。Dagger模块必须是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1357" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您可以注入生成的工厂，并通过intent的捆绑包使用它的<code class="fe lu lv lw lx b">create</code>方法。该库将通过在<code class="fe lu lv lw lx b">intent.extras</code>中提供<code class="fe lu lv lw lx b">Activity</code>的包来为您构建<code class="fe lu lv lw lx b">SavedStateHandle</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="03b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以更进一步，用Kotlin委托创建我们的<code class="fe lu lv lw lx b">ViewModel</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么上面的例子就变成了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="bd1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这个库符合我们的期望，但值得一提的是，您将需要依赖这个库和来自Square的AssistedInject。此外，当Dagger最近支持这种DI模式时，这两个库都被弃用了。</p><p id="50d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们注意到这个库不能很好地处理增量构建。生成的代码经常碍事，迫使您临时禁用<code class="fe lu lv lw lx b">gradle.properties</code>文件中的增量构建来重置缓存。</p><h2 id="9fda" class="nv mv iq bd mw oa ob dn na oc od dp ne lf oe of ng lj og oh ni ln oi oj nk ok bi translated">2.新人剑柄</h2><p id="c2b5" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">虽然<a class="ae kv" href="https://dagger.dev/hilt/" rel="noopener ugc nofollow" target="_blank">剑柄</a>在2020年才刚刚出现在我们的雷达上，但是这个很有前途的DI库在几周前才刚刚稳定下来(撰写本文时)。所有的目光都投向了这位新候选人。</p><p id="b26c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它不仅使用与Dagger相同的机制，而且还消除了配置项目使用DI的所有障碍。</p><p id="319f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于辅助注射，<a class="ae kv" href="https://dagger.dev/hilt/view-model.html" rel="noopener ugc nofollow" target="_blank">手柄将其支撑在盒外</a>。你所需要做的就是用<code class="fe lu lv lw lx b">@HiltViewModel</code>注释你的<code class="fe lu lv lw lx b">ViewModel</code>类，并在构造函数中给出一个<code class="fe lu lv lw lx b">SavedStateHandle</code>参数。当创建<code class="fe lu lv lw lx b">ViewModel</code>时，Hilt将解析它的依赖项并提供一个<code class="fe lu lv lw lx b">SavedStateHandle</code>。甚至不需要注射一个<code class="fe lu lv lw lx b">Factory</code>。希尔特为你做一切！</p><p id="735d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用内置的Kotlin委托，您需要添加以下依赖项:</p><pre class="kg kh ki kj gt nr lx ns nt aw nu bi"><span id="4713" class="nv mv iq lx b gy nw nx l ny nz">implementation("androidx.activity:activity-ktx:{latest_version}")<br/>implementation("androidx.activity:fragment-ktx:{latest_version}")</span></pre><p id="cb59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们将Kotlin委托给<code class="fe lu lv lw lx b">Activity</code>和<code class="fe lu lv lw lx b">Fragment</code>，这将懒洋洋地创建您的<code class="fe lu lv lw lx b">ViewModel</code>:</p><pre class="kg kh ki kj gt nr lx ns nt aw nu bi"><span id="a405" class="nv mv iq lx b gy nw nx l ny nz">// From an Activity<br/>val viewModel: MyViewModel by viewModels() // Activity scope</span><span id="cb01" class="nv mv iq lx b gy oo nx l ny nz">// From a Fragment<br/>val viewModel: MyViewModel by viewModels() // Fragment scope<br/>val viewModel: MyViewModel by activityViewModels() // Activity scope</span></pre><p id="cd2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，使用Hilt的辅助注射可以归结为这几行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="d616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从理论上讲，Hilt看起来为我们的问题提供了最先进和最简洁的API。然而，如果我能给出我的两美分:</p><ol class=""><li id="8b03" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr mh me mf mg bi translated"><code class="fe lu lv lw lx b">ViewModel</code>的辅助注射是自动进行的，对于未经训练的眼睛来说可能会感到困惑。了解它在引擎盖下的工作原理会有所帮助。否则，请做好调试应用程序的准备。</li><li id="3347" class="ly lz iq ky b kz mi lc mj lf mk lj ml ln mm lr mh me mf mg bi translated">Hilt几乎没有达到稳定，大多数项目不使用这个DI库。此外，迁移到Hilt并不便宜，而且可能无法提供与当前DI系统相同的功能。</li></ol><h2 id="28a3" class="nv mv iq bd mw oa ob dn na oc od dp ne lf oe of ng lj og oh ni ln oi oj nk ok bi translated">3.升级版匕首</h2><p id="a3c3" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">最后但同样重要的是，我们又回到了老匕首！从<a class="ae kv" href="https://dagger.dev/dev-guide/assisted-injection.html" rel="noopener ugc nofollow" target="_blank">版本2.31 </a>开始，匕首支持辅助注射。</p><p id="0503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它结合了两个注释来告诉匕首如何注射你的<code class="fe lu lv lw lx b">ViewModel</code>。在我们之前的示例中，实现是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a7f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的<code class="fe lu lv lw lx b">@AssistedFactory</code>接口必须符合两点:</p><ol class=""><li id="b7e6" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr mh me mf mg bi translated">它必须包含一个方法。</li><li id="5ddc" class="ly lz iq ky b kz mi lc mj lf mk lj ml ln mm lr mh me mf mg bi translated">这个方法必须返回<code class="fe lu lv lw lx b">ViewModel</code>类类型。</li></ol><p id="ff10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lu lv lw lx b">SavedStateViewModelFactory</code>声明通用契约，这样你只需要标注你的工厂接口，让它扩展这个接口。</p><p id="f604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于创建<code class="fe lu lv lw lx b">ViewModel</code>，你需要注入工厂并给它<code class="fe lu lv lw lx b">Activity</code>的包来创建<code class="fe lu lv lw lx b">SavedStateHandle</code>辅助对象。为了简化这一点，我们将创建自己的Kotlin委托:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来就是注入工厂，并把它交给我们的委托，用给定的<code class="fe lu lv lw lx b">SavedStateHandle</code>调用它的<code class="fe lu lv lw lx b">create</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个，一切都用纯匕首工作，代价是一个科特林代表协助你。如果我们将其与Hilt进行比较，它会更加冗长，因为您需要:</p><ul class=""><li id="d811" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">用<code class="fe lu lv lw lx b">@Assisted</code>注释声明所有辅助参数。</li><li id="e570" class="ly lz iq ky b kz mi lc mj lf mk lj ml ln mm lr md me mf mg bi translated">用带有所有<code class="fe lu lv lw lx b">@Assisted</code>参数的<code class="fe lu lv lw lx b">@AssistedFactory</code>注释声明一个工厂(顺序很重要！).</li><li id="32b3" class="ly lz iq ky b kz mi lc mj lf mk lj ml ln mm lr md me mf mg bi translated">注入工厂，并把它交给一个Kotlin委托(与androidX委托不兼容)。</li></ul><p id="3363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">话虽如此，你不需要任何额外的第三方库。你也不会弄清楚刀柄是如何连接所有东西的。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="73ad" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">你应该选择哪种解决方案？</h1><p id="645d" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">无论你选择什么样的解决方案，请记住，它总是取决于你的项目的限制和你在使用阿迪解决方案时的价值。</p><p id="030a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个方案我用了很久，很满意。然而，我正在考虑转移到第三个解决方案，因为我看不出现在有理由迁移到Hilt。如果我要开始一个全新的项目，我可能会考虑第二种选择。</p></div></div>    
</body>
</html>