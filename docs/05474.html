<html>
<head>
<title>Previous Routes in Angular 6+</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度为6+的先前路线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/previous-route-in-angular-6-484288410d99?source=collection_archive---------1-----------------------#2020-07-11">https://betterprogramming.pub/previous-route-in-angular-6-484288410d99?source=collection_archive---------1-----------------------#2020-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4824" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个简单的服务，在Angular应用程序中提供以前路线的信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f76dd236e56ebc30bae39e7846de10d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*08kE2TlxWnPFKzOs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Javier Allegue Barros 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="daa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Angular的特点是功能强大、用途广泛的<a class="ae ky" href="https://angular.io/api/router" rel="noopener ugc nofollow" target="_blank">路由器</a>。最近，我需要确保我的组件能够访问用户在我的应用程序中访问的前一条路线的信息。令我惊讶的是，路由器目前并不支持这种开箱即用的功能。但它仍然提供了快速构建这一功能的必要手段。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c761" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">范围</h1><p id="5b6b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我的用例假设我只需要访问我的各种组件的<code class="fe mz na nb nc b">ngOnInit()</code>生命周期钩子内的前一条路径，并且我不需要在页面重载过程中保持信息的持久性。所以我决定:</p><ul class=""><li id="0dae" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">创建一个名为<code class="fe mz na nb nc b">PreviousRouteService</code>的简单根范围服务</li><li id="3101" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">利用路由器事件来跟踪和捕获以前和当前的路由信息</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d6c1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">服务</h1><p id="e4e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我创建了一个简单的角度服务，其作用范围在应用程序的根级别。然后，我导入了路由器，并为<code class="fe mz na nb nc b">previousUrl</code>添加了属性和一个<code class="fe mz na nb nc b">getter</code>方法。然后，我订阅了所有路由器事件，以查看路由更改期间发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在路由改变期间，路由器触发<a class="ae ky" href="https://angular.io/api/router/RouterEvent" rel="noopener ugc nofollow" target="_blank">多种类型的事件</a>，您可以针对符合您要求的事件。在我的例子中，我决定使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://angular.io/api/router/NavigationEnd" rel="noopener ugc nofollow" target="_blank">NavigationEnd</a></code>,因为我的应用程序使用了<code class="fe mz na nb nc b">canLoad</code> / <code class="fe mz na nb nc b">canActivate</code>守卫，并且我想只统计导致用户实际导航到这样一个页面的成功的路由更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="28a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步改进它</h1><p id="c017" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上面的内容通常是可行的，但是挑战在于，通过使用<code class="fe mz na nb nc b">NavigationEnd</code>，我们面临一个<em class="nt">竞争条件:</em>当导航循环仍在进行并且<code class="fe mz na nb nc b">NavigationEnd</code>事件尚未触发时，页面用户被重定向到对我们的构造函数或<code class="fe mz na nb nc b">ngOnInit</code>钩子内部的服务的调用。</p><p id="0dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这里的选择是要么使用另一个在调用<code class="fe mz na nb nc b">getPreviousUrl</code>之前可靠结束的<code class="fe mz na nb nc b">RouterEvent</code>(比如<code class="fe mz na nb nc b"><a class="ae ky" href="https://angular.io/api/router/ResolveEnd" rel="noopener ugc nofollow" target="_blank">ResolveEnd</a></code>)，要么利用订阅(比如<code class="fe mz na nb nc b"><a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank">BehaviorSubject</a></code>)而不是简单的getter:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，有了订阅，我们可以这样在应用程序的组件中使用我们的服务，记住要在组件销毁挂钩上取消订阅:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1e64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，解决方案工作可靠，我可以实现进一步的功能，这需要用户知道以前访问过的路线。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c1a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6669" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">希望你喜欢这篇短文，祝大家编码愉快。</p></div></div>    
</body>
</html>