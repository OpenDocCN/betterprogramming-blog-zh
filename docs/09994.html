<html>
<head>
<title>Build a Time-Tracking CLI Application Using a Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用测试驱动开发构建时间跟踪CLI应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-time-tracking-cli-application-using-a-test-driven-development-9d238f3c306c?source=collection_archive---------13-----------------------#2021-11-10">https://betterprogramming.pub/build-a-time-tracking-cli-application-using-a-test-driven-development-9d238f3c306c?source=collection_archive---------13-----------------------#2021-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="94d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用oclif测试库的TDD</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5251c1b9ed98d3c62aff8c103b057284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FH9lms6AgPOldECi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然编写CLI工具很有趣，但初始设置和样板文件——解析参数和标志、验证、子命令——对于每个CLI来说通常都是一样的，而且很麻烦。这就是oclif框架拯救世界的地方。编写单命令或多命令CLI的样板文件消失了，您可以快速进入您真正想要编写的代码。</p><p id="171b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等——还有更多！<code class="fe lw lx ly lz b">oclif</code>还有一个测试框架，让您可以像用户一样执行CLI，捕捉标准输出和错误，以便您可以测试预期。在本文中，我将向您展示如何轻松编写和测试一个<code class="fe lw lx ly lz b">oclif</code> CLI应用程序。</p><h1 id="103d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">我们要建造什么？</h1><p id="79c6" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们都厌倦了在典型的TODO应用程序上工作。相反，让我们构建一些不同但简单的东西。我们将使用测试驱动开发(TDD)方法来构建一个时间跟踪应用程序。我们的CLI将允许我们执行以下操作:</p><ul class=""><li id="820f" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">添加项目</li><li id="eda7" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">这些项目的开始和结束计时器</li><li id="b3f0" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">查看项目的总支出</li><li id="ef6b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">查看给定项目在每个条目上花费的时间</li></ul><p id="eca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个与<code class="fe lw lx ly lz b">time-tracker</code> CLI交互的示例:</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="73a5" class="np mb it lz b gy nq nr l ns nt">~ time-tracker add-project project-one<br/>Created new project "project-one"</span><span id="11f1" class="np mb it lz b gy nu nr l ns nt">~ time-tracker start-timer project-one<br/>Started a new time entry on "project-one"</span><span id="bd4a" class="np mb it lz b gy nu nr l ns nt">~ time-tracker start-timer project-two<br/> &gt;   Error: Project "project-two" does not exist</span><span id="7163" class="np mb it lz b gy nu nr l ns nt">~ time-tracker add-project project-two<br/>Created new project "project-two"</span><span id="71af" class="np mb it lz b gy nu nr l ns nt">~ time-tracker start-timer project-two<br/>Started a new time entry on "project-two"</span><span id="9e24" class="np mb it lz b gy nu nr l ns nt">~ time-tracker end-timer project-two<br/>Ended time entry for "project-two"</span><span id="5f96" class="np mb it lz b gy nu nr l ns nt">~ time-tracker list-projects<br/>project-one (0h 0m 13.20s)<br/>- 2021-09-20T13:13:09.192Z - 2021-09-20T13:13:22.394Z (0h 0m 13.20s)<br/>project-two (0h 0m 7.79s)<br/>- 2021-09-20T13:13:22.394Z - 2021-09-20T13:13:30.189Z (0h 0m 7.79s)</span></pre><p id="0d55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在一个“数据库”(一个简单的JSON数据文件)中管理所有关于添加项目和活动计时器的数据。</p><p id="3188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的时间跟踪应用程序项目的源代码可以在<a class="ae ky" href="https://github.com/bloveless/oclif-time-tracker" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们是用TDD的方式来做的，所以让我们开始吧…先测试一下！</p><h1 id="2c9b" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">我们的时间跟踪器:特征和测试</h1><p id="d58a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">当我们描述我们的应用程序的特性时，我们应该考虑我们可以编写的测试来断言我们对这些特性的期望。以下是我们应用程序的功能列表:</p><h2 id="42cd" class="np mb it bd mc nv nw dn mg nx ny dp mk li nz oa mm lm ob oc mo lq od oe mq of bi translated">创建新项目</h2><ul class=""><li id="7709" class="mx my it lb b lc ms lf mt li og lm oh lq oi lu nc nd ne nf bi translated"><strong class="lb iu">快乐路径</strong>:新项目被创建，其记录被存储在底层数据库中。用户收到一条确认消息。</li><li id="968c" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu"> Sad path </strong>:如果项目已经存在，那么用户会看到一条错误消息。底层数据库将保持不变。</li></ul><h2 id="d634" class="np mb it bd mc nv nw dn mg nx ny dp mk li nz oa mm lm ob oc mo lq od oe mq of bi translated">启动项目计时器</h2><ul class=""><li id="1b66" class="mx my it lb b lc ms lf mt li og lm oh lq oi lu nc nd ne nf bi translated"><strong class="lb iu">快乐路径</strong>:请求的项目已经存在，所以我们可以开始一个新的时间条目，将startTime设置为当前日期/时间。当计时器开始计时时，用户将收到通知。</li><li id="6e01" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu">快乐之路</strong>:如果定时器已经在另一个项目上运行，那么该定时器将停止，新的定时器将在所请求的项目上开始。当计时器开始计时时，用户将收到通知。</li><li id="8156" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu"> Sad path </strong>:如果项目不存在，那么用户会看到一条错误信息。底层数据库将保持不变。</li></ul><h2 id="8495" class="np mb it bd mc nv nw dn mg nx ny dp mk li nz oa mm lm ob oc mo lq od oe mq of bi translated">结束项目的计时器</h2><ul class=""><li id="7e0a" class="mx my it lb b lc ms lf mt li og lm oh lq oi lu nc nd ne nf bi translated"><strong class="lb iu">快乐之路</strong>:请求的项目上有一个计时器处于活动状态，因此我们可以结束该计时器并通知用户。</li><li id="7d80" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu"> Sad path </strong>:如果项目不存在，那么会给用户一个错误信息。底层数据库将保持不变。</li><li id="dc03" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><strong class="lb iu"> Sad路径</strong>:如果项目存在，但没有激活的定时器，那么用户将被通知。底层数据库将保持不变。</li></ul><h2 id="e82f" class="np mb it bd mc nv nw dn mg nx ny dp mk li nz oa mm lm ob oc mo lq od oe mq of bi translated">列出项目</h2><ul class=""><li id="4781" class="mx my it lb b lc ms lf mt li og lm oh lq oi lu nc nd ne nf bi translated"><strong class="lb iu">快乐路径</strong>:向用户显示所有项目、总次数、条目、条目次数。</li></ul><h2 id="d1af" class="np mb it bd mc nv nw dn mg nx ny dp mk li nz oa mm lm ob oc mo lq od oe mq of bi translated">数据库存在(对于所有命令)</h2><ul class=""><li id="0760" class="mx my it lb b lc ms lf mt li og lm oh lq oi lu nc nd ne nf bi translated"><strong class="lb iu"> Sad path </strong>:如果当前目录下没有<code class="fe lw lx ly lz b">time.json</code>文件，那么会给用户一个错误信息。</li></ul><p id="70f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于数据存储——我们的“数据库”——我们将时间条目作为JSON存储在磁盘上一个名为<code class="fe lw lx ly lz b">time.json</code>的文件中。以下是该文件的外观示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h1 id="c9a6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">设计决策</h1><p id="a895" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">最后，让我们讨论一下整个应用程序的一些设计决策。</p><p id="256c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将在JSON数据的顶层存储一个<code class="fe lw lx ly lz b">activeProject</code>。我们可以用它来快速检查哪个项目是活动的。其次，我们将在每个项目的<em class="lv">中存储一个<code class="fe lw lx ly lz b">activeEntry</code>字段，它存储当前正在处理的条目的索引。</em></p><p id="edf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这两条信息，我们可以直接导航到活动项目及其活动条目，以便结束计时器。我们还可以立即确定该项目是否有任何活动条目，或者是否有任何活动项目。</p><h1 id="96fa" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">项目设置</h1><p id="14fc" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在我们已经打下了所有的基础，让我们创建一个新的项目，并开始深入研究。下面是第一条命令:</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="cc66" class="np mb it lz b gy nq nr l ns nt">npx oclif multi time-tracker</span></pre><p id="0670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令创建一个新的<a class="ae ky" href="https://oclif.io/docs/multi" rel="noopener ugc nofollow" target="_blank">多命令oclif应用程序</a>。有了多命令CLI，我们可以运行像<code class="fe lw lx ly lz b">time-tracker add-project project-one</code>和<code class="fe lw lx ly lz b">time-tracker start-timer project-one</code>这样的命令。在这些例子中，<code class="fe lw lx ly lz b">add-project</code>和<code class="fe lw lx ly lz b">start-timer</code>都是独立的命令，每个命令都存储在项目中自己的源文件中，但是它们都在<code class="fe lw lx ly lz b">time-tracker</code> CLI下。</p><h1 id="bba2" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">关于存根的一句话</h1><p id="64ef" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们想利用<code class="fe lw lx ly lz b">@oclif/test</code>提供的测试助手。为了测试我们的特定应用程序，我们需要编写一个简单的存根。原因如下:</p><p id="be60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序写入文件系统上的一个<code class="fe lw lx ly lz b">timer.json</code>文件。想象一下，如果我们并行运行我们的测试，并且有十个测试同时写入同一个文件。那会变得混乱，并产生不可预测的结果。</p><p id="53c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更好的方法是让每个测试写入它自己的文件，对照那些文件进行测试，然后自己清理。更好的是，每个测试可以写入内存中的一个对象，而不是一个文件，我们可以断言我们对该对象的期望。</p><p id="3343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写单元测试的最佳实践是用别的东西替换驱动程序。在我们的例子中，我们将使用一个<code class="fe lw lx ly lz b">MemoryStorage</code>驱动程序来清除默认的<code class="fe lw lx ly lz b">FilesystemStorage</code>驱动程序。</p><p id="e005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">@oclif/test 是围绕<a class="ae ky" href="https://github.com/oclif/fancy-test" rel="noopener ugc nofollow" target="_blank"> @oclif/fancy-test </a>的一个简单包装器，它增加了一些测试CLI命令的功能。我们将使用<code class="fe lw lx ly lz b">@oclif/fancy-test</code>中的<a class="ae ky" href="https://github.com/oclif/fancy-test#stub" rel="noopener ugc nofollow" target="_blank">存根功能</a>来替换测试命令中的存储驱动程序。</p><h1 id="b363" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">我们的第一个命令:添加项目</h1><p id="2d1d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在，让我们谈谈“添加项目”命令和与模拟文件系统相关的重要部分。每个新的oclif项目都以<code class="fe lw lx ly lz b">src/commands</code>中的<code class="fe lw lx ly lz b">hello.js</code>文件开始。我们将它重命名为<code class="fe lw lx ly lz b">add-project.js</code>文件，并用最少的文件填充它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h1 id="831e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">用于测试的可交换存储</h1><p id="b3f3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">注意我是如何静态地将一个<code class="fe lw lx ly lz b">FilesystemStorage</code>实例分配给<code class="fe lw lx ly lz b">AddProjectCommand.storage</code>的。这允许我在测试中用内存存储实现替换文件系统存储。下面我们来看看<code class="fe lw lx ly lz b">FilesystemStorage</code>和<code class="fe lw lx ly lz b">MemoryStorage</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">FilesystemStorage</code>和<code class="fe lw lx ly lz b">MemoryStorage</code>有相同的接口，所以我们可以在测试中用一个替换另一个。</p><h1 id="992f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">添加项目命令的第一个测试</h1><p id="bca7" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在<code class="fe lw lx ly lz b">test/commands</code>中，我们将<code class="fe lw lx ly lz b">hello.test.js</code>重命名为<code class="fe lw lx ly lz b">add-project.test.js</code>，并且我们已经编写了我们的第一个测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="abfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇的事情发生在<code class="fe lw lx ly lz b">stub</code>呼叫中。我们用<code class="fe lw lx ly lz b">MemoryStorage</code>替换掉<code class="fe lw lx ly lz b">FilesystemStorage</code>(用一个空对象作为初始数据)。然后，我们断言对存储内容的期望。</p><h1 id="0d72" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">从<a class="ae ky" href="http://twitter.com/oclif/Test" rel="noopener ugc nofollow" target="_blank"> @oclif/Test </a>解包测试命令</h1><p id="2f12" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在实现我们的命令之前，让我们确保理解了我们的测试文件。我们的<code class="fe lw lx ly lz b">describe</code>块调用<code class="fe lw lx ly lz b">test</code>，它是<code class="fe lw lx ly lz b">@oclif/fancy-test</code>(从<code class="fe lw lx ly lz b">@oclif/test</code>再导出)的入口点。</p><p id="8152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，<code class="fe lw lx ly lz b">.stdout()</code>方法捕获命令的输出，让您通过使用<code class="fe lw lx ly lz b">ctx.stdout</code>断言对它的期望。还有一个<code class="fe lw lx ly lz b">.stderr()</code>方法，但是我们稍后会看到在<code class="fe lw lx ly lz b">@oclif/fancy-test.</code>中有另一个更好的处理错误的方法</p><p id="a110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数应用程序，您通常不会断言要写入标准输出的内容。然而，在CLI的情况下，这是您与用户的主要接口之一，因此根据标准输出进行测试是有意义的。</p><p id="082e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，这里有一个主要问题！如果您在开发过程中使用<code class="fe lw lx ly lz b">console.log</code>进行调试，那么<code class="fe lw lx ly lz b">.stdout()</code> <strong class="lb iu">也将捕获该输出。</strong>除非你断言反对<code class="fe lw lx ly lz b">ctx.stdout</code>，否则你可能永远看不到那个输出。</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="b926" class="np mb it lz b gy nq nr l ns nt">.stub(AddProjectCommand, 'storage', new MemoryStorage({}))</span></pre><p id="9ad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经讨论了一点<code class="fe lw lx ly lz b">.stub</code>方法，但是我们在这里做的是用<code class="fe lw lx ly lz b">MemoryStorage</code>代替默认的<code class="fe lw lx ly lz b">FilesystemStorage</code>来替换我们命令上的静态属性。</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="c642" class="np mb it lz b gy nq nr l ns nt">.command(['add-project', 'project-one'])</span></pre><p id="aac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<code class="fe lw lx ly lz b">.command</code>是事情变得真正酷的地方。该行调用您的CLI，就像您从命令行调用一样。你可以传入标志和它们的值或者一个参数列表，就像我在这里做的一样。<code class="fe lw lx ly lz b">@oclif/test</code>将调用您的命令，就像最终用户在命令行调用它一样。</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="5663" class="np mb it lz b gy nq nr l ns nt">.it('test description', () =&gt; [...])</span></pre><p id="32fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能对<code class="fe lw lx ly lz b">it</code>块很熟悉。这是您通常要做的所有工作，来设置您的测试并针对结果运行断言。这里的情况非常相似，但是您可能已经完成了与来自<code class="fe lw lx ly lz b">@oclif/test</code>和<code class="fe lw lx ly lz b">@oclif/fancy-test</code>的其他助手一起设置测试的艰苦工作，并且<code class="fe lw lx ly lz b">it</code>块只需要断言命令的输出。</p><p id="ca45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，现在我们对测试做了更多的了解，我们可以用<code class="fe lw lx ly lz b">npm test</code>来运行我们的测试。因为我们还没有编写任何实现代码，所以我们预计我们的测试会失败。</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="9dd4" class="np mb it lz b gy nq nr l ns nt">1) add project<br/>       should add a new project:<br/>     Error: Unexpected argument: project-one<br/>See more help with --help<br/>      at validateArgs (node_modules/@oclif/parser/lib/validate.js:10:19)<br/>      at Object.validate (node_modules/@oclif/parser/lib/validate.js:55:5)<br/>      at Object.parse (node_modules/@oclif/parser/lib/index.js:28:7)<br/>      at AddProjectCommand.parse (node_modules/@oclif/command/lib/command.js:86:41)<br/>      at AddProjectCommand.run (src/commands/add-project.js:1:1576)<br/>      at AddProjectCommand._run (node_modules/@oclif/command/lib/command.js:43:31)</span></pre><p id="9cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完美！正如我们所料，测试失败了。让我们写代码来达到绿色。</p><h1 id="dcc0" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">走向绿色:执行我们的命令</h1><p id="dc57" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在，我们只需要根据错误来编写命令。首先，我们需要更新<code class="fe lw lx ly lz b">AddProjectCommand</code>类来知道我们想要传入的参数。在这种情况下，我们只传入一个项目名称。让我们用下面的代码进行更改:</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="92ef" class="np mb it lz b gy nq nr l ns nt">class AddProjectCommand extends Command {<br/>  ...<br/>}</span><span id="ad4a" class="np mb it lz b gy nu nr l ns nt">AddProjectCommand.storage = new FilesystemStorage()</span><span id="54ad" class="np mb it lz b gy nu nr l ns nt">AddProjectCommand.description = 'Add a new project to the time tracking database'</span><span id="43ef" class="np mb it lz b gy nu nr l ns nt">// This is the update<br/>AddProjectCommand.args = [<br/>  {name: 'projectName', required: true},<br/>]</span></pre><p id="6966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要告诉oclif我们命令的预期参数及其属性。在我们的例子中，只有一个参数<code class="fe lw lx ly lz b">projectName</code>，并且是必需的。你可以在这里了解更多oclif参数<a class="ae ky" href="https://oclif.io/docs/args" rel="noopener ugc nofollow" target="_blank">，在这里</a>了解oclif标志<a class="ae ky" href="https://oclif.io/docs/flags" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们再次运行测试，如下所示:</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="4b27" class="np mb it lz b gy nq nr l ns nt">1) add project<br/>       should add a new project:</span><span id="bba6" class="np mb it lz b gy nu nr l ns nt">AssertionError: expected {} to deeply equal { Object (activeProject, projects) }<br/>      + expected - actual</span><span id="0b25" class="np mb it lz b gy nu nr l ns nt">-{}<br/>      +{<br/>      +  "activeProject": [null]<br/>      +  "projects": {<br/>      +    "project-one": {<br/>      +      "activeEntry": [null]<br/>      +      "entries": []<br/>      +    }<br/>      +  }<br/>      +}</span><span id="7440" class="np mb it lz b gy nu nr l ns nt">at Context.&lt;anonymous&gt; (test/commands/add-project.test.js:11:55)<br/>      at async Object.run (node_modules/fancy-test/lib/base.js:44:29)<br/>      at async Context.run (node_modules/fancy-test/lib/base.js:68:25)</span></pre><p id="7b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精彩！我们现在看到，虽然我们期望创建“project-one ”,但是底层数据结构没有发生变化。</p><p id="d872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用通过测试所需的最少代码来更新这个命令。为了简洁起见，我们将只在<code class="fe lw lx ly lz b">src/commands/add-project.js</code>中显示<code class="fe lw lx ly lz b">run()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e6cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，如果没有文件存在，那么当从存储器加载时，我们将收到一个空对象。这段代码创建任何默认属性及其值(如果它们不存在的话)(例如，<code class="fe lw lx ly lz b">activeProject</code>和<code class="fe lw lx ly lz b">projects</code>)，然后创建一个具有默认结构的新项目——一个空的<code class="fe lw lx ly lz b">entries</code>数组和设置为<code class="fe lw lx ly lz b">null</code>的<code class="fe lw lx ly lz b">activeEntry</code>。</p><p id="2d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行测试，我们看到下一个错误:</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="108b" class="np mb it lz b gy nq nr l ns nt">1) add project<br/>       should add a new project:<br/>     AssertionError: expected '' to include 'Created new project "project-one"'<br/>      at Context.&lt;anonymous&gt; (test/commands/add-project.test.js:20:27)<br/>      at async Object.run (node_modules/fancy-test/lib/base.js:44:29)<br/>      at async Context.run (node_modules/fancy-test/lib/base.js:68:25)</span></pre><p id="5746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe lw lx ly lz b">.stdout()</code>功能发挥作用的地方。我们期望我们的CLI告诉用户我们创建了他们的新项目，但是它什么也没说。这个很容易修理。我们可以在调用<code class="fe lw lx ly lz b">storage.save()</code>之前添加下面一行。</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="a43f" class="np mb it lz b gy nq nr l ns nt">this.log(`Created new project "${args.projectName}"`)</span></pre><p id="7d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。我们的第一个快乐路径测试通过了。现在我们在巡航！</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="b9a3" class="np mb it lz b gy nq nr l ns nt">add project<br/>    ✓ should add a new project (43ms)</span><span id="307b" class="np mb it lz b gy nu nr l ns nt">1 passing (44ms)</span></pre><h1 id="1f3f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">还有一个测试</h1><p id="0afa" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们还有一个关于<code class="fe lw lx ly lz b">AddProjectCommand</code>的测试。我们需要确保用户不能添加与当前项目同名的另一个项目。对于这些测试，我们将反复需要为单个项目生成一个数据库。让我们为此创建一个助手。</p><p id="b629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">test/test-helpers.js</code>中添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="06dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在<code class="fe lw lx ly lz b">add-project.test.js</code>中添加下一个测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="bc88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试中有一个新方法:</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="8af1" class="np mb it lz b gy nq nr l ns nt">.catch('Project "project-one" already exists')</span></pre><p id="dca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前提到过，我们不需要嘲弄<code class="fe lw lx ly lz b">stderr</code>来断言反对它。这是因为我们可以使用这个<code class="fe lw lx ly lz b">catch</code>方法来断言运行期间发生的任何错误。在这种情况下，我们预计会发生错误，并且底层存储不会发生变化。</p><p id="1374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行我们的测试后，我们看到以下内容:</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="b905" class="np mb it lz b gy nq nr l ns nt">1) add project<br/>       should return an error if the project already exists:<br/>     Error: expected error to be thrown<br/>      at Object.run (node_modules/fancy-test/lib/catch.js:8:19)<br/>      at Context.run (node_modules/fancy-test/lib/base.js:68:36)</span></pre><p id="8559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们从存储器中加载<code class="fe lw lx ly lz b">db</code>之后，我们需要检查并查看项目是否已经存在，如果存在就抛出一个错误。</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="32b3" class="np mb it lz b gy nq nr l ns nt">const db = await AddProjectCommand.storage.load()</span><span id="6d75" class="np mb it lz b gy nu nr l ns nt">// New code<br/>if (db.projects?.[args.projectName]) {<br/>    this.error(`Project "${args.projectName}" already exists`)<br/>}</span></pre><p id="3602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们运行我们的测试，他们都通过了！我们做到了！我们现在可以添加尽可能多的项目来跟踪我们的时间。</p><pre class="kj kk kl km gt nl lz nm nn aw no bi"><span id="6555" class="np mb it lz b gy nq nr l ns nt">add project<br/>    ✓ should add a new project (46ms)<br/>    ✓ should return an error if the project already exists (76ms)</span></pre><h1 id="c00a" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论(目前)</h1><p id="2ef6" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在本文中——我们关于<code class="fe lw lx ly lz b">oclif</code>测试库的两部分系列的第一部分——我们讨论了<code class="fe lw lx ly lz b">oclif</code>,它的测试框架，为什么存根有用，以及如何使用它们。然后，我们开始为我们的<code class="fe lw lx ly lz b">time-tracker</code> CLI编写测试和实现。</p><p id="697c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的开始。在本系列的下一部分中，我们将继续用更多的命令构建我们的CLI，同时涵盖重要的测试概念，如数据存储测试和初始化。</p></div></div>    
</body>
</html>