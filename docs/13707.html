<html>
<head>
<title>What Is Python’s “Self” Argument, Anyway?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的“自我”论点到底是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-pythons-self-argument-anyway-21d1c3bc421f?source=collection_archive---------1-----------------------#2022-09-19">https://betterprogramming.pub/what-is-pythons-self-argument-anyway-21d1c3bc421f?source=collection_archive---------1-----------------------#2022-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e716" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对这场众所周知的争论的幕后调查</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd1356246bb136c53a33ba3c5a5fb06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CewqKbGqfoLIAUYbd1w_Mw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@niloofarkanani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Niloofar Kanani </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="28bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个Python开发人员都熟悉<code class="fe lv lw lx ly b">self</code>参数，它出现在每个类的每个*方法声明中。我们都知道如何使用它，但是你真的<em class="lz">知道它是什么吗</em>知道它为什么在那里，以及它在引擎盖下是如何工作的吗？</p><h1 id="70a7" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">我们已经知道的</h1><p id="e5a4" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">让我们从我们已经知道的开始:<code class="fe lv lw lx ly b">self</code> —方法中的第一个参数—引用类实例，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，这个论点不一定要被称为<code class="fe lv lw lx ly b">self</code>——它只是一个惯例。例如，您可以使用其他语言中常见的<code class="fe lv lw lx ly b">this</code>(但不要这样做)。</p><p id="2397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码可能是自然而显而易见的，因为您一直在使用它，但是我们只给了<code class="fe lv lw lx ly b">.do_stuff()</code>一个参数(<code class="fe lv lw lx ly b">some_arg</code>)，然而这个方法声明了两个参数(<code class="fe lv lw lx ly b">self</code>和<code class="fe lv lw lx ly b">some_arg</code>)，这没有意义。代码片段中的箭头显示<code class="fe lv lw lx ly b">self</code>被翻译成了<code class="fe lv lw lx ly b">instance</code>，但是它到底是怎么翻译的呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="931b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python内部做的是从<code class="fe lv lw lx ly b">instance.do_stuff("whatever")</code>到<code class="fe lv lw lx ly b">MyClass.do_stuff(instance, "whatever")</code>的转换。我们可以在这里结束它，称之为“Python魔术”，但是如果我们想了解幕后发生了什么，我们需要了解什么是Python方法以及它们如何与函数相关。</p><h1 id="094f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">类属性/方法</h1><p id="f978" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在Python中，没有“方法”对象这样的东西——实际上，方法只是普通的函数。函数和方法的区别在于方法是在类的名称空间中定义的，这使得它们成为该类的一个属性。</p><p id="1846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些属性存储在类字典<code class="fe lv lw lx ly b">__dict__</code>中，我们可以直接访问或者使用<code class="fe lv lw lx ly b">vars</code>内置函数。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">访问它们最常见的方式是“类方法”，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bcf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用一个class属性来访问函数，正如所料，它打印出<code class="fe lv lw lx ly b">do_stuff</code>是<code class="fe lv lw lx ly b">MyClass</code>的一个函数。但是，我们也可以使用实例属性来访问它。看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="529d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们得到的是一个“绑定方法”而不是原始函数。Python在这里为我们做的是将类属性绑定到实例，创建了所谓的“绑定方法”这个“绑定方法”是对底层函数的包装，该函数已经将<code class="fe lv lw lx ly b">instance</code>作为第一个参数(<code class="fe lv lw lx ly b">self</code>)插入。</p><p id="5a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，方法是普通的函数，在它们的其他参数前有一个类实例(<code class="fe lv lw lx ly b">self</code>)。</p><p id="992a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要查看描述符协议来理解这是如何发生的。</p><h1 id="1db1" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">描述符协议</h1><p id="788d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">描述符是方法背后的机制(以及其他东西)。它们是定义<code class="fe lv lw lx ly b"> __get__()</code>、<code class="fe lv lw lx ly b">__set__()</code>或<code class="fe lv lw lx ly b">__delete__()</code>方法的对象(类)。为了理解<code class="fe lv lw lx ly b">self</code>如何工作，我们将只考虑<code class="fe lv lw lx ly b">__get__()</code>，它有一个签名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="36a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe lv lw lx ly b">__get__()</code>方法实际上做什么呢？它允许我们在类中定制属性查找——换句话说，当使用点符号访问类属性时会发生什么。考虑到方法只是类的属性，这是非常有用的。这意味着我们可以使用<code class="fe lv lw lx ly b">__get__</code>方法来创建一个类的“绑定方法”。</p><p id="02ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过使用描述符实现一个“方法”来演示这一点，这样会更容易理解。首先，我们创建一个函数对象的纯Python实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe lv lw lx ly b">Function</code>类实现了<code class="fe lv lw lx ly b">__get__</code>，这使它成为一个描述符。这个dunder方法在<code class="fe lv lw lx ly b">instance</code>参数中接收类实例。如果这个参数是<code class="fe lv lw lx ly b">None</code>，我们知道<code class="fe lv lw lx ly b">__get__</code>方法是从一个类中直接调用的(例如<code class="fe lv lw lx ly b">MyClass.do_stuff</code>，所以我们只返回<code class="fe lv lw lx ly b">self</code>。</p><p id="412b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果它是从类实例如<code class="fe lv lw lx ly b">instance.do_stuff</code>中调用的，那么我们返回<code class="fe lv lw lx ly b">types.MethodType</code>，这是一种手动创建“绑定方法”的方式。</p><p id="7a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，我们还提供了<code class="fe lv lw lx ly b">__call__</code> dunder方法。当调用一个类来初始化一个实例时<code class="fe lv lw lx ly b">__init__</code>被调用(例如<code class="fe lv lw lx ly b">instance = MyClass()</code>)，当调用实例时<code class="fe lv lw lx ly b">__call__</code>被调用(例如<code class="fe lv lw lx ly b">instance()</code>)。我们需要这个，因为<code class="fe lv lw lx ly b">types.MethodType(self, instance)</code>中的<code class="fe lv lw lx ly b">self</code>必须是可调用的。</p><p id="81b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了函数实现，我们可以使用它将方法绑定到类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过给<code class="fe lv lw lx ly b">MyClass</code>一个类型为<code class="fe lv lw lx ly b">Function</code>的属性<code class="fe lv lw lx ly b">do_stuff</code>，我们大致模拟了当您在类的名称空间中定义一个方法时Python会做什么。</p><p id="9182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，在<code class="fe lv lw lx ly b">instance.do_stuff</code>等属性访问时，在<code class="fe lv lw lx ly b">instance</code>的属性字典(<code class="fe lv lw lx ly b">__dict__</code>)中查找<code class="fe lv lw lx ly b">do_stuff</code>。如果<code class="fe lv lw lx ly b">do_stuff</code>定义了<code class="fe lv lw lx ly b">__get__</code>方法，那么<code class="fe lv lw lx ly b">do_stuff.__get__</code>被调用，最终调用这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们现在所知，它将返回一个绑定方法——一个围绕原始函数的可调用包装器，它的参数前有<code class="fe lv lw lx ly b">self</code>!</p><p id="8e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想进一步探索，你可以类似地实现静态和类方法——如何做的例子可以在这里的<a class="ae ky" href="https://docs.python.org/3.7/howto/descriptor.html#static-methods-and-class-methods" rel="noopener ugc nofollow" target="_blank">文档中找到。</a></p><h1 id="f722" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">为什么它会在那里？</h1><p id="d76b" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们知道它是如何工作的，但是一个更哲学的问题仍然存在:“为什么它必须出现在方法定义中？”</p><p id="0cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显式的<code class="fe lv lw lx ly b">self</code>方法参数是一个有争议的设计选择，但这是一个有利于简化的选择。</p><p id="9f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的<code class="fe lv lw lx ly b">self</code>是“越差越好”设计哲学的体现——在这里<a class="ae ky" href="https://dreamsongs.com/RiseOfWorseIsBetter.html" rel="noopener ugc nofollow" target="_blank">描述</a>。这一设计理念的首要目标是“简单”,定义如下:</p><blockquote class="mz na nb"><p id="8aa9" class="kz la lz lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated">设计必须简单，无论是在实施和接口。实现简单比接口简单更重要…</p></blockquote><p id="5903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是<code class="fe lv lw lx ly b">self</code>的情况——一个简单的实现，以接口为代价，其中方法签名与其调用不匹配。</p><p id="353e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有更多的理由说明为什么我们有明确的<code class="fe lv lw lx ly b">self</code>或者更确切地说，为什么它必须存在。吉多·范·罗苏姆在<a class="ae ky" href="http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html" rel="noopener ugc nofollow" target="_blank">的博客帖子</a>中描述了其中一些，以回应要求将其删除的提议。</p><h1 id="0cb7" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结束语</h1><p id="208d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">Python抽象掉了很多复杂性，但是在我看来，深入底层细节和复杂性对于更好地理解这种语言的工作原理非常有价值。当出现问题时，这可以派上用场，高级别的故障排除/调试是不够的。</p><p id="0126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，理解描述符可能非常实用，因为它们有一些用例。虽然在大多数情况下，您只需要真正的<code class="fe lv lw lx ly b">@property</code>描述符，但是在某些情况下自定义描述符是有意义的，比如SLQAlchemy 中的<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/orm/mapped_attributes.html#using-descriptors-and-hybrids" rel="noopener ugc nofollow" target="_blank">描述符，或者</a><a class="ae ky" href="https://docs.python.org/3/howto/descriptor.html#validator-class" rel="noopener ugc nofollow" target="_blank">自定义验证器</a>。</p><div class="nf ng gp gr nh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/should-you-be-using-pythons-walrus-operator-yes-and-here-s-why-36297be16907"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">你应该使用Python的Walrus操作符吗？(是的。原因如下)</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Python有争议的赋值表达式——也称为walrus运算符——可以改进您的代码，现在是您…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">better编程. pub</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ks ni"/></div></div></a></div><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="3e18" class="ob mb it ly b gy oc od l oe of"><strong class="ly iu">Want to Connect?</strong></span><span id="8420" class="ob mb it ly b gy og od l oe of">This article was originally posted at <a class="ae ky" href="https://martinheinz.dev/blog/81" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a>.</span></pre></div></div>    
</body>
</html>