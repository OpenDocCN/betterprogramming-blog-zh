<html>
<head>
<title>Angular: Build a CRUD Application With NgRx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:用NgRx构建CRUD应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-building-a-crud-application-with-ngrx-40e5f1c0b50c?source=collection_archive---------1-----------------------#2020-01-21">https://betterprogramming.pub/angular-building-a-crud-application-with-ngrx-40e5f1c0b50c?source=collection_archive---------1-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="965f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Angular中构建一个简单的课程管理系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7574087a3ab4945af104e11790f4904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*So2U6wNF0unSYpr0dNuzTg.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="df11" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">介绍</h1><p id="1bfe" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在我之前的文章中，我解释了<a class="ae mp" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>的基本概念以及它们是如何结合在一起的。现在，是时候构建一个以NgRx作为状态管理系统的迷你CRUD应用程序了。</p><p id="d705" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">如果你是NgRx世界的新手，我建议你在尝试本教程之前看看我以前的帖子。在本文中，我不会详细讨论底层的NgRx概念。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="7ee5" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">项目详情</h1><p id="d3d4" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在这篇文章中，我们将构建一个简单的课程管理系统。如下所示，您将能够通过这个简单的web应用程序在课程实体上执行所有CRUD操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/ff99263eae5ab47e03e09dec92950844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EtdojKbu5QbH7KovvCMUTw.gif"/></div></div></figure><h2 id="dd27" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">项目结构</h2><p id="d8a1" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如下图所示，我们的应用程序将由两个主要模块组成，即<code class="fe ni nj nk nl b">App</code>和<code class="fe ni nj nk nl b">Course</code>。课程模块将有两个定制组件，即<code class="fe ni nj nk nl b">Course List</code>和<code class="fe ni nj nk nl b">Create Course</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/b8f726fe7b54523a66c4ffcab1159411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEbyK3BzgcLbdOhcv2jtMQ.png"/></div></div></figure><h2 id="95c6" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">REST API</h2><p id="335b" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">一般来说，Angular应用程序与REST API交互，对数据执行CRUD操作。</p><p id="51f3" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">因此，我在Spring Boot<a class="ae mp" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank">中实现了一个简单的REST API，它公开了下面的端点。我们将使用这个API从Angular应用程序进行连接，并执行数据操作。</a></p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="0a69" class="mw lc it nl b gy nr ns l nt nu">// Retrieve all courses<br/>GET     <a class="ae mp" href="http://localhost:8080/api/courses" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses</a></span><span id="e3e7" class="mw lc it nl b gy nv ns l nt nu">// Create a course<br/>POST    <a class="ae mp" href="http://localhost:8080/api/courses" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses</a></span><span id="d42a" class="mw lc it nl b gy nv ns l nt nu">// Delete a course<br/>DELETE  <a class="ae mp" href="http://localhost:8080/api/courses/{courseId}" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses/{courseId}</a></span><span id="0bd6" class="mw lc it nl b gy nv ns l nt nu">// Update a course<br/>PUT     <a class="ae mp" href="http://localhost:8080/api/courses/{courseId}" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/courses/{courseId}</a></span></pre><h2 id="5bfd" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">完整源代码</h2><p id="6588" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">您可以在GitHub 上找到这个示例应用程序<a class="ae mp" href="https://github.com/sarindufit/angular-ngrx-example/tree/master/angular-ngrx-example" rel="noopener ugc nofollow" target="_blank">的完整源代码。请注意，我还将Spring Boot应用程序(REST API)的可执行JAR文件(course-1.0.0-SNAPSHOT.jar)添加到了同一个存储库中。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c32add5d317bb1b70e60eff86f58fffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*dfeROOcLZUyeFN-t5RR74w.png"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="fea9" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">NgRx实体一览</h1><p id="e977" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">您已经遇到了我将在本文中使用的大多数NgRx术语。例如，存储、效果、动作、选择器和缩减器。在本文中，我将介绍一个名为<a class="ae mp" href="https://ngrx.io/guide/entity" rel="noopener ugc nofollow" target="_blank"> NgRx Entity </a> ( <code class="fe ni nj nk nl b">@ngrx/entity</code>)的新NgRx库。</p><p id="ab3f" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">NgRx实体帮助我们管理应用程序中的各种数据实体。例如，在我们的应用程序中，<code class="fe ni nj nk nl b">Course</code>是一个实体。它采用以下格式。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="7e7d" class="mw lc it nl b gy nr ns l nt nu">export interface Course {</span><span id="c862" class="mw lc it nl b gy nv ns l nt nu">id: string;</span><span id="7f42" class="mw lc it nl b gy nv ns l nt nu">name: string;</span><span id="360b" class="mw lc it nl b gy nv ns l nt nu">description: string;</span><span id="e5d9" class="mw lc it nl b gy nv ns l nt nu">}</span></pre><p id="057f" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">NgRx实体库使得对存储在应用程序状态中的课程对象执行不同的操作(添加、更新、删除、选择)变得非常容易。让我们看看如何…</p><h2 id="abd4" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">实体状态接口</h2><p id="aa45" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">实体库提供了一套工具，让我们的NgRx生活变得更加轻松。首当其冲的就是<code class="fe ni nj nk nl b">EntityState</code>接口。<code class="fe ni nj nk nl b">EntityState</code>的形状如下图所示。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="cd62" class="mw lc it nl b gy nr ns l nt nu">interface EntityState&lt;V&gt; {<br/>  ids: string[];<br/>  entities: { [id: string]: V };<br/>}</span></pre><p id="9972" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">我们必须使用<code class="fe ni nj nk nl b">EntityState</code>来声明我们的<code class="fe ni nj nk nl b">courses</code>状态的接口。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="0664" class="mw lc it nl b gy nr ns l nt nu">import { EntityState } from '@ngrx/entity';export interface CourseState extends EntityState&lt;Course&gt; { }</span></pre><p id="caad" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">当使用<code class="fe ni nj nk nl b">EntityState</code>时，<code class="fe ni nj nk nl b">courses</code>状态将采用以下格式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ddd55ce2917786cf31710645b09f46b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*ZMhT4I9O4GkPG0VWJVpeXw.png"/></div></figure><p id="6476" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">如您所见，它维护了一个课程id数组和一个课程对象字典。我们维护一个id列表和一个实体字典，而不仅仅是维护一个实体数组，主要有两个原因:</p><ol class=""><li id="d789" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo od oe of og bi translated">我们希望快速查找特定的实体。如果您只想从商店中选择一门课程，使用实体字典比搜索数组要快得多</li><li id="39e8" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo od oe of og bi translated">我们还想维护列表的顺序。如果你想让列表保持有序，这一点尤其重要！</li></ol><h2 id="2225" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">实体适配器</h2><p id="3589" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">实体适配器是另一个与<code class="fe ni nj nk nl b">EntityState</code>齐头并进的工具。它提供了一堆助手方法，使得对存储在<code class="fe ni nj nk nl b">EntityState</code>中的数据执行各种操作变得非常容易。</p><p id="2269" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">这些辅助方法使reducers变得简单、有表现力和一致。您可以通过以下方式创建实体适配器。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="beb9" class="mw lc it nl b gy nr ns l nt nu">import { createEntityAdapter } from '@ngrx/entity';<br/>const courseAdapter = createEntityAdapter&lt;Course&gt;();</span></pre><p id="5c40" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">下面是适配器公开的与状态交互的一些非常有用的方法。</p><ul class=""><li id="ab7a" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated"><code class="fe ni nj nk nl b">addOne</code>:向集合中添加一个实体。</li><li id="4817" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">addMany</code>:向集合中添加多个实体。</li><li id="9a27" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">addAll</code>:用提供的集合替换当前集合。</li><li id="f1ad" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">removeOne</code>:从集合中删除一个实体。</li><li id="3ccd" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">removeMany</code>:通过I或谓词从集合中删除多个实体。</li><li id="356e" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">removeAll</code>:清除实体集合。</li><li id="b31f" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">updateOne</code>:更新集合中的一个实体。</li><li id="8032" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">updateMany</code>:更新集合中的多个实体。</li><li id="4715" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">upsertOne</code>:添加或更新集合中的一个实体。</li><li id="a894" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">upsertMany</code>:添加或更新集合中的多个实体。</li><li id="876d" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">map</code>:通过定义一个映射函数来更新集合中的多个实体，类似于<code class="fe ni nj nk nl b">Array.map</code>。</li></ul></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="1087" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">设置项目</h1><h2 id="695c" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">使用的软件版本</h2><ul class=""><li id="2fc3" class="ny nz it lv b lw lx lz ma mc on mg oo mk op mo om oe of og bi translated">角度CLI: 8.0.1</li><li id="7d69" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated">节点:11.6.0</li><li id="4b77" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated">角度:8.0.2</li><li id="74fc" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated">NgRx: 8.6.0</li><li id="5f43" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated">引导程序:4.4.1</li></ul><h2 id="69bf" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">项目初始化</h2><p id="7032" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">步骤1:执行下面的命令并创建一个新项目。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="ce43" class="mw lc it nl b gy nr ns l nt nu">ng new angular-ngrx-example</span></pre><p id="4b56" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">步骤2:我们将使用<a class="ae mp" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>向我们的应用程序添加样式。您可以使用下面的命令安装引导程序。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="3dc3" class="mw lc it nl b gy nr ns l nt nu">npm install bootstrap --save</span></pre><p id="4162" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">步骤3:通过更新<code class="fe ni nj nk nl b">angular.json</code>文件导入引导程序，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="7446" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">步骤4:安装NgRx依赖项。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="347a" class="mw lc it nl b gy nr ns l nt nu">npm install <a class="ae mp" href="http://twitter.com/ngrx" rel="noopener ugc nofollow" target="_blank">@ngrx</a>/{store,effects,entity,store-devtools,schematics} --save</span></pre></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="d9bf" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">向根模块添加NgRx支持</h1><p id="5587" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">执行以下schematics命令，生成初始状态管理，并将其注册到<code class="fe ni nj nk nl b">app.module.ts</code>中。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="b64e" class="mw lc it nl b gy nr ns l nt nu">ng generate <a class="ae mp" href="http://twitter.com/ngrx/schematics" rel="noopener ugc nofollow" target="_blank">@ngrx/schematics</a>:store State --root --statePath store/reducers --module app.module.ts</span></pre><p id="f000" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">执行完上述命令后，您的项目文件夹结构应该如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/15813b6560f033770ca676ada2293218.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*yYH-xMbWE-osw5Obiol7YA.png"/></div></figure><p id="beb3" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">以下是<code class="fe ni nj nk nl b">index.ts</code>文件的内容。请注意，我对自动生成的文件做了一些小的修改。比如，为了清晰起见，我把<code class="fe ni nj nk nl b">State</code>界面改成了<code class="fe ni nj nk nl b">AppState</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="2914" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">NgRx schematics命令也将更新<code class="fe ni nj nk nl b">app.module.ts</code>文件。以下是该文件的更新内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="41f8" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">创建和设置“课程”功能模块</h1><h2 id="0c35" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">生成“课程”模块</h2><p id="b3f7" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如前所述，我们的应用程序由两个主要模块组成，即<code class="fe ni nj nk nl b">App</code>和<code class="fe ni nj nk nl b">Course</code>。现在是用下面的命令创建<code class="fe ni nj nk nl b">Course</code>模块的时候了。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="aa9a" class="mw lc it nl b gy nr ns l nt nu">ng generate module course</span></pre><p id="cfd5" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">上述命令将在<code class="fe ni nj nk nl b">app</code>文件夹下直接创建一个名为<code class="fe ni nj nk nl b">course</code>的子文件夹。此外，一个名为<code class="fe ni nj nk nl b">course.module.ts</code>的新文件将被创建并放置在<code class="fe ni nj nk nl b">app/course</code>文件夹下。</p><p id="9669" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">以下是<code class="fe ni nj nk nl b">course.module.ts</code>文件的初始版本。请注意，该文件将在下游进行修改，以添加NgRx支持、声明组件和声明服务提供者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="8486" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义“课程”模型</h2><p id="a1ba" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">下一步，您必须定义表示<code class="fe ni nj nk nl b">Course</code>实体的模型接口。创建一个名为<code class="fe ni nj nk nl b">course.model.ts</code>的文件，并将其放在<code class="fe ni nj nk nl b">app/course/model</code>文件夹下。这个文件的内容应该如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="5440" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义服务类别</h2><p id="218a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">服务用于与REST API交互并执行数据操作。为了定义服务类，创建一个名为<code class="fe ni nj nk nl b">course.service.ts</code>的文件，并将其放在<code class="fe ni nj nk nl b">app/course/services</code>文件夹下。</p><p id="ee19" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">这个文件的内容应该如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="e750" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">如您所见，它有通过REST API检索、创建、更新和删除<code class="fe ni nj nk nl b">Course</code>实体的方法。一旦定义了服务类，您必须在如下所示的<code class="fe ni nj nk nl b">course.module.ts</code>文件中注册它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="842e" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">下图说明了此时我们的应用程序的文件夹结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/daaf20742329154efb01e4bcb5c93d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*WYhXck5sD4KYLeNB0ISoBg.png"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="eb0c" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">向“课程”模块添加NgRx工件</h1><p id="8ae7" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">下一步，你必须定义动作、减少器、效果和选择器，并连接到<code class="fe ni nj nk nl b">course</code>模块。这些工件将被创建在一个名为<code class="fe ni nj nk nl b">store</code>的目录中，这个目录位于<code class="fe ni nj nk nl b">app/course</code>目录下。</p><h2 id="dd21" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义NgRx操作(course.actions.ts)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="871d" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><ul class=""><li id="6d63" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated"><code class="fe ni nj nk nl b">loadCourses</code>、<code class="fe ni nj nk nl b">createCourse</code>、<code class="fe ni nj nk nl b">deleteCourse</code>和<code class="fe ni nj nk nl b">updateCourse</code>是组件调度的自解释动作。然而，<code class="fe ni nj nk nl b">coursesLoaded</code>是一个特殊的动作，将由效果调度，以便通知商店课程已成功加载。</li><li id="bc65" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">updateCourse</code>动作接受类型为<code class="fe ni nj nk nl b">{update: Update&lt;Course&gt;}</code>的有效载荷。<code class="fe ni nj nk nl b">Update</code>是NgRx实体提供的辅助类型，用于帮助建模部分实体更新。这个类型有一个属性<code class="fe ni nj nk nl b">id</code>标识更新的实体，还有一个属性<code class="fe ni nj nk nl b">changes</code>指定对实体做了哪些修改。</li></ul><h2 id="6a8b" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义NgRx减速器(course.reducers.ts)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="afb7" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><ul class=""><li id="bdab" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">下面的代码片段通过扩展<code class="fe ni nj nk nl b">EntityState</code>来定义<code class="fe ni nj nk nl b">Course</code>状态。正如我们之前讨论的，<code class="fe ni nj nk nl b">EntityState</code>维护一个id列表和一个实体字典。除了这两个属性，我们在这里定义了一个名为<code class="fe ni nj nk nl b">coursesLoaded</code>的自定义属性。该属性主要用于指示课程是否已经加载到状态中。</li></ul><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="c85d" class="mw lc it nl b gy nr ns l nt nu">export interface CourseState extends EntityState&lt;Course&gt; {  coursesLoaded: boolean;}</span></pre><ul class=""><li id="f01d" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">下面的代码片段创建了一个提供帮助函数的<code class="fe ni nj nk nl b">Entity Adapter</code>。</li></ul><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="73e4" class="mw lc it nl b gy nr ns l nt nu">export const adapter: EntityAdapter&lt;Course&gt; = createEntityAdapter&lt;Course&gt;();</span></pre><ul class=""><li id="3caf" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">初始状态定义如下。实体适配器提供了一个助手函数来获取初始状态。如你所见，我们最初将<code class="fe ni nj nk nl b">coursesLoaded</code>属性设置为<code class="fe ni nj nk nl b">false</code>。</li></ul><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="2a5a" class="mw lc it nl b gy nr ns l nt nu">export const initialState = adapter.getInitialState({  coursesLoaded: false});</span></pre><ul class=""><li id="a674" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">下面的代码行导出了适配器提供给我们的几个预定义的选择器。这些选择器将被我们的自定义选择器使用。(我们将在定义选择器时研究这一点。)</li></ul><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="e066" class="mw lc it nl b gy nr ns l nt nu">export const { selectAll, selectIds } = adapter.getSelectors();</span></pre><h2 id="3a41" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义NgRx选择器(course . selector . ts)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="52c4" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><ul class=""><li id="886c" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">这里，我们使用<code class="fe ni nj nk nl b">selectAll</code>预定义的选择器以数组的形式检索所有的课程实体。</li><li id="eddd" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated"><code class="fe ni nj nk nl b">areCoursesLoaded</code>选择器用于检查程序是否已经载入状态。这个选择器使用我们在<code class="fe ni nj nk nl b">CourseState</code>中定义的<code class="fe ni nj nk nl b">coursesLoaded</code>定制属性。</li></ul><h2 id="5b0b" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义NgRx效果(course.effects.ts)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="ef26" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><p id="bec8" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated"><code class="fe ni nj nk nl b">createCourse$</code>、<code class="fe ni nj nk nl b">deleteCourse$</code>和<code class="fe ni nj nk nl b">updateCourse$</code>效果不言自明。它们只是调用相应的REST端点并执行操作。</p><p id="d058" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">这些效果不会将传入的动作映射到新的动作类型，这就是使用<code class="fe ni nj nk nl b">{dispatch: false}</code> config的原因。</p><p id="9f63" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">但是，<code class="fe ni nj nk nl b">loadCourses$</code>有一个特殊的行为。它接受类型<code class="fe ni nj nk nl b">loadCourses</code>的动作，一旦通过REST API检索到课程，它就将响应映射到一个名为<code class="fe ni nj nk nl b">coursesLoaded</code>的新动作类型。</p><p id="772c" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">检索到的课程列表被传递到<code class="fe ni nj nk nl b">coursesLoaded</code>动作中。</p><h2 id="af67" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">在课程模块中注册NgRx工件</h2><p id="2004" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">定义NgRx工件后，如下所示更新<code class="fe ni nj nk nl b">course.module.ts</code>文件以添加<code class="fe ni nj nk nl b">State</code>支持。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="dca1" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><ul class=""><li id="abb3" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">下面的代码行在课程模块的应用程序状态中创建了一个专用切片(<code class="fe ni nj nk nl b">courses</code>),并将reducers附加到其上。</li></ul><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="d23a" class="mw lc it nl b gy nr ns l nt nu">StoreModule.forFeature('courses', courseReducer),</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/3f9881d37622ef0e572975a3c9d0b520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*2tJKjqrKe4BzT_Q_bEtTYA.png"/></div></figure><ul class=""><li id="74ec" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">下面的代码行记录了课程模块状态下的效果。</li></ul><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="2590" class="mw lc it nl b gy nr ns l nt nu">EffectsModule.forFeature([CourseEffects])</span></pre><p id="6010" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">现在，这个问题已经解决了，在这个阶段，你的项目文件夹结构应该如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/b36b373c4899e2c9a19ba9b673c00217.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*hUqyULAxy60W05BNF_m7UQ.png"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="e405" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">创建组件和定义路线</h1><p id="13fa" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">正如我们之前讨论的，我们的应用程序由两个主要模块组成，即<code class="fe ni nj nk nl b">App</code>和<code class="fe ni nj nk nl b">Course</code>。课程模块由两部分组成，即<code class="fe ni nj nk nl b">courses-list</code>和<code class="fe ni nj nk nl b">create-course</code>。</p><p id="8c84" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">我们的下一步是创建这两个组件并定义相应的路由。注意，<code class="fe ni nj nk nl b">courses-list</code>和<code class="fe ni nj nk nl b">create-course</code>目录将被创建在<code class="fe ni nj nk nl b">app/course/component</code>目录下。</p><h2 id="ca65" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义“课程-列表”组件</h2><p id="4136" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">模板:<code class="fe ni nj nk nl b">courses-list.component.html</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="b3ec" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">组件:<code class="fe ni nj nk nl b">courses-list.component.ts</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="a4bf" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><ul class=""><li id="3211" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated">该组件负责简化列表、更新和删除操作。</li></ul><h2 id="b238" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义“创建课程”组件</h2><p id="8c3d" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">模板:<code class="fe ni nj nk nl b">create-course.component.html</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="41c7" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">组件:<code class="fe ni nj nk nl b">create-course.component.ts</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="0935" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">在课程模块中声明组件</h2><p id="bdf7" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">你必须在<code class="fe ni nj nk nl b">course.module.ts</code>文件中声明上述组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="24eb" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">配置路线</h2><p id="6b3a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">现在是时候定义路线并将相应的组件与这些路线相关联了。这必须在如下所示的<code class="fe ni nj nk nl b">app.module.ts</code>中完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="06e8" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><ul class=""><li id="bb38" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated"><code class="fe ni nj nk nl b">CoursesListComponent</code>使用解析器获取数据。路径解析器确保组件在导航到特定路径之前可以使用数据。在这种情况下，解析器负责在完成到<code class="fe ni nj nk nl b">/courses</code>的导航之前检索课程列表。</li></ul><h2 id="e671" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">实施路径解析器(course.resolver.ts)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="c9dd" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:</p><ul class=""><li id="c74a" class="ny nz it lv b lw mq lz mr mc oa mg ob mk oc mo om oe of og bi translated"><code class="fe ni nj nk nl b">areCoursesLoaded</code>自定义选择器用于检查数据是否已经加载到状态中。</li><li id="0ef0" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated">只有当数据在状态中不可用时，才会调度<code class="fe ni nj nk nl b">loadCourses</code>动作。</li><li id="2a17" class="ny nz it lv b lw oh lz oi mc oj mg ok mk ol mo om oe of og bi translated">在<code class="fe ni nj nk nl b">coursesLoaded</code>标志被设置为<code class="fe ni nj nk nl b">true</code>之前，运营商链不会让值传递给订户。因此，在成功加载课程之前，应用程序不会导航到<code class="fe ni nj nk nl b">/courses</code>路线。</li></ul><h2 id="e12a" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">定义路由器出口</h2><p id="b84d" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">作为最后一步，您必须在<code class="fe ni nj nk nl b">app.component.html</code>中定义路由器出口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="c55c" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">在这个阶段，你的文件夹结构应该如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/6dbf525eb92b28e4c5ea5c2591d2da93.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*TgjHG_yi0EvSIicO1hrVuw.png"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="78d3" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">配置代理以访问REST API</h1><p id="2f83" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">正如本文开头提到的，我们使用一个用Spring Boot编写的简单的REST API来连接Angular应用程序。</p><p id="1833" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">Spring Boot应用程序在<code class="fe ni nj nk nl b">localhost:8080</code>运行，而角度应用程序在<code class="fe ni nj nk nl b">localhost:4200</code>运行。当Angular应用程序试图访问REST API时，这种不匹配将导致跨源资源共享(CORS)错误。为了解决这个问题，我们必须创建一个代理。</p><h2 id="bd9f" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">创建代理文件</h2><p id="4633" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在项目的根文件夹中创建一个名为<code class="fe ni nj nk nl b">proxy.conf.json</code>的文件(与<code class="fe ni nj nk nl b">package.json</code>文件在同一层)，并在其中添加以下内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="cb61" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">注册代理文件</h2><p id="6c78" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在CLI配置文件<code class="fe ni nj nk nl b">angular.json</code>中，将<code class="fe ni nj nk nl b">proxyConfig</code>选项添加到<code class="fe ni nj nk nl b">serve</code>目标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="d662" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">运行应用程序</h1><p id="d1ef" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">应用程序应该分两步启动。您必须首先启动Spring Boot应用程序(REST API ),然后启动Angular应用程序。</p><h2 id="67d3" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">运行Spring Boot应用程序(REST API)</h2><p id="0efc" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">Spring Boot应用程序被打包成一个名为<code class="fe ni nj nk nl b">course-1.0.0-SNAPSHOT.jar</code>的可执行JAR文件，放在<a class="ae mp" href="https://github.com/sarindufit/angular-ngrx-example/blob/master/angular-ngrx-example/course-1.0.0-SNAPSHOT.jar" rel="noopener ugc nofollow" target="_blank">这里(GitHub) </a>。</p><p id="07ae" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">注意，要执行这个JAR文件，您必须在系统上安装Java 8。如果安装了Java 8，您可以执行下面的命令并启动应用程序。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="3ca6" class="mw lc it nl b gy nr ns l nt nu">java -jar {path_to_the_jar_file}/<!-- -->course-1.0.0-SNAPSHOT.jar</span></pre><p id="df13" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">如果应用程序成功启动，您应该会看到下面的日志。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="91b7" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">运行角度应用程序</h2><p id="4e11" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">可通过执行以下命令启动角度应用。</p><pre class="kj kk kl km gt nn nl no np aw nq bi"><span id="4537" class="mw lc it nl b gy nr ns l nt nu">ng serve</span></pre><p id="e3f6" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">当应用程序成功启动时，从浏览器导航到<code class="fe ni nj nk nl b">http://localhost:4200/courses</code>,您应该会看到下面的屏幕。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/cbc2fce8a938dc5eab3af48d5dd70fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBSu0oxd3AhjrZJWi4VVOQ.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="210b" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">了解执行流程</h1><h2 id="aa67" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">检索课程</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/43edb62999dec69519190da919c5702f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQFUWw97o7eg-7fpC2fF2Q.png"/></div></div></figure><h2 id="1810" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">创建课程</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/372ad660b969e773f1dbc0407affc8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lmjsld-zclvD91CUIQg_w.png"/></div></div></figure><p id="31a9" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:<strong class="lv iu"> </strong>需要注意的关键是reducer用新的数据更新状态(反过来UI也会更新)，甚至在效果调用API并实际在服务器中创建记录之前。</p><h2 id="6e76" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">更新课程</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/ff2eb523e1071d52e88246c00dfb5b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*925DzzIzNJVa3Us5BvRgkA.png"/></div></div></figure><p id="817e" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:<strong class="lv iu"> </strong>同样，reducer用更新的课程数据更新状态(反过来，UI也会更新)，甚至在效果调用API并实际更新服务器中的相关记录之前。</p><h2 id="9707" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">删除课程</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/84ebdd00744115df133939f12c291098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75BoqaCVbMA-QOcXKfWRng.png"/></div></div></figure><p id="a375" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">特别说明:类似于创建一个课程，更新一个课程，reducer从状态中删除相关的课程信息(反过来UI也会更新)，甚至在效果调用API，删除服务器中的相关记录之前。</p><h2 id="d850" class="mw lc it bd ld mx my dn lh mz na dp ll mc nb nc ln mg nd ne lp mk nf ng lr nh bi translated">乐观UI</h2><p id="26bc" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">乐观UI是一种模式，您可以用它来模拟状态突变的结果，甚至在从服务器收到响应之前更新UI。</p><p id="c171" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">在这个特定的应用程序中，我们遵循相同的模式。如上所述，当创建、更新和删除课程时，状态和UI甚至在从REST API接收到响应之前就被更新了。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="e90f" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">结论</h1><p id="49cc" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">这个故事的主要目的是提供一个分步指南来构建一个基于NgRx的Angular应用程序。</p><p id="a5fa" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">正如上一节所解释的，我们已经使用乐观UI模式实现了这个迷你系统。</p><p id="a9ba" class="pw-post-body-paragraph lt lu it lv b lw mq ju ly lz mr jx mb mc ms me mf mg mt mi mj mk mu mm mn mo im bi translated">在我的下一篇文章中，我打算解释在基于NgRx的应用程序中使用乐观UI模式时如何进行错误处理。</p></div></div>    
</body>
</html>