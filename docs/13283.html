<html>
<head>
<title>Method Chaining in Swift Using Self Returning Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中使用自返回功能的方法链接</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/method-chaining-in-swift-using-self-returning-functions-7489ca34a336?source=collection_archive---------5-----------------------#2022-08-14">https://betterprogramming.pub/method-chaining-in-swift-using-self-returning-functions-7489ca34a336?source=collection_archive---------5-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6f6f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用UIKit中的声明性编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ff693afafc6436b3cdc28fac3de9bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jgUWKdbki4MUHfe4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马修·兰卡斯特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Method_chaining" rel="noopener ugc nofollow" target="_blank">维基百科</a>将方法链定义为:</p><blockquote class="ls lt lu"><p id="3e9c" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><strong class="ky ir">方法链接</strong>，也称为<strong class="ky ir">命名参数习语</strong>，是面向对象编程语言中调用多个方法调用的常用语法。每个方法返回一个对象，允许调用在一个语句中链接在一起，而不需要变量来存储中间结果。</p></blockquote><p id="83a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很有可能，我们大多数人已经在某个时候使用过方法链。但是在这里我想谈谈一种特殊类型的对象返回函数。</p><p id="9b4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用一个例子深入探讨一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用UIKit创建普通的声明式UI</p></figure><p id="0bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，创建了一个对象<code class="fe lz ma mb mc b">UIButton</code>,它反过来用于设置按钮属性，如背景/标题颜色、按钮标题文本等。最后，将目标操作添加到相同的。</p><p id="4ce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看<code class="fe lz ma mb mc b">Self</code>返回函数是如何帮助我们的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">包含自返回功能的UIButton扩展</p></figure><p id="68fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码片段是一个带有几个函数的<code class="fe lz ma mb mc b">UIButton</code>扩展。这些功能体中的每一个基本上都设置了一个或多个按钮属性。如果你注意到，这里所有的函数都有两个共同点:</p><ol class=""><li id="f223" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated">它们都标有<code class="fe lz ma mb mc b"><strong class="ky ir">@discardableResult</strong></code> <strong class="ky ir"> </strong>属性。这是为了抑制编译器警告，因为在大多数情况下，我们不会显式地存储/使用该函数的返回值。过一会儿你就会明白了。</li><li id="b57e" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">它们都有一个返回类型为<code class="fe lz ma mb mc b">Self</code>。这就是让我们链接函数调用的原因。</li></ol><p id="3cc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们来使用这些功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用UIKit中的链式方法创建声明性UI</p></figure><p id="ed71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次我们使用上面声明的函数编辑一个按钮属性时，我们都获得按钮对象作为返回值，这又可以用来调用一个新函数。</p><p id="abf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在大多数情况下，我们甚至不必声明一个变量来存储它(当然，除非您想在以后编辑按钮属性)。</p><p id="4dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，我们将这个按钮添加到一个<code class="fe lz ma mb mc b">StackView</code>中。您可以简单地在<code class="fe lz ma mb mc b">arrangedSubviews</code>数组中定义它，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="b365" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">UIKit类加上这些漂亮而简单的扩展使得声明式UI创建成为一种流畅的体验。</p><p id="47d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种类型的方法链接不局限于UIKit类，可以与任何类类型耦合。一个广泛使用的例子是Alamofire请求API。</p></div></div>    
</body>
</html>