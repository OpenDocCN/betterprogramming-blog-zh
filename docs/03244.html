<html>
<head>
<title>Measure the Cadence of Commits in Your Git History</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测量您的Git历史中提交的节奏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/measuring-the-cadence-of-commits-in-git-history-ed58590a3b0e?source=collection_archive---------12-----------------------#2020-01-29">https://betterprogramming.pub/measuring-the-cadence-of-commits-in-git-history-ed58590a3b0e?source=collection_archive---------12-----------------------#2020-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e448" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何从git日志中挖掘数据以构建测试预言</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65c8f8cd106fdde2eb47126ac3af9683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16E8YzGksHOQxm9FvysEtA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@mn24?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔·纽西格</a>在<a class="ae kv" href="https://unsplash.com/s/photos/patterns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="77dd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Git日志是神谕的来源</h1><p id="14af" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了正确地测试Git存储库中的源代码的任何抽象的“质量”定义，我们需要首先建立一些源代码本身的基线度量。在软件QA中，这些基线度量通常被称为<strong class="lq ir">Oracle。</strong></p><p id="490b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在软件QA行话中，“<strong class="lq ir">Oracle”</strong>是我们用来评估一个测试或一组测试的正确性的方法的总称。当有人看着你的测试结果问“你对那些测试结果有多少信心？”无论你用什么来回答它们，都是一个<strong class="lq ir">神谕。</strong>根据软件测试理论，一个<strong class="lq ir"> oracle </strong>是任何完整测试的必要组成部分。</p><p id="bf30" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在测试Git存储库中源代码的质量时，我们可以参考哪些神谕？一个是Git历史中提交的<strong class="lq ir">节奏</strong>:代码多久提交一次？了解了这一点，就有可能测试(例如)新代码投入生产的频率，或者现有代码被重构的频率。</p><h1 id="24a7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><em class="mp">构建一个Oracle:“提交的步调</em>”</h1><p id="514b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这篇文章的剩余部分，我将从Git历史中最简单的计数提交用例开始，构建一个越来越细粒度的提交步调度量。我希望这将是实际有用的(这里显示的代码将与任何Git repo一起工作),并且它还将有助于显示如何从数据中构造oracles。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cd0e" class="mv kx iq mr b gy mw mx l my mz">git log --pretty=oneline | wc -l</span></pre><p id="9da7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的一行shell脚本打印出Git日志中的提交数量(针对当前分支)。计数是什么意思？这是一个神谕，所以它的确切含义是上下文相关的。</p><p id="8afd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，回购中提交的原始数量是一个有用的数据点，表明代码库被其作者触及的频率。例如，长期回购中相对较少的提交将表明开发历史上是以大批量执行的，而不是随着时间的推移许多小提交的首选模式。</p><p id="f996" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了确定Git回购的期限，请使用以下一行shell脚本:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2495" class="mv kx iq mr b gy mw mx l my mz">git log --date=relative --reverse --format="%ad" | head -n1</span></pre><p id="bed8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这将打印出回购的相对年龄，这将是一个类似于<code class="fe na nb nc mr b">36 months ago</code>的字符串，表明您的回购是在36个月前创建的。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="c3c8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了对任何Git repo中的提交节奏有一个大致的了解，您现在可以编写一个三行的shell脚本，如下所示，它应该打印出类似于<code class="fe na nb nc mr b">360 commits since 36 months ago</code>的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Git日志中提交节奏的最高级视图。</p></figure><p id="7722" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦有了Git存储库的年龄，再加上历史上提交次数的计数，就可以得到一个由多个变量组成的度量——这在度量时非常罕见！</p><p id="488b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，上面的shell脚本并没有真正达到“cadence ”,因为我们不能使用它的输出来使关于代码如何随时间提交的假设无效。</p><h1 id="4d9a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">一段时间内提交的频率</h1><p id="161a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Git日志包含带有时间戳的条目，但它不是一个时间序列。相反，<code class="fe na nb nc mr b">git log</code>命令是一个客户机，用于对存储在<code class="fe na nb nc mr b">.git</code>目录中的复杂数据结构运行查询。</p><p id="efac" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从Git日志中的提交时间戳中构建时间序列的最直接的方法是提取所有提交的时间戳，然后计算在某个时间段内有多少次提交。</p><p id="b729" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，在回购的整个生命周期中，每月提交多少次？事实证明，这个问题可以用相对较少的几行代码来回答:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一行shell脚本，从Git repo中提取每月的提交数量。</p></figure><p id="d99e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的脚本是公认的简洁和密集。它应该打印出这样的内容:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="edd4" class="mv kx iq mr b gy mw mx l my mz">53    2017-09<br/>82    2017-12<br/>20    2018-01<br/>66    2018-02<br/>49    2018-09<br/>11    2018-10<br/>35    2018-11<br/>41    2019-07<br/>23    2020-01</span></pre><p id="6525" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出是制表符分隔的，这意味着如果您将它重定向到一个文件并给该文件一个<code class="fe na nb nc mr b">.tsv</code>扩展名，您可以将它导入到Excel或Google Sheets中，并立即在您的存储库中可视化每月提交量。您还可以执行标准的数据分析任务，比如在您的Git存储库中查找每月提交的平均值、中值和标准差。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="022f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，月份是根据您的当前时区<em class="nm">计算的。</em>如果您不在办公室所在的时区，您可以在脚本的开头更改<code class="fe na nb nc mr b">TZ</code>变量的值，以反映您大部分工作发生的时区——例如:<code class="fe na nb nc mr b">TZ=-0500</code>。或者，如果你的团队是全球分布的，你可以设置<code class="fe na nb nc mr b">TZ=UTC</code>。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="7188" class="kw kx iq bd ky kz nn lb lc ld no lf lg jw np jx li jz nq ka lk kc nr kd lm ln bi translated">提交的每周频率</h1><p id="e84b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">尽管月度节奏是对Git回购进行时间序列测量的最直接的方式，但推导出活动的<em class="nm">周</em>节奏会更有用，因为对于大多数软件团队来说，计划是以周(块)为单位的。</p><p id="68ed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">可以使用<code class="fe na nb nc mr b"><a class="ae kv" href="http://www.fresse.org/dateutils/" rel="noopener ugc nofollow" target="_blank">dateutils</a></code>包中的<code class="fe na nb nc mr b">dateround</code>计算提交的每周频率:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将dateutils命令添加到上面的配方中，可以按周而不是按月存储提交。</p></figure><p id="95f2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这将再次输出制表符分隔的值(TSV ),您可以将其直接保存到扩展名为<code class="fe na nb nc mr b">.tsv</code>的文件中，然后使用数据可视化工具进行可视化。</p><p id="d3e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我将总结一下，因为已经深入到提交<strong class="lq ir"> </strong>的每周节奏，我们已经达到了足够细粒度的Git度量，可以在讨论代码质量时使用。换句话说，我们得到了一个有用的神谕！</p></div></div>    
</body>
</html>