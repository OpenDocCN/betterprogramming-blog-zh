<html>
<head>
<title>How to Implement SSL Pinning in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中实现SSL锁定</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-ssl-pinning-in-swift-7c4e8f6ee821?source=collection_archive---------1-----------------------#2020-05-20">https://betterprogramming.pub/how-to-implement-ssl-pinning-in-swift-7c4e8f6ee821?source=collection_archive---------1-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf4f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无论你使用苹果的API还是Alamofire，都要在你的应用中防止中间人攻击</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f43fbe953070d25bea0970299fb6196e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IfKI21qjhkhr1cX4N7du3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@almosbech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿尔莫斯·贝托尔德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/fire?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz"><p id="52e6" class="la lb it bd lc ld le lf lg lh li lj dk translated"><em class="lk">隐私——就像吃饭和呼吸一样——是生活的基本要求之一。</em></p><p id="2ed5" class="la lb it bd lc ld ll lm ln lo lp lj dk translated">凯瑟琳·内维尔</p></blockquote><p id="d33a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk lj im bi translated">几乎每个iOS应用程序都与服务器通信以检索信息。有时这些信息是敏感的，您不希望任何人能够访问它们(例如，他们登录应用程序的用户名和密码)。</p><p id="733f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">在iOS 9的发布会上，苹果推出了<em class="mq"> App传输安全</em>，通过采用HTTPS协议和<a class="ae ky" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank">传输层安全(TLS) </a>，强制应用使用安全的网络连接。这是什么意思？这意味着我们的应用无法通过不安全的连接与服务器通信。实际上，可以绕过这个限制，但是为了避免潜在的攻击，不建议这样做。</p><p id="8f12" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">所以我的数据是安全的，对吗？答案是否定的！即使TLS保护了传输的数据，攻击者也更容易使用黑客或自签名证书设置<em class="mq">中间人攻击</em>。这意味着他们可以捕捉进出你的应用程序的数据。</p><p id="16b9" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">在本文中，我将解释如何防止这种攻击，以确保您的应用程序数据安全。我们将涵盖以下主题的一些基本知识:</p><ul class=""><li id="e8fc" class="mr ms it ls b lt ml lw mm lz mt md mu mh mv lj mw mx my mz bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="mq">对称</em> </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Public-key_cryptography" rel="noopener ugc nofollow" target="_blank"> <em class="mq">非对称</em> </a>加密。</li><li id="18c6" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Certificate_authority" rel="noopener ugc nofollow" target="_blank">认证机构</a>。</li></ul></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="3eee" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">传输层安全性</h1><p id="3c21" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">首先，我们需要了解TLS和中间人<em class="mq"> </em>攻击的工作原理，了解如何预防它们。TLS允许您通过安全网络传输数据，遵循三个阶段:</p><ul class=""><li id="c1d2" class="mr ms it ls b lt ml lw mm lz mt md mu mh mv lj mw mx my mz bi translated">客户端通过发送包含受支持的TLS版本和用于加密的<a class="ae ky" href="https://en.wikipedia.org/wiki/Cipher_suite" rel="noopener ugc nofollow" target="_blank">密码套件</a>的消息来启动与服务器的连接。服务器用选择的密码组和一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Public_key_certificate" rel="noopener ugc nofollow" target="_blank">数字证书</a>进行响应。客户端验证这些数字证书是真实的(即由认证机构发布)。</li><li id="6aac" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated">如果验证成功，客户端将生成一个预主密钥，该密钥使用证书中包含的服务器公钥进行加密。服务器用它的私钥解密这个秘密。两者都使用这个秘密来生成主密钥。</li><li id="641b" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated">两者都使用明文加密，并通过使用主密钥和对称加密来解密密文。</li></ul><p id="bc82" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">但是，什么是证书呢？证书是服务器身份的证明。它只是一个文件，包含拥有证书的服务器的信息，遵循<a class="ae ky" href="https://en.wikipedia.org/wiki/X.509" rel="noopener ugc nofollow" target="_blank"> X.509标准</a>。客户端只信任能够提供由可信证书颁发机构之一签名的有效证书的服务器，否则，连接将中止。</p><p id="3c8f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">为了验证它，应用程序验证:</p><ul class=""><li id="a26d" class="mr ms it ls b lt ml lw mm lz mt md mu mh mv lj mw mx my mz bi translated">截止日期。</li><li id="63e5" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated">数字签名。</li></ul></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="e712" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">中间人</h1><p id="ff00" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">中间人是攻击者秘密监听并最终改变双方通信的一种攻击。使用这种攻击来拦截应用程序发送到服务器的数据比你想象的要容易。您所需要的只是一个SSL代理服务器。</p><p id="5c19" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">SSL代理在客户机和服务器之间执行加密和解密(两个方向的密钥不同)。查尔斯就是一个例子。它位于你的应用程序和互联网之间，你可以检查甚至中途更改数据，以测试你的应用程序如何响应。</p><ul class=""><li id="7337" class="mr ms it ls b lt ml lw mm lz mt md mu mh mv lj mw mx my mz bi translated">您的应用程序使用Charles ProxyCertificate公钥加密数据，而不是服务器的。Charles证书是有效的，因为开发者可以将它安装在他的设备中。</li><li id="24d1" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated">Charles能够用其私钥解密所有数据，然后使用服务器的公钥与服务器通信。</li></ul><p id="cfd2" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">这意味着任何开发者都可以读取你的应用程序通过网络发送的所有数据！</p><p id="294d" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">下面是<a class="ae ky" href="http://Follow this tutorial to know how to setup Charles." rel="noopener ugc nofollow" target="_blank">如何设置查尔斯</a>。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="daea" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">SSL固定</h1><p id="66ac" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">幸运的是，有一种简单的方法可以防止这种攻击，通过一种叫做SSL固定的技术。</p><p id="0fac" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">这种技术再次验证服务器证书，即使在SSL握手之后。开发人员在客户端应用程序中嵌入一系列可信证书，并在运行时将它们与服务器证书进行比较。在服务器证书和本地副本不匹配的情况下，简单地中止连接。</p><p id="3940" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">这意味着应用程序将检查查尔斯的证书，即使它是可信的，它也将不同于嵌入在应用程序中的本地证书。</p><p id="4cf2" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">一个缺点是，一个固定的证书有一个截止日期，这需要应用程序更新，除非开发人员也在应用程序中固定未来的证书。实际上，不需要固定整个证书，您可以只使用散列的公钥(这是一个更好的方法，因为我们可以在未来的证书中重用相同的散列密钥)。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="e08d" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">锁定Swift</h1><p id="f9a1" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">评估信任分两步走。</p><ul class=""><li id="683c" class="mr ms it ls b lt ml lw mm lz mt md mu mh mv lj mw mx my mz bi translated">验证证书的数字签名。你的应用可以依赖任何嵌入在<a class="ae ky" href="https://support.apple.com/en-us/HT204132" rel="noopener ugc nofollow" target="_blank"> iOS </a>中的根证书，或者你可以提供自己的根证书。</li><li id="945a" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated">根据信任策略测试证书。该策略指示证书的特定字段或扩展应该如何被信任。</li></ul><p id="ac68" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">所有这些活动都是通过使用一个或多个证书和策略对象准备的<code class="fe oj ok ol om b"><a class="ae ky" href="https://developer.apple.com/documentation/security/sectrust" rel="noopener ugc nofollow" target="_blank">SecTrust</a></code>对象的实例来实现的。</p><h2 id="7116" class="on nn it bd no oo op dn ns oq or dp nw lz os ot ny md ou ov oa mh ow ox oc oy bi translated">准备证书</h2><p id="3aec" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">Apple提供了<code class="fe oj ok ol om b"><a class="ae ky" href="https://developer.apple.com/documentation/security/seccertificate" rel="noopener ugc nofollow" target="_blank">SecCertificate</a></code>来代表X.509证书。如果您将证书添加到捆绑包中，您可以使用以下命令检索它:</p><pre class="kj kk kl km gt oz om pa pb aw pc bi"><span id="f59f" class="on nn it om b gy pd pe l pf pg"><strong class="om iu">let</strong> filePath = Bundle.main.path(forResource: name, ofType: type)!</span><span id="dac7" class="on nn it om b gy ph pe l pf pg"><strong class="om iu">let</strong> data = <strong class="om iu">try</strong>! Data(contentsOf: URL(fileURLWithPath: filePath))</span><span id="807b" class="on nn it om b gy ph pe l pf pg"><strong class="om iu">let</strong> certificate = SecCertificateCreateWithData(<strong class="om iu">nil</strong>, data <strong class="om iu">as</strong> CFData)</span></pre><p id="8ff7" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/security/certificate_key_and_trust_services/certificates/getting_a_certificate" rel="noopener ugc nofollow" target="_blank">在这里</a>您还可以找到更复杂的解决方案，例如，使用钥匙链和身份识别。没有“最佳”的解决方案，因为它主要取决于问题和你的应用程序需要的安全级别。我建议你仔细阅读并全部尝试，然后决定哪一个适合你的需要。</p><h2 id="20b1" class="on nn it bd no oo op dn ns oq or dp nw lz os ot ny md ou ov oa mh ow ox oc oy bi translated">准备一项政策</h2><p id="1fb2" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">最好的选择通常是使用预定义的策略之一。例如，您可以将X509证书的标准基本策略用于:</p><pre class="kj kk kl km gt oz om pa pb aw pc bi"><span id="90c8" class="on nn it om b gy pd pe l pf pg">let policies = <!-- -->SecPolicyCreateBasicX509()</span></pre><p id="13ec" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">这对你的应用程序来说可能足够了，但是如果你需要更多的灵活性，你可以用<code class="fe oj ok ol om b"><a class="ae ky" href="https://developer.apple.com/documentation/security/1392592-secpolicycreatessl" rel="noopener ugc nofollow" target="_blank">SecPolicyCreateSSL(_:_:)</a></code>创建你自己的SSL策略。</p><h2 id="8e73" class="on nn it bd no oo op dn ns oq or dp nw lz os ot ny md ou ov oa mh ow ox oc oy bi translated">秘方</h2><p id="ccc3" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">现在是时候验证证书和策略了。苹果用一个<code class="fe oj ok ol om b"><a class="ae ky" href="https://developer.apple.com/documentation/security/sectrust" rel="noopener ugc nofollow" target="_blank">SecTrust</a></code>对象方便了所有这些操作。</p><pre class="kj kk kl km gt oz om pa pb aw pc bi"><span id="1445" class="on nn it om b gy pd pe l pf pg">var optionalTrust: SecTrust?<br/>let status = SecTrustCreateWithCertificates(certArray as AnyObject,<br/>                                            policy,<br/>                                            &amp;optionalTrust)<br/>guard status == errSecSuccess else { return }<br/>let trust = optionalTrust!</span></pre><p id="1982" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated"><code class="fe oj ok ol om b">SecTrustCreateWithCertificates(_:_:_:)</code>根据提供的证书和策略创建信任管理对象。</p><p id="3968" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">您可以使用<code class="fe oj ok ol om b">SecTrustEvaluateWithError(_:_:)</code>来验证一个信任对象。从文档中:</p><blockquote class="pi pj pk"><p id="b0ab" class="lq lr mq ls b lt ml ju lv lw mm jx ly pl mn mb mc pm mo mf mg pn mp mj mk lj im bi translated">此方法评估证书的有效性，以针对特定用途建立信任，例如，创建数字签名或建立安全套接字层连接。该方法根据包含在信任管理对象中的一个或多个策略，通过验证证书的签名加上其证书链中的证书的签名，直到锚证书，来验证证书。</p><p id="a3f6" class="lq lr mq ls b lt ml ju lv lw mm jx ly pl mn mb mc pm mo mf mg pn mp mj mk lj im bi translated">如果信任管理实例缺少验证叶证书所需的一些证书，<code class="fe oj ok ol om b">SecTrustEvaluateWithError(_:_:)</code>搜索证书:</p><p id="cab0" class="lq lr mq ls b lt ml ju lv lw mm jx ly pl mn mb mc pm mo mf mg pn mp mj mk lj im bi translated">-在用户的钥匙串中。</p><p id="467b" class="lq lr mq ls b lt ml ju lv lw mm jx ly pl mn mb mc pm mo mf mg pn mp mj mk lj im bi translated">-在您以前通过调用SecTrustSetAnchorCertificates(_:_:)提供的任何证书中。</p><p id="8f99" class="lq lr mq ls b lt ml ju lv lw mm jx ly pl mn mb mc pm mo mf mg pn mp mj mk lj im bi translated">-在系统为此目的提供的一组钥匙链中。</p><p id="0fae" class="lq lr mq ls b lt ml ju lv lw mm jx ly pl mn mb mc pm mo mf mg pn mp mj mk lj im bi translated">-通过网络，如果用于构建链的证书中存在某些扩展。</p></blockquote><p id="132b" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">你现在唯一需要做的就是用你的策略评估你在网络通话中收到的<code class="fe oj ok ol om b">SecTrust</code>，并将证书与应用程序中的证书进行比较。</p><p id="a893" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="05a8" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">这是一个简单的例子，但是还有许多其他参数和对象来处理所有可能的<code class="fe oj ok ol om b">SecTrust</code>验证。我建议你仔细阅读苹果公司提供的所有文档，并在尝试将其用于你的应用程序之前进行测试。</p><p id="98fa" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/security/certificate_key_and_trust_services" rel="noopener ugc nofollow" target="_blank">这里是</a>主链接。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="50ad" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">用Alamofire 5固定</h1><p id="1475" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">如您所见，使用普通API相当复杂。我推荐使用<code class="fe oj ok ol om b">Alamofire</code>，它是一个外部库，提供了更高级别的API，让您的生活更加简单。</p><p id="db8a" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">一切都基于<code class="fe oj ok ol om b">ServerTrustEvaluating</code>协议，该协议提供了一种执行任何类型的服务器信任评估的方法。Alamofire包括许多不同类型的信任评估程序，例如:</p><ul class=""><li id="32fa" class="mr ms it ls b lt ml lw mm lz mt md mu mh mv lj mw mx my mz bi translated"><code class="fe oj ok ol om b">DefaultTrustEvaluator</code>:允许您控制是否验证挑战提供的主机。</li><li id="6885" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated"><code class="fe oj ok ol om b">RevocationTrustEvaluator</code>:检查收到的证书的状态，确保它没有被撤销。</li><li id="32b7" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated"><code class="fe oj ok ol om b">PinnedCertificatesTrustEvaluator</code>:如果其中一个固定证书与其中一个服务器证书匹配，则认为服务器信任有效。</li><li id="fe6d" class="mr ms it ls b lt na lw nb lz nc md nd mh ne lj mw mx my mz bi translated"><code class="fe oj ok ol om b">PublicKeysTrustEvaluator</code>:如果固定的公钥之一与服务器证书的公钥之一相匹配，则认为服务器信任有效。</li></ul><p id="3fdb" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">你只需要为每个API选择使用哪个<code class="fe oj ok ol om b">ServerTrustEvaluating</code>:</p><pre class="kj kk kl km gt oz om pa pb aw pc bi"><span id="79b1" class="on nn it om b gy pd pe l pf pg">let evaluators: [String: ServerTrustEvaluating] = [<br/>    "cert.example.com": PinnedCertificatesTrustEvalutor(),<br/>]<br/><br/>let manager = ServerTrustManager(evaluators: serverTrustPolicies)</span></pre><p id="2fa4" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">然后与他们建立一个会话:</p><pre class="kj kk kl km gt oz om pa pb aw pc bi"><span id="6296" class="on nn it om b gy pd pe l pf pg">let serverTrustManager = ServerTrustManager(evaluators: evaluators)</span><span id="bdae" class="on nn it om b gy ph pe l pf pg"><strong class="om iu">self</strong>.session = Session(serverTrustManager: serverTrustManager)</span></pre><p id="d5a4" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">你可以在这里阅读完整的文档<a class="ae ky" href="https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md#security" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="2f54" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">如何下载证书</h1><p id="0672" class="pw-post-body-paragraph lq lr it ls b lt oe ju lv lw of jx ly lz og mb mc md oh mf mg mh oi mj mk lj im bi translated">如果你想做一些测试或者你需要验证一个公共的API，你可以下载证书并把它绑定到你的应用上。</p><p id="aa9f" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">打开您的终端，写下以下内容:</p><pre class="kj kk kl km gt oz om pa pb aw pc bi"><span id="9ddd" class="on nn it om b gy pd pe l pf pg">openssl s_client -connect <strong class="om iu">&lt;url&gt;</strong>:443 &lt;/dev/null \<br/>  | openssl x509 -outform DER -out <strong class="om iu">&lt;filename&gt;</strong>.der</span></pre><p id="7e85" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">这会将证书下载到您当前的文件夹中。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="d791" class="pw-post-body-paragraph lq lr it ls b lt ml ju lv lw mm jx ly lz mn mb mc md mo mf mg mh mp mj mk lj im bi translated">我希望你喜欢这篇文章！如果你有任何疑问，请随时联系我。</p></div></div>    
</body>
</html>