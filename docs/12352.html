<html>
<head>
<title>Stress Testing Concurrent Features in React 18: A Case Study of startTransition and 3D Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18中并发特性的压力测试:startTransition和3D渲染的案例研究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stress-testing-concurrent-features-in-react-18-a-case-study-of-starttransition-and-3d-rendering-9aecb4a479f8?source=collection_archive---------16-----------------------#2022-05-30">https://betterprogramming.pub/stress-testing-concurrent-features-in-react-18-a-case-study-of-starttransition-and-3d-rendering-9aecb4a479f8?source=collection_archive---------16-----------------------#2022-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解React 18的并发功能，并使用three.js构建的3D数据可视化对其进行压力测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39bed78f0d54c7bf2410e1e0cf30378e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Iub5FOJ6yC59eB6Q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔瓦罗·雷耶斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将深入3D可视化，并讨论如何使用React 18的并发渲染逐步优化其性能。先睹为快:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="5542" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">使用useTransition进行并发渲染</h1><p id="0dd9" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener ugc nofollow" target="_blank"> React 18介绍并发特性</a>。核心思想是将状态更新分为两类:</p><ul class=""><li id="6c26" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">紧急更新:它们为用户交互提供响应反馈，比如打字和点击。</li><li id="a459" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">转换更新:它们提供非紧急的UI转换，比如显示数据集。</li></ul><p id="4578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目的是为用户创造更快、更灵敏的体验。</p><p id="e2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React 18之前，所有的更新都被认为是紧急的，当有更大的渲染时，简单的点击或输入就可以导致屏幕冻结。因此，在React 18中，通过将非紧急更新推迟到紧急更新，用户能够从他们的交互中接收即时反馈，同时React在后台处理非紧急更新，并在准备就绪时反映结果。</p><p id="fd33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React工作组发表了几篇关于过渡更新的精彩文章:</p><ul class=""><li id="1eb6" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/41" rel="noopener ugc nofollow" target="_blank">新功能:startTransition </a></li><li id="3f32" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/65" rel="noopener ugc nofollow" target="_blank">真实世界示例:为慢速渲染添加startTransition】</a></li></ul><p id="51ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据工作组，并行渲染能够执行以下任务:</p><ul class=""><li id="544d" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">屈服:React会周期性地停止工作，让浏览器产生一个或多个副作用。</li><li id="2728" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">中断:当React检测到新的紧急更新时，它将中断和暂停非紧急更新，并开始处理传入的紧急更新，以便页面能够保持响应。</li><li id="21bc" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">跳过旧结果:React将丢弃过时的过渡更新，仅使用最新状态进行渲染。</li></ul><p id="6e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用文章中的格式和方法来测试3D渲染演示，并观察对性能和用户体验的影响。</p><h1 id="d5a4" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">3D渲染演示概述</h1><p id="9a0e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了创建用于渲染的繁重计算，我构建了一个3D可视化来显示GitHub用户和他们在GitHub上联系的用户之间的联系。</p><p id="2f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该技术包括:</p><ul class=""><li id="de70" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/mrdoob/three.js/" rel="noopener ugc nofollow" target="_blank"> three.js </a></li><li id="8fce" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/pmndrs/react-three-fiber" rel="noopener ugc nofollow" target="_blank">反应三纤</a></li><li id="514e" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener ugc nofollow" target="_blank">反应18 </a></li></ul><p id="18cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户界面如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/ddd520c6fcfa0bbfae5f28a674afb590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8Yf41QsCVeLX2Fdpa40Mw.png"/></div></div></figure><p id="f690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们今天将讨论的组件包括:</p><ul class=""><li id="8db2" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">搜索栏:搜索GitHub用户名并从GitHub GraphQL API获取用户信息。</li><li id="cae5" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">场景:在3D地球上可视化用户和他们的连接之间的连接。</li></ul><blockquote class="nj nk nl"><p id="fbf8" class="kz la nm lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated"><em class="it">你可以在GitHub </em>  <em class="it">上找到</em> <a class="ae ky" href="https://github.com/DawChihLiou/concurrent-react-stress-testing" rel="noopener ugc nofollow" target="_blank"> <em class="it">的仓库，在Netlify </em> </a> <em class="it">上找到</em> <a class="ae ky" href="https://sweaty-concurrent-react.netlify.app/" rel="noopener ugc nofollow" target="_blank"> <em class="it">的演示。</em></a></p><p id="ce78" class="kz la nm lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">请注意，由于任务超时，演示可能会崩溃。超时是由获取城市坐标的实验性API调用缓慢造成的。如果您想与演示程序进行交互，建议您派生存储库并在本地运行开发服务器。</p></blockquote><p id="fb7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在搜索栏中输入时，您会看到场景中的星星数量不断增加，以模拟UI上的高渲染需求。星星的数量是<code class="fe nq nr ns nt b">100,000 * inputValue.length</code>。我们将使用它来对并发渲染进行压力测试。</p><h1 id="f521" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">问题是</h1><p id="d8d7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">让我们从最基本的实现开始。结果看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">你可以在视频左下角看到我的打字。</em></p><p id="579f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我打字的时候，搜索栏被冻结了。它直到最后才显示输入值。不仅仅是搜索栏，现场也被冻结了。直到我打完字星星才被渲染出来。理想情况下，我们希望能够观察到我们打字的即时反馈。</p><p id="c31b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一起来看看表演。我们将CPU速度降低4倍，并运行性能分析。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/2c66c3d923c8821f9e37967c632ee586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UHAxuiamkNwBrZpyzQRkQ.png"/></div></div></figure><p id="12ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在火焰图中看到带有按键事件的大块任务。每按一次键，React就会计算出<code class="fe nq nr ns nt b">SearchBar</code>和<code class="fe nq nr ns nt b">Scene</code>的下一次渲染。正如我们在图表中看到的，最长的任务几乎需要0.8秒才能完成。所以页面感觉这么慢。</p><h1 id="9bac" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">发生了什么事？</h1><p id="5c34" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在主页组件中，<code class="fe nq nr ns nt b">SearchBar</code>监听按键事件，并在发生变化时更新<code class="fe nq nr ns nt b">username</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv lw l"/></div></figure><p id="4d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当有<code class="fe nq nr ns nt b">username</code>更新时，React通过调用<code class="fe nq nr ns nt b">computeVertices()</code>重新计算<code class="fe nq nr ns nt b">vertices</code>，并将结果传递给<code class="fe nq nr ns nt b">Scene</code>组件来渲染星星。由于顶点的数量是<code class="fe nq nr ns nt b">100,000 * username.length</code>，将两个状态的更新耦合在一起是一个非常昂贵的渲染周期。</p><h1 id="d696" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">在React 18之前我们是怎么修复的？</h1><p id="d66d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">理想情况下，我们希望立即看到我们在搜索栏中输入的内容。知道在同一个渲染周期中更新两个状态需要太长时间，我们可以简单地将两个更新分开，这样<code class="fe nq nr ns nt b">SearchBar</code>和<code class="fe nq nr ns nt b">Scene</code>就可以分别渲染。</p><p id="b93f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先为<code class="fe nq nr ns nt b">SearchBar</code>添加一个新的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv lw l"/></div></figure><p id="9891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有一个<code class="fe nq nr ns nt b">value</code>状态用于<code class="fe nq nr ns nt b">SearchBar</code>和一个<code class="fe nq nr ns nt b">username</code>状态用于计算<code class="fe nq nr ns nt b">vertices</code>。我们将需要额外的工作来分离渲染，因为React将在同一事件中批量更新状态，以避免额外的渲染。让我们来看看一些典型的方法。</p><h1 id="8237" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">方法1:设置超时</h1><p id="96e7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以简单地通过添加<code class="fe nq nr ns nt b">setTimeout</code>将其放入事件循环来推迟较慢的更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv lw l"/></div></figure><p id="91d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，即使减速4倍，<code class="fe nq nr ns nt b">SearchBar</code>看起来反应更灵敏。我们还观察到，当我们打字时，星星正在被渲染。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="bdcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您看一下性能配置文件，您会发现我们能够将按键事件与昂贵的任务分开。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/92acbee636338d1864580ad2b27e4a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1r2h7JqfN4nbCYLWV0xloQ.png"/></div></div></figure><p id="71f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们注意到<code class="fe nq nr ns nt b">Scene</code>在最后一次按键事件后被渲染了两次。那是因为当<code class="fe nq nr ns nt b">setTimeout</code> s被发射时，渲染仍然以一种过时的状态被安排。</p><h1 id="6b93" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">方法2:去抖</h1><p id="325e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们实际上可以通过实现去抖动来取消渲染时间表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv lw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="085b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户体验现在看起来更好了。在最后一次按键事件消失后，<code class="fe nq nr ns nt b">SearchBar</code>保持相当的响应速度，速度降低了4倍，并且对<code class="fe nq nr ns nt b">Scene</code>进行了冗余更新。</p><p id="9942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，去抖的缺点是，在这种情况下，<code class="fe nq nr ns nt b">Scene</code>更新将总是延迟100ms。对于更快的CPU，延迟很可能是多余的，它使页面感觉很慢。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/25b55f486aabeccd232765e5aa798da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ux1FZj3UnUXLwcLMpL2Qeg.png"/></div></div></figure><h1 id="b911" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">React 18的并发渲染:startTransition</h1><p id="a61f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">添加<code class="fe nq nr ns nt b">setTimeout</code>或去抖动后，页面感觉更灵敏，但它们会带来不同的问题:</p><ul class=""><li id="cb02" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><code class="fe nq nr ns nt b">setTimeout</code>:导致带有过期状态的额外UI更新</li><li id="426a" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe nq nr ns nt b">debouncing:</code>导致用户界面更新的人为延迟</li></ul><p id="ef39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看React 18如何解决并发渲染的问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv lw l"/></div></figure><p id="feff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe nq nr ns nt b">startTransition</code>函数内部调用<code class="fe nq nr ns nt b">setUsername</code>。它告诉React将<code class="fe nq nr ns nt b">setUsername</code>推迟到其他紧急更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们能够在没有任何异步功能的情况下分离<code class="fe nq nr ns nt b">SearchBar</code>和<code class="fe nq nr ns nt b">Scene</code>的渲染。如果我们看一下性能概况，我们可以观察到一些情况:</p><ul class=""><li id="a870" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">按键事件与长渲染函数调用分开。</li><li id="d73a" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">按键事件被分组。它符合并发渲染中的让步行为。</li><li id="00f3" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">在最后一组按键事件之后，只有一个呈现调用。它与并行渲染中的跳过旧结果行为一致。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/98f59c4f21874d81614fcb584ede9e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCEGhRWqmaiqYGi3RgUv3w.png"/></div></div></figure><p id="6f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打断行为不是很容易观察到的。如果你知道如何从绩效档案中分析它，请随时在Twitter上与我联系！</p><p id="919b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们去掉减速，看看最后的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe nq nr ns nt b">SearchBar</code>总是反应灵敏，而<code class="fe nq nr ns nt b">Scene</code>更新迅速。用户体验感觉流畅多了。</p><h1 id="1206" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">最后的想法</h1><p id="7bf3" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">过去，在保持页面响应性的同时，添加去抖动是渲染大型UI更新的首选解决方案。基于这个实验，并发渲染使用户界面响应更快——没有去抖动的缺点。</p><p id="13e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使对于至少有100，000个3D对象的繁重计算，并发渲染仍然有助于页面的快速运行。</p><p id="f2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是并排比较:</p><h2 id="42e8" class="ny ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated"><strong class="ak"> UI与4x CPU节流的比较</strong></h2><p id="24cd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">无并发渲染的基本实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ae8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并行渲染的优化实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="c701" class="ny ly it bd lz nz oa dn md ob oc dp mh li od oe mj lm of og ml lq oh oi mn oj bi translated"><strong class="ak">无CPU限制的用户界面对比</strong></h2><p id="4c3a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">无并发渲染的基本实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a74e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并行渲染的优化实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="600a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">参考</h1><ul class=""><li id="b744" class="mu mv it lb b lc mp lf mq li ok lm ol lq om lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/DawChihLiou/concurrent-react-stress-testing" rel="noopener ugc nofollow" target="_blank"> GitHub:演示库</a></li><li id="85ba" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://sweaty-concurrent-react.netlify.app/" rel="noopener ugc nofollow" target="_blank">网站:演示网站</a></li><li id="4393" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener ugc nofollow" target="_blank">网址:React v18.0 </a></li><li id="0c61" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/41" rel="noopener ugc nofollow" target="_blank"> GitHub:新功能:startTransition </a></li><li id="bb7a" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/reactwg/react-18/discussions/65" rel="noopener ugc nofollow" target="_blank"> GitHub:真实世界示例:为慢速渲染添加startTransition】</a></li><li id="110e" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/mrdoob/three.js/" rel="noopener ugc nofollow" target="_blank"> GitHub: three.js </a></li><li id="1f15" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://github.com/pmndrs/react-three-fiber" rel="noopener ugc nofollow" target="_blank">GitHub:react-三纤</a></li><li id="7cae" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><a class="ae ky" href="https://webgl-globe-solutions.stackblitz.io/" rel="noopener ugc nofollow" target="_blank">网址:WebGL Globe解决方案</a></li></ul></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ou nt ov ow aw ox bi"><span id="cdd0" class="ny ly it nt b gy oy oz l pa pb"><strong class="nt iu">Want to Connect?</strong></span><span id="c5fe" class="ny ly it nt b gy pc oz l pa pb">This article is originally posted on <a class="ae ky" href="https://dawchihliou.github.io/articles/stress-testing-concurrent-features-in-react-18" rel="noopener ugc nofollow" target="_blank">Daw-Chih’s website</a>.</span></pre></div></div>    
</body>
</html>