<html>
<head>
<title>Introduction to Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-regex-8c18abdd4f70?source=collection_archive---------6-----------------------#2019-08-29">https://betterprogramming.pub/introduction-to-regex-8c18abdd4f70?source=collection_archive---------6-----------------------#2019-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ef6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python逐步介绍正则表达式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45dc6a6c73567cd13191498fc7b933f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-bcadRUeImW9Zw3H"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="4ecc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是正则表达式？</h1><p id="8f49" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Regex代表<em class="mn">正则表达式</em>，本质上是一种简单的<em class="mn">定义字符模式的方式。正则表达式主要用于模式识别、文本挖掘或输入验证。</em></p><p id="3750" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Regex让很多人望而却步，因为它乍一看像是胡言乱语。但那些知道如何使用它的人，似乎无法停止！这是一个值得学习的强大工具。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="cc8e" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">正则表达式简介</h1><p id="4fbd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关于regex，您需要知道的第一件事是您可以匹配特定的字符或单词。</p><p id="bbae" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们假设，我们想知道一个特定的字符串是否包含字母“a”或单词“lot”。我们可以使用以下python代码:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="6af9" class="nk la it ng b gy nl nm l nn no">import re<br/>str = "Learning regex can be a lot of fun"<br/>lst = re.findall('a', str)<br/>lst2 = re.findall('lot', str)<br/>print(lst)<br/>print(lst2)</span></pre><p id="9247" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这将返回一个包含三个匹配项的列表和一个包含一个匹配项的列表:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="28bd" class="nk la it ng b gy nl nm l nn no">['a', 'a', 'a']<br/>['lot']</span></pre><p id="379e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">保持相同的设置，假设您想要以任意顺序搜索这三个字母:a、b和c。您可以使用方括号列出一个列表:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="a7b7" class="nk la it ng b gy nl nm l nn no">lst = re.findall('[abc]', str)<br/>lst2 = re.findall('[a-c]', str)<br/>print(lst)<br/>print(lst2)</span></pre><p id="6c90" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这将返回:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="b4da" class="nk la it ng b gy nl nm l nn no">['a', 'c', 'a', 'b', 'a']<br/>['a', 'c', 'a', 'b', 'a']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89ff21a6acad16c12ef08821d3872144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m3a4fk_BX_o2tVMM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e6a1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">让我们看另一个例子。假设你有一个很大的电子邮件存档，你想找到夏洛克发给他的朋友华生医生的所有电子邮件。您知道每个电子邮件文件头看起来会像这样:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="2e09" class="nk la it ng b gy nl nm l nn no">From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>&gt;<br/>Subject: The giberrish looking algorithm<br/>To: Dr Watson &lt;johnhwatson<a class="ae ky" href="mailto:drwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">@mysteryemails.com</a>&gt;</span></pre><p id="7d8d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">因此，您想要搜索包含单词“发件人:”后跟夏洛克的电子邮件地址和“收件人:”后跟沃森博士的电子邮件地址的内容。仅使用我们到目前为止介绍的基础知识，我们可以扫描文档一次，查找来自:夏洛克·福尔摩斯&lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank"><em class="mn">sherlock@mysteryemails.com</em></a><em class="mn">&gt;’</em>，然后再次查找来自:华生医生&lt;<a class="ae ky" href="mailto:drwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank"><em class="mn">@ mysteryemails . com</em></a><em class="mn">&gt;</em>。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e157" class="nk la it ng b gy nl nm l nn no">import re<br/>str = '''<br/>  From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>&gt;<br/>  Subject: The giberrish looking algorithm<br/>  To: Dr Watson &lt;<a class="ae ky" href="mailto:johnhwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">johnhwatson@mysteryemails.com</a>&gt;'''</span><span id="badd" class="nk la it ng b gy np nm l nn no">lst = re.findall('From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>&gt;',str)<br/>lst2= re.findall('To: Dr Watson &lt;<a class="ae ky" href="mailto:johnhwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">johnhwatson@mysteryemails.com</a>&gt;',str)</span><span id="5ffe" class="nk la it ng b gy np nm l nn no">print(lst)<br/>print(lst2)</span></pre><p id="2c16" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">返回此:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7154" class="nk la it ng b gy nl nm l nn no">['From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>&gt;']<br/>['To: Dr Watson &lt;<a class="ae ky" href="mailto:johnhwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">johnhwatson@mysteryemails.com</a>&gt;']</span></pre><p id="f80d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">匹配了这两个字符串后，我们知道这封邮件确实是从夏洛克发给沃森博士的。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="6e8c" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">正则表达式备忘单</h1><p id="2bbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每当我需要写一个复杂的正则表达式时，我的第一个停靠点是下面的<a class="ae ky" href="https://www.py4e.com/lectures3/Pythonlearn-11-Regex-Handout.txt" rel="noopener ugc nofollow" target="_blank">列表</a>，由查克·塞费恩博士提供:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="1a33" class="nk la it ng b gy nl nm l nn no">Python Regular Expression Quick Guide</span><span id="65fd" class="nk la it ng b gy np nm l nn no">^        Matches the beginning of a line<br/>$        Matches the end of the line<br/>.        Matches any character<br/>\s       Matches whitespace<br/>\S       Matches any non-whitespace character<br/>*        Repeats a character zero or more times<br/>*?       Repeats a character zero or more times <br/>         (non-greedy)<br/>+        Repeats a character one or more times<br/>+?       Repeats a character one or more times <br/>         (non-greedy)<br/>[aeiou]  Matches a single character in the listed set<br/>[^XYZ]   Matches a single character not in the listed set<br/>[a-z0-9] The set of characters can include a range<br/>(        Indicates where string extraction is to start<br/>)        Indicates where string extraction is to end</span></pre><p id="70c8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">使用上面的备忘单作为指南，您可以想出几乎任何语法。让我们仔细看看一些更复杂的搜索模式。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="bb00" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">填补空白</h1><p id="abda" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据我们前面的例子，我们希望使我们的模式匹配算法更加健壮。我们想搜索单词“<em class="mn"> From: </em>”，然后是夏洛克的电子邮件地址。</p><p id="e200" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">使用上面的备忘单，我们可以使用'<em class="mn">。* </em>'匹配任意字符零次或多次。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="b608" class="nk la it ng b gy nl nm l nn no">import re<br/>str = '''<br/>  From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>&gt;<br/>  Subject: The giberrish looking algorithm<br/>  To: Dr Watson &lt;<a class="ae ky" href="mailto:johnhwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">johnhwatson@mysteryemails.com</a>&gt;'''</span><span id="9266" class="nk la it ng b gy np nm l nn no">lst = re.findall('From:.*<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>',str)</span><span id="84c9" class="nk la it ng b gy np nm l nn no">print(lst)</span></pre><p id="6990" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这就给出了:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="1911" class="nk la it ng b gy nl nm l nn no">['From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>']</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="5d69" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">多行匹配</h1><p id="502e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">继续上一个例子，让我们扩展匹配模式，使其跨多行工作。我们可以使用regex的(M)multiline函数来实现这一点。这里值得强调的是，这个函数期望我们<em class="mn">定义我们期望在模式匹配中看到新行</em>的地方。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="6b78" class="nk la it ng b gy nl nm l nn no">import re<br/>str = '''<br/>  From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>&gt;<br/>  Subject: The giberrish looking algorithm<br/>  To: Dr Watson &lt;<a class="ae ky" href="mailto:johnhwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">johnhwatson@mysteryemails.com</a>&gt;'''</span><span id="62ff" class="nk la it ng b gy np nm l nn no">lst = re.findall('From:.+<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>.+\n.*\n.*To:.+<a class="ae ky" href="mailto:johnhwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">johnhwatson@mysteryemails.com</a>', str,re.M)</span><span id="7c8a" class="nk la it ng b gy np nm l nn no">print(lst)</span></pre><p id="3ed8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这给了我们这个:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="a247" class="nk la it ng b gy nl nm l nn no">['From: Sherlock Holmes &lt;<a class="ae ky" href="mailto:sherlock@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">sherlock@mysteryemails.com</a>&gt;\n\t\tSubject: The giberrish looking algorithm\n\t\tTo: Dr Watson &lt;<a class="ae ky" href="mailto:johnhwatson@mysteryemails.com" rel="noopener ugc nofollow" target="_blank">johnhwatson@mysteryemails.com</a>']</span></pre><p id="3b57" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">注意，我们有时用<code class="fe nq nr ns ng b">.*</code>，其他时间用<code class="fe nq nr ns ng b">.+</code>。不同之处在于，<code class="fe nq nr ns ng b">.+</code>期望至少是一个字符，而<code class="fe nq nr ns ng b">.* </code>可以处理零个或多个字符。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e1f4" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">加快步伐</h1><p id="3467" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设您在一个输入字段上构建某种验证，用户可以在该字段中输入任何数字，后跟字母d、m或y。</p><p id="c074" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">您的正则表达式算法看起来会像这样:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="9d64" class="nk la it ng b gy nl nm l nn no">^[0-9]+[dmy]$</span></pre><p id="09b5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">分解上述内容:^表示比赛的开始，后面跟着一个0-9的数字。然而,+号意味着至少需要一个0-9的数字，尽管可以有更多。然后字符串后面需要跟d，m，或者y，因为$所以必须在最后。</p><p id="0cc3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在python中测试上述内容:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="0a5e" class="nk la it ng b gy nl nm l nn no">import re<br/>str = '1d'<br/>str2 = '200y'<br/>str3 = 'y200'<br/>lst = re.findall('^[0-9]+[dmy]$', str)<br/>lst2 = re.findall('^[0-9]+[dmy]$', str2)<br/>lst3 = re.findall('^[0-9]+[dmy]$', str3)<br/>print(lst)<br/>print(lst2)<br/>print(lst3)</span></pre><p id="332c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">返回以下内容:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="5491" class="nk la it ng b gy nl nm l nn no">['1d']<br/>['200y']<br/>[]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/329acad41d4e3d1033d49ebd96c577a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ebMaBjJ8oz9Csk5_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="69ba" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">转义特殊字符</h1><p id="f9a8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">说到正则表达式，某些字符是特殊的。例如，点、星和美元符号都用于匹配目的。如果你想匹配这些字符，会发生什么呢？</p><p id="9075" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在这种情况下，我们可以使用反斜杠:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e433" class="nk la it ng b gy nl nm l nn no">import re<br/>str = 'Sentences have dots. How do we escape them?'<br/>lst = re.findall('.', str)<br/>lst1 = re.findall('\.', str)<br/>print(lst)<br/>print(lst1)</span></pre><p id="7929" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">上面的例子是用点号和反斜杠点号。如您所料，它返回两个结果。第一个匹配所有字符，而第二个只匹配点。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="72d7" class="nk la it ng b gy nl nm l nn no">['S', 'e', 'n', 't', 'e', 'n', 'c', 'e', 's', ' ', 'h', 'a', 'v', 'e', ' ', 'd', 'o', 't', 's', '.', ' ', 'H', 'o', 'w', ' ', 'd', 'o', ' ', 'w', 'e', ' ', 'e', 's', 'c', 'a', 'p', 'e', ' ', 't', 'h', 'e', 'm', '?']<br/>['.']</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="b164" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">匹配精确的字符数</h1><p id="ea88" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设你想匹配一个日期。你知道格式会是什么:DD/MM/YYYY。有时会有2d或2Ms，有时只有一个，但总是4y。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="09bd" class="nk la it ng b gy nl nm l nn no">import re<br/>str = 'The date is 22/10/2018'<br/>str1 = 'The date is 3/1/2019'<br/>lst = re.findall('[0-9]{1,2}\/[0-9]{1,2}\/[0-9]{4}', str)<br/>lst = re.findall('[0-9]{1,2}\/[0-9]{1,2}\/[0-9]{4}', str1)</span><span id="2db7" class="nk la it ng b gy np nm l nn no">print(lst)<br/>print(lst1)</span></pre><p id="5d99" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这给出了以下结果:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="bea5" class="nk la it ng b gy nl nm l nn no">['22/10/2018']<br/>['3/1/2019']</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="b7f4" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">提取匹配的模式</h1><p id="903d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">仅仅知道你在匹配一个模式是不够的。你需要从比赛中提取信息的能力。</p><p id="503f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">例如，假设您正在扫描一个大型数据集，寻找电子邮件地址。如果你用我们学到的，你可以寻找一个模式:</p><ul class=""><li id="82fc" class="nu nv it lt b lu mo lx mp ma nw me nx mi ny mm nz oa ob oc bi translated">以字母、数字、点号或下划线开头</li><li id="c181" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">后跟至少另一个字母或数字</li><li id="0b5d" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">后面可以跟一个点或下划线</li><li id="bbb7" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">然后一个@</li><li id="20f9" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">然后再次遵循与@之前相同的逻辑</li><li id="5ddb" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">最后，寻找一个点后面跟着一个字母</li></ul><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="aea6" class="nk la it ng b gy nl nm l nn no">^[a-zA-Z0-9\.\_]*[a-zA-Z0-9]+[\.\_]*\@[a-zA-Z0-9\.\_]*[a-zA-Z0-9]+[\.\_]*\.[a-zA-z]+</span></pre><p id="1c9b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">从上面的匹配中，您只想提取域名，即@后面的所有内容。你所要做的就是在你要找的东西周围加上括号:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="33b8" class="nk la it ng b gy nl nm l nn no">import re<br/>str = '<a class="ae ky" href="mailto:email123_test@gmail.com" rel="noopener ugc nofollow" target="_blank">email123_test@gmail.com</a>'<br/>lst = re.findall('^[a-zA-Z0-9\.\_]*[a-zA-Z0-9]+[\.\_]*\@([a-zA-Z0-9\.\_]*[a-zA-Z0-9]+[\.\_]*\.[a-zA-z]+)', str)<br/>print(lst)</span></pre><p id="f450" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">返回:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e176" class="nk la it ng b gy nl nm l nn no">['gmail.com']</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="02a8" class="kz la it bd lb lc na le lf lg nb li lj jz nc ka ll kc nd kd ln kf ne kg lp lq bi translated">概括起来</h1><p id="1eb1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">总之，您可以使用正则表达式来匹配数据字符串，并且它可以以多种不同的方式使用。Python包含一个名为re的regex包，它允许您使用这个包。但是，如果您发现自己在Unix机器上，您可以将正则表达式与grep、awk或sed一起使用。在Windows上，如果您想访问所有这些命令，可以使用Cygwin之类的工具。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="dab7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">参考资料:</p><ul class=""><li id="b2b3" class="nu nv it lt b lu mo lx mp ma nw me nx mi ny mm nz oa ob oc bi translated"><a class="ae ky" href="https://www.py4e.com/lectures3/Pythonlearn-11-Regex-Handout.txt" rel="noopener ugc nofollow" target="_blank">https://www . py4e . com/lectures 3/python learn-11-Regex-讲义. txt </a></li><li id="a2b6" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated">【https://en.wikipedia.org/wiki/Regular_expression T2】号</li></ul></div></div>    
</body>
</html>