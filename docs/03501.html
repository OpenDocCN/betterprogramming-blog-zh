<html>
<head>
<title>A Look at Docker Compose’s Bootup Sequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看看Docker Compose的启动序列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-look-at-docker-composes-bootup-sequence-1f597049cc65?source=collection_archive---------12-----------------------#2020-02-13">https://betterprogramming.pub/a-look-at-docker-composes-bootup-sequence-1f597049cc65?source=collection_archive---------12-----------------------#2020-02-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="330c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何管理应用程序堆栈中对时间敏感的容器间依赖关系</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/da2db2db29a7f350e21e6e9af8eab0b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d3G6rLUT0zZp6DRa"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@dnevozhai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Denys Nevozhai </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="6bb1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">作为好的Docker公民，我们都通过分离关注的区域来创建容器:一个容器用于我们的后端，另一个用于我们的前端，第三个用于持久服务。</p><p id="85d5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，当后端容器启动并运行，而您却发现数据库容器仍在试图变得可用时，会发生什么呢？您的应用程序是无法启动，还是会一直重试，直到数据库服务可以访问？</p><p id="b438" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将回顾不同的选项，以确保容器不仅以预期的顺序启动，而且在另一个依赖容器启动并试图使用它们之前变得可访问。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4af2" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">在Docker编写中定义依赖关系</h1><p id="6fcf" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">从版本2开始，Docker Compose允许您使用<code class="fe na nb nc nd b">depends_on</code>键明确定义容器的相互依赖关系。通过在Docker Compose YAML文件的服务规范中添加一个<code class="fe na nb nc nd b">depends_on</code>键，您可以有效地告诉Docker Compose“Container FOO依赖于container BAR”这有多简单:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><p id="3217" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的YAML将让Docker Compose不仅知道如何以特定的顺序启动容器，还知道如何以完全相反的顺序关闭它们:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/622a7964b50cb68e38130a24927b0ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*VQ20RcxkvLWppepptnn1uQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Docker编写上下排序(图片由作者提供)。</p></figure><p id="44cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，那是小菜一碟！我们的容器完全按照我们希望的顺序启动，当我们的后端试图访问数据库时，它已经在那里了，准备好并监听请求…对吗？嗯，没那么快。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8125" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">开始的容器不是就绪的容器</h1><p id="2147" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">你看，一个容器被报告为<em class="nh"> started </em>的事实并不一定意味着它已经准备好提供它的服务。在容器内部运行的应用程序可能需要经历一个初始化阶段，在这个阶段完成之前，它可能不会响应。</p><p id="efe2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker Compose不知道在容器内部检查什么或者如何检查，以找出在容器内部运行的应用程序的实际状态。它所关心的是<code class="fe na nb nc nd b">CMD</code>或<code class="fe na nb nc nd b">ENTRYPOINT</code>被成功执行。让我们用下面的Docker合成文件样本做一个快速测试，看看这一点在实践中是如何实现的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><p id="9048" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们用<code class="fe na nb nc nd b">docker-compose up</code>来运行它:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ni"><img src="../Images/e1cb0e622acfe094eeb5817955735b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXFGfEnIfu2p_HJMUIHh5Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">“数据库”容器比需要访问它的“后端”容器晚26秒准备好接受请求。</p></figure><p id="4d55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您在上面看到的，尽管Docker Compose尊重我们的依赖定义，并在后端容器之前启动数据库容器，但后者需要更长的时间来准备接受请求。如果后端容器在前一个容器准备好之前的26秒内试图访问数据库，它就会失败。</p><p id="9f29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，需要一个更好的服务状态检查机制——这种机制要考虑到知道如何测试其状态的底层嵌入式服务的性质。接下来让我们看看如何实现它。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="1414" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">实施服务状态检查</h1><p id="ce1f" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">有几种不同的方法来检查容器中的底层服务是否准备好接受请求，而不管Docker本身对其托管容器报告了什么。让我们回顾一下我们的选择。</p><h2 id="7354" class="nj me iu bd mf nk nl dn mj nm nn dp mn lj no np mp ln nq nr mr lr ns nt mt nu bi translated">使用容器健康检查</h2><p id="8b4c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">虽然Docker health checks是一个非常有用的概念，但是你不能用它来让一个容器等待另一个容器。我只是在这里提到它，因为你可能会发现对它的在线参考，不幸的是对Docker Compose的现代版本不再有效。在Docker的GitHub repo上有一个关于这个主题的<a class="ae kz" href="https://github.com/moby/moby/issues/31333" rel="noopener ugc nofollow" target="_blank">长讨论</a>，以及为什么这个功能被移除(并且永远不会回来)。另一方面，如果你想实现健康检查来监控你的容器，我已经在之前的文章中写过了。</p><h2 id="dbbb" class="nj me iu bd mf nk nl dn mj nm nn dp mn lj no np mp ln nq nr mr lr ns nt mt nu bi translated">使用第三方工具和集成</h2><p id="e710" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">从Docker Compose的早期开始，人们就试图用定制的解决方案来解决容器相互依赖的问题。以下是三种最广泛使用的方法:</p><ol class=""><li id="e23c" class="nv nw iu lc b ld le lg lh lj nx ln ny lr nz lv oa ob oc od bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://github.com/vishnubob/wait-for-it" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">wait-for-it</strong></a></code> <strong class="lc iv"> <br/> </strong> wait-for-it.sh是一个纯粹的bash脚本，它将等待主机和TCP端口的可用性。这对于同步相互依赖的服务(如链接的Docker容器)的启动非常有用。因为它是一个纯bash脚本，所以它没有任何外部依赖性。</li><li id="8b5b" class="nv nw iu lc b ld oe lg of lj og ln oh lr oi lv oa ob oc od bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://github.com/jwilder/dockerize" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">dockerize</strong></a></code> <br/> dockerize是一个简化Docker容器中运行应用程序的实用程序。它允许您在容器启动时从模板和容器环境变量生成应用程序配置文件，将多个日志文件添加到<code class="fe na nb nc nd b">stdout</code>和/或<code class="fe na nb nc nd b">stderr</code>，或者使用TCP、HTTP(S)等待其他服务可用。</li><li id="990f" class="nv nw iu lc b ld oe lg of lj og ln oh lr oi lv oa ob oc od bi translated"><code class="fe na nb nc nd b"><a class="ae kz" href="https://github.com/vegardit/await.sh" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">await.sh</strong></a></code> <br/> await.sh是一个自包含的POSIX shell脚本，用于等待资源和服务的可用性。与<code class="fe na nb nc nd b">wait-for-it</code>类似，它具有最低的系统要求(POSIX shell、timeout、nc、wget ),可以与BusyBox以及Alpine Linux映像一起工作。</li></ol><p id="6dfc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从技术上讲，上面的工具都不需要修改容器的Docker映像才能工作。然而，它们需要——以某种方式——在容器内部可被访问以被执行。让我们尝试用dockerize包装我们的hello-world容器，然后用<code class="fe na nb nc nd b">docker build . -t hello-world-dockerize</code>重新构建它:</p><pre class="kk kl km kn gu oj nd ok ol aw om bi"><span id="f6c2" class="nj me iu nd b gz on oo l op oq">FROM hello-world</span><span id="83ab" class="nj me iu nd b gz or oo l op oq">FROM jwilder/dockerize<br/>COPY --from=0 hello /</span><span id="bf76" class="nj me iu nd b gz or oo l op oq">ENTRYPOINT dockerize -wait tcp://database:3306 -timeout 60s /hello</span></pre><p id="ebd2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，更新Docker合成文件以使用包装的图像:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><p id="1c0d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在是时候使用<code class="fe na nb nc nd b">docker-compose up</code>再次运行我们的演示应用堆栈了:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj os"><img src="../Images/a86a22153d3e0073b4fa07ead13bc657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPFHPusfMtmjpRl7FIPp8w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">让一个容器等待另一个容器(图片由作者提供)。</p></figure><p id="5f6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次，后端容器耐心地等待，直到数据库容器中运行的数据库服务可用。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fd95" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">容错简介</h1><p id="2c98" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在上面只涉及两个容器的场景中，手动定义它们之间的相互依赖关系并不是一件困难的任务。然而，在现实世界中，您的堆栈可能包含多个自治容器，手动处理相互依赖和正确的启动顺序可能会变得非常复杂。</p><p id="4f12" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，如果您在容器中引入运行状况检查(这是您应该做的),您可能很容易出现活锁的情况，在这种情况下，等待另一个容器变得可用的容器会由于运行状况检查超时而自行重置。</p><p id="0d47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这种情况下的设计范例是将容错引入到您的系统中。例如，后端容器不是因为数据库容器不可用而无法引导，而是可以继续引导，只是在建立对底层数据库的访问之前尝试处理请求时返回一个错误代码。后台进程可以检查数据库服务的可用性，并在准备就绪时透明地连接到数据库。</p><p id="a9ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">引入容错不仅解决了初始启动序列的问题，而且在您无法控制容器的位置或可用性的分布式环境中，它也是有帮助的，甚至是必要的。将您的应用程序设计为在底层资源不可用时正常降级，并在资源再次可用时自动切换到正常模式。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="9885" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="9a02" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">当您有一个由Docker容器组成的应用程序堆栈时，您可能会发现自己处于需要特定引导顺序的情况。为了实现这一点，您可以集成第三方解决方案，让一个容器等待另一个容器中服务的可用性。然而，如果可能的话，你应该在你的设计中引入容错，允许你的容器在资源变得不可用时优雅地降级。</p><p id="fd37" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您阅读这篇文章。希望下一部能见到你。</p></div></div>    
</body>
</html>