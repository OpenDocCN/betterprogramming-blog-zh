<html>
<head>
<title>3 Powerful Swift Tricks From WWDC 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自WWDC 2022的3个强有力的快速技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-powerful-swift-tricks-from-wwdc-2022-8369a9a141c6?source=collection_archive---------4-----------------------#2022-06-13">https://betterprogramming.pub/3-powerful-swift-tricks-from-wwdc-2022-8369a9a141c6?source=collection_archive---------4-----------------------#2022-06-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ab3d" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">最容易学的语言变得越来越容易</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/aba6c28d7905c243e377a12940c78912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7_VN_uEPlPFB835AuEUlg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1207886" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kz" href="https://pixabay.com/users/martinvorel_com-2835811/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1207886" rel="noopener ugc nofollow" target="_blank">马丁·沃雷尔</a></p></figure><p id="4de3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Swift 5.7中有很多新的技巧可以学习，但这些是我最喜欢的苹果2022年的WWDC。随着语言的不断发展，编写以前重复的代码变得越来越容易。处理可选和泛型总是很容易，但是现在变得更加容易了。</p><p id="a2aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看看这些简单的例子，你就会明白我的意思了。</p><h1 id="695d" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">使用“if let”而不重复可选的名称</h1><p id="b8cd" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">Swift 5.7之前的可选绑定采取的是<code class="fe mt mu mv mw b">if let myOptional = myOptional</code>的形式。虽然我想保留可选的名称，因为我将它作为一个常量绑定在闭包中，但是我仍然需要重复这个名称。在Swift 5.7中，仍然可以编写类似于<code class="fe mt mu mv mw b">if let myNewName = myOptional</code>的内容，但保留现有名称而不重复自己更容易。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="5245" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个视图有一个可选的<code class="fe mt mu mv mw b">@State</code>属性，名为<code class="fe mt mu mv mw b">displayedText</code>，我正在可选地将它与<code class="fe mt mu mv mw b">if let</code>绑定。当该值等于<code class="fe mt mu mv mw b">nil</code>时，以透明颜色的形式提供一个空白空间。这样即使没有设置值，在<code class="fe mt mu mv mw b">Form</code>中也会有一行。</p><p id="a378" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mt mu mv mw b">TextField</code>设置<code class="fe mt mu mv mw b">inputText</code>属性，<code class="fe mt mu mv mw b">Button</code>用这个值更新可选的<code class="fe mt mu mv mw b">displayText</code>。</p><h1 id="dcd0" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">对于符合具有关联类型的协议的任何类型，使用“any”关键字</h1><p id="d3d6" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们都非常熟悉<code class="fe mt mu mv mw b">any</code>关键字，但是它与<code class="fe mt mu mv mw b">some</code>关键字有什么不同呢？Swift 5.7中一个很大的不同是<code class="fe mt mu mv mw b">any</code>现在可以用于关联类型的协议，这在以前是不可能的。为了测试它的局限性，我创建了一个名为<code class="fe mt mu mv mw b">MyProtocol</code>的协议，它有一个关联的类型。</p><p id="3063" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我创建了两个几乎相同的类型:<code class="fe mt mu mv mw b">MyConformingType</code>和<code class="fe mt mu mv mw b">MyOtherConformingType</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="c79b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我有另一个名为<code class="fe mt mu mv mw b">MyType</code>的结构，它同时使用了<code class="fe mt mu mv mw b">any</code>和<code class="fe mt mu mv mw b">some</code>关键字来创建<code class="fe mt mu mv mw b">MyConformingType</code>的实例。在SwiftUI视图中显示了它们的类型，并且一个<code class="fe mt mu mv mw b">Button</code>提供了改变它们类型的能力。</p><p id="7705" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是两个关键字之间的区别变得明显的地方，因为不可能改变<code class="fe mt mu mv mw b">someExample</code>属性。</p><p id="aec1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您在这个函数中的一个断点处停下来，您可能会看到<code class="fe mt mu mv mw b">someExample</code>是MyProtocol类型。</p><p id="bf49" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们最终得到了一个抽象类型，它只具有协议所要求的属性。</p><p id="225d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我试着将<code class="fe mt mu mv mw b">someExample</code>设置为与<code class="fe mt mu mv mw b">MyConformingType</code>完全相同的实例，即使这样也不被认为是相同的类型！</p><h1 id="2505" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">使用时钟API来延迟代码的执行</h1><p id="a4ea" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">iOS 16中有一个新的API，可以更容易地处理和测量时间。</p><p id="44b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个简单的<code class="fe mt mu mv mw b">Form</code>，它使用两种时钟:一个<code class="fe mt mu mv mw b">SuspendingClock</code>，当应用程序进入后台时停止；一个<code class="fe mt mu mv mw b">ContinuousClock</code>，它...继续。每个时钟都有一个<code class="fe mt mu mv mw b">Stepper</code>用于选择您想要等待的时间，还有一个<code class="fe mt mu mv mw b">Button</code>用于启动等待。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mx my l"/></div></figure><p id="0bcf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于<code class="fe mt mu mv mw b">sleep</code>函数可以抛出，我将它包装在一个<code class="fe mt mu mv mw b">do-catch</code>中，它在一个<code class="fe mt mu mv mw b">Task</code>中，因为否则，闭包将是异步的，不适合作为<code class="fe mt mu mv mw b">Button</code>的动作。</p><pre class="kk kl km kn gu mz mw na nb aw nc bi"><span id="36b6" class="nd lx iu mw b gz ne nf l ng nh"><strong class="mw iv">Want Daily Coding Tips like these?</strong></span><span id="44ca" class="nd lx iu mw b gz ni nf l ng nh">These tips previously appeared in my newsletter <a class="ae kz" href="https://typesafely.substack.com/" rel="noopener ugc nofollow" target="_blank">Type Safely</a>.</span></pre></div></div>    
</body>
</html>