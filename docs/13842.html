<html>
<head>
<title>All the Ways To Introspect Python Objects at Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运行时自省Python对象的所有方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/all-the-ways-to-introspect-python-objects-at-runtime-80e6991b4cc6?source=collection_archive---------3-----------------------#2022-10-03">https://betterprogramming.pub/all-the-ways-to-introspect-python-objects-at-runtime-80e6991b4cc6?source=collection_archive---------3-----------------------#2022-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="226f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在运行时检查Python对象和获取代码信息的技巧和诀窍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3417822dd372a725c87b89ae7bed83be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVp3cIBHPb3t0r9erlhJkQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰西·卡森在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="9996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python提供了很多询问代码问题的方法。无论是像<code class="fe lv lw lx ly b">help()</code>函数这样的基本东西，像<code class="fe lv lw lx ly b">dir()</code>这样的内置函数，还是<code class="fe lv lw lx ly b">inspect</code>模块中更高级的方法——这些工具都可以帮助你找到问题的答案。</p><p id="9db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看Python能为我们解答哪些关于我们自己代码的问题，以及它如何在调试会话、处理类型注释、验证输入等过程中帮助我们。</p><h1 id="b363" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">内置的</h1><p id="6519" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如已经提到的Python中有几类自省工具/函数——让我们从最基本的一类开始，即内置函数。</p><p id="ef1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python包含了一组基本的<a class="ae ky" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">内置函数</a>，其中大部分我们已经知道了——比如<code class="fe lv lw lx ly b">len()</code>、<code class="fe lv lw lx ly b">range()</code>或者<code class="fe lv lw lx ly b">print()</code>。然而，有几个模糊的问题可以帮助我们回答一些关于我们代码的问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="356e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">locals()</code>、<code class="fe lv lw lx ly b">globals()</code>和<code class="fe lv lw lx ly b">hasattr()</code>，可以帮助我们找出局部/全局变量或类实例属性是否存在。</p><p id="a746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们还可以使用内置函数来检查变量是否是函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以做到这一点——最好的选择是使用<code class="fe lv lw lx ly b">callable()</code>,但是如果你运行的是Python 3.1，那么你必须使用<code class="fe lv lw lx ly b">hasattr</code>函数来检查<code class="fe lv lw lx ly b">__call__</code>属性的存在。最后一个选项是使用来自<code class="fe lv lw lx ly b">inspect</code>模块的<code class="fe lv lw lx ly b">isfunction()</code>，不过要小心，因为它会为内置函数返回<code class="fe lv lw lx ly b">False</code>，比如<code class="fe lv lw lx ly b">sum</code>、<code class="fe lv lw lx ly b">len</code>或<code class="fe lv lw lx ly b">range</code>，因为这些函数是用C实现的，所以它们不是Python函数。</p><p id="f9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想检查的另一件事是变量是一个列表(序列)还是一个标量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b9ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“显而易见”的解决方案是使用<code class="fe lv lw lx ly b">isinstance</code>来检查变量是否是抽象类<code class="fe lv lw lx ly b">Sequence</code>的实例。然而，这不适用于非内置类型，如NumPy数组。它还认为字符串是正确的序列，但可能并不理想。另一种方法是使用<code class="fe lv lw lx ly b">hasattr</code>来检查变量是否有<code class="fe lv lw lx ly b">__len__</code>属性，这将适用于NumPy数组，但对于字典也将返回<code class="fe lv lw lx ly b">True</code>。最后一个选项是将一组类型传递给<code class="fe lv lw lx ly b">isinstance</code>来定制您需要的行为。</p><p id="3706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了如何使用<code class="fe lv lw lx ly b">globals()</code>来检查变量是否存在，但是我们也可以使用它通过字符串调用函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">getattr(instance, "func_name")()</code>可以对对象(类)属性使用类似的策略。</p><p id="7c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个内置函数的例子使用了<code class="fe lv lw lx ly b">locals()</code>。假设你有一个函数，它有很多参数，这些参数都需要传递给另一个函数，你不想把它们都写出来。嗯，你可以简单地使用<code class="fe lv lw lx ly b">locals()</code>和<code class="fe lv lw lx ly b">**</code>(析构)操作符，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面应该给了你一个如何使用内置函数的好主意，然而这并不是一个详尽的列表。还有几个功能，如<code class="fe lv lw lx ly b">dir()</code>或<code class="fe lv lw lx ly b">vars()</code>，所以一定要查看<a class="ae ky" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">文档</a>以获得完整的图片。</p><h1 id="eb8c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">对象属性</h1><p id="2ec4" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果上面的内置没有给你所有的答案，那么我们可以挖得更深一点。Python中的每个对象都有一组非常广泛的属性，可以告诉我们关于特定对象的更多信息。</p><p id="201c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些基本上是用来构造<code class="fe lv lw lx ly b">help(object)</code>输出的值，所以您在<code class="fe lv lw lx ly b">help(object)</code>输出中发现的任何东西都可以从<code class="fe lv lw lx ly b">object</code>属性中提取。例如，您可以找到其对象的文档字符串(<code class="fe lv lw lx ly b">.__doc__</code>)、函数的源代码(<code class="fe lv lw lx ly b">.__code__</code>)或回溯/堆栈信息(例如<code class="fe lv lw lx ly b">.tb_frame</code>)。</p><p id="7bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管弄乱属性并不理想，但是有一种更好的方法。我们来看看<code class="fe lv lw lx ly b">inspect</code> modul。</p><h1 id="efb3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><code class="fe lv lw lx ly b">Inspect</code>模块</h1><p id="47ea" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">inspect</code>模块利用所有上述属性(和<a class="ae ky" href="https://docs.python.org/3/library/inspect.html#types-and-members" rel="noopener ugc nofollow" target="_blank">更多的</a>)来允许我们更有效地自省我们的代码。</p><p id="db66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经使用了内置的<code class="fe lv lw lx ly b">dir()</code>方法来获取对象的所有属性。<code class="fe lv lw lx ly b">inspect</code>模块有一个类似的叫<code class="fe lv lw lx ly b">getmembers()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bc60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">inspect.getmembers()</code>的优点是提供了第二个参数，可以用来过滤属性。这里我们用它分别过滤掉变量属性和函数。</p><p id="3ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">inspect</code>模块的另一个很好的用例是调试。例如，您可以使用它来调试发电机的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="52b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们通过将<code class="fe lv lw lx ly b">yield</code>放入函数体来定义一个虚拟生成器。然后我们可以使用<code class="fe lv lw lx ly b">isgeneratorfunction()</code>测试它是否真的是一个生成器。我们还可以使用<code class="fe lv lw lx ly b">getgeneratorstate()</code>来检查它的状态，它将返回<code class="fe lv lw lx ly b">GEN_CREATED</code>(尚未执行)、<code class="fe lv lw lx ly b">GEN_RUNNING</code>、<code class="fe lv lw lx ly b">GEN_SUSPENDED</code>(等待<code class="fe lv lw lx ly b">yield</code>)或<code class="fe lv lw lx ly b">GEN_CLOSED</code>(已消耗)中的一个。</p><p id="5b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">inspect.signature</code>的帮助下，你还可以调试与函数签名相关的东西，比如可变的默认参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4beb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，你<a class="ae ky" href="https://docs.python-guide.org/writing/gotchas/" rel="noopener ugc nofollow" target="_blank">不应该为参数默认值</a>使用可变类型，比如<code class="fe lv lw lx ly b">list</code>，因为它们会在每次函数执行期间被修改(变异)。用<code class="fe lv lw lx ly b">inspect.signature()</code>检查函数签名在这里就很清楚了。</p><p id="58f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于参数默认值，我们也可以使用<code class="fe lv lw lx ly b">signature()</code>函数来读取它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="538b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想将一个函数的默认值传递给另一个函数，这可能会很有帮助。上面的例子表明，您可以遍历所有的参数并挑选出具有非空默认值的参数，或者如果您知道参数名，那么您可以直接查询它。</p><p id="2d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">signature()</code>函数的一些更高级的用法包括使用装饰器向函数注入额外的参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段定义了一个名为<code class="fe lv lw lx ly b">optional_debug</code>的装饰器，它在应用于函数时注入<code class="fe lv lw lx ly b">debug</code>参数。它首先检查函数签名并检查是否存在<code class="fe lv lw lx ly b">debug</code>参数。如果不存在，它就用一个新的函数签名替换原来的函数签名，并附加一个仅包含关键字的参数。</p><p id="f94f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设你有一个函数，它只声明了参数<code class="fe lv lw lx ly b">*args</code>和<code class="fe lv lw lx ly b">**kwargs</code>。这使得该函数非常“通用”，但是使得参数检查相当混乱。我们可以用<code class="fe lv lw lx ly b">inspect</code>模块中的<code class="fe lv lw lx ly b">Signature</code>和<code class="fe lv lw lx ly b">Parameter</code>类来解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="da23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用<code class="fe lv lw lx ly b">Parameter</code>类定义期望的参数(<code class="fe lv lw lx ly b">params</code>)，指定它们的类型和默认值，之后我们从它们创建签名。在“通用”函数中，我们使用签名的<code class="fe lv lw lx ly b">bind</code>方法将提供的<code class="fe lv lw lx ly b">*args</code>和<code class="fe lv lw lx ly b">**kwargs</code>绑定到准备好的签名。如果参数不满足签名，我们会收到一个异常。如果一切正常，我们可以使用<code class="fe lv lw lx ly b">bind</code>方法的返回值访问绑定参数。</p><p id="ce77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的方法适用于验证基本函数中的参数，但是如果我们想验证生成器从修饰函数中获得了所有必要的参数，该怎么办呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="195a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段显示了一个认证装饰器的实现，它期望将<code class="fe lv lw lx ly b">username</code>参数传递给被装饰的函数。为了验证参数是否存在，我们使用了<code class="fe lv lw lx ly b">Signature</code>类的<code class="fe lv lw lx ly b">from_callable()</code>方法，该方法从函数中提取所提供的参数。然后，在执行任何实际逻辑之前，我们检查<code class="fe lv lw lx ly b">username</code>是否在返回的元组中。</p><p id="761a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe lv lw lx ly b">inspect.signature</code>继续，您也可以使用<code class="fe lv lw lx ly b">inspect</code>模块来自省您的源代码文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们简单地使用<code class="fe lv lw lx ly b">getfile</code>查找<code class="fe lv lw lx ly b">some_func</code>函数的位置(文件)。这同样适用于内置函数/对象，如上面的<code class="fe lv lw lx ly b">datetime.date</code>所示。</p><p id="5564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">inspect</code>模块还包含了用于回溯的助手。例如，您可以使用它来查找当前正在执行的源文件和行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d69e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以做到这一点，最直接的方法是使用<code class="fe lv lw lx ly b">getframeinfo(currentframe())</code>，但是你也可以通过<code class="fe lv lw lx ly b">stack()</code>函数访问堆栈帧。在这种情况下，您必须在堆栈中进行索引，以找到正确的帧。</p><p id="87d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是直接使用<code class="fe lv lw lx ly b">currentframe()</code>，在这种情况下，您将不得不访问<code class="fe lv lw lx ly b">f_back</code>和<code class="fe lv lw lx ly b">f_lineno</code>来分别找到正确的框架和线。</p><p id="296f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用回溯助手可以做的下一件事是访问调用者对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="43b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们使用<code class="fe lv lw lx ly b">inspect.currentframe().f_back.f_locals['self']</code>来访问“父”对象。这只应该用于调试——如果你需要访问调用者对象，你应该把它作为一个参数传递给函数，而不是遍历堆栈。</p><p id="24cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，如果你在代码中使用类型提示，那么你可能熟悉<code class="fe lv lw lx ly b">typing.get_type_hints</code>，它可以帮助你检查类型提示。然而这个函数通常会抛出<code class="fe lv lw lx ly b">NameError</code>(特别是在类上调用的时候)，所以如果你在Python 3.10上，你可能应该切换到使用<code class="fe lv lw lx ly b">inspect.get_annotations</code>，它会为你处理很多边缘情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="81ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关在Python 3.10及更高版本中访问注释的更多细节，请参见<a class="ae ky" href="https://docs.python.org/3.10/howto/annotations.html#annotations-howto" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="1402" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结束语</h1><p id="a63f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正如我们已经看到的，有足够多的工具来自省和询问您的Python代码。其中一些非常晦涩，您可能永远不需要使用它们，但是知道它们的存在是有好处的，尤其是那些可用于调试的。</p><p id="1751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果以上还不够，或者您只是想更深入一点，那么您可能想看看<code class="fe lv lw lx ly b">ast</code>，它可以用来遍历和检查语法树，甚至是用于反汇编Python字节码的<code class="fe lv lw lx ly b">dis</code>模块。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nf"><a rel="noopener  ugc nofollow" target="_blank" href="/should-you-be-using-pythons-walrus-operator-yes-and-here-s-why-36297be16907"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">你应该使用Python的Walrus操作符吗？(是的。原因如下)</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Python有争议的赋值表达式——也称为walrus运算符——可以改进您的代码，现在是您…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">better编程. pub</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><div class="nu nv gp gr nw nf"><a rel="noopener  ugc nofollow" target="_blank" href="/python-list-comprehensions-are-more-powerful-than-you-might-think-3363a90e5bb0"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">Python列表理解比你想象的更强大</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">借助这些未知的功能和技巧，写出更好的列表理解</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">better编程. pub</p></div></div><div class="no l"><div class="nx l nq nr ns no nt ks nf"/></div></div></a></div><pre class="kj kk kl km gt ny ly nz oa aw ob bi"><span id="617b" class="oc ma it ly b gy od oe l of og"><strong class="ly iu">Want to Connect?</strong></span><span id="4fc9" class="oc ma it ly b gy oh oe l of og">This article was originally posted at <a class="ae ky" href="https://martinheinz.dev/blog/82" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a></span></pre></div></div>    
</body>
</html>