<html>
<head>
<title>Multi-select Filter in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的多选过滤器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/multi-select-filter-in-swift-part-1-5f4da79989b9?source=collection_archive---------1-----------------------#2022-12-29">https://betterprogramming.pub/multi-select-filter-in-swift-part-1-5f4da79989b9?source=collection_archive---------1-----------------------#2022-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="afa0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用设计模式实现过滤逻辑</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/02c025e448ce0b73b6b27ce6f55d8a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIe-Pmg-vusOHTc7iEt4bw.png"/></div></div></figure><p id="ed8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将学习如何使用两种设计模式来实现多选过滤器:策略和装饰。</p><p id="1251" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本教程将分为两个部分:</p><ol class=""><li id="0ad9" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">在第一部分中，我们将重点关注过滤逻辑的实现。</li><li id="e217" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">在第二部分中，我们将讨论UI(即将推出)。</li></ol><p id="29ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们开始吧！</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="601d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">前言</h1><p id="c7e4" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">想象一下，我们正在为一家在线智能手机零售商开发一款应用，我们的产品负责人想出了在目录中过滤智能手机的主意。</p><p id="9d5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们应该创建一个健壮的、可扩展的解决方案。这意味着，如果我们要在过滤器中增加一个选项，这不会有一点麻烦。</p><p id="43e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除此之外，过滤器必须是多选过滤器，假设用户可以同时选择几个选项。</p><p id="cd80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到这些要求，我们开始制定解决方案。</p><h1 id="22cf" class="mi mj iq bd mk ml nf mn mo mp ng mr ms jw nh jx mu jz ni ka mw kc nj kd my mz bi translated">模型</h1><p id="9058" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">首先，我们从定义一个<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Model/Phone.swift?plain=1#L10" rel="noopener ugc nofollow" target="_blank">手机</a>型号开始:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="0308" class="nq mj iq nm b be nr ns l nt nu">struct Phone {<br/>    let model: String<br/>    let price: Int<br/>    let screenSize: Double<br/>    let processor: String<br/>    let memory: Int<br/>    let diskSpace: Int<br/>    let color: String<br/>}</span></pre><p id="2002" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，我们应该确定一个<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Model/Specification.swift?plain=1#L10" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="nv">规格</em> </strong> </a>型号，该型号将用于过滤具体的智能手机规格:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="1ea2" class="nq mj iq nm b be nr ns l nt nu">enum Specification {<br/>    case model(String)<br/>    case price(Int)<br/>    case screenSize(Double)<br/>    case processor(String)<br/>    case memory(Int)<br/>    case diskSpace(Int)<br/>    case color(String)<br/>}</span></pre><p id="2d79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个枚举案例都包含相关联的值，该值表示具体规范的底层类型。</p><p id="9577" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然模型都设置好了，我们就可以开始实现过滤功能了。</p><h1 id="371a" class="mi mj iq bd mk ml nf mn mo mp ng mr ms jw nh jx mu jz ni ka mw kc nj kd my mz bi translated">过滤策略</h1><p id="9456" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">我们首先创建一个上下文类和一些符合<a class="ae nk" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank">策略设计模式</a>的类，它们负责分别过滤每个智能手机规范。</p><blockquote class="nw nx ny"><p id="b2a6" class="kr ks nv kt b ku kv jr kw kx ky ju kz nz lb lc ld oa lf lg lh ob lj lk ll lm ij bi translated"><strong class="kt ir">策略</strong> —一种行为设计模式，定义了一系列相似的算法，并将每个算法放在自己的类中，之后算法可以在运行时互换。</p><p id="9e9f" class="kr ks nv kt b ku kv jr kw kx ky ju kz nz lb lc ld oa lf lg lh ob lj lk ll lm ij bi translated"><strong class="kt ir">来源:</strong>设计模式:深入研究设计模式</p></blockquote><p id="5f1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们应该概述一个每个具体滤波器都要遵守的<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Filter/FilterStrategy.swift?plain=1#L27" rel="noopener ugc nofollow" target="_blank">协议</a>:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="7f6d" class="nq mj iq nm b be nr ns l nt nu">protocol FilterStrategy {<br/>    func filter(phones: [Phone], by specs: [Specification]) -&gt; [Phone]<br/>}</span></pre><p id="c56d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它将只包含一个方法，该方法有两个输入参数:</p><p id="074f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➊手机-要过滤的手机阵列。</p><p id="e0f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➋规格—过滤将基于的规格数组。</p><p id="c723" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成之后，我们继续实现一个负责管理具体过滤器的<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Filter/FilterStrategy.swift?plain=1#L10" rel="noopener ugc nofollow" target="_blank">过滤器上下文类</a>:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="05ad" class="nq mj iq nm b be nr ns l nt nu">final class Filter {<br/>    private var strategy: FilterStrategy // 1<br/>    <br/>    init(strategy: FilterStrategy) {<br/>        self.strategy = strategy<br/>    }<br/>    <br/>    func update(strategy: FilterStrategy) { // 2<br/>        self.strategy = strategy<br/>    }<br/>    <br/>    func applyFilter(to phones: [Phone], withSpecs specs: [Specification]) -&gt; [Phone] {<br/>        return strategy.filter(phones: phones, by: specs) // 3<br/>    }<br/>}</span></pre><p id="a161" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正是这个类能够在运行时交换策略。</p><p id="2e36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➊它保持对当前过滤器的引用。</p><p id="5a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➋的<strong class="kt ir"> <em class="nv">更新</em> </strong>功能反过来用于将当前策略改变为新策略。</p><p id="ea5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➌，然后我们可以通过协议中定义的接口与当前过滤器进行交互。</p><p id="3449" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置好上下文之后，我们最后继续创建具体的过滤器。</p><blockquote class="nw nx ny"><p id="64fc" class="kr ks nv kt b ku kv jr kw kx ky ju kz nz lb lc ld oa lf lg lh ob lj lk ll lm ij bi translated"><strong class="kt ir">注意<br/> </strong>我们将只研究一个具体的滤波器，因为所有滤波器的实现细节都是相同的。过滤器的完整列表可以在<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/main/MultiselectFilter/Filter/FilterStrategy.swift" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><p id="20e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Filter/FilterStrategy.swift?plain=1#L42" rel="noopener ugc nofollow" target="_blank">价格过滤器</a>的实现:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="e303" class="nq mj iq nm b be nr ns l nt nu">final class PriceFilter: FilterStrategy {<br/>    func filter(phones: [Phone], by specs: [Specification]) -&gt; [Phone] {<br/>        let priceSpecs = Set(specs.compactMap { (spec) -&gt; Int? in // 1<br/>            if case let .price(price) = spec { return price }; return nil // 2<br/>        })<br/>        return phones.filter { priceSpecs.contains($0.price) } // 3<br/>    }<br/>}</span></pre><p id="a233" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➊:我们使用<code class="fe oc od oe nm b">compactMap</code>是为了只收集价格参数，用于以后的过滤，并确保我们有任何价格参数。为了实现快速查找，我们将数组包装在Set中。</p><p id="aebf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➋ <strong class="kt ir"> <em class="nv"> if case let </em> </strong>语法只允许我们解开一个特定的enum case关联值。更多信息请点击查看<a class="ae nk" href="https://useyourloaf.com/blog/swift-if-case-let/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="36b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➌:最后，我们对电话收集应用一个过滤器并返回结果。</p><p id="c5de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成过滤器的实现后，我们继续创建过滤器装饰器。</p><h1 id="639f" class="mi mj iq bd mk ml nf mn mo mp ng mr ms jw nh jx mu jz ni ka mw kc nj kd my mz bi translated">过滤器装饰工</h1><p id="d18d" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">为了能够一次使用几个过滤器，我们应该创建一个与<a class="ae nk" href="https://refactoring.guru/design-patterns/decorator" rel="noopener ugc nofollow" target="_blank">装饰设计模式</a>一致的类。</p><blockquote class="nw nx ny"><p id="70a7" class="kr ks nv kt b ku kv jr kw kx ky ju kz nz lb lc ld oa lf lg lh ob lj lk ll lm ij bi translated">装饰器(Decorator)——一种结构设计模式，允许你通过将对象包装在有用的“包装器”中，动态地给对象添加新功能。</p><p id="bc83" class="kr ks nv kt b ku kv jr kw kx ky ju kz nz lb lc ld oa lf lg lh ob lj lk ll lm ij bi translated">设计模式:深入研究设计模式</p></blockquote><p id="a6a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们定义一个每个装饰者都要遵守的<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Filter/FilterDecorator.swift?plain=1#L10" rel="noopener ugc nofollow" target="_blank">协议</a>:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="36e5" class="nq mj iq nm b be nr ns l nt nu">protocol PhoneFilter {<br/>    func filter(phones: [Phone], by specs: [Specification]) -&gt; [Phone]<br/>}</span></pre><p id="09bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它有一个方法和与<code class="fe oc od oe nm b">FilterStrategy</code>方法相同的方法签名。</p><p id="813c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们创建一个符合<code class="fe oc od oe nm b">PhoneFilter</code>协议的<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Filter/FilterDecorator.swift?plain=1#L22" rel="noopener ugc nofollow" target="_blank">基类</a>:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="c755" class="nq mj iq nm b be nr ns l nt nu">class PhoneFilterDecorator: PhoneFilter {<br/>    private let phoneFilter: PhoneFilter // 1<br/>    <br/>    init(phoneFilter: PhoneFilter) {<br/>        self.phoneFilter = phoneFilter<br/>    }<br/>    <br/>    func filter(phones: [Phone], by specs: [Specification]) -&gt; [Phone] { // 2<br/>        return phoneFilter.filter(phones: phones, by: specs)<br/>    }<br/>}</span></pre><p id="c813" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的主要任务是为每个具体的装饰器指定包装接口。</p><ul class=""><li id="da7e" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm of lt lu lv bi translated">该类将符合<code class="fe oc od oe nm b">PhoneFilter</code>协议的包装对象保存在<code class="fe oc od oe nm b">phoneFilter</code>常量中。</li><li id="d12c" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm of lt lu lv bi translated"><code class="fe oc od oe nm b">filter</code>函数将被子类覆盖，以提供定制的过滤逻辑。</li></ul><p id="7d9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们创建一个<code class="fe oc od oe nm b"><a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Filter/FilterDecorator.swift?plain=1#L15" rel="noopener ugc nofollow" target="_blank">PhoneBaseFilter</a></code>类，它将扮演占位符过滤器的角色:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="2e16" class="nq mj iq nm b be nr ns l nt nu">class PhoneBaseFilter: PhoneFilter {<br/>    func filter(phones: [Phone], by specs: [Specification]) -&gt; [Phone] {<br/>        return phones<br/>    }<br/>}</span></pre><p id="3102" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使这个类符合<code class="fe oc od oe nm b">PhoneFilter</code>协议，作为返回值，我们提供了传递给函数的相同的电话数组。</p><p id="3d74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<code class="fe oc od oe nm b">PhoneBaseFilter</code>类作为默认过滤器。</p><p id="1a17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与strategy类似，我们将只深入一个decorator类的实现细节。</p><p id="18b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回顾一下<code class="fe oc od oe nm b"><a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Filter/FilterDecorator.swift?plain=1#L45" rel="noopener ugc nofollow" target="_blank">PhonePriceFilter</a></code>类:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="e333" class="nq mj iq nm b be nr ns l nt nu">final class PhonePriceFilter: PhoneFilterDecorator { // 1<br/>    override func filter(phones: [Phone], by specs: [Specification]) -&gt; [Phone] { // 2<br/>        let filter = Filter(strategy: PriceFilter()) // 3<br/>        let appliedFilterResult = super.filter(phones: phones, by: specs) // 4<br/>        let filteredPhones = filter.applyFilter(to: appliedFilterResult, withSpecs: specs) // 5<br/>        return filteredPhones<br/>    }<br/>}</span></pre><p id="fde8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➊它是从基础装饰者那里继承来的— <code class="fe oc od oe nm b">PhoneFilterDecorator</code> <em class="nv">。</em></p><p id="55f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➋它覆盖了过滤方法。</p><p id="b278" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➌过滤逻辑由过滤策略提供。</p><p id="1614" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➍我们通过调用超级过滤方法将过滤后的电话数组设置为常量<code class="fe oc od oe nm b">appliedFilterResult</code> <strong class="kt ir"> <em class="nv"> </em> </strong>。</p><p id="a358" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">意思是如果我们把<strong class="kt ir"> <em class="nv">，</em> </strong>比如说<code class="fe oc od oe nm b">PhoneDiskSpaceFilter</code> <strong class="kt ir"> <em class="nv"> </em> </strong>传递给<code class="fe oc od oe nm b">PhonePriceFilter</code> <strong class="kt ir"> <em class="nv"> </em> </strong>初始化器，那么提供的初始手机数组会先用磁盘空间条件过滤，只有这样结果才会传递给<code class="fe oc od oe nm b">PhonePriceFilter</code> <strong class="kt ir"> <em class="nv"> </em> </strong>进一步过滤<em class="nv">。</em></p><p id="a298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">➎我们使用当前过滤器(PriceFilter)来过滤前一个过滤器(例如DiskSpaceFilter)的结果，它保存在<code class="fe oc od oe nm b">appliedFilterResult</code> <strong class="kt ir"> <em class="nv"> </em> </strong>常量中，因此我们将<code class="fe oc od oe nm b">appliedFilterResult</code>传递给<code class="fe oc od oe nm b">applyFilter</code>方法。</p><p id="f623" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">装饰器部分到此为止，让我们继续看用法示例。</p><h1 id="e3bd" class="mi mj iq bd mk ml nf mn mo mp ng mr ms jw nh jx mu jz ni ka mw kc nj kd my mz bi translated">使用</h1><p id="b3ff" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">我们首先创建一个<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Modules/Main/DataSource/MainDataSource.swift?plain=1#L13" rel="noopener ugc nofollow" target="_blank">模拟数据</a>，用于过滤:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="18cc" class="nq mj iq nm b be nr ns l nt nu">var phones = [<br/>    Phone(<br/>        model: "iPhone 14",<br/>        price: 799,<br/>        screenSize: 6.1,<br/>        processor: "Apple A15 Bionic",<br/>        memory: 6,<br/>        diskSpace: 128,<br/>        color: "Midnight"<br/>    ),<br/>    Phone(<br/>        model: "iPhone 14 Plus",<br/>        price: 899,<br/>        screenSize: 6.7,<br/>        processor: "Apple A15 Bionic",<br/>        memory: 6,<br/>        diskSpace: 256,<br/>        color: "Starlight"<br/>    )<br/>    ...<br/>]</span></pre><p id="7a20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成之后，我们现在就可以开始使用过滤器了。</p><p id="f625" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建一个<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Modules/Main/View/MainViewController.swift?plain=1#L14" rel="noopener ugc nofollow" target="_blank">规格数组</a>:</p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="8c1e" class="nq mj iq nm b be nr ns l nt nu">private let specifications: [Specification] = [<br/>    .diskSpace(256),<br/>    .diskSpace(512),<br/>    .color("Starlight"),<br/>    .color("Space Black"),<br/>    .price(1299)<br/>]</span></pre><p id="4924" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当用户选择UI中的选项时，将填充这个数组。</p><p id="16d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在唯一剩下的事情就是按照期望的顺序创建一个装饰链。</p><p id="183f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们创建了一个由三个装饰者组成的<a class="ae nk" href="https://github.com/creimbord/multiselect-filter/blob/cf62d7521421bb392de4f8a4a538681d69a5554a/MultiselectFilter/Modules/Main/View/MainViewController.swift?plain=1#L46" rel="noopener ugc nofollow" target="_blank">链:</a></p><pre class="kg kh ki kj gt nl nm nn bn no np bi"><span id="3641" class="nq mj iq nm b be nr ns l nt nu">override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>    <br/>    let phoneColorFilter = PhoneColorFilter(phoneFilter: PhoneBaseFilter()) // 1<br/>    let phoneDiskSpaceFilter = PhoneDiskSpaceFilter(phoneFilter: phoneColorFilter) // 2<br/>    let phonePriceFilter = PhonePriceFilter(phoneFilter: phoneDiskSpaceFilter) // 3<br/>    <br/>    dataSource.phones = phonePriceFilter.filter(<br/>        phones: dataSource.phones,<br/>        by: specifications<br/>    )<br/>    <br/>    tableView.reloadData()<br/>}</span></pre><p id="3c54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意每个装饰器是如何插入另一个的。这就是装饰模式的强大之处。</p><ul class=""><li id="2113" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm of lt lu lv bi translated">滤色器将产生以下结果:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/643013ebbe69434608d1b58a4ff2ac29.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*L3JGWzfo524KctjwmE8RMw.png"/></div></figure><ul class=""><li id="f8c3" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm of lt lu lv bi translated">然后它将被传递给磁盘空间过滤器，结果将是:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1caff61508c920162de717f35ce0b6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*VzYRyoYlVQz1rP7Qnk2lWA.png"/></div></figure><ul class=""><li id="c49e" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm of lt lu lv bi translated">最后，上一步的结果将被传递给价格过滤器，最终输出将是:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/0aae4efeebb0c50a2d99a802a9e50f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*ZWmZtRsrFBeTOoKv-HhoTw.png"/></div></figure><h1 id="8540" class="mi mj iq bd mk ml nf mn mo mp ng mr ms jw nh jx mu jz ni ka mw kc nj kd my mz bi translated">结论</h1><p id="119e" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">使用设计模式可以让我们创建一个灵活的解决方案，在不破坏现有过滤选项的情况下，更容易添加新的过滤选项。</p><p id="ab2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！如果您喜欢本教程，请鼓掌，请继续关注第二部分，我们将学习如何将过滤逻辑附加到UI上。</p><h1 id="e9cd" class="mi mj iq bd mk ml nf mn mo mp ng mr ms jw nh jx mu jz ni ka mw kc nj kd my mz bi translated">源代码</h1><p id="4876" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">这个项目的源代码可以在我的GitHub资源库中找到:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/creimbord/multiselect-filter" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">GitHub-creim bord/multiselect-filter:多选过滤器应用程序</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kp ok"/></div></div></a></div></div></div>    
</body>
</html>