<html>
<head>
<title>5 Basic Programming Concepts for JavaScript Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript开发人员的5个基本编程概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-javascript-concepts-you-should-know-460be406711e?source=collection_archive---------1-----------------------#2022-12-17">https://betterprogramming.pub/advanced-javascript-concepts-you-should-know-460be406711e?source=collection_archive---------1-----------------------#2022-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="84b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对核心编程概念的深入理解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/173a4ab2f69fb976b1a32ac833f9af69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UtCanQiEzCNqUAHr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nadineshaabana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">纳丁·沙巴纳</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="84ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是一种弱类型编程语言，这意味着它不强制变量的数据类型。当某些变量被转换为不同的数据类型时，强类型语言会在编译时抛出错误，而JavaScript通常不会，有时甚至会在后台执行类型转换，这可能会导致错误和无法预见的问题。TypeScript解决了这个问题，但是对于用JavaScript开发的人来说，这篇文章是了解如何避免弱类型语言的陷阱的好地方。</p><p id="dffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将涵盖JavaScript中的五个概念:运算符优先级、结合性、短路、原语和(隐式)类型转换。</p><p id="a9a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些概念中有许多是与语言无关的，唯一的变化是每种编程语言的规则可能不同。无论你是一个经验丰富的开发人员还是刚刚起步，你一定会学到一些新的东西！</p><h1 id="0157" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运算符、优先级和结合性</h1><p id="22ac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">运算符是编程语言中的保留符号，用于对变量和值(称为操作数)执行数学计算、赋值、比较和逻辑运算。有:</p><ul class=""><li id="740d" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><em class="my">非元</em>运算符——作用于一个操作数(即<code class="fe mz na nb nc b">! </code>非运算符)</li><li id="b5a7" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><em class="my">二元</em>运算符——作用于两个操作数(即<code class="fe mz na nb nc b">%</code>模数运算符)</li><li id="7a8a" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><em class="my">三进制</em>运算符——作用于三个操作数(即<code class="fe mz na nb nc b">?</code>三进制运算符)</li><li id="217b" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><em class="my">n</em>-数组运算符——作用于<em class="my"> n </em>个操作数(即<code class="fe mz na nb nc b">()</code>函数调用运算符)</li></ul><p id="6024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">绝大多数操作符要么是二元的，要么是一元的(有时，根据上下文，一个符号可能既是二元的也是一元的)。</p><h2 id="9be3" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">运算符执行的顺序</h2><p id="ba84" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">优先级是指运算符执行的顺序。优先值较大的运算符在优先值较低的运算符之前执行。没有先例，像<code class="fe mz na nb nc b">3 + 4 * 5</code>这样的表达会产生意想不到的结果和混乱。</p><p id="9d11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Mozilla的JS <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table" rel="noopener ugc nofollow" target="_blank">运算符优先级</a>表的一个片段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/1b2f56e7697de274d6c1bdc3e54773ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wv5pMxug8jidi-6lzhjhWA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列(从左到右):优先级、运算符—来源<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table" rel="noopener ugc nofollow" target="_blank"> [2] </a></p></figure><p id="5700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定表达式<code class="fe mz na nb nc b">3 + 4 * 5</code>，由于乘法运算符的优先级高于加法运算符，因此首先执行乘法运算，然后将3与该结果相加，得到最终结果23。</p><p id="0bdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以基本上<code class="fe mz na nb nc b">3+4*5</code>变成了<code class="fe mz na nb nc b">3 + (4*5)</code></p><p id="aef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定<code class="fe mz na nb nc b">**</code>优先13，<code class="fe mz na nb nc b">*</code>优先12，<code class="fe mz na nb nc b">+</code>优先11，你能解出<code class="fe mz na nb nc b">3 + 4 ** 2 * 5</code>吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/8b2fe1802e6e6960c0985f75389c1263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlcCNpbr7QlOX4ZULLFIjw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NodeJS优先级示例</p></figure><h2 id="e93d" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">如果优先级相同呢？</h2><p id="9fff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">关联性决定了操作的执行顺序。当在一个表达式中使用多个优先级相同的操作时，了解这一点非常有用。在之前的图像中，我们看到操作符<code class="fe mz na nb nc b">+</code>和<code class="fe mz na nb nc b">-</code>具有相同的优先级。</p><p id="8178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑一下<code class="fe mz na nb nc b">1 + 2 - 3 + 4</code>的表达方式:</p><p id="e7b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mz na nb nc b">*</code>和<code class="fe mz na nb nc b">-</code>操作符具有从左到右的结合性，那么表达式计算为<code class="fe mz na nb nc b">(1 + 2) -3) + 4</code>，其计算结果为0 + 4或4。</p><p id="928e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mz na nb nc b">+</code>和<code class="fe mz na nb nc b">-</code>操作符具有从右向左的结合性，那么表达式计算为<code class="fe mz na nb nc b">1 + (2 -(3 + 4)</code>，其计算结果为1 - 5或-4。</p><p id="b153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者考虑表达式<code class="fe mz na nb nc b">3 ** 3 ** 3</code>，其中<code class="fe mz na nb nc b">**</code>是取幂:</p><p id="db4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mz na nb nc b">**</code>有从左到右的关联性，那么我们有<code class="fe mz na nb nc b">(3**3)**3</code>就是19683。</p><p id="bca0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是对于从右到左的结合性，我们有<code class="fe mz na nb nc b">3**(3**3)</code>给出7625597484987。</p><p id="c308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，结合性在决定预期的结果方面起着至关重要的作用！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/af90d1840b6203530e0e3f94530593ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUqeWi14qOP33IaZFYw-Rg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列(从左到右):优先级、运算符、结合性、运算符表达式—来源<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table" rel="noopener ugc nofollow" target="_blank">【2】</a></p></figure><p id="7eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，虽然大多数算术运算符具有左结合性，但取幂运算符是右结合的</p><p id="9e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考上表，我们现在可以在Node中检查先前的结果</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/3b8c79778f13e40c98befa4c5be8d6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbUKdstlA2MDKt7aidtXrQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NodeJS关联性示例</p></figure><p id="6dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">赋值运算符是另一种右关联运算符</p><p id="4743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此<code class="fe mz na nb nc b">a=b=c</code>翻译成<code class="fe mz na nb nc b">a=(b=c)</code>，而<code class="fe mz na nb nc b">a=b+=c</code>翻译成<code class="fe mz na nb nc b">a=(b+=c)</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/cbd05585343645213d61c28e78b5b036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAyo1sh-UaYosfM3IZJkqw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NodeJS赋值运算符优先级/结合性—来源<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table" rel="noopener ugc nofollow" target="_blank">[2】</a></p></figure><p id="642c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然某些规则可能是相似的，并且适用于大多数编程语言，但这并不意味着所有编程语言都共享相同的规则。</p><p id="95cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，运算符的优先级和结合性都是由编程语言的规则决定的，由于不同的语言可能有不同的规则，所以阅读每种语言的文档以了解它们的运算符是如何工作的是很重要的。</p><p id="8316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于运算符是非关联的(n/a)情况，建议使用括号对表达式进行分组。</p><p id="e337" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>我在这里引用了MDN文档，因为ECMAScript规范指南没有运算符优先级/关联性表</p><p id="1963" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管优先级别较高的表达式会首先被计算，但有些情况下这并不成立。用<em class="my">短路</em> <strong class="ky ir"> <em class="my">，</em> </strong>一个操作数可能根本不求值！</p><h1 id="2889" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">短路(和逻辑运算符)</h1><p id="3c98" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一些逻辑操作符有一个称为短路的特性<strong class="ky ir">，</strong>，在这个特性中，解释器在给定操作数的结果值的情况下停止对表达式求值。</p><p id="7331" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，假设<code class="fe mz na nb nc b">x &amp;&amp; (y || z)</code>如果<code class="fe mz na nb nc b">x</code>为假(评估为<code class="fe mz na nb nc b">false</code>)，那么<code class="fe mz na nb nc b">(y || z)</code>永远不会被评估，即使<code class="fe mz na nb nc b">()</code>的优先级高于<code class="fe mz na nb nc b">&amp;&amp;</code>。</p><p id="332d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当表达式中的某些条件依赖于其他条件时，通常使用短路，因此并不总是需要对整个表达式求值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/925ae1d77c35253b219c15b7ddb89d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ym6HzVl4rNT4JQ6oYefcA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JavaScript逻辑运算符— <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></figure><p id="6659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JS有三个二元<strong class="ky ir"> </strong>逻辑运算符，都具有从左到右的结合性</p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="600a" class="oe lt iq nc b be of og l oh oi">let user = { name : "George" }<br/><br/>const getUserName = (userObj) =&gt; {<br/> if (user) {<br/>  if (user.name) {<br/>   console.log(user.name);<br/>  } else {<br/>   console.log("User object has no attribute called name");<br/>  }<br/> } else {<br/>  console.log("User object does not exist");<br/> }<br/>};<br/><br/>const getUserNameWithShortCircuit = (userObj) =&gt; {<br/> if (user &amp;&amp; user.name) {<br/>  console.log(user.name);<br/> } else {<br/>  console.log(`${user ? "User object has no attribute called name" : "User object does not exist"}`);<br/> }<br/>}<br/><br/>getUserName(user); // George<br/>getUserNameWithShortCircuit(user); // George<br/><br/>user = {};<br/><br/>getUserName(user); // User object has no attribute called name<br/>getUserNameWithShortCircuit(user); // User object has no attribute called name<br/><br/>user = null;<br/><br/>getUserName(user); // User object does not exist<br/>getUserNameWithShortCircuit(user); // User object does not exist<br/></span></pre><p id="8255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，<code class="fe mz na nb nc b">getUserName</code>函数嵌套了if条件来检查是否定义了<code class="fe mz na nb nc b">user</code>，如果是，则检查其<code class="fe mz na nb nc b">name</code>属性是否存在。如果它们都存在，我们打印出<code class="fe mz na nb nc b">name</code>属性。</p><p id="8b07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">getUserNameWithShortCircuit</code>函数使用逻辑<code class="fe mz na nb nc b">&amp;&amp;</code> (AND)运算符，将两个条件聚集在一个表达式中。不同之处在于，如果第一个操作数评估为<code class="fe mz na nb nc b">false</code>，那么第二个表达式不被评估，解释器跳转到<code class="fe mz na nb nc b">else</code>块。这有助于精简逻辑，并将条件/操作数之间的依赖关系组合在一起。</p><p id="4b26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">短路的另一个用例是提供默认值</p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="dd79" class="oe lt iq nc b be of og l oh oi">let userName = someNameVar || "default"</span></pre><p id="3247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mz na nb nc b">someNameVar</code>为<em class="my">真值</em>(计算结果为<code class="fe mz na nb nc b">true</code>)，则OR运算符不会计算右操作数，而是将<code class="fe mz na nb nc b">someNameVar</code>值赋给<code class="fe mz na nb nc b">userName</code>。否则，如果<code class="fe mz na nb nc b">someNameVar</code>为falsy，那么我们将<code class="fe mz na nb nc b">userName</code>设置为字符串<code class="fe mz na nb nc b">default</code>。</p><p id="1fbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong> : <strong class="ky ir"> </strong>如果左操作数为false sy，<code class="fe mz na nb nc b">||</code>返回第二个操作数，不管它是<code class="fe mz na nb nc b">true</code>还是<code class="fe mz na nb nc b">false</code></p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="dd58" class="oe lt iq nc b be of og l oh oi">let userName = "" || false; //returns false</span></pre><p id="0b16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">??</code>无效合并运算符类似于逻辑<code class="fe mz na nb nc b">||</code> OR，因为如果左操作数为<em class="my">真值</em>，它们都会短路。不同之处在于，只有当左操作数为<code class="fe mz na nb nc b">null</code>或<code class="fe mz na nb nc b">undefined</code>时，<code class="fe mz na nb nc b">??</code>才会计算右操作数。</p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="0b27" class="oe lt iq nc b be of og l oh oi"><br/>console.log("" ?? false); // ""<br/>console.log("" || false); // false<br/><br/>console.log(0 ?? false); // 0<br/>console.log(0 || false); // false<br/><br/>console.log(null ?? false); // false<br/>console.log(null || false); // false<br/><br/>console.log(undefined ?? false); // false<br/>console.log(undefined || false); // false<br/><br/>console.log(true ?? false); // true<br/>console.log(true || false); // true</span></pre><p id="5976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，使用<code class="fe mz na nb nc b">||</code>，任何falsy值都计算为右操作数。</p><p id="a650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是关于这些操作员的文档:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/fb1256482cce8b54ac906319456e5908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ekbWXlwsxJvEE2CP-gdyBg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">二元逻辑运算符— <a class="ae kv" href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-binary-logical-operators-runtime-semantics-evaluation" rel="noopener ugc nofollow" target="_blank"> ECMAScript指南</a></p></figure><h2 id="a363" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated"><strong class="ak">短路(更多)</strong></h2><p id="2a61" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">上述运算符(<code class="fe mz na nb nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND_assignment" rel="noopener ugc nofollow" target="_blank">&amp;&amp;=</a></code>、<code class="fe mz na nb nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment" rel="noopener ugc nofollow" target="_blank">||=</a></code>、<code class="fe mz na nb nc b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment" rel="noopener ugc nofollow" target="_blank">??=</a></code>)的赋值对应项也短路，因此赋值根本不会发生。</p><p id="f936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果左操作数是<code class="fe mz na nb nc b">null</code>或<code class="fe mz na nb nc b">undefined</code>，可选链接运算符<code class="fe mz na nb nc b">?.</code>也会短路。由于这不是一个逻辑操作符，而是用于访问对象的属性，所以我没有深入研究它，但认为它值得一提。</p><p id="d960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经学习了操作符，是时候学习它们的操作数了！</p><h1 id="69d5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基元</h1><p id="8993" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">原语被认为是大多数编程语言的构建块。在JavaScript中，它们是数据类型，不是对象；因此没有方法或属性。原语也是不可变的，因此它们的值不能改变。</p><p id="27dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript有七种原始数据类型:</p><ul class=""><li id="0c7a" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">不明确的</li><li id="a2bd" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">空</li><li id="27d8" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">数字</li><li id="559f" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">bigint</li><li id="7373" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">标志</li><li id="a115" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">线</li><li id="0ac6" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">布尔型</li></ul><p id="00eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将不再赘述<code class="fe mz na nb nc b">string</code>或<code class="fe mz na nb nc b">boolean</code>数据类型，因为它们通常都很好理解。</p><h2 id="e2c0" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">不明确的</h2><p id="bb66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果变量的值或属性尚未声明或赋值，则变量为<code class="fe mz na nb nc b">undefined</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/aae08304beb86d9c6417abde33bbe50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*mkiJZztgoZe9gosEAcQFiA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">未定义的变量/属性</p></figure><p id="ed0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变量<code class="fe mz na nb nc b">a</code>在没有值的情况下初始化时属于类型<code class="fe mz na nb nc b">undefined</code>。同样，如果<code class="fe mz na nb nc b">a</code>是一个空对象，我们试图访问一个不存在的属性，我们得到的不是错误，而是属性是<code class="fe mz na nb nc b">undefined</code></p><p id="282e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，当试图访问一个不存在/未声明的变量时，就会抛出一个<code class="fe mz na nb nc b">ReferenceError</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/803d6d2229b84841b35a8684f1d2b1a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcQVfxjM9v1DyEZ9bijAkg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">函数返回未定义的</p></figure><p id="be63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不返回值的函数返回<code class="fe mz na nb nc b">undefined</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/bbdbae53bfb6613b12803407f0fee460.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*4QkVSmM3oNJRpVcbn_M3ww.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数组索引未定义</p></figure><p id="eaa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">访问不存在的数组索引也会返回<code class="fe mz na nb nc b">undefined</code></p><h2 id="2453" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">空</h2><p id="e80c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与表示没有任何值的变量的<code class="fe mz na nb nc b">undefined</code>不同，<code class="fe mz na nb nc b">null</code>是分配给变量的值，表示“没有值”。因此，<code class="fe mz na nb nc b">null</code>被视为一个<em class="my">对象值</em>，尽管<code class="fe mz na nb nc b">typeof null</code>的计算结果为<code class="fe mz na nb nc b">object</code>，但它不是一个对象，因为它没有属性或方法，也不是可变的。</p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="2ec4" class="oe lt iq nc b be of og l oh oi">let newObject;<br/><br/>console.log(newObject); // undefined<br/><br/>newObject = null;<br/><br/>console.log(newObject); // null<br/><br/>console.log(newObject === null); // null<br/><br/>newObject = { name: "John Done", age: 30, email: "johndoe@email.com" }<br/><br/>//Clear object's value by assigning null<br/>newObject = null;</span></pre><p id="85a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">null</code>的一个常见用例是清除、重置或作为已初始化变量的占位符。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/3a46dbb3c8551347417cdf16b2738072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*Khnt-VDPdhUovDfkbxZvPg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">null数据类型的严格相等与typeof</p></figure><p id="48f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe mz na nb nc b">typeof null</code>的计算结果为<code class="fe mz na nb nc b">object</code>，为了测试一个对象是否为空，建议使用<code class="fe mz na nb nc b">===</code> <em class="my">严格相等</em>运算符。所有其他原语都可以使用<code class="fe mz na nb nc b">typeof</code>操作符进行测试。</p><h2 id="937a" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">标志</h2><p id="1c35" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mz na nb nc b">symbol</code>数据类型是JS在ES6中推出的一个新特性。符号保证是唯一的，因为它们是不可变的，所以非常适合用作<code class="fe mz na nb nc b">constants</code>。</p><p id="f52e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用内置的<code class="fe mz na nb nc b">Symbol</code>对象创建符号，该对象的构造函数采用一个可选参数(设置<code class="fe mz na nb nc b">description</code>属性)。</p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="8f6c" class="oe lt iq nc b be of og l oh oi">const firstName = Symbol("First name");<br/>const lastName = Symbol("Last name");</span></pre><pre class="oo oa nc op oq aw or bi"><span id="9dc1" class="ni lt iq nc b gy os ot l ou oi">let person = {<br/>  [firstName]: "George",<br/>  [lastName]: "Anton",<br/>  age: "Forever Young"<br/>};</span><span id="bc63" class="ni lt iq nc b gy ov ot l ou oi">console.log(person[firstName]); // "George"<br/>console.log(person[lastName]); // "Anton"</span><span id="1ee4" class="ni lt iq nc b gy ov ot l ou oi">const new_symbol = Symbol("This is a new symbol");<br/>const new_symbol2 = Symbol();</span><span id="4d6f" class="ni lt iq nc b gy ov ot l ou oi">console.log(new_symbol.description) // "This is a new symbol"<br/>console.log(new_symbol2.description) // undefined</span></pre><p id="09db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">符号被包在<code class="fe mz na nb nc b">[]</code>方括号中，以便设置为对象属性的键。</p><p id="56c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有提供描述属性，则描述属性为<code class="fe mz na nb nc b">undefined</code>。</p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="44de" class="oe lt iq nc b be of og l oh oi">const firstName = Symbol.for("First name");<br/>const lastName = Symbol.for("Last name");</span></pre><pre class="oo oa nc op oq aw or bi"><span id="15dc" class="ni lt iq nc b gy os ot l ou oi">let person = {<br/>  [firstName]: "George",<br/>  [lastName]: "Anton",<br/>  age: "Forever Young"<br/>};</span><span id="223b" class="ni lt iq nc b gy ov ot l ou oi">console.log(person[firstName]); // "George"<br/>console.log(person[lastName]); // "Anton"</span></pre><p id="e045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以使用<code class="fe mz na nb nc b">Symbol.for</code>创建符号，不同之处在于这些符号现在在程序的<strong class="ky ir">全局</strong>范围内。</p><p id="b30c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下所示，符号不能通过<code class="fe mz na nb nc b">Member Access</code>(点)操作符访问，也不能通过<code class="fe mz na nb nc b">Object.getOwnPropertyNames</code>和<code class="fe mz na nb nc b">Object.keys</code>方法公开。</p><p id="380f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们也不能被转换成<code class="fe mz na nb nc b">string</code>，所以<code class="fe mz na nb nc b">JSON.stringify</code>方法会忽略它们(它们也不能被转换成<code class="fe mz na nb nc b">number</code>类型)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/5f9e253b718eda91462be31ca08f2c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s0PsggTfsqx806MmP-oyA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尝试访问值电子邮件地址符号值</p></figure><p id="8efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这并不意味着符号是私有的。</p><p id="1e7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mz na nb nc b">Computed Member Access</code>或<code class="fe mz na nb nc b">Reflect.ownKeys</code>访问它们的值</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/d7fa2110ce9cab106b9c6b0467e64528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rHaIiV4UZBOVxQM2o-myA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用符号访问类的值</p></figure><p id="3659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">symbols</code>的一个常见用例是作为<code class="fe mz na nb nc b">object</code>属性的键，因为它们的唯一性避免了命名冲突的可能性。在符号出现之前，我们必须使用数字或像<code class="fe mz na nb nc b">uuid</code>这样的库来为对象键创建唯一的字符串，这并不总是理想的。</p><h2 id="bb40" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">数字</h2><p id="5114" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mz na nb nc b">number</code>数据类型是JavaScript中数值的默认类型。它包括整数、浮点值和特殊值，如<code class="fe mz na nb nc b">Infinity</code>、<code class="fe mz na nb nc b">-Infinity</code>、<code class="fe mz na nb nc b">NaN</code>(代表“不是一个数”)和两者<code class="fe mz na nb nc b">+/- 0</code>。由于数字是用<a class="ae kv" href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" rel="noopener ugc nofollow" target="_blank">双精度浮点数</a>来表示的，这意味着它们的精度有限，因此具有有限的表示形式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/13e0593a5b1405d8fb79b972ab968892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx-B_dNM4TJxeY8_et9YnA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最大整数值— <a class="ae kv" href="https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-number-type" rel="noopener ugc nofollow" target="_blank"> ECMAScript文档</a></p></figure><p id="25ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整数值被限制在区间[-2⁵，2⁵ ]内</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/85bf279a47c58c297c75da19e2ba6c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*N6l9EDoMI0DySfkpH6DSDw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对于整数x，x的定义域在[2⁵-2⁵]</p></figure><p id="5dfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">Number.MIN_SAFE_INT</code>，<code class="fe mz na nb nc b">Number.MAX_SAFE_INTEGER</code>返回最大/最小整数值</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/8d9e32252efd39e183685225db52607b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAK50TN8PO2-8491S-SG2Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最小/最大安全整数值</p></figure><p id="539f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最大/最小浮点值可通过<code class="fe mz na nb nc b">Number.MAX_VALUE</code>和<code class="fe mz na nb nc b">Number.MIN_VALUE</code>属性找到，超出该范围的值不保证精度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/bf022be15018ebd5b917ae96b25f0dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fS_ud2mDoF-d2MtDmstrcQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最大浮点值</p></figure><p id="38ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">范围[-2 ⁰ ⁴,2 ⁰ ⁴]之外的浮点由<code class="fe mz na nb nc b">+/- Infinity</code>表示</p><p id="7263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据ECMAScript，存在2⁵ -2不同的<code class="fe mz na nb nc b">NaN</code>值，每个值都无法区分(它是JavaScript中唯一不等于自身的值)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/b98da55c813d3f015478ae3de814a9ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*j2aClZYvNpneRcAKo-ZESw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NaN值彼此不同</p></figure><p id="8a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">NaN</code>对非数值执行算术运算或使用<code class="fe mz na nb nc b">Number</code>转换非数值/字符串时出现值</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/a523eeaf8e30f8afd424664186ba8741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1M2jlW5GZ3eiImhAJevBAA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NaN转换</p></figure><h2 id="ea28" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">bigint</h2><p id="790f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mz na nb nc b">bigint</code>是JavaScript引入的最新原语，它允许我们在不损失精度的情况下表示任意大小的整数。通过使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="noopener ugc nofollow" target="_blank">任意精度算法</a>，bigint表示数字的能力只受主机系统可用内存的限制。</p><p id="028b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">表示一个<code class="fe mz na nb nc b">bigint</code>是通过将<code class="fe mz na nb nc b">n</code>附加到一个整数文字的末尾来完成的</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/d6d12fc6fd3283be9f0f89e9c307e0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZ4uCVXhHwq2ThsZ3q8n9g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">定义大整数和转换</p></figure><p id="99b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第7、10行的日志表明<code class="fe mz na nb nc b">number</code>文字在<code class="fe mz na nb nc b">(2⁵³-1) + 2</code>的运算过程中会分解，而<code class="fe mz na nb nc b">bigint</code>不会</p><p id="2344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以使用全局函数<code class="fe mz na nb nc b">BigInt()</code>将数值转换为<code class="fe mz na nb nc b">bigint</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/83ace1a96ab3088088c7a25fffaf1cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIrfJXaGUcNE58yvkmtIRg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">BigInt文字定义了过去的数字。最大值</p></figure><p id="8e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe mz na nb nc b">number</code>文字使用<code class="fe mz na nb nc b">Infinity</code>时，<code class="fe mz na nb nc b">BigInt</code>能够处理该值</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/9e812abf06693674384828f140daa4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK2hMf_XmUOkRDJTroh0UA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">number和bigInt类型之间算术运算的TypeError</p></figure><p id="bf92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">bigint</code>和<code class="fe mz na nb nc b">number</code>类型之间的操作将抛出一个<code class="fe mz na nb nc b">TypeError</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/89518bdf453010484436c7719737e350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAT-N7yXFucP6WW9qqvioQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数值类型转换警告— ECMAScript</p></figure><p id="373d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免计算过程中的精度损失，将抛出<code class="fe mz na nb nc b">TypeError</code>。因此，由不同类型的操作符进行的隐式转换对<code class="fe mz na nb nc b">BigInt</code>无效。作为最佳实践，建议在程序中单独使用<code class="fe mz na nb nc b">bigint</code>或<code class="fe mz na nb nc b">number</code>类型，而不是同时使用两种类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/5c14355f8e1b9f4318da933ecc5c5f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELetz43mL714wR77gtzuWw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">巨大的int转换损失</p></figure><p id="11e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mz na nb nc b">BigInt</code>功能，当铸造值大于<code class="fe mz na nb nc b">Number.MAX_SAFE_INTEGER</code>时，会出现精度损失，如上面使用<code class="fe mz na nb nc b">number</code>类型转换所示。当它们是<code class="fe mz na nb nc b">string</code>类型时，建议转换更大值以避免这种行为。</p><p id="1856" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">BigInt</code>使得在没有溢出和精度损失风险的情况下执行整数运算成为可能，并且可能最终形成JavaScript中的<code class="fe mz na nb nc b">BigDecimal</code>实现的基础！</p><p id="7677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到在对<code class="fe mz na nb nc b">bigint</code>和<code class="fe mz na nb nc b">number</code>类型执行算术运算时，解释器抛出一个<code class="fe mz na nb nc b">TypeError</code>。虽然，对于操作者来说，在不同的原语上执行计算并不少见(这实际上就是我们如何得到<code class="fe mz na nb nc b">NaN</code>值的！).这种计算可能导致意想不到的结果，甚至错误，这是由于所谓的隐式类型转换(或强制)。</p><h1 id="5ac1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">隐式类型转换(强制)</h1><p id="ca62" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="my">类型转换</em>是将一个值从一种数据类型转换成另一种数据类型的过程。有两种方法执行类型转换:隐式和显式。</p><p id="9926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们使用全局<code class="fe mz na nb nc b">BigInt()</code>函数将一个<code class="fe mz na nb nc b">string</code>值转换为<code class="fe mz na nb nc b">bigint</code>值时，这是一种显式类型转换的形式。<code class="fe mz na nb nc b">Number()</code>、<code class="fe mz na nb nc b">String()</code>和<code class="fe mz na nb nc b">Boolean()</code>是另外三个全局可用的显式造型函数。</p><p id="63dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，隐式类型转换是在您不知情的情况下，由语言本身转换数据类型。了解的唯一方法是了解语言实现这些类型转换的规则。</p><p id="b422" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">旁注</strong> : <code class="fe mz na nb nc b">BigInt</code>类型在JavaScript中没有隐式转换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/44da329c1e413d2e0ec44819edc434a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*resa295CZhtBF61qxT3kPA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">加法运算符隐式转换</p></figure><p id="d58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面，我们可以看到一个隐式转换的例子。<code class="fe mz na nb nc b">+</code>操作符既可以做字符串连接，也可以做数字加法。虽然当操作数是不同的类型而不是抛出一个<code class="fe mz na nb nc b">TypeError</code>时，JavaScript似乎隐式地将<code class="fe mz na nb nc b">number</code>类型转换为<code class="fe mz na nb nc b">string</code>，然后返回字符串连接的结果。</p><p id="29d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们得到的不是期望值<code class="fe mz na nb nc b">3</code>，而是<code class="fe mz na nb nc b">12</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/b2ed408c332d3d44a3b61aec33ac66e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjcJGgtC80unS6ZlPb2mag.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">加法运算符— <a class="ae kv" href="https://262.ecma-international.org/11.0/#sec-addition-operator-plus" rel="noopener ugc nofollow" target="_blank"> ECMAScript指南</a></p></figure><p id="f4c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一下评估:</p><ul class=""><li id="4de7" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">步骤<strong class="ky ir"> 2 </strong>和<strong class="ky ir"> 4 </strong>检索表达式的值，在本例中是我们的操作数<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code></li><li id="20f2" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">步骤<strong class="ky ir"> 5 </strong>和<strong class="ky ir"> 6 </strong>被忽略，因为<code class="fe mz na nb nc b">ToPrimitive()</code>作用于对象，并且我们的操作数的值是原始类型<code class="fe mz na nb nc b">number</code>和<code class="fe mz na nb nc b">string</code></li><li id="30e1" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">步骤<strong class="ky ir"> 7 </strong>检查任一值是否为<code class="fe mz na nb nc b">string</code>的情况。在这种情况下，<code class="fe mz na nb nc b">y</code>为，因此<code class="fe mz na nb nc b">7a</code>将我们对<code class="fe mz na nb nc b">x</code>的原始值转换为<code class="fe mz na nb nc b">string</code>“2”，并且<code class="fe mz na nb nc b">7c</code>返回给我们<code class="fe mz na nb nc b">"1" + "2"</code>，即<code class="fe mz na nb nc b">"12"</code>。</li></ul><p id="5552" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，对我们之前的脚本的修正是<code class="fe mz na nb nc b">Number(x) + Number(y)</code>得到3。</p><p id="7a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果<code class="fe mz na nb nc b">x</code>是一个<code class="fe mz na nb nc b">boolean</code>、<code class="fe mz na nb nc b">null</code>或<code class="fe mz na nb nc b">undefined</code>，我们应该期待什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/059644400f3d3d947ee5c6f3d8fe2926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ShnX9GyPGnsMb8czU8TqQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">针对字符串的各种数据类型的加法运算</p></figure><p id="b3e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，在上面的所有实例中，<code class="fe mz na nb nc b">x</code>被转换为<code class="fe mz na nb nc b">string</code>类型并与<code class="fe mz na nb nc b">y</code>连接在一起。这仅仅是因为<code class="fe mz na nb nc b">y</code>属于<code class="fe mz na nb nc b">string</code>类型(步骤<strong class="ky ir"> 7 </strong>)</p><p id="c07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mz na nb nc b">y</code>不是<code class="fe mz na nb nc b">string</code>类型的怎么办？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/6f84d018fd16027aeacc4dcb57a4b998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHqvVyBvi1iUps9ct8E_8A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">非数字和非字符串数据类型之间的加法运算</p></figure><p id="6541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再看一遍评估:</p><ul class=""><li id="a213" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">步骤<strong class="ky ir"> 2 </strong>和<strong class="ky ir"> 4 </strong>检索每个操作数的值</li><li id="d4ea" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">步骤<strong class="ky ir"> 5 </strong>和<strong class="ky ir"> 6 </strong>被忽略，因为所有情况下我们都在处理原语</li><li id="d897" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">步骤<strong class="ky ir"> 7 </strong>被忽略，因为<code class="fe mz na nb nc b">x</code>或<code class="fe mz na nb nc b">y</code>都不是类型<code class="fe mz na nb nc b">string</code></li><li id="d2e9" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">步骤<strong class="ky ir"> 8 </strong>和<strong class="ky ir"> 9 </strong>将<code class="fe mz na nb nc b">x</code>和<code class="fe mz na nb nc b">y</code>的值转换为<code class="fe mz na nb nc b">number</code></li><li id="4959" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">步骤10增加了一项检查，以确保两个<code class="fe mz na nb nc b">number</code>类型相同，并且之前的<code class="fe mz na nb nc b">ToNumeric()</code>转换成功</li><li id="b9ac" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated">步骤12返回<code class="fe mz na nb nc b">Number::add</code>的结果，这是对转换后的<code class="fe mz na nb nc b">number</code>值的数值运算。</li></ul><p id="e9cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在来解释输出:</p><ol class=""><li id="54a8" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr pn mv mw mx bi translated">由于<code class="fe mz na nb nc b">Number(undefined)</code>是<code class="fe mz na nb nc b">NaN</code>而<code class="fe mz na nb nc b">typeof NaN</code>是<code class="fe mz na nb nc b">number</code>，两个未定义变量变成<code class="fe mz na nb nc b">NaN</code>的值按预期求值。</li></ol><p id="b07c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe mz na nb nc b">NaN</code> +任何<code class="fe mz na nb nc b">number</code>表达式(包括<code class="fe mz na nb nc b">Infinity</code>)总是产生<code class="fe mz na nb nc b">NaN</code></p><p id="cd32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<code class="fe mz na nb nc b">null</code>转换成数字就是<code class="fe mz na nb nc b">0</code>，可以通过<code class="fe mz na nb nc b">Number(null)</code>查看，因此有<code class="fe mz na nb nc b">0 + 0 = 0</code>。</p><p id="5359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4/5.<code class="fe mz na nb nc b">boolean</code> true和false分别转换为<code class="fe mz na nb nc b">1</code>和<code class="fe mz na nb nc b">0</code>，给出预期的结果。</p><p id="c527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，了解操作符如何处理不同的数据类型有助于防止错误。隐式强制转换不是<code class="fe mz na nb nc b">+</code>操作符独有的！</p><p id="a992" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们跳过的一个案例是，<code class="fe mz na nb nc b">+</code>如何处理<code class="fe mz na nb nc b">objects</code>？</p><h2 id="b70d" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">ToPrimitive()和原始强制</h2><p id="2437" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们回想一下，步骤<strong class="ky ir"> 5 </strong>和<strong class="ky ir"> 6 </strong>在操作数值上调用<code class="fe mz na nb nc b">ToPrimitive()</code>。</p><p id="2472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，抽象操作是算法或行为的规范，由语言内部使用，以帮助执行特定的任务，如强制。</p><p id="db4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">ToPrimitive()</code>是一个抽象操作，开发者无法使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/fa55a06d7c5930e7f462acf114fab72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7Bz3cMGm1vR6gBGyd1CEw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">初级抽象操作— <a class="ae kv" href="https://tc39.es/ecma262/#sec-type-conversion" rel="noopener ugc nofollow" target="_blank"> ECMAScript指南</a></p></figure><p id="5a64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">ToPrimitive</code>用于将对象转换为原语，需要2个参数。</p><p id="6dc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的第一个参数，<code class="fe mz na nb nc b">input</code>、<em class="my">、</em>是要转换的表达式或<code class="fe mz na nb nc b">object</code>，第二个，可选<code class="fe mz na nb nc b">preferredType</code>、<em class="my">、</em>是“默认”、“字符串”或“数字”之一。<code class="fe mz na nb nc b">preferredType</code>也被称为<strong class="ky ir">提示</strong>。</p><p id="7047" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤<strong class="ky ir"> 1检查输入是否是类型</strong> <code class="fe mz na nb nc b"><strong class="ky ir">object</strong></code> <strong class="ky ir">，</strong>如果不是，则<strong class="ky ir"> </strong>输入已经是原语，并且不执行任何动作(步骤<strong class="ky ir"> 2 </strong>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/b33a60717888a2c8b9c809298c4276e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*TmbK2ENqnrgR9aUhuby5CA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">valueOf()和toString()对象方法</p></figure><p id="1860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">ToPrimitive</code>操作按以下顺序进行:</p><ol class=""><li id="80ff" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr pn mv mw mx bi translated">查看对象的<code class="fe mz na nb nc b">valueOf</code>方法，如果存在，调用它。如果<code class="fe mz na nb nc b">valueOf</code>返回一个原语，则使用该原语值。</li><li id="aae3" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">如果<code class="fe mz na nb nc b">valueOf</code>没有返回原语，那么它查看对象的<code class="fe mz na nb nc b">toString</code>方法，如果存在，就调用它。如果<code class="fe mz na nb nc b">toString</code>返回一个原语，则使用该值。</li><li id="33a0" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">如果<code class="fe mz na nb nc b">toString</code>没有返回一个原语，那么我们查看<code class="fe mz na nb nc b">valueOf</code>和<code class="fe mz na nb nc b">toString</code>的<code class="fe mz na nb nc b">Object.prototype</code>内置方法(重复步骤1和2，直到返回一个原语)。</li><li id="669c" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">如果没有原语被返回，则抛出一个<code class="fe mz na nb nc b">TypeError</code>。</li></ol><p id="77f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们看到<code class="fe mz na nb nc b">obj + "World"</code>和<code class="fe mz na nb nc b">obj + 8</code>都有“obj”计算为<code class="fe mz na nb nc b">2</code>。这是因为<code class="fe mz na nb nc b">valueOf</code>方法首先执行，由于<code class="fe mz na nb nc b">2</code>是一个<code class="fe mz na nb nc b">number</code>类型，那么它就是一个原语，这就是返回的内容。</p><p id="078a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在回想一下，这是<a class="ae kv" href="https://262.ecma-international.org/11.0/#sec-addition-operator-plus" rel="noopener ugc nofollow" target="_blank">步骤中的<strong class="ky ir"> 5 </strong> </a> <strong class="ky ir"> </strong>中的<code class="fe mz na nb nc b">+</code>符铸造。因此，如果第二个操作数是字符串，原语<code class="fe mz na nb nc b">2</code>将被转换为<code class="fe mz na nb nc b">string</code>，因此我们有了字符串连接。否则它仍然是一个<code class="fe mz na nb nc b">number</code>，我们添加。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/d3589c5981ce73e59c1c24c2b1054e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*JpoUAXHSx6bvcAuHVOJ6WQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">提示=== "字符串"</p></figure><p id="062c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">覆盖前面的<code class="fe mz na nb nc b">ToPrimitive</code>操作行为的一种方法是提供一个提示。以前，hint被设置为“默认”,为了提供提示，我们需要使用显式转换。</p><p id="b45e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用<code class="fe mz na nb nc b">String</code>显式强制转换“obj”时，我们告诉<code class="fe mz na nb nc b">ToPrimitive</code>我们想先使用<code class="fe mz na nb nc b">toString()</code>(这是我们的<code class="fe mz na nb nc b">preferredType</code>)，在两种情况下都返回<code class="fe mz na nb nc b">Hello</code>(然后我们回到<code class="fe mz na nb nc b">+</code>手册的第7步)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/805f3529638bbc1bc220e7f5e1479df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Rt1PvAGngC1iaapOuMs8g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">普通操作限制— <a class="ae kv" href="https://262.ecma-international.org/9.0/#sec-ordinarytoprimitive" rel="noopener ugc nofollow" target="_blank"> ECMAScript指南</a></p></figure><p id="acb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们刚刚概述的步骤实际上是由<code class="fe mz na nb nc b">OrdinaryToPrimitive</code>抽象操作定义的，它实际上是<code class="fe mz na nb nc b">ToPrimitive</code>中的步骤1d。我们基本上跳过了1a — 1c。现在我来讨论1a什么时候用，以及<code class="fe mz na nb nc b">exoticToPrim</code>是什么意思。</p><h2 id="25d3" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">内部[@ @ top primitive]()方法</h2><p id="7394" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经看到，当我们向抽象的<code class="fe mz na nb nc b">ToPrimitive</code>操作传递一个提示时，比如<code class="fe mz na nb nc b">string</code>，然后我们在内部调用对象的适当方法(在这个例子中是<code class="fe mz na nb nc b">toString()</code>)(如果那些方法存在的话)。</p><p id="1dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行这些任务的(内部)函数是一个名为<code class="fe mz na nb nc b">[@@toPrimitive]()</code>的<em class="my">众所周知的</em>符号(“众所周知的<em class="my">”</em>符号由<code class="fe mz na nb nc b">@@</code>表示，是JavaScript中预定义的符号)。</p><p id="645a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这个<code class="fe mz na nb nc b">symbol</code>方法是JavaScript的内部方法，但是可以使用<code class="fe mz na nb nc b">Symbol.toPrimitive</code>覆盖它。JavaScript用这个方法查看对象作为<em class="my">外来的</em>和<code class="fe mz na nb nc b">exoticToPrim</code>属性被定义(步骤<strong class="ky ir"> 1a/b </strong>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/2ab99efc2746305f1fea1b8c4cba40de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMMIcPztfIVADt3BU_qS6g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“外来”对象—已定义的[symbol . top primitive]()方法</p></figure><p id="a85e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面是一个<em class="my">外来</em>对象的例子。尽管定义了<code class="fe mz na nb nc b">valueOf</code>和<code class="fe mz na nb nc b">toString</code>，但是<code class="fe mz na nb nc b">[Symbol.toPrimitive]()</code>方法覆盖了这些行为。</p><p id="a653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们在<code class="fe mz na nb nc b">if/else-if</code>块的范围之外没有显式的<code class="fe mz na nb nc b">hint === "default"</code>或简单的<code class="fe mz na nb nc b">return</code>，那么<code class="fe mz na nb nc b">obj + " World"</code>将返回<code class="fe mz na nb nc b">undefined</code>。这是因为我们覆盖了“默认”行为，并且<code class="fe mz na nb nc b">[@@toPrimitive]()</code>期望从“默认”的提示中得到一个值，但是没有赋值。</p><h2 id="7c45" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">包扎</h2><p id="7680" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了总结这一点，让我们看看为什么<code class="fe mz na nb nc b">{} + []</code>返回<code class="fe mz na nb nc b">[object Object]</code>:</p><ol class=""><li id="bdc6" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr pn mv mw mx bi translated"><code class="fe mz na nb nc b">+</code>操作的步骤<strong class="ky ir"> 2、4 </strong>、<code class="fe mz na nb nc b">GetValue({}) = {}</code>和<code class="fe mz na nb nc b">GetValue([]) = []</code></li><li id="425f" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">由于这些都不是图元，<code class="fe mz na nb nc b">+</code>操作的步骤<strong class="ky ir"> 5、6 </strong>调用<code class="fe mz na nb nc b">ToPrimitive</code></li><li id="818d" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated"><code class="fe mz na nb nc b">ToPrimitive</code>操作的步骤<strong class="ky ir"> 1 </strong>确认<code class="fe mz na nb nc b">{}</code>和<code class="fe mz na nb nc b">[]</code>为<code class="fe mz na nb nc b">object</code>类型。</li><li id="6f58" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">我们跳过步骤<strong class="ky ir"> 1a </strong>、<strong class="ky ir"> 1b </strong>，因为这些是空的，因此不是<em class="my">外来的</em></li><li id="fde3" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">步骤<strong class="ky ir"> 1c </strong>使用<code class="fe mz na nb nc b">OrdinaryToPrimitive</code>。因为它们是空的，所以没有用户定义的<code class="fe mz na nb nc b">valueOf</code>和<code class="fe mz na nb nc b">toString</code>方法。</li><li id="13ff" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">首先考虑左操作数。<code class="fe mz na nb nc b">{}</code>是<code class="fe mz na nb nc b">Object.prototype</code>的成员，因此继承了<code class="fe mz na nb nc b">.valueOf()</code>和<code class="fe mz na nb nc b">.toString()</code>方法。默认情况下，<code class="fe mz na nb nc b">OrdinaryToPrimitive</code>调用<code class="fe mz na nb nc b">{}.valueOf()</code>，后者返回一个<code class="fe mz na nb nc b">object</code>。</li><li id="1c62" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">由于<code class="fe mz na nb nc b">object</code>不是原语，它然后调用<code class="fe mz na nb nc b">{}.toString()</code>，这返回了<code class="fe mz na nb nc b">string</code>类型<code class="fe mz na nb nc b">[object Object]</code>。</li><li id="bf51" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">考虑右操作数。<code class="fe mz na nb nc b">[]</code>是<code class="fe mz na nb nc b">Array.prototype</code>的成员，也继承了<code class="fe mz na nb nc b">.valueOf()</code>和<code class="fe mz na nb nc b">.toString()</code>方法。首先调用<code class="fe mz na nb nc b">[].valueOf()</code>，它返回一个<code class="fe mz na nb nc b">object</code>类型</li><li id="5a97" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated">由于<code class="fe mz na nb nc b">object</code>不是一个原语，它然后调用<code class="fe mz na nb nc b">[].toString()</code>，这将返回<code class="fe mz na nb nc b">string</code>类型<code class="fe mz na nb nc b">"”</code>。</li><li id="e868" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr pn mv mw mx bi translated"><code class="fe mz na nb nc b">+</code>操作的第<strong class="ky ir"> 7 </strong>步，由于<code class="fe mz na nb nc b">string</code>的两个操作数，我们执行字符串连接，因此<code class="fe mz na nb nc b">[object Object] + ""</code>计算为字符串<code class="fe mz na nb nc b">[object Object]</code>。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/ecd9ad2af2a07f1b08531a2404b3d967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bk3u-5t5ids7a5bah0WL6A.jpeg"/></div></div></figure><h1 id="bf75" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">灵感</h1><p id="a5b9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你已经做到这一步，我想分享这篇文章的灵感:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/9da6fdb7a052d9b0705a8c674dc743c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUwRaZbXHESZ5hL954BBwA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">感谢发明JavaScript！</p></figure><p id="d2a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我们现在所知道的，看看你是否能理解输出的意思！</p><p id="859e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你发现这篇文章内容丰富，最重要的是，感谢你的阅读！</p><pre class="kg kh ki kj gt oa nc ob bn oc od bi"><span id="7b59" class="oe lt iq nc b be of og l ou oi">Connect with me on <a class="ae kv" href="https://www.linkedin.com/in/ganton000/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre><h1 id="f48b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="50c2" class="mp mq iq ky b kz mk lc ml lf pv lj pw ln px lr mu mv mw mx bi translated">ECMAScript指南</li><li id="741d" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><a class="ae kv" href="https://tc39.es/ecma262/#sec-ecmascript-language-expressions" rel="noopener ugc nofollow" target="_blank">操作员— ECMAScript指南</a></li><li id="72f4" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><a class="ae kv" href="https://tc39.es/ecma262/#sec-abstract-operations" rel="noopener ugc nofollow" target="_blank">类型转换— ECMAScript指南</a></li><li id="8c29" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" rel="noopener ugc nofollow" target="_blank"> JS运算符优先级— MDN单据</a></li><li id="0202" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" rel="noopener ugc nofollow" target="_blank"> JavaScript数据结构— MDN文档</a></li><li id="b2fe" class="mp mq iq ky b kz nd lc ne lf nf lj ng ln nh lr mu mv mw mx bi translated"><a class="ae kv" href="https://v8.dev/features/bigint" rel="noopener ugc nofollow" target="_blank"> BigInt原语— V8文档</a></li></ul></div></div>    
</body>
</html>