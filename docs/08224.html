<html>
<head>
<title>Understanding JavaScript Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-javascript-closures-87838e459cc8?source=collection_archive---------10-----------------------#2021-04-07">https://betterprogramming.pub/understanding-javascript-closures-87838e459cc8?source=collection_archive---------10-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过几个例子学习JavaScript的基本概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29a2462ed701f83b9846ffbc2d1f9658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ODBEtQ1AMOODIOFF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想学习并掌握JavaScript函数闭包吗？你来对地方了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="23cc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">前言</h1><p id="ebe2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要理解这个教程，你基本上只需要知道什么是函数和变量。阅读完这里的例子后，你会知道<em class="mz">范围</em>、<em class="mz">词法环境</em>、<em class="mz">内部</em>和<em class="mz">外部</em>函数，当然还有<em class="mz">闭包！</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3bee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基础</h1><p id="3c17" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们先回顾一些基础知识。函数接受参数并返回结果。例如，名为<code class="fe na nb nc nd b">add</code>的函数可以接受两个参数并返回一个和:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a4f8" class="ni md it nd b gy nj nk l nl nm">function add(a,b) {<br/>    return a + b;<br/>}</span></pre><p id="b4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用匿名函数语法(即函数没有名字)重写，将它赋给一个名为<code class="fe na nb nc nd b">add</code>的变量:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="8709" class="ni md it nd b gy nj nk l nl nm">const add = function (a,b) {<br/>    return a + b;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="397b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们创建一个函数时，我们可以访问全局范围。这意味着每个函数都可以访问共存的全局变量(即在全局范围内声明的变量):</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="bd91" class="ni md it nd b gy nj nk l nl nm">const name = 'I am global variable'; // global scope</span><span id="1a58" class="ni md it nd b gy nn nk l nl nm">function add (a,b) {<br/>    console.log(name); // 'name' is global variable<br/>    return a + b;<br/>}</span><span id="f630" class="ni md it nd b gy nn nk l nl nm">const result = add(3,5); // console.log will output: 'I am global variable' and add function will return 8 as expected</span></pre><p id="9b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在函数内部创建<em class="mz">局部</em>变量:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2251" class="ni md it nd b gy nj nk l nl nm">function add (a,b) {<br/>    const result = a + b; // result is local variable<br/>    return result;<br/>}</span></pre><p id="3daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe na nb nc nd b">result</code>是一个作用于<code class="fe na nb nc nd b">add</code>函数内部的<em class="mz">局部</em>变量，这意味着在函数外部，它是不可用的。换句话说，<code class="fe na nb nc nd b">result</code>有一个被功能性的开括号和闭括号<code class="fe na nb nc nd b">{}</code>绑定的环绕状态——这也被称为<em class="mz">词汇环境</em>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f19" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭</h1><p id="6b86" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">闭包是其他函数内部的函数，可以访问它们的<em class="mz">词法环境</em>。</p><p id="206f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在另一个名为<code class="fe na nb nc nd b">add5</code>的函数中创建一个函数，它显然会接受一个参数并将其值增加<code class="fe na nb nc nd b">5</code>:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4b63" class="ni md it nd b gy nj nk l nl nm">function add5 (a) {          // outer function<br/>    const b = 5;             // local variable<br/>    function add (a) {       // inner function<br/>         return a + b;       // a and b are both available inside<br/>    }<br/>    return add(a,b);<br/>}</span><span id="f280" class="ni md it nd b gy nn nk l nl nm">const result = add5(3);      // returns 8 as expected</span></pre><p id="51e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">奇怪的是，这过于复杂了，但是我们马上会简化它。</p><p id="e508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，重点是说明内部的<code class="fe na nb nc nd b">add</code>函数可以访问外部函数中定义的局部变量，因为<code class="fe na nb nc nd b">b</code>变量和<code class="fe na nb nc nd b">add </code>函数共享<code class="fe na nb nc nd b">add5</code>函数的相同范围——两者都在外部的<code class="fe na nb nc nd b">{}</code>括号中声明。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="aad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做一点重构，去掉局部<code class="fe na nb nc nd b">b</code>变量。毕竟在那里完全没必要。此外，我们希望重用我们的代码。我们希望能够轻松地创建像<code class="fe na nb nc nd b">add1</code>、<code class="fe na nb nc nd b">add5</code>和<code class="fe na nb nc nd b">add10</code>这样的函数。我们还将重命名我们的外部函数<code class="fe na nb nc nd b">generator</code>。这将帮助我们生成其他函数:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="612f" class="ni md it nd b gy nj nk l nl nm">function generator(a) {<br/>    return function(param) {<br/>        return a + param;   // a and param are both available inside<br/>    }<br/>}</span><span id="2ccc" class="ni md it nd b gy nn nk l nl nm">const add1 = generator(1); // set a = 1 and return inner function<br/>const add5 = generator(5); // set a = 5 and return inner function<br/>const add10 = generator(10); // set a = 10 and return inner function</span><span id="4cd8" class="ni md it nd b gy nn nk l nl nm">add1(3); // returns 4 as a = 1 and param = 3<br/>add5(3); // returns 8 as a = 5 and param = 3<br/>add10(3); // returns 13 as a = 10 and param = 3</span></pre><p id="3c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们新的<code class="fe na nb nc nd b">generator</code>函数返回一个将<code class="fe na nb nc nd b">a</code>和<code class="fe na nb nc nd b">param</code>相加的函数，并且有一个输入参数<code class="fe na nb nc nd b">a</code>的词法范围。因此，当每个函数被调用时，<em class="mz">内部</em>函数仍然可以访问<code class="fe na nb nc nd b">a</code>并记住它的值(维护一个引用),从函数被创建时开始。因此，我们可以创建类似于<code class="fe na nb nc nd b">add1</code>或<code class="fe na nb nc nd b">add10</code>的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了有一个更好的视图，让我们最终将<code class="fe na nb nc nd b">a</code>重命名为<code class="fe na nb nc nd b">local</code>，并突出内部函数的词法环境:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/12cd67c398720e1ceef7595e6a6460d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qR6kTATvkaataaTOV2CGGA.png"/></div></div></figure><p id="1b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上是一个闭包——它是内部函数与外部函数相同范围内的变量的组合(在本例中，它是<code class="fe na nb nc nd b">generator</code>函数的输入参数，简称为<code class="fe na nb nc nd b">local</code>)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="db41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="90d9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>是JavaScript的基本概念。在这篇短文中，我们通过简单的例子展示了如何创建和使用闭包。</p><p id="d486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你来自面向对象编程时，这可能是一个有点奇怪的概念，但这是函数式编程中的一个核心概念。</p><p id="5b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题或意见，请在下面分享。</p></div></div>    
</body>
</html>