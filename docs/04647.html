<html>
<head>
<title>Boost Your Kotlin Productivity With Extensions and Higher-Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用扩展和高阶函数提高您的Kotlin生产率</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/boost-your-kotlin-productivity-with-extensions-and-higher-order-functions-a19ebaf2aeac?source=collection_archive---------14-----------------------#2020-04-27">https://betterprogramming.pub/boost-your-kotlin-productivity-with-extensions-and-higher-order-functions-a19ebaf2aeac?source=collection_archive---------14-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的代码更干净，更易于管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0f36c701444f60472533b784b7dd4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsRne2fVulXqWnRK0EZgEQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/blur-close-up-code-computer-546819/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@luis-gomes-166706?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> luis gomes </a>的照片。</p></figure><p id="520b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Google I/O 2017上，谷歌宣布编程语言<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>现已正式支持Android应用开发。从此，再也没有回头。截至Google I/O 2019，Android移动开发一直是Kotlin-first。</p><p id="e1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将描述Kotlin的两个特性，它们是我生活中不可或缺的，而不是对它的所有特性大谈特谈，比如空安全性、数据类、过滤或Java的可解释性。他们保证为你节省时间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f069" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">扩展ˌ扩张</h1><p id="02a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Kotlin提供了用新功能扩展类的能力，而不必从类继承或使用设计模式，如装饰器。这是通过称为扩展的特殊声明来完成的。您可以创建函数、类成员等的扩展。</p><p id="0d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，这就是扩展函数的工作方式:不用扩展一个类，你就在其中定义了一个函数，现在你可以在任何地方使用它。</p><p id="e0b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要定义一个扩展函数，你所要做的就是定义一个名字为<code class="fe mz na nb nc b">&lt;ClassNameYouWishToInherit&gt;.&lt;YouMethodName&gt;</code>的函数。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6b46" class="nh md it nc b gy ni nj l nk nl"><br/>fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) {<br/> val tmp = this[index1] // ‘this’ corresponds to the list<br/> this[index1] = this[index2]<br/> this[index2] = tmp<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="182f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何利用它们提高生产力</h1><p id="e35c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从一个非常简单的用例开始。在Android开发中，有一些你经常使用的通用代码(例如，显示一个祝酒词，一个简单的警告对话框，等等。).为此，您每次都必须编写同样粘人的代码行:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="74c8" class="nh md it nc b gy ni nj l nk nl">Toast.makeText(this.<em class="nm">applicationContext</em>, txt, Toast.<em class="nm">LENGTH_SHORT</em>).show()</span></pre><h2 id="1a07" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">扩张函数的魔力</h2><p id="a866" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建一个扩展函数来显示祝酒词:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="134a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们为<code class="fe mz na nb nc b">Activity</code>类创建了扩展函数<code class="fe mz na nb nc b">toast</code>。现在你所要做的就是调用<code class="fe mz na nb nc b">Activity</code>类中的<code class="fe mz na nb nc b">toast</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="865c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们可以为<code class="fe mz na nb nc b">LayoutInflator</code>创建扩展函数:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1300" class="nh md it nc b gy ni nj l nk nl">fun View?.layoutInflator() = LayoutInflater.from(this?.<em class="nm">context</em>)<br/><br/>fun ViewGroup?.layoutInflator() = LayoutInflater.from(this?.<em class="nm">context</em>)<br/><br/>fun Fragment?.layoutInflator() = LayoutInflater.from(activity?.context)</span></pre><p id="3db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们为<code class="fe mz na nb nc b">View</code>、<code class="fe mz na nb nc b">ViewGroup</code>，甚至是<code class="fe mz na nb nc b">Fragment</code>类创建了一个扩展。</p><h2 id="80c8" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">更复杂的用例</h2><p id="5601" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在让我们来看看实际的用例。前几天，我发现自己在做地图盒子SDK。代码大概是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">它在Java中的样子。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在科特林是什么样子。</p></figure><p id="a42c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">救援的扩展功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">只要一句话，你就完成了。</p></figure><p id="38af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们直接创建了一个<code class="fe mz na nb nc b">MapView</code>的扩展函数。所有获得回调然后添加层的代码都是通过简单地调用<code class="fe mz na nb nc b">MapView</code>的<code class="fe mz na nb nc b">addLayer</code>扩展函数来完成的。</p><p id="fd9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">addLayer</code>函数现在将被视为<code class="fe mz na nb nc b">MapView</code>类自己的函数。</p><p id="548a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是扩展<code class="fe mz na nb nc b">MapView</code>类并添加这些函数。但是，当您可以添加一个扩展函数时，为什么要经历这么多痛苦并重构您现有的代码呢？</p><p id="8e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将进一步优化这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc83" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">高阶函数</h1><p id="0127" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">高阶函数是以函数为参数或返回函数的函数。</p><blockquote class="oa ob oc"><p id="881f" class="kz la nm lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated">“Kotlin函数是<a class="ae ky" href="https://en.wikipedia.org/wiki/First-class_function" rel="noopener ugc nofollow" target="_blank"> <em class="it">一级</em> </a>，这意味着它们可以存储在变量和数据结构中，作为参数传递给其他<a class="ae ky" href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions" rel="noopener ugc nofollow" target="_blank">高阶函数并从其返回</a>。您可以用任何可能用于其他非函数值的方式来操作函数。— <a class="ae ky" href="https://kotlinlang.org/docs/reference/lambdas.html" rel="noopener ugc nofollow" target="_blank">正式文件</a></p></blockquote><p id="1b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bfda" class="nh md it nc b gy ni nj l nk nl">fun sayHello(funcAsArg: (String) -&gt; Unit) {<br/> funcAsArg(“Hello”)<br/>}</span></pre><p id="b479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们创建了接受另一个函数作为参数的<code class="fe mz na nb nc b">sayHello</code>函数。并且这个函数接受<code class="fe mz na nb nc b">String</code>作为参数，返回<code class="fe mz na nb nc b">Unit</code>(类似Java中的<code class="fe mz na nb nc b">void</code>)。</p><p id="4c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些函数作为参数的帮助下，我们可以摆脱为这样简单的用例定义接口(例如，只有一个方法用于回调的接口)。</p><p id="7a52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过移除接口来进一步优化代码，因为接口很难维护，除了用于回调之外，在这里没有任何用处。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用HoF替换回调接口。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f132" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最终代码</h1><p id="9c08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，我们的Mapbox扩展Kotlin文件看起来像这样(如下)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终MapboxExtension.kt。</p></figure><p id="5bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经创建了几个扩展函数(用于获取<code class="fe mz na nb nc b">Map</code>实例、<code class="fe mz na nb nc b">Style</code>实例、添加<code class="fe mz na nb nc b">Layer</code>等)。).</p><p id="9c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了扩展函数和Hof处理的所有东西，我们的代码变得更加紧凑和可读。</p><h2 id="b104" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">代码比较</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a5565eb530574ab9512bb6221e27f7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRyoVJyzaShI7G43xReBbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">之前= 53行|之后= 17行</p></figure><p id="f440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后面的<em class="nm">(右侧)看起来紧凑，可读性强，同时也省去了我们反复写重复代码的麻烦。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="afce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="89d6" class="oh oi it lb b lc mu lf mv li oj lm ok lq ol lu om on oo op bi translated">延伸:【https://kotlinlang.org/docs/reference/extensions.html T2】</li><li id="72d6" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">高阶函数:<a class="ae ky" href="https://kotlinlang.org/docs/reference/lambdas.html#higher-order-functions" rel="noopener ugc nofollow" target="_blank">https://kotlinlang . org/docs/reference/lambdas . html #高阶函数</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9bd0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="8cfc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">仅凭这两个特性，您就可以实现很多目标。天空是极限。试试它们，并评论它们如何让你的生活变得更轻松。此外，请随意评论您使用Kotlin的体验，以及您如何从中获得最大收益。</p><p id="a18c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>