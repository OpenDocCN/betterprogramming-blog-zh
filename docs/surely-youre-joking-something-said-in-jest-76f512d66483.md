# 使用 React、Jest、TypeScript 和 Node 的测试驱动开发实现

> 原文：<https://betterprogramming.pub/surely-youre-joking-something-said-in-jest-76f512d66483>

## 以搜索框组件为例

![](img/c2eda4f359edb4f6cf58d0a1c81c1933.png)

帕特里克·托马索在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

学习通过 TDD 开发组件是令人畏惧的——所以让我们做一个快速的 TDD 实现，红绿重构，谈论实现的进展，一些问题，以及我们如何用一个真实的例子来解决它们。通常，我们将深入研究 React、Jest、React-Testing-Library、Typescript 和 Node。

首先，让我们考虑一个相当无害的请求，请求一个类似于 google 搜索栏的 React 组件。我们将有少量的静态选择，所以我们不需要将它连接到后端 API 或进行 API 端过滤。

在我们的例子中，我们需要一个简单的输入，允许您开始输入文本，并从后端 API 返回的值列表中弹出一个相关选项的悬挂列表。要做到这一点，用户应该能够点击其中一个来“选择”它，然后发出一个事件来影响应用程序的其余部分。我们将为这个实现使用缓存，并从失败的测试到实现构建它。如果我们要获得这个组件的用户故事，它可能看起来像这样:

```
I am a user
I want to see a list of options for country as I type in to the search bar
So that I can select the correct country for megiven I am filling out a form
when I click on the country textbox and type "Un"
then a list of filtered countries should appear with "United Arab Emirates", "United Kingdom", and "United States" as optionsgiven I am filling out the form, have typed in "Un", and am seeing the list of filtered countries
when I click on a country
then it should lock in my selectiongiven I am filling out the form and have locked in a country selection
when I click on the locked in selection
then it should reset the selection and allow me to search again
```

首先，我们必须创建我们的测试文件和组件文件，以开始处理这些代码。我们称之为`FilteredSearch.tsx`，在同一个文件夹里有一个好友`FilteredSearch.test.tsx`。我将在这里添加一个基本的测试，它将无法启动我们(这是红绿重构中的“红色”)。

好吧，我们有了一个好的开始。我们有一个`FilteredSearch`组件和一个失败测试的测试文件，但是等等，当我们的测试失败时，为什么会是一个好的开始呢？这是 TDD 的主要方法——红绿重构是在我们编写代码之前验证预期的一种方式。

所以，让我们探索一下重构部分——下一步是相对简单的一步，添加一些具有“文本框”aria 角色的东西，让我们通过测试:

既然我们已经通过了测试，我们可能应该开始考虑我们可以对组件进行的下一个增量更改，以及如何测试它。因为我们知道我们的实现将过滤一组数据，并允许用户输入部分文本，所以我们应该有一些在用户输入文本后出现的列表，当没有文本时消失。让我们更新我们的测试:

好了，我们已经开发了一些失败的测试(主要是因为 options prop 还没有实现),用来测试用户输入后应该出现的过滤列表。当 options prop 被实现时，这些测试中的一个将立即成功——当没有输入任何内容时，该测试确认元素不存在。

为了节省空间和促进重用，我已经先发制人地将`options`列表定义移到了文件的顶部。现在我们需要重构组件，以便测试成功:

好的，为了方便我们新的`options`列表，我们做了一些改动。我将为台词谈论他们，从新的`option`道具的道具解构开始。

*   我们需要那个`options` prop 来接收一个字符串列表，当用户输入他们的搜索时，这个列表将被过滤和显示
*   然后我们需要储存一些`searchText`
*   能够管理用户输入文本时的状态
*   我们也可以存储一些记忆化的内容；一个变量，指示是否存在一些搜索文本，这样我们就可以在列表出现时显示`options`列表，以及一个 div 数组，该数组与文本后过滤选项相关联
*   之后，我们通过将值设置为我们的`searchText`状态来控制输入
*   处理`onChange`事件来捕获键入的文本
*   当检测到搜索文本时，添加`options`列表 div。

进步很大！我们的搜索列出了一些选项，这些选项可以作为一个 API 调用(或者一个静态资源)的道具发送进来，并在用户输入文本时进行过滤。但是，我们已经注意到，这种经历是一种可怕的 UX，因为缺乏更好的词。当用户在搜索框中键入内容时，我们添加的 div 会在高度上扩展，并将页面上的所有其他内容都推到它的下方，当选项被添加/删除时，它们的闪烁会非常分散注意力。

我们在这里偶然发现了一些东西——如果我们让这个搜索组件管理悬停元素，它似乎有很多责任。似乎我们需要另一个组件来处理这些需求，将一个绝对定位的组件锚定在另一个组件之下，并将其从 DOM 流中移除，以便它可以出现在其他元素之上。

我们还从其他关于该系统的会议中了解到，这种浮动内容在其他地方也是一种需求。听起来我们提前感受到了痛苦！让我们找到一个解决方案，为我们节省一些时间。

进入挂钩和组件设计！

让我们负责确定一个元素在页面上的什么位置被绑定到一个钩子上，这个钩子接受一些子元素和一个引用。之后，它将决定我们的位置。让我们写一个测试，看看我们的钩子是否可以通过`getBoundingClientRect()`检索元素的正确 x 和 y:

我们已经为上面所有重要的实现细节模拟了一个 ref，并将元素定位在 ref 元素的 top + height，然后是左边界。从这里开始，实现变得非常容易:

现在让我们为这里的需求添加一套测试。我们将从当前的 `<FilteredSearch />`实现中借用一个，因为我们想要呈现一个 div 并检查“文档”角色。我们还将检查它是否呈现了发送到其中的孩子。最后，它的位置是正确的(感谢`useLocation`钩！):

值得注意的是，我们将首先模拟钩子，这样我们就不用担心底层的实现细节。我们将在 ref 存在的情况下测试锚的渲染，锚正在显示，但如果`show`为假或目标 ref 为空，它也不会渲染。我们还将检查子元素是否被渲染，以及“顶部”和“左侧”样式属性是否被设置为基于被模仿的`useLocation`钩子的正确值。

现在，我们需要实现组件本身:

通过测试后，我们可以通过将当前的`options`列表包装在`<FloatingAnchor />`组件中来修复`<FilteredSearch />`组件:

现在，随着测试的通过，我们终于可以确信，我们的新组件集在我们当前的站点中可以如预期的那样运行了！运行代码会产生一个相当无害的输入，可以键入该输入来显示满足类型化过滤器的国家的锚定浮动列表。

接下来，我们需要能够与过滤选项列表进行交互。让我们通过单击列表中的一个选项进行简单的测试来实现这一点:

这里我们在一个名为`onOptionSelected`、`fireEvent`的新事件处理程序道具上添加了一个事件间谍，用于键入初始文本，我们在过滤搜索中找到并单击目标选项文本。这将失败，因为我们还没有设置事件处理程序属性`onOptionSelected`，也没有连接`onClick`事件来使用它。让我们在主要组件中实现它:

保存后，我们就可以通过测试，将选中的选项事件发送给包含它的 react 代码，对它进行必要的处理。最有可能的是，这些数据存储在某个状态值中，用来确认“表单”是完整的，但是我们不做任何假设。

所以我们只需要构建最后一个功能:选择“锁定”。当我使用这个控件搜索一个选项并单击它时，它应该显示我选择的值，如果再次单击选择的值，我应该能够更改它。这应该是一个非常简单的实现，所以让我们开始红绿重构，对我们在这里添加的函数进行额外的测试:

这个测试现在查找具有“note”角色的元素和所选元素的文本。如果两者都存在，我们就可以开始了！现在要修复组件的实现:

最后一个要实现的函数。当我们点击新添加的“锁定”选项时，我们需要能够选择一些新的东西。现在让我们来实现它:

最后一步是:

现在我们的组件满足了所有要求！另一个增加的功能是当锁定的选择被点击时清除搜索文本，或者其他 UX 的改进，比如 CSS 样式，使它不那么粗糙和容易。但是由于我们只是在讨论红绿重构的 TDD 过程和用例，我们就此打住。

感谢阅读。敬请关注更多内容。