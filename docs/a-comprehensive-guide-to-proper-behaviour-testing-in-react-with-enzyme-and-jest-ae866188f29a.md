# 与酶和 Jest 反应中正确行为测试的综合指南

> 原文：<https://betterprogramming.pub/a-comprehensive-guide-to-proper-behaviour-testing-in-react-with-enzyme-and-jest-ae866188f29a>

## 基于三年实践经验的七点建议

![](img/78725d5a86d8c16cf9a4e0c12482948f.png)

作者图片

在 React 领域，过去几年我们测试组件的方式发生了重大转变。虽然以前它主要集中在单元测试上，但是现在的标准更倾向于确保你的测试尽可能地代表你的用户体验——行为测试。

这种变化也可以在 React 官方文档中找到，其中他们[推荐](https://reactjs.org/docs/testing.html#tools)用于测试 React 组件的工具是 [React 测试库](https://testing-library.com/docs/react-testing-library/intro/)，这是一个专注于行为测试领域的替代前端测试库。在《2020 年 JavaScript 现状报告》中，这个库进入了测试类别，在市场份额、满意度和兴趣方面,[占据了主导地位。](https://2020.stateofjs.com/en-US/technologies/testing/#testing_experience_ranking)

不幸的是，并不是每一个 React 开发人员或团队都能随时跟上最新的趋势。虽然能够使用 React 测试库将有助于更适当的行为测试，但这并不是每个团队都可以实际做出的改变。如果一个团队已经为 React 代码准备好了某种测试结构，那么坚持使用它并不奇怪。潜在的好处可能不会超过采用全新的测试库所需的努力，这是一个合理的考虑。

然而，结果是 React 开发人员想要应用行为测试，但是不得不使用次优的工具来这样做。在过去的三年里，我经历了多次这样的事情。作为团队和个人，我们的重点转向了行为测试。但是这个团队已经使用 Enzyme 有一段时间了，而且它已经深深地集成到了前端堆栈中。从 Enzyme 迁移到 React 测试库，或者任何其他行为测试库，实际上是不可能的。

因为这是不可能的，我决定利用我现有的资源，尝试在酶中应用适当的行为测试。在过去的三年里，我专门研究酶，并尝试用它做行为测试。我遇到了很多障碍，并努力磨练这项技能。在酶中进行行为测试并不困难，但是正确地做*它本身就是一个挑战。在这篇文章中，我将分享我多年来在与酶反应中应用行为测试所学到的东西。特别是，重点是如何正确地做，以使最终的测试有意义、可靠和有价值。*

# *总是使用完整的 DOM 呈现*

*使用 Enzyme 渲染组件有三种方式:浅层渲染(使用`shallow`)、全 DOM 渲染(使用`mount`)和静态渲染(使用`render`)。如果您专注于使用 Enzyme 编写适当的行为测试，正确的选择总是完全 DOM 呈现要测试的组件。*

*正如在 [Enzyme API 文档](https://enzymejs.github.io/enzyme/docs/))中所述，浅层渲染的主要目的是隔离一个组件，并确保您的测试只针对该组件进行断言，而静态渲染则从 React 树中生成 HTML，以便您更容易验证生成的 HTML 结构。这两种呈现方法都创建了组件的隔离环境，供您在其中进行测试。*

*浅层呈现将组件与应用程序的其余部分隔离开来，而静态呈现仅将组件与生成的 HTML 结构隔离开来。虽然这些隔离的环境对于单元测试和某些验证来说很好，但是它们不是用户与应用程序交互的环境，因此对正确的行为测试没有帮助。通常，使用这些渲染方法会助长不良的测试习惯:[专注于测试实现细节](https://kentcdodds.com/blog/testing-implementation-details)和[获得虚假的安全感](https://kentcdodds.com/blog/why-i-never-use-shallow-rendering)。*

*另一方面，完整的 DOM 呈现不会以任何方式隔离要测试的组件，并确保它与其他组件、DOM、外部资源和 React 生命周期的所有交互保持完整。这意味着测试将在一个类似于浏览器的环境中运行，并且最接近用户的体验。因此，如果您的目标是执行适当的行为测试，那么总是尝试使用完整的 DOM 呈现是一个必要的步骤。*

# *警惕依赖实现细节*

*大多数前端测试库最初并不是以行为测试为中心构建的。酶就是这些测试库之一。虽然这在过去很有意义，但是前端测试领域已经发生了很大的变化。与以前相比，这个领域已经转向以行为为中心的测试。*

*这不是一个问题，但它确实意味着当使用酶编写行为测试时，您必须格外深思熟虑。特别是，你应该格外小心，你的测试不要依赖于[实现细节](https://kentcdodds.com/blog/testing-implementation-details/)。你的重点应该是确保你的测试是有意义的，并且正确地反映用户如何与你的应用程序交互。*

*当您试图与元素交互以触发某些流时，这一点尤其重要。当这样做时，这些交互不能依赖于我们作为开发人员所拥有的内部信息——实现细节。*

*如果做错了，那么你的测试中最基本的部分之一就已经很脆弱了。这反过来会使你的测试变得不可靠，不断地触发假阴性，因为无关的小变化会影响测试，不可靠，没有价值。*

# *寻找元素时避免 CSS 选择器*

*我所见过的行为测试中最常见的实现细节是依赖于你的前端代码的 CSS 方面。一般来说，我建议你避免使用 CSS 选择器；相反，坚持使用从用户角度来看有意义的交互元素。从用户的角度来看，类名或代码的其他 CSS 特性没有任何意义或目的。*

*当测试你的前端代码时，使用 CSS 选择器是非常容易和方便的。这也是为什么很多人这样做，但最终，这是一个实现细节。从开发的角度来看，改变是非常主观的，只会降低测试的可信度和可靠性，因为最小的改变都会导致假阴性。相反，结合其他视觉属性，尝试坚持使用实际的元素，如`button`或`a`。这是用户在与交互元素交互之前识别交互元素的最典型方式。*

# *有时候你必须变得乏味*

*如上所述，酶不一定是在考虑行为测试的情况下产生的。这意味着，如果我们想要编写适当的行为测试，我们有时需要在实现它们时有创造性和乏味性。下面的代码片段是一个例子，它基于我现在在酶中如何处理我的行为测试。*

```
*const submitButton = wrapper.findWhere(
	node => node.type() === 'button' && node.text() === 'Submit'
);*
```

*它的目的是使用 Enzyme 的 API 在页面上找到一个提交按钮，这可能是验证表单提交流所必需的。它看起来非常冗长、丑陋和乏味，尤其是如果你将它与我经常遇到的`const submitButton = wrapper.find('.submit-button')`的内容进行比较的话。但另一方面，更乏味的选择器更好地代表了实际用户在应用程序中寻找提交按钮的方式。也就是说，找到一个带有“提交”标签的可视按钮。*

*采用更繁琐的选择也避免了我们已经描述过的问题，即依赖于实现细节。比方说，在未来，我们希望将我们的组件重组到一个设计系统中，并拥有不同大小的按钮。我们现在有了`submit-button-md`、`submit-button-small`和`submit-button-large`，而不是`submit-button`。*

*如果我们使用不那么繁琐但更方便的 CSS 选择器方法来实现提交流的行为测试，那么测试将会因为样式的改变而失败。这个测试突然失败的问题是它没有给我们提供任何有意义的信息。对于用户来说，提交流程并没有中断。该功能本身非常好，但测试现在失败了。突然，我们不得不走出我们的方式，并解决它，这在这种情况下感觉完全没有意义。这就是导致前端测试失败的原因——测试突然失败，而特性没有被破坏，因此被认为是古怪的、令人讨厌的，并且容易受到最小变化的影响。*

*相反，使用上面描述的更繁琐的方法在我们的测试中找到相同的 submit 按钮将会避免这些不必要的假阴性测试结果。这是因为它不依赖于与测试无关的脆弱代码部分，即 CSS 类，而是依赖于对我们和用户都有意义的信息。在本例中，它是关于一个 HTML 元素`button`的，上面有提交文本。这是这次测试中对我们最重要的信息。如果将来我们对 submit 按钮执行类似的 CSS 样式更改，那么测试结果将不会受到影响，因为现在我们不依赖那种信息。这对于用户的体验也是有意义的，因为它不影响提交流本身。*

*但是让我们说，在另一个时刻，我们不小心交换了页面上提交和取消按钮的文本标签。测试现在将失败，这是有意义的，因为现在触发了一个不同的流，并影响了我们用户的体验。对于我们的用户来说，这个特性现在被破坏了，这对我们来说是非常重要的信息，应该会触发测试结果的变化。但是如果我们使用更方便的 CSS 选择器方法，那么测试将不能提醒我们这个损坏的特性，因为它依赖于不同的、不相关的信息。*

*当执行行为测试时，采取简单的方法可能会很方便并节省您的时间，但是会给您留下一种错误的安全感和潜在的无意义的测试。反而有时候更繁琐一点更好。这将花费更多的前期时间和精力，但是这种投资的价值在于最终的测试更加可靠和有价值。*

# *停止使用快照测试*

*在 React 中编写测试的最常见的方法之一是通过快照测试。它们非常方便，易于使用，几乎不需要测试。然而，快照测试的问题是，它们通常几乎没有意义，几乎没有任何价值。这是因为快照测试所做的唯一事情就是呈现组件并将结果 DOM 结构保存为快照。然后，下一次创建另一个快照并与前一个进行比较。如果有任何差异，快照测试将失败。*

*快照通常几乎不提供任何价值的原因是它们没有超出组件的 DOM 结构。这与我们之前讨论的关于浅层渲染的问题密切相关，即创建一个不代表用户如何通过隔离组件与您的应用程序交互的测试环境。在快照测试的情况下，快照测试无法正确验证用户的工作流。它唯一的目的是验证组件的结果 DOM 结构没有改变，这与行为测试领域无关。*

*因此，如果您热衷于在 React 中编写适当的行为测试，那么停止使用快照测试，因为它们不会为该目标提供任何有意义的价值。*

***小提示**:我不认为快照测试在所有场景中都是完全无用的。但是在行为测试的环境中，正如我提到的，它们没有存在的理由，因为它们不能以任何方式验证用户行为。他们的目的集中在一个完全不同的测试领域，这个领域的重点是防止 DOM 改变。在前端某些部分的 DOM 结构不允许改变的情况下，快照测试是非常有意义的，非常有意义。但是根据个人经验，我看到它们被用于完全不同的原因，这只会导致你的测试结果中有更多的噪音。*

# *使用额外的匹配器会让你的生活更轻松*

*虽然 Jest 本身是一个验证 JavaScript 代码的极好的测试框架，但不幸的是，现成的工具不足以正确验证 React 代码或在 DOM 上执行断言。特别是，内置的匹配器不能直观地处理我们希望在前端代码中执行的断言，或者与 Enzyme 一起执行的断言。幸运的是，有一些[包](https://github.com/jest-community/awesome-jest#matchers)扩展了现有的匹配器集，在不同的用例中更加方便、具体和直观。*

*其中之一是`jest-enzyme`，它可以与 Enzyme 顺利集成，提供的匹配器是对开箱即用匹配器的升级。如果没有它们，执行断言通常是一项乏味、冗长且不直观的任务，正如在本文前面的部分中可以看到的那样。而在`jest-enzyme`中，很多问题都被抽象在它们提供的匹配器中，比如`toExist`、`toIncludeText`和`toHaveText`。*

*虽然`jest-enzyme`是对现成匹配器的升级，并使我在执行正确行为测试方面的生活变得更加容易，但它绝不是完美的。然而，我强烈建议在 Jest 上使用额外的扩展，使你的测试更加直观。这反过来将使您更容易创建更接近用户如何与您的应用程序交互的测试。*

# *对你嘲笑的东西要深思熟虑*

*模仿是编写测试代码的一个重要部分，但也可能是一个非常容易导致错误安全感的陷阱。正如前面讨论浅层渲染时提到的，隔离一个组件会使我们远离我们的目标，即编写适当的行为测试来反映用户如何与我们的应用程序交互。模仿是获得对代码的某一部分的控制的一个强大的方法，但是也会导致为你的测试创建一个孤立的环境，这正是我们所不希望的。*

*关键是要留意你在嘲笑什么，以及你嘲笑它的原因。如果你仅仅因为子组件令人讨厌而嘲笑它们，那么与用户仅仅为了通过测试而感知它的方式相比，你正在积极地减少你的测试的代表性。此外，您实际上也正在远离行为集成测试，并通过隔离您的组件进行测试来回归到单元测试。*

*深入研究所有场景的细节，无论在测试中模仿某段代码是否有意义，都超出了本文的范围。我还有一篇文章更深入地探讨了这些场景。但是现在，当处理前端行为测试中的模拟时，这里有一些通用的指导方针，我可以给你一些帮助:*

*   *如果运行一段代码与用户如何与之交互无关，但确实需要一些开销，那么模仿是有意义的。*
*   *如果代码影响了测试的结果，并且您想要控制它所导致的不同场景来验证它们，比如错误处理，那么模仿是有意义的。*
*   *试着控制你的测试，只验证必要的东西。这将使你的测试切中要点，避免因为你试图验证太多而嘲笑太多。*

*[](https://keraito.medium.com/to-mock-or-not-to-mock-that-is-the-question-2150cc83a96b) [## 嘲笑还是不嘲笑，这是个问题

### 帮助你决定嘲讽是否有意义的 3 个建议。

keraito.medium.com](https://keraito.medium.com/to-mock-or-not-to-mock-that-is-the-question-2150cc83a96b)* 

# *最后的想法*

*虽然使用像 React Testing Library 这样的专用库执行行为测试是目前测试 React 组件的首选方式，但不幸的是，这并不是每个开发人员或团队都可以立即采用的。我就遇到过这种情况，我所在的团队在使用酶的时候遇到了困难。*

*在过去的几年里，我投入了大量的时间和精力在酶的行为测试上。虽然只是做它并不一定困难，但是以一种适当的方式做它，在那里你的测试是有用的、可靠的和有意义的，这并不是一个微不足道的任务。*

*为了帮助你解决这个问题，我在这篇文章中分享了几个基于我多年来所学的技巧，这样你就不必从头再来了。第一步是尽可能使用完整的 DOM 呈现，以便在与用户体验相同的环境中测试组件。*

*然后，重要的是要确保你的测试基础是坚实的。这意味着你应该小心依赖于实现细节，避免在寻找元素交互时使用 CSS 选择器，有时你的测试会很乏味，因为 Enzyme 不一定是为行为测试而构建的。*

*应该尽可能避免快照测试。尽管它们非常受欢迎，但它们并没有以任何有意义的方式对行为测试做出贡献。在现有匹配器的基础上使用一个库来添加额外的匹配器可以覆盖很多领域，使您的行为测试更加容易。最后，重要的是要注意你在嘲笑什么。鲁莽地不加思考地进行测试会降低你的测试的代表性，从而使你远离正确的行为测试。*

*编写适当的行为测试并不是一件容易的事情，尤其是当你被提供了次优的工具来这样做的时候。但是通过一些创造性，额外的资源，和一些指导方针，它肯定有可能和酶一起工作。希望这篇文章能让你受益，帮助你创建更有用、更可靠、更有意义的行为测试。*