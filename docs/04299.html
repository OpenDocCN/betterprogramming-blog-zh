<html>
<head>
<title>Transmit Network Data Using Volley in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中使用凌空传输网络数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/transmit-network-data-using-volley-in-android-6afd142f9130?source=collection_archive---------10-----------------------#2020-04-03">https://betterprogramming.pub/transmit-network-data-using-volley-in-android-6afd142f9130?source=collection_archive---------10-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9637" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个HTTP库，使Android应用程序的联网更容易，更重要的是，更快</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f0a5ef271e3ee58d01cf2cb905848e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/0*aPKApgS3WFPUBt0d.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来自<a class="ae ku" href="https://developer.android.com/training/volley/simple" rel="noopener ugc nofollow" target="_blank">安卓</a></p></figure><p id="c238" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过阅读本文，您将学会直接从Android应用程序中调用REST API。我们将使用Android官方支持的名为<a class="ae ku" href="https://developer.android.com/training/volley/" rel="noopener ugc nofollow" target="_blank">凌空</a>的HTTP库。</p><p id="cf07" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">根据其中一位读者的反馈，谷歌已经离开了这个图书馆，不再主动更新它。最后一次发布是在2018年7月17日。如果您打算在项目中使用它，请考虑这一点。</p><p id="0e09" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">根据<a class="ae ku" href="https://developer.android.com/training/volley/" rel="noopener ugc nofollow" target="_blank">官方文件</a>，</p><blockquote class="lr ls lt"><p id="60c0" class="kv kw lu kx b ky kz ju la lb lc jx ld lv lf lg lh lw lj lk ll lx ln lo lp lq im bi translated">“凌空擅长用于填充UI的RPC类型的操作，例如以结构化数据的形式获取一页搜索结果。它很容易与任何协议集成，并且开箱即用，支持原始字符串、图像和JSON。通过为您需要的功能提供内置支持，凌空将您从编写样板代码中解放出来，并允许您专注于特定于应用程序的逻辑。”</p></blockquote><p id="c732" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该文档列出了以下优点:</p><ul class=""><li id="fbd0" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">网络请求的自动调度</li><li id="0eca" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">多个并发网络连接</li><li id="1412" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">具有标准HTTP缓存一致性的透明磁盘和内存响应缓存</li><li id="244a" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">支持请求优先级</li><li id="97f0" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">取消请求API。您可以取消单个请求，也可以设置要取消的请求的块或范围</li><li id="c79a" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">易于定制，例如重试和回退</li><li id="50cc" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">强有序性使得用从网络异步获取的数据正确填充用户界面变得容易</li><li id="1759" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">调试和跟踪工具</li></ul><p id="e9bf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，对于调用REST API和传输网络数据来说，凌空是一个非常有用的库。但是，由于在解析过程中会将所有响应存储在内存中，因此凌空不适合大型下载或流操作。如果您正在寻找流操作，请考虑其他选择，如<a class="ae ku" href="https://developer.android.com/reference/android/app/DownloadManager" rel="noopener ugc nofollow" target="_blank">下载管理器</a>。</p><p id="14b5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">本教程分为三个部分:</p><ol class=""><li id="8852" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq mm me mf mg bi translated">设置</li><li id="2565" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq mm me mf mg bi translated">履行</li><li id="d385" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq mm me mf mg bi translated">结论</li></ol></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4871" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.设置</h1><p id="86d8" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">确保您已经安装了<a class="ae ku" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> Android Studio </a>和开发所需的SDK。转到<code class="fe nr ns nt nu b">build.gradle (Module: app)</code>，在依赖项中添加以下代码:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="a573" class="nz mv it nu b gy oa ob l oc od">implementation 'com.android.volley:volley:1.1.1'</span></pre><p id="263e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同步gradle文件并等待它完成。在<code class="fe nr ns nt nu b">AndroidManifest.xml</code>中增加以下权限。我们需要互联网接入来发送网络数据。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="ebc7" class="nz mv it nu b gy oa ob l oc od">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</span></pre><p id="eeb4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们进入下一部分，启动您的Android项目。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="093f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">2.履行</h1><p id="0b7f" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">我们将建立一个<code class="fe nr ns nt nu b">RequestQueue</code>类，作为我们应用程序的服务。让我们创建一个名为<code class="fe nr ns nt nu b">RequestSingleton.java</code>的新类。强烈推荐使用单例方法，这样效率会高很多。</p><h2 id="1e32" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated">导入</h2><p id="f47c" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">将以下导入添加到类中。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="4b6e" class="nz mv it nu b gy oa ob l oc od">import android.content.Context;<br/>import android.graphics.Bitmap;<br/><br/>import com.android.volley.DefaultRetryPolicy;<br/>import com.android.volley.Request;<br/>import com.android.volley.RequestQueue;<br/>import com.android.volley.toolbox.StringRequest;<br/>import com.android.volley.toolbox.Volley;</span></pre><h2 id="4de5" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated">初始化</h2><p id="ef9b" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">在您的类中初始化下列变量。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="95d3" class="nz mv it nu b gy oa ob l oc od">private static RequestSingleton <em class="lu">instance</em>;<br/>private RequestQueue requestQueue;<br/>private static Context <em class="lu">ctx</em>;</span></pre><h2 id="1358" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated">单一对象</h2><p id="47f1" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">创建一个名为<code class="fe nr ns nt nu b">getInstance</code>的同步方法。我们传递一个<code class="fe nr ns nt nu b">Context </code>对象作为参数。我们将调用这个方法来获取singleton。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="9688" class="nz mv it nu b gy oa ob l oc od">public static synchronized RequestSingleton getInstance(Context context) {<br/>    if (<em class="lu">instance </em>== null) {<br/>        <em class="lu">instance </em>= new RequestSingleton(context);<br/>    }<br/>    return <em class="lu">instance</em>;<br/>}</span></pre><h2 id="4ad0" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated">构造器</h2><p id="df55" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">用下面的初始化创建<code class="fe nr ns nt nu b">RequestSingleton</code>的构造函数。(您将看到一个错误，因为<code class="fe nr ns nt nu b">getRequestQueue</code>功能尚未实现。)</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="4e73" class="nz mv it nu b gy oa ob l oc od">private RequestSingleton(Context context) {<br/>    <em class="lu">ctx </em>= context;<br/>    requestQueue = getRequestQueue();<br/><br/>}</span></pre><p id="dfb0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">用下面的代码实现缺少的<code class="fe nr ns nt nu b">getRequestQueue</code>方法。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="1058" class="nz mv it nu b gy oa ob l oc od">public RequestQueue getRequestQueue() {<br/>    if (requestQueue == null) {<em class="lu"><br/>        </em>requestQueue = Volley.<em class="lu">newRequestQueue</em>(<em class="lu">ctx</em>.getApplicationContext());<br/>    }<br/>    return requestQueue;<br/>}</span></pre><h2 id="a54c" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated">通用请求方法</h2><p id="a645" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">一旦完成，继续添加下面的通用函数，以确保我们的singleton能够支持所有类型的<code class="fe nr ns nt nu b">Request</code>。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="de66" class="nz mv it nu b gy oa ob l oc od">public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; req) {<br/>    //retry policy<br/><br/>    getRequestQueue().add(req);<br/>}</span></pre><p id="099b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果API调用需要相当长的时间才能完成，您可以设置<code class="fe nr ns nt nu b">RetryPolicy</code>来防止它超时。在注释下添加以下内容，将超时设置为一秒。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="8b40" class="nz mv it nu b gy oa ob l oc od">req.setRetryPolicy(new DefaultRetryPolicy(<br/>        1000, <br/>        DefaultRetryPolicy.DEFAULT_MAX_RETRIES, <br/>        DefaultRetryPolicy.DEFAULT_BACKOFF_MULT))</span></pre><p id="6fb1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它接受以下参数:</p><ul class=""><li id="2720" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated"><code class="fe nr ns nt nu b">Timeout</code> —指定每次重试的套接字超时，单位为毫秒</li><li id="1707" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated"><code class="fe nr ns nt nu b">Number Of Retries</code> —尝试重试的次数</li><li id="476e" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated"><code class="fe nr ns nt nu b">Back Off Multiplier</code> —一个乘数，用于确定为每次重试尝试设置到套接字的指数时间</li></ul><h2 id="c48c" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated"><code class="fe nr ns nt nu b">StringRequest</code></h2><p id="74e2" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">返回到<code class="fe nr ns nt nu b">MainActivity.java</code>并添加一个新功能。它接受一个字符串输入参数。让我们使用内置的<code class="fe nr ns nt nu b">StringRequest</code>来尝试一个简单的<code class="fe nr ns nt nu b">GET</code>调用。创建一个新的<code class="fe nr ns nt nu b">StringRequest</code>对象。将有两个侦听器事件，在这两个事件中，您成功地获得了响应或者请求失败了。通过<code class="fe nr ns nt nu b">addToRequestQueue</code>方法添加对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="5c1c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">调用<code class="fe nr ns nt nu b">ConnectURL</code>并传入一个有效的URL。您应该能够看到来自服务器的反馈。</p><h2 id="ace4" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated"><code class="fe nr ns nt nu b">JSONObjectRequest</code></h2><p id="375a" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">如果你要用JSON数据做一个<code class="fe nr ns nt nu b">POST</code>请求，你需要预先构造一个<code class="fe nr ns nt nu b">JSONObject</code>。在项目的顶部添加以下导入。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="5797" class="nz mv it nu b gy oa ob l oc od">import org.json.JSONException;<br/>import org.json.JSONObject;</span></pre><p id="2658" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建一个新函数并初始化一个<code class="fe nr ns nt nu b">JSONObject</code>。需要调用<code class="fe nr ns nt nu b">put</code>函数将数据插入其中。需要将其包装在一个try-catch块中，以捕获<code class="fe nr ns nt nu b">JSONException</code>错误。根据接受的<code class="fe nr ns nt nu b">POST</code>调用输入相应地修改数据。您甚至可以通过函数的输入参数传递它。其余的实现类似于<code class="fe nr ns nt nu b">StringRequest</code>，唯一的例外是在创建<code class="fe nr ns nt nu b">JsonObjectRequest</code>时传递<code class="fe nr ns nt nu b">jsonObj</code>变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="29c2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您可以通过调用<code class="fe nr ns nt nu b">ConnectURLJson</code>函数并传入一个有效的URL来测试它。</p><h2 id="6b4c" class="nz mv it bd mw oe of dn na og oh dp ne le oi oj ng li ok ol ni lm om on nk oo bi translated"><code class="fe nr ns nt nu b">JSONObjectRequest</code>带图像</h2><p id="be3e" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">发送图像数据有点棘手，需要转换成Base64格式。首先，从您的<code class="fe nr ns nt nu b">ImageView</code>或任何本地文件中获取相应的位图。将其转换为字节数组，并通过<code class="fe nr ns nt nu b">java.util.Base64</code>函数进行编码。它现在是字符串格式，您可以很容易地将其添加到<code class="fe nr ns nt nu b">JSONObject</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="f25c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">需要在服务器中将编码的字符串解码回正确的格式。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ad35" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">3.结论</h1><p id="b340" class="pw-post-body-paragraph kv kw it kx b ky nm ju la lb nn jx ld le no lg lh li np lk ll lm nq lo lp lq im bi translated">让我们回顾一下今天所学的内容。我们从一个简单的设置开始，在gradle文件中添加库。然后，我们在<code class="fe nr ns nt nu b">AndroidManifest.xml</code>中添加了所需的互联网权限。</p><p id="d04c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们创建了一个新的singleton类，它为我们添加各种类型的<code class="fe nr ns nt nu b">Request</code>提供了一个通用方法。</p><p id="5675" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在实现部分，我们尝试了三种不同的方法。第一个是使用<code class="fe nr ns nt nu b">StringRequest</code>的简单GET调用。接下来是接受一个<code class="fe nr ns nt nu b">JSONObject</code>的POST调用。最后，我们还尝试以Base64字符串的形式发送图像数据。</p><p id="e826" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读这篇文章。希望在下一篇文章中再见到你！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="79ac" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ul class=""><li id="07c9" class="ly lz it kx b ky nm lb nn le or li os lm ot lq md me mf mg bi translated"><a class="ae ku" href="https://developer.android.com/training/volley/" rel="noopener ugc nofollow" target="_blank">凌空的文档</a></li><li id="5c19" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated"><a class="ae ku" href="https://github.com/google/volley" rel="noopener ugc nofollow" target="_blank">凌空的GitHub </a></li></ul></div></div>    
</body>
</html>