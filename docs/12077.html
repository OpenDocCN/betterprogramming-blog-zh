<html>
<head>
<title>Environment Values as an Alternative to Dependency Injection in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">环境值作为SwiftUI中依赖注入的替代</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/environment-values-as-an-alternative-to-dependency-injection-in-swiftui-a9de89854afe?source=collection_archive---------4-----------------------#2022-05-10">https://betterprogramming.pub/environment-values-as-an-alternative-to-dependency-injection-in-swiftui-a9de89854afe?source=collection_archive---------4-----------------------#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f8d2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用环境价值观来避免不必要的身体重新评估，使我们的观点更加独立。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e0bfb5c7db831b0c7301fadb2c1c858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KuB9tQDDksMpDnJN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@pieterpanflute?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">皮特</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><blockquote class="kw kx ky"><p id="71c8" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">依赖注入是一个5美分概念的25美元术语。詹姆斯·肖尔</p></blockquote><p id="f49b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">依赖注入是一种奇特的说法，即我们将为一个对象提供它需要或依赖的对象来完成它的工作。</p><p id="8538" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在SwiftUI中，实现依赖注入的一种非常常见的方式是使用环境对象。通过将一个对象注入到我们的视图层次结构中，我们可以将逻辑和数据从视图中抽象出来并放入类中，从而允许我们遵循单一责任原则，并使我们的代码更具可测试性。</p><p id="5e61" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">举个例子，假设我们有一个包含几个属性的<code class="fe lz ma mb mc b">UserSettings</code>类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0d65" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了确保我们的<code class="fe lz ma mb mc b">View</code>可以访问我们的<code class="fe lz ma mb mc b">UserSettings</code>对象中的值，我们可以使用<code class="fe lz ma mb mc b">.environmentObject()</code>修饰符注入它，并使用<code class="fe lz ma mb mc b">@EnvironmentObject</code>属性包装器读取它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这可能看起来很熟悉。</p></figure><p id="9bc2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在这个例子中，<code class="fe lz ma mb mc b">ContentView</code>需要在<code class="fe lz ma mb mc b">UserSettings</code>中找到的两个值，但是我们正在创建一个更深的依赖关系，如果没有完整的<code class="fe lz ma mb mc b">UserSettings</code>对象，我们的视图<strong class="lc ir">将无法工作</strong>。</p><p id="06ff" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这有两个明显的缺点:</p><ol class=""><li id="ddf8" class="mf mg iq lc b ld le lg lh lw mh lx mi ly mj lv mk ml mm mn bi translated">首先，每当对象中的任何值改变时，视图的<code class="fe lz ma mb mc b">body</code>将被重新评估，即使改变的值不是这个特定视图使用的值。在我们的例子中，当<code class="fe lz ma mb mc b">soundsEnabled</code>改变时，我们的视图的<code class="fe lz ma mb mc b">body</code>将被重新评估，即使它没有在主体中使用。如果你碰巧使用这个方法来注入你的应用程序的状态，就像我过去所做的那样，这个对象可能包含许多值，这些值将触发你的视图层次结构中不必要的视图评估。</li><li id="20e1" class="mf mg iq lc b ld mo lg mp lw mq lx mr ly ms lv mk ml mm mn bi translated">第二，当预览一个依赖于环境对象的视图时，我们需要将环境对象注入到预览中，否则它将无法加载。更糟糕的是，任何将该视图显示为子视图的视图都需要在它们的预览中接收环境对象才能加载，尽管通过查看它们的<code class="fe lz ma mb mc b">body</code>，这一要求并不明显。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">还不如开始在你所有的预告片里注射。</p></figure><h1 id="45f3" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">自定义环境值</h1><p id="633e" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">与<code class="fe lz ma mb mc b">EnvironmentObjects</code>一样，<code class="fe lz ma mb mc b">EnvironmentValues</code>被注入到视图层次结构中，并传播到所有后代，直到它们被新值替换。它们是像<code class="fe lz ma mb mc b">.foregroundColor()</code>或<code class="fe lz ma mb mc b">.font()</code>这样的修改器使用的机制。</p><p id="5ae9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">最大的区别在于，要定义一个定制的环境值，您需要提供一个默认值<strong class="lc ir">。它需要更多的样板文件，但它有它的优势。</strong></p><p id="8852" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">要创建您自己的环境值，您需要创建一个环境键并扩展<code class="fe lz ma mb mc b">EnvironmentValues</code>；然后，您可以使用<code class="fe lz ma mb mc b">.environment()</code>修饰符将值插入到层次结构中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">您需要为每个值创建一个EnvironmentKey结构，并将其添加到EnvironmentValues类型中。</p></figure><h1 id="15c5" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">环境价值的价值注入</h1><p id="81d3" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">通过从一个特定的环境值中读取，我们的视图主体只有在该值改变时才会被重新评估。并且因为<code class="fe lz ma mb mc b">EnvironmentValues</code>总是有一个<code class="fe lz ma mb mc b">defaultValue</code>，这些视图可以被利用而不需要注入任何东西，这意味着你不需要修改你的预览。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d133" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">需要注意的重要一点是<code class="fe lz ma mb mc b">@Environment</code>属性是<em class="lb">只读的</em>。你可能已经注意到我在我的<code class="fe lz ma mb mc b">SettingsProvider</code>中注入了<code class="fe lz ma mb mc b">UserSettings</code>，这是因为任何需要修改值的视图，比如本例中的<code class="fe lz ma mb mc b">SettingsView</code>，仍然需要读取整个对象。</p><h1 id="51b7" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">不仅仅是用户设置</h1><p id="ff12" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">到目前为止，我一直使用简单的值作为例子，但当用各种数据填充我们的应用程序的视图时，这种技术会很有用。</p><p id="b8d6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">假设我们正在构建一个应用程序，该应用程序以不同的方式和子集显示用户的交易。</p><p id="ac5c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果我们正在使用CoreData，我们可以在每个视图中使用一个带有相关查询的<code class="fe lz ma mb mc b">@FetchRequest</code>;如果我们从服务器获取数据，我们可以在每个视图上从网络获取所需的事务。</p><p id="8b20" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">然而，我更喜欢的选择是在层次结构中的一个非常高的级别注入事务，并在任何显示它们的视图中读取该值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="347f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">获取数据是留给读者的一个练习，但是一旦获取了事务，我们可以使用<code class="fe lz ma mb mc b">.environment</code>修饰符将它们注入到环境中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="99e6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">任何想要显示<code class="fe lz ma mb mc b">userTransactions</code>数组中的值的视图都可以从环境中读取该值，而不必自己获取任何值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="b601" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这使得我们的视图变得简单了许多，并且获取事务的逻辑不仅从<code class="fe lz ma mb mc b">View</code> <code class="fe lz ma mb mc b">struct</code>中移除，而且在视图层次结构的不同节点中。</p><h1 id="8a4d" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">结论</h1><p id="3a67" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">通过使用值注入，需要<em class="lb">对这些值进行只读</em>访问的视图将只在那些特定值改变时被刷新。</p><p id="9faa" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">因为环境值提供了一个<strong class="lc ir">缺省值</strong>，我们不再需要为使用它们的视图的预览注入依赖关系。</p><p id="66cb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">使用环境对象的依赖注入在需要对对象的属性进行写访问的视图中仍然有它的位置。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h2 id="87f9" class="nx mu iq bd mv ny nz dn mz oa ob dp nd lw oc od nf lx oe of nh ly og oh nj oi bi translated">继续阅读</h2><p id="65a6" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">在我的上一篇文章中，我探索了使用<code class="fe lz ma mb mc b">EnvironmentValues</code>创建一个响应链，允许我们遵循一种“开火并忘记”的方法来行动，以便使我们的观点更加独立。</p><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/building-a-responder-chain-using-the-swiftui-view-hierarchy-2a08df23689c"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">使用SwiftUI视图层次结构构建响应者链</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">利用环境价值轻松响应视图层次结构中生成的事件</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">better编程. pub</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kp om"/></div></div></a></div></div></div>    
</body>
</html>