<html>
<head>
<title>Bit Manipulation — Playing With the Truth (Part One)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比特操纵——玩弄真相(第一部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bit-manipulation-playing-with-the-truth-part-1-e4740466d3b1?source=collection_archive---------7-----------------------#2019-07-21">https://betterprogramming.pub/bit-manipulation-playing-with-the-truth-part-1-e4740466d3b1?source=collection_archive---------7-----------------------#2019-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e49c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解和实现与或真值表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39753e3586cc50191d7bdf8ebecde11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGeNCXSd4Deyuu_B4g1LjQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jefflssantos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰佛森·桑多斯</a>在<a class="ae ky" href="https://unsplash.com/search/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解位操作的第一步是了解真相…就像在真值表中一样。</p><p id="ec80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，太好了，就一张桌子？不…不是一个，但是为了这篇文章，我们将讨论两个— <code class="fe lv lw lx ly b">AND</code>和<code class="fe lv lw lx ly b">OR</code>。如果你想了解更多，请查看<a class="ae ky" href="https://www.csetutor.com/logic-gates-and-truth-table/" rel="noopener ugc nofollow" target="_blank">这篇</a> <a class="ae ky" href="https://www.csetutor.com/logic-gates-and-truth-table/" rel="noopener ugc nofollow" target="_blank">文章</a>。也就是说，让我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7005" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">和</strong></h1><p id="93f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这用<em class="nd"> &amp; </em>表示。本质上，这意味着当且仅当A和B都是1时，组合两个比特A和B将仅给出1 <em class="nd"> </em> <strong class="lb iu">的结果。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e0ebf5e3e9cf4138de80634f3c8ecd91.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*A05IT58kOsoNenlZttS9fw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">还有真值表(<a class="ae ky" href="http://bit.ly/32GjG1m" rel="noopener ugc nofollow" target="_blank">http://bit.ly/32GjG1m</a>)</p></figure><p id="116b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助上表，很容易确定两个整数之间按位AND运算的结果。例如，为了得到12 &amp; 4的结果，将两个整数都转换成二进制表示。</p><p id="cdaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">12=1100</p><p id="08a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">4=100</p><p id="0798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯。12有四位，4有三位。让它们等长总是很酷的。为此，我们用零填充较小的位数，使它们相等。所以:</p><p id="67f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">4=0100.</p><p id="a5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然它们的长度相等，我们现在可以找到按位AND:</p><p id="ca7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1100<strong class="lb iu"><em class="nd"><br/></em></strong>&amp;<strong class="lb iu"><em class="nd"><br/></em></strong>0100<br/>—<br/>0100</p><p id="3854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从每个整数的最右位开始，查看上表以查看相应的值。所以0&amp;0=0，0&amp;0=0，1&amp;1=1，1&amp;0=0。<br/>所以，最后的结果是0100，也就是4。即12 &amp; 4=4。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6bff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">或</strong></h1><p id="3857" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这由<strong class="lb iu"> | </strong>表示。这表示如果 A或B中至少有一个为1，则组合两个位A和B将仅给出1 <strong class="lb iu">的结果。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8e17705668544388b73dab1c52ae29e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*qaYKXB4Qmo-6AjadCTCU7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">还是真值表(<a class="ae ky" href="http://bit.ly/32GjG1m" rel="noopener ugc nofollow" target="_blank">http://bit.ly/32GjG1m</a>)</p></figure><p id="ffc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上表的帮助下，很容易确定两个整数之间的按位OR运算的结果。</p><p id="ef5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，要计算13|3的结果，请将两个整数都转换为二进制表示。</p><p id="95ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">13=1101</p><p id="b49b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">3=11</p><p id="35df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">填充后:</p><p id="b282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">3=0011.</p><p id="8082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们找到按位OR:</p><p id="10eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1101<strong class="lb iu"><em class="nd"><br/></em></strong>|<strong class="lb iu"><em class="nd"><br/></em></strong>0011<br/>——<br/>1111</p><p id="41f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从每个整数的最右位开始，查看上表以查看相应的值。所以1|1=1，0|1=1，1|0=1，1|0=1。<br/>所以，最后的结果是1111，也就是15。即13|3=15。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="eb39" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">你可能会问，这有什么用…</h1><p id="7845" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设您被要求编写一个<code class="fe lv lw lx ly b">function</code>,它接收一个字符串并返回由以下标签包围的修饰字符串:<code class="fe lv lw lx ly b">&lt;i&gt;</code>、<code class="fe lv lw lx ly b">&lt;b&gt;</code>和<code class="fe lv lw lx ly b">&lt;u&gt;</code></p><h2 id="e539" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">选项一</h2><p id="3cf6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以决定写一个函数，考虑它的签名中的所有标签。所以，我们有这样的东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c12b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上功能运行良好。但是它的挑战是，当传递参数给函数时，你必须记住每个标签的位置。</p><p id="62c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，假设您只想给文本加下划线。你将不得不这样做:<code class="fe lv lw lx ly b">decorateString("Hello", false, false, true)</code>。任何阅读这段代码的人(除了你)都必须查找这个函数才能知道什么是假，什么是真。</p><h2 id="820a" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">选择二</h2><p id="9c97" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">嗯……算法部长，你知道你不必用Javascript那样写你的函数。您可以将第二个参数设为<code class="fe lv lw lx ly b">Object </code>并将<em class="nd">析构为</em>以获得可用的值并相应地使用它。所以你有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="24e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这要好得多，因为我不必记住顺序，只需指定我想要的。但是我没有使用Javascript。还有其他选择吗？</p><h2 id="a4bc" class="ng mh it bd mi nh ni dn mm nj nk dp mq li nl nm ms lm nn no mu lq np nq mw nr bi translated">选项三</h2><p id="5676" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是啊！使用bits作为配置(BaC)！让我们同意一位代表一面旗帜。当该位为1时，标志向上，当该位为0时，标志向下。现在，每个标签将在某个位置用一个标志来表示。我们可以将每个标签定义如下(二进制):</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="1881" class="ng mh it ly b gy ny nz l oa ob"><em class="nd">includeITag =  001</em> <br/><em class="nd">includeBTag = 010 </em><br/><em class="nd">includeUTag = 100</em></span><span id="6598" class="ng mh it ly b gy oc nz l oa ob">// 001 = 1, 010 = 2, 100 = 4</span></pre><p id="6f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用该函数将如下所示:</p><p id="66af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅包含I标签:<code class="fe lv lw lx ly b">decorateString("Hello", 1)</code></p><p id="e9b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅包含B标签:<code class="fe lv lw lx ly b">decorateString("Hello", 2)</code></p><p id="0150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅包含U标签:<code class="fe lv lw lx ly b">decorateString("Hello", 4)</code></p><p id="98af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错，但是我必须记住这些数字，对吗？</p><p id="e8ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不会。这些值将被定义为包含这个函数的类/文件中的常量，所以你不必记住它们。</p><p id="a6f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，没有办法一起使用两个标签。为了使字符串包含I和B标签，我们需要设置两个标志…即<code class="fe lv lw lx ly b">011</code>。为了让这三个标签出现，我们需要<code class="fe lv lw lx ly b">111</code>。</p><p id="016a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要为所有可能的标签组合定义值吗？不。你只创建你需要的并生成组合。这就是使用|操作符的地方。</p><p id="7369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">include tag = 001<br/>|<br/>include tag = 010<br/>———011</p><p id="955f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们现在可以像这样调用函数:</p><p id="788c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅包括I和B标签:<code class="fe lv lw lx ly b">decorateString("Hello", includeITag | includeBTag)</code></p><p id="8962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包含三个标签:<code class="fe lv lw lx ly b">decorateString("Hello", includeITag | includeBTag | includeUTag)</code></p><p id="0356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以是任何顺序。</p><p id="185f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，在实现函数时，如何从输入中提取这些值呢？通过检查是否设置了标志！这就是&amp;运算符的用武之地。</p><p id="8872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果索引I处的某个位被置位，则检查该整数，<code class="fe lv lw lx ly b">bitwise AND</code>用它来检查索引的2^i值。如果结果不为0，则设置该位，否则不设置该位。</p><p id="4310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如给定<code class="fe lv lw lx ly b">1101</code>，检查索引1处的位是否置位，2 = 2。</p><p id="86bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此:</p><p id="eb4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1101<br/>&amp;<br/>0010<br/>—<br/>0000</p><p id="5121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于该值为0，因此索引1处的位不会置位。因此，索引1处的标志没有被设置。</p><p id="59ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，给定1011，检查索引1处的位是否被设置，2 = 2。</p><p id="7cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此:</p><p id="f01c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1011<br/>&amp;<br/>0010<br/>—<br/>0010</p><p id="5d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于结果不为0，这意味着设置了索引1处的位。</p><p id="3ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解了这一点，让我们来实现我们的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="be4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以在任何编程语言中实现，而无需使用析构或传递一长串参数。</p><p id="9027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的用例是在Android中启动新活动时设置标志:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="40ff" class="ng mh it ly b gy ny nz l oa ob">myIntent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION|Intent.FLAG_ACTIVITY_CLEAR_TOP);</span></pre><p id="c8cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有什么要补充的，请写在评论里。</p><p id="4317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二部分中，我们将讨论移位以及如何使用它。在那之前，一点一点地享受你的生活。</p></div></div>    
</body>
</html>