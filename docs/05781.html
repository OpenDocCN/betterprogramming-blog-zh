<html>
<head>
<title>Converting an Angular App to React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转换角度应用程序以做出反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angularjs-react-one-component-at-a-time-4e39c0b14916?source=collection_archive---------9-----------------------#2020-08-05">https://betterprogramming.pub/angularjs-react-one-component-at-a-time-4e39c0b14916?source=collection_archive---------9-----------------------#2020-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一次一个组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1c7dbb98a293e0eed4966a76eb47025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0OQuoFbWyGtU6M0g"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@bepnamanh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">南安</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="aa30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你如何吃掉一头大象？希望你对此没有答案。但是如果一个巨大的、传统的AngularJS是你的<em class="ls">隐喻</em>大象，那么我想分享一个我最近使用的方法，至少是朝着现代框架的方向迈出了一步。</p><p id="b439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们今天将使用的工具是<a class="ae kv" href="https://github.com/ngReact/ngReact" rel="noopener ugc nofollow" target="_blank">n React</a>，这是一个库，允许您将新的React组件转换为Angular指令，以便在旧的(我的用例是angular@1.3)应用程序中使用。</p><p id="26bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的AngularJS应用程序由未编译的静态资产组成，由一个Spring Boot应用程序提供服务，该应用程序也充当后端。用户点击该站点并检索<code class="fe lt lu lv lw b">index.html</code>及其所有指定的资源。</p><p id="3ebd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，这并不理想。JavaScript没有“构建过程”。依赖性管理是困难的。我说过它的角度是1.3吗？但是不要陷入简单地批评现有事物的陷阱。我们真正想要的(我们的问题陈述)是能够在现代web开发框架中创建新功能。</p><ul class=""><li id="2a50" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">选项1是完全重写应用程序。虽然大多数公司没有时间和/或资源来实施这一方案，但至少应该予以考虑。</li><li id="fe60" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">选项2是在新的框架中创建一个单独的应用程序，两者都提供服务。我会考虑在新的框架中运行传统的应用程序(反之亦然)也属于这一类。这种选择有几个复杂之处。一种是从一个“侧面”到另一个侧面——这通常很简单。下一步是复制任何现有的公共服务(例如，将请求变异到后端的<code class="fe lt lu lv lw b">apiService</code>拦截器)。所有这些可能都必须在新的框架中重新创建。</li><li id="db1a" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">选项3是使用一个库来获取用新框架编写的组件，并将它们“翻译”成遗留应用程序可以理解的东西。这种方法允许你一步一步来。你在一个现代的框架中编写新的特性并修复bug，直到足够多的代码库被转换，这才是有意义的。</li></ul><p id="d7b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在研究转换angular 1.x反应的最佳方式之前，我不认为我知道第三种选择。有几个库能够执行这个功能，但是我最终选择了<a class="ae kv" href="https://github.com/ngReact/ngReact" rel="noopener ugc nofollow" target="_blank">n react</a>。该库的工作方式是获取一个React组件，并将其转换为AngularJS指令。值得注意的是，ngReact将允许你传递任何你可以作为依赖注入的东西(比如一个角度服务)作为你的组件的道具，所以在你准备好之前没有必要重写你的<code class="fe lt lu lv lw b">apiService</code>。</p><p id="222b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们对上面描述的应用程序进行一些修改，替换几个页面上的<code class="fe lt lu lv lw b">Breadcrumb</code>元素:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/854c129adc117bfbc5a7ea7acad103b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*6loTPhSAjaCs8zYSZuaUjA.png"/></div></figure><p id="888b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，在我们的AngularJS应用程序的入口点，我们将添加两个新模块:</p><ul class=""><li id="72ed" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">应用程序的注入依赖项:<code class="fe lt lu lv lw b">react</code>。</li><li id="938d" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">一个单独的模块，作为所有新的React组件指令的声明点。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据现有应用程序中管理依赖关系的方式，下一部分看起来会有所不同。在本例中，我们已经将新的<em class="ls">外部</em>依赖项(<code class="fe lt lu lv lw b">react</code>、<code class="fe lt lu lv lw b">react-dom</code>和<code class="fe lt lu lv lw b">ngReact</code>)的缩小模块放在了<code class="fe lt lu lv lw b">lib</code>目录下的应用程序中。<code class="fe lt lu lv lw b">react-components.js</code>将是我们新指令的上述声明点。<code class="fe lt lu lv lw b">dist/bundle.js</code>根据应用程序的构建配置，可能看起来有所不同，但在本例中，它是React组件的webpacked输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将使用ngReact向我们的angularJS应用程序注册一个指令，转换新的React组件。<code class="fe lt lu lv lw b">reactDirective</code>函数有四个参数:</p><ol class=""><li id="fa03" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mo md me mf bi translated">与稍后将声明的组件的AngularJS <code class="fe lt lu lv lw b">value</code>匹配的字符串。</li><li id="3f55" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mo md me mf bi translated">组件使用的属性数组，当在HTML中使用时，将传递给指令。</li><li id="7e98" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mo md me mf bi translated">一个配置对象，用于覆盖指令的一些默认行为(<a class="ae kv" href="https://github.com/ngReact/ngReact#the-reactdirective-service" rel="noopener ugc nofollow" target="_blank">参见文档</a>)。</li><li id="56ef" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mo md me mf bi translated">任何有角度的可注入物(服务等。)您希望在您的组件中使用它。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="19ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并使用新的指令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dd85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件<code class="fe lt lu lv lw b">Breadcrumb</code>的实现并不令人惊讶。请注意我们是如何使用Angular <code class="fe lt lu lv lw b">navService</code>的，就像我们可能将道具传递给组件的任何其他模块一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="65e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，对于每个组件指令，我们还将注册一个角度<code class="fe lt lu lv lw b">value</code>(我们在上面将其用作<code class="fe lt lu lv lw b">reactDirective</code>函数的第一个参数)。你可以在应用程序的任何地方这样做，但我选择在<code class="fe lt lu lv lw b">react-components/index.js</code>这样做，我也将把它作为我的webpack入口点。当我添加额外的组件指令时，我将为它们重用这个文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>