<html>
<head>
<title>Evolution of Collection Types in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift收藏类型的演变</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/evolution-of-collection-types-in-swift-a409c15067b5?source=collection_archive---------11-----------------------#2020-12-14">https://betterprogramming.pub/evolution-of-collection-types-in-swift-a409c15067b5?source=collection_archive---------11-----------------------#2020-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d54e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解使数组、字典和集合工作的协议</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4edc75c84dd4ddd48a179843b0d37982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*is5nq9I5ZMCQ-KMm"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">苏珊·d·威廉姆斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8fc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift中的三种主要收款类型— <code class="fe ls lt lu lv b">Array</code>、<code class="fe ls lt lu lv b">Dictionary</code>和<code class="fe ls lt lu lv b">Set</code> —无需介绍。但是，如果您曾经探索过其中任何一个的协议一致性层次，您可能会注意到它可能相当长，而且似乎过于复杂。例如，对于<code class="fe ls lt lu lv b">Array</code>，它可能看起来像下面这样(由于多个协议一致性，可以有多个路径，这不是最长的一个):</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7f31" class="ma mb iq lv b gy mc md l me mf">Sequence &lt;- Collection &lt;- MutableCollection &lt;- Array</span></pre><p id="76d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Array</code>可用的大多数方法和属性都分布在这些协议上。但是<code class="fe ls lt lu lv b">Array</code>的功能有这么多成熟阶段有什么意义呢？让我们从头开始，弄清楚每个阶段都引入了哪些新的语义和新的API。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f844" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">顺序</h1><p id="be6f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">作为所有集合类型的根协议，<code class="fe ls lt lu lv b">Sequence</code>可以说是一个原型集合，它只包含基本的雏形，可以发展成更多的东西。顾名思义，<code class="fe ls lt lu lv b">Sequence</code>建模了一个值列表，您可以一次一个地按顺序遍历它。任何<code class="fe ls lt lu lv b">Sequence</code>必须实现的唯一方法是<code class="fe ls lt lu lv b">makeIterator()</code>，它返回<code class="fe ls lt lu lv b">IteratorProtocol</code>的一个实例——与<code class="fe ls lt lu lv b">Sequence</code>协议相关的类型。</p><p id="c6e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">IteratorProtocol</code>又有唯一需要的方法<code class="fe ls lt lu lv b">next()</code>，每次调用它时返回下一个元素，如果没有下一个元素，则返回nil。顺便说一下，你可以让你的自定义类型同时符合<code class="fe ls lt lu lv b">Sequence</code>和<code class="fe ls lt lu lv b">IteratorProtocol</code>。然后你只需要实现<code class="fe ls lt lu lv b">next()</code>，而<code class="fe ls lt lu lv b">makeIterator()</code>会被自动推断出来。这个非常简单的机制正是一个<code class="fe ls lt lu lv b">for-in</code>循环所利用的。因此，如果你正在<code class="fe ls lt lu lv b">for</code>循环某个东西，这个东西就是<code class="fe ls lt lu lv b">Sequence</code>。<code class="fe ls lt lu lv b">for-in</code>句法当然不是必要的；你可以显式地使用迭代器。</p><p id="b566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，严格地说，<code class="fe ls lt lu lv b">Sequence</code>不一定包含某种元素的列表；相反，它代表了某种抽象的能力，可以动态地连续生成它们。例如，您可以创建序列<code class="fe ls lt lu lv b">OddNumbers</code>，其<code class="fe ls lt lu lv b">Element</code>为<code class="fe ls lt lu lv b">Int</code>。第一个元素是1，每次调用<code class="fe ls lt lu lv b">next()</code>都会将前一个元素加2并返回。使用这个基本序列也让我想起在一些老式的环境中从文件中读取。您一点一点地阅读它，直到发现文件结束符号，这类似于调用<code class="fe ls lt lu lv b">iterator.next()</code>直到它返回<code class="fe ls lt lu lv b">nil</code>。</p><p id="6398" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这些基本的<code class="fe ls lt lu lv b">Sequence</code>看起来非常简单，但是它们足以开发成一个丰富和繁荣的API，可以免费用于任何序列。标准库为大量有用的操作提供了默认实现，从搜索(<code class="fe ls lt lu lv b">contains()</code>、<code class="fe ls lt lu lv b">first(where:)</code>等)开始。)并以<code class="fe ls lt lu lv b">filter</code>、<code class="fe ls lt lu lv b">map</code>和<code class="fe ls lt lu lv b">reduce</code>结尾——这些都是函数式编程的支柱。你也可以洗牌，反转，连接，分割你的序列，删除它的元素，提取前缀和后缀，等等。当然现在有了Combine，你可以免费为你的序列得到一个<code class="fe ls lt lu lv b">Publisher</code>。</p><p id="4ddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<code class="fe ls lt lu lv b">Sequence</code>协议有一个重要的免责声明:没有要求它是否会被迭代破坏性地消耗。也就是说，如果你已经在序列的一个实例上执行了一个<code class="fe ls lt lu lv b">for-in</code>循环，然后在同一个实例上开始另一个循环，你不能确定它是否会继续迭代，或者重新开始，或者什么都不做——你得到的行为是不确定的。如果您确实需要这样的非破坏性迭代，<code class="fe ls lt lu lv b">Collection</code>就在这里为您服务，我们将很快回到这个主题。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="47ab" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">收藏品</h1><p id="874a" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Collection</code>协议继承了<code class="fe ls lt lu lv b">Sequence</code><em class="nj"/>协议，增加了任何元素都可以通过其位置直接访问的要求，保证了对其元素更加精细和可控的管理。从语义上来说，集合模型是一个预定义的有限元素列表，每个元素都固定在一个特定的位置。它不像<code class="fe ls lt lu lv b">Sequence</code>那样有迭代的能力。</p><p id="12ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给你另一个例子，<code class="fe ls lt lu lv b">Sequence</code>可以被看作是你桌上的一堆文件，你只能从上到下浏览，检查每一项，直到你找到你要找的东西。相比之下，<code class="fe ls lt lu lv b">Collection</code>反映了一些扩展的文件夹，每个口袋上都有标签、书签，甚至还有目录，以便更快地查阅。</p><p id="eb86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，<code class="fe ls lt lu lv b">Collection</code>引入了指数的概念。它声明了定义索引界限的<code class="fe ls lt lu lv b">startIndex</code>和<code class="fe ls lt lu lv b">endIndex</code>属性，以及推进索引的<code class="fe ls lt lu lv b">index(after:)</code>方法。请注意，这些方法使索引适用于任意类型，而不一定适用于整数。<code class="fe ls lt lu lv b">Index</code>是<code class="fe ls lt lu lv b">Collection</code>协议的关联类型，对取代它的类型的唯一限制是<code class="fe ls lt lu lv b">Comparable</code>。最后，至少有一个只读的<a class="ae kv" href="https://developer.apple.com/documentation/swift/collection/1641358-subscript" rel="noopener ugc nofollow" target="_blank">下标</a>用于访问给定索引处的元素。而且可以认为是<code class="fe ls lt lu lv b">Collection</code>功能的基石。</p><p id="8a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<code class="fe ls lt lu lv b">Collection</code>声明并提供了下一批利用索引的现成API的默认实现。它不仅仅是通过索引访问，还包括前缀、后缀、切片、确定索引之间的距离等。甚至<code class="fe ls lt lu lv b">count</code>最早出现在<code class="fe ls lt lu lv b">Collection</code>。对于<code class="fe ls lt lu lv b">Sequence</code>，我们只有<code class="fe ls lt lu lv b">underestimatedCount</code>，根据定义，它小于或等于估计的元素数量，默认情况下是零。因为你永远不知道迭代器的<code class="fe ls lt lu lv b">next()</code>什么时候会返回最终的<code class="fe ls lt lu lv b">nil</code>。</p><p id="8d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">Sequence</code>相比，索引访问自然意味着将<code class="fe ls lt lu lv b">Collection</code>带到下一个级别的另一个需求。与我们对<code class="fe ls lt lu lv b">Sequence</code>所做的不同，符合<code class="fe ls lt lu lv b">Collection</code>的类型必须保证每次你用<code class="fe ls lt lu lv b">for-in</code>循环(或使用迭代器)遍历它时，迭代将重新开始，你将得到与上次相同的结果(当然，除非你没有在这两次循环之间修改它)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fa98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，第一个<code class="fe ls lt lu lv b">for-in</code>循环没有消耗数组的前两个元素。所以当你重新开始迭代时，它将从头开始。请记住，对于<code class="fe ls lt lu lv b">Sequence</code>，第二个循环的行为没有定义。还要注意另一种迭代<code class="fe ls lt lu lv b">Collection</code>的方法，除了从<code class="fe ls lt lu lv b">Sequence</code>继承的基本方法之外，还使用了索引和下标。</p><p id="9c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我在索引直接访问的能力和非破坏性、可重复遍历的需求之间的深层联系上多停留一会儿。从技术上讲，一些基本的索引访问不仅适用于<code class="fe ls lt lu lv b">Collection</code>，也适用于<code class="fe ls lt lu lv b">Sequence</code>。您可以声明一个单独的计数器，在每次迭代<code class="fe ls lt lu lv b">for-in</code>时进行递增和检查，并在它达到您想要的索引值时触发您需要的逻辑。</p><p id="0421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但且不说有多尴尬，这对于真实案例来说几乎完全不可用，那只是因为默认情况下<code class="fe ls lt lu lv b">Sequence</code>不能被重复遍历。通常情况下，如果索引是在之前的某个时间点保存的，就使用它，或者保存索引以备将来访问同一个元素。因此，这至少是一个两步过程——保存索引并以任何顺序使用索引——它假设您的对象列表足够持久和稳定，可以重复迭代。否则，即使技术上可以，也没有理由索引它。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d991" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">集合类型</h1><p id="6a11" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">到目前为止，我们主要讨论了协议结构和含义，但是让我们最终转向具体的集合类型。现在有了所有关于集合协议的神圣知识，您应该能够创建您的自定义类型，但是您可能不会。标准的(<code class="fe ls lt lu lv b">Array</code>、<code class="fe ls lt lu lv b">Dictionary</code>和<code class="fe ls lt lu lv b">Set</code>)是非常详尽的，经过很好的优化，在99.9%的情况下足够了。让我们看看它们是如何准确地被写入完整的收集协议层次结构的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/59ce74fcee2fd1e4c48796cea9e4c415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*re2OpwD94RebYdE-lzP5gw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集合类型家族树</p></figure><p id="45bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你现在所看到的，正如简介中所提到的，<code class="fe ls lt lu lv b">Array</code>通过一些过渡形式与<code class="fe ls lt lu lv b">Collection</code>协议相连。在这篇文章中，我们不会把重点全部放在它们上面，但是如果你想更深入地了解它们，你可以看看Ole Begemann的这篇<a class="ae kv" href="https://oleb.net/blog/2017/02/why-is-dictionary-not-a-mutablecollection/" rel="noopener ugc nofollow" target="_blank">伟大的文章</a>。但是这里让我们至少强调一些有趣的事情。</p><p id="7359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上图可以看出，<code class="fe ls lt lu lv b">Array</code>的一致性之一是<code class="fe ls lt lu lv b">MutableCollection</code>协议。嗯，这似乎一点也不违反直觉；当然<code class="fe ls lt lu lv b">Array</code>是可变的！但是如果你的第一个联想是像<code class="fe ls lt lu lv b">append()</code>，或者<code class="fe ls lt lu lv b">insert()</code>，或者<code class="fe ls lt lu lv b">remove()</code>这样的方法，那就不是这样了。事实是，<code class="fe ls lt lu lv b">MutableCollection</code>协议的文档假设改变其元素的值不应该影响<code class="fe ls lt lu lv b">Collection</code>的长度。但显然，<code class="fe ls lt lu lv b">append()</code>、<code class="fe ls lt lu lv b">insert()</code>和<code class="fe ls lt lu lv b">remove()</code>有，所以不在这个协议范围内。它们是在<code class="fe ls lt lu lv b">Array</code>本身中声明和实现的。那<code class="fe ls lt lu lv b">MutableCollection</code>呢？除了从<code class="fe ls lt lu lv b">Collection</code>继承的只读访问之外，主要是关于<code class="fe ls lt lu lv b">subscript</code>的写访问。顺便说一下，当我们讨论数组下标的时候，你可能会对我的前一篇文章感兴趣，这篇文章揭示了数组工作原理中隐藏的一个细节。</p><p id="ac9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也是为什么<code class="fe ls lt lu lv b">Set</code>实际上是可变的，绕过<code class="fe ls lt lu lv b">MutableCollection</code>并立即符合<code class="fe ls lt lu lv b">Collection</code>。但是<code class="fe ls lt lu lv b">Dictionary</code>呢？它确实有一个<a class="ae kv" href="https://developer.apple.com/documentation/swift/dictionary/2885650-subscript" rel="noopener ugc nofollow" target="_blank">下标</a>来设置键的值，替换之前的值，因此不会影响大小。那么，这有什么问题呢？</p><p id="6228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，这里出现了另一个微妙之处，是时候更仔细地看看字典的<code class="fe ls lt lu lv b">Index</code>了。这个乍一看有点纠结，但是<code class="fe ls lt lu lv b">Dictionary</code>里的<code class="fe ls lt lu lv b">Key</code>和<code class="fe ls lt lu lv b">Collection.Index</code>没有关系，就像<code class="fe ls lt lu lv b">Value</code>和<code class="fe ls lt lu lv b">Sequence.Element</code>完全没有关系一样。所以如果你声明，比如说，<code class="fe ls lt lu lv b">Dictionary&lt;Int, String&gt;</code>，它的<code class="fe ls lt lu lv b">Key</code>会是<code class="fe ls lt lu lv b">Int</code>，它的<code class="fe ls lt lu lv b">Value</code>是<code class="fe ls lt lu lv b">String</code>，它的<code class="fe ls lt lu lv b">Element</code>是元组<code class="fe ls lt lu lv b">(key: Int, value: String)</code>。</p><p id="44bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而<code class="fe ls lt lu lv b">Index</code>呢？它是一个<a class="ae kv" href="https://developer.apple.com/documentation/swift/dictionary/index" rel="noopener ugc nofollow" target="_blank">单独的结构</a>，在字典中内部声明，在我们的例子中是<code class="fe ls lt lu lv b">Dictionary&lt;Int, String&gt;.Index</code>。这个结构基本上保存了所有与哈希相关的东西，这些东西是<code class="fe ls lt lu lv b">Dictionary</code>的内部实现成为哈希表所依赖的。顺便说一下，类似的东西也适用于<code class="fe ls lt lu lv b">Set.Index</code>，我们也很少直接使用。</p><p id="276e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，key和值是特定于<code class="fe ls lt lu lv b">Dictionary</code>的东西，它们属于它的实现，而不属于<code class="fe ls lt lu lv b">Collection</code>协议的实现。因此，广泛使用的<code class="fe ls lt lu lv b">Dictionary</code>的get-set <code class="fe ls lt lu lv b">subscript(Key)-&gt;Value?</code>与<code class="fe ls lt lu lv b">Collection</code>协议要求的只读<code class="fe ls lt lu lv b">subscript(Index) -&gt; Element</code>没有任何关系。当然，后者对于<code class="fe ls lt lu lv b">Dictionar</code>来说也还在发挥作用，你可以很好地使用它(以及其他所有继承了<code class="fe ls lt lu lv b">Collection</code>的<code class="fe ls lt lu lv b">Index</code>的操作)。但这不是我们通常会做的，因为<code class="fe ls lt lu lv b">Key</code>和<code class="fe ls lt lu lv b">Value</code>是为了让我们的生活更轻松。下面是总结所有这些的一小段代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5686" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一句，如果你想知道为什么<code class="fe ls lt lu lv b">Dictionary</code>的下标是可选的，而<code class="fe ls lt lu lv b">Array</code>的显然等价的下标不是可选的，那么你已经得到了答案——它们是不等价的。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="68b5" class="mn mb iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">序列与集合——主题的更多变化</h1><p id="a741" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">如果你还没有被上面的内容搞得不知所措，让我分享一些关于<code class="fe ls lt lu lv b">Sequence</code>和<code class="fe ls lt lu lv b">Collection</code>协议的相似和不同之处的推测。希望你能从接下来的章节中模糊的指控中获得一些实际的收获。</p><p id="dcc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于语义不同，这些协议也提供了性质稍有不同的操作。这在符合两种协议的每个具体集合类型的API之间创建了一定的角色划分。在设计自己的涉及集合的API时，感觉某种方法或属性更适合哪种协议可能会有所帮助。尽管在大多数实际情况下，你可以指定一个具体的类型，但有时你必须减少限制，使用<code class="fe ls lt lu lv b">Collection</code>，或者甚至减少限制，使用<code class="fe ls lt lu lv b">Sequence</code>，这取决于在这个特定的范围内，他们的API的哪个行为或部分是预期的或必要的。毕竟，让你的API尽可能的通用是一个很好的实践，如果明智的使用，它永远不会有坏处。</p><p id="136c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，你可能已经猜到，一般的经验法则是，当你对某些元素的位置有所了解或者需要获得这些知识以备将来使用时，主要使用<code class="fe ls lt lu lv b">Collection</code>，而如果你可以从头开始浏览所有元素，那么<code class="fe ls lt lu lv b">Sequence</code>就足够了。</p><p id="fce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这里有一些进一步的思考。请注意，<code class="fe ls lt lu lv b">Sequence</code>上最典型的操作涵盖了将众多元素作为一个整体来处理的情况，比如用<code class="fe ls lt lu lv b">map</code>将其全部转换，用<code class="fe ls lt lu lv b">reduce</code>将其全部消化，用<code class="fe ls lt lu lv b">filter</code>将其浓缩，等等。即使当你搜索<code class="fe ls lt lu lv b">Sequence</code>的单个元素时(例如，用<code class="fe ls lt lu lv b">first(where:)</code>)，在内部它仍然逐个测试它们，所以它通常仍然作为一个列表与它们交互。</p><p id="c1d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从数学上来说(以防万一你也喜欢把简单的事情复杂化)，这样的操作实际上是输入是一个元素列表，输出也是一个元素列表的函数。这只是一种特殊的情况，结果可能碰巧是一个空列表，或者它被强制修剪为只有一个元素。例如，<code class="fe ls lt lu lv b">first(where:)</code>是访问序列中某个元素的主要方法，它只是<code class="fe ls lt lu lv b">filter(where:)</code>的精简版本。如果过滤的结果是一个空列表，它将丢弃过滤结果中除第一个元素之外的所有元素，或者返回<code class="fe ls lt lu lv b">nil</code>。并且，让我们说，<code class="fe ls lt lu lv b">contains(where:)</code>只是另一种方式来说明检索到的元素列表的大小是否大于零。</p><p id="42b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相比之下，<code class="fe ls lt lu lv b">Collection</code>的根本目的是给出一个明确而有保证的结果。索引下标是<code class="fe ls lt lu lv b">Collection</code>API的核心，它提供了一个且只有一个元素。如果没有这样的单一元素，它就会崩溃。所以它不是可选的，不像<code class="fe ls lt lu lv b">Sequence</code>的大多数语义对应的方法。这代表了从一系列元素到一个单一且必须的元素的投影的数学思想。同样，这不是一个严格的规则或定义，而更像是试图找到一些模式和规律。</p><p id="6f2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个要再次提到的区别是，只有使用<code class="fe ls lt lu lv b">Collection</code>你才能首先获得知道它的元素数量<em class="nj">的能力。</em>用<code class="fe ls lt lu lv b">Sequence</code>是不可能的，因为你永远不知道它上面的迭代什么时候会到达最后一个元素。出于同样的原因，要知道<code class="fe ls lt lu lv b">Sequence</code>在概念上是无限的，所以遍历它和使用它的大部分方法(内部仍然包含遍历)都不太安全。迭代器的<code class="fe ls lt lu lv b">next()</code>方法可能会一直返回非零值，直到时间结束。当使用标准库中的序列时，你不太可能遇到这种情况，但是当处理一个未知的序列时，你不能100%确定你不会陷入某个方法中。</p><p id="1f81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来你唯一可以依赖的方法是那些处理有限前缀的方法(比如<code class="fe ls lt lu lv b">dropFirst(Int)</code>和<code class="fe ls lt lu lv b">prefix(Int)</code>)。顺便说一下，不知道序列的大小还会阻止您访问最后一个元素和任何包含后缀的逻辑。(好吧，坦白说，<code class="fe ls lt lu lv b">Sequence</code>里还是有<code class="fe ls lt lu lv b">suffix()</code>和<code class="fe ls lt lu lv b">dropLast()</code>的方法，但是它们需要刻意限制接收者为有限的，在这里理论上有些不协调)。</p><p id="2b8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天最后要提到的是性能。除非另有说明，<code class="fe ls lt lu lv b">Sequence</code>必须提供不差于O(n)中的元素，而<code class="fe ls lt lu lv b">Collection</code>必须使<em class="nj"> </em>达到最高的O(1)，这是索引访问的另一个优点。然而，性能-内存权衡的伟大定律预测<code class="fe ls lt lu lv b">Collection</code>在内存方面更昂贵。当然，这一切都取决于具体的实现，但是作为一个概念，是的，这来自于重复访问的需求。这是一种松散的类比，但是<code class="fe ls lt lu lv b">Collection</code>可以被认为更面向状态(事实上，处理索引意味着保存状态)，而<code class="fe ls lt lu lv b">Sequence</code>更符合函数式方法。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="e305" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">呼，这就是我想告诉你的。如果你跟踪了这么远，我应该为能让你注意这么久而感到骄傲！在评论中分享你的想法和问题。感谢您的阅读，下次再见。</p></div></div>    
</body>
</html>