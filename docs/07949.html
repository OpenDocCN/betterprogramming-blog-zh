<html>
<head>
<title>Apply These 4 Techniques To Write Concise Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用这4种技术来编写简洁的Python代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/apply-these-4-techniques-to-write-concise-python-code-9298458fbb2e?source=collection_archive---------3-----------------------#2021-03-09">https://betterprogramming.pub/apply-these-4-techniques-to-write-concise-python-code-9298458fbb2e?source=collection_archive---------3-----------------------#2021-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d861" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python的方式编写Python代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/721f1b5df4eddf8f5a144fea2992a79f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3z9C4VwTP3vgg1mB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的缺口处</a>拍摄。</p></figure><p id="9fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何编程项目的一个重要目标都与可维护性有关。无论项目的规模有多大，您总是希望有一个可维护的代码库，以便在项目的长期维护阶段不会浪费您或您的团队成员的时间。因此，当我们在项目中工作时，我们必须牢记可维护性。</p><p id="de6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提高项目可维护性的一个重要方法是编写简洁的代码——有几个原因。第一，一般来说，简洁的代码可读性更强，更容易让你的队友理解。第二，简洁的代码意味着代码更少，更不容易出现bug。</p><p id="9a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想分享一些Python特性，这些特性允许您编写更简洁的Python代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cef7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.在for循环中使用枚举</h1><p id="ed62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们使用<code class="fe mz na nb nc b">for</code>循环来避免为相同的工作编写重复的代码。在许多情况下，我们希望记录iterable中项的位置。下面向您展示了wordy版本的两种可能的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无需列举</p></figure><ul class=""><li id="2c2f" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">第一个<code class="fe mz na nb nc b">for</code>循环涉及到使用<code class="fe mz na nb nc b">index()</code>方法来定位项目的位置，这可以通过访问列表来直接检索。</li><li id="725a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第二个<code class="fe mz na nb nc b">for</code>循环涉及到使用<code class="fe mz na nb nc b">range()</code>函数来创建一个iterable，该iterable产生项目的索引。我们用这个来找回物品。</li></ul><p id="dc1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两个版本中，我们必须分别获取条目和索引。然而，这两条信息可以一起生成。以下代码向您展示了一个更简洁的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带枚举</p></figure><ul class=""><li id="3f7d" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">enumerate()</code>将list作为它的第一个参数，这将产生一个迭代器，每个条目作为一个tuple对象。</li><li id="cc8c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">元组对象由两项组成:计数器(或“索引”)和项。在示例中，我们使用解包来直接访问这两个项目。</li><li id="cb86" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">计数器从哪个数字开始由<code class="fe mz na nb nc b">enumerate()</code>函数的第二个参数决定。在示例中，我们将值设置为<code class="fe mz na nb nc b">1</code>，这意味着我们希望从<code class="fe mz na nb nc b">1</code>开始计数。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2646" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.检查容器是否空</h1><p id="410b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，我们经常将元组、列表、字典和集合称为数据容器，因为所有这些数据类型都可以将其他对象作为它们的项目。值得注意的是，所有这些容器都允许有零个项目。因此，当我们处理这些数据容器时，我们经常需要在进行任何操作之前检查它们是否有任何条目。</p><p id="113d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以列表对象为例，但同样的原则也适用于其他数据类型。</p><p id="87db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码向您展示了wordy版本的可能实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查空性(罗嗦)</p></figure><ul class=""><li id="da64" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">第一个例子使用了<code class="fe mz na nb nc b">len()</code>函数，它检查列表中的项目数量。当它的长度大于<code class="fe mz na nb nc b">0</code>时，这意味着列表不是空的。</li><li id="afdc" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第二个示例将获取的列表对象与一个空列表进行比较。因为如果获取的列表不等于空列表，列表对象就按值进行比较，所以它不是空的。</li></ul><p id="184c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段向您展示了一个更简洁的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">止空(简洁)</p></figure><p id="7789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码利用了Python将空列表评估为<code class="fe mz na nb nc b">False</code>，将非空列表评估为<code class="fe mz na nb nc b">True</code>的事实。更广泛地说，这种评估也适用于其他容器，包括元组、字典和集合。作为一个旁注，这也适用于字符串的求值，当它们不是空字符串时是真的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ddf2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用命名元组作为数据容器</h1><p id="f02a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您的项目涉及读取数据，并且这些数据具有相同的结构，您可以考虑使用数据容器来帮助您访问数据的单个元素。假设一个数据单元包含客户的三条信息:姓名、年龄和性别。下面向您展示了一个冗长版本的一些可能的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据容器(冗长)</p></figure><ul class=""><li id="2eb6" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们可以用字典来代表每个客户。然而，我们可能会拼错一些键，导致<code class="fe mz na nb nc b">KeyError</code>异常。</li><li id="681f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们还可以创建一个自定义类来管理客户端信息。但是，正确维护一个类对象和单个对象的内存消耗需要额外的开销。</li></ul><p id="18c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只需要一个数据容器来保存数据，并且大部分操作都是读取数据，那么我们可以考虑使用命名元组作为轻量级的数据容器。下面的代码向您展示了这样一个实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">命名元组(简明)</p></figure><ul class=""><li id="99c4" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">namedtuple</code>是在<code class="fe mz na nb nc b">collections</code>模块中可用的工厂功能。之所以称之为工厂函数，是因为该函数创建了一种新的数据类型，它是元组的子类型，如下所示:</li></ul><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="a4ee" class="nx md it nc b gy ny nz l oa ob">&gt;&gt;&gt; type(Client)<br/>&lt;class 'type'&gt;<br/>&gt;&gt;&gt; issubclass(Client, tuple)<br/>True</span></pre><ul class=""><li id="923f" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">在<code class="fe mz na nb nc b">namedtuple</code>函数中，我们将类名作为第一个参数传递，将属性(由空格分隔的字符串或字符串列表)作为第二个参数传递。</li><li id="ecd5" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当我们创建<code class="fe mz na nb nc b">Client</code>类的实例时，我们可以使用与常规定制类相同的实例化方法。</li><li id="ae6a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">更重要的是，我们可以使用相同的点符号来访问元组对象的“属性”，就像自定义类对象一样，如下所示:</li></ul><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="1ee2" class="nx md it nc b gy ny nz l oa ob">&gt;&gt;&gt; client0 = Client("John", 37, "M")<br/>&gt;&gt;&gt; client0.name<br/>'John'<br/>&gt;&gt;&gt; client0.age<br/>37<br/>&gt;&gt;&gt; client0.gender<br/>'M'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b91a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.使用部分功能</h1><p id="ae4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了避免代码重复，我们重构了函数。考虑在更大的范围内，我们有以下效用函数及其用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">效用函数(可能很罗嗦)</p></figure><ul class=""><li id="fd79" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们在各种模块中使用<code class="fe mz na nb nc b">save_image_to_directory</code>实用函数。</li><li id="b689" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当我们处理<code class="fe mz na nb nc b">Event 0</code>时，我们向函数传递三个参数。值得注意的是，第三个参数在模块范围内总是相同的。</li><li id="15f3" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当我们处理另一个事件时，同样的场景通过为每个调用重复第三个参数而发生。</li></ul><p id="0d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种使用场景下，我们应该考虑使用部分函数。具体来说，如果在合理的范围内(例如一个模块)使用一个特定的函数，并且在每个函数调用中都应用了相同的参数，那么部分函数可能会有所帮助。实质上，部分函数是通过将部分参数应用于现有函数而创建的。以下代码向您展示了这种用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部分功能(简明)</p></figure><ul class=""><li id="c343" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">partial</code>功能在<code class="fe mz na nb nc b">functools</code>模块中可用。该函数采用现有函数，并为每个模块应用共享参数。在这种情况下，它是<code class="fe mz na nb nc b">desired_directory</code>参数。</li><li id="bb97" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe mz na nb nc b">partial</code>函数创建另一个函数。调用它消除了传递共享参数的需要。如您所见，从现在开始，我们只需要为分部函数设置两个参数。</li></ul><p id="742b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，我们可以利用lambda函数创建一个分部函数，如下所示。但是我不推荐这种方法，因为它没有使用部分函数来表示我们正在创建部分函数那么明确。</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="2c45" class="nx md it nc b gy ny nz l oa ob">save_image_for_event2 = lambda x, y: save_image_to_directory(x, y, desired_directory='folder_for_event2')<br/>save_image_for_event2("image_data2_101", "event2_101.png")</span></pre><p id="5b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda函数的检查也有问题，因为它没有给出有用的信息，不像使用<code class="fe mz na nb nc b">partial</code>创建的分部函数。考虑以下差异:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="1c04" class="nx md it nc b gy ny nz l oa ob">&gt;&gt;&gt; save_image_for_event1<br/>functools.partial(&lt;function save_image_to_directory at 0x111bf68b0&gt;, desired_directory='folder_for_event1')<br/>&gt;&gt;&gt; save_image_for_event2<br/>&lt;function &lt;lambda&gt; at 0x111bf6940&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab9f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6fe0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了可以帮助您编写更简洁的Python代码的四个特性。通过应用这些技术和许多其他Pythonic方法，您可以提高项目的整体可维护性。</p><p id="5c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这篇文章的摘要:</p><ul class=""><li id="fb40" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">使用<code class="fe mz na nb nc b">enumerate()</code>函数为<code class="fe mz na nb nc b">for</code>循环中的可重复项创建计数器。</li><li id="ad35" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">理解Python将空容器评估为Falsy，这样我们就不需要将它们与另一个值进行比较。</li><li id="81be" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">命名元组是一种易于实现且灵活的只读数据容器。</li><li id="7a61" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">使用部分函数可以消除在特定范围内重复共享参数的需要。</li></ul></div></div>    
</body>
</html>