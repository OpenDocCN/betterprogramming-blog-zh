<html>
<head>
<title>Dependency Injection Containers in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的依赖注入容器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dependency-injection-containers-in-javascript-5fd2c2b4be30?source=collection_archive---------8-----------------------#2020-04-08">https://betterprogramming.pub/dependency-injection-containers-in-javascript-5fd2c2b4be30?source=collection_archive---------8-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b8e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这里，注射是控制的逆过程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b76b751c0667763d191ec7209f9e78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uxz9v1rH9C8H3dxoJl-Axg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ayoisaiah?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ayooluwa Isaiah </a>在<a class="ae ky" href="https://unsplash.com/s/photos/toad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="28c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于其灵活性的本质，JavaScript能够使用许多技术。在这篇文章中，我们将讨论依赖注入容器。</p><p id="794d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式实际上提供了与依赖注入相同的目标，但是以一种更灵活和更强大的方式，充当容纳函数(或类)的依赖项的容器，这些函数(或类)在需要时需要它们，例如在它们的初始化阶段。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9703" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">没有容器的依赖注入</h1><p id="2cf0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们快速回顾一下什么是依赖注入，它在代码中是什么样子，它解决了什么问题，以及它遭受了什么问题。</p><p id="2381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入是一种模式，有助于避免模块中的硬编码依赖，使调用者能够改变它们，并在一个地方提供他们自己的依赖。</p><p id="163b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些依赖关系可以注入到构造函数(实例化)阶段，也可以在以后用setter方法设置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="293b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有一些问题。</p><h2 id="e530" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated"><strong class="ak">问题#1 </strong></h2><p id="08ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们需要改变<code class="fe nn no np nq b">Toad</code>的构造方式，并且它需要一些脆弱的东西，比如参数的定位或它们的数据结构，我们将不得不手动改变代码，因为它是被<em class="nr">硬编码到他们的代码块中的。</em></p><p id="f8d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种场景的一个例子是在<code class="fe nn no np nq b">Frog</code>类中有一个突破性的变化。</p><p id="f15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，如果<code class="fe nn no np nq b">Frog</code>像<code class="fe nn no np nq b">weight</code>一样在其构造函数中添加了第三个参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们的<code class="fe nn no np nq b">Toad</code> <em class="nr">必须</em>被更新，因为这个新的依赖项被添加到我们的<code class="fe nn no np nq b">Frog</code>实例化中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="34ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如果我们保持这种方式，如果你在某个青蛙创业公司，并且那是你开始的第一批代码之一，你认为你会有多少次不得不改变<code class="fe nn no np nq b">Toad</code>？</p><h2 id="8a81" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">第二期</h2><p id="dfec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你必须知道每次对<code class="fe nn no np nq b">Toad</code>使用什么依赖关系。</p><p id="90b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们<em class="nr">有</em>知道<code class="fe nn no np nq b">Toad</code>现在需要<em class="nr">完全相同顺序的四个参数</em>来正确初始化<code class="fe nn no np nq b">Frog</code>的实例，甚至是它们的数据类型，否则很容易出现bug。</p><p id="6e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你知道<code class="fe nn no np nq b">Toad</code>本质上是一只青蛙，这看起来会很尴尬，所以知道了这一点，你可能会意外地认为<code class="fe nn no np nq b">Toad</code>会扩展<code class="fe nn no np nq b">Frog</code>。</p><p id="e87b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，然后你意识到<code class="fe nn no np nq b">Frog</code>的一个实例正在<code class="fe nn no np nq b">Toad</code>内部被创建，现在你变得很困惑，因为你是一个聪明的人，代码只是把你扔了出去——意识到代码与现实世界不一致。</p><h2 id="1152" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated"><strong class="ak">问题#3 </strong></h2><p id="f9e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不必要地包含更多代码。</p><p id="e0c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用依赖注入模式，这些问题可以通过反转依赖实例化方式的控制来解决:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="72f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，那很简单。现在，当<code class="fe nn no np nq b">Frog</code>有另一个突破性的变化时(比如参数被放入一个JavaScript对象)，我们甚至不需要接触<code class="fe nn no np nq b">Toad</code>或者浪费脑细胞去读取<code class="fe nn no np nq b">Toad</code>，然后<code class="fe nn no np nq b">Frog</code>，然后回到<code class="fe nn no np nq b">Toad</code>，等等。</p><p id="f7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们现在可以只改变我们创建一个<code class="fe nn no np nq b">Toad</code>实例的部分(这比不得不在<code class="fe nn no np nq b">Toad</code>实现中改变内容要好，这是一种糟糕的做法！</p><p id="9cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不应该担心frog是如何构造的，它应该只知道它将一个frog作为参数，并将其存储在它的<code class="fe nn no np nq b">.frog</code>属性中以备后用。<em class="nr">你</em>现在掌管它的属地。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="06d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们只是通过从<code class="fe nn no np nq b">Toad</code>构造函数中抽象出<code class="fe nn no np nq b">Frog</code>的实现细节来实践一些干净的代码实践。有道理:难道<code class="fe nn no np nq b">Toad</code>连<em class="nr">都要关心</em> <code class="fe nn no np nq b">Frog</code>是怎么构造的？如果有的话，它应该只是延长它！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a55" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">依赖注入容器(DIC)模式</h1><p id="9675" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经对依赖注入有了新的认识，那么让我们来谈谈依赖注入容器吧！</p><p id="32b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么我们需要DIC模式，为什么没有容器的依赖注入在困难的情况下还不够？</p><p id="af90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是:它就是不可扩展。你的项目变得越大，你就越开始对长期维护你的代码失去信心，因为这样，随着时间的推移，它就会变得一团糟。</p><p id="6ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，你还必须以正确的顺序获得注入依赖项的顺序，这样当你实例化某个东西时，你就不会陷入某个东西被<code class="fe nn no np nq b">undefined</code>的问题。</p><p id="9106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，本质上，六个月后，我们的代码可以进化成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当调用来自<code class="fe nn no np nq b">FrogAdoptionFacility</code>的<code class="fe nn no np nq b">setAdoption</code>时，整个采用过程结束。</p><p id="3f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设您开始使用这些类开发代码，并以如下所示的工作版本结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行代码，它将工作并创建一个新的收养对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个非常好的应用程序——一个青蛙收养设施，客户可以来收养一只青蛙。但是收养过程不是简单的给钱/收钱交易。</p><p id="4790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们假装有一条法律要求每个收养青蛙的机构都要进行这个过程，把青蛙交给它们的新主人。</p><p id="6163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它要求工厂(青蛙天堂)生成一份需要客户签名的合同。</p><p id="37ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，还会在现场创建一个许可证，客户需要将它放在上面以获得法律保护。最后，完成所有工作后，领养也就完成了。</p><p id="fe7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一看<code class="fe nn no np nq b">FrogOwner</code>级:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="325b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有三个依赖关系:<code class="fe nn no np nq b">frogOwner</code>、<code class="fe nn no np nq b">frogOwnerLicense</code>和<code class="fe nn no np nq b">frog</code>。</p><p id="7756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设有一个对<code class="fe nn no np nq b">frogOwner</code>(一个<code class="fe nn no np nq b">Person</code>的实例)的更新，它变成了一个<code class="fe nn no np nq b">Client</code>的实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d0b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，需要更新对初始化<code class="fe nn no np nq b">FrogParadiseOwner</code>的调用。</p><p id="c5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们已经在代码的几个位置初始化了<code class="fe nn no np nq b">FrogParadiseOwner</code>会怎么样呢？如果我们的代码越来越长，这些实例的数量越来越多，维护就越来越成问题。</p><p id="0bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是依赖注入容器可以发挥作用的地方，因为您只需要在一个位置更改代码。</p><p id="2724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入容器可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a52e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些，更新更改就变得如此简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，不是像以前那样直接初始化它，而是必须更改代码的所有其他实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，您可以使用DIC来更新它<em class="nr">一次</em>，并且您不需要更改代码的任何其他部分，因为我们颠倒了流向容器的方向:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="68cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们解释一下驾驶员信息中心正在做什么:</p><p id="36bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过将任何您希望由DIC解析的类或函数传递给<code class="fe nn no np nq b">.factory()</code>方法来插入它们，该方法存储在<code class="fe nn no np nq b">.factory</code>属性中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/7323060811dd17d4471cc4f171b1361e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OHTWOXbakXaRvw8P.jpg"/></div></div></figure><p id="a564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于传递给<code class="fe nn no np nq b">.factory</code>的每一个函数，您必须使用<code class="fe nn no np nq b">.register()</code>注册它们的参数，这样当容器初始化被请求的函数时，它们就可以被获取。</p><p id="af86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们从<code class="fe nn no np nq b">.dependencies</code>地产被接走。您可以使用<code class="fe nn no np nq b">.dependencies()</code>方法向依赖项添加内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a287cd91580785428bdde6439cae094f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IWGYf5tmT8SRGvE-.jpg"/></div></div></figure><p id="4cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你想找回某样东西时，你用<code class="fe nn no np nq b">.get</code>和一些<code class="fe nn no np nq b">key</code>。它使用<code class="fe nn no np nq b">key</code>来查看它的<code class="fe nn no np nq b">dependencies</code>，如果它在那里发现了什么，它将返回它。</p><p id="7b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，它将继续查看它的<code class="fe nn no np nq b">factories</code>,如果它发现了什么，它将把它当作一个你希望它解决的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/edfaf7f8b870156ba533af4e6a8f009b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EZ_MZrWYJZlSY6WR.jpg"/></div></div></figure><p id="14d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它将调用传递给<code class="fe nn no np nq b">.inject</code>，在其中读取函数依赖项(参数)的名称，并从其<code class="fe nn no np nq b">.dependencies</code>属性中获取它们，调用函数并注入其参数，返回结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/799d327165e2d6aaaace3353fd8aa230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sDPAG7Vfd1bWuRvb.jpg"/></div></div></figure><p id="ad54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的代码示例中，我使用了<code class="fe nn no np nq b">parse-function</code>来允许<code class="fe nn no np nq b">inject</code>方法获取函数参数的名称。</p><p id="4fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在没有库的情况下做到这一点，您可以向<code class="fe nn no np nq b">.get</code>添加一个额外的参数，并让它像这样传递给它的<code class="fe nn no np nq b">.inject</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，我们仍然得到相同的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8af2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="a704" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这篇文章到此结束！我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>