<html>
<head>
<title>How Enums Can Impact the Performance of Android Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">枚举如何影响Android应用的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-how-enums-can-impact-the-performance-f787ef5903dd?source=collection_archive---------5-----------------------#2019-12-17">https://betterprogramming.pub/android-how-enums-can-impact-the-performance-f787ef5903dd?source=collection_archive---------5-----------------------#2019-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2806" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在使用它们之前知道枚举的价格</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/280ec33417b4467ec5127601dee99453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKhZ6d4pwOk9-vmjIlMvrQ.png"/></div></div></figure><p id="6a3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开发应用程序时，您可能偶尔会用到枚举。它们很方便。但是当你使用它们时，你可能不知道枚举的全部影响。枚举非常方便，但不幸的是，当涉及到内存大小和速度时，可能会很痛苦。让我们探索枚举如何影响性能，以及我们如何停止使用它们。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="023d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">什么是枚举？</h1><p id="e797" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Java中的<em class="mu">枚举</em>是一种包含一组固定常数的数据类型。</p><p id="0bba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一种特殊的数据类型，它使变量成为一组预定义的常量。它的变量必须等于为它预定义的值之一。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1665" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我们为什么使用枚举？</h1><p id="8b8d" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">当一个变量只能从一组可能的值中取一个值时，我们使用枚举。让我们考虑一个例子:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8db8" class="na ly it mw b gy nb nc l nd ne">public enum Fruits{ Apple, Bannana, Grape, Mango }</span></pre><p id="ad30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在名为<code class="fe nf ng nh mw b">Fruits</code>的枚举只能有一个值，除了已经定义的值之外，不能有其他值。</p><p id="2a92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果我们使用整数或字符串常量，就有可能传递无效的常量。因此，为了避免这些无效的常量错误并增加编译时<strong class="kw iu"> </strong>检查，我们通常使用枚举。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ce56" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">埃努姆的价格</h1><p id="4f97" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">与int常量相比，枚举值将占用更多内存。添加一个枚举会将最终的DEX文件的大小增加大约13倍。</p><p id="ba68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为枚举类中的每个值都被视为一个对象，并且每个值都将占用一些堆内存来引用该对象。这消耗了可用的geap空间。</p><p id="1fb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应用程序中的枚举越多，占用的空间就越多。</p><p id="7d30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们甚至可能不知道enum正在影响我们的应用程序的性能。可能写一两个enum类对我们的app影响可能不大。但是，如果您正在使用一些枚举类，并且您的应用程序中包含的库正在使用一些其他枚举类，则组合所有这些枚举可能会对您的应用程序产生相当大的影响，这可能会增加文件大小，并影响性能。</p><p id="a988" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>核心平台团队的作者强烈建议不要在他们编写的代码的任何部分使用枚举。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="bc65" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">解决办法</h1><p id="7f72" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Android通过注释支持库支持多种注释。可以通过<code class="fe nf ng nh mw b">android.support.annotation</code>包访问库。本库有<code class="fe nf ng nh mw b">TypeDef<em class="mu"> </em></code>注解。这些注释确保特定的参数、返回值或字段引用一组特定的常量。它们还使代码完成能够自动提供允许的常数。</p><p id="ca8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nf ng nh mw b">@IntDef<em class="mu"> </em></code>和<code class="fe nf ng nh mw b">@StringDef</code> <strong class="kw iu"> <em class="mu"> </em> </strong>是两个常量注释，可以用来代替int和string常量的枚举，从而提供编译时安全性。这些注释将帮助我们在编译时检查变量赋值——就像枚举一样。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a6fc" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">如何使用注释</h1><p id="9d00" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们用一个例子来理解这一点。</p><p id="6ba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有一个带有一组int常量的<code class="fe nf ng nh mw b">Fruit</code>类。因此，在创建对象时，我们需要从可用集合中传递int类型的值。但是在我的main方法中，我传递了一个不在常量集中的值——这可能会导致一个有问题的情况。下面的代码片段中没有类型安全。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="067e" class="na ly it mw b gy nb nc l nd ne">public class Fruit {  <br/>     public static final int APPLE = 0;   <br/>     public static final int BANNANA = 1;    <br/>     public static final int GRAPE = 2;   <br/>     public static final int MANGO = 3;</span><span id="2c8c" class="na ly it mw b gy ni nc l nd ne">public Fruit(int fruit) {   <br/>       System.out.println("Fruit Selected:" + fruit);   <br/>     }</span><span id="7b98" class="na ly it mw b gy ni nc l nd ne">public static void main(String[] args) {     <br/>       //Passing Invalid value       <br/>       Fruit fruit = new Fruit(4);    <br/>     }<br/>}</span></pre><p id="bc25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用枚举的类似代码实现如下:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="adac" class="na ly it mw b gy nb nc l nd ne">public class EnumFruit {<br/>   public EnumFruit(Fruit fruit) {             .                 <br/>   System.out.println("Fruit selected is:" + fruit);<br/> }</span><span id="d6b5" class="na ly it mw b gy ni nc l nd ne">public enum Fruit {  <br/>    APPLE, BANNANA, GRAPE, MANGO   <br/> }</span><span id="48f3" class="na ly it mw b gy ni nc l nd ne">public static void main(String[] args) {        <br/>   EnumFruit enumFruitInstance = new EnumFruit(Fruit.APPLE);  <br/> }</span><span id="bfab" class="na ly it mw b gy ni nc l nd ne">}</span></pre><p id="b99e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在应用程序级别添加支持-注释依赖关系<code class="fe nf ng nh mw b">build.gradle</code>:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0614" class="na ly it mw b gy nb nc l nd ne">dependencies {<br/>    implementation 'com.android.support:support-annotations:28.0.0'<br/>}</span></pre><p id="c4bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">声明常数<strong class="kw iu">和</strong> <code class="fe nf ng nh mw b">@IntDef </code>为这些常数:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="46e8" class="na ly it mw b gy nb nc l nd ne">public class AnnotationFruit {     <br/>   public static final int APPLE = 0;    <br/>   public static final int BANNANA = 1;  <br/>   public static final int GRAPE = 2;    <br/>   public static final int MANGO = 3;   <br/> <br/>   public AnnotationFruit(@Fruit int fruit) {         <br/>     System.out.println("Fruit Selected is :" + fruit);   <br/>   }</span><span id="cfe7" class="na ly it mw b gy ni nc l nd ne">@IntDef({APPLE, BANNANA, GRAPE, MANGO})        <br/>   @Retention(RetentionPolicy.SOURCE) <br/>   public @interface Fruit {}</span><span id="f47c" class="na ly it mw b gy ni nc l nd ne">public static void main(String[] args) {       <br/>   AnnotationFruit  annotationSeason = new AnnotationFruit(GRAPE);   <br/>   }<br/>}</span></pre><p id="0220" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上例中，<code class="fe nf ng nh mw b">Typedef</code> <em class="mu"> </em>标注使用:</p><ul class=""><li id="290a" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe nf ng nh mw b">@interface</code> <em class="mu"> </em>声明新的枚举注释类型</li><li id="dc89" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><code class="fe nf ng nh mw b">@IntDef</code> <em class="mu"> </em>和<code class="fe nf ng nh mw b">@StringDef</code> <em class="mu"> </em>注释以及<code class="fe nf ng nh mw b">@Retention</code>是定义枚举类型所必需的</li></ul><p id="1204" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nf ng nh mw b">@Retention(RetentionPolicy.SOURCE)</code>注释告诉编译器不要在<code class="fe nf ng nh mw b">.class</code>文件中存储枚举的注释数据。</p><p id="ac72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置器和获取器可以定义如下:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f7cd" class="na ly it mw b gy nb nc l nd ne">// Decorate the target methods with the annotation     <br/>   @Fruit    <br/>   public abstract int getFruitName();</span><span id="582c" class="na ly it mw b gy ni nc l nd ne">// Attach the annotation    <br/>   public abstract void setFruitName(@Fruit int fuitValue);</span></pre><p id="f43a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果Proguard配置正确，它可以在某些情况下代表我们将枚举优化为int值。所以我们可能不需要担心。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1c3e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="476f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">枚举的总APK大小至少比普通常数多2倍，并且使用的RAM比等效常数多5-10倍。</p><p id="bc26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果你希望你的应用程序在内存和性能上更高效，尽量避免在代码中使用枚举。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="102e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">参考文献:</strong></h1><ul class=""><li id="10e3" class="nj nk it kw b kx mp la mq ld nx lh ny ll nz lp no np nq nr bi translated"><a class="ae oa" href="https://www.youtube.com/watch?v=Hzs6OBcvNQE" rel="noopener ugc nofollow" target="_blank">“enum的价格(Google Dev的100天)</a>”</li></ul></div></div>    
</body>
</html>