<html>
<head>
<title>Three Ways to Define Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中定义函数的三种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/three-ways-to-define-functions-in-javascript-750a908e51d9?source=collection_archive---------1-----------------------#2019-07-26">https://betterprogramming.pub/three-ways-to-define-functions-in-javascript-750a908e51d9?source=collection_archive---------1-----------------------#2019-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0dba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义编程中的一个关键组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4158d53d50ee630fdbf8ff76105746a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avlg0U4o26ozRD2Ft6DT9Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lucabravo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae ky" href="https://unsplash.com/search/photos/functions?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="5977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是编程的关键组成部分之一。它们被定义为执行特定的任务，并且可以被反复调用来执行。javascript中的函数与其他编程语言的主要区别在于，Javascript中的函数是一级对象，这意味着它们的行为类似于对象，可以被赋给变量、数组和其他对象。</p><p id="e229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章讨论了定义函数的三种不同方法:</p><ol class=""><li id="46f9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">函数声明</li><li id="7e08" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">函数表达式</li><li id="2203" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">发电机功能</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ad0a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.函数声明</h1><p id="c12a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这可能是声明函数最常见的方式。让我们看看它的语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数声明的语法</p></figure><p id="c8f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数声明由关键字<code class="fe np nq nr ns b">function</code> <strong class="lb iu"> </strong>组成，后跟函数的强制名称，然后是一对括号内的参数(也可以定义不带参数的函数)。最后，在一对花括号内是函数体，它执行一个实际的任务。</p><p id="53da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">知道函数</em>的形参和实参之间的区别很重要。定义函数时，参数是一个变量。当调用一个函数时，实参是传递给函数形参的实际数据。</p><p id="5f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们看一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f1e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个名为<code class="fe np nq nr ns b">hello</code>的函数用一个参数<code class="fe np nq nr ns b">name</code>声明，它在控制台中记录一条消息。正如您在示例中看到的，由于参数中没有指定类型，因此它对string和number都有效。但是如果我只想让我的函数问候一个名字，而不是一个数字呢？遗憾的是，在Javascript中没有预建的方法来实现这一点，所以我们必须手动检查函数中传递的参数类型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">默认情况下，函数返回未定义。若要返回任何其他值，函数必须有一个指定要返回值的return语句。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">函数声明中的</em><strong class="lb iu"><em class="nt"/></strong><code class="fe np nq nr ns b">Hoisting</code><em class="nt">是什么？</em></p><p id="15b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，这意味着当代码被执行时，无论你在哪里声明函数或变量，它们都被移动到它们作用域的顶部。这就是所谓的吊装。</p><p id="5fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数声明中的提升</p></figure><p id="7e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我在声明之前就调用了这个函数，这就是提升。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c47d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.函数表达式</h1><p id="7a19" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">函数表达式与函数语句非常相似，语法也几乎相同。主要区别在于，函数表达式不是以关键字<code class="fe np nq nr ns b">function</code>开始，函数的<code class="fe np nq nr ns b">name</code>也是可选的，在这种情况下，它变成了一个<em class="nt">匿名函数</em>。如果函数有一个<code class="fe np nq nr ns b">name</code>，那么它被称为<em class="nt">命名函数表达式</em> <strong class="lb iu">。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数表达式示例</p></figure><p id="2dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看定义上述函数的匿名方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匿名函数表达式</p></figure><p id="692a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">函数声明和函数表达式的一个重要区别在于，函数表达式中没有提升。如果你尝试与提升函数声明中相同的程序，你会遇到一个错误。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数表达式中没有提升</p></figure><h2 id="ebaf" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated"><strong class="ak">life(立即调用函数表达式)</strong></h2><p id="5600" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这意味着函数一定义就运行，这里函数表达式被包含在<em class="nt">分组运算符()</em>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d5e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们在典型的函数表达式中需要生命？我们定义了函数，然后在以后的某个时候调用它任意次，但是如果我只想调用函数一次来产生一个输出，就这样——我不想再使用它了，该怎么办呢？这是生命出现的地方。它会被立即执行，并且以后再也不会被程序访问。因为它不会被再次调用，所以它不需要名字，所以对于IIFE来说，匿名函数表达式是首选的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8564" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.发电机功能</h1><p id="7cc5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正常功能遵循<em class="nt">运行至完成</em>模型，在执行最后一行之前不能停止。如果你想在执行过程中退出，你必须返回或者抛出一个错误。</p><p id="be90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">发电机功能可以在执行中途停止。当它被回调时，它从停止的地方继续。</em></p><p id="3074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它像一个普通的函数一样被声明，但是不同的是生成器函数在关键字<code class="fe np nq nr ns b">function</code>后面有一个星号*，并且在它们之间可以包含任意数量的空格。</p><p id="5221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一点需要注意:在JavaScript中，生成器是一个函数，它返回一个你可以调用<code class="fe np nq nr ns b">next()</code>的对象。每次调用<code class="fe np nq nr ns b">next()</code>都会返回一个结构如下的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="33a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这个对象有两个属性:<code class="fe np nq nr ns b">value</code>和<code class="fe np nq nr ns b">done</code>。<code class="fe np nq nr ns b">Value</code>是对象的实际值，而<code class="fe np nq nr ns b">done</code>是指定函数终止的属性——默认值为false，当它变为true时，函数停止。</p><p id="6465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个简单的例子来更好地理解它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数体内，我们不使用return关键字—而是使用<code class="fe np nq nr ns b">yeild</code>，如果使用了<strong class="lb iu"> </strong> <code class="fe np nq nr ns b">return</code>，它会将属性<code class="fe np nq nr ns b">done</code>更改为<code class="fe np nq nr ns b">true</code>，函数将结束—它之后的任何内容都不会执行。<code class="fe np nq nr ns b">Yield</code>给出赋予它的值。</p><p id="818a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义我们的函数，然后我们调用它，调用一个生成器函数产生一个生成器对象，它存储在变量gen中。</p><p id="ac58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用<code class="fe np nq nr ns b">next()</code>和<code class="fe np nq nr ns b">value</code>属性调用对象，</p><p id="1681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次使用<code class="fe np nq nr ns b">next()</code>时，功能开始执行。首先，它运行console.log(“第一个执行”)并将其记录在控制台中，然后它遇到<code class="fe np nq nr ns b">yield </code> —产生值“暂停”，执行停止。</p><p id="fd58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二次调用<code class="fe np nq nr ns b">next()</code>时，它从上次离开的地方开始。同样，它首先运行<code class="fe np nq nr ns b">console.log()</code>，然后遇到<code class="fe np nq nr ns b">yield</code>，产生值“函数结束”，然后函数停止。</p><p id="5a19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三次调用<code class="fe np nq nr ns b">next()</code>时，结果显示为未定义。发生这种情况是因为从生成器函数生成的对象只能迭代一次——该对象现在没有用了，必须生成一个新对象，程序才能重新启动。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">如果我使用</em> <code class="fe np nq nr ns b"><em class="nt"> return</em></code> <em class="nt">而不是</em> <code class="fe np nq nr ns b"><em class="nt">yield</em></code> <em class="nt">，数据的值会更改为</em> <code class="fe np nq nr ns b"><em class="nt">true</em></code> <em class="nt">，之后不会执行任何操作。</em></p><p id="2a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器与Promises结合使用时，是异步编程的一个非常强大的工具。他们减轻，如果不是完全消除，回调的问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f340" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论:哪种方式更好？</h1><p id="dd3b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">嗯，我们不能比较它们，说一个比另一个好——声明的类型取决于情况或条件。</p><p id="b7d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用生成器函数来获得更好的异步功能，并对想要立即执行的函数使用匿名函数表达式。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6bdb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">参考</h1><p id="303a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> Mozilla Docs </a></p></div></div>    
</body>
</html>