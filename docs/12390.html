<html>
<head>
<title>Implement a Scalable WebSocket Server With Spring Boot, Redis Pub/Sub, and Redis Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Boot、Redis发布/订阅和Redis流实现可伸缩的WebSocket服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-scalable-websocket-server-with-spring-boot-redis-pub-sub-and-redis-streams-b6b8cc08767f?source=collection_archive---------2-----------------------#2022-06-02">https://betterprogramming.pub/implement-a-scalable-websocket-server-with-spring-boot-redis-pub-sub-and-redis-streams-b6b8cc08767f?source=collection_archive---------2-----------------------#2022-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7eec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Spring Boot、Redis发布/订阅和Redis流水平扩展WebSocket服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/593a6fac76e61a90051d6f71617c4f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l54synhYAM1a7gvi1wjVwA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德里亚斯·瓦格纳在<a class="ae ky" href="https://unsplash.com/@waguluz_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/design-considerations-for-scaling-websocket-server-horizontally-with-a-publish-subscribe-pattern-fe6de9988400">上一篇关于水平扩展WebSocket服务器的设计考虑的文章</a>的后续。</p><p id="7657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将详细介绍如何使用Redis发布/订阅和Redis流来实现这一点。</p><div class="lv lw gp gr lx ly"><a href="https://github.com/bkjam/websocket-microservice" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">GitHub-bkjam/websocket-微服务:实时web socket微服务探索…</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">Websocket微服务用于前端和后端实时通信的探索</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="5dc3" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我的WebSocket服务器系列</h1><ul class=""><li id="4cd4" class="nf ng it lb b lc nh lf ni li nj lm nk lq nl lu nm nn no np bi translated">01: <a class="ae ky" href="https://medium.com/@kbryan1008/building-a-websocket-server-in-a-microservice-architecture-50c6c6432e2b" rel="noopener">在微服务架构中构建WebSocket服务器</a></li><li id="13df" class="nf ng it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">02: <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/design-considerations-for-scaling-websocket-server-horizontally-with-a-publish-subscribe-pattern-fe6de9988400">使用发布-订阅模式水平扩展WebSocket服务器的设计考虑</a></li><li id="8839" class="nf ng it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">03:使用Spring Boot、Redis发布/订阅和Redis流实现可伸缩的WebSocket服务器</li><li id="ba91" class="nf ng it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">04:待定</li></ul><h1 id="f048" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">快速回顾</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ee989441b96935ed29f59bb46aa6e037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m05B3RKqGIrzfqp7TSrDAQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用发布-订阅模式在微服务架构中扩展WebSocket服务器的完整设计</p></figure><p id="b712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们指出了水平扩展WebSocket服务器和后端微服务时会出现的两个问题:</p><ul class=""><li id="e107" class="nf ng it lb b lc ld lf lg li nw lm nx lq ny lu nm nn no np bi translated">问题#1:负载平衡器导致的消息丢失</li><li id="a451" class="nf ng it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">问题#2:由于多个订户而导致重复的消息处理</li></ul><p id="b80f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是将带有消费者团体概念的发布-订阅消息传递模式应用到架构设计中。有关更多信息，请参考<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/design-considerations-for-scaling-websocket-server-horizontally-with-a-publish-subscribe-pattern-fe6de9988400">上一篇文章</a>。</p><h1 id="b226" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我们开始吧</h1><p id="e53b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">继续使用Spring Boot、Stomp、Redis发布/订阅和Redis流构建一个可伸缩的WebSocket服务器。</p><h2 id="5b9c" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤1:构建WebSocket服务器</strong></h2><p id="8f79" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">按照我上一篇文章中的<a class="ae ky" href="https://medium.com/@kbryan1008/building-a-websocket-server-in-a-microservice-architecture-50c6c6432e2b" rel="noopener">步骤1和2，使用Spring Boot和STOMP消息协议初始化一个WebSocket服务器。</a></p><h2 id="ec4d" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">第二步:启动Redis服务器</strong></h2><p id="90cc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">为了快速设置，使用docker在本地运行Redis服务器。</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="1f8b" class="oc mo it op b gy ot ou l ov ow">docker run --name redis -p 6379:6379 -d redis</span></pre><h2 id="0693" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤3:配置与Redis服务器的连接</strong></h2><p id="8ae3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">将以下配置添加到WebSocket服务器的<code class="fe ox oy oz op b">application.yml</code>文件中，以连接到Redis服务器。</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="c2f7" class="oc mo it op b gy ot ou l ov ow"># application.yml<br/>spring.redis:<br/>    host: localhost<br/>    port: 6379</span></pre><h1 id="2872" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak">步骤4:实现单向实时通信的发布/订阅(广播信道)</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/5d0e4d68f3b64b22f8835cb9626b65a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpvtgq3wXjM3u4Ds0HEIZw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用API和发布/订阅(广播)的单向实时通信设计</p></figure><p id="8b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4步中，我们将为后端微服务和web应用程序(前端)之间的单向实时通信创建API。WebSocket服务器通过API从后端微服务接收消息，并使用Redis Pub/Sub将消息广播到所有WebSocket服务器实例。然后，通过建立的WebSocket连接将消息转发给web应用程序。</p><h2 id="b335" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤4.1:创建BroadcastEvent类</strong></h2><p id="b224" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><code class="fe ox oy oz op b">BroadcastEvent</code>是一个自定义对象，用于将消息从WebSocket服务器的一个实例广播到WebSocket服务器的所有实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="2582" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤4.2:配置Redis发布/订阅—reactivedistemplate</strong></h2><p id="2bb7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><code class="fe ox oy oz op b">ReactiveRedisTemplate</code>是一个助手类，它简化了Redis数据访问代码。在我们的配置中，我们发布/订阅值<code class="fe ox oy oz op b">BroadcastEvent</code>，并使用<code class="fe ox oy oz op b">Jackson2JsonRedisSerializer</code>来执行值的自动序列化/反序列化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="a4a7" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤4.3:配置Redis发布/订阅广播服务</strong></h2><p id="2cf2" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><code class="fe ox oy oz op b">RedisBroadcastService</code>包含发布和订阅定制频道的逻辑(<code class="fe ox oy oz op b">BROADCAST-CHANNEL</code>)。这是从WebSocket服务器的一个实例向WebSocket服务器的所有实例广播消息的通道。</p><p id="e1e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当WebSocket服务器收到来自<code class="fe ox oy oz op b">BROADCAST-CHANNEL</code>的消息时，该消息就会被转发到已经与它建立了WebSocket连接的web应用程序(前端)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="7952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="pd">注意</em> </strong> <em class="pd"> : </em> <code class="fe ox oy oz op b"><em class="pd">@PostConstruct</em></code> <em class="pd">是一个Spring注释，允许我们将自定义动作附加到bean创建中，并且这些方法只运行一次。在我们的例子中，我们订阅了关于bean创建的</em> <code class="fe ox oy oz op b"><em class="pd">BROADCAST-CHANNEL</em></code> <em class="pd">。</em></p><h2 id="7b96" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤4.4:创建API端点</strong></h2><p id="4f25" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">下面的代码创建了一个带有POST请求端点的REST控制器，该端点接收一个请求体<code class="fe ox oy oz op b">NewMessageRequest</code>。<code class="fe ox oy oz op b">topic</code>是客户端(前端)订阅的STOMP目的地，<code class="fe ox oy oz op b">message</code>是字符串格式的实际消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="51d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API请求将被广播到WebSocket服务器的所有实例，如上面步骤4.3中所配置的。</p><h2 id="2348" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤4.5:通过API测试单向实时通信</strong></h2><p id="f90d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">启动WebSocket服务器，使用<a class="ae ky" href="https://github.com/jiangxy/websocket-debug-tool" rel="noopener ugc nofollow" target="_blank"> jiangxy </a>开发的<a class="ae ky" href="https://bkjam.github.io/websocket-debug-tool/" rel="noopener ugc nofollow" target="_blank"> WebSocket调试工具</a>通过STOMP协议连接到WebSocket服务器<code class="fe ox oy oz op b">ws://localhost:8080/stomp</code>。连接后，配置WebSocket调试器工具来订阅主题<code class="fe ox oy oz op b">/topic/frontend</code>。</p><p id="505b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，使用下面的curl命令向WebSocket服务器发送HTTP POST请求:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="bbaa" class="oc mo it op b gy ot ou l ov ow">curl -X POST -d '{"topic": "/topic/frontend", "message": "testing API endpoint" }' -H 'Content-Type: application/json' localhost:8080/api/notification</span></pre><p id="3c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSocket调试器工具应该具有如下所示的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/cf792c02799ba33896ff3a14369c8bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09ELQKx2Y8-qXO1HKNOF4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WebSocket调试器工具的输出屏幕截图</p></figure><p id="604b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这说明我们已经成功地用Redis Pub/Sub配置了WebSocket服务器，实现了后端微服务和web应用(前端)之间可伸缩的单向实时通信。</p><h2 id="c66f" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">第五步:与消费群体实现双向实时沟通的发布/订阅</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/092832b911a9310dd3ff06930b2657ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_lciU8EFkC4WRBRYlGcuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用发布/订阅和消费群进行双向实时通信的设计</p></figure><p id="c6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5步中，我们将使用Redis流作为我们的发布/订阅系统，用于后端微服务和web应用程序(前端)之间的双向实时通信。我们不使用Redis发布/订阅，因为它不支持消费者群体的概念。</p><h2 id="de50" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.1:创建StreamDataEvent类</strong></h2><p id="a4bc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated"><code class="fe ox oy oz op b">StreamDataEvent</code>是用于订阅者和发布者之间数据交换的自定义对象。<code class="fe ox oy oz op b">message</code>是字符串格式的实际消息，而<code class="fe ox oy oz op b">topic</code>是WebSocket服务器知道将消息发送到哪个STOMP目的地的必填字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="8821" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.2: WebSocket服务器——实现Redis流消费者</strong></h2><p id="d7ce" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">消费者使用Redis流中的消息，并通过已建立的WebSocket连接将消息转发给所有web应用程序(前端)。</p><p id="7cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="pd">注意:</em> </strong> <em class="pd">不需要广播消息，因为所有WebSocket服务器实例都会从Redis流接收消息。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="847f" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.3: WebSocket服务器——实现Redis流配置</strong></h2><p id="0692" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">以下代码包含订阅Redis流的配置，其中消息将由我们在步骤5.2中配置的<code class="fe ox oy oz op b">RedisStreamConsumer</code>处理。</p><p id="61b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们配置WebSocket服务器来监听由键<code class="fe ox oy oz op b">TEST_EVENT_TO_WEBSOCKET_SERVER</code>标识的流。您可以根据您的使用情况创建更多订阅。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="cc01" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.4: WebSocket服务器—实现Redis流生成器</strong></h2><p id="6268" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">生产者提供了一个方法<code class="fe ox oy oz op b">publishEvent</code>，用于将数据发布到Redis流。在我们的示例中，有一个调度作业，它使用关键字<code class="fe ox oy oz op b">TEST_EVENT_TO_BACKEND</code>定期(在WebSocket服务器启动后每五秒或十秒)发布到Redis流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="a413" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.5: WebSocket服务器——实现WebSocket配置</strong></h2><p id="30fb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">创建一个<code class="fe ox oy oz op b">Controller</code>，它处理来自web应用程序(前端)的消息，这些消息被发送到带有前缀<code class="fe ox oy oz op b">/app</code>的WebSocket服务器。在下面的例子中，发送到<code class="fe ox oy oz op b">/app/test</code>的消息将被转发(发布)到关键字<code class="fe ox oy oz op b">TEST_EVENT_TO_BACKEND</code>处的Redis流。</p><p id="ad4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="pd">注意</em> </strong> <em class="pd">:不需要将消息广播到所有WebSocket实例，因为发布到Redis流已经确保所有后端微服务都接收到消息。有关更多详细信息，请参考步骤5中的图表。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="931e" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.6:后端微服务——实现Redis流消费者</strong></h2><p id="0ec6" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">类似地，在样本后端微服务中，实现Redis流消费者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="7a48" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.6:后端微服务——实现Redis流配置</strong></h2><p id="15df" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">这里的配置类似于WebSocket服务器的配置。唯一的区别是我们添加了消费者组(<code class="fe ox oy oz op b">CONSUMER_GROUP</code>)，这确保了只有一个后端微服务实例将消费来自Redis流的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="36cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使配置工作，我们必须首先使用下面的命令在Redis中为流<code class="fe ox oy oz op b">TEST_EVENT_TO_BACKEND</code>手动创建消费者组。</p><p id="7790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="pd">注意</em> </strong> <em class="pd">:也可以使用代码来实现这一点，但是为了简单起见，我将使用Redis CLI命令。</em></p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="d860" class="oc mo it op b gy ot ou l ov ow">docker exec redis redis-cli XGROUP CREATE TEST_EVENT_TO_BACKEND CONSUMER_GROUP $ MKSTREAM</span></pre><h2 id="aaa0" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.7:后端微服务——实现Redis流生成器</strong></h2><p id="f8ed" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">生产者配置类似于WebSocket服务器配置。</p><p id="0afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pd">请注意，微服务有一个定期发布到Redis流的计划作业，作为我们示例的一部分，该消息被精心设计为发送到目的地主题为</em> <code class="fe ox oy oz op b"><em class="pd">/topic/to-frontend</em></code> <em class="pd">的web应用程序(前端)。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="6b39" class="oc mo it bd mp od oe dn mt of og dp mx li oh oi mz lm oj ok nb lq ol om nd on bi translated"><strong class="ak">步骤5.8:通过发布/订阅测试双向实时通信</strong></h2><p id="713f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">我们已经配置了WebSocket服务器和样本后端微服务。让我们使用我们在两个<code class="fe ox oy oz op b">RedisStreamProducer</code>中所做的预定数据发布配置来测试来自Redis流的数据的发布和订阅。</p><p id="bef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动WebSocket服务器的两个实例和样本后端微服务的两个实例。您应该注意到输出日志与下面的类似。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/62f3edf44ed62dd5f166d316cdfe2a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-Y-ydl9TiYdSBD-y1Gf3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后端微服务的输出日志(实例A)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/81a6ab39c402262cd0cdc1330987d590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*af1t8Z-wlOWoEWSgvVsvUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后端微服务的输出日志(实例B)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/b538cd413a18e1002156e4a15b04c98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-ga10clblIpXAS4KMEnuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WebSocket服务器的输出日志(实例A)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/4f01e44a7d65e76818bda9cb4a2d219d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3URLgo2BYGrZyt9DJ4WcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WebSocket的输出日志(实例B)</p></figure><p id="f6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您要使用<a class="ae ky" href="https://bkjam.github.io/websocket-debug-tool/" rel="noopener ugc nofollow" target="_blank"> WebSocket调试器工具</a>连接到WebSocket服务器并订阅主题<code class="fe ox oy oz op b">/topic/to-frontend</code>，您应该会看到以下日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/375c906aef632438a06d4cf7d00e378b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gXAW0UAjRbqZKGlIk6Msw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">WebSocket调试器工具的输出日志(前端)</p></figure><p id="554a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明我们已经成功地用Redis流配置了WebSocket服务器，用于后端微服务和web应用程序(前端)之间可伸缩的双向实时通信。</p><h1 id="9b34" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">摘要</h1><p id="098f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">就是这样！你可以在G  itHub上找到<a class="ae ky" href="https://github.com/bkjam/websocket-microservice/tree/main/02-scaling-websocket-server" rel="noopener ugc nofollow" target="_blank">示例代码。我的实现并不完美，但目的是让您了解如何使用发布-订阅消息传递模式在微服务架构中轻松扩展WebSocket服务器。</a></p></div><div class="ab cl pj pk hx pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="im in io ip iq"><p id="4a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pd">感谢阅读到最后。我希望你能从这篇文章中学到一些新的东西。敬请期待下一期，学习愉快！</em></p></div></div>    
</body>
</html>