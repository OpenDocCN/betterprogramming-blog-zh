<html>
<head>
<title>6 Quirks of Python That Can Puzzle You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的6个让你困惑的怪癖</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-quirks-of-python-that-can-puzzle-you-4476012a1fee?source=collection_archive---------9-----------------------#2021-04-27">https://betterprogramming.pub/6-quirks-of-python-that-can-puzzle-you-4476012a1fee?source=collection_archive---------9-----------------------#2021-04-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0691" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">一些你可能忽略的鲜为人知的令人困惑的特性</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ae5e9d94cffdf159967b7a8f1545f6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kewz0xLvwocuc8INzphzmA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@emilymorter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae kz" href="https://unsplash.com/s/photos/confusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2e7a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python是一种初学者友好的语言，依赖于可读性。它因其伪英语式的语法而广受欢迎。我们知道英语是一种有趣的语言。</p><p id="3534" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">嗯，Python也是。语言中有相当多的不一致之处(注意:这并不意味着设计缺陷),这可能会让任何开发人员感到困惑——尤其是在他们刚开始的时候。</p><p id="3a7a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将了解一些奇怪的事情。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="b121" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">1.在f字符串中显示浮点值</h1><p id="ed94" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Python f字符串是一个强大的特性。它们允许您计算表达式、为更好的调试设置占位符，以及用引号格式化字符串。人们也可以使用它们相当快地打印出一个值的字典。</p><p id="71dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个例子:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="94e9" class="nf me iu nb b gz ng nh l ni nj">&gt;&gt;&gt; x = {‘lang’: ‘Python’, ‘version’: 3.10}<br/>&gt;&gt;&gt; print(‘{lang} {version} is amazing.’.format(**x))</span><span id="c13a" class="nf me iu nb b gz nk nh l ni nj">Python 3.1 is amazing.</span></pre><p id="a163" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如您所见，输出不是您所期望的。它缺少十进制值。</p><p id="11e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以通过设置格式说明符来解决这个问题，如下所示:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="119f" class="nf me iu nb b gz ng nh l ni nj">&gt;&gt;&gt; print(‘{lang} {version:.2f} is amazing.’.format(**x))</span><span id="873c" class="nf me iu nb b gz nk nh l ni nj">Python 3.10 is amazing.</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="ed44" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">2.for-else和while-else条件循环</h1><p id="b5d8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这是一个会让任何开发人员感到困惑的怪癖，尤其是那些来自另一种语言的开发人员，比如说JavaScript。</p><p id="9f3c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在编程中都见过并使用过<code class="fe nl nm nn nb b">if-else</code>条件句。<code class="fe nl nm nn nb b">if-elif</code>构造是Python中常用的。然而，也可以使用<code class="fe nl nm nn nb b">for-else</code>和<code class="fe nl nm nn nb b">while-else</code>语法。</p><p id="76e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，从远处看，条件循环的<code class="fe nl nm nn nb b">else</code>子句似乎只有在循环无法完全执行时才会执行，但实际上，它的工作正好相反。</p><p id="675a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">考虑一下这个:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="9468" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">人们本以为<code class="fe nl nm nn nb b">else</code>条款不会被打印出来。令人惊讶的是，确实如此。</p><p id="65d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">基本上，<code class="fe nl nm nn nb b">for-else</code>或<code class="fe nl nm nn nb b">while-else</code>语句的工作方式如下:</p><ul class=""><li id="665c" class="nq nr iu lc b ld le lg lh lj ns ln nt lr nu lv nv nw nx ny bi translated">只有当<code class="fe nl nm nn nb b">for</code>或<code class="fe nl nm nn nb b">while</code>循环没有终止时，才会执行<code class="fe nl nm nn nb b">else</code>语句。</li><li id="43ec" class="nq nr iu lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">如果使用<code class="fe nl nm nn nb b">break</code>语句终止循环，则<code class="fe nl nm nn nb b">else</code>结构不会执行。</li></ul><p id="df09" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，在下面这段代码中，<code class="fe nl nm nn nb b">else</code>子句不执行:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="9e7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nl nm nn nb b">for-else</code>这是一个很难理解的概念，因此这是一个需要注意的流行怪癖。当进行线性搜索时，如上所示的条件循环非常方便。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="deb8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">3.循环变量缺乏作用域</h1><p id="3315" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在大多数编程语言(如Java)中，当循环终止时，它的索引变量变得未定义。同样，在Python中这不会发生。</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="a8cc" class="nf me iu nb b gz ng nh l ni nj">i = 1<br/>for i in [2,3,4]:<br/>    print(i)</span><span id="f519" class="nf me iu nb b gz nk nh l ni nj">print(i)</span></pre><p id="f00e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您希望打印的内容:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="3a30" class="nf me iu nb b gz ng nh l ni nj">#Output: 2, 3, 4, 1</span></pre><p id="d13d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">实际打印的内容:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="3345" class="nf me iu nb b gz ng nh l ni nj">#Output: 2, 3, 4, 4</span></pre><p id="38b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是因为Python除了函数级别之外没有任何作用域规则。因此，您可以在循环或条件语句中定义的任何内容都可以从该块外部访问。</p><p id="4ad6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个想法相当简单。但是，当开发人员刚刚开始接触Python时，这可能会造成混乱。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a101" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">4.列表()和方括号是不同的</h1><p id="3dba" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您会注意到创建列表有两种方式:使用<code class="fe nl nm nn nb b">[]</code>操作符和使用<code class="fe nl nm nn nb b">list()</code>构造函数。字典也是如此(<code class="fe nl nm nn nb b">dict()</code> vs. <code class="fe nl nm nn nb b">{}</code>)。</p><p id="d8d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，两者之间有着鲜明的差异。<code class="fe nl nm nn nb b">[]</code>不仅速度更快，而且输出也与<code class="fe nl nm nn nb b">list()</code>不同。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="61d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您所看到的，list构造函数遍历字符串，然后将它转换成一个列表，而括号操作符将字符串作为列表的一个元素。</p><p id="d65f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似地，如果在list构造函数中设置一个字典，它只会创建一个字典键列表。因此，最好选择<code class="fe nl nm nn nb b">[]</code>而不是<code class="fe nl nm nn nb b">list</code>构造函数。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0809" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">5.默认可变参数</h1><p id="ba51" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">通过在函数中设置默认参数，我们可以在调用点防止函数中可怕的长参数列表。</p><p id="0a86" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是设置可变值，比如列表、字典和集合，并不能真正给出您最初期望的结果:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="bdf8" class="nf me iu nb b gz ng nh l ni nj">def addToList(x, a=[]):<br/>    a.append(x)<br/>    return a</span><span id="b78b" class="nf me iu nb b gz nk nh l ni nj">&gt;&gt;&gt; list1 = addToList(5)<br/>[5]</span><span id="bd2f" class="nf me iu nb b gz nk nh l ni nj">list2 = addToList(10)<br/>[5, 10]</span></pre><p id="db67" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的输出展示了函数中的默认可变参数在调用时只计算一次。这并不奇怪，因为Python中的函数被认为是一级对象。</p><p id="4cda" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您不希望在函数调用中保留默认值，可以使用稍微不同的方法。这里有一个例子，将字典作为默认参数，并设置为<code class="fe nl nm nn nb b">None</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4354" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">6.迭代时修改列表是可行的，但是使用字典时，它会抛出一个错误</h1><p id="6f72" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在遍历集合时添加或删除元素从来都不是一个好主意。然而，如果我们比较两个微不足道的输出，一个用Python字典，另一个用列表，结果是惊人的。</p><p id="5752" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个字典的例子，我们在迭代过程中删除元素:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="c7f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，如果我们将相同的逻辑应用于Python列表，它在某种程度上是有效的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="8f2c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您会注意到，在迭代过程中，只有第一个和第三个元素会从列表中删除。这是因为删除一个元素后，下一个元素会占用该索引。此外，每迭代一次，索引就增加一——这导致我们跳过奇数元素。</p><p id="c115" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，这是Python列表的一个奇怪行为，尤其是当字典和集合抛出一个错误时，我们得到了一致的结果(尽管它是不正确的)。列表和字典中不同结果的原因与它们的底层实现有关。</p><p id="b9cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">传统上，列表是基于索引的，而字典依赖于哈希查找表，这要求字典的大小在迭代期间保持不变。因此，在迭代过程中删除字典键会导致运行时错误。</p><p id="a176" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们总是可以将字典键包装在一个<code class="fe nl nm nn nb b">list()</code>中来使它工作。但理想情况下，字典理解应该优先用于删除元素。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="6b84" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="e7cb" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">还有一些，像<code class="fe nl nm nn nb b">is</code>对<code class="fe nl nm nn nb b">==</code>进行身份对等式检查，以及<code class="fe nl nm nn nb b">tuple</code>对<code class="fe nl nm nn nb b">u</code>操作符。希望你发现Python的上述怪癖有用。</p><p id="d53a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。</p></div></div>    
</body>
</html>