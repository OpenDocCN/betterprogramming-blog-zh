<html>
<head>
<title>Continuous Performance Improvement of HTTP API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP API的持续性能改进</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/continuous-performance-improvement-of-http-api-86290433aa54?source=collection_archive---------13-----------------------#2022-02-23">https://betterprogramming.pub/continuous-performance-improvement-of-http-api-86290433aa54?source=collection_archive---------13-----------------------#2022-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们用Python开发了一个分析HTTP API。这就是我们如何发现需要改进的地方，以便更快地满足请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb316feb8a67f92f196ed70d6fe9ec7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M393zHdiKhOxKS7oIBlzMg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烧毁了。图像许可CC0。</p></figure><p id="ba3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我之前的文章中，我详细介绍了一些提高后端性能的代码技巧。但是，我怎么知道应该关注哪里，应该优化什么呢？事实上，将Cython和其他低级小发明加入该党应该有坚实的理由。</p><p id="f4d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在<a class="ae lu" href="https://athenian.com/" rel="noopener ugc nofollow" target="_blank">雅典</a>工作。雅典人提供了一个SaaS，帮助工程领导者建立一个持续改进的软件开发文化。UX规定了非常严格的绩效目标。如果没有合适的工具，很难实现很好的P95响应时间。因此，我们用高质量的应用和服务包装自己:</p><ul class=""><li id="9678" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="https://docs.sentry.io/product/sentry-basics/tracing/distributed-tracing/" rel="noopener ugc nofollow" target="_blank"> Sentry分布式跟踪</a>允许我们调查为什么一个特定的API请求在生产中执行缓慢。该工具适用于Python领域。</li><li id="847b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Prodfiler 独立放大本机CPU性能，包括所有共享库。</li><li id="5b9c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank"> py-spy </a>是由<a class="mj mk ep" href="https://medium.com/u/de31421e853a?source=post_page-----86290433aa54--------------------------------" rel="noopener" target="_blank"> Ben Frederickson </a>开发的一款优秀的低开销Python分析器。</li><li id="6d07" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Prometheus + Grafana有助于监控即时情况并触发性能灾难恢复。</li><li id="8d91" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://cloud.google.com/logging/docs/logs-based-metrics" rel="noopener ugc nofollow" target="_blank">基于Google日志的指标</a>通过显示重要运营事件的频率提高，增强了之前的工具链。</li><li id="857b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://cloud.google.com/blog/products/databases/get-ahead-of-database-performance-issues-with-cloud-sql-insights" rel="noopener ugc nofollow" target="_blank"> Google Cloud SQL Insights </a>是单个查询级别的必备托管PostgreSQL性能监视器。</li><li id="59d9" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://explain.tensor.ru/" rel="noopener ugc nofollow" target="_blank"> explain.tensor.ru </a>是我最喜欢的PostgreSQL执行计划可视化工具。它提供了许多总是相关的自动提示。</li></ul><p id="ea9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天的帖子展示了每周例行工作，以确定慢点并加快速度。特别是，我将演示哨兵跟踪、py-spy和Prodfiler的有用性。</p><h2 id="30a5" class="ml mm it bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">寻找受害者</h2><p id="23c8" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们从<a class="ae lu" href="https://sentry.io/" rel="noopener ugc nofollow" target="_blank"> Sentry </a>中的性能概述页面开始。我们每隔几天检查一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/abb3febc9a6623e99ee9841098490a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WPhMv7J5EV96B8R5ULBLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Sentry中的雅典API性能概述。图片作者。</p></figure><p id="5b51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该表显示了我们所有API端点的P50和P95响应时间，以及在服务于主请求(例如更新缓存)之后执行的延迟(<code class="fe nk nl nm nn b">if err != nil {</code>，哎呀，那是我的肌肉内存)任务。雅典API是一个分析API。它聚合了成千上万的项目，如PR、release、CI run、JIRA问题元数据，同时通常会应用数十个过滤器并动态计算统计数据和置信区间。因此，平均响应时间是以秒而不是毫秒来度量的。</p><p id="2a28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">P50和P95在普罗米修斯/格拉夫纳也可以看到，没有什么是突出的。但是，如果我们单击一个端点，例如<code class="fe nk nl nm nn b">/metrics/code_checks</code>，我们将访问更多详细信息并向下钻取。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7a00f4b3ba3adbd4bf3c244fc4e758f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTuCa_C9eWsRuO0KVoRzuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Sentry中的一个API端点运行缓慢。图片作者。</p></figure><p id="05c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">详细信息表显示了所选端点的分析跟踪，按持续时间降序排序。我感谢Sentry团队根据我的请求更改了<code class="fe nk nl nm nn b">USER</code>栏，以显示用户id而不是IP地址👏🙇‍♂️.</p><p id="2a5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过点击一个可疑的慢端点调用并研究一个类似profile的结构来继续。数据库和CPU瓶颈发生在哪里(当然，对于代码作者来说)变得一目了然。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/34fc529da6f8a2e144cdf49ec8313718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p92KnxYtZNMTF4sGZtGObw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Sentry中API端点跟踪的片段。图片作者。</p></figure><p id="a961" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">左窗格中的名称是手动代码检测的结果。例如，这就是我们如何检测对<code class="fe nk nl nm nn b">mine_check_runs()</code>函数的调用:</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="eabb" class="ml mm it nn b gy nu nv l nw nx">@sentry_span<br/>async def mine_check_runs(...):<br/>    # endpoint logic</span></pre><p id="755e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<code class="fe nk nl nm nn b">@sentry_span</code>是一个函数装饰器，用于将调用包装到跟踪树中的Sentry span-node中。当然，我们不会修饰我们拥有的每一个方法。相反，我们凭直觉判断什么是有趣的，什么是噪音。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="830a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nk nl nm nn b">sentry_sdk.start_span()</code>测量内部经过的时间。<code class="fe nk nl nm nn b">with sentry_sdk.Hub(sentry_sdk.Hub.current)</code>是哨兵SDK 中 <code class="fe nk nl nm nn b"><a class="ae lu" href="https://github.com/getsentry/sentry-python/issues/772" rel="noopener ugc nofollow" target="_blank">asyncio</a></code> <a class="ae lu" href="https://github.com/getsentry/sentry-python/issues/772" rel="noopener ugc nofollow" target="_blank">支持不完整的</a><a class="ae lu" href="https://github.com/getsentry/sentry-python/issues/772" rel="noopener ugc nofollow" target="_blank">解决方法。<code class="fe nk nl nm nn b">__tracebackhide__</code>是一个神奇的局部变量，它隐藏了pytest和Sentry中调用堆栈的包装函数。</a></p><p id="a677" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nk nl nm nn b">/metrics/code_checks</code>返回<a class="ae lu" href="https://api.athenian.co/v1/ui/#model-CodeCheckMetricID" rel="noopener ugc nofollow" target="_blank">向GitHub报告的CI运行</a>的各种统计数据:GitHub Actions、CircleCI、Appveyor等。一次提交可能会生成数十甚至数百次CI运行，根据Sentry trace，仅在客户端x的两周内，我们就加载了164，610次CI运行。通常，这不是问题，查询在大约500毫秒内完成，但我们很不幸。第二个问题出现在<code class="fe nk nl nm nn b">_disambiguate_pull_requests()</code>的Python函数中。向GitHub map报告的CI运行是提交请求，而不是拉请求。<a class="ae lu" href="https://docs.github.com/en/rest/reference/checks#create-a-check-run" rel="noopener ugc nofollow" target="_blank">GitHub就是这么工作的</a>。因此，如果有几个pr具有相同的提交，我们必须确定哪个pr触发了CI。<code class="fe nk nl nm nn b">_disambiguate_pull_requests()</code>应用多种启发式方法解决难题。我们可以也将会预计算这个函数，但是由于一些特定领域的问题，我们还没有预计算。</p><p id="2830" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">长话短说，在<code class="fe nk nl nm nn b">_disambiguate_pull_requests()</code>呆一秒钟都不行，我们应该深入挖掘，优化。</p><h2 id="0bae" class="ml mm it bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">剖析、重写、重复</h2><p id="a1c9" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">由于将请求体存储在Sentry跟踪元数据中，所以总是可以使用代理到本地主机的生产数据库进行本地重放。我们继续将函数的参数保存在磁盘上，并准备好<em class="oa">宏</em>基准。</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="0a28" class="ml mm it nn b gy nu nv l nw nx"># curl --data '{...}' http://localhost:8080/v1/metrics/code_checks</span><span id="0af0" class="ml mm it nn b gy ob nv l nw nx">async def <!-- -->_disambiguate_pull_requests(*args, **kwargs):<br/>    with open("/tmp/args.pickle", "wb") as fout:<br/>        pickle.dump((args, kwargs), fout)<br/>    exit()</span></pre><p id="01da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用pytest插件<code class="fe nk nl nm nn b"><a class="ae lu" href="https://github.com/ionelmc/pytest-benchmark" rel="noopener ugc nofollow" target="_blank">pytest-benchmark</a></code>进行基准测试。</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="b39b" class="ml mm it nn b gy nu nv l nw nx">def test__disambiguate_pull_requests(benchmark):<br/>    with open("/tmp/args.pickle", "rb") as fin:<br/>        args, kwargs = pickle.load(fin)<br/>    benchmark(_disambiguate_pull_requests, *args, **kwargs)</span></pre><p id="8cd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用<code class="fe nk nl nm nn b">pytest --benchmark-min-rounds=N</code>执行基准测试，其中N是精度和基准测试时间之间的折衷。n应该大到足以将波动限制在目标水平。我通常把目标定在平均值的0.5%到2%之间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/bc1952d1371b28b8b2d42b3dcd7f88f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4K9A-lXmQjs26jcVRyr4oQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例基准运行。图片作者。</p></figure><p id="e85b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经设置了<em class="oa">宏</em>基准，现在进入配置文件优化周期:</p><ol class=""><li id="df96" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt od mb mc md bi translated">收集当前代码的概要文件。</li><li id="26fb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt od mb mc md bi translated">分析概要文件:瓶颈是什么？最后的改变有帮助吗？</li><li id="442c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt od mb mc md bi translated">如果您看到一个均匀平坦的轮廓或挣扎着进一步优化，请停止。</li><li id="f752" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt od mb mc md bi translated">制定优化假设，并相应地重写代码。</li><li id="ea0b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt od mb mc md bi translated">转到步骤1。</li></ol><p id="fdd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我是收集<a class="ae lu" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank">间谍</a>个人资料的粉丝。这是Python的一个采样分析器:它以某种可配置的频率读取进程的内存转储，并识别和遍历线程堆栈。随着采样频率的增加，开销自然会增加，并且总会有一个折衷方案。我通常设置500赫兹的体面的结果。</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="193d" class="ml mm it nn b gy nu nv l nw nx">py-spy record -r 500 -o profile.ss -f speedscope -- pytest ...</span></pre><p id="899d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">py-spy可以输出类似于<a class="ae lu" href="https://github.com/jlfwong/speedscope" rel="noopener ugc nofollow" target="_blank"> speedscope </a> flamegraph格式的文件。我喜欢speedscope的“左重”视图，它非常适合研究重复的基准迭代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/686712805e431a24459093be3fa2de08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7fjoDuAu6L_4zOD6AHglw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由py-spy收集并在Speedscope中可视化的剖面，迭代0。图片作者。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/58e483820167a49d6f2aede4b9a4aca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTAH3oyfNg3LMgnAEKg54Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由py-spy收集并在Speedscope中可视化的剖面，迭代6。图片作者。</p></figure><p id="bb93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常需要十次左右的概要优化循环迭代才能达到极限并停止。上面两张图片是我开始优化和第六次迭代时的speedscope配置文件。我们看到右边不相关的粉红色火焰变得更宽了，而左边的一些火焰消失了——这很好。</p><p id="9744" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唉，<em class="oa">宏</em>基准继承了一些微基准的问题，特别是对上下文的依赖。当然，性能问题的最佳解决方案是改变算法，而不是绕过另一个pandas合并。我推荐大家观看费多尔·皮库斯的“为性能而设计”演讲。不要介意C++，因为提出的概念是普遍适用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of nz l"/></div></figure><h2 id="1feb" class="ml mm it bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">监控假设</h2><p id="2362" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">关于对上下文的依赖。我们为一个特定的客户优化了<code class="fe nk nl nm nn b">_disambiguate_pull_requests()</code>。我们怎么能确定我们没有其他客户端的性能下降呢？降低P95反而有什么整体影响？Prodfiler出现了。</p><p id="a0fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多人都听说过<a class="ae lu" href="https://ebpf.io/" rel="noopener ugc nofollow" target="_blank">eBPF</a>——可以说是自cgroups以来最伟大的Linux内核技术。我们有一个JIT内核虚拟机，它可以在运行时执行轻量级程序。eBPF可以像py-spy一样对Python调用栈进行采样，但是开销更小，并且可以推广到其他语言。Prodfiler是一个SaaS，它聚集了来自eBPF驱动的代理的跟踪。代理是一个影子Kubernetes pod，可以完全访问节点。</p><p id="c930" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下Prodfiler中的火焰图显示了<code class="fe nk nl nm nn b">_disambiguate_pull_requests()</code>在一天的生产中的表现。聚集周期越长，探查器收集的样本越多，精度就越高。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ca456989893f0e239b9c9870429fdf17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PO-sKnLEHVYIo6yGJREToQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对Prodfiler中函数性能的精细洞察。图片作者。</p></figure><p id="9091" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一些注意事项:</p><ul class=""><li id="22a8" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">与标准操作系统包相比，我们用一些额外的优化来编译CPython。因此，我们必须在CI/CD中将调试符号提交给Prodfiler。</li><li id="d2b9" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">不支持<code class="fe nk nl nm nn b">asyncio</code>,因此没有协程堆栈跟踪。</li><li id="3a00" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">与类似哨兵的手动工具相比，测量函数的逻辑部分是不可能的。</li></ul><p id="b3bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，Prodfiler已经被证明是验证性能优化的一个很好的工具。作为奖励，它无缝地将火焰分解到特定的内核函数，这是py-spy做不到的。</p><h2 id="4cd5" class="ml mm it bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">摘要</h2><p id="4543" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我已经描述了我们如何识别后端的慢速CPU点，分析它们，并监控优化。我们使用了:</p><ul class=""><li id="3085" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="https://docs.sentry.io/product/sentry-basics/tracing/distributed-tracing/" rel="noopener ugc nofollow" target="_blank">哨兵分布式追踪</a>。</li><li id="b51a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank">间谍</a>。</li><li id="d8d9" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://prodfiler.com/" rel="noopener ugc nofollow" target="_blank">前过滤器</a>。</li></ul><p id="4fca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一篇文章将会介绍我们如何应对PostgreSQL的性能，敬请关注，并请关注作者。哦，如果我们正在构建的产品听起来像是你的工程组织需要的东西，请查看我们的<a class="ae lu" href="https://athenian.co" rel="noopener ugc nofollow" target="_blank">网站</a>。</p></div></div>    
</body>
</html>