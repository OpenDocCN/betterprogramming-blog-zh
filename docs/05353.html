<html>
<head>
<title>The Importance of Priority Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优先级队列的重要性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-importance-of-priority-queues-f87e1f5ac842?source=collection_archive---------15-----------------------#2020-07-01">https://betterprogramming.pub/the-importance-of-priority-queues-f87e1f5ac842?source=collection_archive---------15-----------------------#2020-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8622" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">优先级队列可以解决一大堆不同的问题</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/9efd283db68905d76e0d2addd5c4e54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kenwxbETshLnNBEZ"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">利瓦伊·琼斯在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="aa39" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">优先级队列<em class="lt">、</em>也称为堆、<em class="lt">、</em>是计算机科学中一个经常被误解和低估的概念。尽管优先级队列非常简单，但它可以作为强大的工具来解决计算机科学中一些众所周知的问题。</p><p id="72cb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">本文主要关注优先级队列的基本概念，它们在C++中的用法，以及对一些最重要问题的应用。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="2ae9" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">优先级队列背后的概念</h1><p id="ca90" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">顾名思义，优先级队列<em class="lt"> </em>包含具有与之相关联的优先级的元素。我们先举一个简单的例子。</p><p id="57dd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设我们有一个食品杂货清单，并为它们附加了一个优先级。让我们将它们关联为插入到优先级队列中的键值对，如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1752d6047a66d780b8dfeb26e5ea039b.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*rOhy-6n3zGKMC6-ELHMV0A.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">具有优先级的食品杂货清单</p></figure><p id="3ba4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mz na nb nc b">Tomatoes</code>位于队列的顶部，具有最高的优先级，其次是<code class="fe mz na nb nc b">Noodles</code>、<code class="fe mz na nb nc b">Rice</code>和<code class="fe mz na nb nc b">Wheat</code>、<em class="lt">。</em>假设<em class="lt"> </em>我们要推送一个名为<code class="fe mz na nb nc b">Cake</code> <em class="lt"> </em>的项目，优先级等于<em class="lt"> </em> 10 <em class="lt">。</em>当我们将<code class="fe mz na nb nc b">Cake</code>推入优先级队列时，队列会检查该物品的优先级是否高于<code class="fe mz na nb nc b">Tomatoes</code> (7)。如果是，那么它被插入到队列的顶部。新队列如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nd"><img src="../Images/6f93845fe2f52820c908949021ee1f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*Gs9YSUkWhwlOAVaaYXxm0w.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">添加到优先级队列顶部的蛋糕</p></figure><p id="75d6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，假设我们想要推送优先级等于2的另一个杂货项目(<code class="fe mz na nb nc b">Chocolate</code> ) <em class="lt"> </em>)。在这种情况下，<code class="fe mz na nb nc b">Chocolate</code> (2)的优先级低于<code class="fe mz na nb nc b">Cake</code> (10)的优先级。因此队列弹出项目<code class="fe mz na nb nc b">Cake</code>并检查下一个项目<code class="fe mz na nb nc b">Tomatoes </code> (7)。情况与<code class="fe mz na nb nc b">Cake</code>类似——队列弹出<code class="fe mz na nb nc b">Tomatoes</code>。同样的规则也适用于<code class="fe mz na nb nc b">Noodles</code> (5)和<code class="fe mz na nb nc b">Rice</code> (3)。</p><p id="73ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该队列现在包含一个项目，<code class="fe mz na nb nc b">Wheat</code> (1)，位于队列的顶部。<code class="fe mz na nb nc b">Cake</code> (2)的优先级比<code class="fe mz na nb nc b">Wheat</code> (1)高，所以它被放在队列的顶部。从队列中弹出的项目按顺序放回后进先出。因此<code class="fe mz na nb nc b">Rice</code>、<code class="fe mz na nb nc b">Noodles</code>、<code class="fe mz na nb nc b">Tomatoes</code>和<code class="fe mz na nb nc b">Cake</code>被放回到优先级队列中，如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/2b435c38737abd1f7636c6803b3ecb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*LCMdc7grxIAWk264-NMfdQ.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">中间插入巧克力的优先队列</p></figure><p id="58ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">优先级队列的概念很简单。根据优先级将项目插入队列，<em class="lt"> </em>从队列顶部弹出<em class="lt"> </em>优先级最高的项目。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="a65b" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated"><strong class="ak">编码优先级队列</strong></h1><p id="4946" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">优先级队列是C++标准模板库(STL)的一部分。它们属于容器适配器的基本组，如堆栈和队列。他们是这样声明的:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="daf1" class="nj mc iq nc b gy nk nl l nm nn">priority_queue&lt;type&gt;pq;</span></pre><p id="f297" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mz na nb nc b">Type</code>表示任何变量类型，如<code class="fe mz na nb nc b">int</code>、<code class="fe mz na nb nc b">char</code>、<code class="fe mz na nb nc b">float</code>等。</p><p id="522e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">默认情况下，具有最高值(优先级)的元素位于队列的顶部。所有元素以降序排列在队列中。如果我们希望将具有最低值的元素放在队列的顶部，并按升序对元素进行排序，那么可以更改声明:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="d68a" class="nj mc iq nc b gy nk nl l nm nn">priority_queue&lt;type, greater&lt;type&gt;&gt;pq;</span></pre><p id="ab2b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们想对优先级队列中的元素进行自定义排序，那么使用自定义函数<code class="fe mz na nb nc b">myOrder</code>声明优先级队列:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="7d78" class="nj mc iq nc b gy nk nl l nm nn">priority_queue&lt;type, vector&lt;type&gt;, myOrder&gt;pq;</span></pre><p id="7d8f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">自定义函数需要是名为<code class="fe mz na nb nc b">myOrder</code> <em class="lt">的结构或类的一部分。</em>假设我们想要返回队列顶部具有最高值的元素。然后我们会返回<em class="lt"> </em> <code class="fe mz na nb nc b">p1.val &lt; p2.val</code>。</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="14c7" class="nj mc iq nc b gy nk nl l nm nn">struct myOrder{ </span><span id="661a" class="nj mc iq nc b gy no nl l nm nn">bool operator()(type const&amp; p1, type const&amp; p2){ </span><span id="05e9" class="nj mc iq nc b gy no nl l nm nn">//Write your own custom order function. For example, we order elements in decreasing order and return element with the highest value. </span><span id="0bc3" class="nj mc iq nc b gy no nl l nm nn">return p1.val &lt; p2.val; </span><span id="ee79" class="nj mc iq nc b gy no nl l nm nn">} </span><span id="86e5" class="nj mc iq nc b gy no nl l nm nn">};</span></pre><p id="0a01" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要将一个元素推入优先级队列<em class="lt"/><code class="fe mz na nb nc b">pq</code><em class="lt"/>我们使用:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="53fa" class="nj mc iq nc b gy nk nl l nm nn">pq.push(item);</span></pre><p id="ff7f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">类似地，为了从优先级队列中弹出一个项目，我们使用:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="2f41" class="nj mc iq nc b gy nk nl l nm nn">pq.pop();</span></pre><p id="82f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了访问队列顶部的元素，我们使用:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="f301" class="nj mc iq nc b gy nk nl l nm nn">type item = pq.top();</span></pre><p id="bd7b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了检查队列的大小，我们使用:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="61ff" class="nj mc iq nc b gy nk nl l nm nn">size_type t = pq.size();</span></pre><p id="9967" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要检查优先级队列是否为空，我们使用:</p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="01f1" class="nj mc iq nc b gy nk nl l nm nn">bool is_empty = pq.empty();</span></pre><p id="b87f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">其他函数，如<code class="fe mz na nb nc b">emplace</code>和<code class="fe mz na nb nc b">swap</code>，用于插入新的项目，并与其他优先级队列交换。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="96cd" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">优先级队列的应用</h1><h2 id="d436" class="nj mc iq bd md np nq dn mh nr ns dp ml lg nt nu mn lk nv nw mp lo nx ny mr nz bi translated">1.排序堆</h2><p id="717e" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">这一类别中的一个经典问题是找到前<em class="lt"> k </em>个频繁项目<em class="lt">。给定一个非空的单词列表，返回k个最频繁出现的元素。由于答案需要按降序排序，因此我们使用<code class="fe mz na nb nc b">max heap</code>来实现这一目的:</em></p><pre class="kh ki kj kk gt nf nc ng nh aw ni bi"><span id="ba05" class="nj mc iq nc b gy nk nl l nm nn"><strong class="nc ir">Input:</strong> ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4<br/><strong class="nc ir">Output:</strong> ["the", "is", "sunny", "day"]<br/><strong class="nc ir">Explanation:</strong> "the", "is", "sunny" and "day" are the four most frequent words,<br/>    with the number of occurrence being 4, 3, 2 and 1 respectively.</span></pre><p id="d1a3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个问题的解决方案包括使用无序映射将单词存储为一个<code class="fe mz na nb nc b">key</code>，将频率存储为一个<code class="fe mz na nb nc b">value</code> <em class="lt">。</em>我们根据<em class="lt"> </em>频率<em class="lt">将<em class="lt"> </em>字推入优先级队列。</em>出现频率最高的单词存储在队列的顶部。然后我们从队列中弹出单词并返回结果。</p><p id="e157" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">排序堆的其他例子有<em class="lt"> k </em>个最接近原点的点、<em class="lt">第k个</em>-流中最大的元素、<em class="lt">第k个</em>-排序矩阵中最小的元素、寻找具有最小和的<em class="lt"> k个</em>对，等等。<em class="lt"> </em>另外，堆排序——一种经典的排序算法——使用优先级队列对元素进行排序。</p><h2 id="0547" class="nj mc iq bd md np nq dn mh nr ns dp ml lg nt nu mn lk nv nw mp lo nx ny mr nz bi translated">2.负载平衡</h2><p id="3e80" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">堆扮演重要角色的另一个经典问题是负载平衡。负载平衡是一种计算机联网方法，涉及在多个计算资源之间分配工作负载。考虑分布式环境中负责执行多项任务的n个服务器。假设有一个来自用户的新请求。该请求需要被路由到具有最小工作负载和最大阈值的服务器。过载的服务器有一个阈值&lt; 0。</p><p id="9140" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了解决这样的问题，我们用<code class="fe mz na nb nc b">max heap</code> <em class="lt"> </em>来存储<em class="lt"> </em>阈值<em class="lt">。</em>具有最大阈值和最小负载的服务器存储在优先级队列的顶部。这个服务器从队列中弹出，负责执行新的用户请求。</p><h2 id="98b7" class="nj mc iq bd md np nq dn mh nr ns dp ml lg nt nu mn lk nv nw mp lo nx ny mr nz bi translated">3.数据压缩</h2><p id="9eb3" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">霍夫曼编码是一种无损数据压缩算法，其中数据中的每个字符都分配有一个可变长度的代码。最不常用的字符得到最大的代码，最常用的字符得到最小的代码。以这种方式编码数据既简单又高效。使用优先级队列存储带频率的字符和<code class="fe mz na nb nc b">max heap</code>树来压缩数据可以帮助解决这个问题。JPEG和MP3多媒体编解码器使用霍夫曼编码进行数据压缩。</p><h2 id="6d56" class="nj mc iq bd md np nq dn mh nr ns dp ml lg nt nu mn lk nv nw mp lo nx ny mr nz bi translated">4.图形算法</h2><p id="f36d" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">Dijkstra的最短路径算法<em class="lt"> </em>和<em class="lt"> </em> Prim的算法<em class="lt"> </em>以寻找从源到目标的最短路径而闻名。我们需要存储节点的邻接矩阵以及从<em class="lt">节点i </em>到<em class="lt">节点j的开销。</em> <code class="fe mz na nb nc b">Min heap</code> <em class="lt"> </em>可用于存储路径和与之相关的开销。成本最低的路径位于优先级队列的顶部。它会弹出，用于计算从源节点到目标节点的最短路径。</p><h2 id="8493" class="nj mc iq bd md np nq dn mh nr ns dp ml lg nt nu mn lk nv nw mp lo nx ny mr nz bi translated">5.人工智能算法</h2><p id="d9ff" class="pw-post-body-paragraph kx ky iq kz b la mt jr lc ld mu ju lf lg mv li lj lk mw lm ln lo mx lq lr ls ij bi translated">A*搜索算法是人工智能领域中用于寻路和图遍历的最好和最流行的技术之一。优先队列，在A*搜索算法中也称为边缘<em class="lt"> </em>，跟踪游戏中未探索的路线。总路径长度上的最低边界路由(即具有最短路径的路由)被赋予最高优先级。它被存储在队列的顶部。这条路线在游戏中用于以后的寻路。</p><p id="aa3e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这些应用只是使用优先级队列的几个例子。优先级队列的使用范围很广。它目前正在几个领域使用。因此，优先级队列，一个计算机科学中的基本概念，可以作为解决一些最有趣问题的有力工具。</p><p id="a03c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>