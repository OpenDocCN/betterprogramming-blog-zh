<html>
<head>
<title>The Future of React: Server Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的未来:服务器组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-future-of-react-server-components-90f6e3e97c8a?source=collection_archive---------2-----------------------#2021-01-06">https://betterprogramming.pub/the-future-of-react-server-components-90f6e3e97c8a?source=collection_archive---------2-----------------------#2021-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React即将推出的功能介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9e754e58fa9dfe477083a012ea979631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*tGA71mQYRla0DpyfrIG5ig.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">用<a class="ae ku" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">碳</a>生成的图像。</p></figure></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="f2a7" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">什么是服务器组件？</h1><p id="5ad0" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">今天，我们有了React组件，仅此而已。</p><p id="b9f1" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">然而，React团队现在正在试验一种新的想法，将组件分成两种类型:客户端组件和服务器组件。建议是开始用文件扩展名(<code class="fe mv mw mx my b">.client.js</code>和<code class="fe mv mw mx my b">.server.js</code>)来区分它们。那么它们是什么呢？</p><p id="981c" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">客户端组件只是我们今天拥有的组件。</p><p id="de73" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">另一方面，服务器组件是一种新型的组件，它首先在服务器端呈现，然后再发送到客户端。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="931f" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">有什么优势？</h1><p id="d7a1" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">乍一看，这听起来非常类似于服务器端渲染(SSR)。事实上，它提供了许多类似的优势:</p><ul class=""><li id="4213" class="mz na it lw b lx mq ma mr md nb mh nc ml nd mp ne nf ng nh bi translated">由于可以直接访问服务器端资源(如数据库、文件系统、内部微服务等),因此开发更容易。).</li><li id="e585" class="mz na it lw b lx ni ma nj md nk mh nl ml nm mp ne nf ng nh bi translated">更快的性能，因为我们避免了服务器和客户端之间的网络延迟。</li><li id="9f9b" class="mz na it lw b lx ni ma nj md nk mh nl ml nm mp ne nf ng nh bi translated">更小的捆尺寸。只在服务器上使用的库(例如<code class="fe mv mw mx my b">lodash</code>、<code class="fe mv mw mx my b">rambda</code>、<code class="fe mv mw mx my b">moment</code>等实用程序库)不需要提供给客户端。</li></ul><p id="170b" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">它还为React开发人员提供了一些生活质量的改善。最值得注意的是:</p><ul class=""><li id="b793" class="mz na it lw b lx mq ma mr md nb mh nc ml nd mp ne nf ng nh bi translated">自动代码分割(即将代码分割成小的包，这样客户端就可以只加载必要的代码)。目前，React开发人员必须有意识地通过编写如下代码来实现代码拆分:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/0b0ebe973de5001eeb288684141a899b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mkc3AcQoITo0mBthaznC5Q.png"/></div></div></figure><p id="e9ba" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">将来，服务器组件会自动处理它。这意味着我们可以像平常一样编写导入代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi ns"><img src="../Images/cc411d2e4bfe40af3b35819ae32d5ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqB4y8vvfxdZK_yD1xhhxQ.png"/></div></div></figure><p id="6e80" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">然而，最大的优势只有当我们仔细研究服务器组件和SSR之间的区别时才能理解。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="7a36" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">服务器组件与SSR有何不同？</h1><p id="0f9a" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">在SSR中，您在服务器上呈现HTML，然后将其发送到客户端。此过程在每次页面访问中只能发生一次(在初始加载时)。之后，您的应用程序与普通的React应用程序没有什么不同。要显示更新的数据，您需要从客户端进行网络调用或者刷新页面。这两个选项都将导致组件重新渲染并丢失它们的状态。</p><p id="b80e" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">在服务器组件中，您在服务器上呈现React组件，然后通过自定义协议将它们发送到客户端(参见下面的截图)。React获取这些数据，将新的UI合并到客户端树<em class="nt">中，而</em>不会影响任何客户端状态。这个过程可以发生无数次。跨UI更新保存客户端状态可以极大地改善用户体验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nu"><img src="../Images/434a1036ce14ae7c4adf00f0bfab8f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDuUZHUjB5DiIPFOt0PO-w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">获取服务器组件的网络调用示例。</p></figure><p id="28ec" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">要了解更多细节，请查看丹·阿布拉莫夫本人的<a class="ae ku" href="https://twitter.com/dan_abramov/status/1342264337478660096" rel="noopener ugc nofollow" target="_blank">这个帖子</a>，React数据团队的劳伦·谭的<a class="ae ku" href="https://twitter.com/sugarpirate_/status/1341141198258524163" rel="noopener ugc nofollow" target="_blank">这个帖子</a>，或者freeCodeCamp的Mehul Mohan的<a class="ae ku" href="https://www.freecodecamp.org/news/react-server-components/" rel="noopener ugc nofollow" target="_blank">这个帖子</a>。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="7db3" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">警告</h1><p id="8357" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">因为服务器组件是静态的，并且在后端呈现，所以对它们的使用有一些限制。</p><p id="e628" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">首先，服务器组件不能有任何交互性(即没有<code class="fe mv mw mx my b">useState()</code>，没有<code class="fe mv mw mx my b">useEffect()</code>)。要解决这个问题，您需要在服务器组件中导入客户端组件(可以是交互式的)。例如，您可以像这样两全其美:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nv"><img src="../Images/680711d23ff3824f10544224b6194bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYjfp5Azv0wrnU-WUkHSSQ.png"/></div></div></figure><p id="32b5" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">其次，从服务器组件传递到客户端组件的<code class="fe mv mw mx my b">props</code>必须在网络上是可序列化的(即可以传入字符串、JSON和JSX等数据，但不能传入JavaScript函数)。这是因为呈现的服务器组件必须通过网络发送。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="8ba5" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">下一步是什么？</h1><p id="5f77" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">虽然这非常令人兴奋，但该功能仍处于试验阶段。它的API和实现可能会发生变化。这是<em class="nt">不是</em>生产就绪。</p><p id="4923" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">目前，React团队正在与Next.js团队密切合作，将服务器组件集成到框架中。有一个webpack插件的alpha版本，一个package插件的谈判正在进行中。</p><p id="9e2f" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">最后，服务器组件将是一个选择加入的功能。现有的React代码仍然可以工作，不需要急着使用新特性。</p><p id="d15c" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">有关该功能的更多详细信息，我鼓励您查看<a class="ae ku" href="https://youtu.be/TQQPAU21ZUw" rel="noopener ugc nofollow" target="_blank">演示视频</a>或<a class="ae ku" href="https://github.com/josephsavona/rfcs/blob/server-components/text/0000-server-components.md#update-refetch-sequence" rel="noopener ugc nofollow" target="_blank">本RFC </a>！</p><p id="e4e1" class="pw-post-body-paragraph lu lv it lw b lx mq ju lz ma mr jx mc md ms mf mg mh mt mj mk ml mu mn mo mp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>