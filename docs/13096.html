<html>
<head>
<title>7 Ways of Reading a File in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中读取文件的7种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-ways-of-reading-a-file-in-python-855340b002dc?source=collection_archive---------2-----------------------#2022-07-28">https://betterprogramming.pub/7-ways-of-reading-a-file-in-python-855340b002dc?source=collection_archive---------2-----------------------#2022-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="732a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你能在不打开文件的情况下读取它吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a4c81af303525a2a8e40a8295f6b94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-UdRS6GkMi1xusnS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/es/@gluca?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gianluca Cinnante </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python编程语言以其巨大的灵活性而闻名，无论是在语法方面还是在如何实现某个目标方面。事实上，对于Python程序员来说，有无数不同的方法可以获得相同的最终结果，从使用花哨的语法到破解内置功能。</p><p id="ea23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示用Python读取文件内容的7种方法。</p><h1 id="7001" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">老式的内置open()函数</h1><p id="53cd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Python中读取文件的第一个也是最基本的方法是使用内置的<code class="fe ms mt mu mv b">open()</code>函数，该函数返回一个可读的流。随后，您可以使用<code class="fe ms mt mu mv b">read()</code>方法来读取流的内容。</p><p id="304f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们在Python脚本的同一个目录中有一个名为<code class="fe ms mt mu mv b">file.txt</code>的文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，这是一个有点平庸和非pythonic式的。让我们看看更好的方法。</p><h1 id="e9af" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用上下文管理器打开</h1><p id="d6be" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是Python中读取文件最常见的方式。上下文管理器防止在打开或读取文件时发生错误时的内存泄漏，因为它负责在任何情况下关闭文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="047b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法与传统的方法没有本质上的不同，但它通常被认为是更好、更干净、更安全的方法。</p><p id="ec3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经排除了“默认”方法，那么让我们转到读取文件内容的更奇特的方法。</p><h1 id="7d3a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用内置的文件系统模块</h1><p id="001c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">开发者说Python有一个模块来处理所有的事情。不出所料，它还有一个与文件系统交互的模块叫做<code class="fe ms mt mu mv b"><a class="ae ky" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank">pathlib</a></code>。</p><p id="5ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe ms mt mu mv b">pathlib</code>读取文件就像创建一个<code class="fe ms mt mu mv b">Path</code>对象并调用它的<code class="fe ms mt mu mv b">read_text()</code>方法一样简单，不需要手动关闭流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ee7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管非常简单，但您通常不会在Python代码库中找到这种方法，因为它需要导入一个模块。</p><p id="079a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将看一看“黑客”，或者奇怪的、非默认的读取文件的方式，尽管如此，它们还是实现了最终目标。</p><h1 id="fc86" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用外壳</h1><p id="8687" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您曾经使用过类似UNIX的操作系统，那么您肯定熟悉标准的<code class="fe ms mt mu mv b">cat</code>命令。这个名字实际上来源于单词“con <strong class="lb iu"> cat </strong> enate ”,与可爱的宠物无关。</p><p id="c79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内置的<code class="fe ms mt mu mv b">subprocess</code>模块允许您运行shell命令，并从Python脚本中处理它们的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些拥有Windows操作系统的人来说，你可以使用类似的<code class="fe ms mt mu mv b">type</code>命令来代替……或者直接切换到Linux。</p><p id="a548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你认为这种读取文件的方式不寻常，那就勒紧裤腰带吧:我们变得越来越奇特了。</p><h1 id="2670" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建自定义C扩展</h1><p id="9506" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你对Python的内置函数不满意怎么办？您可以编写自己的自定义C扩展。为了保持文章简洁，我不打算解释为Python创建C扩展的完整过程。如果你有兴趣了解更多关于这个话题的信息，请查阅<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/speed-up-your-python-codebases-with-c-extensions-94859875eb70">这个指南</a>。</p><p id="7102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你要写C扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你创建了<code class="fe ms mt mu mv b">setup.py</code>脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，构建并安装C扩展:</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="3dc3" class="nc lw it mv b gy nd ne l nf ng">python3 setup.py build<br/>python3 setup.py install --user</span></pre><p id="abe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以在Python脚本中导入您的自定义C模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于读取文件内容来说，这有点过于复杂了，不是吗？下一种方法不包含任何C代码，但同样有些夸张。</p><h1 id="65eb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建一个web服务器来服务该文件</h1><p id="d3c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用Python内置的<code class="fe ms mt mu mv b">flask</code>模块运行一个小型web服务器，通过HTTP发送文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以使用<code class="fe ms mt mu mv b">requests</code>库向服务器请求文件内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很不寻常，对吧？下一个将是一个真正的黑客。</p><h1 id="82c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">暴力破解文件内容</h1><p id="8ab3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有可能不打开文件就能读取它吗？正如您可能已经猜到的，我们将尝试所有可能的字节组合，并检查它们是否与实际的文件内容相对应。然而，为了实现这一点，我们不能直接在Python中打开文件，所以我们将利用返回给定文件的md5散列的<code class="fe ms mt mu mv b">md5sum</code> UNIX命令。</p><p id="3687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了校验和，我们就开始暴力破解，直到我们找到正确的字节组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法既糟糕又可怕。在找到正确的文件内容之前，它必须检查的最大组合数是<code class="fe ms mt mu mv b">256ⁿ</code>，其中<code class="fe ms mt mu mv b">n</code>是以字节为单位的文件大小，而<code class="fe ms mt mu mv b">256</code>是一个字节中可能的组合数。</p><p id="2aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论这种方法效率有多低，您的Python脚本最终都会在不读取文件内容的情况下猜测文件内容，除非您的计算机先死机。</p><h1 id="3442" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5b4a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总结一下，在Python中有无数种方法可以读取文件的内容。有些是有意义的，应该在真正的代码库中使用，而另一些是深奥的技巧，只是为了证明概念或进行编码练习。</p><p id="10b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。如果你有任何其他用Python读取文件的奇特方法，请在评论中分享。感谢阅读！</p><p id="8196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于Python的C扩展，我建议你看看下面这个故事:</p><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/speed-up-your-python-codebases-with-c-extensions-94859875eb70"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">用C扩展加速你的Python代码库</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">给你的Python程序带来C语言的速度</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">better编程. pub</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>