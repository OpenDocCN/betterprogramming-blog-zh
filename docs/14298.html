<html>
<head>
<title>Cashing In on Caching as a Frontend Engineer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为前端工程师利用缓存赚钱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cashing-in-on-caching-as-a-frontend-engineer-611a7c57f6b5?source=collection_archive---------2-----------------------#2022-11-26">https://betterprogramming.pub/cashing-in-on-caching-as-a-frontend-engineer-611a7c57f6b5?source=collection_archive---------2-----------------------#2022-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b325" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过学习缓存策略提高网站性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1401eba62ed8db5929e963e8fb0c517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*55Li8_UoVTb4LvXy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cf52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像React.js、Next.js等现代javascript框架。，通过更加模块化、声明式的开发风格提升了最终用户和开发人员的体验。虚拟DOMS和diffing有助于优化DOM操作。</p><p id="6c7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是对于浏览器来说，绘制DOM并不是唯一需要担心的事情。它还处理文件和网络呼叫；一堆HTML，CSS，JS，字体，图片等等。，用于构建页面。</p><p id="5c1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如Sam Thorogood在这个<a class="ae kv" href="https://www.youtube.com/watch?v=tprJYFkv4LU" rel="noopener ugc nofollow" target="_blank">视频</a>中所说，前端工程师更经常地专注于提高<a class="ae kv" href="https://web.dev/performance-scoring/" rel="noopener ugc nofollow" target="_blank">灯塔评分</a>，这主要关注网站的首次加载体验。当用户再次访问网站时，我们还应该优先考虑第二次(或随后的)加载速度。这就是缓存和高效缓存策略发挥作用的地方。</p><blockquote class="ls lt lu"><p id="f12a" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">缓存是将可重用数据存储在高速数据存储层中的想法，因此可以更快地检索这些数据以满足未来的请求。</p></blockquote><p id="cd8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一些文件在网站上不经常改变，浏览器可以缓存它们，这样它们可以更快地为未来的请求服务，并节省大量的网络调用。(还有网费！)</p><blockquote class="ls lt lu"><p id="c588" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">"计算机科学中只有两个难题:缓存失效和事物命名."—菲尔·卡尔顿</p></blockquote><p id="d2a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想分享我所学到的关于网络缓存的知识。</p><h1 id="7db6" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">概观</h1><p id="ad5a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这里有一个简化的视图，以便更好地理解主要参与者。除了客户端缓存，我们还在代理服务器或cdn上实现了共享缓存，可供多个客户端使用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/be26d1a9980181febd6830a0c5598670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoSbGhFV6Pg-9ej2X13TQg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">浏览器缓存和共享缓存</p></figure><p id="0f3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">资源缓存是在<code class="fe mx my mz na b">Cache-Control</code> HTTP头的帮助下完成的。它有请求和响应指令，告诉浏览器和共享缓存如何访问资源(后面会详细介绍)。</p><h1 id="9b8e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">浏览器端缓存初探</h1><p id="3f83" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面是我的Twitter个人资料页面第一次加载(或者清空缓存硬重装后)。观察“大小和时间”选项卡。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/ef70b1e9f78faddb0285f0b72652065b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUtPjuYkBAJZbFzPSIKZOw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Chrome开发工具的网络标签在第一次加载时显示Twitter网站上的图片(没有缓存)</p></figure><p id="1b21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我第二次打开它。请注意，时间急剧减少。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/f337bfe956eb052ca740cbc160e227ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LD0Vghvp-vhi0EU6V0u_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Chrome dev tools的网络标签显示了第二次加载时Twitter网站上的图片(带磁盘缓存)</p></figure><p id="4cd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我每次打开它的钱。它在0 ms内加载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/65b555f317a8d5fd33a305ff178d70e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6w1Atb36mt8h1-pL-jKBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Chrome dev tools的网络标签显示Twitter网站上加载的图片(来自内存缓存)</p></figure><p id="87ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Twitter徽标、图标、我的个人资料横幅、个人资料图片等项目。，不经常更改，因此会被缓存。</p><p id="73ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么会有磁盘缓存和内存缓存呢？</p><h1 id="76f7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">浏览器中的缓存类型(Chrome)</h1><p id="fcf0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Google chrome有四种类型的缓存:</p><ol class=""><li id="87d0" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">内存缓存:内存缓存是一种短期缓存，它存储当前文档生命周期(非持久)内缓存的所有资源。在选项卡/会话关闭之前，此处缓存的资源会一直保留。它存储在内存中。</li><li id="11ed" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">磁盘缓存:磁盘缓存(HTTP缓存)是一种永久缓存，允许资源在会话之间和跨站点重用。它是基于磁盘的缓存。</li><li id="e400" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">服务工作者缓存:服务工作者有一个缓存API，我们可以用它来控制缓存，并且是持久的。服务工作者是一个JS文件，是构建PWA(渐进式Web应用程序)的基本组件。</li><li id="d16a" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">推送缓存:推送缓存是存储HTTP/2推送资源的地方。推送是一种性能优化技术，其中服务器在浏览器请求资源之前向浏览器发送一些资源。我们不会在这里深入讨论，因为我正在弄清楚它到底是如何使用的(让我知道你是否知道更多关于推送缓存的信息)</li></ol><p id="672f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击了解更多信息<a class="ae kv" href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="ls lt lu"><p id="6dcb" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>只有当页面上注册了服务工作者时，服务工作者缓存才会存在。</p></blockquote><p id="4192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Twitter的JS文件是从<code class="fe mx my mz na b">Service</code> worker缓存中加载的。这是因为Twitter web应用程序是一个PWA，所以它注册了一个服务人员。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/2d4bf42cc0417f899461903479fb44f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHTUEuOrDtCGTgKOoNCyYg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Twitter站点的JS文件缓存在服务工作者缓存中</p></figure><h2 id="ec43" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated">浏览器的缓存流程</h2><p id="88ea" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">根据<a class="ae kv" href="https://web.dev/service-worker-caching-and-http-caching/" rel="noopener ugc nofollow" target="_blank"> web.dev </a>的说法，浏览器在检查资源时遵循缓存流顺序。内存缓存存在于服务工作者缓存之上(下图中缺失)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/7e9e190866ac9d8c14e7dbaeff077a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEDd93DdKrdhScduOkbPkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">浏览器的缓存流程</p></figure><h1 id="8aeb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">捆绑工具和缓存破坏</h1><p id="bbfc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设你的网站有一个<code class="fe mx my mz na b">index.html</code>、<code class="fe mx my mz na b">script.js</code>和<code class="fe mx my mz na b">style.css</code>。您希望项目被缓存很长一段时间(比如一年左右)，但是您也在定期对<code class="fe mx my mz na b">script.js</code>和<code class="fe mx my mz na b">style.css</code>进行更改和部署。因为名称没有改变，所以用户可以从缓存中获得文件。</p><p id="31da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缓存破坏是解决这个问题的一种方式，我们在文件名中使用版本或哈希，以便浏览器可以加载它们并更新缓存。</p><p id="1499" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将阻止浏览器缓存HTML文件，加载到<code class="fe mx my mz na b">&lt;link&gt;</code>或<code class="fe mx my mz na b">&lt;script&gt;</code>标签中的文件也将在它们的名称中有一个版本(大多数内容都有)，以便浏览器可以加载它们并更新缓存。</p><p id="fef3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用过<a class="ae kv" href="https://webpack.js.org/guides/caching/" rel="noopener ugc nofollow" target="_blank"> webpack </a>或者类似的工具来构建你的应用程序(或者使用类似于<a class="ae kv" href="https://create-react-app.dev/docs/production-build/#static-file-caching" rel="noopener ugc nofollow" target="_blank"> CRA </a>的东西)，你一定见过捆绑的CSS和JS文件以<code class="fe mx my mz na b">main.[content-hash].js</code>的格式有着奇怪的名字。每当文件内容发生变化时，内容哈希也会发生变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/036713427fb71af0b543bd71d2f3562e.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*kPXPknJnWm-NerCI8_1nIw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">名称中的内容哈希支持缓存破坏</p></figure><h1 id="8155" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">高速缓存控制标题</h1><p id="2465" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这是网络缓存的圣杯。作为来自服务器的响应的一部分的cache-control头可以告诉浏览器或代理是否缓存资源、应该缓存多长时间、是否应该重新验证等等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6f3b63378dc21f7e2d1d268a9ba43d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*Vf1HzynRlDfrrdisL2XeEg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">包含cache-control的HTTP响应标头</p></figure><p id="38a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，上面的配置说响应可以在缓存中存储一周，并在新鲜时重用。如果响应变得<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age" rel="noopener ugc nofollow" target="_blank">陈旧</a>，那么在重用之前必须通过原始服务器的验证(因为<code class="fe mx my mz na b">must-revalidate</code>响应指令)。</p><p id="f413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以根据我们的需要进行配置，而且非常广泛。我发现<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>是了解它的最佳地方。这里有一篇杰克·阿奇博尔德写的关于缓存最佳实践的文章。</p><h1 id="30c1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">验证、ETags和HTTP状态代码304</h1><p id="cf48" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设一个文件在缓存中，浏览器在使用它之前必须重新验证它。这可以在一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" rel="noopener ugc nofollow" target="_blank">实体标签(ETag) </a>即。HTTP头。ETag的值是表示文件的特定版本的标识符。它们还有助于防止文件的同时更新相互覆盖。例如:</p><pre class="kg kh ki kj gt oj na ok bn ol om bi"><span id="95a5" class="on ma iq na b be oo op l oq or">ETag: "&lt;etag_value&gt;"</span></pre><p id="b81b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是它如何工作的简单概述。假设浏览器向服务器请求一个文件<code class="fe mx my mz na b">ABC.svg</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/80a69f4e0fb0c8e5d3f6d1834c9fc3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZ8L3x2XUaWu6JwaQgYTBg.png"/></div></div></figure><ol class=""><li id="1b69" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">服务器发回文件，生成一个ETag，并将其与200 HTTP状态代码一起附加到响应头。然后，浏览器会对此进行缓存。</li><li id="ce51" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">现在，如果浏览器必须重新验证缓存中的文件，它会发送一个请求以及之前收到的ETag。</li><li id="7d5e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">然后，服务器检查文件的ETag，如果版本没有改变，它会发回一个带有304 HTTP状态码的响应，告诉浏览器文件没有被修改，可以重用旧文件。否则，服务器发送文件的新版本，以及新的ETag和200 HTTP状态码。</li></ol><h1 id="ed39" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="551f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">缓存是提高web性能的重要组成部分。因此，理解它的工作原理是很重要的。这篇文章是对缓存的简单介绍，并不是深入的指导。</p><p id="e9b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><h2 id="3109" class="ns ma iq bd mb nt nu dn mf nv nw dp mj lf nx ny ml lj nz oa mn ln ob oc mp od bi translated"><strong class="ak">延伸阅读和参考资料</strong></h2><ul class=""><li id="f014" class="nd ne iq ky b kz mr lc ms lf ot lj ou ln ov lr ow nj nk nl bi translated"><a class="ae kv" href="https://web.dev/love-your-cache/" rel="noopener ugc nofollow" target="_blank">爱你的缓存</a></li><li id="900b" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ow nj nk nl bi translated"><a class="ae kv" href="https://web.dev/use-long-term-caching/" rel="noopener ugc nofollow" target="_blank">利用长期缓存</a></li><li id="107f" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ow nj nk nl bi translated"><a class="ae kv" href="https://jakearchibald.com/2016/caching-best-practices/" rel="noopener ugc nofollow" target="_blank">缓存最佳实践&amp;最大年龄问题</a></li><li id="5166" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ow nj nk nl bi translated"><a class="ae kv" href="https://calendar.perfplanet.com/2016/a-tale-of-four-caches/" rel="noopener ugc nofollow" target="_blank">四个缓存的故事</a></li><li id="0ca2" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ow nj nk nl bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#types_of_caches" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/enUS/docs/Web/HTTP/Caching # types _ of _ caches</a></li></ul></div></div>    
</body>
</html>