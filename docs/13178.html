<html>
<head>
<title>The Ultimate Clean Architecture Template for TypeScript Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript项目的终极干净架构模板</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-ultimate-clean-architecture-template-for-typescript-projects-e53936269bb9?source=collection_archive---------1-----------------------#2022-08-04">https://betterprogramming.pub/the-ultimate-clean-architecture-template-for-typescript-projects-e53936269bb9?source=collection_archive---------1-----------------------#2022-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a8a9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">遵循干净架构原则创建基于层的TypeScript项目模板的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbd144ebc67749d3502e320e1b615621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e54_eZAXLmxguSXB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马克斯·兰格洛特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><pre class="kg kh ki kj gt kw kx ky kz aw la bi"><span id="1d5f" class="lb lc iq kx b gy ld le l lf lg">Table of Contents</span><span id="0b92" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#e215" rel="noopener ugc nofollow">Intro</a><br/><a class="ae kv" href="#8887" rel="noopener ugc nofollow">What is clean architecture</a></span><span id="edd5" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#8571" rel="noopener ugc nofollow">A Detailed Implementation Guide</a><br/><a class="ae kv" href="#6973" rel="noopener ugc nofollow">Create your project directories and root</a><br/><a class="ae kv" href="#bd70" rel="noopener ugc nofollow">Configuring Core, Data, and DI</a><br/><a class="ae kv" href="#9fa7" rel="noopener ugc nofollow">Setting up the mono repo configuration</a><br/><a class="ae kv" href="#8c97" rel="noopener ugc nofollow">Setting up dependencies between packages</a></span><span id="d97a" class="lb lc iq kx b gy lh le l lf lg"><a class="ae kv" href="#88f7" rel="noopener ugc nofollow">How do I use this masterpiece of a mono repo</a><br/><a class="ae kv" href="#0a61" rel="noopener ugc nofollow">Why I did things the way that I did</a><br/><a class="ae kv" href="#1179" rel="noopener ugc nofollow">Extras</a><br/><a class="ae kv" href="#9ea1" rel="noopener ugc nofollow">References and Links</a></span></pre><h1 id="e215" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">介绍</h1><p id="6205" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">这就是了。你一生都在寻找这个。你猜怎么着？你找到了！结束您的痛苦，苦难，以及在您认为您的应用程序将在三个小时内完成的日子里编写的调试代码的时间。或者当你认为你只是在做一个不值得努力的演示应用时。或者当你还不知道的时候。</p><p id="d7e5" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">在本指南中，我将解释我创建实现干净架构原则的TypeScript项目模板的方法。这可能适用于你能想到的任何类型的应用程序，包括带有Angular、React、Vue或React Native或electronic等其他框架的SPAs(单页应用程序)。基本上它用TypeScript就行了。</p><p id="3d7a" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">干净的架构不仅仅是遵循几条规则，让编写应用程序不那么痛苦。它是关于转变您的工作环境，以帮助您实施适当的架构和依赖规则。你不允许你自己，可能在未来的某个时刻，变得懒惰，完全无视规则，只是为了尽快制作一部电影，因为<insert_bad_reason_here>它会反咬你一口。</insert_bad_reason_here></p><h1 id="8887" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">什么是干净的建筑？</h1><p id="a10f" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><a class="ae kv" href="#8571" rel="noopener ugc nofollow">点击此处跳到精彩片段</a></p><p id="d1a9" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">Bob叔叔的干净架构背后的想法是关注点的分离。它允许您的代码独立于框架、数据库或用户界面。这也使得你的代码更易测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/c5ca91716942c51029efac6212141677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t6HRr_Z4yRNq0QaF.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">干净架构中依赖关系的可视化(摘自鲍勃叔叔的博客)</p></figure><p id="ee46" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">该图可视化了干净架构的核心思想:依赖规则。你会注意到所有的箭头都向内指向实体。这意味着实体不依赖于任何东西，但一切都依赖于它们。这是因为实体代表你的业务规则，并不关心你是否使用Angular、React、Vue等。</p><p id="1788" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">简而言之，企业业务规则是您实现定义企业/应用程序核心规则的类或模型的层。</p><p id="dd51" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">您使用包含层与这些实体进行交互，这就是用例。它们规定了实体之间的数据流。它们允许下面的层与实体进行交互。</p><p id="3737" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">接下来，控制器与用例进行交互，以产生在演示者中使用的输出，正如您在图的右下部分所看到的。这是角度或反应组件发生的地方，承担控制器和演示者的角色。</p><p id="1aee" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">最后，在最外层有一些细节，比如数据库。这意味着你可以改变这些最外层的细节，而不必改变任何内部的圆圈。有道理，对吧？例如，一个Web框架并不关心你使用的是MongoDB、SQL还是区块链。当然，用例或实体离这些工具更远。</p><h1 id="8571" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">详细的实施指南</h1><p id="e228" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">开始之前，有几件事要提一下:</p><p id="a3b8" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">首先，我将应用程序模板分为四层:核心层、数据层、依赖注入层(DI)和表示层。</p><ul class=""><li id="27cb" class="nb nc iq mb b mc mv mf mw mi nd mm ne mq nf mu ng nh ni nj bi translated">核心:包含我们的实体、用例以及存储库接口。这是应用程序的核心(因此得名)。</li><li id="c441" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated">数据:包含用于从本地和远程存储中检索数据的核心存储库的实现。这就是我们获取和存储数据的方式。</li><li id="ea28" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated">DI:将核心和数据联系在一起，允许表示直接依赖于核心。</li><li id="efb9" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated">表示层:这一层是用户看到我们的应用程序并与之交互的方式。例如，它将包含我们的角度或反应代码。</li></ul><p id="59b8" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">第二，我更喜欢在这里使用Lerna，因为它最不会让我头疼。有像Yarn或Npm工作空间这样的替代方案，但对我来说，它们没有当前的解决方案那么简单。</p><p id="3477" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">最后，在某些方面你可能不同意我的方法，但是，这个架构的美妙之处在于，只要你的应用程序核心不变，并且它的依赖只针对它自己，你就可以用任何东西替换任何东西。</p><p id="1512" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">说了这么多，开始吧。</p><h2 id="6973" class="lb lc iq bd lj np nq dn ln nr ns dp lr mi nt nu lt mm nv nw lv mq nx ny lx nz bi translated">创建您的项目目录和根目录</h2><ul class=""><li id="374f" class="nb nc iq mb b mc md mf mg mi oa mm ob mq oc mu ng nh ni nj bi translated">为您的项目创建一个文件夹。我刚把我的叫做<code class="fe od oe of kx b">root</code>。</li><li id="156e" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated">在该文件夹中，创建一个名为packages的文件夹。在其中，创建三个文件夹:<code class="fe od oe of kx b">core</code>、<code class="fe od oe of kx b">data</code>和<code class="fe od oe of kx b">di</code>。</li></ul><p id="521b" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">您现在应该有如下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/504f4ae612a9aba125afabc7ed1b55ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*d-wDMQjzjYbO6Oo6OJFeSg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">初始文件夹结构</p></figure><p id="9924" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">接下来，我们必须初始化所有这些。在每个<code class="fe od oe of kx b">root</code>、<code class="fe od oe of kx b">core</code>、<code class="fe od oe of kx b">data</code>、<code class="fe od oe of kx b">di</code>内，执行以下命令:</p><ul class=""><li id="2e4e" class="nb nc iq mb b mc mv mf mw mi nd mm ne mq nf mu ng nh ni nj bi translated">运行<code class="fe od oe of kx b">npm init -y</code></li><li id="29f7" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated">创建一个<code class="fe od oe of kx b">tsconfig.json</code>文件。使用下面提供的配置。</li></ul><p id="e0e0" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">对于根节点<code class="fe od oe of kx b">tsconfig.json</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="5705" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">对于<code class="fe od oe of kx b">core</code>和<code class="fe od oe of kx b">data</code> tsconfig.json</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="4069" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated"><code class="fe od oe of kx b">di</code>为<code class="fe od oe of kx b">tsconfig.json</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="cbda" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">最后，我们创建演示文稿。你想怎么做都行。我只是使用angular CLI来创建它，因为这是我更喜欢的框架。要用Angular CLI初始化一个项目，运行包目录中的<code class="fe od oe of kx b">ng new</code>,根据您的喜好完成各个步骤。</p><p id="2a5f" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">我还补充道。gitignore文件到所有的包以及根来忽略<code class="fe od oe of kx b">node_module</code> s并通过添加一个<code class="fe od oe of kx b">/node_modules</code>和一个<code class="fe od oe of kx b">/build</code>条目来构建。</p><p id="ba9f" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">完成所有这些后，您应该有以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/61df5b1fcabd2cdc5b46d73b2c6c839e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*aiQFzMJ64olt8Vw5WIAppA.png"/></div></figure><h1 id="bd70" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">配置核心、数据和DI</h1><p id="4145" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">接下来，我们配置<code class="fe od oe of kx b">core</code>、<code class="fe od oe of kx b">data</code>和<code class="fe od oe of kx b">di</code>。它们都遵循相同的初始配置。因此，对所有这些应用程序执行以下步骤(或者仅对核心应用程序执行这些步骤，然后将所有内容复制并粘贴到数据和di中):</p><p id="10a6" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">首先，创建一个名为<code class="fe od oe of kx b">src</code>的文件夹，并在其中添加一个名为<code class="fe od oe of kx b">index.ts</code>的文件。这个文件将暴露我们想要从包中导出的所有内容。在<code class="fe od oe of kx b">src</code>内部，创建一个名为<code class="fe od oe of kx b">tests</code>的文件夹。这将包含我们对这个包的所有单元测试。</p><p id="a3a5" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">有几个脚本和<code class="fe od oe of kx b">devDependencies</code>我们需要添加到<code class="fe od oe of kx b">package.json</code>。您可以复制并粘贴以下内容(更改数据和di包的名称):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="2c58" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">注意文件末尾的<code class="fe od oe of kx b">types</code>属性。这对于允许此包在其他包中导入和使用是必要的。</p><p id="5009" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">以下是对这些脚本的解释:</p><ul class=""><li id="bb54" class="nb nc iq mb b mc mv mf mw mi nd mm ne mq nf mu ng nh ni nj bi translated"><code class="fe od oe of kx b">build</code>:构建您的项目，产生一个包含index.d.ts的构建文件夹，它将使这个包能够被导入到其他包中。</li><li id="3dfb" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">build:watch</code>:导致项目在每次代码更改时重新生成</li><li id="40b1" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">rollup</code>:在构建之后捆绑你的项目类型。这是创建包含正确声明和导出的<code class="fe od oe of kx b">index.d.ts</code>所必需的。</li><li id="d2cf" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">test</code>:运行您的包中的所有单元测试</li><li id="c76b" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">test:watch</code>:对每一个相关的变更重新运行你的测试。(更多信息见<a class="ae kv" href="https://jestjs.io/docs/cli#--watch" rel="noopener ugc nofollow" target="_blank"> jest文档</a></li></ul><p id="af93" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">下面是对<code class="fe od oe of kx b">devDependencies</code>的解释:</p><ul class=""><li id="c209" class="nb nc iq mb b mc mv mf mw mi nd mm ne mq nf mu ng nh ni nj bi translated"><code class="fe od oe of kx b">rollup</code>、<code class="fe od oe of kx b">rollup-plugin-dts</code>和<code class="fe od oe of kx b">@rollup/plugin-typescript</code>:一个模块捆绑器，用于将<code class="fe od oe of kx b">index.d.ts</code>文件固定成对我们的用例更有用的东西。</li><li id="b689" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">jest</code>和<code class="fe od oe of kx b">ts-jest</code>:用于编写和运行单元测试</li><li id="d4a0" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">nodemon</code>:允许我们在代码改变时运行命令。参见<code class="fe od oe of kx b">build:watch</code>脚本。</li><li id="9ce4" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated">剩下的都是TypeScript的依赖。</li></ul><p id="6c6b" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">我们需要为rollup和jest添加几个配置文件。这些文件与<code class="fe od oe of kx b">package.json</code>处于同一级别。他们在这里:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e63b" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">最后一件事:我们不希望我们的构建包含测试，所以在<code class="fe od oe of kx b">tsconfig.json</code>旁边创建一个名为<code class="fe od oe of kx b">tsconfig.build.json</code>的新文件。这是我们在<code class="fe od oe of kx b">package.json</code>的构建脚本中使用的文件。其内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="2669" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">就是这样！</p><p id="89df" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">您的每个包现在应该看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/20e14f528ffae0a42d8f2ef3904e17d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*JSLy8ElzFzpDq-1_5jWMxw.png"/></div></figure><p id="1f47" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">我们现在可以对我们的包进行测试构建了。为了在构建中实现，将任何导出添加到您的包的<code class="fe od oe of kx b">index.ts</code>文件中。例如:<code class="fe od oe of kx b">export const Foo = 1;</code></p><p id="931e" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">现在，在每个内核、数据和di中运行<code class="fe od oe of kx b">npm install &amp;&amp; npm run build</code>。</p><p id="66bf" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">正确运行后，查看您的<code class="fe od oe of kx b">build/src/index.ts and build/src/index.d.ts</code>文件中的构建结果是否正确。</p><p id="c9fe" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">项目的包现在已经准备好了。</p><h1 id="9fa7" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">设置单声道回购配置</h1><p id="1288" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">现在，我们只有五个不相关的包(<code class="fe od oe of kx b">root</code>、<code class="fe od oe of kx b">core</code>、<code class="fe od oe of kx b">data</code>、<code class="fe od oe of kx b">di</code>和<code class="fe od oe of kx b">presentation</code>)。我们需要<code class="fe od oe of kx b">root</code>作为其他包装的容器。为此，我们将使用Lerna。</p><p id="088a" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">首先，将下面的配置复制并粘贴到您的根目录<code class="fe od oe of kx b">package.json</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="5b16" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">以下是脚本的分类:</p><ul class=""><li id="a640" class="nb nc iq mb b mc mv mf mw mi nd mm ne mq nf mu ng nh ni nj bi translated"><code class="fe od oe of kx b">prestart</code>:当你运行<code class="fe od oe of kx b">npm start</code>时，这个脚本自动运行。它确保所有包的所有依赖项都存在并且配置正确。</li><li id="9732" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">start</code>:运行<code class="fe od oe of kx b">packages</code>目录下所有包的启动脚本。</li><li id="513a" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><code class="fe od oe of kx b">test</code>和<code class="fe od oe of kx b">build</code>:同<code class="fe od oe of kx b">start</code></li><li id="8feb" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated">创建一个交互式依赖图，这样你就可以可视化你的项目依赖关系。</li></ul><p id="b923" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">Lerna和NX的依赖项是必需的，因为我们的脚本使用它们。</p><p id="22fe" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">接下来，有几个用于Lerna和NX的配置文件，分别命名为<code class="fe od oe of kx b">lerna.json</code>和<code class="fe od oe of kx b">nx.json</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="ba22" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">你会注意到在<code class="fe od oe of kx b">nx.json</code>我们有一个名为<code class="fe od oe of kx b">cacheableOperations</code>的酒店。这使得只有有变化的包才被重建/重新测试。随着项目的增长，您会更加感激这个特性。</p><p id="50c7" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">您会注意到的另一件事是<code class="fe od oe of kx b">targetDefaults</code>包含两个条目:一个用于<code class="fe od oe of kx b">start</code>，一个用于<code class="fe od oe of kx b">build</code>。这里的配置使得如果包A依赖于包B，那么包A的启动将只在包B构建之后运行，以此类推。如果现在还不明显，您将在下一节看到为什么这是必要的。</p><h2 id="8c97" class="lb lc iq bd lj np nq dn ln nr ns dp lr mi nt nu lt mm nv nw lv mq nx ny lx nz bi translated">设置包之间的依赖关系</h2><p id="7daa" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">还有最后一步，我们就完成了。我们还没有告诉<code class="fe od oe of kx b">data</code>、<code class="fe od oe of kx b">presentation</code>、<code class="fe od oe of kx b">di</code>他们依赖<code class="fe od oe of kx b">core</code>。我们接下来会这么做。</p><p id="ea3a" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">在<code class="fe od oe of kx b">data/package.json</code>内部，在<code class="fe od oe of kx b">devDependencies</code>上方添加以下属性:<code class="fe od oe of kx b">dependencies: { "core": "*" }</code></p><p id="a833" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">在<code class="fe od oe of kx b">di/package.json</code>内部，在<code class="fe od oe of kx b">devDependencies</code>上方添加以下属性:<code class="fe od oe of kx b">dependencies: { "core": "*", "data": "*" }</code></p><p id="ab87" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">在<code class="fe od oe of kx b">presentation/package.json</code>内部，在<code class="fe od oe of kx b">devDependencies</code>上方添加以下属性:<code class="fe od oe of kx b">dependencies: { "core": "*", "di": "*" }</code></p><p id="95ae" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">NX和Lerna足够聪明，可以确保<code class="fe od oe of kx b">core</code>、<code class="fe od oe of kx b">data</code>和<code class="fe od oe of kx b">di</code>在<code class="fe od oe of kx b"> presentation</code>开始之前就已经构建好了，因为演示依赖于那些其他的包。</p><p id="3256" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">我们正式结束了！在root中运行<code class="fe od oe of kx b">npm start</code>，观察神奇的事情发生。</p><p id="4736" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">如果遇到任何错误，从所有文件夹中删除所有package-lock.json和node_modules，然后再次运行<code class="fe od oe of kx b">npm start</code>。</p><p id="1058" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">下面是以上所有指令的最终实现。</p><h1 id="88f7" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">我如何使用这个单声道回购的杰作？</h1><p id="d16f" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">你可以阅读我的文章，这篇文章解释了如何一步一步地使用这个模板。这里可以找到链接<a class="ae kv" href="https://medium.com/@aziznal/create-your-next-web-app-using-clean-architecture-27c7eb745ab4" rel="noopener">。</a></p><div class="ol om gp gr on oo"><a href="https://medium.com/@aziznal/create-your-next-web-app-using-clean-architecture-27c7eb745ab4" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">用干净的架构编写你的下一个Web应用</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">如何用干净的架构构建下一个应用程序的详细指南</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div></div></a></div><h1 id="0a61" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">为什么我会这样做</h1><p id="64c8" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">一段时间以来，我一直试图找到一种好的方法来做到这一点。我考虑过最快的方法，把所有的东西都放在一个包里，相信自己会遵守规则，因为我是一个好的程序员(或者说我愿意相信)，但这对我来说还不够好。</p><p id="fdb1" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">我需要一些东西来确保规则不会被打破。当然，我所说的规则是指依赖规则。我们不允许实体依赖于数据库，也不允许实体依赖于UI代码。我试图通过包含一些脚本来解决这个问题，这些脚本会在错误的事物之间建立依赖关系时抛出错误(使用dependency-cruiser)，但这太挑剔了。而且它显示错误也太晚了。</p><p id="0919" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">所以，我决定把每个应用层分成自己的包。配有自己的<code class="fe od oe of kx b">package.json</code>和<code class="fe od oe of kx b">tsconfig.json</code>以及一个配置好的捆扎机。我使用Lerna和NX将所有这些层放在一起。这样，一个包就永远不会依赖于它不应该依赖的东西，“意外地”或者其他，如果它不存在于它的<code class="fe od oe of kx b">package.json</code>依赖项中。如果我自己这么说的话，它已经成为一件艺术品。</p><h1 id="1179" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">临时演员</h1><p id="8594" class="pw-post-body-paragraph lz ma iq mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">我建议你在使用mono repo时使用<a class="ae kv" href="https://code.visualstudio.com/docs/editor/workspaces" rel="noopener ugc nofollow" target="_blank"> VS代码工作空间</a>，就像我们刚刚做的那样。</p><p id="c2c0" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">当您使用VS代码工作区时，通过允许VS代码将每个VS代码与其他代码分开处理，您可以充分利用语法突出显示和特定于工作区的扩展。</p><p id="d054" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">VS代码只关心项目根目录下的<code class="fe od oe of kx b">tsconfig.json</code>文件。这意味着它完全忽略了我们每个包中的每个<code class="fe od oe of kx b">tsconfig.json</code>文件，导致误报出现在你的问题部分。工作空间让你远离这些。</p><p id="4fca" class="pw-post-body-paragraph lz ma iq mb b mc mv jr me mf mw ju mh mi mx mk ml mm my mo mp mq mz ms mt mu ij bi translated">感谢您的阅读！</p><h1 id="9ea1" class="li lc iq bd lj lk ll lm ln lo lp lq lr jw ls jx lt jz lu ka lv kc lw kd lx ly bi translated">参考和链接</h1><ul class=""><li id="6e95" class="nb nc iq mb b mc md mf mg mi oa mm ob mq oc mu ng nh ni nj bi translated"><a class="ae kv" href="https://medium.com/@aziznal/create-your-next-web-app-using-clean-architecture-27c7eb745ab4" rel="noopener">我关于使用这个模板的文章</a></li><li id="0c27" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><a class="ae kv" href="https://github.com/aziznal/typescript-clean-architecture" rel="noopener ugc nofollow" target="_blank">已经完成实现的GitHub repo</a></li><li id="ae82" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">鲍勃大叔的干净建筑</a></li><li id="1813" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><a class="ae kv" href="https://lerna.js.org/docs/introduction" rel="noopener ugc nofollow" target="_blank"> Lerna文档</a></li><li id="1e8f" class="nb nc iq mb b mc nk mf nl mi nm mm nn mq no mu ng nh ni nj bi translated"><a class="ae kv" href="https://nx.dev/getting-started/intro" rel="noopener ugc nofollow" target="_blank"> NX文档</a></li></ul></div></div>    
</body>
</html>