<html>
<head>
<title>Programmatic Deep Link Navigation in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的程序化深度链接导航</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/programmatic-navigation-in-swiftui-project-81200f35150?source=collection_archive---------10-----------------------#2019-11-18">https://betterprogramming.pub/programmatic-navigation-in-swiftui-project-81200f35150?source=collection_archive---------10-----------------------#2019-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1447" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深层链接、通知、快速操作、快捷方式等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/623cc36f791adfeb09aba2952fb2f2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GNBq7vNyRzZp-YwB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@stagfoo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·金</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个竞争激烈的市场中，开发人员尽最大努力在他们的移动应用程序中实现引人注目的用户体验。这不仅包括在其应用程序中构建令人惊叹的功能，还包括与iOS系统的原生集成。</p><p id="f8ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些集成中，有一些技术允许启动带有指令的应用程序，以显示特定的应用程序页面，而不是默认的登录屏幕:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/7d274a0f2dd439221a020705efe99d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*tYAk6tf3pLuxzsKS_a3mFA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://developer.apple.com/design/human-interface-guidelines/ios/extensions/home-screen-actions/" rel="noopener ugc nofollow" target="_blank">主屏幕快速操作</a></p></figure><ul class=""><li id="afcc" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">使用<a class="ae kv" href="https://developer.apple.com/ios/universal-links/" rel="noopener ugc nofollow" target="_blank">通用链接</a>或<a class="ae kv" href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app" rel="noopener ugc nofollow" target="_blank">自定义URL方案</a>进行深度链接</li><li id="18ce" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">本地和远程<a class="ae kv" href="https://developer.apple.com/documentation/usernotifications/" rel="noopener ugc nofollow" target="_blank">通知</a></li><li id="6612" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="https://developer.apple.com/design/human-interface-guidelines/sirikit/overview/siri-shortcuts/" rel="noopener ugc nofollow" target="_blank"> Siri快捷键</a></li><li id="4489" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="https://developer.apple.com/ios/search/" rel="noopener ugc nofollow" target="_blank">聚光灯搜索</a></li><li id="029d" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="https://developer.apple.com/design/human-interface-guidelines/ios/extensions/home-screen-actions/" rel="noopener ugc nofollow" target="_blank">主屏幕快速操作</a></li><li id="bd1f" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><a class="ae kv" href="https://developer.apple.com/handoff/" rel="noopener ugc nofollow" target="_blank">换手</a></li></ul><p id="aaef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然您可以很容易地找到这些特性的教程，但是有一个主题我还没有考虑到:</p><blockquote class="mh mi mj"><p id="cf3a" class="kw kx mk ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated"><em class="iq">按照深度链接说明，我们如何以编程方式导航到SwiftUI应用程序中的自定义内容屏幕？</em></p></blockquote><p id="bb6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在UIKit中有很多方法可以实现这一点(大多数都很难看)，但是SwiftUI引入了一个全新的范例，用它自己的方式来构建屏幕导航的UI。</p><p id="ac9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI应用程序中<code class="fe mo mp mq mr b">AppDelegate</code>的功能继承者是<code class="fe mo mp mq mr b">SceneDelegate</code>，它继承了为应用程序提供导航指令的两种方法:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="a6ff" class="mw mx iq mr b gy my mz l na nb">func scene(_ scene: UIScene, continue userActivity: NSUserActivity)</span><span id="c665" class="mw mx iq mr b gy nc mz l na nb">func scene(_ scene: UIScene, openURLContexts URLContexts: Set&lt;UIOpenURLContext&gt;)</span></pre><p id="a369" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的挑战是将这个指令转发到SwiftUI的视图层次结构，以显示正确的内容。</p><p id="1390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，我们拥有的是在<code class="fe mo mp mq mr b">scene(_:, willConnectTo:, options:)</code>中创建的<code class="fe mo mp mq mr b">ContentView</code>，无法访问底层视图。</p><p id="3c74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们切换显示内容的唯一方法是改变视图的状态。</p><p id="c5e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mo mp mq mr b">View</code>可以绑定到两种不同类型的状态:</p><ul class=""><li id="14cb" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">本地<code class="fe mo mp mq mr b">@State</code>变量</li><li id="105f" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">在外部<code class="fe mo mp mq mr b">ObservableObject</code>上定义的变量(有或没有<code class="fe mo mp mq mr b">@Published</code>属性)</li></ul><p id="0df6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以一个<code class="fe mo mp mq mr b">TabView</code>(替代<code class="fe mo mp mq mr b">UITabBarController</code>)作为实验对象，构建一个简单的app，看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/5d051c73eaece0ac63241a5e185e2b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*OlGo5VstUpiRcsIhLR3y8A.png"/></div></figure><p id="e1d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">切换选项卡的视图状态绑定可以使用<code class="fe mo mp mq mr b">@State</code>构建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5331" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…并使用<code class="fe mo mp mq mr b">ObservableObject</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fc19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在带有属性<code class="fe mo mp mq mr b">@State</code>、<code class="fe mo mp mq mr b">@ObservedObject</code>或<code class="fe mo mp mq mr b">@EnvironmentObject</code>的变量名前键入<code class="fe mo mp mq mr b">$</code>时，我们检索到一个类型为<code class="fe mo mp mq mr b">Binding</code>的特殊实体。</p><p id="6cb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mo mp mq mr b">Binding</code>是可以传递的访问令牌，用于提供对值的直接读写访问，而无需授予所有权(就保留引用类型而言)或复制(就值类型而言)。</p><p id="6a38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户选择<code class="fe mo mp mq mr b">TabView</code>中的一个选项卡时，它通过<code class="fe mo mp mq mr b">Binding</code>单方面改变值，并将关联的<code class="fe mo mp mq mr b">.tag(...)</code>赋给<code class="fe mo mp mq mr b">selectedTab</code>变量。这对于<code class="fe mo mp mq mr b">@State</code>和<code class="fe mo mp mq mr b">ObservableObject</code>都是一样的</p><p id="2954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序员也可以随时给那个<code class="fe mo mp mq mr b">selectedTab</code>变量赋值——而<code class="fe mo mp mq mr b">TabView</code>会立即切换显示的选项卡。</p><p id="1bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是SwiftUI中程序化导航的关键。</p><p id="06cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个切换显示层次的视图，无论是<code class="fe mo mp mq mr b">TabView</code>、<code class="fe mo mp mq mr b">NavigationView</code>还是<code class="fe mo mp mq mr b">.sheet()</code>，现在都使用<code class="fe mo mp mq mr b">Binding</code>来控制显示的内容。</p><p id="18c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们能够访问<code class="fe mo mp mq mr b">SceneDelegate</code>中的<code class="fe mo mp mq mr b">Binding</code>(或实际的底层状态)，我们将能够告诉SwiftUI视图显示我们想要的屏幕，而不是默认的屏幕。</p><p id="4a62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题有两种方法。</p><h1 id="3c1c" class="ng mx iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">1.将导航变量存储在集中式AppState中</h1><p id="5685" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">第一种方法意味着创建一个共享的应用程序状态，通过根视图上的<code class="fe mo mp mq mr b">.environmentObject(...)</code>方法注入到视图层次结构中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="9b7a" class="ng mx iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">2.通过外部发布者广播导航参数</h1><p id="4b82" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">第二种方法是使用Combine的<code class="fe mo mp mq mr b">Publisher</code>来传递导航状态更新:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d0b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这实际上取决于您使用哪种方法，但是存在概念上的差异。</p><p id="1f06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法确保所选择的导航参数保持被选择，即使内容视图还不能选择它。沿途的一些视图可能会显示一个加载指示器，但是一旦它完成并显示最终的子视图层次结构，其中一个子视图最终会选择导航参数并相应地进行操作。</p><p id="3f12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在第二种方法中根本行不通，除非您将<code class="fe mo mp mq mr b">PassthroughSubject</code>改为<code class="fe mo mp mq mr b">CurrentValueSubject</code>以始终保持导航状态。但是在这种情况下，一旦导航完成，您需要手动重置该值。</p><p id="a278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于第一种方法，您不需要重置导航状态，因为保存导航参数的应用状态是整个程序的唯一来源，当用户继续在应用中导航时，SwiftUI将更新这些值。</p><h1 id="a0bd" class="ng mx iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">通过多个视图导航</h1><p id="9864" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">使用上述方法之一，您可以通过编程导航到任意深度的屏幕。</p><p id="7fe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的要求是:对于每一个“可导航的”视图，沿着到深层链接的目标视图的路径，您需要在AppState或广播的消息中分配一个单独的导航参数。</p><p id="1de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在<code class="fe mo mp mq mr b">scene(_ scene, openURLContexts:)</code>中，你需要一次切换所有的导航参数，SwiftUI视图层次结构将一步转移到目标屏幕。</p><h1 id="a02f" class="ng mx iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated"><code class="fe mo mp mq mr b">List</code>不支持程序化导航</h1><p id="d3ac" class="pw-post-body-paragraph kw kx iq ky b kz nx jr lb lc ny ju le lf nz lh li lj oa ll lm ln ob lp lq lr ij bi translated">当我在<a class="ae kv" href="https://github.com/nalexn/clean-architecture-swiftui" rel="noopener ugc nofollow" target="_blank">示例项目</a>中实现深层链接时，我发现了一个通过<code class="fe mo mp mq mr b">List</code>编程导航的隐藏陷阱</p><p id="5a3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑这个简单的设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9c66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序只显示100个文本项目的列表。让我们假设，我们实现了一个深度链接，为带有指定的<code class="fe mo mp mq mr b">id</code>的条目打开<code class="fe mo mp mq mr b">ItemDetailsView</code>。我们用URL试试，如下所示:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="37df" class="mw mx iq mr b gy my mz l na nb">https://www.100items.com/details?id=5</span></pre><p id="83a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">..这很有效。该应用程序启动并解析URL以将<code class="fe mo mp mq mr b">5</code>分配给<code class="fe mo mp mq mr b">appState.selectedItemId</code>，并立即显示在<code class="fe mo mp mq mr b">List</code>顶部推送的<code class="fe mo mp mq mr b">ItemDetailsView</code>。</p><p id="ad49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止一切顺利。但是一旦你尝试了另一个<code class="fe mo mp mq mr b">id</code>，比如说<code class="fe mo mp mq mr b">75</code>:</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="4844" class="mw mx iq mr b gy my mz l na nb"><a class="ae kv" href="https://www.100items.com/details?id=75" rel="noopener ugc nofollow" target="_blank">https://www.100items.com/details?id=75</a></span></pre><p id="ca2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码以同样的方式工作，但是<code class="fe mo mp mq mr b">List</code> <strong class="ky ir">没有</strong>推动<code class="fe mo mp mq mr b">ItemDetailsView</code>。</p><p id="9b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是怎么回事？我们知道id为75的项目存在于列表中，但出于某种原因，详细信息屏幕没有被推送。</p><p id="0af7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是，我们推送到<strong class="ky ir">的列表项必须在<code class="fe mo mp mq mr b">List</code>中可见</strong>，这样程序导航才能工作。</p><p id="8948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您滚动列表使目标项目可见，您将看到一个不吸引人的效果:滚动突然停止，详细信息视图在导航堆栈上没有动画地出现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f6740299fc9a21c50249ac00b02b3421.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/1*M7pk_xB7FKY25OvJe-XSJw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Github<a class="ae kv" href="https://github.com/nalexn/clean-architecture-swiftui" rel="noopener ugc nofollow" target="_blank">上SwiftUI的干净架构</a></p></figure><p id="649a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mo mp mq mr b">List</code>的优化方式与<code class="fe mo mp mq mr b">UITableView</code>相同，因此它跟踪显示的项目，而<strong class="ky ir">根据需要缓慢地加载内容。</strong></p><p id="abee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，<code class="fe mo mp mq mr b">List</code>不知道带有<code class="fe mo mp mq mr b">id=75</code>的条目，所以它什么也不做，直到它知道它实际上在数组中。</p><p id="da35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们可以访问<code class="fe mo mp mq mr b">List</code>的滚动偏移量来调整它以适应这种边缘情况，这个bug就可以被修复，但是我们不能:没有API来改变<code class="fe mo mp mq mr b">List</code>的偏移量。</p><p id="bd0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在看到的这个问题的修补程序是将目标项目移动到数组中的第一个位置，这样<code class="fe mo mp mq mr b">List</code>就可以正确地拾取<code class="fe mo mp mq mr b">NavigationLink</code>。或者我们可以简单地不依赖<code class="fe mo mp mq mr b">List</code>中的程序导航</p><p id="fe2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">支持深层链接的示例项目可以在Github上找到:</p><div class="od oe gp gr of og"><a href="https://github.com/nalexn/clean-architecture-swiftui" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">nalexn/clean-architecture-swift ui</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">一个展示SwiftUI应用程序的干净架构设置的演示项目。该应用程序使用restcountries.eu REST…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div></div></a></div><p id="df2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它最初是为了说明文章<a class="ae kv" href="https://medium.com/swlh/clean-architecture-for-swiftui-6d6c4eb1cf6a" rel="noopener">swift ui的干净架构</a>而创建的，我建议您也去看看:</p><p id="c77e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Twitter上关注我，关注即将发布的帖子！</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="831a" class="mw mx iq mr b gy my mz l na nb"><strong class="mr ir">Want to Stay Updated With My Latest Articles?</strong></span><span id="0a27" class="mw mx iq mr b gy nc mz l na nb">Here’s the <a class="ae kv" href="https://nalexn.github.io/feed.xml" rel="noopener ugc nofollow" target="_blank">RSS</a> feed of my blog.</span></pre></div></div>    
</body>
</html>