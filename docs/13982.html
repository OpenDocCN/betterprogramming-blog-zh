<html>
<head>
<title>Synchronized Code — Unlocking the Power of Accelerator and Parallel Programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步代码——释放加速器和并行程序的力量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/synchronization-letting-accelerator-parallel-developers-run-free-809573b3b86a?source=collection_archive---------12-----------------------#2022-10-21">https://betterprogramming.pub/synchronization-letting-accelerator-parallel-developers-run-free-809573b3b86a?source=collection_archive---------12-----------------------#2022-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b860" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用于防止崩溃和错误的锁、信号量、临界区和其他同步结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2924c04885e1fd7b5395086b1d3b21ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uge6zCH-b6Groid6"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="abc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的上一篇文章<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/an-accelerated-and-parallel-programming-introduction-2f91420fb4f0">加速器和并行编程简介</a>中，我们讨论了并行编程的基础知识，包括一些简单的方法来获取一个程序并在多个CPU或一个加速器上运行它。当然，这篇文章只是触及了并行和加速编程挑战的表面。</p><p id="364f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，这些类型的编程使用异步执行模型，这意味着多个计算将同时在一个系统中发生。挑战在于确保这种执行是快速和正确的。</p><p id="281f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将讨论如何使用同步来确保程序正确运行。</p><h1 id="9a7e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">线</h1><p id="9171" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，稍微绕一下术语“线程”，主要是因为键入线程比键入程序的一部分更容易，它与程序的另一部分同时执行，并在一个硬件上反复执行。</p><p id="61ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在并行程序的上下文中，您编写的代码可能同时运行在多个处理器上。每段同时运行的代码都是一个线程。这听起来可能很复杂，但幸运的是，大多数编程范式允许我们专注于要并行化的内容以及我们希望如何并行化，而不必关注使用线程的具体细节。</p><h1 id="a3a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">同步</h1><p id="4320" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">同步构造强制执行我们线程的顺序。当我们允许线程运行时，我们需要考虑各种事情来确保我们的程序按照我们期望的方式运行，包括:</p><ol class=""><li id="8712" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">多个线程是否试图同时访问一个共享资源？</li><li id="e945" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">多线程是否需要完成自己的工作后才能进入程序的下一部分？</li><li id="e7c4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">有没有一些问题会导致我们的程序挂起，以至于所有的线程都因为某种原因而互相等待？</li></ol><h2 id="f1bb" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">为什么同步很重要？</h2><p id="1eee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">想象一下，我们想做一些简单的事情，比如数体育场里的人数，我们有三个人在数。一个简单的算法是:</p><p id="2c10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.把体育场分成几部分</p><p id="2d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.将每个部分分配给三个人中的一个</p><p id="4255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.让每个人清点其指定区域的人数</p><p id="49af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.将三个人中的每一个人的价值相加，得到整个体育场的总价值</p><p id="e240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来很简单，但有一个问题:要对步骤4中的值求和，每个人都必须读取当前的总数，加上该值，然后将更新后的总数写在纸上，让其他人都可以看到。所以，实际上，要更新总数，实际上必须发生三个动作(读、加、写)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/4ddcd6af033ffbfc492f87b886c10e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovDFv2JbEP9qm-od0WA1Dw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1</p></figure><p id="6c25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据图1，这个问题的正确答案是18。每个线程都有一个变量，<code class="fe nq nr ns nt b">local_count</code>,这个变量只在那个线程中创建和使用，这意味着对段的计数独立于其他线程。然而，当线程去更新共享总值时，有一个潜在的问题。</p><p id="e5b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们假设线程1和线程2同时尝试更新<code class="fe nq nr ns nt b">Total</code>。有可能他们都读取了总数的值<code class="fe nq nr ns nt b">0</code>，然后将他们的<code class="fe nq nr ns nt b">local_count</code>加到总数上，这意味着他们认为<code class="fe nq nr ns nt b">Total </code>的更新值应该分别是0+4=4或0+6=6。当他们去更新<code class="fe nq nr ns nt b">Total</code>时，输出可能是4或6。</p><p id="9839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论哪种情况，两个线程更新总数后的结果实际上都应该是<code class="fe nq nr ns nt b">10</code>。这是一场数据竞赛，也是为什么同步对正确性很重要。我们需要确保一次更新一个共享变量。下面是一个使用OpenMP的简单例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，有三个不同的OpenMP编译器指令在工作。</p><ul class=""><li id="cd00" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nw mv mw mx bi translated"><code class="fe nq nr ns nt b"><em class="nx">omp parallel sections</em></code> <em class="nx"> </em> —告诉编译器并行运行下面代码块中的每个部分(也称为线程中的每个部分)。sections pragma还会等待，直到块中的每个单独部分都完成。</li><li id="8621" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated"><code class="fe nq nr ns nt b"><em class="nx">omp section</em></code> —告诉编译器下面的代码块是可以在线程上运行的完整部分。</li><li id="7c64" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated"><code class="fe nq nr ns nt b"><em class="nx">omp critical</em> </code> —告诉编译器只允许一个线程执行下面的代码块，这只是一行代码。</li></ul><p id="b069" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了编译代码，我使用了支持OpenMP的<a class="ae kv" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html" rel="noopener ugc nofollow" target="_blank">英特尔oneAPI DPC++/C++编译器</a>，使用了以下命令:</p><pre class="kg kh ki kj gt ny nt nz oa aw ob bi"><span id="8ad5" class="nd lt iq nt b gy oc od l oe of">&gt; icx count_sections_omp.cpp -o serial.exe<br/>&gt; icx -fopenmp count_sections_omp.cpp -o parallel.exe</span></pre><p id="c4f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个命令在不启用OpenMP的情况下编译，而第二个命令告诉编译器使用OpenMP编译指令。在这种情况下，我的测试系统是我的HP Envy 16英寸笔记本电脑，采用英特尔酷睿i7–12700h处理器和32GB内存。运行两个可执行文件如下所示:</p><pre class="kg kh ki kj gt ny nt nz oa aw ob bi"><span id="8f40" class="nd lt iq nt b gy oc od l oe of">&gt;serial.exe<br/>Total=18<br/>Elapsed time in milliseconds: 1570 ms<br/>&gt;parallel.exe<br/>Total=18<br/>Elapsed time in milliseconds: 520 ms</span></pre><p id="995f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到并行代码和只在一个CPU上运行的代码在运行时的差异。</p><p id="fe55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只是为了好玩，我从代码中删除了omp关键指令，并运行了几次。经过几次尝试，我得到了以下输出:</p><pre class="kg kh ki kj gt ny nt nz oa aw ob bi"><span id="a9f9" class="nd lt iq nt b gy oc od l oe of">&gt;parallel.exe<br/>Total=14<br/>Elapsed time in milliseconds: 520 ms</span></pre><p id="66ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，您可以看到第一部分的值(值为4)不知何故被遗漏了，因为每个线程没有以序列化的方式添加到总数中。</p><h2 id="1a90" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">资源共享同步</h2><p id="a78e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有相当多的同步构造保护对资源的访问，我不能给出所有这些的代码示例。为了让您更深入地了解，我将列出几个例子以及它们的一般用途:</p><ul class=""><li id="2ea3" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nw mv mw mx bi translated">临界区—一次只允许一个线程运行受临界区保护的代码。</li><li id="0532" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">lock/mutex —通过要求每个线程在运行某些代码之前通过锁显式请求访问来保护代码段。这不同于临界区，因为存在多个线程可以同时访问共享资源的情况(例如，下面将讨论的读取器/写入器范例)。</li><li id="8851" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">信号量——给定一个预定义的数量<code class="fe nq nr ns nt b">N</code>；这只允许<code class="fe nq nr ns nt b">N</code>用户同时运行他们的代码。</li></ul><p id="47e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，如果同步使用不当，可能会导致不正确的结果以及线程无法取得进展或挂起的问题。</p><h1 id="d57a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">读者/作者范式</h1><p id="de44" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">经常使用的并行编程范例之一是读取器/写入器。当有两种类型的用户访问内存中的一些共享值时，使用这种同步:</p><ul class=""><li id="7901" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nw mv mw mx bi translated">读者—需要知道共享的价值</li><li id="b083" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">writer —需要更新共享值</li></ul><p id="3ba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想想看，多个读者可以同时查看一个值，因为他们将总是看到与其余值相同的值。但是，当写入方需要更新该值时，它必须防止其他人读取或写入该值。这确保了程序中所有读者和作者的值是一致的。</p><p id="8009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更具体地说明这一点，让我们看一个SYCL中的例子，看看读取器/写入器的使用如何影响程序的行为和性能。</p><h2 id="d47a" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">读者/作者SYCL示例</h2><p id="9732" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们看看SYCL如何使用读/写器同步来控制对数组的访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6d56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到读取和写入功能基本相同。需要了解的一些关键事项:</p><ul class=""><li id="466c" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nw mv mw mx bi translated">第18行— <code class="fe nq nr ns nt b">Read()</code>创建一个<code class="fe nq nr ns nt b">sycl::access::mode::read</code>访问器</li><li id="ad2c" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">第34行— <code class="fe nq nr ns nt b"> Write()</code>创建一个<code class="fe nq nr ns nt b">sycl::access::mode::write</code>访问器</li><li id="a221" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">第16行和第32行—提交到所选计算设备的队列。这是异步的，所以代码会在任务完成之前返回</li><li id="7f64" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">第25行和第41行—将一个任务放入要执行的队列中</li></ul><p id="ddb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，为了让测试更容易理解，我通过旋转<code class="fe nq nr ns nt b">WORK_ITERS</code>变量将<code class="fe nq nr ns nt b">doWork()</code>函数设置为在我的特定机器上运行大约一秒钟。如果你自己测试，你可能想调整一下，让测试更快或更慢。</p><p id="d48e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了核心读写函数，让我们看看读写访问模式如何影响程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个程序，感兴趣的行是25–41，每个循环迭代<code class="fe nq nr ns nt b">NUM_ACCOUNTS (8)</code>次。考虑到读取器/写入器同步的工作方式，运行同步的时间应该是:</p><ul class=""><li id="f4f8" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nw mv mw mx bi translated">第25–28行:对我们的缓冲区执行八次读取(一秒钟，并行发生)</li><li id="e742" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">第31–34行:对我们的缓冲区执行八次写操作(八秒，按顺序运行)</li><li id="58c2" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">第37–40行:对我们的缓冲区执行八次写操作(一秒钟，并行发生)</li></ul><p id="7cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，第41行导致程序在继续之前等待队列中的所有异步操作完成。</p><p id="f58e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我再次使用<a class="ae kv" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html" rel="noopener ugc nofollow" target="_blank">英特尔DPC++编译器</a>编译并运行我的代码:</p><pre class="kg kh ki kj gt ny nt nz oa aw ob bi"><span id="1f80" class="nd lt iq nt b gy oc od l oe of">&gt;icx -fsycl read_write_sycl.cpp<br/>&gt;read_write_sycl.exe<br/>Running on device: 12th Gen Intel(R) Core(TM) i7-12700H<br/>Pass<br/>Elapsed time in milliseconds: 11105 ms</span></pre><p id="4977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的运行时间接近我们预期的10秒。</p><h2 id="4187" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">读者/作者对关键部分</h2><p id="7adf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了理解读取器/写入器的价值，想象一下，如果我们不使用读取器/写入器结构，而是使用一种锁定机制，其中读取和写入都被视为需要独占访问。</p><p id="c774" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了模拟这种情况，我更新了我的<code class="fe nq nr ns nt b">Read()</code>中的第18行，如下所示以使用写锁(一次一个访问):</p><pre class="kg kh ki kj gt ny nt nz oa aw ob bi"><span id="c5f8" class="nd lt iq nt b gy oc od l oe of">auto acc = buf.get_access&lt;sycl::access::mode::read&gt;(h);<br/>auto acc = buf.get_access&lt;sycl::access::mode::write&gt;(h);</span></pre><p id="3f6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新编译并运行我的代码，我得到以下输出:</p><pre class="kg kh ki kj gt ny nt nz oa aw ob bi"><span id="e637" class="nd lt iq nt b gy oc od l oe of">&gt;read_write_sycl.exe<br/>Running on device: 12th Gen Intel(R) Core(TM) i7–12700H<br/>Pass<br/>Elapsed time in milliseconds: 24035 ms</span></pre><p id="97ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将代码运行方式与读写器代码进行比较，细分如下:</p><ul class=""><li id="d083" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr nw mv mw mx bi translated">第25–28行:对我们的缓冲区执行八次读取(八秒，按顺序运行)</li><li id="f14b" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">第31–34行:对我们的缓冲区执行八次写操作(八秒，按顺序运行)</li><li id="ac68" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nw mv mw mx bi translated">第37–40行:对我们的缓冲区执行八次写操作(八秒，按顺序运行)</li></ul><p id="f2ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着读者/作者总是更好，但事实并非如此。读/写锁是一个更复杂的同步结构，运行时开销更大，所以在选择使用什么同步时要记住这一点。</p><p id="120e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对SYCL以及它如何帮助你用同步结构保护数据感兴趣，你可以看看这个<a class="ae kv" href="https://www.intel.com/content/www/us/en/events/on365/sycl-basics.html" rel="noopener ugc nofollow" target="_blank">SYCL基础介绍视频</a>。</p><h1 id="695c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="e2a7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">加速器和并行编程在正确使用时可以给我们更快的应用和程序。但是就像生活中的大多数事情一样，好处并不总是免费的。在这种情况下，当我们希望在更快、更多样化的计算硬件上运行我们的程序时，我们还必须学习和理解帮助我们面对加速器和并行计算带来的挑战的API。</p><p id="6b16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章只是触及了同步的表面和加速器编程的陷阱。下一次，我将讨论为什么在您进行性能编程时，对目标加速器架构有一个基本的了解会很重要。</p><pre class="kg kh ki kj gt ny nt nz oa aw ob bi"><span id="5d75" class="nd lt iq nt b gy oc od l oe of"><strong class="nt ir">Want to Connect?</strong></span><span id="de35" class="nd lt iq nt b gy og od l oe of">If you want to see what random tech news I’m reading, you can <a class="ae kv" href="https://twitter.com/tonymongkolsmai" rel="noopener ugc nofollow" target="_blank">follow me</a> on Twitter. Also, check out <a class="ae kv" href="https://connectedsocialmedia.com/category/code-together/" rel="noopener ugc nofollow" target="_blank">Code Together</a>, an Intel podcast for developers that I host where we talk tech.</span></pre></div></div>    
</body>
</html>