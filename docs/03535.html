<html>
<head>
<title>RabbitMQ vs. Kafka: Head-To-Head</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RabbitMQ与卡夫卡:正面交锋</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rabbitmq-vs-kafka-1779b5b70c41?source=collection_archive---------0-----------------------#2020-02-17">https://betterprogramming.pub/rabbitmq-vs-kafka-1779b5b70c41?source=collection_archive---------0-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="097c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较各自的优势和劣势</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc1102751679055ca4848ef018eab53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqymJuhjJY8iaam76iOShg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">精选图片—图片由</em><a class="ae kz" href="https://unsplash.com/@freegraphictoday?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="ky">absolute vision</em></a><em class="ky">上</em> <a class="ae kz" href="https://unsplash.com/s/photos/guidance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> Unsplash </em> </a></p></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="65f4" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">介绍</h1><p id="c741" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">作为一名处理大量基于微服务的系统的软件架构师，我经常遇到一个不断重复的问题:“我应该使用<a class="ae kz" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>还是<a class="ae kz" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>？”</p><p id="d5cf" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">出于某种原因，许多开发人员认为这些技术是可以互换的。虽然在某些情况下确实如此，但这些平台之间存在各种潜在的差异。</p><p id="c3b3" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">因此，不同的场景需要不同的解决方案，选择错误的解决方案可能会严重影响您设计、开发和维护软件解决方案的能力。</p><p id="1d0d" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><a class="ae kz" href="https://medium.com/better-programming/rabbitmq-vs-kafka-1ef22a041793" rel="noopener">本系列的第1部分</a>解释了<a class="ae kz" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>和<a class="ae kz" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>的内部实现概念。这一部分继续回顾这两个平台之间的显著差异，作为软件架构师和开发人员，我们应该注意这些差异。</p><p id="caba" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然后，它继续解释我们通常试图用这些工具实现的架构模式，并评估何时使用每种工具。</p><h2 id="e634" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">附注1</h2><p id="85eb" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">如果你不熟悉RabbitMQ和Kafka的内部结构，我强烈推荐你先通读一下本帖的<a class="ae kz" href="https://medium.com/better-programming/rabbitmq-vs-kafka-1ef22a041793" rel="noopener"> part 1 </a>。如果您不确定，那么请随意浏览标题和图表，至少可以对这些差异有所了解。</p><h2 id="c234" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">附注2</h2><p id="e4aa" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">继上一篇帖子之后，一些读者问我关于<a class="ae kz" href="https://pulsar.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇脉冲星</a>的问题。Pulsar是另一个消息平台，旨在结合RabbitMQ和Kafka的一些优点。</p><p id="cccc" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">作为现代平台，看起来很有前景；然而，像任何其他平台一样，它有自己的优势和劣势。我将在以后的帖子中尝试解决Apache Pulsar的比较问题，因为这篇帖子主要关注RabbitMQ和Kafka。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="8f05" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">RabbitMQ和Kafka之间的显著差异</h1><p id="f04d" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">RabbitMQ是一个<em class="nm">消息代理</em>，而Apache Kafka是一个<em class="nm">分布式流媒体平台</em>。这种差异可能看起来是语义上的，但是它包含了严重的含义，影响了我们舒适地实现各种用例的能力。</p><p id="0af2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">例如，Kafka最适合用于处理数据流，而RabbitMQ对于流中消息的排序有最低限度的保证。</p><p id="4336" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">另一方面，RabbitMQ内置了对重试逻辑和死信交换的支持，而Kafka将这些实现留给了用户。</p><p id="e9ff" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">本节重点介绍这些不同平台之间的这些和其他显著差异。</p><h2 id="a831" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">消息排序</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/fdde0e00d9be43e1a1d5c2af208ad7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_eV5Z2z8y3SBw1vOq1Mrw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@ar_shad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿尔沙德·普卢奥</a>在<a class="ae kz" href="https://unsplash.com/s/photos/series?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7a57" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ对发送到队列或交换的消息的排序没有提供什么保证。虽然消费者按照生产者发送消息的顺序处理消息似乎是显而易见的，但这很容易让人误解。</p><p id="f297" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ文档对其订购保证做了如下说明:</p><blockquote class="no"><p id="093f" class="np nq it bd nr ns nt nu nv nw nx mu dk translated">在一个通道中发布的消息，经过一个交换、一个队列和一个传出通道后，将按发送顺序被接收— <a class="ae kz" href="https://www.rabbitmq.com/semantics.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ代理语义</a></p></blockquote><p id="822f" class="pw-post-body-paragraph lz ma it mb b mc ny ju me mf nz jx mh mi oa mk ml mm ob mo mp mq oc ms mt mu im bi translated">换句话说，只要我们有一个消息消费者，它就按顺序接收消息。然而，一旦我们有多个消费者从同一个队列中读取消息，我们就不能保证消息的处理顺序。</p><p id="ec97" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这种缺乏排序保证的情况之所以发生，是因为消费者可能会在阅读完消息后将它们返回(或重新传递)到队列中(例如，在处理失败的情况下)。</p><p id="7849" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">一旦消息被返回，即使它已经使用了后面的消息，另一个消费者也可以获取它进行处理。因此，使用者组无序地处理消息，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6f923249219fac3b66e7771283e27557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XblUPw72k2S8RLfhK0acLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用RabbitMQ时丢失消息排序的示例</p></figure><p id="5dcf" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">当然，我们可以通过将消费者并发限制为一个来恢复RabbitMQ中的消息排序。更准确地说，单个使用者中的线程数量应该限制为一个，因为任何并行消息处理都可能导致相同的无序问题。</p><p id="94e7" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然而，将我们自己局限于一个单线程消费者会严重影响我们在系统增长时扩展消息处理的能力。因此，我们不应该轻松地进行这种权衡。</p><p id="f5d2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">另一方面，Kafka在消息处理上提供了可靠的排序保证。Kafka保证发送到同一个主题分区的所有消息都按顺序处理。</p><p id="ddf0" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果您还记得第1部分，默认情况下，Kafka使用循环分割器将消息放在分区中。但是，生产者可以在每个消息上设置一个分区键，以创建逻辑数据流(例如来自同一设备的消息，或者属于同一租户的消息)。</p><p id="981d" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然后，来自同一个流的所有消息都被放在同一个分区中，让使用者组按顺序处理它们。</p><p id="1f46" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">但是，我们应该注意，在一个使用者组中，每个分区都是由单个使用者的单个线程处理的。因此，我们无法扩展单个分区的处理。</p><p id="bd77" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然而，在Kafka中，我们可以扩展一个主题中的分区数量，使每个分区接收更少的消息，并为额外的分区添加额外的消费者。</p><p id="b4c8" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">获胜者</strong></p><p id="e37d" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">Kafka是明显的赢家，因为它允许按顺序处理信息。RabbitMQ在这方面只有弱保证。</p><h2 id="4c77" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">信息发送</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/595dc355624d927918f2f9643853c132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPQRyk1h0vUL5-JiupHMWg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@webaroo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">韦巴罗</a>在<a class="ae kz" href="https://unsplash.com/s/photos/router?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="613a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ可以根据用户定义的路由规则将消息路由到消息交换的用户。一个<a class="ae kz" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-topic" rel="noopener ugc nofollow" target="_blank">主题交换</a>可以基于一个名为<code class="fe of og oh oi b">routing_key</code>的专用头来路由消息。</p><p id="195c" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">或者，<a class="ae kz" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-headers" rel="noopener ugc nofollow" target="_blank">头交换</a>可以基于任意消息头路由消息。这两种交换都有效地允许消费者指定他们感兴趣接收的消息类型，从而为解决方案架构师提供了极大的灵活性。</p><p id="0117" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">另一方面，Kafka不允许消费者在投票之前过滤主题中的消息。订阅的使用者无一例外地接收分区中的所有消息。</p><p id="2edb" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">作为开发人员，您可以使用一个<a class="ae kz" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka流作业</a>，它从主题中读取消息，过滤它们，并将它们推送到消费者可以订阅的另一个主题。然而，这需要更多的努力和维护，并有更多的移动部件。</p><p id="772e" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">获胜者</strong></p><p id="ae2b" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ在路由和过滤消息供消费者使用时提供了卓越的支持。</p><h2 id="6dad" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">消息定时</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/06b1affc6d1ed70e2bda9d7ddd5bdcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZyDChHJPP8sMjBh41og2A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥利弗·黑尔在<a class="ae kz" href="https://unsplash.com/s/photos/timing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fae5" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ提供了各种与对发送到队列的消息进行计时有关的功能:</p><p id="49c4" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">消息生存时间(TTL) </strong></p><p id="5c27" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">一个<a class="ae kz" href="https://www.rabbitmq.com/ttl.html" rel="noopener ugc nofollow" target="_blank"> TTL </a>属性可以与发送到RabbitMQ的每个消息相关联。设置TTL可以由发布者直接完成，也可以作为队列本身的策略来完成。</p><p id="c98a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">指定TTL允许系统限制消息的有效期。如果消费者没有及时处理它，那么它会自动从队列中删除(并被转移到一个死信交换，稍后会详细介绍)。</p><p id="8d47" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">TTL对于时间敏感的命令特别有用，这些命令在经过一段时间没有处理就变得无关紧要。</p><p id="b882" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">延迟/预定消息</strong></p><p id="8242" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ通过使用<a class="ae kz" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" rel="noopener ugc nofollow" target="_blank">插件</a>支持延迟/预定消息。当在消息交换中启用该插件时，生产者可以向RabbitMQ发送消息，生产者可以延迟RabbitMQ将该消息路由到消费者队列的时间。</p><p id="1d5a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这个特性允许开发者安排未来的命令，这些命令并不意味着在那之前就要被处理。例如，当生产者遇到节流规则时，我们可能想要将特定命令的执行延迟到稍后的时间。</p><p id="2366" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">Kafka不支持此类功能。当消息到达时，它将消息写入分区，消费者可以立即使用这些消息。</p><p id="74b7" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">此外，Kafka没有为消息提供TTL机制，尽管我们可以在应用程序级别实现一个。</p><p id="3866" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我们还必须记住，Kafka分区是一个只附加的事务日志。因此，它不能操纵消息时间(或分区内的位置)。</p><p id="a8cf" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">获胜者</strong></p><p id="636d" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ轻而易举地胜出，因为其实现的性质限制了Kafka。</p><h2 id="564d" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">消息保留</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/7761f7cf19670f9d696596d25d21d60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frq3fk36g4IzOdODyxakig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae kz" href="https://unsplash.com/s/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="4629" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">一旦消费者成功地消费了消息，RabbitMQ就从存储器中驱逐它们。此行为无法修改。这是几乎所有消息代理设计的一部分。</p><p id="b0a7" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">相比之下，Kafka根据设计将所有消息保存到每个主题配置的超时时间。关于信息保持，Kafka不关心其消费者的消费状态，因为它充当信息日志。</p><p id="6caf" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">消费者可以随心所欲地使用每条消息，并且可以通过操纵分区偏移量来“及时”地来回移动。Kafka定期检查主题中消息的年龄，并驱逐那些足够老的消息。</p><p id="2dcf" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">Kafka的性能不依赖于存储大小。因此，从理论上讲，我们几乎可以无限期地存储消息，而不会影响性能(只要您的节点足够大，能够存储这些分区)。</p><p id="7851" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">获胜者</strong></p><p id="2482" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">Kafka是为了保留信息而设计的，而RabbitMQ不是。这里没有竞争，卡夫卡被宣布为胜利者。</p><h2 id="2de4" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">故障处理</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/49207f6c636294d7fa99e5568a196d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsMQ00CZ5Co2gctHK9shtg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@rojekilian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎拉·基利安</a>在<a class="ae kz" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="01c8" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在处理消息、队列和事件时，开发人员通常认为消息处理总是成功的。毕竟，由于生产者将每条消息放在一个队列或主题中，即使消费者未能处理消息，它也可以简单地重试，直到成功。</p><p id="aff3" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">虽然表面上是这样，但我们应该在这个过程中投入更多的思考。我们应该承认，在某些情况下，消息处理可能会失败。我们应该优雅地处理这些情况，即使解决方案部分由人为干预组成。</p><p id="0805" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">处理消息时有两种可能的错误:</p><ol class=""><li id="f708" class="ol om it mb b mc mv mf mw mi on mm oo mq op mu oq or os ot bi translated">瞬时故障—由于网络连接、CPU负载或服务崩溃等临时问题而发生的故障。我们通常可以通过一次又一次的重试来减轻这种失败。</li><li id="8927" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">持续故障—由于无法通过额外重试解决的永久性问题而发生的故障。这些失败的常见原因是软件错误或无效的消息模式(即，有害消息)。</li></ol><p id="0f1c" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">作为架构师和开发人员，我们应该问自己:“当消息处理失败时，我们应该重试多少次？重试之间应该等待多长时间？我们如何区分瞬时故障和持续故障？”</p><p id="d9f7" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">最重要的是:“当所有的重试都失败，或者我们遇到一个持续的失败时，我们该怎么办？”</p><p id="88b6" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">虽然这些问题的答案是特定于领域的，但是消息平台通常为我们提供实现我们的解决方案的工具。</p><p id="1d50" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ提供了传递重试和死信交换(DLX)等工具来处理消息处理失败。</p><p id="f98b" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">DLX的主要思想是RabbitMQ可以根据适当的配置将失败的消息自动路由到DLX，并在此交换中对消息应用进一步的处理规则，包括延迟重试、重试计数和提交到“人工干预”队列。</p><p id="df3c" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><a class="ae kz" href="https://engineering.nanit.com/rabbitmq-retries-the-full-story-ca4cc6c5b493" rel="noopener ugc nofollow" target="_blank">本文</a>提供了关于RabbitMQ中处理重试的可能模式的更多见解。</p><p id="4417" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这里要记住的最重要的一点是，在RabbitMQ中，当一个使用者忙于处理和重试一个特定的消息时(甚至在将它返回到队列之前)，其他使用者可以并发地处理跟在它后面的消息。</p><p id="e0ec" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">当特定的消费者重试特定的消息时，消息处理作为一个整体不会停滞。因此，消息消费者可以同步重试消息，而不会影响整个系统。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/f3b1950ae4075f1c65b5cdd55956b106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pLZ4R4E6KUA1f2G5MhT8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">消费者1可以继续重试消息1，而其他消费者继续处理消息</p></figure><p id="2f48" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">与RabbitMQ相反，Kafka没有提供任何现成的机制。有了Kafka，我们就可以在应用程序级别提供和实现消息重试机制。</p><p id="6dc0" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">此外，我们应该注意，当使用者忙于同步重试特定消息时，来自同一分区的其他消息无法得到处理。</p><p id="be04" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我们不能拒绝并重试特定的消息，也不能提交它之后的消息，因为消费者不能更改消息顺序。正如您所记得的，分区仅仅是一个只附加的日志。</p><p id="79e2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">应用程序级解决方案可以将失败的消息提交给“重试主题”并从那里处理重试；然而，在这种类型的解决方案中，我们失去了消息排序。</p><p id="8549" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在Uber.com的<a class="ae kz" href="https://eng.uber.com/reliable-reprocessing/" rel="noopener ugc nofollow" target="_blank">可以找到由优步工程公司实施的这样一个例子。如果消息处理延迟不是问题，那么对错误进行充分监控的普通Kafka解决方案可能就足够了。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/5030f294f44d918db1fe4f94205d9bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7bkcxGiUEAgUoS2zI4Sjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果使用者无法重试消息，则不会处理底部分区中的消息</p></figure><p id="3892" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">冠军</strong></p><p id="1741" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ在点数上是赢家，因为它提供了一种开箱即用的机制来解决这个问题。</p><h2 id="883f" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">规模</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/6aaf7d02e4d4a74e92b975288618819d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlrVwbstm7ZLCwBobv8H-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/s/photos/scale?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kz" href="https://unsplash.com/@graphicnode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">图形节点</a>拍照</p></figure><p id="eeb7" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">有多个基准测试，检查RabbitMQ和Kafka的性能。</p><p id="b9b6" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">虽然通用基准对特定情况的适用性有限，但Kafka通常被认为比RabbitMQ具有更好的性能。Kafka使用顺序磁盘I/O来提高性能。</p><p id="c606" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">它使用分区的架构意味着它比RabbitMQ在水平方向(向外扩展)的伸缩性更好，而rabbit MQ在垂直方向(向上扩展)的伸缩性更好。</p><p id="63ed" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">大型Kafka部署通常每秒可以处理数十万条消息，甚至数百万条消息。</p><p id="aedd" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">过去，Pivotal记录了RabbitMQ集群每秒处理<a class="ae kz" href="https://content.pivotal.io/blog/rabbitmq-hits-one-million-messages-per-second-on-google-compute-engine" rel="noopener ugc nofollow" target="_blank">一百万条消息</a>；但是，它是在一个30节点的集群上实现的，负载在多个队列和交换之间进行了优化分布。</p><p id="ea71" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">典型的RabbitMQ部署包括三到七个节点集群，这些集群不一定能在队列之间最佳地分配负载。这些典型的集群通常可以预期每秒处理数万条消息的负载。</p><p id="991d" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">赢家</strong></p><p id="312a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">虽然两个平台都可以处理大量负载，但Kafka通常比RabbitMQ具有更好的伸缩性，可以实现更高的吞吐量，因此赢得了这一轮。</p><p id="c3b9" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然而，值得注意的是，大多数系统都没有达到这些限制中的任何一个！因此，除非你正在构建下一个百万用户的热门软件系统，否则你不需要如此关心规模，因为这两个平台都可以很好地为你服务。</p><h2 id="ff63" class="na li it bd lj nb nc dn ln nd ne dp lr mi nf ng lt mm nh ni lv mq nj nk lx nl bi translated">消费者复杂性</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/cd921c0476c819d50437de5443da5160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3k673ozITqnxGAjJfDMm0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·巴克利普在<a class="ae kz" href="https://unsplash.com/s/photos/complex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3695" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ使用智能代理和非智能消费者的方法。消费者注册使用队列，RabbitMQ将消息推给他们，让他们在消息进来时进行处理。RabbitMQ也有拉API然而，它很少被使用。</p><p id="d1c2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ管理向消费者分发消息和从队列中移除消息(可能是dlx)。消费者不需要担心这些。</p><p id="29d6" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ的结构还意味着，当负载增加时，队列的使用者组可以有效地从一个使用者扩展到多个使用者，而无需对系统进行任何更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/c1a012021f8bc146713959fff96a859e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5urcA0y4t8iuFNVRzI5rg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RabbitMQ消费者有效地扩大规模和缩小规模</p></figure><p id="6cbe" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">另一方面，卡夫卡使用一种愚蠢的经纪人和聪明的消费者的方法。消费者组中的消费者需要协调他们之间的主题分区租约(以便消费者组中只有一个消费者监听特定的分区)。</p><p id="37c2" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">消费者还需要管理和存储他们的分区的偏移索引。幸运的是，Kafka SDK会为我们处理这些，所以我们不需要自己管理它。</p><p id="0d02" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然而，当我们的负载较低时，单个消费者需要并行处理和跟踪多个分区，这需要消费者端有更多的资源。</p><p id="2297" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">此外，随着负载的增加，我们只能将使用者组扩大到使用者数量等于主题中分区数量的程度。除此之外，我们需要配置Kafka来添加额外的分区。</p><p id="0575" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然而，随着负载再次降低，我们不能删除已经添加的分区，这增加了消费者需要做的工作。尽管如上所述，SDK处理这些额外的工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/8ef22adc39a56efb6784db035426f2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1N-2sAOBpuWv_S-T9kN7YA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kafka分区不能被移除，在缩小规模后留给消费者更多的工作</p></figure><p id="076f" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated"><strong class="mb iu">获胜者</strong></p><p id="e8a3" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">RabbitMQ，从设计上来说，是为头脑简单的消费者设计的。因此，它是这一轮的赢家。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="e8cd" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">什么时候用哪个？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/b521485fd3eba0ecdfba7d7ede078a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M86HNL7XvyGTups2RzYVww.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@paulius005?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Paulius Dragunas </a>在<a class="ae kz" href="https://unsplash.com/s/photos/lighthouse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3110" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">现在我们来到了这个百万美元的问题:“我们什么时候应该使用RabbitMQ，什么时候应该使用Kafka？”</p><p id="9234" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">如果我们总结上述差异，我们会得出以下结论:</p><p id="8249" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">当我们需要时，RabbitMQ是更好的选择:</p><ol class=""><li id="3ef8" class="ol om it mb b mc mv mf mw mi on mm oo mq op mu oq or os ot bi translated">高级灵活的路由规则。</li><li id="ef7c" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">消息定时控制(控制消息到期或消息延迟)。</li><li id="885e" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">高级故障处理功能，以防消费者很可能无法处理消息(暂时或永久)。</li><li id="6480" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">更简单的消费者实现。</li></ol><p id="5b92" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">当我们需要:</p><ol class=""><li id="1760" class="ol om it mb b mc mv mf mw mi on mm oo mq op mu oq or os ot bi translated">严格的消息排序。</li><li id="6960" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">延长消息保留时间，包括重播过去消息的可能性。</li><li id="d674" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">在传统解决方案无法满足需求的情况下，达到高规模的能力。</li></ol><p id="afde" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">我们可以使用这两个平台实现大多数用例。然而，作为解决方案架构师，我们有责任为这项工作选择最合适的工具。在做这个选择的时候，我们应该同时考虑到上面强调的功能性差异和非功能性约束。</p><p id="13f3" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这些约束包括以下内容:</p><ol class=""><li id="54a5" class="ol om it mb b mc mv mf mw mi on mm oo mq op mu oq or os ot bi translated">这些平台的现有开发人员知识。</li><li id="b69a" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">托管云解决方案的可用性(如果适用)。</li><li id="17e6" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">每个解决方案的运营成本。</li><li id="d4a6" class="ol om it mb b mc ou mf ov mi ow mm ox mq oy mu oq or os ot bi translated">我们的目标堆栈的SDK的可用性。</li></ol><p id="69a6" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">当开发复杂的软件系统时，我们可能会尝试使用相同的平台来实现所有需要的消息传递用例。然而，从我的经验来看，通常情况下，使用这两个平台会有很多好处。</p><p id="574b" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">例如，在基于事件驱动架构的系统中，我们可以使用RabbitMQ在服务之间发送命令，并使用Kafka实现业务事件通知。</p><p id="19cf" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">原因是事件通知通常用于事件源、批处理操作(ETL风格)或审计目的，因此Kafka的消息保留能力非常有价值。</p><p id="0c6a" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">另一方面，命令通常需要在使用者端进行额外的处理，这些处理可能会失败，并且需要高级的故障处理能力。</p><p id="042f" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">在这里，RabbitMQ因其功能而大放异彩。我可能会在将来写一篇关于它的详细文章，但是你必须记住——你的里程可能会有所不同，因为适用性取决于你的具体要求。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="cb41" class="lh li it bd lj lk ll lm ln lo lp lq lr jz ls ka lt kc lu kd lv kf lw kg lx ly bi translated">结束语</h1><p id="a0c4" class="pw-post-body-paragraph lz ma it mb b mc md ju me mf mg jx mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">我从许多开发人员将RabbitMQ和Kafka视为可互换的观点出发，开始了这个由两篇文章组成的系列。我希望回顾这些帖子有助于深入了解这些平台的实现，以及它们之间的技术差异。</p><p id="1c9e" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">这些差异反过来会影响这些平台能够很好服务的用例。这两个平台都很棒，可以服务于多种用例。</p><p id="8c5e" class="pw-post-body-paragraph lz ma it mb b mc mv ju me mf mw jx mh mi mx mk ml mm my mo mp mq mz ms mt mu im bi translated">然而，作为解决方案架构师，我们需要理解每个用例的需求，区分它们的优先级，并选择最合适的解决方案。</p></div></div>    
</body>
</html>