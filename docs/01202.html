<html>
<head>
<title>An Introduction to Buffer in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中缓冲区的介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-buffer-in-node-js-2237a9bce9da?source=collection_archive---------0-----------------------#2019-08-22">https://betterprogramming.pub/an-introduction-to-buffer-in-node-js-2237a9bce9da?source=collection_archive---------0-----------------------#2019-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/22fe2ef7060d0bc5e9a1b1bd1be89b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EdgtHJmcQ3P-TQwX"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="f22f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="3896" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Buffer是Node全局对象上的一个对象属性，在Node中大量使用它来处理二进制数据流。因为它是全球可用的，所以没有必要在我们的代码中要求它。</p><p id="3044" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">缓冲区实际上是分配在V8堆之外的一块内存。V8是默认的JavaScript引擎，支持Node和Google Chrome。在Node中，缓冲区是使用JavaScript typedArray ( <code class="fe mi mj mk ml b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="noopener ugc nofollow" target="_blank">Uint8Array</a></code>)实现的，但这并不意味着分配给缓冲区的内存在V8堆内部。它仍然被显式地分配在V8堆之外。</p><p id="c283" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因此，我们可以将缓冲区视为某种数组，它是一种低级数据结构，用来表示二进制数据序列，但有一个主要区别:与数组不同，缓冲区一旦被分配，就不能调整大小。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="5f8a" class="kg kh it bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">缓冲和字符编码</h1><p id="9d2a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">每当数据存储在缓冲区实例中或从缓冲区实例中提取时，它都只是二进制数据。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/fad24a67315aa69f5254006905a196f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*R1hi5SKujn-OJIcCVF1p7g.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">不指定编码的缓冲区</p></figure><p id="0bc3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当我们从一个<code class="fe mi mj mk ml b">Node.js</code>字符串创建一个缓冲区时(我们将马上讨论创建缓冲区)，你可以看到我们得到了一些十六进制序列预览。这是因为我们没有指定任何字符编码。</p><p id="4dee" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因此，只要有缓冲区，就必须有某种字符编码来正确地读回数据(也就是说，每当我们从文件或某个套接字读取一些内容时，我们都将其作为缓冲区读取，因此，如果我们不指定字符编码，我们将得到一个缓冲区对象)。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/f6760f206dcd435f36f897bdf038623f.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*jjRKeeor2Rj-z61at_vzLQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">具有不同字符编码的缓冲器</p></figure><p id="b5fe" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您可以看到，当不同的字符编码应用于缓冲区时，我们会得到不同的结果。这就是字符编码如何改变我们看待数据的方式。如果没有参数给<code class="fe mi mj mk ml b">toString()</code>方法，默认情况下它采用<code class="fe mi mj mk ml b">‘utf8’</code>编码。</p><p id="8731" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mi mj mk ml b">Node.js</code>中支持的不同类型的字符编码有:</p><ul class=""><li id="56c7" class="ne nf it lg b lh mc ll md lp ng lt nh lx ni mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'ascii'</code> —仅用于7位ASCII数据</li><li id="3337" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'utf8'</code> —多字节编码的Unicode字符。许多网页和其他文档格式使用UTF-8。</li><li id="29d2" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'utf16le'</code> — 2或4个字节，小端编码的Unicode字符</li><li id="4261" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'ucs2'</code>—<code class="fe mi mj mk ml b">'utf16le'</code>的别名</li><li id="ea51" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'base64'</code> — Base64编码</li><li id="7044" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'latin1'</code> —将<code class="fe mi mj mk ml b">Buffer</code>编码成一个字节编码字符串的一种方式</li><li id="7cc1" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'binary'</code>—<code class="fe mi mj mk ml b">'latin1'</code>的别名</li><li id="dd38" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated"><code class="fe mi mj mk ml b">'hex'</code> —将每个字节编码为两个十六进制字符</li></ul></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="850d" class="kg kh it bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">创建缓冲区</h1><p id="281f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">创建缓冲区有三种最常用的方法:</p><ol class=""><li id="c85d" class="ne nf it lg b lh mc ll md lp ng lt nh lx ni mb ns nk nl nm bi translated"><code class="fe mi mj mk ml b">Buffer.from()</code></li><li id="70b2" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb ns nk nl nm bi translated"><code class="fe mi mj mk ml b">Buffer.alloc()</code></li><li id="a0cb" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb ns nk nl nm bi translated"><code class="fe mi mj mk ml b">Buffer.allocUnsafe()</code></li></ol><h2 id="5e72" class="nt kh it bd ki nu nv dn km nw nx dp kq lp ny nz ku lt oa ob ky lx oc od lc oe bi translated">Buffer.from()</h2><p id="6372" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe mi mj mk ml b">Buffer.from</code>用于从数组、字符串或缓冲区本身创建缓冲区。</p><p id="8233" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mi mj mk ml b">Buffer.from(‘Node.js’)</code>输出<code class="fe mi mj mk ml b">&lt;Buffer 4e 6f 64 65 2e 6a 73&gt;</code></p><h2 id="c831" class="nt kh it bd ki nu nv dn km nw nx dp kq lp ny nz ku lt oa ob ky lx oc od lc oe bi translated">Buffer.alloc()</h2><p id="0ecb" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe mi mj mk ml b">Buffer.alloc</code>接受一个大小(整数)作为参数，返回一个新的指定大小的初始化缓冲区(即创建一个特定大小的填充缓冲区)。</p><p id="69a0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mi mj mk ml b">Buffer.alloc(8)</code>输出<em class="mh"> </em> <code class="fe mi mj mk ml b">&lt;Buffer 00 00 00 00 00 00 00 00&gt;</code></p><p id="e15d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这里我们有一个8字节的缓冲区，每一位都预先填充了0。</p><h2 id="b4e5" class="nt kh it bd ki nu nv dn km nw nx dp kq lp ny nz ku lt oa ob ky lx oc od lc oe bi translated">Buffer.allocUnsafe()</h2><p id="e824" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe mi mj mk ml b">Buffer.allocUnsafe</code>接受size作为参数，返回一个未初始化的新缓冲区。这意味着它可能包含一些旧的或敏感的数据。所以必须小心使用。由于创建缓冲区时不涉及初始化，该方法比<code class="fe mi mj mk ml b">Buffer.alloc()</code>更快。</p><p id="4e17" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mi mj mk ml b">Buffer.allocUnsafe(8)</code>可能输出<code class="fe mi mj mk ml b">&lt;Buffer d0 ce ed 02 00 00 00 00&gt;</code></p><p id="232d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们可以看到，有一些信息留在我们的缓冲区，这些信息直接来自我们的记忆。为了保护我们的敏感信息，我们需要预填充这个缓冲区，我们通过使用<code class="fe mi mj mk ml b"><strong class="lg iu">fill()</strong></code> <strong class="lg iu"> </strong>方法来完成。</p><p id="8bc9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mi mj mk ml b">Buffer.allocUnsafe(8).fill()</code>输出<em class="mh"> </em> <code class="fe mi mj mk ml b">&lt;Buffer 00 00 00 00 00 00 00 00&gt;</code></p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="9fc5" class="kg kh it bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">字符串/数组和缓冲区的区别</h1><p id="1ac4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们在字符串和缓冲区上都有一个<code class="fe mi mj mk ml b">length</code> <em class="mh"> </em>属性，它在两者中的行为是相同的。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/feae50767dd9ac36a02fee47d23b26d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*bE9O6ALfMiaAFbWgkmSWnA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">上面代码的输出</p></figure><p id="ecdf" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">现在，正如你所看到的，尽管<code class="fe mi mj mk ml b"><em class="mh">lengt</em>h</code>属性对于String和buffer的行为是一样的，但是我们得到了不同的答案。这是因为字符串基于UTF-8编码计算字符数，而缓冲区计算用于表示给定字符串的实际字节数。</p><p id="21f3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">就像数组和字符串一样，对于buffer，我们可以使用类似于<code class="fe mi mj mk ml b">slice</code>、<code class="fe mi mj mk ml b">indexOf</code>等多种操作。但是当我们在缓冲区上使用这些方法时，会有一些不同。</p><p id="f87a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">假设我们想对数组<code class="fe mi mj mk ml b">arr.slice([begin[, end]])<strong class="lg iu"><em class="mh">.</em></strong></code> <em class="mh"> S </em>应用一个<code class="fe mi mj mk ml b">slice</code>操作，数组上的切片给我们一个新数组，从原始数组的开始索引到结束索引都有切片元素。在<code class="fe mi mj mk ml b">slice</code>之后，两个数组将有不同的引用(也就是说，它们不共享内存，所以无论我们在其中一个数组中做什么都不会影响另一个)。</p><p id="63ed" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">但缓冲器的情况并非如此。当我们在一个缓冲区上应用<code class="fe mi mj mk ml b">slice</code>操作时，例如<code class="fe mi mj mk ml b">buf.slice([start[, end]])</code> <strong class="lg iu"> <em class="mh">，</em> </strong>，它也返回一个新的缓冲区，但是新的缓冲区引用与原始缓冲区相同的内存(只是通过<code class="fe mi mj mk ml b">start</code>和<code class="fe mi mj mk ml b">end</code>索引进行了偏移和裁剪)。这意味着我们在任一缓冲区中所做的任何改变都会反映到另一个缓冲区中。</p><figure class="mz na nb nc gt ju"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e918fba4d73c9a5ee9c7e9b90da73ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*v8C0Oe9xX8yp5TVMUjP9XQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">上述代码的输出</p></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="15d4" class="kg kh it bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">结束了</h1><p id="a68d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我们需要从TCP流中读取图像、压缩文件或任何其他形式的二进制数据时，缓冲区非常有用。Node中的流大量使用缓冲区，因此对它们有一个基本的了解是有好处的。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="5884" class="kg kh it bd ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld bi translated">参考</h1><div class="oj ok gp gr ol om"><a href="https://nodejs.org/dist/latest-v12.x/docs/api/buffer.html" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">Node.js v12.8.1文档</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在引入TypedArray之前，JavaScript语言没有读取或操作流的机制…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">nodejs.org</p></div></div></div></a></div></div></div>    
</body>
</html>