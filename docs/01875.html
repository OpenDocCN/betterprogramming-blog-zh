<html>
<head>
<title>Create the Perfect UserDefaults Wrapper Using Property Wrapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用属性包装创建完美的UserDefaults包装</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-the-perfect-userdefaults-wrapper-using-property-wrapper-42ca76005ac8?source=collection_archive---------3-----------------------#2019-10-19">https://betterprogramming.pub/create-the-perfect-userdefaults-wrapper-using-property-wrapper-42ca76005ac8?source=collection_archive---------3-----------------------#2019-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e54" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不再有样板代码，提高了可重用性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e55546b9386d282db428b6003f79d27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1HBb9CFrK8VOZpppU0sag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不再有样板代码</p></figure><p id="b397" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设你有一个应用程序，你想实现自动登录功能。因此，您创建了一个<code class="fe lu lv lw lx b">UserDefaults</code>包装器来封装<code class="fe lu lv lw lx b">UserDefaults</code>读写逻辑。</p><p id="7d92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将使用<code class="fe lu lv lw lx b">UserDefaults</code>包装器来跟踪自动登录的开/关状态，以及用户的用户名。这是您的<code class="fe lu lv lw lx b">UserDefaults</code>包装器通常的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6d0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过Swift 5.1中引入的属性包装器，您可以将您的<code class="fe lu lv lw lx b">UserDefaults</code>包装器简化为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="21a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很棒吧？想了解更多？请继续阅读…</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1ca8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">什么是属性包装？</h1><p id="77d7" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">在我们进入细节之前，让我们快速介绍一下什么是属性包装器。</p><p id="f880" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，属性包装是一种通用的数据结构，它可以截获属性的读/写访问，从而允许在属性的读/写操作期间添加自定义行为。</p><p id="a880" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要定义一个属性包装器，可以使用关键字<code class="fe lu lv lw lx b">@propertyWrapper</code>。假设您想要一个string类型的属性，每次读取或写入它时，都会打印一个控制台日志。</p><p id="f772" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以创建一个名为<code class="fe lu lv lw lx b">Printable</code>的属性包装器，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="a456" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的代码可以看出，property wrapper就像Swift中的任何其他<code class="fe lu lv lw lx b">struct</code>一样。然而，在定义属性包装器时，<code class="fe lu lv lw lx b">wrappedValue</code>是必需的。</p><p id="8870" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">wrappedValue</code> <code class="fe lu lv lw lx b">get</code>和<code class="fe lu lv lw lx b">set</code>块是您可以截取并执行所需操作的地方。在本例中，添加了一条打印语句来打印出值为<code class="fe lu lv lw lx b">get</code>或<code class="fe lu lv lw lx b">set</code>。</p><p id="8973" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是如何使用<code class="fe lu lv lw lx b">Printable</code>属性包装器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5ea9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们使用<code class="fe lu lv lw lx b">@</code>符号来声明被属性包装器包装的<code class="fe lu lv lw lx b">name</code>变量。如果您在Xcode游戏中尝试上述代码，您将看到如下所示的控制台输出:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="4712" class="ni mi it lx b gy nj nk l nl nm">Set value: Adidas<br/>Get value: Adidas</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="10f1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">用户默认值包装</h1><p id="e4c1" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">理解了属性包装器的工作原理后，我们现在准备开始实现我们的<code class="fe lu lv lw lx b">UserDefaults</code>包装器。概括地说，我们的属性包装器需要跟踪自动登录的开/关状态，以及用户的用户名。</p><p id="a357" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用我们上面讨论的概念，您可以很容易地将<code class="fe lu lv lw lx b">Printable</code>属性包装器转换成在属性读/写操作期间写入或读取<code class="fe lu lv lw lx b">UserDefaults</code>的属性包装器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="efb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们将我们的属性包装器命名为<code class="fe lu lv lw lx b">Storage</code>。它有两个属性:T3和T4。</p><p id="deba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">key</code>将是读写<code class="fe lu lv lw lx b">UserDefaults</code>时使用的键，<code class="fe lu lv lw lx b">defaultValue</code>是<code class="fe lu lv lw lx b">UserDefaults</code>中没有值时返回的值。</p><p id="0173" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了<code class="fe lu lv lw lx b">Storage</code>属性包装器，我们就可以开始实现<code class="fe lu lv lw lx b">UserDefaults</code>包装器了。这非常简单，我们只需要创建一个由<code class="fe lu lv lw lx b">Storage</code>属性包装器包装的用户名变量。</p><p id="2d7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意如何用<code class="fe lu lv lw lx b">key</code>和<code class="fe lu lv lw lx b">defaultValue</code>初始化<code class="fe lu lv lw lx b">Storage</code>属性包装器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6f2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至此，<code class="fe lu lv lw lx b">UserDefaults</code>包装器终于可以使用了。让我们来看看它的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f053" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，让我们尝试将<code class="fe lu lv lw lx b">enableAutoLogin</code>变量添加到我们的<code class="fe lu lv lw lx b">UserDefaults</code>包装器中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f3a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，您会注意到发生了以下两个错误:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="276d" class="ni mi it lx b gy nj nk l nl nm">Cannot convert value of type ‘Bool’ to expected argument type ‘String’</span><span id="79c7" class="ni mi it lx b gy nn nk l nl nm">Property type ‘Bool’ does not match that of the ‘wrappedValue’ property of its wrapper type ‘Storage’</span></pre><p id="94fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为我们的属性包装器目前只支持<code class="fe lu lv lw lx b">String</code>数据类型。要修复这两个错误，我们必须使我们的属性包装器通用。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="233c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">使属性包装成为泛型</h1><p id="84cc" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">为了使属性包装器通用，我们必须将属性包装器的<code class="fe lu lv lw lx b">wrappedValue</code>数据类型从<code class="fe lu lv lw lx b">String</code>更改为通用类型<code class="fe lu lv lw lx b">T</code>。</p><p id="5baf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们将不得不更新<code class="fe lu lv lw lx b">wrappedValue</code> <code class="fe lu lv lw lx b">get</code>块，以使用通用方式从<code class="fe lu lv lw lx b">UserDefaults</code>中读取。下面是更新后的属性包装:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c5a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了通用属性包装器，我们的<code class="fe lu lv lw lx b">UserDefaults</code>包装器现在可以毫无问题地存储一个布尔值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1cfe" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">存储自定义对象</h1><p id="421b" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">此时，我们的<code class="fe lu lv lw lx b">UserDefaults</code>包装器能够存储任何基本数据类型，如<code class="fe lu lv lw lx b">String</code>、<code class="fe lu lv lw lx b">Bool</code>、<code class="fe lu lv lw lx b">Int</code>、<code class="fe lu lv lw lx b">Float</code>、<code class="fe lu lv lw lx b">Array</code>等。</p><p id="ced0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是如果我们需要存储一个自定义对象呢？目前，如果我们试图存储一个自定义对象，我们将会遇到一个错误。在这一节中，让我们通过使我们的<code class="fe lu lv lw lx b">UserDefaults</code>包装器支持定制对象来使它更棒。</p><p id="b33f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的概念很简单，我们将自定义对象作为数据存储在<code class="fe lu lv lw lx b">UserDefaults</code>中。为了实现这一点，我们必须更新<code class="fe lu lv lw lx b">Storage</code>属性包装泛型类型<code class="fe lu lv lw lx b">T</code>，以符合<code class="fe lu lv lw lx b">Codable</code>协议。</p><p id="8ffe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，在<code class="fe lu lv lw lx b">wrappedValue</code> <code class="fe lu lv lw lx b">set</code>块中，我们将使用<code class="fe lu lv lw lx b">JSONEncoder</code>将自定义对象转换为数据并写入<code class="fe lu lv lw lx b">UserDefaults</code>。</p><p id="ea9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，在<code class="fe lu lv lw lx b">wrappedValue</code> <code class="fe lu lv lw lx b">get</code>块中，我们将使用<code class="fe lu lv lw lx b">JSONDecoder</code>将从<code class="fe lu lv lw lx b">UserDefaults</code>中检索到的数据转换回所需的数据类型。</p><p id="617a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是更新后的<code class="fe lu lv lw lx b">Storage</code>属性包装器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="e1ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了了解如何使用更新后的<code class="fe lu lv lw lx b">Storage</code>属性包装器，让我们看看下面的例子。</p><p id="c0b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您需要存储用户成功登录后服务器端返回的用户信息。</p><p id="f4d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，您需要一个结构来保存服务器返回的用户信息。该结构必须符合<code class="fe lu lv lw lx b">Codable</code>协议，以便将其转换为数据并存储到<code class="fe lu lv lw lx b">UserDefaults</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5d00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是在<code class="fe lu lv lw lx b">UserDefaults</code>包装器中声明一个<code class="fe lu lv lw lx b">User</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="ccec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！<code class="fe lu lv lw lx b">UserDefaults</code>包装器现在能够存储定制对象了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2cd1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">存储加密字符串</h1><p id="6f15" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">通过使我们的<code class="fe lu lv lw lx b">UserDefaults</code>包装器通用化，并且基本上能够存储我们想要的任何东西，我们已经走了很长的路。</p><p id="7710" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等，如果您需要使用<code class="fe lu lv lw lx b">UserDefaults</code>包装器存储用户密码或任何敏感数据，该怎么办？</p><p id="c09e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，存储在我们的<code class="fe lu lv lw lx b">UserDefaults</code>包装器中的所有字符串都是纯文本，我们都知道将密码存储为纯文本是一种非常糟糕的做法！</p><p id="5b2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们可以使用我们刚刚讨论过的概念，创建另一个属性包装器，在将它的值设置到<code class="fe lu lv lw lx b">UserDefaults</code>之前对其进行加密。我们将把这个属性包装器称为<code class="fe lu lv lw lx b">EncryptedStringStorage</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="e87f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于演示的目的，我们在这里做的加密只是反转整个字符串的简单操作。使用<code class="fe lu lv lw lx b">EncryptedStringStorage</code>属性包装器的方法相当简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="78db" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">包扎</h1><p id="0f47" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">通过使用Swift 5.1中引入的属性包装器，我们减少了<code class="fe lu lv lw lx b">UserDefaults</code>包装器中的大量样板代码。</p><p id="6bf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，<code class="fe lu lv lw lx b">Storage</code>属性包装器和<code class="fe lu lv lw lx b">EncryptedStringStorage</code>属性包装器也可以在其他项目中重用。</p><p id="c896" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下次当你需要创建一个<code class="fe lu lv lw lx b">UserDefaults</code>包装器时，试试属性包装器方法，我相信你会喜欢的。</p><p id="adb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到完整的源代码。</p><p id="adec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这篇文章对你有用。如果您对<code class="fe lu lv lw lx b">UserDefaults</code>包装有任何问题或想法，请随时发表评论。</p><p id="9fdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读和快乐编码！</p></div></div>    
</body>
</html>