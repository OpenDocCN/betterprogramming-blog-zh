<html>
<head>
<title>Algorand Smart Contracts Using PyTeal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTeal的Algorand智能合约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-algorand-413d3474cb5?source=collection_archive---------4-----------------------#2022-10-27">https://betterprogramming.pub/getting-started-with-algorand-413d3474cb5?source=collection_archive---------4-----------------------#2022-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fef9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用Python编写一个简单的智能合同，开始使用Algorand</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7b6962294a6272d056ace4fc62035e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JgwN0TkHdV0XtcZN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mari?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马里·赫林</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="0709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将展示如何使用PyTeal在Algorand上编写一个简单的智能契约，将其部署在本地开发网络上，并使用Python与它进行交互，然后在浏览器中进行交互。我将尝试简化所使用的工具，这样读者就可以专注于PyTeal代码。</p><h1 id="d2ab" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置开发环境</h1><p id="82ca" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">配置本地开发环境的第一步是设置<a class="ae kv" href="https://github.com/algorand/sandbox" rel="noopener ugc nofollow" target="_blank"> Algorand沙箱</a>。沙箱创建了一个本地专用网络，允许开发人员完全控制在任何时候重置其状态，并为该网络创建了一个索引器。使用Algorand沙盒的唯一要求是安装Docker和Docker-Compose。</p><p id="700f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要运行沙盒，请克隆存储库:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="91ef" class="mu lt iq mq b gy mv mw l mx my">git clone <a class="ae kv" href="https://github.com/algorand/sandbox" rel="noopener ugc nofollow" target="_blank">https://github.com/algorand/sandbox</a></span></pre><p id="d9c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过运行以下命令进入目录并启动沙盒(<code class="fe mz na nb mq b">-v</code>显示日志):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f101" class="mu lt iq mq b gy mv mw l mx my">sandbox up -v</span></pre><p id="359c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您应该有三个容器在运行:(I)一个索引器，(ii)一个用于索引器的Postgres数据库，最重要的是，(iii) algod客户端。</p><p id="76e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在algod容器中，可以运行例如<a class="ae kv" href="https://developer.algorand.org/docs/clis/goal/goal/" rel="noopener ugc nofollow" target="_blank"> goal </a>，这是Algorand用于与网络交互的CLI。您可以使用它来获取在沙箱中创建的帐户列表，方法是在容器中输入以下内容:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5ccc" class="mu lt iq mq b gy mv mw l mx my">./sandbox enter algod<br/>goal account list</span></pre><p id="646a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者通过运行以下命令:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="cc23" class="mu lt iq mq b gy mv mw l mx my">./sandbox goal account list</span></pre><p id="0558" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例将显示这台机器上的Algorand帐户列表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/8debbb507e32585694c3d12ed3317b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Kt9_giMDun3I_I_MmoBQA.png"/></div></div></figure><p id="2dc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于本教程，我不会进入可用的CLI工具，如goal，kmd，algokey等。我将尝试只使用Python，主要是Python algoSDK，但也会简单地涉及Beaker，这是一个用于<a class="ae kv" href="https://github.com/algorand/pyteal" rel="noopener ugc nofollow" target="_blank"> PyTeal </a>的智能合约开发框架。</p><p id="a304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Beaker使Algorand上的开发变得更加容易，也许我会在将来写一篇关于它的文章，但现在，我们将使用它的“helpers”函数从沙盒中获取algod客户端和帐户。</p><h2 id="4dc6" class="mu lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">安装所需的库</h2><p id="9264" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要编写、部署和调用智能合约，我们将在沙盒上创建，然后安装PyTeal、Python Algorand SDK和Beaker。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f553" class="mu lt iq mq b gy mv mw l mx my">python -m venv venv<br/>source venv/bin/activate</span><span id="3f3a" class="mu lt iq mq b gy no mw l mx my">pip install pyteal beaker-pyteal</span></pre><p id="357a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(SDK也将被安装，因为它是一个依赖项)</p><p id="19d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以使用Python Algorand SDK创建Algod客户端的连接实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Beaker为我们提供了一些帮助函数，使得创建客户端(使用默认的沙盒设置，它的运行方式与上面相同)和获取现有帐户变得更加容易。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="01bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以通过各自的ALGO <code class="fe mz na nb mq b">balance</code>检查现有账户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><blockquote class="nr ns nt"><p id="aef8" class="kw kx nu ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">账户余额DNP 46…6 miyi:40亿微藻类<br/>账户余额KM23D…NL3NA:40亿微藻类<br/>账户余额whn mm…SNHAI:10亿微藻类</p></blockquote><h1 id="de0d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">发送简单的支付交易</h1><p id="fced" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们通过发送一个在两个账户之间转移1000个微藻的交易来测试我们是否已经正确设置了一切。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们再次运行代码来列出帐户，我们将看到这两个帐户之间的余额变化。</p><h1 id="57ad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">沙盒区块链浏览器</h1><p id="9eef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这一点上，我建议检查一下<a class="ae kv" href="https://dappflow.org/" rel="noopener ugc nofollow" target="_blank">https://dappflow.org/</a>，这是一个浏览器开发工具，它使我们能够连接到沙盒，以获取有关帐户、交易、资产和应用程序的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/5863deff33734ae76786bb686b15740d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lf7rQnAF1twpDqQMFIXEcQ.png"/></div></div></figure><p id="73c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个工具，你可以很容易地检查发送到沙箱的事务，现有的应用程序，应用程序调用等。</p><h1 id="bbd8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">皮蒂尔</h1><p id="e24d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本教程中，我们将使用PyTeal编写一个简单的存储智能契约(应用程序)。</p><p id="2210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PyTeal是一个用于algrand Smart Contracts(ASC1s)的Python语言绑定，使用一种基于堆栈的语言实现，称为事务执行批准语言(Teal)。</p><p id="b7d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TEAL本质上是一种汇编语言，写起来并不用户友好。PyTeal在Teal上提供了高级函数式编程抽象，开发者可以通过PyTeal对象纯粹使用Python来表达智能合约逻辑。</p><p id="414a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将用于编写简单智能契约的PyTeal对象是:</p><ul class=""><li id="b5d1" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oe of og oh bi translated"><code class="fe mz na nb mq b">Approve</code> / <code class="fe mz na nb mq b">Reject </code> —表达式导致程序立即退出。如果使用<code class="fe mz na nb mq b">Approve</code>，则标记执行成功，如果使用<code class="fe mz na nb mq b">Reject</code>，则标记执行不成功。</li><li id="de82" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Bytes </code> —一个字节片是一个二进制字符串。</li><li id="108f" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Int </code> —整数，其中<code class="fe mz na nb mq b">n &gt;= 0</code>和<code class="fe mz na nb mq b">n &lt; 2 ** 64</code></li><li id="35e7" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Seq</code> —创建多个表达式序列的链接表达式</li><li id="ab7a" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Cond</code> —链接一系列测试以选择结果表达式的表达式</li><li id="4c41" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Btoi()</code> —将字节字符串转换为uint64的函数</li><li id="c172" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">App.globalPut</code> —写入当前应用程序全局状态的方法</li><li id="69dd" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Txn.application_args </code> —表示应用程序调用参数数组</li><li id="b207" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Txn.application_id() </code> —从当前事务的<code class="fe mz na nb mq b">ApplicationCall</code>部分获取应用ID</li><li id="7f3d" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">Txn.on_completion()</code> —从事务的<code class="fe mz na nb mq b">ApplicationCall</code>部分获取完成时动作</li><li id="15c6" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">OnComplete </code> —值的枚举<code class="fe mz na nb mq b">TxnObject.on_completion() may return</code></li></ul><p id="dc4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这些和其他PyTeal对象的完整参考，请参考这里的文档:<a class="ae kv" href="https://pyteal.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">https://pyteal.readthedocs.io/</a>。</p><p id="efbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，如果我们编译<code class="fe mz na nb mq b">Approve()</code> PyTeal对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ff19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将得到以下输出代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="29c6" class="mu lt iq mq b gy mv mw l mx my">#pragma version 6<br/>int 1<br/>return</span></pre><p id="9902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为第二个例子，如果我们编译一个序列，将整数<code class="fe mz na nb mq b">5</code>写入“number”键下的当前应用程序的全局状态，然后批准该事务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6a5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将得到以下输出代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="cedd" class="mu lt iq mq b gy mv mw l mx my">#pragma version 6<br/>byte “number”<br/>int 5<br/>app_global_put<br/>int 1<br/>return</span></pre><h1 id="bb95" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建简单的智能存储合同</h1><p id="9f0c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">关于Algorand智能合同如何工作的完整解释，我建议阅读Algorand开发者文档上智能合同页面的前几段，尤其是“智能合同的生命周期”一节</p><div class="on oo gp gr op oq"><a href="https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">智能合同详情——algrand开发商门户</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">阿尔格兰德智能合约是位于阿尔格兰德区块链上的逻辑块，可以远程调用。这些…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">developer.algorand.org</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe kp oq"/></div></div></a></div><p id="041a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将创建一个简单的存储智能契约，它在一个名为“number”的变量中保存一个值，允许用户检索当前值并在其上存储一个新值。我们将使用PyTeal来创建批准和清除状态程序。</p><p id="bda1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，审批程序负责实现应用程序的大部分逻辑。只有当程序完成时，堆栈上还留有一个非零值，或者调用顶部为正值的<code class="fe mz na nb mq b">return</code>操作码时，程序才会成功。<code class="fe mz na nb mq b">ClearStateProgram</code>用于处理使用clear调用的账户，以从其余额记录中删除智能合约。</p><p id="07a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe mz na nb mq b">ClearStateProgram</code>，我们将不处理任何逻辑，我们将总是在堆栈上留一个，这样调用将总是成功的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8599" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在<code class="fe mz na nb mq b">Approve()</code>上运行<code class="fe mz na nb mq b">compileTeal</code>功能。这将返回带有参数模式应用程序和TEAL版本6的<code class="fe mz na nb mq b">Int(1)</code>。这将生成以下TEAL代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a05d" class="mu lt iq mq b gy mv mw l mx my">#pragma version 6<br/>int 1<br/>return</span></pre><p id="be7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在对于处理所有事务调用类型的<code class="fe mz na nb mq b">ApprovalProgram</code>(除了<code class="fe mz na nb mq b">ClearState</code>):</p><ul class=""><li id="ff88" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oe of og oh bi translated"><code class="fe mz na nb mq b">NoOp </code> —执行<code class="fe mz na nb mq b">ApprovalProgram</code>的通用应用程序调用。</li><li id="1af6" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">OptIn </code> —账户使用此交易开始参与智能合约。参与支持本地存储使用。</li><li id="e56f" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">DeleteApplication </code> —删除申请交易。</li><li id="37e2" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">UpdateApplication </code> —更新合同的TEAL程序的交易。</li><li id="a28c" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">CloseOut</code> —账户使用该交易结束其在合同中的参与。基于TEAL逻辑，该调用可能会失败，从而阻止帐户从其余额记录中删除该合同。</li></ul><p id="f2b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的合同中，我们将拒绝除<code class="fe mz na nb mq b">NoOp</code>之外的所有交易电话。这是批准程序的完整代码。这可能不是编写该应用程序的最佳方式，但它展示了可以用PyTeal定义的不同逻辑部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4b56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该计划的主要部分是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="82b3" class="mu lt iq mq b gy mv mw l mx my">program = Cond(<br/>[Txn.application_id() == Int(0), init],<br/>[Txn.on_completion() == OnComplete.NoOp, no_op],    [Txn.on_completion() == OnComplete.DeleteApplication, Reject()],<br/>[Txn.on_completion() == OnComplete.UpdateApplication, Reject()],<br/>[Txn.on_completion() == OnComplete.OptIn, Reject()],<br/>[Txn.on_completion() == OnComplete.CloseOut, Reject()],<br/>)</span></pre><p id="ae5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用<code class="fe mz na nb mq b">Cond</code>来表示条件，就像一系列由逻辑语句和动作组成的“如果”语句。</p><p id="cfa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个将在应用程序创建时运行“init”表达式，即当调用事务但不包含应用程序id时:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d9d1" class="mu lt iq mq b gy mv mw l mx my">[Txn.application_id() == Int(0), init]</span></pre><p id="7db1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">init表达式将值<code class="fe mz na nb mq b">0</code>存储在全局var号中，然后批准交易。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f2d4" class="mu lt iq mq b gy mv mw l mx my">init = Seq(App.globalPut(number, Int(0)), Approve())</span></pre><p id="4b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，上面代码中的“number”只是一个Python变量，它指向开头定义的名为<code class="fe mz na nb mq b">number</code>的字节块。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e4fd" class="mu lt iq mq b gy mv mw l mx my">number = Bytes("number")</span></pre><p id="064f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续通用应用程序调用的<code class="fe mz na nb mq b">Cond</code>表达式(<code class="fe mz na nb mq b">NoOp</code>),“存储”表达式被调用:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d78a" class="mu lt iq mq b gy mv mw l mx my">[Txn.on_completion() == OnComplete.NoOp, store]</span></pre><p id="d9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储表达式获取事务调用的第一个参数<code class="fe mz na nb mq b">Tx.application_args[0]</code>，将其从字节转换为整数<code class="fe mz na nb mq b">Btoi()</code>，并将其存储在数字变量<code class="fe mz na nb mq b">App.globalPut(number, …)</code>中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3d41" class="mu lt iq mq b gy mv mw l mx my">store = Seq(<br/> App.globalPut(number, Btoi(Txn.application_args[0])),<br/> Approve()<br/>)</span></pre><p id="d807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，继续<code class="fe mz na nb mq b">Cond</code>表达式，对于<code class="fe mz na nb mq b">DeleteApplication</code>、<code class="fe mz na nb mq b">UpdateApplication</code>、<code class="fe mz na nb mq b">OptIn</code>和<code class="fe mz na nb mq b">CloseOut</code>交易类型，使用<code class="fe mz na nb mq b">Reject()</code>或<code class="fe mz na nb mq b">Int(0)</code>拒绝应用程序调用。代码如下:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bdc7" class="mu lt iq mq b gy mv mw l mx my">[Txn.on_completion() == OnComplete.DeleteApplication, Reject()],<br/>[Txn.on_completion() == OnComplete.UpdateApplication, Reject()],<br/>[Txn.on_completion() == OnComplete.OptIn, Reject()],<br/>[Txn.on_completion() == OnComplete.CloseOut, Reject()],</span></pre><p id="cc11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们上面定义的函数生成的TEAL代码太长了，不能在这里发表，但是我建议读者输出并浏览它。</p><p id="c2d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不得不说，目前有更好的方法在Algorand上编写应用程序，而不仅仅是使用这些简单的对象，即使用ABI路由器。它公开了应用程序中可以调用的方法，或者更好的是，使用Beaker。但是这个智能合同很容易实现。此外，Algorand Foundation已经暗示了对开发工具包的进一步改进，即Algokit，即将推出。</p><h1 id="896f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">部署智能合同</h1><p id="81e0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将通过使用Python SDK函数发送一个<code class="fe mz na nb mq b">ApplicationCreate</code>事务来部署智能契约，称为Algorand上的应用程序。</p><p id="9130" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将创建一个助手函数，以字节形式向<code class="fe mz na nb mq b">ApplicationCreate</code>事务提供审批和清算程序的TEAL代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="344f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们用<code class="fe mz na nb mq b">ApplicationCreateTxn</code>创建事务，并提供适当的输入:</p><ul class=""><li id="5b07" class="nz oa iq ky b kz la lc ld lf ob lj oc ln od lr oe of og oh bi translated"><code class="fe mz na nb mq b">sender </code> —合同创建人的地址</li><li id="df4b" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">sp</code> —我们可以从客户那里获得的建议参数</li><li id="c2ac" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">on_complete</code> —一旦程序运行完毕，什么应用程序应该这样做</li><li id="ebcf" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">approval_program</code>和<code class="fe mz na nb mq b">clear_program</code>——以字节为单位的TEAL代码</li><li id="6c43" class="nz oa iq ky b kz oi lc oj lf ok lj ol ln om lr oe of og oh bi translated"><code class="fe mz na nb mq b">global_schema</code>和<code class="fe mz na nb mq b">local_schema</code> — <code class="fe mz na nb mq b">StateSchema </code>表示全局和局部变量中有多少整数和字节的对象。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们用发送方的私钥对交易进行签名，并将交易发送给客户端。</p><p id="2502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行这段代码应该会输出一个包含应用程序id和事务哈希的字符串。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4bfc" class="mu lt iq mq b gy mv mw l mx my">Created App with id: 13 in tx: 5E5PXN24CBRZVWPD2KMMFFIV3LJZYXNGMOKH2NGANFQYXZ5ELQDA</span></pre><h1 id="2081" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进行应用程序调用</h1><p id="3c66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们将使用整数<code class="fe mz na nb mq b">5</code>作为参数调用应用程序，这样它就可以存储在应用程序的全局状态中，在<code class="fe mz na nb mq b">number</code>键下。</p><p id="62c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<code class="fe mz na nb mq b">ApplicationCallTxn</code>，添加带有输入列表的参数<code class="fe mz na nb mq b">app_args</code>。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d8c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用事务成功后，我们可以查询应用程序的全局状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bc42" class="mu lt iq mq b gy mv mw l mx my">{‘key’: b’number’, ‘value’: {‘bytes’: ‘’, ‘type’: 2, ‘uint’: 5}}</span></pre><p id="1c5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储在关键字<code class="fe mz na nb mq b">number</code>中的值属于类型<code class="fe mz na nb mq b">2</code>，即整数，并且具有值<code class="fe mz na nb mq b">5</code>。</p><p id="eb3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(注意，我们必须解码密钥才能看到<code class="fe mz na nb mq b">number</code>，因为它们存储为base64编码的字符串。)</p><h1 id="7aa7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分度器</h1><p id="0fb0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我将简单地提到索引器，它也可以在沙盒中使用，并允许查询大量信息。</p><p id="fb58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如从上面定义的应用程序中获取状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dbde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是输出结果:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9fae" class="mu lt iq mq b gy mv mw l mx my">{'application': {'created-at-round': 1792,<br/>  'deleted': False,<br/>  'id': 13,<br/>  'params': {'approval-program': 'BiACAAEmAQZudW1iZXIxGCISQAA2MRkiEkAAKDEZgQUSQAAeMRmBBBJAABQxGSMSQAALMRmBAhJAAAEAIkMiQyJDIkMoNhoAZyNDKCJnI0M=',<br/>   'clear-state-program': 'BoEBQw==',<br/>   'creator': 'DNP46TUHD55E7ZFF4GBLDL4ZQGTHX4V623FVIJPIZWMV32EAXOMVO6MIYI',<br/>   'global-state': [{'key': 'bnVtYmVy',<br/>     'value': {'bytes': '', 'type': 2, 'uint': 5}}],<br/>   'global-state-schema': {'num-byte-slice': 0, 'num-uint': 1},<br/>   'local-state-schema': {'num-byte-slice': 0, 'num-uint': 0}}},<br/> 'current-round': 16881}</span></pre><p id="edc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者获取特定帐户的信息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7d8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是输出结果:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="79a4" class="mu lt iq mq b gy mv mw l mx my">{'account': {'address': 'UBIVVQ72ZI6MUPGAF7EIXKNGBDQJFHY4BXP4NUEE5UQ6H6Y7MRI4HVLVE4',<br/>  'amount': 30002040,<br/>  'amount-without-pending-rewards': 30000000,<br/>  'created-at-round': 13826,<br/>  'deleted': False,<br/>  'pending-rewards': 2040,<br/>  'reward-base': 345,<br/>  'rewards': 2040,<br/>  'round': 16528,<br/>  'status': 'Offline',<br/>  'total-apps-opted-in': 0,<br/>  'total-assets-opted-in': 0,<br/>  'total-created-apps': 0,<br/>  'total-created-assets': 0},<br/> 'current-round': 16528}</span></pre><p id="4d24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者通过提供过滤器来搜索应用程序，尽管没有过滤器，我们将得到所有应用程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e0c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是截断的输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d899" class="mu lt iq mq b gy mv mw l mx my">{'applications': [{'created-at-round': 1521,<br/>   'deleted': False,<br/>   'id': 8,<br/>   'params': {'approval-program': 'BiACAAEmAQZudW1iZXIxGCISQAA2MRkiEkAAKDEZgQUSQAAeMRmBBBJAABQxGSMSQAALMRmBAhJAAAEAIkMiQyJDIkMoNhoAZyNDKCJnI0M=',<br/>    'clear-state-program': 'BoEBQw==',<br/>    'creator': 'DNP46TUHD55E7ZFF4GBLDL4ZQGTHX4V623FVIJPIZWMV32EAXOMVO6MIYI',<br/>    'global-state': [{'key': 'bnVtYmVy',<br/>      'value': {'bytes': '', 'type': 2, 'uint': 0}}],<br/>    'global-state-schema': {'num-byte-slice': 1, 'num-uint': 1},<br/>    'local-state-schema': {'num-byte-slice': 0, 'num-uint': 0}}},<br/>  (...)</span></pre><h1 id="83e6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">通过浏览器中的前端与合同交互</h1><p id="0e97" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们将编写一个基本的HTML文件，以便从浏览器与部署的应用程序进行交互。</p><p id="bd47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用Javascript Algorand SDK来构建和发送事务，并使用MyAlgo Connect对它们进行签名。</p><p id="2704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MyAlgo Connect Javascript库的缩小版可以在这里下载:<a class="ae kv" href="https://github.com/randlabs/myalgo-connect/releases" rel="noopener ugc nofollow" target="_blank">https://github.com/randlabs/myalgo-connect/releases</a>。</p><p id="8418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Algorand SDK可以在这里下载:<a class="ae kv" href="https://github.com/algorand/js-algorand-sdk" rel="noopener ugc nofollow" target="_blank">https://github.com/algorand/js-algorand-sdk</a>。它也可以通过一个缩小的包直接在浏览器中使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6da5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将省略错误捕捉和其他测试，以使代码不那么冗长，更易于阅读。</p><p id="0b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行测试，我们可以从连接到客户端并使用JavaScript从一个帐户获取信息开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="678e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要获得以下示例输出:</p><blockquote class="nr ns nt"><p id="9f3d" class="kw kx nu ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated">账户余额:29998014微藻</p></blockquote><p id="feec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将测试发送一个帐户将从MyAlgo Wallet签名的支付交易。为此，我们将使用带有Python SDK的KMD客户端来创建一个测试帐户，并为其提供资金以将该帐户导入MyAlgo Wallet。</p><p id="def4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">沙箱将默认具有一个“未加密的默认钱包”钱包，该钱包具有三个预先注资的账户。我们可以通过运行以下命令来检查这一点:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9530" class="mu lt iq mq b gy mv mw l mx my">./sandbox goal wallet list</span></pre><p id="6d91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看以下输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ea62" class="mu lt iq mq b gy mv mw l mx my">##################################################<br/>Wallet: AssetWallet<br/>ID: e3113df264e17bb996fdb1fc06a37fc9<br/>##################################################<br/>Wallet: unencrypted-default-wallet (default)<br/>ID: d62580046d0e0e78828f7ef9e86efae6<br/>##################################################</span></pre><p id="8f5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后去看账目:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b8e1" class="mu lt iq mq b gy mv mw l mx my">./sandbox goal account list</span></pre><p id="015c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以使用下面的Python代码片段在这个钱包中创建一个帐户:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c4c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(请在代码中插入您自己的助记符。)</p><p id="6c2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过选择“添加帐户”，然后选择“导入短语”，并输入创建帐户时使用的助记符中的25个单词，将该帐户导入my algo wallet(<a class="ae kv" href="https://wallet.myalgo.com/" rel="noopener ugc nofollow" target="_blank">https://wallet.myalgo.com</a>)。(我知道，可能有点繁琐。)</p><p id="0716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以发送支付交易。导入的帐户将在MyAlgo wallet中签名。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e2c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发送此交易时，MyAlgo wallet会提示您连接钱包中的帐户(通常，您会有一个用于dApp的“连接钱包”),然后签署交易。</p><p id="9962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果成功，您可以检查发送方和接收方帐户的余额，并验证付款金额是否已转账。</p><p id="9d20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们现在将读取状态并向部署的应用程序发送一个调用事务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a27c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使用页面上输入框中的值发送应用程序调用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/9d1c6f6a4342380eb6596f7185bb5199.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*WMEgnxCUxljtmgMfTHJd3g.png"/></div></figure><p id="3f71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果成功，应用程序状态中的<code class="fe mz na nb mq b">number</code>键应该更改为调用中的值。</p><p id="7c7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为了展示获取应用程序信息的另一种方式，我们将向沙箱中的索引器发出一个<code class="fe mz na nb mq b">GET</code>请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a8b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只是输出<code class="fe mz na nb mq b">global-state</code>键中的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/d7c20d4617d40488329b940ccd7b108b.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*YhlPHvvBiI_zP4O3fD_mzw.png"/></div></figure><p id="8063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是完整的输出将是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="df85" class="mu lt iq mq b gy mv mw l mx my">{‘application’: {‘created-at-round’: 3827,<br/> ‘deleted’: False,<br/> ‘id’: 13,<br/> ‘params’: {‘approval-program’: ‘BiACAAEmAQZudW1iZXIxGCISQAA3MRkiEkAAKDEZgQUSQAAeMRmBBBJAABQxGSMSQAALMRmBAhJAAAEAIkMiQyJDIkMoNhoAF2cjQygiZyND’,<br/> ‘clear-state-program’: ‘BoEBQw==’,<br/> ‘creator’: ‘DNP46TUHD55E7ZFF4GBLDL4ZQGTHX4V623FVIJPIZWMV32EAXOMVO6MIYI’,<br/> ‘global-state’: [{‘key’: ‘bnVtYmVy’,<br/> ‘value’: {‘bytes’: ‘’, ‘type’: 2, ‘uint’: 39}}],<br/> ‘global-state-schema’: {‘num-byte-slice’: 1, ‘num-uint’: 1},<br/> ‘local-state-schema’: {‘num-byte-slice’: 0, ‘num-uint’: 0}}},<br/> ‘current-round’: 37710}</span></pre><p id="eaab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！敬请关注更多内容。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="42f6" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">Connect with me</strong></span><span id="520b" class="mu lt iq mq b gy no mw l mx my"><a class="ae kv" href="https://twitter.com/nhaga" rel="noopener ugc nofollow" target="_blank">Twitter</a> | <a class="ae kv" href="https://www.linkedin.com/in/davidmduarte/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a> | <a class="ae kv" href="https://github.com/nhaga" rel="noopener ugc nofollow" target="_blank">Github</a> | <a class="ae kv" href="https://www.instagram.com/nhaga/" rel="noopener ugc nofollow" target="_blank">Instagram</a></span></pre></div></div>    
</body>
</html>