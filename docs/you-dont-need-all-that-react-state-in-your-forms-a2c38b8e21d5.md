# 您不需要表单中的所有反应状态

> 原文：<https://betterprogramming.pub/you-dont-need-all-that-react-state-in-your-forms-a2c38b8e21d5>

## 您知道只用纯 HTML 和 JavaScript 处理表单是可能的吗？

![](img/8bfc45b35fdc2d61eb5a5a286e369071.png)

由 [Katka Pavlickova](https://unsplash.com/@katerinapavlickova?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

前端应用程序包含某种形式是很常见的。不幸的是，具体到 *React* 应用程序，我经常看到人们用不必要的大量受控输入构建表单。这通常会增加表单的复杂性，而不会带来任何真正的好处。我以前也做过同样的事情。而且我也不能因为这个坏习惯去责怪别人甚至是以前的自己。毕竟，[官方 React 文档](https://reactjs.org/docs/uncontrolled-components.html)(在撰写本文时)说:

> 在大多数情况下，我们建议使用受控组件来实现表单。在受控组件中，表单数据由 React 组件处理。另一种方法是不受控制的组件，表单数据由 DOM 本身处理。

但是…我不买他们卖给我的东西。我在这里向你展示一个更简单的方法来写你的表格。

# **古老而痛苦的方式**

首先，我想提醒我们所有人，当我们用 state 填充表单时，它们是什么样子的。

在我的例子中，我将使用一些基本类型的输入。阅读本文时，请随意与代码沙箱进行交互。

使用受控输入对表单做出反应(使用使用状态)

请注意，我给`form`元素添加了一点样式，使它在浏览器中看起来稍微容易一些。

老实说…不得不把这些都写出来真的很伤人。你会注意到有很多笨拙的代码看起来是多余的。但这不是什么新鲜事。我们的 React 朋友在[文档](https://reactjs.org/docs/forms.html#alternatives-to-controlled-components)中提到了这个问题:

> 使用受控制的组件有时会很乏味，因为您需要为数据可能改变的每一种方式编写一个事件处理程序，并通过 React 组件处理所有的输入状态。

这是 React 中受控表单的一个显著缺点。虽然钩子的世界很棒，但你肯定经历过这种挣扎…大量对`useState`的调用…大量看起来几乎完全一样的`handleChange`函数…大量`input`道具的污染(其中一些可能会导致你的格式化程序对`input`元素进行多行处理)…这令人沮丧。

那些喜欢在类组件中拥有一个事件处理程序和整个状态对象的人可能知道`useReducer`模式:

用受控输入对表单做出反应(使用 useReducer 模式)

(这个`useReducer`模式是我从 [Kent C. Dodds](https://twitter.com/kentcdodds) 做的资源中学来的。虽然不常见，但在某些情况下确实很有用。)

一个钩子调用、一个事件处理程序和一个存储表单状态的地方(而不是分散在变量中)。一切都好，对吗？呃……大部分时间。

感觉我们还是有些多余。不要误会，显示`useState`和`handle*Change`的线条减少肯定很大！但是现在我们有相同的表单数据属性(例如`firstName`)被一遍又一遍地显示。*而且我们还在多余地污染所有的* `*input*` *道具！*

这种方法很好，但它的代码行与前一种方法大致相同。实际上，对于当前的格式化程序，它比长了几行*。这种方法也给新开发人员增加了一些开销，因为他们需要学习稍微复杂一点的`useReducer`钩子。(我们在表单中使用的 reducer 模式…对于 reducer 来说有点非正统。)*

所以最终，我们仍然会遇到不必要的冗余和复杂性问题。肯定有更好的方法…

# **更好的解决方案**

你知道只用纯 HTML 和 JS 处理表单是可能的吗？不，我不是指 React 所指的“纯 JS”。我指的是字面上的，不依赖于任何 npm 包的纯 JS。如果您使用常规形式的 API，事情会变得很好:

使用纯 HTML 和 JS(即不受控制的输入)对表单做出反应

现在这种做法是光荣的！没有不必要的状态变量……没有不必要的复杂性……代码冗余更少……当然，您可以看到，这个实现比之前的实现要少得多。与以前的实现相比，这个实现使用了几乎一半的代码行(忽略样式)。*一半*(差不多)。

(注意:我知道`select`元素的`defaultValue`反应警告；但是我忽略了它，因为我们的输入是不受控制的，这篇文章的重点是强调纯 HTML+JS 的可能性，*而不是*特定于 React 的语法。)

如果你对`form.elements`不熟悉，可以看看 [MDN 的文档](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements)。但是基本上，`form.elements`属性允许你通过它们的`id`或`name`获取表单的所有与输入相关的元素。我们使用了`[namedItem](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormControlsCollection/namedItem)`方法，但是你也可以直接从`form.elements`析构所有的元素:

使用纯 HTML 和 JS 反应表单(重构了 handleSubmit)

或者，你可以抓取所有的`input`，就好像它们来自一个数组。更多信息请参见`form.elements`上的文档。

您会注意到对于 TypeScript 用户来说事情变得更加冗长，因为您必须指定`form.elements`上的属性，以及所述属性映射到的输入元素。对于只使用 JS 的用户，你不必担心定义接口。你可以像平常一样析构元素。

对于 TypeScript 用户，注意有一种更简单的方法来处理表单控件的类型；所以，不要对你在上面看到的感到害怕。很有可能，您的表单数据已经是在您的代码库中某处定义的显式类型…至少它应该是这样。如果是这种情况，那么您可以创建一个实用程序类型，将表单数据的键映射到适当的 input 元素。根据个人经验，创建这个实用程序类型相当简单。然而，我不打算在本文中讨论这种方法。如果有足够的兴趣，也许我以后会把它添加到这里——或者在一篇单独的文章中。

# **不受控制的输入的另一个好处**

我之前已经给出了几个原因，但是默认情况下使用不受控制的输入更好的另一个重要原因是，它们*显著*减少了页面上产生的重新呈现。我知道你们中有些人会说这是吹毛求疵，但这确实值得考虑。如果你正在处理一个使用受控输入的表单/页面，那么每当用户更新一个值时，整个表单/页面将重新呈现*。每次输入(或删除)一个字母，每次从`select`元素中选择一个选项，每次点击一个复选框……嘣！全部重新招标。这是…低效的。*

如果你想更清楚地看到这一点，请访问 [React Hook Form](https://react-hook-form.com/) 文档并向下滚动到“隔离重新渲染”演示部分。现在想象一下，当您有更复杂的表单和组件时的情况。

现在，是的，我们可以谈谈“变通办法”。也许你会试着将一定数量的状态*或*表单的某些部分隔离成特殊的子组件。也许你可以尝试特殊的优化技术？

或许你已经接受了这句经典的话:“反正成本也没那么低。”但是我的问题是:当一个更简单的纯 JS 解决方案存在时，为什么还要为所有的复杂性和抽象而烦恼呢？

一个可以在所有前端框架之间移植的解决方案？我可以理解默认使用受控输入的争论，如果它使生活变得更容易，降低复杂性，或者减少代码行…但是在正常情况下，根本不是这样。

通常情况下，*默认*应该是使用非受控输入，*不是*受控输入。(尽管是的，每件事都有时间和地点，包括受控输入。)

# “但是复杂的表单呢？”

虽然我们已经介绍了如何处理表单提交以及如何在没有状态的情况下处理输入，但是有些人可能想知道更复杂的情况。有人可能会说，“格式化是一个常见的用例，没有状态就不能格式化输入。”实际上，[我已经写了另一篇文章](https://thomason-isaiah.medium.com/do-you-really-need-react-state-to-format-inputs-9d17f5f837fd)来证明你*可以*格式化没有状态的输入……或许也更干净。

你想知道表单验证吗？[有不需要前端框架的本地 API。它们可能会让造型比你想象的更容易。](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation)

你的表单验证用例更复杂吗？或者您可能需要访问更精确的信息，比如某个字段是否已经被访问过？那么 [React Hook Form](https://react-hook-form.com/) 就是一个*优秀的*解决方案，值得检验。它基本上寻求提供这些常见的表单功能，同时最小化状态变量、重新呈现和代码中不必要的抽象的数量。它也可以很好地处理基本的 HTML/CSS/JS！

(如果你熟悉`Formik`，那么我建议你试试`React Hook Form`，如果你还没试过的话。这主要是因为`Formik`采取了状态优先的方法，从而增加了你的渲染。

`Formik`这也使你更有可能过早地倾向于不必要的抽象——比如抽象的组件——而简单的 HTML 已经足够了。这并不是说`Formik`是一个糟糕的图书馆。但是，如果你在默认情况下严重依赖于`Formik`，你可能很难获得本文提到的好处。)

# **说实话……**

React 是一个*伟大的*前端框架。这可以从它被广泛使用和欣赏的程度上看得很清楚。如果没有他们的创新，Vue 等其他可爱的框架可能不会像今天这样好。

但是如果我们诚实的话，React 也有它的缺点。一个常见的缺点(至少从我的经验来看)是在 React 社区中过度依赖状态。我们用`redux`看到的。这种对政府的过度依赖常常让我们忽略了摆在眼前的解决方案。(例如，使用纯 HTML 和 JS 的常规表单功能。)并且它会导致代码效率更低或者更不容易维护。

我们天生就依赖国家。但是普通的 HTML/CSS/JS 比我们想象的有更多的可能性。

# **重塑我们的本能**

谢天谢地，过度依赖国家的问题并没有使 React 成为一个糟糕的框架，因为 React 本身并没有迫使你过度依赖国家。我们*可以*通过学习基础知识，通过选择只在我们真正需要的时候利用状态*来消除那些不好的本能*。这将增强我们作为 React 开发人员的能力，并帮助我们更加欣赏这个框架。

对我的前端技能来说，没有什么比学习普通的 HTML、CSS 和 JS 如何工作更好的了。记下这些基本的原则极大地改进了我开发的应用程序的代码。我鼓励你也加强你的基础(即使你对这些技能很有信心，因为你知道反应)。

这里有一个专业建议:当你在谷歌上搜索解决方案时(我们都这样做)，在看到如何在你选择的框架中做之前，试着弄清楚用*原生* HTML/CSS/JS 特性是否有可能(无论是 React 或 Vue 或 Svelte 或其他什么)。例如，*在*搜索“React how to submit a form”之前，通过搜索“JS how to submit a form”*开始*。这会让生活变得容易得多。

是的，我承认从技术上讲，你可以用原始的 HTML/CSS/JS 做所有的事情，但是有些是痛苦的。最重要的是弄清楚什么是原生特性更容易的，什么是前端框架更容易的，然后选择最好的。

你可以忽略的有偏见的“提示”:试试`[Svelte](https://svelte.dev/)`。真正让我开始强化基础知识的框架不是 React 或 Vue……它很苗条。这是因为 Svelte 真的试图增强现有的网络功能，而不是创造完全不同的概念(Svelte 有一些非常棒的功能)。

我强烈建议你在坚持使用你已经熟悉的框架的同时，尝试学习基本的 HTML/CSS/JS。但是如果因为状态变量诱惑你而不起作用，那么考虑尝试苗条来重新校准你自己。不会有坏处。

## 信用

我想特别感谢 [@kentcdodds](https://twitter.com/kentcdodds) 。虽然 Svelte 是真正帮助我开始学习基本面的框架，但我甚至没有注意到或关心基本面，直到我开始观看/阅读 Kent 的一些资源。他是一个有天赋的家伙，在制作 React 应用程序和编写测试方面真的很棒。