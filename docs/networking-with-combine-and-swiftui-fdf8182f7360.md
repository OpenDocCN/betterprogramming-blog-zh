# 使用 Combine 和 SwiftUI 联网

> 原文：<https://betterprogramming.pub/networking-with-combine-and-swiftui-fdf8182f7360>

## 使用反应式编程执行网络呼叫

![](img/53da9f03a556379e63a83a48511d4365.png)

基于 SF 符号中“网络”图标的标题图像

不及时更新应用程序不同部分的用户界面会导致非常糟糕的用户体验，我相信我们都知道至少有一两个应用程序因为这种行为而臭名昭著。

编写在 UI 和底层数据模型之间保持状态同步的应用程序传统上是一项艰巨的任务，开发社区已经提出了许多方法来以或多或少对开发人员友好的方式解决这一挑战。

反应式编程就是这样一种方法，SwiftUI 的反应式状态管理通过引入真理的*来源*的概念使这变得容易得多，真理的*来源可以使用 SwiftUI 的属性包装器如`@EnvironmentObject`、`@ObservedObject`和`@StateObject`在您的应用程序中共享。*

事实的来源通常是内存中的数据模型——但是众所周知，没有一个应用程序是孤立存在的。大多数现代应用程序需要在某个时候访问网络(或其他服务)，这意味着向应用程序引入异步行为。在我们的应用程序中，有很多方法可以处理异步行为:委托方法、回调处理程序、合并和异步/等待，等等。

在这个系列中，我们将看看如何在 SwiftUI 的上下文中使用 **Combine** 来

*   接入网络，
*   地图数据，
*   处理错误

…并处理一些高级场景。

让我们从了解如何使用 Combine 从服务器获取数据并将结果映射到 Swift `struct`开始。

# 如何使用 URLSession 获取数据

让我们假设我们正在开发一个应用程序的注册屏幕，其中一个需求是检查用户选择的用户名在我们的用户数据库中是否仍然可用。这需要我们与授权服务器进行通信。下面是一个请求，显示了我们如何尝试找出用户名 *sjobs* 是否仍然可用:

```
GET localhost:8080/isUserNameAvailable?userName=sjobs HTTP/1.1
```

然后，服务器会回复一个简短的 JSON 文档，说明用户名是否仍然可用:

```
HTTP/1.1 200 OK 
content-type: application/json; charset=utf-8 
content-length: 39 
connection: close 
date: Thu, 06 Jan 2022 16:09:08 GMT  
{"isAvailable":false, "userName":"sjobs"}
```

要在 Swift 中执行这个请求，我们可以使用`URLSession`。使用`URLSession`从网络获取数据的传统方式如下所示:

虽然这段代码运行良好，本身没有任何问题，但它确实存在一些问题:

1.  目前还不清楚快乐路径是什么——返回成功结果的唯一位置是非常隐蔽的(1 ),不熟悉使用完成处理程序的开发人员可能会对快乐路径甚至不使用`return`语句将网络调用的结果传递给调用者这一事实感到困惑。
2.  错误处理分散在各处(2，3，4，5)。
3.  有几个退出点，很容易忘记`if let`条件中的`return`语句之一。
4.  总的来说，它很难阅读和维护，即使你是一个有经验的 Swift 开发人员。
5.  很容易忘记你必须打电话给`resume()`来实际执行请求(6)。我很确定我们大多数人都疯狂地寻找 bug，结果却发现我们忘记了使用`resume`来启动请求。是的，我认为`resume`对于一个被集成来*发送*请求的 API 来说不是一个好名字。

> ***运行代码示例***
> 
> *你会在附带的* [*GitHub 资源库*](https://github.com/peterfriese/SwiftUI-Combine-Applied) *中找到所有的代码样本，在* `*Networking*` *文件夹中。为了最大程度地受益，我还在* `*server*` *子文件夹中提供了一个演示服务器(用 Vapor 构建)。要在您的机器上运行它，请执行以下操作:*

# 如何使用 Combine 获取数据

当他们推出 Combine 时，苹果为他们自己的许多异步 API 增加了发行商。这很好，因为这使我们更容易在自己的联合收割机管道中使用它们。

现在，让我们来看看代码在利用 Combine 进行重构后的样子。

这已经很容易阅读了，而且(除了确保我们得到有效 URL 的`guard`语句)只有*一个*出口点。

让我们一步一步地浏览代码:

1.  我们使用`dataTaskPublisher`来执行请求。此发布者是一次性发布者，一旦请求的数据到达，它将发出一个事件。值得记住的是，如果没有订阅者，联合发布者不执行任何工作。这意味着，除非至少有一个订阅者，否则该发布者不会对给定的 URL 执行任何调用。稍后我将向您展示如何将这个管道连接到 UI，并确保每次用户输入他们的首选用户名时都会调用它。
2.  一旦请求返回，发布者发出一个包含`data`和`response`的值。在这一行中，我们使用`map`操作符来转换这个结果。如您所见，我们可以重用先前版本代码中的大部分数据映射代码，除了一些小的更改:
3.  我们可以返回一个`Boolean`值来指示用户名是否仍然可用，而不是调用`completion`闭包。该值将通过管道向下传递。
4.  在数据映射失败的情况下，我们捕捉错误并返回`false`，这似乎是一个很好的妥协。
5.  对于访问网络时可能出现的任何错误，我们也是这样做的。这是一种简化，我们可能需要在未来重新审视。

这看起来比最初的版本更好，更容易阅读，我们可以在这里停下来，将它集成到我们的应用程序中。

但是我们可以做得更好。这里有三个变化，将使代码更线性，更容易推理:

# 使用关键路径解构元组

我们经常发现自己处于需要从变量中提取特定属性的情况。在我们的例子中，我们接收到一个包含我们发送的 URL 请求的`data`和`response`的元组。下面是`URLSession`中各自的声明:

Combine 提供了一个重载版本的`map`操作符，允许我们使用一个键路径来析构元组，并且只访问我们关心的属性:

# 更轻松地映射数据

由于映射数据是一项如此常见的任务，Combine 提供了专门的操作符来使它变得更容易:`decode(type:decoder:)`。

这将从上游发布者返回 decode 的`data`值，并将其解码为一个`UserNameAvailableMessage`实例。

最后，我们可以再次使用`map`操作符来析构`UserNameAvailableMessage`并访问它的`isAvailable`属性:

# 使用合并提取数据，简化

有了所有这些变化，我们现在有了一个易于阅读的管道版本，并且有一个线性流程:

# 如何连接 SwiftUI

最后，让我们看看如何在我们假设的注册表单中集成这个新的联合管道。

这是一个精简版的注册表单，只包含一个用户名字段、一个显示消息的`Text`标签和一个注册按钮。在实际的应用程序中，我们还需要一些 UI 元素来提供密码和密码确认。

所有 UI 元素都连接到一个视图模型，以分隔关注点并保持视图整洁易读:

由于`@Published`属性是组合发布者，我们可以订阅它们，以便在它们的值改变时接收更新。这允许我们调用上面创建的`checkUserNameAvailable`管道。

让我们创建一个可重用的 publisher，我们可以用它来驱动 UI 中需要显示依赖于用户名是否可用的信息的部分。一种方法是创建一个惰性计算属性。这确保了只有在需要时才会建立管道，并且只有一个管道实例。

要调用另一个管道并使用其结果，我们可以使用`flatMap`操作符。这将从上游发布者获取所有输入事件(即由`$username` published 属性发出的值)，并将它们转换成一个新的发布者(在我们的例子中，是发布者`checkUserNameAvailable`)。

在下一步也是最后一步，我们将把`isUsernameAvailablePublisher`的结果连接到 UI。如果您看一下视图模型，您会注意到我们在视图模型的输出部分有两个属性:一个用于与用户名相关的任何消息，另一个保存表单的整体验证状态(记住，在实际的注册表单中，我们可能还需要验证密码字段)。

联合收割机发布器可以连接到多个订户，因此我们可以将`isValid`和`usernameMessage`连接到`isUsernameAvailablePublisher`:

使用这种方法允许我们重用`isUsernameAvailablePublisher`并使用它来驱动表单的整体`isValid`状态(这将启用/禁用*提交*按钮),以及通知用户他们选择的用户名是否仍然可用的错误消息标签。

# 如何处理“不允许从后台线程发布更改”

运行这段代码时，您会注意到几个问题:

1.  对于您键入的每个字符，API 端点都会被调用几次
2.  Xcode 告诉你不应该从后台线程更新 UI

在接下来的几集中，我们将更深入地探究这些问题的原因，但是现在，让我们先来解决这个错误消息:

```
SwiftUI] Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.
```

出现此错误消息的原因是，Combine 将在后台线程上执行网络请求。当请求被满足时，我们将结果分配给视图模型上的一个已发布的属性。反过来，这将提示 SwiftUI 更新 UI——这将发生在前台线程上。

为了防止这种情况发生，我们需要使用`receive(on:)`操作符指示 Combine 在收到网络请求的结果后切换到前台线程:

在下一集讨论联合调度器时，我们将深入探讨线程化。

# 关闭

在本文中，我向您展示了如何使用 Combine 访问网络，以及这如何使您能够编写比相应的回调驱动代码更易于阅读和维护的直线代码。

我们还研究了如何通过使用视图模型将向 SwiftUI 发出网络请求的联合管道连接起来，并将管道附加到一个`@Published`属性。

现在，你可能想知道为什么`isUsernameAvailablePublisher`使用`Never`作为它的错误类型——毕竟，网络错误是我们需要处理的事情。

我们将在下一集研究错误处理(和自定义数据映射)。我们还将研究优化基于 Combine 的网络层的方法，敬请关注！

感谢阅读🔥

*原发布于*[*https://peterfriese . dev*](https://peterfriese.dev/posts/swiftui-combine-networking-gettingstarted/)*。*