<html>
<head>
<title>Dockerizing a Ruby on Rails API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Ruby on Rails API进行Dockerizing</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerizing-a-ruby-on-rails-api-aca8a0cb963c?source=collection_archive---------2-----------------------#2019-06-16">https://betterprogramming.pub/dockerizing-a-ruby-on-rails-api-aca8a0cb963c?source=collection_archive---------2-----------------------#2019-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/fd89dc72b287aed0a058bc5fa22d6a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*d-HKujYLR5Q2QED4ybEiPw.png"/></div></figure><p id="4cad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">容器提供了一种在与实际运行环境完全隔离的环境中打包应用程序的方法。作为软件的一个标准单元，容器封装了代码及其所有的依赖项，因此它可以从一个环境高效地运行到另一个环境。</p><p id="1ae5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这种抽象将开发过程与部署过程分离开来，提供了一种灵活、可移植、可扩展的轻量级替代方案，可以将应用程序部署在私有数据中心、公共云甚至本地个人计算机上。</p><p id="dbe1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>是一个平台，使开发者能够将他们的应用容器化，他们可以在Linux容器中部署、构建和运行它们。</p><p id="b612" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们如何着手把本地运行的<a class="ae ks" href="https://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> Ruby on Rails </a>应用程序转换成在容器中运行的Dockerized应用程序？</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="0742" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤1:环境设置</h1><p id="f39a" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">通过选择所需的操作系统并按照屏幕上的说明安装<a class="ae ks" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker Desktop </a>。</p><p id="b665" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">安装后，打开终端并运行以下命令，确保安装正确:</p><p id="cabb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe md me mf mg b">docker --version</code></p><p id="970b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">期待看到你刚刚安装的Docker版本。说明docker不是可识别命令的错误表明Docker没有正确安装或没有完成安装。</p><p id="bff6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe md me mf mg b">docker run hello-world</code></p><p id="47bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个命令将运行一个简单的<em class="mh"> Hello，World </em>应用程序。</p><p id="45f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能会注意到一条消息，说明Docker找不到名为<em class="mh"> hello-world，</em>的图像，但是正确的消息打印到了屏幕上。这是因为Docker有一组托管在Docker Hub上的存储库，为新用户和有经验的用户提供了一个将他们的应用程序归档的起点，并通过记录良好的示例展示了最佳实践。</p><p id="dbd7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的程序中，我们将使用<a class="ae ks" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>来运行一个名为ParkMe的应用程序，在一个<a class="ae ks" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>服务器上运行Ruby，带有一个<a class="ae ks" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>数据库。</p><p id="3b8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">ParkMe的源代码可以在下面找到。您可以随意派生和克隆这个存储库，并查看docker分支。</p><div class="mi mj gp gr mk ml"><a href="https://github.com/mshapir/ParkMe-Final-Backend-Rails/tree/docker/ParkMe" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">mshapir/park me-Final-back end-Rails</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">后端api使用rails停车应用程序。为mshapir/park me-Final-back end-Rails开发做出贡献，创建一个…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz js ml"/></div></div></a></div><p id="6d48" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以开始整理了！</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="c18b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤2:创建Dockerfile文件</h1><p id="1870" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">Dockerfile确切地定义了容器环境内部发生的事情。在项目的根目录下，创建一个名为<code class="fe md me mf mg b">Dockerfile</code>的新文件，并将以下内容粘贴到内容中:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c528" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以通过docker文件中定义的命令流快速查看我们的应用程序正在使用的工具——Ruby 2 . 3 . 4版、Node.js服务器和PostgreSQL数据库——所有这些工具都可以很容易地进行调整，以匹配您的应用程序堆栈。</p><p id="44c0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦运行了Docker映像，Docker就会一行一行地运行这个文件，以安装最新版本的工具，创建必要的目录和文件，用于基于工具的依赖性管理。我们的是Ruby，所以我们使用的是一个<a class="ae ks" href="https://bundler.io/v1.5/gemfile.html" rel="noopener ugc nofollow" target="_blank"> Gemfile </a>。然后，我们可以在端口3000上通过entrypoint.sh脚本运行应用程序。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="814c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤3:创建Entrypoint.sh</h1><p id="0530" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">在与Dockerfile相同的目录中，创建一个名为<code class="fe md me mf mg b">entrypoint.sh</code>的文件，并将以下内容粘贴到其内容中:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="3d5c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤4:创建Docker-compose.yml</h1><p id="1cda" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">Docker Compose是一个定义和运行多容器Docker应用程序的工具。</p><p id="68e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将使用这个工具来设置自己，以便能够一起运行其他相关的Docker应用程序——例如，我们应用程序的前端。该文件还定义了我们的应用程序在生产环境中的行为。</p><p id="6173" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在Dockerfile和entrypoint.sh文件所在的目录中，创建一个名为docker-compose.yml的文件，并将以下内容粘贴到其内容中:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d767" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个文件定义了组成我们的应用程序的服务。一定要用你的Docker API密匙替换<code class="fe md me mf mg b">YOUR_API_KEY</code>！</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="f9cc" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">第五步:跑步</h1><p id="cff6" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">在您的终端中，运行下面的命令来读取您的<code class="fe md me mf mg b">docker-compose.yml</code>，并在容器中调出应用程序服务:</p><p id="1546" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe md me mf mg b">docker-compose up</code></p><p id="5fc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您从Docker指南中提取一个示例Docker文件，最后一行是:<code class="fe md me mf mg b">CMD [“rails”, “server”, “-b”, “0.0.0.0”]</code>，您可能会遇到一些错误。</p><p id="fa03" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该命令与传递给Docker Compose的命令之间的冲突会阻止应用程序启动，因为这两个文件都指定了每次容器启动时要运行的命令。</p><p id="e6fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们在Dockerfile中注释掉这一行，以允许命令<code class="fe md me mf mg b">bash -c “rm -f tmp/pids/server.pid &amp;&amp; bundle exec rails s -p 3000 -b ‘0.0.0.0’”</code> <em class="mh"> </em>启动应用程序。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="fa3b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤6:创建数据库实例</h1><p id="2ddc" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">在真正能够使用像ParkMe这样的后端服务之前，您需要在您的容器内部配置您的数据库，即使它是在您的本地机器上完成的。请记住，您是在一个隔离的环境中运行您的应用程序！</p><p id="e345" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在您的终端中运行以下命令:</p><p id="95c2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe md me mf mg b">docker-compose run web rake db:create</code></p><p id="a046" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">和</p><p id="23ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe md me mf mg b">docker-compose run web rake db:migrate</code></p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="327e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">第七步:测试</h1><p id="6f96" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">要验证服务是否启动并运行，请导航到REST API中的一个入口点。如果你以ParkMe为例，打开任何一个网页浏览器，粘贴如下:<a class="ae ks" href="http://localhost:3000/api/v1/users/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/v1/users/</a>。</p><p id="06fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您应该看到以JSON格式返回的用户列表(如果您在步骤6中向数据库添加了一些新用户)。</p><p id="ef1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的应用程序作为Docker容器中的服务启动并运行！</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="5433" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">步骤8:部署</h1><p id="acf0" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">部署应用程序可以通过对docker-compose.yml文件做一些调整来完成，</p><p id="de2e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe md me mf mg b">docker swarm init</code></p><p id="98da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">防止与您的节点不是群管理器相关的错误；</p><p id="c420" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe md me mf mg b">docker stack deploy -c docker-compose.yml nameofyourapp</code></p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="4749" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="5408" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">容器化是抽象应用程序基础结构层的一种好方法，可以尽可能高效地运输代码。</p><p id="22b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只需几个额外的步骤，您也可以让您的应用程序在Docker容器中运行！</p></div></div>    
</body>
</html>