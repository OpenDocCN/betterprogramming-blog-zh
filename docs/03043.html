<html>
<head>
<title>Code Smells in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的代码味道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/more-code-smells-in-javascript-113067dbd89f?source=collection_archive---------10-----------------------#2020-01-16">https://betterprogramming.pub/more-code-smells-in-javascript-113067dbd89f?source=collection_archive---------10-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1076" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看特征羡慕和亲密类</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d51cf673288c779432df523ba3bc4131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGe8AUEnX9-MIQiyx5WcLw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mimithian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米米·蒂安</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coding-at-work?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程中，代码气味是一段代码的特征，表明可能有更深层次的问题。这是一种主观特征，用来通过观察代码来判断代码是否具有良好的质量。</p><p id="4b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们看到了JavaScript代码中更多的代码味道，包括特性嫉妒和过于亲密的类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9747" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">特征羡慕</h1><p id="41ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">特性嫉妒意味着一个类使用了另一个类太多的特性。这意味着一个类中的大部分引用另一个类中的一些东西。</p><p id="21c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这尤其适用于在另一个类中过度使用一个类中的字段</p><p id="1a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">ShapeCalculator</code>类使用了来自<code class="fe nb nc nd ne b">Rectangle</code>的大量字段。当我们不需要的时候，我们从<code class="fe nb nc nd ne b">ShapeCalculator</code>类中的<code class="fe nb nc nd ne b">Rectangle</code>获取所有字段。</p><p id="0e22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这打破了<code class="fe nb nc nd ne b">Rectangle</code>类中的封装，因为我们在不需要的时候暴露了字段<code class="fe nb nc nd ne b">height</code>和<code class="fe nb nc nd ne b">width</code>。</p><p id="2cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们应该避免使用来自<code class="fe nb nc nd ne b">ShapeCalculator</code>类中<code class="fe nb nc nd ne b">Rectangle</code>对象的<code class="fe nb nc nd ne b">height</code>和<code class="fe nb nc nd ne b">width</code>字段，并在<code class="fe nb nc nd ne b">Rectangle</code>类中编写一个方法，然后在<code class="fe nb nc nd ne b">ShapeCalculator</code>类中调用它，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这要好得多，因为我们在来自<code class="fe nb nc nd ne b">Rectangle</code>类的<code class="fe nb nc nd ne b">ShapeCalculator</code>中引用的只是<code class="fe nb nc nd ne b">getArea</code>方法。我们不再需要担心<code class="fe nb nc nd ne b">height</code>和<code class="fe nb nc nd ne b">width</code>字段的变化，因为它们被封装在<code class="fe nb nc nd ne b">getArea</code>方法中。</p><p id="d6ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要<code class="fe nb nc nd ne b">getArea</code>返回一个带有<code class="fe nb nc nd ne b">Rectangle</code>区域的数字，我们就不关心<code class="fe nb nc nd ne b">Rectangle</code>类中的字段或方法的实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/db9b790159bf165668d17384bbea4907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YniifVjiDRxYC9iG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wynand_uys?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Wynand Uys </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ead1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="ng">不恰当的亲密关系</em></h1><p id="0c5d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">依赖于另一个类的实现细节的类被认为是过于亲密的。</p><p id="9363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不想要依赖于其他类的实现的类，因为这意味着当第一个类改变时，我们必须改变两个类。</p><p id="191b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有足够的字段封装或方法实现。</p><p id="471a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺少封装可能是由于暴露了类的字段。让我们直接设置字段值在大多数情况下可能并不好。</p><p id="8838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写遵循某个接口的代码是不可能的，因为很难改变一个类来遵循一个接口，因为如此多的其他类依赖于给定类的实现。</p><p id="b343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类之间过多的交互也会导致混乱，因为工作流很难跟踪。这是面向对象版本的意大利面条代码。</p><p id="b288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们改变一个类时，其他类过于依赖的任何类的改变也会产生问题，因为它们是如此紧密耦合，我们必须改变所有依赖它的类来改变它。这加剧了代码的可维护性问题，除了意大利面条式的代码。</p><p id="bbcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe nb nc nd ne b">ShapeCalculator</code>大量使用了<code class="fe nb nc nd ne b">Box</code>类的字段和方法。</p><p id="fb3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nb nc nd ne b">ShapeCalculator</code>类中，我们引用了<code class="fe nb nc nd ne b">Box</code>的<code class="fe nb nc nd ne b">length</code>、<code class="fe nb nc nd ne b">width</code>、<code class="fe nb nc nd ne b">height</code>属性和<code class="fe nb nc nd ne b">getSurfaceArea</code>方法。</p><p id="e52c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在<code class="fe nb nc nd ne b">Box</code>类中改变了什么，我们也必须在<code class="fe nb nc nd ne b">ShapeCalculator</code>中改变它。例如，如果我们重命名<code class="fe nb nc nd ne b">Box</code>类中的所有内容，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须在<code class="fe nb nc nd ne b">ShapeCalculator</code>计算器中进行同样的更改。这完全是一场噩梦，甚至没有那么复杂。想象一下，如果我们的类有更多的字段和方法，它很快变得不可维护。</p><p id="965c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交互也很混乱。有些字段在<code class="fe nb nc nd ne b">ShapeCalculator</code>中用于计算，有些方法直接从<code class="fe nb nc nd ne b">Box</code>类中使用。</p><p id="8a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该做的不是在<code class="fe nb nc nd ne b">ShapeCalculator</code>类中引用<code class="fe nb nc nd ne b">Box</code>类中的任何字段，而是改变<code class="fe nb nc nd ne b">Box</code>类来提供<code class="fe nb nc nd ne b">ShapeCalculator</code>类需要的所有方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe nb nc nd ne b">ShapeCalculator</code>可以改写为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe nb nc nd ne b">ShapeCalculator</code>类只引用了<code class="fe nb nc nd ne b">Box</code>类的方法，而没有混合引用来自<code class="fe nb nc nd ne b">Box</code>类的字段和方法。</p><p id="f641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们不必担心字段名称是否在<code class="fe nb nc nd ne b">Box</code>类中被改变，因为我们从未使用过它们。</p><p id="f52e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们写类的时候，我们应该只暴露我们需要的。大多数字段可能是隐藏的，这样它们就不会被外部类使用。这减少了维护代码的工作量，因为它们不必在所有使用它们的类中进行更改。</p><p id="a13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它保持了一切的模块化和独立。同样，出于同样的原因，我们只公开我们需要使用的方法，而对公众隐藏其他方法，如helper方法。</p><p id="5634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类之间过多的耦合和引用是没有好处的！</p></div></div>    
</body>
</html>