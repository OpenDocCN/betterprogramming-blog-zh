# 从α到ω的泛函 JS:滤波器

> 原文：<https://betterprogramming.pub/functional-js-from-%CE%B1-to-%CF%89-filter-10d8227e8f34>

## 过滤功能在我们神圣的三位一体中是第二位的

> Richard Waters 开发了一个程序，可以自动分析传统的 Fortran 程序，从映射、过滤和累积的角度来查看它们。他发现 Fortran 科学子程序包中整整 90%的代码恰好符合这种范式。
> 
> — SICP 1979 年

![](img/6da31d4faa02b63e443e8a715ff65ea4.png)

照片由[泰勒·尼克斯](https://unsplash.com/@jtylernix)在 [Unsplash](https://unsplash.com/photos/W9rOPHK--RQ) 上拍摄

我们 JavaScript 编码人员有机会实践一种支持函数式编程的多参数语言。

你想学习那种力量吗？

让我们从 24 课开始，从α到ω，解决我们的日常问题。

**课程概述:**

[α。对于每个](https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1)，

[β。地图](https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3)，

γ.过滤器。

# 签到

我经常谈到函数的*签名*。签名是一行语句，表示意图(或名称)以及函数的输入和输出，就像`double::number -> number`。

他们对实施只字不提。如果你在 15 分钟内用一个好的签名解决了你的问题，你有一整天的时间来重构你的实现。签名应该总是先于实现，就像测试先于 TDD 的开发一样。我想做什么？在我的计算/效果之前我得到了什么，之后我能期待什么？

在编写代码之前，思考你想要达到的目标是至关重要的。你会感觉到控制着你的代码，准备好一点一点地解决问题。它防止你迷失在代码的意大利面中，疯狂地修补一切，直到它看起来可以工作。

在 JavaScript 中，签名不是硬编码的，因为它是一种松散/动态类型的语言。秘诀就是使用注释。让我们想象我们的领域是一个赌场，尤其是轮盘赌游戏。这里有一些有用的签名，以及基本的实现。

# 加入秩序

`Map`、`filter`和`reduce`是简单的高阶函数，如本系列之前的文章所述。当您只使用一个更高级别的有序性时，您总是对两个签名感兴趣:您的二阶(更高级)函数的签名(运行另一个函数的函数)和您的一阶函数的签名(作为将要运行的参数接收的经典函数，例如回调函数)。

如您所见，`filter`有一个非常有趣的特征:它返回相同类型元素的集合，最终是只包含匹配条件的元素的原始列表的子集。事实上，它不能在你的收藏中添加或转换任何东西。

这个条件由回调测试，对原始集合的每个元素逐一执行。

回调的签名将类似于`callback::(a) -> boolean`，在循环中采用当前的`a`。事实上，返回真值的回调是允许高阶函数`filter`只保留搜索结果的通过/不通过门。

我们的`even`和`odd`函数在这里很受欢迎，因为它们的`number -> boolean`签名与我们的`number[]`数组兼容。

我们的`color`函数逻辑上不能原样使用，只是更进一步。

我知道你不同意这个`play`不纯的函数与全局范围共享一些常数。我一开始也是这么想的，但是我们还得等着看我们从`closures`、`currying,`、*、*、`memoization`、*、*中学到了什么，才能治愈这种不可接受的杂质。

抛开我们的赌场假设，你可以把你的代码看成一个到处都是传送带的大工厂。武器拿走我们保留的东西，把它放在一条新的带子里，把其余的扔进垃圾桶。然后特殊的`map` 手臂改造他们在新皮带上发现的东西。这些机器可以兼容我们领域内任何规模的收藏。事实上，我正在做一个名为“Functorio”的项目，这是一个在大工厂里用经典函数式编程玩的游戏。

## 我自己的代数

你能预见一些不同的自定义代数的到来吗？我们非常紧密地定义数据和功能的世界，一个领域接一个领域，一个是赌场，另一个是约会网站。这就是为什么`map-filter-reduce`是我们的神圣三位一体:他们可以很容易地匹配几乎每个领域。剧透警告:`map`和`filter`只是`reduce`最常见的一些用例。函数式程序员选择将它们分开，因为它们太常见了。对于`odd, even, min, max, reverse`等就不一定了。最后，都是关于特定领域的代数——例如，一个制作精良的专业代码库。

函数式编程并不是一种新范式。这是一种思考编码的方式:我们希望定义一个人脑可以控制的内聚的虚拟世界——就像 React 中的虚拟 DOM 一样。它基于图灵机:真链和假链——所以我们依赖于布尔代数。函数是我们最小的比特，作为抽象的可组合工具来激活这个生活领域——所以我们拥抱[λ演算](https://www.youtube.com/watch?v=3VQ382QG-y4)。它是建立在内聚列表和集合之上的，所以我们拥抱[范畴理论](https://github.com/hmemcpy/milewski-ctfp-pdf)。其余的类型和计算将由我们自己完成，所以我们为我们的特定领域创建了一个新的代数:一个在线赌场、一个比萨饼店预订监视器、一个兽医后勤办公室、一个银行 ERP 或一个鸟类学家网站。

您可能知道，`filter`存在于任何 JavaScript 数组的本机实现中。这是一个您可以使用的原型方法(如果您不像我们一样编写自己的过滤器)。我们可以一起想象它的实现，然后用一些`maps`把它链接起来，感受我们的新力量。

链接我们的`filter`而不是每次都创建一个新的`const`怎么样？通过组合是可能的，但是目前在我们最喜欢的语言中还没有内置的操作符。但是未来的 JavaScript (ES9，ES10？)，应该有管道函数的方式，用这个管道操作符:`|>`。它已经可以和巴别塔一起使用了。

下一课之后，我们将能够构建`pipe` 和`compose` 运算符函数，允许我们在 2020 年之前链接函数，尤其是我们的高阶`map`、`filter`和 `reduce`。