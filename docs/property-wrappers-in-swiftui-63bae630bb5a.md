# SwiftUI 中的属性包装器指南

> 原文：<https://betterprogramming.pub/property-wrappers-in-swiftui-63bae630bb5a>

## @State、@Published、@EnvironmentObject 等等

![](img/a27d6720da72ed403728342917746ec0.png)

照片由 [Tim Gouw](https://unsplash.com/@punttim?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄。

SwiftUI 有许多用于不同目的的属性包装器，以使开发人员的生活更加轻松。我想分享一些关于这些包装的注意事项。让我们开始吧。

# **@状态**

*   我们可以通过将该结构用作值类型来修改该结构的值。
*   这意味着存储简单的类型，如`String`、`Int`、`Bool`等。
*   我们需要在视图中使用它，建议将其设为私有。
*   我们应该提供一个默认值。
*   它可以用作装订。

# **@ObservedObject**

*   当我们想要在视图之间传递一个复杂的对象时，我们可以使用这个，当对象改变时，所有的视图都会得到通知。
*   类型应符合`ObservableObject`协议。
*   我们需要将对象中的属性标记为`@Published`,以指示正在使用该对象的视图的变化。
*   对象类型应该是类。
*   我们应该提供一个默认值。
*   假设我们有一个符合`ObservableObject` 和的`MenuData`类，将它的属性菜单之一标记为`@Published`。每当这个菜单改变时，它会通知所有正在使用的视图。在我们的例子中，它是`ContentView`:

*   如果没有视图正在使用该对象，则发布的数据将被忽略。

# **@环境对象**

*   类似于`@ObservedObject`。
*   类型应符合`ObservableObject`协议。
*   我们需要将对象中的属性标记为`@Published`,以指示对正在使用该对象的视图的更改。
*   对象类型应该是类。
*   不需要默认值，因为它可以从环境中读取默认值。如果该对象在环境中不可用，应用程序将会崩溃。
*   还有另一个主要区别:假设我们有五个视图(V1…V5)。如果我们想将一个对象直接从 V1 传递到 V5，我们可以使用`@EnvironmentObject`而不是`@ObservedObject`。设置要在环境中从 V1 传递的数据，并在 V5 中检索它(或任何需要的地方)。代码会简单得多。
*   在环境中，一次只能有一个类型的实例。
*   纯粹是基于观点。如果父视图设置了环境对象，那么它的所有子视图都可以使用它。如果另一个父视图设置了另一个环境对象，其子视图可以使用它:

# @环境

*   我们可以用它来获得系统相关的值，比如应用程序是在亮模式还是暗模式下运行，core data 的托管对象上下文，大小类等。
*   我们需要提供正确的键来访问该值，因为它可以针对多个键保存相同的数据类型:

# **@绑定**

*   这用于维护视图之间的共享数据。
*   最好的例子是在视图 1 中显示一个工作表，在视图 2 中启动一个解除操作。
*   我们需要使用@Binding 声明一个属性。
*   不需要默认值，因为它会从另一个视图中设置它。

# **@手势状态**

*   这个类似于`@State`。
*   唯一的区别是手势一结束，默认值就会被设置。而在`@State`中，最后的设定值被保存。

# @已发布

*   这用于通知视图，每当对象中的属性更新时，就重新呈现其 body 属性。
*   我们需要在`ObservableObject`协议中使用这个。
*   如果一个类符合`ObservableObject`，我们可以将该类中的一个或所有属性标记为`@Published`。
*   每当 class' `@Published`属性中的数据发生变化时，SwiftUI 将向所有正在使用该对象的视图发出通知:

# **@FetchRequest**

*   我们可以用它从核心数据中提取数据，并直接在视图中使用它。没必要写什么多余的逻辑。
*   我们需要传递实体名称和排序描述符来从核心数据中获取数据。
*   我们也可以提供一个选项谓词。
*   这隐含地具有`@ObservedObject`的行为，因此每当对象改变时，视图将自动更新:

# 结论

SwiftUI 中有几个重要的属性包装器。所有这些都是为了使开发过程变得容易，减少错误。

感谢阅读。