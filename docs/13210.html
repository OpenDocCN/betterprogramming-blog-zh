<html>
<head>
<title>The History of DOM Manipulation Performance in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，DOM操纵性能的历史</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-history-of-dom-manipulation-performance-in-a-nutshell-701247c19e83?source=collection_archive---------3-----------------------#2022-08-08">https://betterprogramming.pub/the-history-of-dom-manipulation-performance-in-a-nutshell-701247c19e83?source=collection_archive---------3-----------------------#2022-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="903a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">直接更新DOM成本很高。我们如何知道我们今天所知道的？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d3a1afa4bcf3bfd4620e0e3556067c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SsTY55YyzMecL_CQLfz85A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e525" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那是1998年。我是一个十岁的孩子，对最近巴西在世界杯决赛中输给法国感到失望。法国人的大日子，尤其是足球迷。</p><p id="a3d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不那么重要，但肯定不那么受欢迎，几个月后，那年发生了另一件大事:DOM的首次发布！由<a class="ae lr" href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium" rel="noopener ugc nofollow" target="_blank"> WWW联盟</a>创建，它是一个跨平台和独立于语言的接口，提供对表示文档、HTML或XML的对象的定义和访问。</p><p id="4725" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有多好？拥有一个逻辑树来代表你的网页的每一部分！它开启了太多我无法提及的可能性。这对我们网络开发者来说是一场革命。</p><p id="b3eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">发现的时刻。探索的时刻。</p><p id="7435" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在真正的DOM发明之前，我们有一种叫做“DOM Level 0”或“Legacy DOM”的东西创建交互是可能的，但仅限于某些元素。</p><p id="7874" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一个规范中，DOM让我们能够访问完整的HTML/XML模型。2000年，2级出版。它介绍了<a class="ae lr" href="https://en.wikipedia.org/wiki/DOM_events" rel="noopener ugc nofollow" target="_blank">事件模型</a>。</p><p id="7a1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">开发人员不用花很长时间就可以发布库来简化DOM接口的使用。</p><h1 id="c819" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">值得纪念的图书馆</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/f82a471391efe3814284637bd243e937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c0pXlnjhLioXa-6K"/></div></div></figure><p id="deb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">访问和操作DOM并不是一件愉快的任务。创建一个大的功能是不必要的，最终会产生一个巨大的代码库。jQuery的出现使这种操作不那么冗长。</p><p id="cd47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，jQuery带来了更多的功能，如事件处理、CSS动画和Ajax。</p><p id="deb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是操纵DOM的代价是什么呢？我相信这不是你第一次听说直接操纵DOM不好。它花费很多。但是为什么呢？为什么简单的属性更改可能意味着性能问题？</p><p id="06a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实是，更新属性非常便宜和快速，但问题是更改本身会触发重新绘制和重新定位文档元素的流程(<a class="ae lr" href="https://developer.mozilla.org/pt-BR/docs/Web/Performance/Critical_rendering_path#paint" rel="noopener ugc nofollow" target="_blank"> repaint </a>和<a class="ae lr" href="https://developer.mozilla.org/pt-BR/docs/Glossary/Reflow" rel="noopener ugc nofollow" target="_blank"> reflow </a>)。这是通过复杂的内部算法来完成的。</p><p id="6ae9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个简单的改变可以对树中的所有其他对象产生巨大的级联效应。即使是一个小操作，比如将一个元素上的<code class="fe ml mm mn mo b">display: none;</code>改为<code class="fe ml mm mn mo b">display: inline;</code>，也会导致周围更多元素的回流，并导致大部分重新绘制。</p><p id="6b52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2010年左右，jQuery非常流行(现在仍在广泛使用)。尽管有一个问题jQuery没有解决:应用程序的复杂性使得前端数据成为一件需要认真处理的事情。数据越多，DOM树中的变化就越多。</p><p id="536f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个新的时代必须出现…</p><h1 id="c8f1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">框架时代</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/eaf827d2bdf89ef13b225fa5d142be57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UWzh75SmnoX5TO28"/></div></div></figure><p id="88a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的想法是抛弃网页这个术语，采用一种新的方法和思维方式:网络应用。不再有静态页面，不再有简单的交互和事件处理。世界宣称数据管理和spa。web应用程序需要一个状态，并且状态需要被管理。框架大爆发！</p><p id="b2a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">烬，流星，脊梁，淘汰赛，还有第一代最重要的:AngularJS。</p><p id="3efd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的职业，前端工程师，前所未有地出现了。这些框架的想法很简单:为构建应用程序提供完整(或部分)的工具和指南。前端应用程序世界引入了惊人的特性:依赖注入、双向数据绑定、动态模板、服务、工厂等。</p><p id="0330" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多发现的伟大时代。但随后一个问题出现了，并成为论坛和讨论组的共同话题:如何处理海量数据和管理复杂状态。双向数据绑定很容易变得一团糟，降低应用程序的性能。</p><p id="a289" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着应用程序变得越来越大，我们心爱的DOM没有得到很好的对待。以AngularJS为例，框架为每个控制器创建作用域。这些作用域模仿DOM结构，并提供观察器来观察变化。一旦发现变化，AngularJS就会触发消化循环。一个循环将新旧值进行比较，并在DOM中应用更新。</p><p id="a743" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从开发商的角度来看，这是令人兴奋和现代的。但是正如我前面提到的，DOM的不断变化会导致性能下降。</p><p id="db5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是安古拉杰的遭遇。范围可以有嵌套的范围。观察器可以触发其他观察器。消化周期可以在不需要它的情况下运行多次。如果我们将双向数据绑定添加到这个场景中，很容易想象很难找到大型应用程序的真实来源——如果这个应用程序不是真正组织良好的话。</p><p id="c990" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个时期，我开始了我的开发人员生涯。在学习了我的第一个框架(AngularJS)后，我非常兴奋，但过了一会儿，我又对性能问题感到沮丧。</p><p id="29d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，全世界的开发人员都明白性能是一个应该更加认真对待的话题。</p><h1 id="841e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">表演的时代</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/02ea1289a43cdc8ceee4b2397305c289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OPV5GDwd6v8KiP2F"/></div></div></figure><p id="42d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们现在生活的时刻。激动的一刻。性能是一个热门话题。现在的应用程序有大量的数据。他们需要复杂的用户界面，离线的可能性，多平台等。</p><p id="4be3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在求职面试中，应聘者会被问及许多问题:</p><ul class=""><li id="d8d5" class="ms mt iq kx b ky kz lb lc le mu li mv lm mw lq mx my mz na bi translated">虚拟DOM如何工作</li><li id="a4b3" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">Angular的变化检测如何工作</li><li id="6151" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">什么是细粒度的反应性</li><li id="c5d2" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">WebAssembly如何帮助提高性能</li><li id="0348" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">什么是阴影世界</li><li id="e857" class="ms mt iq kx b ky nb lb nc le nd li ne lm nf lq mx my mz na bi translated">什么是web组件</li></ul><p id="1bf3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理解这些主题变得更加困难。</p><p id="a8ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们明白，如果我们需要改变DOM，我们需要在不触发大规模回流的情况下精确地完成。复杂的算法和策略出现来解决这种情况。</p><h2 id="d919" class="ng lt iq bd lu nh ni dn ly nj nk dp mc le nl nm me li nn no mg lm np nq mi nr bi translated">虚拟DOM</h2><p id="98ff" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">这一切都始于2013年ReactJS发布的一个新模式的引入:虚拟DOM。数以百万计的开发者被这个令人惊叹的新图书馆所吸引。虚拟DOM背后的理念是什么？</p><p id="707b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">精准更新，批量更新。</p><p id="9fbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个想法是有一个DOM的副本，由一个JavaScript对象表示。这个对象的每个属性代表原始DOM中的一个节点。因此，每当一个状态改变或者一个新的属性被输入到一个组件中，React就会更新虚拟DOM。</p><p id="9054" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一种叫做调和的算法负责比较两个DOM。如果发现差异，受影响的节点将被更新，避免更新整个或更大的DOM。</p><p id="d0ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法使React成为一种趋势。</p><h2 id="3e2c" class="ng lt iq bd lu nh ni dn ly nj nk dp mc le nl nm me li nn no mg lm np nq mi nr bi translated">角度变化检测</h2><p id="8c93" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">Angular的做法有点不同。它覆盖本机事件处理程序，并为每个组件生成更改检测脚本。这些工厂具有一些表示组件绑定的依赖关系。</p><p id="46a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个工厂内部有一个名为<code class="fe ml mm mn mo b">updateRenderer</code>的函数，每次Angular执行变更检测时都会调用这个函数。该函数获取绑定属性的当前值，并调用一个函数根据检索到的值检查它们。这样，Angular为每个视图节点分别执行DOM更新。</p><h2 id="b231" class="ng lt iq bd lu nh ni dn ly nj nk dp mc le nl nm me li nn no mg lm np nq mi nr bi translated">细粒度反应性</h2><p id="d65c" class="pw-post-body-paragraph kv kw iq kx b ky ns jr la lb nt ju ld le nu lg lh li nv lk ll lm nw lo lp lq ij bi translated">该策略基于同步反应式编程的概念。想法是将模板编译成真实的DOM节点，并使用这种反应来更新这些节点。</p><p id="b4a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种反应性被SolidJS，MobX，和Svelte使用。<a class="ae lr" href="https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf" rel="noopener ugc nofollow" target="_blank">下面详细讲解一下。</a></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="4a88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们如何知道我们今天所知道的。随着应用程序的数据越来越大，复杂性越来越高，我们生活在一个对性能非常担忧的时代。</p><p id="dd72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我在这篇文章中提到的每一个时刻，都有可能创建一个单独的帖子或者写一本关于它的书。我打算向您展示一些主要的变化，这些变化使我们理解了我们今天对DOM和应用程序性能的了解。</p><p id="edd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">干杯。</p></div></div>    
</body>
</html>