<html>
<head>
<title>SwiftUI: Drag Gesture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:拖动手势</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-drag-gesture-2559cf255c5e?source=collection_archive---------1-----------------------#2020-03-27">https://betterprogramming.pub/swiftui-drag-gesture-2559cf255c5e?source=collection_archive---------1-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6aea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让您的用户在应用程序的屏幕上拖动项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62fe0b5e9f7a13d399e0c9e99bfe42b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsLXRyTTCHEqMiEy9ygbMg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@vidarnm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">维达尔·诺德里-马西森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pull?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b7d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"拖动手势:一种拖动动作，当拖动事件序列改变时，它调用一个动作."— <a class="ae ky" href="https://developer.apple.com/documentation/swiftui/draggesture" rel="noopener ugc nofollow" target="_blank">苹果文档</a></p><p id="a693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，您将了解SwiftUI中的拖动手势是什么。您将学习如何:</p><ul class=""><li id="8999" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">.onChanged</code></li><li id="330a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">.updating</code></li><li id="8536" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">.onEnded</code></li><li id="e38a" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">限制滚动</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="adb2" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">先决条件</h1><p id="4254" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">要跟随本教程，您需要:</p><ul class=""><li id="caaf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">基本熟悉Swift</li><li id="a4ea" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">至少具备Xcode 11的一些基础知识</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="38c4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">。onChanged</h1><p id="c008" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe me mf mg mh b">onChanged</code>改变您拖动的对象的位置值。这将移动物体。</p><p id="b20f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个可以存储大小的变量。使用下面的变量，对象现在被放置在x <em class="nr"> </em>和y<em class="nr"/>的坐标50处。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="1925" class="nw mv it mh b gy nx ny l nz oa">@State private var rectPosition = CGPoint(x: 50, y: 50)</span></pre><p id="1f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当矩形移动时，你将改变<code class="fe me mf mg mh b">rectPosition</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="17fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果，你有一个移动的矩形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5f864f0ebfbf81a81e7b3e8c3423214b.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*YBLKzbicPxtn1VJ1.gif"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="89f5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">。更新</h1><p id="e5dc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">通过读取状态可以知道用户是否在拖动。首先，创建保存一个值的<code class="fe me mf mg mh b">GestureState</code>。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="18db" class="nw mv it mh b gy nx ny l nz oa">@GestureState private var isDragging = false</span></pre><p id="7edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里你不能更新<code class="fe me mf mg mh b">isDragging</code>，因为它是只读的。但是您可以更新状态，然后状态会更新<code class="fe me mf mg mh b">isDragging</code>。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="2853" class="nw mv it mh b gy nx ny l nz oa">.gesture(DragGesture().onChanged({ value in<br/>    self.rectPosition = value.location<br/>}).updating($isDragging, body: { (value, state, trans) in<br/>    state = true<br/>}))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5ca665a813bdaa2089109696eb6a0a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*sUK8g5z-MdomCH_O.gif"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2f58" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">。统一的</h1><p id="abe2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">也许您只希望在用户拖动完对象后执行某些操作。首先，创建一个变量来知道用户是否已经结束拖动。</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="42f0" class="nw mv it mh b gy nx ny l nz oa">@State private var isEnded = false</span></pre><p id="bfa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果x小于120，您可以使用相同的代码并稍加调整来设置颜色。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="c421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c433cbab4316f6ab6fec0397deaaf100.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*vf1GRTFMDaaoMAwp.gif"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5944" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">限制水平滚动</h1><p id="b93d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在屏幕上拖动太多；我的应用不太支持这个功能。只是水平拖动呢？</p><pre class="kj kk kl km gt ns mh nt nu aw nv bi"><span id="6562" class="nw mv it mh b gy nx ny l nz oa">.gesture(DragGesture().onChanged({ value in<br/>    self.rectPosition = CGPoint(x: value.location.x, y: 50)<br/>}))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b76c73ae8404dde2a17d738d58e333d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*Hh0mnPwqs1ultiY9.gif"/></div></figure><p id="7b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只想让它垂直滚动，那么你可以只考虑改变y的值。</p></div></div>    
</body>
</html>