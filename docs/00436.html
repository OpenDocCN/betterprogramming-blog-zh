<html>
<head>
<title>Understanding Django QuerySets Evaluation and Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Django查询集评估和缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-django-database-querysets-and-its-optimizations-1765cb9c36e5?source=collection_archive---------1-----------------------#2019-05-21">https://betterprogramming.pub/understanding-django-database-querysets-and-its-optimizations-1765cb9c36e5?source=collection_archive---------1-----------------------#2019-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="020c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过示例深入探究QuerySet的评估和缓存</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dae2a845069ffd68d496a67513e9d054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1iypsouAGB6jABtPW-JyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cgower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯托弗·高尔</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="88e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.2/ref/models/querysets/#django.db.models.query.QuerySet" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">QuerySet</strong></a></code>代表数据库中的一组对象。它可以有零个、一个或多个<em class="lz">过滤器</em>。过滤器根据给定的参数缩小查询结果的范围。在SQL术语中，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.2/ref/models/querysets/#django.db.models.query.QuerySet" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">QuerySet</strong></a></code>相当于一个<code class="fe lv lw lx ly b"><strong class="lb iu">SELECT</strong></code>语句，过滤器是一个限制子句，如<code class="fe lv lw lx ly b"><strong class="lb iu">WHERE</strong></code>或<code class="fe lv lw lx ly b"><strong class="lb iu">LIMIT</strong></code>。</p><p id="40c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你通过使用你的模型的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.2/topics/db/managers/#django.db.models.Manager" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Manager</strong></a></code>得到一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.2/ref/models/querysets/#django.db.models.query.QuerySet" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">QuerySet</strong></a></code>。每个型号至少有一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.2/topics/db/managers/#django.db.models.Manager" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Manager</strong></a></code>，默认叫<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.djangoproject.com/en/3.2/ref/models/class/#django.db.models.Model.objects" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">objects</strong></a></code>。</p><p id="bbe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询集可以被构造、过滤、切片，并且通常在不实际访问数据库的情况下传递。在您对查询集进行评估之前，实际上不会发生任何数据库活动。</p><p id="583f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我们将参考以下模型:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="cbb5" class="me mf it ly b gy mg mh l mi mj">from django.db import models<br/><br/>class Blog(models.Model):<br/>    name = models.CharField(max_length=100)<br/>    tagline = models.TextField()<br/>    <br/>    def __str__(self):<br/>        return self.name<br/><br/>class Entry(models.Model):<br/>    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)<br/>    headline = models.CharField(max_length=255)<br/>    body_text = models.TextField(blank=True)<br/><br/>    class Meta:<br/>        default_related_name = 'entries'<br/><br/>    def __str__(self):<br/>        return self.headline</span></pre><p id="27e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的例子来理解懒惰:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="a9d2" class="me mf it ly b gy mg mh l mi mj">q1 = Entry.objects.filter(blog=2)<br/>q2 = q1.filter(headline__contains='food')<br/>entry_list = list(q3)</span></pre><p id="0a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这看起来像两次数据库命中，但实际上它只命中数据库一次，在最后一行(<code class="fe lv lw lx ly b">entry_list = list(q3)</code>)。</p><p id="d82c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次细化一个查询集，都会得到一个独立且不同的查询集，它不绑定到前一个查询集，可以存储、使用和重用。</p><p id="f88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码中，<code class="fe lv lw lx ly b">q</code>和<code class="fe lv lw lx ly b">q2</code>执行相同的数据库操作。注意，<code class="fe lv lw lx ly b">q, q1, q2</code>是三个不同的查询集。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="2f5f" class="me mf it ly b gy mg mh l mi mj">q =Entry.objects.filter(blog=2).exclude(body_text__icontains="food")<br/><br/>q1 = Entry.objects.filter(blog=2)<br/>q2 = q1.exclude(body_text__icontains="food")</span></pre><p id="f082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来谈谈<code class="fe lv lw lx ly b">evaluation</code>和<code class="fe lv lw lx ly b">caching</code>。</p><p id="cdd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Evaluation</code>表示实际命中数据库。当您开始迭代一个QuerySet时，QuerySet匹配的所有行都从数据库中取出，并转换成Django模型。这叫<code class="fe lv lw lx ly b">evaluation</code>。然后，这些模型被QuerySet的内置缓存存储，这样，如果您再次遍历QuerySet，就不需要再次访问数据库。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="39aa" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">启用缓存</h1><p id="c290" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">要在QuerySet中启用缓存，只需将QuerySet保存在一个变量中并重用它。Django QuerySet类有一个<code class="fe lv lw lx ly b">_result_cache</code>变量，它将查询结果(Django模型)保存在<code class="fe lv lw lx ly b">list</code>中。<code class="fe lv lw lx ly b">_result_cache</code>是<code class="fe lv lw lx ly b">None</code>如果QuerySet没有任何缓存(还没有求值)，否则是模型对象列表。当您迭代一个缓存的QuerySet时，您基本上是在迭代一个<code class="fe lv lw lx ly b">_result_cache</code>，它是一个列表。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="498c" class="me mf it ly b gy mg mh l mi mj"># The following will create two QuerySet's, evaluate them, and throws them away, because they are not saving the queryset anywhere to reuse them later.<br/>print([e.headline for e in Entry.objects.all()])<br/>print([e.pub_date for e in Entry.objects.all()])<br/><br/># Following code saves QuerySet in a variable. When it evaluates, <br/># it saves the results to its cache(_result_cache). <br/>queryset = Entry.objects.all()<br/># evaluation with iteration.<br/>for each in queryset:<br/>    print(each.headline)<br/>    <br/># Using cache from previous evaluation.<br/>for each in queryset:<br/>    print(each.id)</span></pre><p id="4ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代并不是评估的唯一方式，在评估发生时还有很多其他方式，让我们用例子来讨论一下。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b3ec" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">循环</h1><p id="f4a4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">QuerySet对象是可迭代的，在开始迭代第一行之前，数据库命中，结果保存在缓存中。在以下示例中，数据库点击和缓存发生在打印第一个标题之前:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="e99f" class="me mf it ly b gy mg mh l mi mj">queryset = Entry.objects.all()    <br/># Evaluated and cached<br/>for each in queryset:<br/>    print(each.headline)<br/><br/># Using cache from previous evaluation.<br/>for each in queryset:<br/>    print(each.headline)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d157" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">切片</strong></h1><p id="e84e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对未计算的QuerySet进行切片会返回一个新的QuerySet。返回的QuerySet不允许进一步修改(例如，添加更多过滤器，或修改排序)，但它允许更多切片。如果对Queryset进行迭代，query set(切片或非切片)会将结果保存到其缓存中:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="bb97" class="me mf it ly b gy mg mh l mi mj"># You can't use filter to queryset anymore.<br/>queryset = Entry.objects.all()[10:100]<br/># You can use filter to q1 but not to q2, q3.<br/>q1 = Entry.objects.all()<br/>q2 = q1[1:10]<br/>q3 = q2[1:5]<br/><br/># saves results to cache of q1<br/>lst1 = [each.blog.id for each in q1]<br/># saves results to cache of q2<br/>lst2 = [each.blog.id for each in q2]</span></pre><p id="3a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对已经计算过的Queryset进行切片，它将返回对象列表，而不是QuerySet对象，因为在计算之后，当您再次迭代时，QuerySet将使用其缓存的(<code class="fe lv lw lx ly b">_result_cache</code>)值，这是一个列表。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="ad68" class="me mf it ly b gy mg mh l mi mj">queryset = Entry.objects.all()<br/>lst = list(queryset)<br/># returns a list of entry objects<br/>first_ten = queryset[:10]<br/># list slicing not queryset slicing because first_ten is a list.<br/>first_five = first_ten[:5]</span></pre><p id="ec92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用index从未评估的查询集中选取一个元素，它会导致数据库命中，但是如果您从已经评估的查询集中选取，它会使用缓存。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="492d" class="me mf it ly b gy mg mh l mi mj">queryset = Entry.objects.all()<br/># Queries the database because queryset hasn't been evaluated yet.<br/>print(queryset[5])</span><span id="a84d" class="me mf it ly b gy nn mh l mi mj">lst = list(queryset)<br/># Using cache because evaluation happened in previous list() operation.<br/>print(queryset[5])<br/>print(queryset[10])</span></pre><p id="3398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例外是，如果您对未计算的QuerySet使用Python slice语法的<code class="fe lv lw lx ly b">step</code>参数。在这种情况下，它立即执行查询并返回模型对象的<code class="fe lv lw lx ly b">list</code>,而不是QuerySet对象。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="d6ed" class="me mf it ly b gy mg mh l mi mj">entry_list = Entry.objects.all()[1:100:2]</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="044a" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">酸洗/缓存</strong></h1><p id="fc61" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果您pickle一个QuerySet，它将被求值。如果您将QuerySet保存在缓存中，它将被求值，下次您使用它时，它将从缓存中为您提供模型对象列表。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7790" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak"> repr() </strong></h1><p id="0adc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">方法返回给定对象的一个可打印的表示字符串。当您对QuerySet调用<code class="fe lv lw lx ly b">repr()</code>时，会对它进行计算，但它不会将结果保存到缓存中。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="7995" class="me mf it ly b gy mg mh l mi mj"># repr() evaluates but does not saves results to cache.<br/>queryset = Entry.objects.all()<br/>str_repr = repr(queryset)<br/># Not using cache.Hitting database again.<br/>for each in queryset:<br/>    print(each.headline)</span></pre><p id="0214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<code class="fe lv lw lx ly b">print()</code>函数也计算QuerySet，但不将结果保存到缓存中。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="08ad" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak"> len() </strong></h1><p id="2bd6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当您调用<code class="fe lv lw lx ly b">len()</code>时，会对QuerySet进行评估，并将评估结果保存到缓存中。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="0d63" class="me mf it ly b gy mg mh l mi mj"># len() evaluates and saves results to cache.<br/>queryset = Entry.objects.all()<br/>ln = len(queryset)<br/># Using cache from previous evaluation.<br/>for each in queryset:<br/>    print(each.headline)</span></pre><p id="fdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果您只需要知道QuerySet中的项数，请不要使用这个选项。Django为此提供了一个<code class="fe lv lw lx ly b">count()</code>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="51bd" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">列表()</strong></h1><p id="b8ea" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">通过对QuerySet调用<code class="fe lv lw lx ly b">list()</code>来强制对其进行评估，这会返回模型对象列表并将结果保存在缓存中。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="19a6" class="me mf it ly b gy mg mh l mi mj"># Evaluates the queryset and saves results in cache.<br/>queryset = Entry.objects.all()<br/>lst = list(queryset)<br/># Using cache from previous list() evaluation.<br/>for each in queryset:<br/>    print(each.headline)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e2eb" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak"> If语句</strong></h1><p id="6d76" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">if语句将导致执行查询并将结果保存在缓存中。如果至少有一个结果，QuerySet为<code class="fe lv lw lx ly b">True</code>，否则为<code class="fe lv lw lx ly b">False</code>。例如:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="b463" class="me mf it ly b gy mg mh l mi mj"># The `if` statement evaluates the queryset and saves results in cache.<br/>queryset = Entry.objects.all()<br/>if queryset:     <br/>    # Using cache from previous if statement evaluation.     <br/>    for each in queryset:         <br/>        print(each.headline)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="06fc" class="mr mf it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">相关的模型属性不会被缓存</h1><p id="ca56" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当Django计算QuerySet时，向前或向后关系字段不包括在查询中，因此也不包括在缓存中，除非您使用<code class="fe lv lw lx ly b">select_related</code>或<code class="fe lv lw lx ly b">prefetch_related</code>。检查<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/django-select-related-and-prefetch-related-f23043fd635d">这个</a>。</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="4872" class="me mf it ly b gy mg mh l mi mj">queryset = Entry.objects.all()<br/>    for each in queryset:<br/>        print(each.headline)<br/>        # Hits database for blog.<br/>        print(each.blog.name)<br/><br/>    for each in queryset:<br/>        # uses cache<br/>        print(each.headline)<br/>        # No cache, hits database again for blog.<br/>        print(each.blog.name)<br/><br/>    # Use select_related or prefetch_related to cache related objects<br/>    queryset = Entry.objects.select_related('blog')<br/>    for each in queryset:<br/>        print(each.headline)<br/>        print(each.blog.name)<br/><br/>    for each in queryset:<br/>        # uses cache<br/>        print(each.headline)<br/>        # uses cache<br/>        print(each.blog.name)</span></pre></div></div>    
</body>
</html>