<html>
<head>
<title>Reactive Programming in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振中的反应规划</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reactive-programming-in-flutter-9fd7b0a4835f?source=collection_archive---------6-----------------------#2020-12-08">https://betterprogramming.pub/reactive-programming-in-flutter-9fd7b0a4835f?source=collection_archive---------6-----------------------#2020-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e47d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">发现颤动——第15周</h2><div class=""/><div class=""><h2 id="fc47" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">流的简要介绍</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/38c23462baed1fe7826f8fc9d0961c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URW4L9nO_f2UinKEwXifSA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">克里斯汀娜·戈塔迪在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="14b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">反应式编程是用异步数据流编程。数据流是一个随时间发出多条数据的对象。在Dart中，这种数据被称为<em class="me">流</em>。</p><p id="cc1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">流随时间发出数据。通过订阅流，我们可以听到所有发生的变化，只要我们订阅了它，我们就会在每次有新的数据添加到流中时收到通知。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="8533" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">两种等待方式——未来与流</h1><ul class=""><li id="09bd" class="ne nf it lk b ll ng lo nh lr ni lv nj lz nk md nl nm nn no bi translated">随着时间的推移，未来只能提供一个<code class="fe np nq nr ns b">single</code>结果——或者是一个<code class="fe np nq nr ns b">error</code>或者是一个<code class="fe np nq nr ns b">data</code>,它是异步交付的。</li><li id="afcd" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated">另一方面，流可以随着时间的推移提供<code class="fe np nq nr ns b">zero</code>或<code class="fe np nq nr ns b">more</code>或<code class="fe np nq nr ns b">values</code>或<code class="fe np nq nr ns b">error</code>结果。他们可以在不同的时间段推送多条数据。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b9b7df30f389d737b20a65de33ec4883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*vxtBcgsw2TTNPxxmgmsTXg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">未来与潮流</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="1fe6" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">简单看一下流</h1><ul class=""><li id="8cd8" class="ne nf it lk b ll ng lo nh lr ni lv nj lz nk md nl nm nn no bi translated">单一订阅——关于流的重要的一点是，它们在默认情况下是为单一订阅设置的。这意味着他们一生只允许一个听众。如果你试图监听一个流两次，你会得到一个异常。</li><li id="dc66" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated">广播流——如果需要多个侦听器，可以使用<code class="fe np nq nr ns b">asBroadcastStream</code>方法从单个订阅中生成一个广播流。</li><li id="5c32" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated">产生错误——如上所述，流会产生错误。使用<code class="fe np nq nr ns b">onError</code>方法并捕捉和处理其中的错误是一个好方法。如果您想在发生错误后继续订阅，您可以将属性<code class="fe np nq nr ns b">cancelOnError</code>设置为<code class="fe np nq nr ns b">false</code>。</li><li id="43b3" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated"><code class="fe np nq nr ns b">onDone</code>方法—使用此方法在流发送完数据后执行代码。</li><li id="8026" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated"><code class="fe np nq nr ns b">subscription</code>对象——有三种方法:<code class="fe np nq nr ns b">pause()</code>、<code class="fe np nq nr ns b">resume()</code>和<code class="fe np nq nr ns b">cancel()</code>。使用这些方法来操作数据流。</li><li id="8a64" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated">数据操作简单——您可以使用各种方法以优雅的方式操作流中的数据，如<code class="fe np nq nr ns b">map()</code>、<code class="fe np nq nr ns b">where()</code>、<code class="fe np nq nr ns b">distinct()</code>等。</li><li id="9cd1" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated"><code class="fe np nq nr ns b">Stream controller</code> —用于创建新流的控制器。</li><li id="245d" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated"><code class="fe np nq nr ns b">Stream builder</code> —使用此构建器从流数据构建小部件。你需要提供一个<code class="fe np nq nr ns b">stream</code>和一个<code class="fe np nq nr ns b">builder</code>方法。每当流发出新值时，它将重新生成其子级。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="7687" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">结论</h1><p id="11f0" class="pw-post-body-paragraph li lj it lk b ll ng kd ln lo nh kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">如果你是涵盖各种Flutter主题的简短有趣文章的粉丝，并且你想养成在接下来的14周内和我一起学习Flutter的习惯，你可以每周二阅读我的文章。</p><p id="c257" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你对这篇文章有任何问题或评论，请在评论区告诉我。</p><p id="1e2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于那些想加入我们的颤振之旅的人，可以在下面找到前几周的链接:</p><ul class=""><li id="f0e4" class="ne nf it lk b ll lm lo lp lr oc lv od lz oe md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/better-programming/customize-default-splash-screen-in-flutter-4f0a3d872377" rel="noopener">第11周</a>——“自定义Flutter中的默认启动画面”</li><li id="f5f3" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/better-programming/arrange-buttons-in-a-row-with-togglebuttons-flutter-widget-3e28b1ad51bb" rel="noopener">第12周</a>——“用ToggleButtons小工具将按钮排成一行”</li><li id="a294" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/better-programming/stateful-widget-lifecycle-a01c44dc89b0" rel="noopener">第13周</a>——“有状态小部件生命周期”</li><li id="28e3" class="ne nf it lk b ll nt lo nu lr nv lv nw lz nx md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/better-programming/my-december-recommendations-for-flutter-packages-d463cbb257cf" rel="noopener">第14周</a>——“我12月份对颤振套件的建议”</li></ul><p id="46f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下周见。不要打破记录！</p></div></div>    
</body>
</html>