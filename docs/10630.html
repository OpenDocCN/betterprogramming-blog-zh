<html>
<head>
<title>Going Modular — The Kotlin Multiplatform Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走向模块化——kot Lin多平台方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/going-modular-the-kotlin-multiplatform-way-132c3dee6c95?source=collection_archive---------7-----------------------#2022-01-19">https://betterprogramming.pub/going-modular-the-kotlin-multiplatform-way-132c3dee6c95?source=collection_archive---------7-----------------------#2022-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8151" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">设置模块化代码库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cb29f74fb0e80d56e7363fb03e9a00a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NExDJVvg0K4-Pifg.jpeg"/></div></div></figure><p id="d402" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最近决定深入Kotlin多平台世界。到目前为止，一切顺利。这篇文章的目的是谈论我的旅程模块产生一个我一直在做的项目。</p><p id="9d5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我肯定还有其他的方法，但这是对我有效的方法。</p><h1 id="c9d1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">电视狂人</h1><p id="4ea3" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我正在使用<a class="ae mk" href="https://developers.themoviedb.org/3" rel="noopener ugc nofollow" target="_blank"> TMDB </a>获取电视节目信息。这是它在两个平台上的样子。我在Android上做了很多工作，因为那是我的领域。随着我的学习，我正在更新iOS方面的内容。你可以在<a class="ae mk" href="https://github.com/c0de-wizard/tv-maniac" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到该项目的源代码。</p><div class="ml mm gp gr mn mo"><a href="https://github.com/c0de-wizard/tv-maniac" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">GitHub-c0de-wizard/Tv-Maniac:Tv-Maniac是一个用于观看电视的多平台应用程序(Android &amp; iOS)…</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">TvManiac是一个多平台应用程序(Android和iOS ),用于查看来自TMDB的电视节目信息。这个项目的目的是…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc kp mo"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/9bbec34fca2ff446b43fad26f83cb248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oP1Yfe_hxENFrbdC5Zxtvw.png"/></div></div></figure><h1 id="2112" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">共享模块</h1><p id="0e52" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在讨论模块化之前，让我分享一下为什么我决定这样做。共享模块包含两个平台的通用逻辑。(iOS &amp; Android)。</p><p id="596f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">准确地说，我们共享网络和缓存代码。在文章的最后有几篇很棒的介绍文章。下面是最初看到的共享模块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/da4759621a88ad9a81d834b082c26dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*nlQDDg9wkQuNb46aC3TMxA.png"/></div></figure><p id="98ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么为什么要模块化共享模块呢？</p><p id="65fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，我最初是用包来构造代码的。它工作了，但是在包中导航是一件痛苦的事情。既然我计划更新这个项目，为什么不把事情做对。伙计们，这就是我们在这里的原因。</p><p id="5d21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一件事，每当我对共享模块中的一个类进行更改时，整个模块都要重新构建。</p><h1 id="5c24" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">走向模块化</h1><p id="e918" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">下图显示了经过几次试验后共享模块的样子。但是，首先，让我们看一下项目结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1560ef504f7127d1aa2eb4f2393aad2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*_th3YyqZZX_it6Bj.png"/></div></figure><h1 id="130a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">项目结构</h1><p id="f5b5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们有几个模块，但是我们可以把它们分成四个主要的目录/模块。</p><ul class=""><li id="cced" class="ng nh iq kt b ku kv kx ky la ni le nj li nk lm nl nm nn no bi translated"><code class="fe np nq nr ns b">core</code>:包含所有模块使用的所有“公共”类。这些可以是实用类，如抽象类的协同作用域/调度程序。</li><li id="888b" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><code class="fe np nq nr ns b">remote</code>:带<a class="ae mk" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank"> Ktor </a>实现的模块</li><li id="de29" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><code class="fe np nq nr ns b">database</code> : DB实现。我们在这个项目中使用了<a class="ae mk" href="https://cashapp.github.io/sqldelight/" rel="noopener ugc nofollow" target="_blank"> SQLDelight </a>。</li><li id="781a" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><code class="fe np nq nr ns b">domain</code>(特性):领域模块更像特性模块。它们与应用程序中的功能完美匹配。他们有两个模块:</li><li id="eb7f" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><code class="fe np nq nr ns b">api</code>:它们包含接口。我们也导出这些模块，所以iOS有权限。</li><li id="1c41" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><code class="fe np nq nr ns b">implementation</code>:顾名思义，这个模块包含了API模块的实现细节。</li></ul><p id="b719" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我省略了<strong class="kt ir">交互器</strong>模块。我暂时称之为边缘模块。这包含没有域逻辑或者不一定是特性的交互类。随着我们继续添加功能，这将会发生变化并进入领域模块。</p><h1 id="4965" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Kmm预编译脚本</h1><p id="2fcd" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">由于大多数模块的<code class="fe np nq nr ns b"><strong class="kt ir"><em class="ny">build.gradle</em></strong></code>文件是相同的，我们可以使用一个预编译脚本来节省大量重复。我们在<code class="fe np nq nr ns b"><strong class="kt ir">buildSrc</strong></code>目录中创建一个文件<code class="fe np nq nr ns b"><strong class="kt ir"><em class="ny">kmm-domain-plugin.gradle.kts</em></strong></code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/f4b4c9264d514ac344219da4ae1be1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPtqJUe0UBtcAoepfFG49A.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">kmm预编译脚本</p></figure><p id="3295" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以将插件添加到模块中，去掉大量代码。现在，我们需要应用脚本并添加模块依赖项。如你所见，这样做的一个好处是拥有精益模块，不需要不必要的依赖。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/83a4b048649f949dc02a55f8720d4447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCm_h-y99tYEU9pwt-qjMQ.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">API build.gradle.kts</p></figure><h1 id="37cf" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">暴露对iOS的依赖</h1><p id="d36b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在我们有了自己的模块，我们需要将它们添加到共享模块中，因为这是iOS的入口点。通过将模块添加到commonMain，Kmm将生成一个<code class="fe np nq nr ns b">Obj-C Framework</code>。</p><p id="1fca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了公开依赖关系，我们做两件事</p><ol class=""><li id="be5f" class="ng nh iq kt b ku kv kx ky la ni le nj li nk lm of nm nn no bi translated">将模块作为API添加到<code class="fe np nq nr ns b">commonMain</code>源集中</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/29ae03782e9b4e095ff388a719235444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhvO_IDDDvQJvgQQLTq38A.png"/></div></div></figure><p id="90a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.导出框架配置中的模块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/d71e307fdd376a8a38e91f3104983e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeoaEUtmbSRTYxY9JtfZ_Q.png"/></div></div></figure><p id="d5e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您会注意到，我们只是将API模块添加到框架配置中。这是因为我们只需要公开接口。</p><p id="492a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一件事，我们可以结束了。让我们看看依赖注入。</p><h1 id="dbf9" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">依赖注入</h1><p id="6d8e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我正在使用我想称为混合注入的方法，其中Android使用<a class="ae mk" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank">匕首柄</a>，共享模块使用<a class="ae mk" href="https://insert-koin.io/" rel="noopener ugc nofollow" target="_blank"> Koin </a>来初始化图形。我在shared中使用Koin，这样我们可以为iOS提供依赖关系。因此，我们将只看如何在共享模块中设置它。</p><p id="9519" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数模块都有一个包含模块依赖的<code class="fe np nq nr ns b"><strong class="kt ir">di</strong></code>包。举个例子，这就是流派的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/6fa568ce8d6a193122807a293e9e3d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RfSAFYUi12sTxIREqWhLw.png"/></div></div></figure><p id="6a5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以将它们添加到共享模块<code class="fe np nq nr ns b">koin</code>类的主依赖图中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/b5d4eadacf79d6fe0628aa82eba1e6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VkdQc009KYdqXGkYVVD1w.png"/></div></div></figure><p id="f267" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要在<code class="fe np nq nr ns b">iosMain</code>目录中添加一个类。这是一个调用主init函数的空函数。这样做将允许我们初始化图形。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/fd6e6c13951c8b594f6faf3e702dfd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLWFOxMmLDs6I784HdvnGA.png"/></div></div></figure><p id="3304" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我可能没有提到我正在创建一个Swift包并将其添加到iOS应用程序中。John O'Reilly有一篇关于如何着手的精彩文章。在这里阅读更多<a class="ae mk" href="https://johnoreilly.dev/posts/kotlinmultiplatform-swift-package/" rel="noopener ugc nofollow" target="_blank"/>。(如果你想迷失在KMM的宇宙中，就跟着他。他确实涵盖了很多话题，并分享了宝贵的资源。)</p><h1 id="7d42" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">摘要</h1><p id="deb6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我希望这在我向您介绍我如何应对这一挑战时有用。我知道我没有深究事情。主要是因为我相信还有其他方法。可能更好/更直接的方式。如果你有什么见解，请随时联系。学习是一个永无止境的循环，我准备好了。</p><p id="2318" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我喜欢Kotlin多平台的原因是:</p><ul class=""><li id="3326" class="ng nh iq kt b ku kv kx ky la ni le nj li nk lm nl nm nn no bi translated">大部分核心业务逻辑是共享的。这让我可以抽出一些时间，潜入苹果的世界。</li><li id="4ea6" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated">UI开发是本机的。因此，我仍然可以跟上Android上发生的事情，同时学习一点Swift。</li></ul><p id="cf36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直到我们再次相遇。再见。</p><h1 id="5557" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">资源</h1><ul class=""><li id="047e" class="ng nh iq kt b ku mf kx mg la ok le ol li om lm nl nm nn no bi translated"><a class="ae mk" href="https://kotlinlang.org/docs/kmm-understand-project-structure.html" rel="noopener ugc nofollow" target="_blank">了解KMM项目结构。</a></li><li id="9ffc" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><a class="ae mk" href="https://youtu.be/hrRqX7NYg3Q" rel="noopener ugc nofollow" target="_blank">生产中的Kotlin多平台——Kevin Galligan</a></li><li id="7c78" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><a class="ae mk" href="https://johnoreilly.dev/posts/kotlinmultiplatform-swift-package/" rel="noopener ugc nofollow" target="_blank">在Kotlin多平台项目中使用Swift软件包— John O'Reilly </a></li><li id="a25f" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><a class="ae mk" href="https://github.com/touchlab/KaMPKit" rel="noopener ugc nofollow" target="_blank"> Touchlab — KaMPKit </a></li><li id="9422" class="ng nh iq kt b ku nt kx nu la nv le nw li nx lm nl nm nn no bi translated"><a class="ae mk" href="https://touchlab.co/multiple-kotlin-frameworks-in-application/" rel="noopener ugc nofollow" target="_blank">应用中的多个Kotlin框架——Kevin Schildhorn</a></li></ul></div></div>    
</body>
</html>