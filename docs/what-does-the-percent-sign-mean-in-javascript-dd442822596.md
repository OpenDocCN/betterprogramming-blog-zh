# JavaScript 中的百分号是什么意思？

> 原文：<https://betterprogramming.pub/what-does-the-percent-sign-mean-in-javascript-dd442822596>

## 看看模运算符和余数运算符之间的区别

![](img/e7c8c7b2a5e1260413be3b1f0c25efb5.png)

卡斯帕·卡米尔·鲁宾在 [Unsplash](https://unsplash.com/s/photos/javascript?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

JavaScript 有很多操作符。其中一个就是百分号:`%`。它在 JavaScript 中有一个特殊的含义:它是**余数运算符**。它获取两个数之间的余数。

这不同于像 Java 这样的语言，在 Java 中`%`是**模操作符**。

在这篇文章中，我们将看看模运算符和余数运算符之间的区别。

# 模算子

模运算符的工作方式类似于数学中的`mod`运算符。这是模运算的一个基本组成部分，它像时钟一样工作。当数字大于给定值时，它会绕回小于给定值的值。

例如，一个时钟有 12 个小时。在数学中，我们用写`x mod 12`来表示，其中`x`是一个整数。例如，如果`x`是 20，那么`20 mod 12`就是 8，因为我们减去 12，直到它在 0 和 11 之间。

另一个例子是负数代表`x`。如果`x`是-1，那么`-1 mod 12`就是 11，因为我们给它加了 12，使它在 0 和 11 之间。

`12 mod 12`是 0，因为我们从中减去 12，直到它在相同的范围内。

`mod`后的操作数可以是正数，也可以是负数。

如果右边的操作数是负的，那么它的范围必须是从负数加 1 到 0。

比如我们有`1 mod -3`。然后我们从中减去 3 得到`-2`。

要查看模运算的更多属性，请查看维基百科上关于模运算的文章[和关于模运算符的文章](https://en.wikipedia.org/wiki/Modular_arithmetic)和[。](https://en.wikipedia.org/wiki/Modulo_operation)

JavaScript 百分号不做模运算。它用于计算第一个操作数除以第二个操作数的余数。

# 余数运算符

这就是 JavaScript 的百分号的真正含义。例如，如果我们写:

```
10 % 2
```

我们得到 0，因为 10 能被 2 整除。

如果第一个操作数不能被第二个操作数整除，那么我们得到一个非零余数。例如，如果我们有:

```
10 % 3
```

那么我们得到 1，因为 10 除以 3 的余数是 1。

因为百分号是一个余数运算符，所以它也适用于任何一个数字为负数的情况。例如，如果我们有:

```
10 % -3
```

那么我们得到 1，因为商是-3，余数是 1。

另一方面，如果我们写:

```
-10 % 3
```

那么我们得到-1，因为商是-3，余数是-1。

# 用于进行模运算的按位运算符

我们可以使用`>>>`操作符，它是零左移操作符，来计算模 2 的 32 次方。

零左移运算符通过将零从左边推进来右移，最右边的一个移出移位。

例如，如果我们写:

```
2**32 >>> 32
```

然后我们得到 0，因为我们从左边压入了 32 个 0，这样就把所有的 1 都压出了。

写`2**32 >>> 0`和写`2**32 >>> 32`一样。

如果我们写`2**32 + 1 >>> 32`，那么我们得到 1，因为我们用值 1 添加了左边的第 33 位，然后我们从左边推入 32 个 0，只留下 1 位。

![](img/1b29da12fcf36f52abf01eebeba33832.png)

[俄罗斯艺术](https://unsplash.com/@slvrnight?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 使用类型化数组进行模运算

我们还可以使用类似于`Uint8Array`、`Uint16Array`和`Uint32Array`的类型化数组进行模运算，因为每个条目只能分别是`0`到`2**8–1`、`0`到`2**16–1`或 0 到`2**32–1`。名称第一个字符中的`U`表示未签名。

在下面的每个例子中，我们创建一个有一个条目的类型化数组，然后我们给它分配不同的值来分别计算`x mod 2**8`、`x mod 2**16`和`x mod 2**32`。

例如，如果我们写:

```
const arr1 = new Uint8Array(1);
arr1[0] = 2**8;
console.log(arr1[0]);
arr1[0] = 2**8 + 1;
console.log(arr1[0]);
```

然后我们得到第一个`console.log`给我们 0，第二个`console.log`给我们 1，因为条目被包装在 0 和`2**8 - 1`之间。

同样，我们可以对其他类型的数组做同样的事情，如下所示:

```
const arr1 = new Uint16Array(1);
arr1[0] = 2**16;
console.log(arr1[0]);
arr1[0] = 2**16 + 1;
console.log(arr1[0]);
```

并且:

```
const arr1 = new Uint32Array(1);
arr1[0] = 2**32;
console.log(arr1[0]);
arr1[0] = 2**32 + 1;
console.log(arr1[0]);
```

然后我们得到与第一个例子相同的结果。

# 用 JavaScript 写一个模函数

如果我们真的想用 JavaScript 做模运算，我们必须写自己的模函数。

一个例子是:

```
const mod = (a, b) => ((a % b) + b) % b
```

通过将`a % b`加到`b`上，如果`b`为负，则将`a % b`的结果包装在 0 和`b — 1`或`b+1`和`0`内。`a % b`总是小于`a`，因为它是余数，但是如果`b`为负，它可能不在 0 和`b — 1`或`b+1`和`0`和`0`的范围内，所以我们给它加上`b`。

如果我们写:

```
console.log(mod(1, 12));
console.log(mod(13, 12));
console.log(mod(13, -12));
```

那么我们应该得到:

```
1
1
-11
```

这是我们所期望的。

在 JavaScript 中，百分号是余数运算符。当我们用左操作数除以右操作数时，它会得到这个数的余数。要用 JavaScript 进行真正的模运算，我们必须编写自己的函数来完成，或者我们可以使用类型化数组来完成，因为它将值包装在给定的范围内。