# 想在代码中编写可维护的测试吗？使用声明式测试

> 原文：<https://betterprogramming.pub/declarative-test-setup-fce1c17d93c6>

## 使用声明式测试设置使测试更容易阅读、维护和编写

![](img/07c5d2f8fa3a717fa5b8a10766c09ef5.png)

照片由[福蒂斯·福托普洛斯](https://unsplash.com/@ffstop?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

我发现编写弹性测试的一个方法是专注于使数据设置具有声明性。

声明式安装代码有很多好处，包括减少代码重复。

然而，对我来说，最大的改进是使我们的设置(以及测试)更容易阅读、维护和编写。

# 什么是声明式安装？

那么，在您的测试设置中“声明性”意味着什么呢？我们的目标是让我们的设置代码关注系统的“最终状态”，而不是一系列的步骤。

为了帮助澄清，让我们首先看一个**而不是**声明性的例子。

想象一个测试，我们需要将基本的领域数据“播种”到数据库中。

**命令式**测试设置示例

这将创建一篇文章，然后使用文章的 ID 添加一些相关的标签和评论。代码是一个逐步实现最终结果的过程。

我们需要逐行阅读以完全理解/内化代码的目标。理想情况下，我们应该描述*需要什么数据*，并允许另一段代码来处理细节。

那么我们如何将这段代码变成声明性的呢？我们通过创建一个新的助手函数将*如何*与*什么*分开。

该函数将接受一个对象，该对象描述了所需的数据。

**声明性**测试设置的示例

`setupPost`函数仍然可以有与第一个例子相同(或相似)的代码，但是细节现在对测试本身是隐藏的。

请注意，这个版本仍然包含与第一个过程示例相同的数据，但是将它组织成一个描述性对象。花点时间比较这两个例子，体会其中的区别——这是微妙的！

这可能有助于[干燥](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)代码，但是我认为还有更重要的好处，乍看起来并不明显。

# 更容易阅读

声明式设置通常更容易浏览，因为您阅读的不是一步一步的过程，而是对最终结果的描述。

在上面的例子中，声明性版本非常明显地表明我们正在创建一个带有相关标签和评论的帖子。

相比之下，在程序性版本中，我们需要阅读每一行，并决定它们如何相互关联。

# 更易于维护

如果一个“帖子”是你的领域中的一个中心数据，那么你可能会在很多测试中创建帖子。我们的声明版本将实际的实现封装在一个地方。

如果创建一个帖子有变化(即使是很小的变化),细节现在对我们的测试是隐藏的。在过程版本中，这可能会“泄露”到许多测试中，并导致雪球的一个小变化。

# 更容易创作

另一个隐藏的好处是，我们对一篇文章的描述非常容易编写，因为它只是数据。

例如，如果我们想将帖子包含到一个更大的设置功能中，现在就很明显了。这里有一个在函数中嵌入帖子*的例子。*

编写声明性设置的示例

这个`setupUser`函数比我们单独的`setupPost`函数能够创建*更多的*数据，但是我们已经实现了它的大部分！

这是因为我们能够重复使用`setupPost`功能。它已经处理了那个精确的形状，所以它应该像`posts.map(setupPost);`一样简单来创建整个 posts 数组！

最好的部分是你可以继续编写这些数据。我们的新`user`形状可以单独使用，但也可以包含在其他形状中，例如一个组织。

随着您编写更多的测试，您将开始构建一个良好的类型和相关助手库。通过将*什么*和*如何*分开，您将有助于确保您可以继续轻松地将您的助手组合在一起。

# 试试吧！

我认为这种实践是我们很多人在“正常”代码中做的事情，但是它经常在测试混乱中丢失。

下一次你需要引导一些数据——可能是数据库、状态管理器、模拟后端等。—尝试关注声明性函数。

我认为这将有助于使你的测试更容易阅读、维护和编写！