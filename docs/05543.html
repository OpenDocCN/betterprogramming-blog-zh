<html>
<head>
<title>6 Things to Know to Master Python Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Python闭包需要知道的6件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-things-to-know-to-master-python-closures-1586ca5165c6?source=collection_archive---------4-----------------------#2020-07-16">https://betterprogramming.pub/6-things-to-know-to-master-python-closures-1586ca5165c6?source=collection_archive---------4-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4998" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">闭包可能很棘手</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b26babafe46020b6c677be735f94ece9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qKtyrj0pbcBe7qoO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@timberfoster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·福斯特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="67b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掌握一门编程语言需要相当长的时间。你可能需要几个月的时间来理解基本的数据结构和控制流，并使用函数执行某些操作。这些基础知识大部分都非常简单，可以通过简单的代码示例来理解。以下示例向您展示了我们如何理解Python中函数调用的基本元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">功能基础</p></figure><p id="58bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们首先定义了一个名为<code class="fe lx ly lz ma b">say_hello</code>的函数，它接受一个名为<code class="fe lx ly lz ma b">name</code>的参数。在函数体中，我们从<code class="fe lx ly lz ma b">name</code>参数创建了问候消息，并将其作为函数输出返回。要调用这个函数，我们只需使用带括号的函数名来括起所需的参数。如您所见，问候消息按预期打印出来了。一切都是非常基本的，并按照它应该的那样工作。</p><p id="3297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码只是一个例子，展示了一些简单的编程概念。但是，其他一些概念可能需要更长的时间才能完全消化。在Python中，与函数创建相关的一个例子是闭包。据我所知，这是很多初学者都知道的东西，但还没有到了解透彻的程度。在这篇文章中，我将解释Python闭包，我希望我的解释能帮助你理解它。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1a84" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.封闭的建筑构件</h1><p id="3acc" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">一般来说，闭包是在编程语言中具有一级函数的词汇范围名称绑定的函数(<a class="ae ky" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> Wikipedia </a>参考)。我觉得这不是最容易理解的定义。我们将逐步展开讨论，并使用更明智的例子来阐述Python中的闭包。让我们首先定义一个简单的闭包，这将作为我们后续讨论的基础。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">闭包的基本形式</p></figure><p id="abd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe lx ly lz ma b">say_hi</code>变量是一个闭包。为了使它成为一个闭包，应该注意三个关键的构建组件。</p><ul class=""><li id="d3e0" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">闭包是一个函数，或者更严格地说，<strong class="lb iu">一个内部函数</strong>，它被定义在另一个函数(称为外部函数)的范围内。在这种情况下，<code class="fe lx ly lz ma b">greeting_creator</code>是外部函数，而内部函数是<code class="fe lx ly lz ma b">greet</code>。</li><li id="71ef" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">内部函数是<strong class="lb iu">外部函数</strong>的返回值。在这种情况下，<code class="fe lx ly lz ma b">greeting_creator</code>返回<code class="fe lx ly lz ma b">greet</code>函数作为输出。不要将这与其他一些嵌套函数混淆，这些嵌套函数可能返回内部函数的输出值(例如，返回<code class="fe lx ly lz ma b">greet</code>，而不是返回调用<code class="fe lx ly lz ma b">greet(“John”)</code>生成的字符串)。</li><li id="8c21" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">内部函数<strong class="lb iu">绑定了在其自身作用域</strong>之外定义的变量。在这种情况下，除了内部函数自己创建的<code class="fe lx ly lz ma b">name</code>变量，它还使用了<code class="fe lx ly lz ma b">greeting_word</code>变量。重要的是，<code class="fe lx ly lz ma b">greeting_word</code>变量在外层函数的范围内(您会发现它被称为封闭范围)。</li></ul><p id="3e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要知道某个对象是不是闭包，可以简单参考上面的标准。如果它们都被满足，那么这个特定的对象就是一个闭包。不过，如果这三点还是让你困惑的话也没关系。我们将在接下来的章节中展开它们。先说最混乱的一个，第三个——<strong class="lb iu">闭包的变量绑定</strong>。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="12c4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.变量和范围</h1><h2 id="d888" class="nt mj it bd mk nu nv dn mo nw nx dp ms li ny nz mu lm oa ob mw lq oc od my oe bi translated">局部和内置变量和范围</h2><p id="43f9" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">当我们使用函数时，我们知道函数可以使用在调用过程中发送的参数。例如，在<code class="fe lx ly lz ma b">say_hello</code>函数中，我们使用了<code class="fe lx ly lz ma b">name</code>变量。用Python的行话来说，我们把这个变量称为<strong class="lb iu">局部变量</strong>，因为它在函数本身的作用域内(即局部作用域)，我们不能在函数之外访问<code class="fe lx ly lz ma b">name</code>变量。此外，<code class="fe lx ly lz ma b">say_hello</code>函数使用了<code class="fe lx ly lz ma b">print</code>函数，它是内置Python库的一部分。在这种情况下，我们将<code class="fe lx ly lz ma b">print</code>函数称为<strong class="lb iu">内置变量</strong>，因为它在内置范围内。</p><p id="36b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，你可能也听说过全局变量和全局范围。这些变量是在模块中定义的。在大多数情况下，您可以考虑在Python文件的顶层定义变量。文件中定义的函数和类可以访问它们。</p><h2 id="1d4d" class="nt mj it bd mk nu nv dn mo nw nx dp ms li ny nz mu lm oa ob mw lq oc od my oe bi translated">非局部变量和封闭范围</h2><p id="a7ed" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们现在已经了解了局部和内置变量和范围。我们可能想知道代码示例中的<code class="fe lx ly lz ma b">greeting_word</code>变量。显然，它不是一个内置或全局变量。这意味着它是一个局部变量吗？</p><p id="d07c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是肯定和否定的。对于外部函数<code class="fe lx ly lz ma b">greeting_creator</code>，它是一个局部变量，因为它在<code class="fe lx ly lz ma b">greeting_creator</code>函数的局部范围内。然而，对于内部函数<code class="fe lx ly lz ma b">greet</code>，变量<code class="fe lx ly lz ma b">greeting_word</code>被称为<strong class="lb iu">非局部变量</strong>或自由变量。与非局部变量密切相关的是<strong class="lb iu">封闭范围</strong>的概念，它从内部函数的角度引用外部函数的范围。任何在外部函数局部范围内的变量都被称为内部函数的非局部变量。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3b69" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.非局部变量绑定</h1><p id="ab4c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如上所述，内部函数<code class="fe lx ly lz ma b">greet</code>使用了非局部变量<code class="fe lx ly lz ma b">greeting_word</code>。我们说的<em class="of">绑定</em>这个词是什么意思？它不仅仅意味着使用变量。它实际上意味着内部函数“拥有”或“捕获”变量，就像绑定到内部函数的变量一样。为了找出哪些变量被绑定到闭包，我们可以运行一些检查，如代码片段所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自由变量的检验</p></figure><p id="f82a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，闭包绑定了一个自由变量<code class="fe lx ly lz ma b">greeting_word</code>，它的值是<code class="fe lx ly lz ma b">Hi</code>，这正是我们在创建闭包时使用的问候词。为了进一步了解非局部变量绑定的有趣方面，考虑下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">闭包之间的不同绑定</p></figure><p id="1bee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚创建了另一个具有不同问候语的闭包。捕获变量的名称仍然不变(即<code class="fe lx ly lz ma b">greeting_word</code>)。但是，捕获的值是<code class="fe lx ly lz ma b">Hey</code>，这反映了每个闭包都有自己的非局部变量绑定的特性。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="58b4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.非局部关键字和LEGB规则</h1><p id="143f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们已经看到闭包是如何绑定非局部变量的。在所示的例子中，闭包只使用了非局部变量。如果闭包需要修改非局部变量的值怎么办？我们能简单地做它吗？我们试试看有没有可能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">unboundlocalrerror</p></figure><p id="c486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图，我们做不到，遇到了<code class="fe lx ly lz ma b">UnboundLocalError</code>。对于新的Python学习者来说，这个异常可能是最令人困惑的异常之一。如回溯所示，有问题的代码行是<code class="fe lx ly lz ma b">greeting_word = “Non-” + greeting_word</code>，错误消息告诉我们在赋值前引用了局部变量<code class="fe lx ly lz ma b">greeting_word</code>。</p><p id="363f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前，我们已经讨论过<code class="fe lx ly lz ma b">greeting_word</code>是一个非局部变量。但是在这个例子中，根据错误信息，它怎么会变成局部变量呢？为了更好地理解这个变化，我们需要理解Python中的变量查找规则，也就是俗称的<strong class="lb iu"> LEGB </strong>。这个首字母缩写代表<strong class="lb iu">局部、封闭、全局和内置</strong>，我们已经在上面简要讨论了所有这些概念。具体来说，LEGB规则决定了如何在链中查找变量。如果可以在局部范围内找到一个变量(即函数本身)，Python会直接使用它。如果可以在封闭范围内找到，则停止进一步查找，依此类推。</p><p id="7568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当Python解释代码行<code class="fe lx ly lz ma b">greeting_word = “Non-” + greeting_word</code>时，它实际上在局部范围内创建了一个名为<code class="fe lx ly lz ma b">greeting_word</code>的变量。在这个赋值语句的左边，Python将理解这个新的局部变量将被绑定到一个特定的值(这个<em class="of"> bound </em>意味着赋值，语义上不同于非局部变量绑定)，所以它继续解释。在右边，它遇到了<code class="fe lx ly lz ma b">greeting_word</code>，Python会查找这个变量，用它的实际字符串值替换它。Python在局部范围内找到了，但是还没有绑定任何值！于是，<code class="fe lx ly lz ma b">UnboundLocalError</code>就提出来了。</p><p id="eae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们可以通过指导Python解释器如何查找变量来解决这个问题。具体来说，我们可以利用<strong class="lb iu">非本地</strong>关键字。让我们看看下面的修复。<em class="of">理论上，我可以使用不同的变量名来创建修改后的问候词，而不修改原始变量，但我只是想向您展示我们如何使用非本地关键字来学习。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非本地关键字的使用</p></figure><p id="8260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们简单地指出<code class="fe lx ly lz ma b">greeting_word</code>是一个非局部变量，这样Python就会理解这个变量应该在封闭范围而不是局部范围中查找。如你所见，它停止抱怨未绑定错误，问题解决了！</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1765" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">5.内部函数和作为对象的函数</h1><p id="5789" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">到目前为止，您可能已经对闭包的非局部变量绑定有了很好的理解。如果我们参考这三个标准，我们基本上已经涵盖了第三个标准，如前所述，它被认为是最难理解的标准。说完这些，让我们回顾一下前两个，它们要简单得多。</p><h2 id="4b36" class="nt mj it bd mk nu nv dn mo nw nx dp ms li ny nz mu lm oa ob mw lq oc od my oe bi translated">内部功能</h2><p id="b645" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">函数可以有嵌套结构。在Python中，我们简单地通过使用不同的缩进层次来安排结构，这非常类似于在许多其他编程语言中使用花括号。当我们在另一个函数中定义一个函数时，我们将内部函数称为<em class="of"> </em>内部函数<em class="of"> </em>，将外部函数称为<em class="of"> </em>外部函数。有些人将内部函数称为嵌套函数。我们看到的例子都是简单的两层结构。如果我们愿意，我们可以有三层甚至更多层——内部函数定义在内部函数中。</p><h2 id="71c2" class="nt mj it bd mk nu nv dn mo nw nx dp ms li ny nz mu lm oa ob mw lq oc od my oe bi translated">作为对象的功能</h2><p id="7149" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">另一个标准是外部函数返回内部函数作为返回值。有可能是因为Python把一切都当成对象，也就是说函数在Python里也是对象。这也是为什么有人说函数是Python中的一等公民，因为函数是作为其他对象工作的。因此，函数可以是其他函数的返回值。与此相关，那些可以将函数作为输入和/或返回其他函数作为输出的函数被称为高阶函数。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1766" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">6.闭包的实际例子:装饰者</h1><p id="22d3" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">到目前为止，我们已经关注了闭包的理论讨论，比如它们是什么以及我们如何构建它们。但是你可能想知道我们用它们做什么。为了理解它们的实际用法，让我们看看利用闭包技术的一个重要的Python特性——decorator。</p><p id="55e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，Python decorators修改另一个函数的行为，而不影响该函数的原始功能。先看个例子再解释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装修工</p></figure><p id="6832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们定义了一个名为<code class="fe lx ly lz ma b">echo</code>的装饰函数，它简单地调用传递的函数两次。要使用装饰器，我们只需使用@符号前缀将装饰器函数名放在要装饰的函数上方。当我们调用被修饰的函数<code class="fe lx ly lz ma b">say_good_morning</code>时，该函数确实被调用了两次，这表明修饰是成功的。</p><p id="2a86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为什么我说装饰者在利用闭包呢？先来看一些代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查装饰函数</p></figure><p id="bfd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，有趣的是，修饰后的函数变成了一个闭包，这实际上一点也不奇怪。您可能已经注意到，decorator函数返回内部函数作为其输出。重要的是，它绑定了非局部变量<code class="fe lx ly lz ma b">func</code>。因此，内部函数满足闭包的所有三个标准。这就是为什么修饰函数是一个闭包。与此相关的是，装修过程相当于下面的代码。要装饰的函数被发送给要装饰的装饰函数，从装饰函数返回的是内部函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显性装饰</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="91fb" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="2bad" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在这篇文章中，我们回顾了结束的三个标准。从结构的角度来看，闭包可以通过下面的讨论来理解。</p><p id="cc16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">闭包是在另一个函数中定义并从另一个函数返回的内部函数对象，它们绑定在封闭范围中定义的非局部变量。</p><p id="bda4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还简要回顾了装饰器技术，它利用闭包技术来装饰函数。</p></div></div>    
</body>
</html>