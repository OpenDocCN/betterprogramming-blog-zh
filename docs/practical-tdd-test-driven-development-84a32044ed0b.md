# 测试驱动开发的实用介绍

> 原文：<https://betterprogramming.pub/practical-tdd-test-driven-development-84a32044ed0b>

## 测试驱动的开发是困难的——这是不为人知的事实

![](img/90f0a6e2ae7bed5016e7172d6ace0f6a.png)

图片来源于[https://testsigma.com/blog/ai-driven-test-automation/](https://testsigma.com/blog/ai-driven-test-automation/)

这些天来，你阅读了大量关于测试驱动开发(TDD)所有优点的文章，并在技术会议上听到了许多告诉你:“做测试！”，以及做这些事情有多酷。

你知道吗？不幸的是，他们是对的(不一定是关于“酷”的部分，而是关于有用的部分)。

测试是必须的！

当谈到 TDD 时，我们列出的典型优势是真实的:

*   你写出更好的软件。
*   当引入新功能时，您可以免受破坏。
*   你的软件是自我记录的。
*   你避免过度工程化。

即使我一直认同这些优点，但曾经有一段时间我认为我不需要 TDD 来编写好的和可维护的软件。

当然，现在，我知道我错了，但为什么我会有这种想法，尽管专业人员有闪亮的魔法？原因只有一个:成本高。

# **成本**

花费很大！有人可能在想:“但是，如果你不做测试，成本会更高”——这也是对的。

这两项成本出现的时间不同:

*   你做 TDD——你现在有了成本*。*
*   *你不做 TDD——你将在未来有一个成本*。**

**那么，我们如何走出这个僵局呢？**

**完成一件事最有效的方法是尽可能自然地去做。**

**人们的本性是懒惰(在这里，软件开发人员是最好的执行者)和贪婪，所以你现在必须找到降低成本的方法。说起来容易，做起来却很难！**

**在这里，我将分享我的经验，以及让我的收益/成本比变得对我有利的方法。但是，在此之前，让我们分析一下应用 TDD 的一些典型困难。**

# **你能测试两个数的和吗？**

**一般来说，理论不是可有可无的。你必须掌握它才能掌握实践。然而，尝试一下子应用你以前学到的所有理论知识可能会有压倒性的效果。**

**关于 TDD 的典型理论课是这样开始的:**

**关于 TDD 的典型开始课程**

**你会说:“这很简单！”**

**接下来是这个:**

*   **红色➡绿色➡重构循环。**
*   **单元、验收、回归和集成测试。**
*   **嘲讽，存根，假货。**
*   **如果你幸运(也可能不幸运)，有人会告诉你关于契约测试的事情。**
*   **而且，如果你非常幸运(或者可能非常不幸)，你会接触到遗留代码库重构。**

**事情会变得艰难，但是你是一个有经验的开发人员，所有这些概念对你来说并不难处理。**

**然后下课；你回家后，在接下来的几天里，你勤奋地做一些代码形来修正你刚刚学到的概念。到目前为止一切顺利。**

# **斗争是真实的**

**接下来是一个真实世界的项目，有真实的截止日期和真实的时间成本——但是你有动力应用你闪亮的新 TDD。**

**你开始考虑你的软件的架构，并开始为第一个类和类本身编写测试——让我们称之为`Class1`。**

**现在，你考虑一下`Class1`的第一个用户，姑且称之为`UsageOfAClass`**，你再次测试并编写它。`Class1`是`UsageOfAClass`的合作者，你要嘲笑它吗？好吧，我们来嘲讽一下。****

****但是，`Class1`和`UsageOfAClass`的真实互动呢？也许你也应该全部测试一下？让我们开始吧。****

****此时，在你的内心，你开始听到一个微弱的声音说:“如果我不必写这些测试，我会开发得更快”。你不听这个邪恶的声音，直接进行下一个测试。****

****`Class2` 将被`UsageOfAClass`使用，它将自己保存在 db 中。那么，我们必须测试`Class2`、它与`UsageOfAClass`的交互以及数据库中的持久性吗？****

****但是等等…有没有人在 TDD 理论课上提到如何应对 I/O 测试？****

****TDD 背后的理论并不难理解，但是如果你没有用正确的方法，将它应用到现实世界会非常复杂。****

# ****做就是了****

****我们应该永远记住，理论必须符合我们的需要，而不是相反。****

****主要目标是完成工作。所以我的建议是:只管去做！****

****从简单开始，坚持完成你的任务。然后，当你陷入某种理论思维循环时，比如:****

*   ****这是单元测试还是集成测试？****
*   ****我该不该嘲笑它？****
*   ****这里我应该写一个新的合作者，所以一个全新的无限单元测试套件，只是为了写“嘿，香蕉”。****

****暂时忘掉理论，向前迈出一步。顺其自然吧！一旦你完成了任务，回头看看你的工作。回顾已经完成的工作，分析什么是正确的事情会容易得多。****

# ****实用 TDD****

****去做吧。顺便说一下，我认为这也是正确的 TDD 方法。****

****我们构建`Class1`、`Class2`和`UsageOfAClass`的方式有什么问题？方法。****

****这是一种自下而上的方法:****

*   ****分析问题。****
*   ****弄清楚一个架构。****
*   ****从单元组件开始构建。****

****这种方法是过度工程的最好朋友。你通常构建系统来阻止你认为将来会发生的变化，而不知道它们是否真的会发生。****

****然后，当一个需求改变时，它通常以一种不适合你的结构的方式发生，不管它有多好。****

****对我来说，大幅降低使用 TDD 写作的直接成本的关键是采用自顶向下的方法:****

1.  ****带来一个用户故事。****
2.  ****编写一个非常简单的用例测试。****
3.  ****让它跑起来。****
4.  ****回到步骤 2，直到所有用例完成。****

****在这个过程中，不要太担心架构、干净的代码(嗯，至少要记住使用合适的变量名)，或者任何当前不需要的复杂问题。****

****做你知道你现在需要的，直到最后。****

****故事的测试清楚地陈述了当前和已知的需求是什么。****

****一旦你完成了，看看你的大球意大利面泥代码，克服耻辱，并深入看看你做了什么:****

*   ****有用！测试证明了这一点。****
*   ****所有的系统都在那里，只有完成工作真正需要的东西。****

****现在，您已经对系统的所有部分有了一个总体的了解，因此您可以利用您从零开始时无法获得的领域知识进行重构。测试将确保在重构过程中不会出现任何问题。****

# ****重构****

****对我来说，开始重构的最佳方式是确定责任范围，并将它们分成私有方法。这一步有助于确定职责及其输入和输出。****

****之后，合作者的类就差不多了，你只需要把它们转移到不同的文件中。****

****随着您的进展，为从流程中跳出的类编写测试，并迭代直到您对结果满意为止。记住，如果你在某个地方卡住了，就去做！****

****如果你做了坏事，一旦你做了，你会有更多的信息告诉你下次面对时如何克服错误。尽你目前的能力，把工作做好是当务之急。****

****这样，如果你分析自己的错误并从中吸取教训，你也会提高自己的能力。****

# ****下一个用户故事****

****按照以下步骤继续开发您的产品:****

*   ****举个故事。****
*   ****让它完全在一个“测试-代码”循环中工作。****
*   ****重构。****

****在添加功能的同时，你将继续改变你的软件，甚至可能改变它的结构。但是，随着系统的增长，由于 TDD 的两个主要特征，变更的成本将保持线性增长:****

*   ****架构发现(有助于控制复杂性)。****
*   ****防止重大变更的保护。****

****这个系统不会被过度设计，因为建筑会随着故事的完成而出现。****

****你不考虑未来可能的需求；如果你最终需要它，那么实现它的成本将会很低。****

# ****什么会让它出错？****

****故事的规模。你最终建造的东西必须是合适的尺寸。不要太大(否则会花太多时间来获得反馈)或太小(否则你不会有概述)。****

****故事太大怎么办？****

****把它分成可以从头到尾建造的小块。****

****你同意我的观点还是认为这一切都是一堆垃圾？在评论里让我知道你的想法；如果能在 TDD 上展开对话并分享我们的经验，那将是一件非常棒的事情。****

****我要感谢 Matteo Baglini 帮助我找到了软件开发和 TDD 的实用方法。****

****感谢您的阅读！****