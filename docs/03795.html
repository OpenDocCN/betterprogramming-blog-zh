<html>
<head>
<title>The Never-Ending Story of Rounding Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">舍入数字的永无止境的故事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-never-ending-story-of-rounding-numbers-7071cdfc1c7c?source=collection_archive---------18-----------------------#2020-03-04">https://betterprogramming.pub/the-never-ending-story-of-rounding-numbers-7071cdfc1c7c?source=collection_archive---------18-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c896" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这就是为什么在JavaScript中舍入数字仍然是一个问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a5a280fe44343a762fd6da1b3bb84e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FOKqhkfufS2gAbmh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼克·希利尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是2020年(或者可能是<code class="fe lv lw lx ly b">2020.0000000000000004</code>)，舍入数字仍然是JavaScript中的一个问题。其实一般来说是计算方面的问题。</p><p id="fa46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个关于如何使用JavaScript正确完成这项工作的权威指南。通读一遍，永远记住！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c2e2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">介绍</h1><p id="eb73" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们来理解一下为什么浮点数一直是，现在是，将来也会继续是计算中的一个问题。</p><p id="258e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个数字都是一个字节序列。例如，十进制数<code class="fe lv lw lx ly b">3</code>是二进制数<code class="fe lv lw lx ly b">00000011</code>。这基本上是计算机如何用字节来表示每个数字的(即一个字节是8位:<code class="fe lv lw lx ly b">0</code>或<code class="fe lv lw lx ly b">1</code>)。如果我们取八个字节，<code class="fe lv lw lx ly b">00000000</code>相当于十进制的<code class="fe lv lw lx ly b">0</code>。<code class="fe lv lw lx ly b">11111111</code>相当于<code class="fe lv lw lx ly b">255</code>。每个字节都有一个权重。从左边开始，依次为<code class="fe lv lw lx ly b">128</code>、<code class="fe lv lw lx ly b">64</code>、<code class="fe lv lw lx ly b">32</code>、<code class="fe lv lw lx ly b">16</code>、<code class="fe lv lw lx ly b">8</code>、<code class="fe lv lw lx ly b">4</code>、<code class="fe lv lw lx ly b">2</code>、<code class="fe lv lw lx ly b">1</code>。将这些加在一起后，我们得到<code class="fe lv lw lx ly b">255</code>。因此，要从二进制转换到十进制，我们查看每个字节，将每个字节乘以其权重，然后求和:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="1d27" class="ni mh it ly b gy nj nk l nl nm">00000011 = 0*128 + 0*64 + 0*32 + 0*16 + 0*8 + 0*4 + 1*2 + 1*1 = 3<br/>10101010 = 1*128 + 0*64 + 1*32 + 0*16 + 1*8 + 0*4 + 1*2 + 1*0 = 170<br/>11111111 = 1*128 + 1*64 + 1*32 + 1*16 + 1*8 + 1*4 + 1*2 + 1*1 = 255</span></pre><p id="5d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对整数来说非常有效。浮点数的问题是，我们不能把字节分成无限小的数，每个浮点数的表示都有一些限制。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fb22" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">二进制分数</h1><p id="259a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了将十进制(分数)部分转换成二进制，我们也可以用权重来表示分数部分！然而，这次我们将向下(即最高有效位的值为<code class="fe lv lw lx ly b">0.5</code>，下一位为<code class="fe lv lw lx ly b">0.25</code>、<code class="fe lv lw lx ly b">0.125</code>、<code class="fe lv lw lx ly b">0.0625</code>，以此类推):</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b9aa" class="ni mh it ly b gy nj nk l nl nm">0.10000000 = 0.5<br/>0.01000000 = 0.25<br/>0.00100000 = 0.125<br/>0.00010000 = 0.0625<br/>0.00001000 = 0.03125<br/>0.00000100 = 0.015625<br/>0.00000010 = 0.0078125<br/>0.00000001 = 0.00390625<br/>...<br/>0.11111111 = 0.99609375</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="169d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么是0.2 + 0.1！== 0.3</h1><p id="1a61" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个常见的JavaScript面试问题:为什么添加<code class="fe lv lw lx ly b">0.1</code>和<code class="fe lv lw lx ly b">0.2</code>不等于<code class="fe lv lw lx ly b">0.3</code>？简单的答案是，计算机不是用十进制数计算，而是用二进制数计算。因此:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e64e" class="ni mh it ly b gy nj nk l nl nm">const a = 0.1;<br/>const b = 0.2;<br/>const c = a + b; // equals to: 0.30000000000000004</span></pre><p id="6515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们，人类，会期望这个等于<code class="fe lv lw lx ly b">0.3</code>。</p><p id="ef9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<code class="fe lv lw lx ly b">0.1</code>的二进制计算机表示是<code class="fe lv lw lx ly b">0.0001100110011001101</code>。转换回十进制，得出<code class="fe lv lw lx ly b">0.1000003814697265625</code>。足够接近<code class="fe lv lw lx ly b">0.1</code>，但不完全是<code class="fe lv lw lx ly b">0.1</code>！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a1ae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">数学.圆</h1><p id="23c3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Math.round()</code>函数将数字四舍五入为最接近的整数。因此，这对我们的情况不好，因为它将为<code class="fe lv lw lx ly b">0.3</code>返回<code class="fe lv lw lx ly b">0</code>:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="2a6f" class="ni mh it ly b gy nj nk l nl nm">const d = Math.round(c); // returns: 0</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f223" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">简单但不正确的方法</h1><p id="e472" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们开始在互联网上搜索解决方案，我们可能会找到一个类似于以下解决方案的最佳结果:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0bff" class="ni mh it ly b gy nj nk l nl nm">const result = <!-- -->Math.round(value * 100)/100;</span></pre><p id="bf11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用等于<code class="fe lv lw lx ly b">c = 0.30000000000000004</code>的<code class="fe lv lw lx ly b">value</code>来检查它，那么它可能看起来是有效的，因为结果将是<code class="fe lv lw lx ly b">0.3</code>。然而，使用下一个值<code class="fe lv lw lx ly b">1.005</code>进行快速测试将会错误地产生<code class="fe lv lw lx ly b">1</code>，而不是预期的<code class="fe lv lw lx ly b">1.01</code>:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b4e3" class="ni mh it ly b gy nj nk l nl nm">const value = 1.005;<br/>Math.round(value * 100)/100; // returns: 1</span></pre><p id="fe0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续深入之前，让我们停下来注意一下，我们不自觉地多了一个要求:我们四舍五入到小数点后两位，或者更科学一点，我们没有讨论精度。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5768" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">埃普西隆</h1><p id="261d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在MDN网络文档上，我们可以找到关于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON" rel="noopener ugc nofollow" target="_blank">艾司隆</a>的信息:</p><blockquote class="nn"><p id="5805" class="no np it bd nq nr ns nt nu nv nw lu dk translated">"<code class="fe lv lw lx ly b"><strong class="ak">Number.EPSILON</strong></code>属性表示1和大于1的最小浮点数之间的差。"</p></blockquote><p id="eb37" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">但是这到底意味着什么，它如何帮助我们舍入呢？首先，我们可以用Epsilon更新上面的代码:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="42bb" class="ni mh it ly b gy nj nk l nl nm">const value = 1.005;<br/>Math.round((value + Number.EPSILON) * 100) / 100; // returns: 1.01</span></pre><p id="c9cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来很对，不是吗？</p><p id="f226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在进入下一个解决方案之前，让我们引用<a class="ae ky" href="https://stackoverflow.com/a/56967003/3013633" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出答案</a>来添加一个简短的注释，说明Epsilon的用途:</p><blockquote class="nn"><p id="5699" class="no np it bd nq nr ns nt nu nv nw lu dk translated">"这只是超级电脑迷可能会在计算中用到的东西."</p></blockquote><p id="46ba" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">换句话说，不要用！有关更多详细信息，请查看引用的SO问题。</p><p id="dd39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以通过此测试案例证明此解决方案失败:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0ee7" class="ni mh it ly b gy nj nk l nl nm">const value = 1.1049999999999998;<br/>Math.round((value + Number.EPSILON) * 100) / 100; // returns: 1.11</span></pre><p id="7aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预期结果是:<code class="fe lv lw lx ly b">1.10</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bdee" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Number.toFixed()</h1><p id="a0b5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">继续，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed" rel="noopener ugc nofollow" target="_blank">Number.toFixed()</a></code>是另一个流行的<a class="ae ky" href="https://stackoverflow.com/a/15762794/3013633" rel="noopener ugc nofollow" target="_blank">解决方案</a>。这是一个带一个可选参数的方法:<code class="fe lv lw lx ly b">digits</code> —小数点后出现的位数。方法返回数字的字符串表示形式，如有必要，将对其进行舍入:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f876" class="ni mh it ly b gy nj nk l nl nm">0.1.toFixed(2);                // returns: "0.10"<br/>0.2.toFixed(2);                // returns: "0.20"<br/>1.005.toFixed(3);              // returns: "1.005"<br/>1.1049999999999998.toFixed(2); // returns: "1.10"</span></pre><p id="08e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="cf8f" class="ni mh it ly b gy nj nk l nl nm">1.005.toFixed(2); // returns: "1.00" instead of expected: "1.01"</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4a9c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用外部库</h1><p id="a397" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这个阶段，我们已经尝试了许多流行的舍入方法，但都失败了。</p><p id="21ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们可以重用其他开发人员编写的代码，而不是重新发明轮子。例如，<a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>是一个流行的实用程序库，它具有<code class="fe lv lw lx ly b"><a class="ae ky" href="https://lodash.com/docs/4.17.15#round" rel="noopener ugc nofollow" target="_blank">round()</a></code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dd05" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="60d8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当在JavaScript或任何计算机编程语言中使用浮点数时，我们需要知道数字是如何表示的。</p><p id="aa7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在源代码中看到定制的舍入函数时，应该会立即在我们的头脑中拉响警报。有些解决方案可能行得通，但舍入一直是一个常见的问题。因此，我们应该在数学函数的支持下使用完善的库。</p><p id="b495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在下面的评论中让我知道你最喜欢或使用哪种解决方案。你遇到过四舍五入的问题吗？</p></div></div>    
</body>
</html>