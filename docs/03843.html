<html>
<head>
<title>Every Python Programmer Should Know the Not-So-Secret ThreadPool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Python程序员都应该知道并不秘密的线程池</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/every-python-programmer-should-know-the-not-so-secret-threadpool-642ec47f2000?source=collection_archive---------0-----------------------#2020-03-09">https://betterprogramming.pub/every-python-programmer-should-know-the-not-so-secret-threadpool-642ec47f2000?source=collection_archive---------0-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d82c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过多线程，您只需要几行代码就可以将代码速度提高几个数量级</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/22e1d3b3c7204df4ed5f635887c6a749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndjrj0UpIUlKIY6nDCF9xw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3106134" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="b402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我不得不在我们的CRM系统上运行数百个外部更新操作而没有批处理它们的选项时，我第一次遇到了用Python并行化我的代码的必要性。</p><p id="a5cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个更新操作将通过一个API调用提交，然后需要大约两到三秒钟来处理。这些更新会触发CRM中的流程，有时会引发错误。</p><p id="d9f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出错的可能性意味着我不得不经历无数次的运动，以确保每件事都以我满意的方式完成。</p><p id="95b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使这一努力耗时如此之久的是这样一个事实，即在每一次API调用之后，我的脚本必须在提交下一个API请求之前等待响应。</p><p id="11e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的情况是多线程(Python中可用的并行概念之一)非常方便的典型用例！在Python中，本质上有三种形式的并发性:</p><ul class=""><li id="85be" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">多线程—通过<code class="fe me mf mg mh b">threading</code>先发制人。</li><li id="5ac5" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">协作式多任务处理——通过<code class="fe me mf mg mh b">asyncio</code>。</li><li id="f3e5" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">多重处理——通过<code class="fe me mf mg mh b">multiprocessing</code>。</li></ul><p id="38bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般的建议是对CPU受限的问题使用多处理(即计算密集型)，对I/O受限的问题使用多线程/多任务处理(即等待输入/输出完成)。</p><p id="f692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，可能会有例外，最终，这取决于手头的具体情况。以我的经验来看，一旦性能变得至关重要，考虑所有选项确实是有意义的。</p><p id="4f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建立了一个web API (AWS API gateway + Lambda ),它可以提供激励性的引用，我们可以“做”这些来进行基准测试。</p><p id="71f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个<a class="ae ky" href="https://medium.fabianbosler.de/run" rel="noopener ugc nofollow" target="_blank">样本！</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="43f3" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">进程池</h1><p id="6e87" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们先来看看来自<code class="fe me mf mg mh b">multiprocessing</code>图书馆的<code class="fe me mf mg mh b">Pool</code>。我发现<code class="fe me mf mg mh b">Pool</code>有一个非常容易使用的API。本质上，您只需在<code class="fe me mf mg mh b">with</code>块中添加<code class="fe me mf mg mh b">Pool</code>，就已经并行化了您的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c16ea2b9741202dd5606de3a4082d849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*SJGioiH0IHbBl4PX0BWc6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/FBosler/c77d28f7d719ac52364bd8420cb0880d#file-multiprocessing-py" rel="noopener ugc nofollow" target="_blank">此处代码</a></p></figure><p id="46fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你问我，我会觉得非常简单。并发的其他实现要复杂得多。</p><p id="34aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，它们要求你主动管理工人、任务、执行者、队列、协程等等。对我来说有点太多的认知开销了。真的很喜欢<code class="fe me mf mg mh b">Pool</code>的简洁。</p><blockquote class="ns"><p id="86ce" class="nt nu it bd nv nw nx ny nz oa ob lu dk translated">“简单比复杂好。”——蒂姆·彼得斯的《Python之禅》</p></blockquote><p id="51ec" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">让我们快速探究一下<code class="fe me mf mg mh b">Pool</code>到底是做什么的。我们首先用特定数量的进程(在我们的例子中是五个)实例化这个池。作为一个经验法则(对于CPU受限的任务)，使用与CPU核心数量大致相同的进程。</p><p id="2b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们有<code class="fe me mf mg mh b">p.map()</code>，<code class="fe me mf mg mh b">p.map(&lt;func&gt;, &lt;iterable&gt;)</code>带一个函数和一个iterable，非常像常规的<code class="fe me mf mg mh b">map</code>。</p><p id="930a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，与<code class="fe me mf mg mh b">map</code>相比，主要的区别是我们现在有多个进程并行处理iterable。一旦一个进程完成了来自iterable的当前元素，该进程就返回到iterable并获取下一个元素来应用函数。</p><p id="10e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多重处理的“问题”是它带来了一些<a class="ae ky" href="https://stackoverflow.com/questions/18114285/what-are-the-differences-between-the-threading-and-multiprocessing-modules/18114475#18114475" rel="noopener ugc nofollow" target="_blank">开销</a>，这就给我们带来了多线程。与进程相比，线程是轻量级的，带来的开销也少得多(并且允许彼此之间更容易地共享内存)。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7ab7" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">秘密“从多处理池导入线程池”</h1><p id="a5f0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">你可能会问，为什么要保密？嗯，事情是这样的，<code class="fe me mf mg mh b">ThreadPool</code>是<a class="ae ky" href="https://stackoverflow.com/questions/3033952/threading-pool-similar-to-the-multiprocessing-pool#answer-3386632" rel="noopener ugc nofollow" target="_blank">没有真正记录</a>。</p><p id="709f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过接口和<code class="fe me mf mg mh b">multiprocessing.Pool</code>是一样的(注意导入是从<code class="fe me mf mg mh b">multiprocessing<strong class="lb iu">.pool</strong></code>而不仅仅是从<code class="fe me mf mg mh b">multiprocessing</code>)。</p><p id="8f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始以多线程的方式从web API获取报价！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/90948306ad5257514c4c0c00d62367b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUIxs34ULwdMUUNCVuJONQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/FBosler/c77d28f7d719ac52364bd8420cb0880d#file-multi_threading-py" rel="noopener ugc nofollow" target="_blank">此处代码</a></p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="517b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">为了完整起见— Asyncio</h1><p id="568c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Asyncio似乎是一种新的狂欢派对(不要与“ay，se cayó”混淆，西班牙语意思是:“哦，他摔倒了”)。</p><p id="7438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Asyncio是在Python 3.4中引入的，但后来有了很大的发展。我真的非常非常不喜欢这个语法，但是我想把它包含在基准测试中。</p><p id="a0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不同于多线程和多处理，因为它只使用一个进程和一个线程，但异步执行代码。</p><p id="1adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键点是，这些异步例程可以暂停并等待它们的结果，同时移交给其他例程(执行程序决定上下文切换的时间)。事件循环有助于这一切。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/42732de17aa343825b63767ee2d2321a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CX_ujkOpKoaWhMSPZGJwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/FBosler/c77d28f7d719ac52364bd8420cb0880d#file-asyncio-py" rel="noopener ugc nofollow" target="_blank">此处代码</a></p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9457" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">获胜者是！</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/327513e4e87bae0a67307e14717e35d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l97EwodUocHq9H6BSsingA.png"/></div></div></figure><p id="fe6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试时间到了！</p><ul class=""><li id="5ec4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="ok">顺序版本</em>(即一个接一个)是迄今为止最慢的，每1000个样本增加80秒左右。</li><li id="56b9" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">其次是<em class="ok"> AsyncIO </em>，大概比顺序版快3-5倍。</li><li id="c241" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">八个线程已经让我们的速度提高了五倍。</li><li id="adc2" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">64个以上的线程让我们的速度提高了10倍！(这是我的Mac开始封顶的地方。但是，如果有合适的环境，如硬件、足够大的样本量、互联网连接和可以处理您的请求的服务器，您可以走得更远，并看到积极的结果。)</li></ul><p id="29a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我得说，从160秒到15秒是相当大的成就！</p><p id="b2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，在我的本地机器上，我能够通过<code class="fe me mf mg mh b">multiprocessing</code>将获取2000个样本<strong class="lb iu"> </strong>所需的时间减少到大约12秒，这起初可能看起来违反直觉(考虑到这是一个I/O绑定的问题)。</p><p id="2d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，与<code class="fe me mf mg mh b">multithreading</code>不同的是，<code class="fe me mf mg mh b">multiprocessing</code>可以使用所有可用的内核，而不局限于一个内核。如果你对<code class="fe me mf mg mh b">multithreading</code>对<code class="fe me mf mg mh b">multiprocessing</code>的整体表现感到好奇，可以去看看<a class="ae ky" href="https://www.python.org/dev/peps/pep-0371/" rel="noopener ugc nofollow" target="_blank"> PEP 371 </a>。</p><p id="48ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想重现结果，可以用下面的代码试一试。(我只要求你稍微留心一点，不要把web API当作机关枪一样扫射到遗忘。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/877d7794ad49a0e45850e62dfb1c788a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOxV8miL8RUp82LUTJuiDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/FBosler/c77d28f7d719ac52364bd8420cb0880d#file-benchmark-py" rel="noopener ugc nofollow" target="_blank">此处代码</a></p></figure><p id="c53a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>