<html>
<head>
<title>Raspberry Pi GPIO — Introduction To Programming Broadcom BCM2835 ARM Peripherals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">raspberry Pi GPIO——Broadcom BCM 2835 ARM外设编程简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/raspberry-pi-gpio-introduction-to-programming-broadcom-bcm2835-arm-peripherals-33e6d9423f98?source=collection_archive---------12-----------------------#2022-04-06">https://betterprogramming.pub/raspberry-pi-gpio-introduction-to-programming-broadcom-bcm2835-arm-peripherals-33e6d9423f98?source=collection_archive---------12-----------------------#2022-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="873d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在Raspberry Pi上使用BCM2835的寄存器直接对其进行编程，以执行写入GPIO引脚或使用SPI等高级功能等任务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/213723c2472bc4b197d90b75bc045e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_EEakhqDNtYnAbRpgEc1g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:RasPi.tv</p></figure><h1 id="5c8e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">概观</h1><p id="8475" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是探索在Raspberry Pi 3B+ 上进行<a class="ae mj" href="https://youngkin.github.io/categories/gpio/" rel="noopener ugc nofollow" target="_blank"> GPIO编程的系列文章的第六篇。它介绍了如何通过直接与BCM2835 SoC(片上系统)上的适当寄存器交互来控制GPIO外设。这是一个简介，因为它仅涵盖其中一种功能，使用BCM2835 ARM外设指南</a>的<a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">第6节中描述的基本GPIO功能。这不包括BCM2835对串行外设接口(SPI)、脉宽调制(PWM)和内部集成电路(IC2)等协议的支持，这些协议通过利用映射到给定协议的底层引脚来覆盖特定的协议功能(例如，GPIO引脚8–11与SPI协议相关联，并且具有针对该协议可以使能的行为)。也就是说，使用基本引脚级功能涵盖了利用SPI等高级协议功能所需的相同概念。本文，再加上</a><a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>，将为驱动通过这些功能控制的设备提供足够的背景知识。</p><p id="5e5e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">当然，还有多个库，如C <a class="ae mj" href="https://www.airspayce.com/mikem/bcm2835/index.html" rel="noopener ugc nofollow" target="_blank"> BCM2835 </a>和<a class="ae mj" href="https://github.com/WiringPi/WiringPi" rel="noopener ugc nofollow" target="_blank"> WiringPi </a>库、Python <a class="ae mj" href="http://abyz.me.uk/rpi/pigpio/" rel="noopener ugc nofollow" target="_blank"> pgpio </a>和<a class="ae mj" href="https://pypi.org/project/RPi.GPIO/" rel="noopener ugc nofollow" target="_blank"> RPi。GPIO </a>库和Go <a class="ae mj" href="https://github.com/stianeikeland/go-rpio" rel="noopener ugc nofollow" target="_blank"> go-rpio </a>库使这变得更加容易。虽然这些库通常更适合大多数项目，但了解BCM2835 SoC如何工作以及这些库如何与BCM2835交互会有所帮助。如果您发现自己正在阅读库代码和/或想要为这些项目做出贡献，或者甚至编写自己的库，这种背景也是有帮助的。</p><p id="a9f2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">本文假设您已经对Raspberry Pi上的BCM2835和GPIO编程有所了解。如果你没有，你可以考虑尝试一下我的其他GPIO文章中的项目。系列中最简单的文章是<a class="ae mj" href="https://youngkin.github.io/post/sunfoundergpionotesled/" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi GPIO in Go和C —闪烁LED </a>。它演示了与本文相同的功能，使LED闪烁，但它也演示了<a class="ae mj" href="https://github.com/WiringPi/WiringPi" rel="noopener ugc nofollow" target="_blank"> WiringPi </a>和Go <a class="ae mj" href="https://github.com/stianeikeland/go-rpio" rel="noopener ugc nofollow" target="_blank"> go-rpio </a>库的用法。这是对在Raspberry Pi上使用GPIO的一个很好的介绍，但它只涵盖了基本的GPIO概念以及如何将试验板连接到Raspberry Pi的GPIO输出。</p><p id="8aea" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">将涵盖以下主题:</p><ol class=""><li id="5c06" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated"><strong class="lp ir">先决条件</strong> —描述本文所需的硬件和库。</li><li id="27cf" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">BCM2835 GPIO外设简介</strong> —概述BCM 2835的架构和功能。</li><li id="22d1" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">使用BCM2835板通过GPIO引脚控制LED</strong>—提供使用BCM2835 GPIO寄存器控制LED的详细信息，包括代码。</li><li id="6d5f" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">总结</strong> —总结本文中涉及的重要概念。</li><li id="c980" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">参考文献</strong> —提供了一个我认为有用的参考文献列表，其中一些在本文的创作中使用过。</li></ol><h1 id="77f3" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">先决条件</h1><p id="29ae" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果你没有，你需要一个树莓派。我在Raspbian OS的“拉伸”版本中使用了一个树莓派3B+。如果您还没有树莓Pi并且需要帮助设置，请参见<a class="ae mj" href="https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up" rel="noopener ugc nofollow" target="_blank">如何从头设置新的树莓Pi</a>。</p><p id="843f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">接下来你需要一个<a class="ae mj" href="https://www.amazon.com/dp/B082KBF7MM/ref=sspa_dk_detail_4?psc=1&amp;pd_rd_i=B082KBF7MM&amp;pd_rd_w=1tGTV&amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;pd_rd_wg=fX8JB&amp;pf_rd_r=44DE0RS1E9FD42RBYC7R&amp;pd_rd_r=47cbdc7f-7834-455f-9429-ef74a438bd45&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFVVkdZVUZRNUw3ODkmZW5jcnlwdGVkSWQ9QTA4MzI4MzYyU0VLNzBJM0cxRUVMJmVuY3J5cHRlZEFkSWQ9QTA0Mjk1NTMzSzNSWlNFUjU0NURBJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank">试验板</a>，一些<a class="ae mj" href="https://www.amazon.com/dp/B08HZ26ZLF/ref=syn_sd_onsite_desktop_19?psc=1&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExRFpLWElCRjg1MUNMJmVuY3J5cHRlZElkPUEwMjMyMTE1M01aOFE3U1BQS09YSiZlbmNyeXB0ZWRBZElkPUEwODE5NTMxMktEMTlZRjEyQjBJNiZ3aWRnZXROYW1lPXNkX29uc2l0ZV9kZXNrdG9wJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank">跳线</a>，<a class="ae mj" href="https://www.amazon.com/Gikfun-Resistor-Experiment-Raspberry-Arduino/dp/B01G3FCMVA/ref=sr_1_19?keywords=220+ohm+resistor&amp;qid=1648933499&amp;sr=8-19" rel="noopener ugc nofollow" target="_blank">一个220欧姆的电阻，和一个LED </a>。您还应该考虑使用一个带有T型适配器的<a class="ae mj" href="https://www.amazon.com/dp/B082PRVRYR/ref=sspa_dk_detail_2?psc=1&amp;pd_rd_i=B082PRVRYR&amp;pd_rd_w=8mKhr&amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;pd_rd_wg=e9psa&amp;pf_rd_r=S09F37DF2G5FW8B8GX4B&amp;pd_rd_r=c065c120-e60b-45e9-b93b-f581f048cf46&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUFCMzhUQ09COFI2VlMmZW5jcnlwdGVkSWQ9QTA5NjU2ODUxRDkxNEYwSTYwV09KJmVuY3J5cHRlZEFkSWQ9QTAxOTg1MTUyRUhEUlc2VzQ2VDQ4JndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank"> 40引脚母对母，将GPIO输出连接到试验板上。您只能使用跳线，但适配器会使事情变得更容易，并有助于防止损坏Raspberry Pi上的GPIO引脚。如果您选择不购买带T型适配器的40针电缆，您需要购买</a><a class="ae mj" href="https://www.amazon.com/SinLoon-Breadboard-Arduino-Circuit-40-Pack/dp/B08M3QLL3Q/ref=pd_sbs_7/143-0445142-7950409?pd_rd_w=sVLrc&amp;pf_rd_p=8b76d7a7-ab83-4ddc-a92d-e3e33bfdbf03&amp;pf_rd_r=CDM5TGJT03VKF0ZFB577&amp;pd_rd_r=8e58fd82-8503-41cf-b8f2-c78eaeb78d25&amp;pd_rd_wg=tT1U0&amp;pd_rd_i=B08M3QLL3Q&amp;psc=1" rel="noopener ugc nofollow" target="_blank">公母跳线</a>。然而，单独购买所有这些东西会比一套花费更多。<a class="ae mj" href="https://www.amazon.com/dp/B06WP7169Y/ref=sspa_dk_detail_5?psc=1&amp;pd_rd_i=B06WP7169Y&amp;pd_rd_w=OZVyf&amp;pf_rd_p=887084a2-5c34-4113-a4f8-b7947847c308&amp;pd_rd_wg=0V0IH&amp;pf_rd_r=623YJTBQ2CN2B2GYXQG5&amp;pd_rd_r=faa61f0f-3aec-4cf0-8e7e-d44eb1b3b92f&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyUVlDQzMzVVZBMFYxJmVuY3J5cHRlZElkPUEwMzExNzk4MUhGSjFSS0VKTlBROCZlbmNyeXB0ZWRBZElkPUEwMzYwNjg2UUdMRU44N0YzNzIwJndpZGdldE5hbWU9c3BfZGV0YWlsJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank">这里有一个简单的工具包，上面所有的</a>。如果你想了解这个系列，我推荐你购买<a class="ae mj" href="https://www.amazon.com/gp/product/B09BMVT4CB/ref=ppx_yo_dt_b_asin_title_o02_s00?ie=UTF8&amp;psc=1" rel="noopener ugc nofollow" target="_blank">sun founder Raspberry Pi Ultimate初学者工具包</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/20bc520ffcdfdd157b1e8f29eb44e48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QdQvl9ZuAKC1ZeNH.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="ne">图片来源:sun founder Ultimate Starter/Raphael套件</em></p></figure><p id="9883" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">您需要一些基本的C编程知识，并且熟悉登录到Raspberry Pi终端，或者登录到一些操作系统版本附带的桌面GUI。根据您采用的方法，您可能需要将键盘和显示器连接到Raspberry Pi。我只是简单地进入Pi。你需要熟悉如何使用像Vi或nano这样的编辑器。您还需要对Linux命令行有基本的了解。</p><p id="1912" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">最后，您需要克隆或派生<a class="ae mj" href="https://github.com/youngkin/gpio" rel="noopener ugc nofollow" target="_blank">我的GPIO库</a>，因为它包含用于访问BCM2835上GPIO功能的底层库代码。正如在其他章节中提到的，这个库代码基于迈克·麦考利开发的<a class="ae mj" href="http://www.airspayce.com/mikem/bcm2835/index.html" rel="noopener ugc nofollow" target="_blank"> BCM2835 C库</a>。</p><h1 id="ce21" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">BCM2835 ARM外设简介</h1><p id="6841" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">本节概述BCM2835外设。它首先概述了各种类型的外设的功能。然后，它将概述BCM2835寻址。理解寻址是理解文章其余部分的基础。最后更详细地讨论了如何使用寄存器来访问外设及其相关的I/O功能。</p><p id="98fd" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这并不是对BCM2835的详尽描述。本文将详细讨论的唯一功能是与GPIO I/O功能的交互，即定义引脚的功能以及设置和清除引脚的值(例如，将其设置为高电平和低电平)，特别是对BCM2835 GPIO进行编程以使LED闪烁。</p><p id="fd60" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">有多种引脚编号方案。Raspberry Pi具有物理pin号码，即印刷在Pi板上的号码。BCM2835有一个称为GPIO编号的编号方案。它与Pi的物理编号方案不同，也不兼容。最后，有些库，如C WiringPi库，有自己的编号方案，与Pi和BCM2835方案不兼容。本文仅使用BCM2835编号方案。有一个很好的<a class="ae mj" href="https://pinout.xyz/" rel="noopener ugc nofollow" target="_blank">引脚排列图</a>可以在这三种编号方案之间进行映射。其中一个引脚支持特定的I/O功能，如下所述，也在该引脚输出图上标出。</p><p id="6760" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">关于术语的快速说明…术语“外围设备”在本文的标题和某些部分使用。对我来说，外设这个术语有点用词不当。让我解释一下。BCM2835最基本的GPIO功能是通过器件上的一组物理引脚实现的。其中一些引脚提供驱动led、传感器和电机等外部设备所需的电源和接地。其他引脚可以通过编程控制，从这些外部设备获取输入或输出。在更高的层面上，GPIO引脚子集支持完整的协议，实现更复杂的功能，如控制电机的速度和方向，以及控制显示文字的LED显示器，如高速公路标志中的文字。这些基本和更复杂的功能通过设置引脚的功能来控制。输入和输出是两个可以设置的功能。还有各种各样的其他将被涵盖。设置引脚的功能描述了BCM2835如何与器件或外设交互。正因为如此，我更喜欢用I/O函数这个术语。我认为这比“外设”一词更准确地描述了这个概念。对我来说，“外围设备”是外部设备。术语<strong class="lp ir"> I/O功能</strong>的第一次使用是下一节的标题。</p><h1 id="d58d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">输入输出功能</h1><p id="4ef9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">BCM2835支持各种I/O功能。这些是<a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>的主题。本节将只详细描述其中的几个功能。还有其他来源，如维基百科，可以提供其他人的信息。</p><p id="5dfa" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">BCM2835支持的主要I/O功能有:</p><ul class=""><li id="fc18" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi nf mv mw mx bi translated">GPIO</li><li id="81b2" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">精力</li><li id="e420" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">脉宽调制（pulse-width modulating的缩写）</li><li id="64bb" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">补助的</li><li id="ed2e" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">理科学士</li><li id="3265" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">直接存储器存取</li><li id="bce8" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">外部大众媒体控制器</li><li id="4aa8" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">中断</li><li id="6441" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">音频(PCM/I2s音频)</li><li id="b052" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">系统记时器</li><li id="4346" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">通用非同步收发传输器(Universal Asynchronous Receiver/Transmitter)</li></ul><p id="9904" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">由于我对前三种I/O功能(GPIO、SPI和PWM)有直接经验，本节将重点讨论这些功能。这将提供足够的背景知识，以便对BCM2835的功能有一个基本的了解，并利用下面的寻址和寄存器部分的信息来了解和使用其余的I/O功能。</p><h2 id="c269" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">通用输入/输出</h2><p id="0130" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">GPIO代表通用输入输出。在BCM2835 ARM外设指南中，术语GPIO指的是物理引脚的最通用或最基本的控制级别。这是用来控制引脚功能的，例如将其设置为输入或输出引脚，或者更高级的I/O功能，如SPI和PWM。它还用于设置或获取pin的值。数值在概念上被称为高电平和低电平，但它们由通过引脚的电压或电压缺失来表示。引脚还有其他类型的设置。这些设置之一用于控制是否在引脚电压变化的上升沿或下降沿检测状态变化。另一种设置控制连接到每个引脚的所谓上拉/下拉电阻。当引脚电压处于不确定状态时，这些电阻用于明确控制引脚的值，1或0。本教程对为什么需要上拉和下拉电阻有一个合理的解释。</p><p id="ab5a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">与本文相关的代码导致LED闪烁。实现这一点需要以下步骤:</p><ol class=""><li id="e7e0" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">将引脚的功能设置为输出，即，为了向LED发送信号，它将被写入。</li><li id="e3e3" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">向引脚写入低电平，使LED开启。</li><li id="6ad0" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">中止</li><li id="bba0" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">向引脚写入高电平，使LED关闭。</li><li id="38d4" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">重复步骤2至4。</li></ol><p id="6e38" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">实现这一点需要使用GPIO I/O功能。更准确地说，它使用GPIO寄存器来设置引脚的功能(例如输出)并控制外设(本例中为LED)的行为。</p><h2 id="b5bc" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">SPI(串行外设接口)</h2><p id="2fcf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">SPI用于将数据串行发送到可以并行接受或要求数据的外设。这很有帮助，因为仅使用3个GPIO引脚就可以写入相对较大的一组并行输入，不包括电源(VCC)和地(GND)。如果不使用SPI，每个并行输入需要一个GPIO引脚。这很容易被禁止，因为引脚是有限的资源。让我们通过一个例子来看看这是如何工作的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e4d1c076bc1e85d70591e147bbb0280a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*kpdTEOQ_e5pvTjLdunyqhA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="1a5f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">上图显示的是MAX7219 LED点阵显示屏。它通常用于显示任意形状，如字母、数字和笑脸。它控制一个8×8的led矩阵。控制一个LED需要1个引脚，不包括电源或地。一个8×8的LED矩阵有64个LED。这个数字远远超过标准Raspberry Pis上可用的26或40个GPIO引脚。如下所述，利用SPI需要的GPIO引脚要少得多。</p><p id="d5ff" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">MAX7219具有以下输入引脚:</p><ol class=""><li id="bc14" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">DIN —这是串行数据输入引脚。</li><li id="475a" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">CS —这通常称为片选(CS)或片使能(CE)引脚。</li><li id="3a33" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">CLK —此引脚连接到Raspberry Pi上的时钟引脚，用于同步Raspberry Pi和MAX7219之间的数据传输。</li></ol><p id="9d68" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">还有2个引脚不用于控制MAX7219。</p><ol class=""><li id="f8a7" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">VCC——这是电源输入引脚。它连接到Raspberry Pi上的电源，通常是3.3v电源。</li><li id="c3a6" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">GND——这是接地引脚。它连接到Raspberry Pi的接地引脚。</li></ol><p id="a9fa" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">从Raspberry Pi到MAX7219至少需要3个GPIO引脚，特别是DIN、CS和CLK引脚。Raspberry Pi只需使用这三个引脚，就能以一种成本(引脚方式)高效的方式控制所有64个led。通常的方法是使用Raspberry Pi引脚来驱动DIN、CS和CLK引脚。这3个引脚被命名为:</p><ol class=""><li id="0943" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">(SPI)MOSI —这代表主机输出从机输入。MOSI引脚将连接到MAX7219 DIN引脚，用于向MAX7219(或任何SPI外设)发送串行数据信号。</li><li id="5144" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">(SPI)SCLK —这些代表SPI时钟。此引脚将连接到MAX7219 CLK引脚。它用作同步BCM2835和MAX7219(或任何SPI外设)之间数据传输的时钟信号源。当MOSI引脚和SCLK引脚都被设为高电平时，数据传输就会发生。</li><li id="32b3" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">(SPI)CS或(SPI)CE——代表片选或片使能。无论哪种情况，将引脚设为低电平都会指示MAX7219接受数据，如前所述。</li></ol><blockquote class="nt nu nv"><p id="4e22" class="ln lo nw lp b lq mk jr ls lt ml ju lv nx mm ly lz ny mn mc md nz mo mg mh mi ij bi translated">我很不情愿地使用“主人”和“奴隶”这两个词。然而，我在SPI上阅读的所有文档中都使用了这些术语。为了避免混淆，我将继续使用它们。</p></blockquote><p id="f23b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Raspberry Pi的SPI功能可能需要多达5个GPIO引脚。这两个附加引脚是:</p><ol class=""><li id="c5db" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">(SPI)MISO —代表主机输入从机输出。此引脚允许MAX7219(或任何SPI外设)将数据发送回BCM2835。</li><li id="48a1" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">(SPI)CS或(SPI)CE——这是第二个片选/片使能引脚。第二个CS/CE引脚允许BCM2835控制2个SPI外设。如上所述，当CS/CE引脚设为低电平时，SPI外设将接受来自BCM2835的数据。因此，通过将一个CS/CE引脚设为高电平，另一个设为低电平，我们可以控制哪个从机可以接收和发送数据。文章<a class="ae mj" href="https://adikedia.com/2016/08/10/using-multiple-spi-slave-devices-with-wiringpi/" rel="noopener ugc nofollow" target="_blank">将多个SPI从器件与Raspberry Pi </a>配合使用提供了有关如何使用2个CE/CS引脚的更多信息。下图说明了这是如何实现的:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d485e81b97a0274bc522d69d841fa2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/0*3oddhTT2rIGAQUVv.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="ne">图片来源:BCM2835 ARM外设指南</em></p></figure><p id="a96f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">BCM2835的主SPI接口SPI0通过GPIO引脚7–11实现。引脚7和8是BCM2835上可用的2个CE/CS引脚。引脚9是MISO，10是MOSI，11是时钟(SPICLK/SCLK)。BCM2835有两个辅助SPI接口:SPI1(也称为AUX_SPI0)和SPI2(也称为AUX_SPI1)。根据BCM2835 ARM外设指南，SPI1位于引脚16–21，SPI2位于引脚35–39。这些辅助接口可通过AUX I/O功能获得。</p><p id="55b0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下图显示了一个常用于将BCM2835 GPIO引脚连接到试验板的GPIO扩展板。这些引脚标有GPIO引脚编号或它们支持的I/O功能(例如SPI)。注意，SPI引脚在电路板上使用与上述相同的术语进行标记:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/a4513ec290c479985bbd4389522bb4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*WLl3HwOTlwvJaHB2.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:Sunfounder</p></figure><p id="a360" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">除了MAX7219之外，SPI还可以用来控制各种外设来显示图像，从触摸屏接收输入，并与各种传感器进行交互。<a class="ae mj" href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface" rel="noopener ugc nofollow" target="_blank">维基百科有一篇很好的文章</a>更详细地描述了SPI。</p><p id="66da" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我的文章标题为<a class="ae mj" href="http://youngkin.github.io/post/spidotmatrixmodule/" rel="noopener ugc nofollow" target="_blank">Raspberry Pi GPIO——使用SPI在MAX7219点阵显示模块上显示任意图案</a>,详细介绍了SPI I/O功能以及如何对其进行编程。与本文类似，它还详细介绍了如何使用BCM2835上的相关寄存器直接对BCM2835进行编程，但针对SPI而不是通用GPIO I/O功能。通过阅读该文章，您将更深入地了解如何使用BCM2835寄存器对BCM2835支持的I/O功能进行编程。</p><h2 id="9d20" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">脉宽调制</h2><p id="1113" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">PWM用于将BCM2835产生的数字信号转换为模拟信号。从某种意义上说，它不是真正的模拟信号。它仍然是一个数字信号，但它的周期如此之快，就像视频一样，看起来像是一个模拟信号。许多外设，如电动机、可调光led和彩色led，都需要模拟信号。与SPI一样，可以使能专用引脚来利用PWM I/O功能。这些是GPIO引脚12、13、18和19。通过这些引脚，BCM2835支持硬件PWM。BCM2835内置PWM功能。它实现了一个基于硬件的时钟环路，控制模拟信号的频率。可以使用其他GPIO引脚进行PWM，这称为软件PWM。然而，在软件PWM中，时钟环路是在Raspberry Pi CPU上运行的代码中编写的。因为CPU正在做许多其他事情，所以不可能产生可靠的时钟信号。这可能会导致一些不良的副作用，例如闪烁的LED代替了暗淡的LED。参见我的文章<a class="ae mj" href="https://youngkin.github.io/post/sunfoundergpionotesrgbled/" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi GPIO in Go和C — RGB LED </a>和<a class="ae mj" href="https://youngkin.github.io/post/pulsewidthmodulationraspberrypi/" rel="noopener ugc nofollow" target="_blank">dummy的脉冲宽度调制</a>，了解更多关于PWM的信息以及使用中的PWM示例。</p><h1 id="2b60" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">演说</h1><p id="60f5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">所有GPIO I/O功能都是通过寄存器访问的。这些寄存器位于片上存储器的不同偏移位置。访问寄存器需要了解BCM2835和Raspberry Pi的寻址方式。这是来自<a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>第1.2.1节的图表，显示了存储器如何从Pi的物理地址映射到BCM2835地址。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/fc5b6602bae34db274f71fb1d87af1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wRzTSl5tmelqdiZE.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="ne"> BCM2835寻址:图像信用BCM2835 ARM外设指南</em></p></figure><p id="1457" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">Raspberry Pi将BCM2835存储器映射到Pi的物理地址<code class="fe od oe of og b">0x2000 0000</code>。这显示在标有“ARM物理地址”的中间一栏中。标有I/o外设的灰色阴影区域是BCM2835外设(如GPIO引脚)的Pi物理存储位置。向左移动，你会看到一个标有“VC/ARM MMU”的金色盒子。这是负责将Pi的物理内存映射到BCM2835内存的<a class="ae mj" href="https://en.wikipedia.org/wiki/Memory_management_unit" rel="noopener ugc nofollow" target="_blank">内存管理单元</a>。沿着中间一列的“I/O外设”分区的线，通过VC/ARM MMU，到最左边一列的“VC CPU总线地址”,通向BCM2835的CPU地址总线上的“I/O外设”分区。它的地址是<code class="fe od oe of og b">0x7E00 0000</code>。</p><p id="2c14" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">I/O外设地址可以通过两种方式之一提供给应用程序。传统的方法是通过安装在文件系统上的<code class="fe od oe of og b">/dev/mem</code>设备。访问此设备需要root权限。从Raspberry Pi 2开始，一种更新的方法变得可用。该方法通过<code class="fe od oe of og b">/dev/gpio</code>访问I/O外设地址。使用这种方法的一个优点是它不需要root访问权限。使用这种方法的缺点是只能访问BCM2835的GPIO I/O功能。这意味着PWM和SPI等高级功能不可用。使用<code class="fe od oe of og b">/dev/mem</code>访问I/O外设也需要更多的工作，即将物理内存从<code class="fe od oe of og b">/dev/mem</code>映射到应用程序的虚拟内存。这将在后面详细介绍。</p><blockquote class="nt nu nv"><p id="8138" class="ln lo nw lp b lq mk jr ls lt ml ju lv nx mm ly lz ny mn mc md nz mo mg mh mi ij bi translated">还有第三种方式与GPIO寄存器接口。对于SPI，有2个器件(通常在许多Raspberry Pi型号上提供)，<code class="fe od oe of og b">/dev/spidev0.0</code>和通过<code class="fe od oe of og b">ioctl()</code>的<code class="fe od oe of og b">/dev/spidev0.1</code>。这种方法不在本文讨论范围之内。</p></blockquote><h1 id="5adf" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">登记</h1><p id="b4b8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如上所述，通过BCM2835上的寄存器来指定一个或一组引脚的I/O功能。每个I/O功能都有一个相关的寄存器集，位于BCM2835的I/O外设地址空间内的某个偏移量处。例如，GPIO寄存器组从CPU总线地址<code class="fe od oe of og b">0x7E20 0000</code>开始。SPI寄存器组从CPU总线地址偏移<code class="fe od oe of og b">0x7E20 4000</code>开始。PWM寄存器组从偏移量<code class="fe od oe of og b">0x7E20 C000</code>开始。等等，每个I/O函数都有自己的一组寄存器来管理它的行为。也就是说，它们的工作原理都是一样的。也就是说，找到每个I/O功能的寄存器组的开始的偏移量，然后在适当的偏移量设置(或获取)适当的位来控制行为。为了使这个例子更清楚，并突出更多的细节，让我们做一个如何控制GPIO引脚使LED闪烁的高级演练。</p><p id="7fac" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如前所述，GPIO寄存器从总线地址<code class="fe od oe of og b">0x7e2000 0000</code>开始。从第90页开始的<a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank"> BCM2835 ARM外设指南</a>的第6.1节提供了有关GPIO寄存器的详细信息。要使LED闪烁，我们首先需要指定引脚的功能，在这种情况下是输出，然后在高低之间切换LED的值。</p><h2 id="d930" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">指定引脚的功能</h2><p id="0b19" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先，需要设置引脚的I/O功能。引脚的功能通过8个可选功能之一来定义。对每个函数进行编码需要3位，000–111。这些位包含在所谓的GPIO功能选择寄存器中。每个寄存器的长度为32位。因此，每个32位寄存器可以控制10个引脚，剩余2位。为了控制所有的GPIO引脚，有6个功能选择寄存器。如果支持，BCM2835可以通过功能选择寄存器控制多达54个引脚(在Raspberry Pi 3B+上只有40个引脚可用)。支持54个引脚，每个寄存器10个引脚，需要6个寄存器。第一个功能选择寄存器位于<code class="fe od oe of og b">0x7E20 0000</code>，从GPIO寄存器组的开始处零偏移。第6个功能选择寄存器从偏移量<code class="fe od oe of og b">0x7E20 0014</code>开始。这8个可选功能是:</p><ul class=""><li id="6680" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi nf mv mw mx bi translated">输入—由位模式<code class="fe od oe of og b">000</code>表示</li><li id="a146" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">输出—由位模式<code class="fe od oe of og b">001</code>表示</li><li id="2559" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">以及分别由位模式<code class="fe od oe of og b">010</code>到<code class="fe od oe of og b">111</code>表示的交替功能0到5。</li></ul><p id="2a1b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在本例中，我们将引脚17用作输出引脚。查看BCM2835 ARM外设指南，我们看到引脚17位于功能选择寄存器1(也称为GPFSEL1)中。GPFSEL1位于偏移量<code class="fe od oe of og b">0x7E20 0004</code>。寄存器中引脚17的功能选择失调位于第21-23位。回想一下，输出位模式是<code class="fe od oe of og b">001</code>,因此我们需要将该位模式放在位21-23中。在下面的编码部分，我们将看到这是如何实现的。</p><h2 id="b8be" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">设置pin值</h2><p id="ea69" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">本文假设引脚17连接到LED的接地端子(阴极)。这意味着我们必须将引脚设置为低电平，以便电流从电源输入端流向阳极，通过引脚17到达LED地，点亮LED。将引脚设为高电平将导致LED关闭。在高低之间切换会导致LED闪烁，这正是我们所期待的。</p><p id="b817" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">GPIO引脚值通过GPIO引脚输出设置寄存器控制。有2个GPIO引脚输出设置寄存器。引脚17在第一个寄存器中，GPIO引脚输出设置0，也称为GPSET0，位于GPIO寄存器偏移量<code class="fe od oe of og b">0x7E20 002C</code>。引脚17位于GPSET0内的位偏移17处。将位17设为1会将寄存器设为高电平。GPIO引脚输出设置寄存器只能将一个引脚设为高电平，将一个引脚设为0不起作用。但是回想一下，我们需要将引脚设置为低电平。既然在GPSET0中设置一个引脚不会导致引脚被设置为低电平，我们该如何实现呢？原来还有另一组GPIO寄存器，称为GPIO引脚输出清零寄存器。这些用来设置一个引脚的值为低。引脚17在GPIO引脚输出清零寄存器0(也称为GPCLR0)中，从偏移量<code class="fe od oe of og b">0x7E20 0028</code>开始。它在寄存器中的位置也是在第17位。将位17设为1会将引脚设为低电平。因此，我们需要将一个<code class="fe od oe of og b">1</code>向左移动到第17位，以便打开LED。我们将使用GPSET0关闭LED。与指定引脚的功能一样，如何完成这一点将在本文后面介绍。依次使用GPCLR0和GPSET0寄存器，我们可以使LED闪烁。</p><h2 id="5def" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">其他GPIO设置</h2><p id="080f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">除了选择功能和设置/清除引脚值之外，GPIO寄存器集还可以用来控制GPIO引脚的许多其他功能。它也可以用来读取一个引脚的值。如上文“I/O功能”部分所述，可以管理的其他事项包括指定如何检测状态变化(上升/下降沿检测)以及如何在引脚处于不确定状态时设置其电压(上拉/下拉电阻)。讨论这些寄存器是一个高级主题，超出了本文的范围。</p><h1 id="ad93" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">设置和代码</h1><p id="b71b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">本节从一个使LED闪烁的程序开始。它相当简单，将显示BCM2835编程所需的基本步骤。本节的下一部分将更详细地介绍BCM2835编程。但在此之前，先来看看如何连接试验板，使其与闪烁的LED示例一起工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/5c08e8f40f44c63b34f9b705c361eae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CjtBu2b0bJo540n1.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="ne">图片来源:Sunfounder </em></p></figure><p id="fe0a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">试验板的接线应该如上图所示。注意，LED的(弯曲的)长引线(阳极)通过电阻器连接到3.3伏电源引脚，阴极(或地)连接到GPIO引脚17。如果你不熟悉试验板和试验板图，这个<a class="ae mj" href="https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard" rel="noopener ugc nofollow" target="_blank">试验板教程</a>应该会有帮助。</p><p id="f3e4" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">本节将首先描述使LED闪烁的主程序。之后，将详细介绍与BCM2835交互的代码如何控制I/O功能。</p><p id="ccd3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">本文中的所有代码都可以在<a class="ae mj" href="https://github.com/youngkin/gpio/tree/main/ledblink" rel="noopener ugc nofollow" target="_blank"> my gpio repository </a>的<code class="fe od oe of og b">ledblink</code>目录中找到。</p><h1 id="ee4f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">控制LED —主程序</h1><p id="6d94" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">包含该代码的文件的代码可以在<code class="fe od oe of og b"><a class="ae mj" href="https://github.com/youngkin/gpio/blob/main/ledblink/blinkinglednolib.c" rel="noopener ugc nofollow" target="_blank">gpio/ledblink/blinkinglednolib.c</a></code>找到。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8d83" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">第一段代码展示了几件重要的事情:</p><ol class=""><li id="b9fc" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">第1行给出了编译和链接程序的命令。</li><li id="4824" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">第3行提供了导入直接与BCM2835交互的BCM2835函数所需的包含指令。</li><li id="e123" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">第8行定义了用于控制LED的BCM GPIO引脚。它符合上面的接线图。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="133e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个代码片段声明了一个中断处理程序，用于优雅地退出程序。这确保了引脚和LED处于已知状态。中断处理程序的定义将在后面给出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="266b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个代码片段显示了main函数的开始。</p><p id="9e10" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第3行</strong>注册SIGINT信号的中断处理程序(即ctrl-C)。</p><p id="c829" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第5–10行</strong>初始化BCM2835 GPIO功能。简而言之，它在主存储器中找到GPIO外设的偏移量和长度，并将其映射到<code class="fe od oe of og b">/dev/mem</code>，这样就可以在程序中安全地访问它。然后，它将变量设置为各种功能寄存器(如GPIO或SPI)的偏移量。如果初始化失败，程序退出。下面将更详细地描述<code class="fe od oe of og b">bcm_init()</code>功能。</p><p id="eb26" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第13行</strong>将<code class="fe od oe of og b">LEDPIN</code>设置为GPIO输出功能。这允许程序将值(高或低)写入引脚。下面将更详细地描述<code class="fe od oe of og b">bcm_gpio_fsel()</code>功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="7152" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个代码片段实现了程序的主要功能。<strong class="lp ir">第2–10行</strong>使LED闪烁。</p><p id="250b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第5行和第8行</strong>通过调用<code class="fe od oe of og b">bcm_gpio_write()</code>设置<code class="fe od oe of og b">LEDPIN</code>的值，并将引脚的值设置为<code class="fe od oe of og b">LOW</code>打开LED，或<code class="fe od oe of og b">HIGH</code>关闭LED。<code class="fe od oe of og b">LOW</code>关闭LED，因为连接BCM GPIO引脚17和LED的导线连接到LED的接地引脚。要让电流流过，引脚必须设置为0伏。同样，<code class="fe od oe of og b">HIGH</code>关闭LED。<code class="fe od oe of og b">bcm_gpio_write()</code>将在下面更详细地描述。</p><p id="3788" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第6行和第9行</strong>导致程序休眠500毫秒，因此可以观察到LED闪烁。</p><p id="e78c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如注释所述，<strong class="lp ir">第13行</strong>释放<code class="fe od oe of og b">bcm_init()</code>获得的GPIO资源。这也会将GPIO系统设置回已知状态。<code class="fe od oe of og b">bcm_close()</code>将在下面更详细地描述。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="96fa" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个代码片段定义了中断处理函数。<strong class="lp ir">3、4线</strong>先关闭LED，然后释放<code class="fe od oe of og b">bcm_init()</code>获得的GPIO资源。</p><h1 id="e85b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">控制LED —与BCM2835交互</h1><p id="2a79" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">本节描述代码如何与GPIO外设交互并控制它们，特别是设置与BCM 2835 I/O功能相关的各种寄存器的值。设置寄存器值用于控制GPIO外设，读取寄存器值允许访问相关GPIO外设的当前状态。</p><p id="044a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个部分的代码可以在<a class="ae mj" href="https://github.com/youngkin/gpio" rel="noopener ugc nofollow" target="_blank">我的gpio库</a>的<a class="ae mj" href="https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.c" rel="noopener ugc nofollow" target="_blank"> bcmfuncs.c </a>中找到。<a class="ae mj" href="https://github.com/youngkin/gpio/blob/main/ledblink/bcmfuncs.h" rel="noopener ugc nofollow" target="_blank">头文件可以在bcmfuncs.h </a>中找到。</p><h2 id="0c2f" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_init()</h2><p id="b06d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">上面关于寄存器的部分提到，BCM2835外设上的所有操作都是通过操作与该类型外设相关的寄存器来完成的。<code class="fe od oe of og b">bcm_init()</code>的目的是确定所有类型寄存器的地址偏移量，如GPIO、PWM、SPI等。以便可以控制它们的相关外围设备。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1562" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个代码片段显示了<code class="fe od oe of og b">bcm_init()</code>函数的开始。</p><p id="431e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第10行</strong>打开<code class="fe od oe of og b">BCM_RPI2_DT_FILENAME</code>。如注释所示，<code class="fe od oe of og b">fopen()</code>调用中的<code class="fe od oe of og b">rb</code>打开一个二进制文件进行读取。<code class="fe od oe of og b">BCM_RPI2_DT_FILENAME</code>在相关的<code class="fe od oe of og b">bcmfuncs.h</code>头文件中定义。它的值是<code class="fe od oe of og b">/proc/device-tree/soc/ranges</code>。如<a class="ae mj" href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html" rel="noopener ugc nofollow" target="_blank"> Linux和设备树</a>中所述，</p><blockquote class="nt nu nv"><p id="d5bf" class="ln lo nw lp b lq mk jr ls lt ml ju lv nx mm ly lz ny mn mc md nz mo mg mh mi ij bi translated">操作系统使用设备树在运行时发现硬件的拓扑结构，从而支持大多数可用的硬件，而无需硬编码信息(假设驱动程序可用于所有设备)。</p></blockquote><p id="6f62" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">设备树包含的信息之一(对我们的目的很重要)是BCM2835物理地址空间中I/O外设分区的位置和长度。下面是树莓派3B+上<code class="fe od oe of og b">/proc/device-tree/soc/ranges</code>内容的十六进制转储:</p><pre class="kg kh ki kj gt ok og ol om aw on bi"><span id="7554" class="ng kw iq og b gy oo op l oq or">pi@pi-node1:/ $ hexdump -C /proc/device-tree/soc/ranges<br/>00000000  7e 00 00 00 3f 00 00 00  01 00 00 00 40 00 00 00  |~...?.......@...|<br/>00000010  40 00 00 00 00 00 10 00                           |@.......|<br/>00000018</span></pre><p id="ee1c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们将在下一个代码片段中引用它。根据<a class="ae mj" href="https://www.devicetree.org/specifications/" rel="noopener ugc nofollow" target="_blank">devicetree.org</a>，在<a class="ae mj" href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.4-rc1/devicetree-specification-v0.4-rc1.pdf" rel="noopener ugc nofollow" target="_blank">device tree规范</a>v 0.4-rc1中，<code class="fe od oe of og b">soc/ranges</code>属性定义如下:</p><blockquote class="nt nu nv"><p id="fc64" class="ln lo nw lp b lq mk jr ls lt ml ju lv nx mm ly lz ny mn mc md nz mo mg mh mi ij bi translated">ranges属性提供了一种定义总线地址空间(子地址空间)和总线节点父地址空间(父地址空间)之间的映射或转换的方法。ranges属性的值的格式是任意数量的三元组(子总线地址、父总线地址、长度)</p></blockquote><p id="d808" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在I/O外设地址块的情况下，如上述<a class="ae mj" href="https://youngkin.github.io/post/gpioprogramming/#addressing" rel="noopener ugc nofollow" target="_blank">寻址部分</a>所述，<em class="nw">“子总线地址”</em>是指<em class="nw">“VC CPU总线地址”</em>内存空间中的<em class="nw">“I/O外设”</em>地址块。<em class="nw">“母总线地址”</em>是指<em class="nw">“ARM物理地址”</em>块中的<em class="nw">“I/O外设”</em>地址块。<em class="nw"/>的“长度”是指<em class="nw">【I/O外设】</em>地址块的实际长度。Raspberry Pi 3B+具有32位地址空间，因此三元组中的每个值都是32位或4个字节。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ff7e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下一段代码使用来自<code class="fe od oe of og b">/proc/device-tree/soc/ranges</code>的数据找到I/O外设块的<em class="nw">父总线地址</em>和<em class="nw">长度</em>。回想一下，父总线地址是三元组中的第二个条目，它也定义了子总线地址和长度。<strong class="lp ir">第1到4行</strong>将<em class="nw">母总线地址</em>的内容，即<code class="fe od oe of og b">buf</code>偏移量4到7处的字节，移入<code class="fe od oe of og b">base_address</code>。<code class="fe od oe of og b">3F</code>被移入<code class="fe od oe of og b">base_address</code>的高位字节。剩余的<code class="fe od oe of og b">buf</code>单元同样从左(最高有效字节)到右(最低有效字节)移位到<code class="fe od oe of og b">base_address</code>。换档完成后，<code class="fe od oe of og b">base_address</code>将被设置为<code class="fe od oe of og b">0x3F000000</code>。回头看看上面<a class="ae mj" href="https://youngkin.github.io/post/gpioprogramming/#addressing" rel="noopener ugc nofollow" target="_blank">寻址部分</a>中的图表，你会注意到它与<em class="nw"> I/O外设</em>地址块中<code class="fe od oe of og b">0x20000000</code>的基址<strong class="lp ir"> </strong>不匹配<em class="nw"> ARM物理地址</em>。这是因为寻址部分中的图表是针对Raspberry Pi 1的。这种偏移在Raspberry Pi型号2 &amp; 3中有所不同。在Raspberry Pi 4模型中又有所不同。</p><p id="b207" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">继续，以与<code class="fe od oe of og b">base_address</code>类似的方式，<strong class="lp ir">线6至9 </strong>通过从<code class="fe od oe of og b">buf</code>偏移8至11移动到<code class="fe od oe of og b">peri-size</code>获得<em class="nw">长度</em>。对于树莓派3B+，<code class="fe od oe of og b">0x01000000</code>是地址块的预期长度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0433" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下一个代码片段完成了从<code class="fe od oe of og b">/proc/device-tree/soc/ranges</code>获取寻址信息。具体来说，它验证了<em class="nw">“子总线地址”</em>和<em class="nw">“父总线地址”</em>具有预期值。回想一下，<em class="nw">“子总线地址”</em>是地址/长度三元组的第一个值，<code class="fe od oe of og b">buf</code>偏移量0到3。第1行到第6行执行以下操作:</p><ol class=""><li id="b1a0" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated"><strong class="lp ir">行1到4 </strong>验证<code class="fe od oe of og b">buf</code>、<em class="nw">子总线地址</em>的前4个字节是否为<code class="fe od oe of og b">0x7E000000</code>，如<em class="nw">“VC CPU总线地址”</em>内存空间中的<em class="nw">、【I/O外设】</em>地址块所定义。</li><li id="a758" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">第5行</strong>验证<em class="nw">父总线地址</em>、<code class="fe od oe of og b">base_address</code>是否与Raspberry Pi模型1到4的预期基址之一相匹配。</li></ol><p id="689c" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第7行和第8行</strong>然后将<em class="nw"> I/O外设</em>地址块的基址和长度设置为将在程序其余部分使用的变量。这一行的重要之处在于，它将源变量转换为目标变量所期望的类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="89fe" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下一段代码将BCM2835的<em class="nw">“I/O外设”</em>地址块映射到<code class="fe od oe of og b">/dev/mem</code>的<em class="nw">“ARM物理地址”</em>内存空间中，以便它可以安全地用于程序中。</p><p id="ee6d" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第1行</strong>首先检查运行程序的用户是否以<em class="nw"> root </em>身份运行(或者是<em class="nw"> root </em>用户或者是<em class="nw"> sudo </em>)。否则，<code class="fe od oe of og b">/dev/mem</code>装置不能使用。<code class="fe od oe of og b">/dev/mem</code>提供对CPU内存的无限制访问。因为这显然是一件危险的事情，所以它的使用仅限于<em class="nw">根</em>。您可能还记得<a class="ae mj" href="https://youngkin.github.io/post/gpioprogramming/#addressing" rel="noopener ugc nofollow" target="_blank">寻址部分</a>，还有一个<code class="fe od oe of og b">/dev/mem</code>、<code class="fe od oe of og b">/dev/gpio</code>的替代方案。这将在本节的后面部分显示。</p><p id="020f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">线4 </strong>打开<code class="fe od oe of og b">/dev/mem</code>准备映射操作。</p><p id="f04a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第13行</strong>将<code class="fe od oe of og b">bcm_peripherals</code>变量分配给<em class="nw"> I/O外设</em>地址块的偏移量和长度<code class="fe od oe of og b">bcm_peripherals_base</code>和<code class="fe od oe of og b">bcm-peripherals_size</code>。这种映射有效地限制了程序对物理存储器的<em class="nw"> I/O外设</em>地址块的访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8e11" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下一段代码计算各种类型寄存器(例如GPIO、PWM、SPI等)的失调。每个偏移量都相对于<code class="fe od oe of og b">bcm_peripherals</code>的值，它是前面代码片段中<code class="fe od oe of og b">mapmem()</code>操作的结果。因此，要获得像GPIO寄存器组这样的寄存器组的地址，我们需要将<code class="fe od oe of og b">BCM_GPIO_BASE</code>加到<code class="fe od oe of og b">bcm_peripherals</code>基址上。但是您可能已经注意到，在将这些偏移量添加到<code class="fe od oe of og b">bcm_peripherals</code>之前，代码会将它们除以4。这些被指定为整数的偏移量，例如<code class="fe od oe of og b">BCM_GPIO_BASE</code>，指向特定的字节地址，即在8位边界处。<code class="fe od oe of og b">bcm_peripherals</code>被指定为<code class="fe od oe of og b">uint32_t*</code>，一个指针。你不能天真地给指针加一个整数。您可能还记得，指针算法是基于相关变量的类型大小来操作指针变量的。对于<code class="fe od oe of og b">unint32_t</code>，它们的大小是32位或4字节。将一个<code class="fe od oe of og b">uint32_t</code>指针加1将导致该指针指向下一个<code class="fe od oe of og b">uint32_t</code>，从当前位置开始4个字节。天真地将像<code class="fe od oe of og b">BCM_GPIO_BASE</code>这样的偏移量添加到<code class="fe od oe of og b">bcm_peripherals</code>会导致<code class="fe od oe of og b">bcm_peripherals</code>指向内存中比当前位置晚4秒的位置，而不是我们想要的比当前位置晚1秒的位置。这就是为什么像<code class="fe od oe of og b">BCM_GPIO_BASE</code>这样的每个寄存器类型偏移在加到<code class="fe od oe of og b">bcm_peripherals</code>之前要除以4。</p><blockquote class="nt nu nv"><p id="7f9a" class="ln lo nw lp b lq mk jr ls lt ml ju lv nx mm ly lz ny mn mc md nz mo mg mh mi ij bi translated">如果你是C语言的新手，你可能不知道指针算法本身是危险的。很难确切知道指针运算的结果是指针将引用什么。指针可能是意外的类型或具有意外的值。这可能会导致难以调试的意外行为。在某些情况下，例如执行除法，指向包含零值的意外位置将导致程序突然结束(出现分段错误)。这很好，这样你就知道出了问题，甚至知道问题出在哪里。指针甚至可能指向程序地址空间之外，这可能导致系统崩溃。然而在我们的例子中，寄存器位置和相关类型是众所周知的，使用指针是相对安全的。也就是说，只要我们正确地执行指针算法…</p></blockquote><h2 id="e1d7" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_fsel()</h2><p id="bf6f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe od oe of og b">bcm_fsel</code>负责设置与给定管脚相关的I/O功能。总共有8种功能可用。其中一个定义了相关联的管脚将被设置为输入管脚，这意味着它将被读取。另一个函数将相关联的引脚定义为输出引脚，这意味着该引脚将被写入。其余6个被称为“备用功能”，并被赋予类似“备用功能0”的名称。为各种备用功能分配的I/O功能因各种GPIO引脚而异。例如，将BCM GPIO引脚17设置为备用功能4可将其I/O功能定义为SPI。它实际上将该引脚定义为SPI功能的一个特定子集，称为芯片使能或芯片选择，但这是后续文章的主题。回想一下，在上面的<code class="fe od oe of og b">main()</code>中，函数被设置为<code class="fe od oe of og b">BCM_GPIO_FSEL_OUTP</code>，它将引脚17定义为输出引脚。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="16ae" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">尽管这个函数很短，但它还是有很多内容。</p><p id="9e3f" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第1行</strong>将函数定义为采用两个参数<code class="fe od oe of og b">pin</code>和<code class="fe od oe of og b">mode</code>。很明显<code class="fe od oe of og b">pin</code>是要分配功能的引脚。<code class="fe od oe of og b">mode</code>是与<code class="fe od oe of og b">pin</code>关联的I/O功能。<code class="fe od oe of og b">mode</code>实际上是分配给特定寄存器偏移量的位模式。位模式分配在第6节<strong class="lp ir"> GPIO </strong>的<a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 I/O外设数据表</a>中定义。模式定义如下:</p><pre class="kg kh ki kj gt ok og ol om aw on bi"><span id="ac05" class="ng kw iq og b gy oo op l oq or">000 = GPIO Pin X is an input<br/>001 = GPIO Pin X is an output<br/>100 = GPIO Pin X takes alternate function 0<br/>101 = GPIO Pin X takes alternate function 1<br/>110 = GPIO Pin X takes alternate function 2<br/>111 = GPIO Pin X takes alternate function 3<br/>011 = GPIO Pin X takes alternate function 4<br/>010 = GPIO Pin X takes alternate function 5</span></pre><p id="6741" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">要理解该函数的其余部分，还需要一些额外的背景知识。首先，<a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 I/O外设数据手册</a>第6节显示，共有54个GPIO引脚可通过功能选择寄存器(GPFSEL0-GPFSEL5)寻址。每个功能选择寄存器的长度为32位。由于上述每个功能选择模式都是3位长，每个功能选择寄存器可以指定10个引脚的I/O功能，剩余2位。每个寄存器10个引脚，总共54个引脚解释了为什么有6个功能选择寄存器，编号为0到5。下面的数学公式就是从这些信息中推导出来的。</p><p id="fe5b" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第3行</strong>定义将根据<code class="fe od oe of og b">mode</code>设置的位的寄存器偏移量<code class="fe od oe of og b">paddr</code>。<code class="fe od oe of og b">BCM_GPFSEL0</code>是功能选择寄存器的基址偏移量，以字节为单位。下面是对这一行中执行的算法的解释。</p><ol class=""><li id="7e3c" class="mp mq iq lp b lq mk lt ml lw mr ma ms me mt mi mu mv mw mx bi translated">请注意，正在执行指针运算。回想一下，指针算法的结果是基于目标变量的类型的(参见上面的<code class="fe od oe of og b">bcm_init()</code>部分)。由于<code class="fe od oe of og b">uint32_t</code>的长度为4字节，因此<code class="fe od oe of og b">BCM_GPFSEL0</code>需要除以4才能正确计算出来。于是<code class="fe od oe of og b">... paddr = bcm_gpio + BCM_GPFSEL0/4 ...</code>。</li><li id="8ad2" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">此外，回想一下，每个寄存器保存10个引脚的功能选择信息。对于给定的引脚，我们需要确定哪个功能选择寄存器(GPFSEL0至GPFSEL5)指定给定引脚的I/O功能。在C #中，产生分数的整数除法的结果将被向下舍入。因此，如果我们将引脚数除以10，<code class="fe od oe of og b">(pin/10</code>，我们将得到正确功能选择寄存器的偏移。因此，引脚9将导致<code class="fe od oe of og b">9/10</code>等于0，这意味着引脚9的功能选择位置在GPFSEL0中。同样，引脚17的<code class="fe od oe of og b">17/10 = 1</code>功能选择寄存器是GPFSEL1。诸如此类。</li></ol><p id="f7b1" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">综上所述，等式<code class="fe od oe of og b">paddr = bcm_gpio + BCM_GPFSEL0/4 + (pin/10)</code>得出适合给定<code class="fe od oe of og b">pin</code>的功能选择寄存器偏移。对于引脚17，这将导致<code class="fe od oe of og b">paddr</code>逻辑指向地址<code class="fe od oe of og b">0x7E20 0004</code>处的GPFSEL1，<code class="fe od oe of og b">7E</code>是总线地址，<code class="fe od oe of og b">20004</code>是GPIO寄存器的偏移量加上GPFSEL1的偏移量，<code class="fe od oe of og b">4</code>，从GPIO寄存器组开始。我说逻辑上是因为<code class="fe od oe of og b">bcm_gpio</code>是从作为<code class="fe od oe of og b">mmap()</code>操作结果返回的地址的偏移。<code class="fe od oe of og b">mmap()</code>返回一个指向进程虚拟内存的指针，而<code class="fe od oe of og b">0x7E20 0004</code>是BCM2835的<em class="nw"> VC CPU总线地址</em>空间中的一个地址。</p><p id="0bb6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第4行</strong>计算给定引脚的功能选择值在功能选择寄存器中的位置。由于我们将使用位移位来设置引脚的功能选择值，因此该位置成为<strong class="lp ir">位移位</strong>的位数，引脚的功能选择值在<code class="fe od oe of og b">mode</code>参数中提供。为了进行计算，我们首先需要找到引脚的逻辑位置，即功能选择寄存器中的哪个3位单元(回想一下，每个功能选择值都是3位长)。对此的计算由<code class="fe od oe of og b">shift = (pin % 10) ...</code>给出。用于销17 <code class="fe od oe of og b">(pin % 17) = 7</code>。因此，引脚17的3位单元位于第7个3位偏移处。接下来，我们必须找到寄存器中的实际位偏移。由于每个功能选择值为3位长，每个引脚的边界是3的倍数，因此完成了<code class="fe od oe of og b">shift = (pin % 10) * 3</code>的计算。对于引脚17，这导致<code class="fe od oe of og b">(17%10)*3</code>等于<code class="fe od oe of og b">7*3</code>，从而导致绝对位偏移为21。查阅第92页的BCM2835 I/O外设数据手册第6节，我们可以确认GPFSEL0寄存器中引脚17的偏移位于位21至23。</p><p id="73e3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在我们来看看<strong class="lp ir">第5行</strong>。当将位的子集设置为给定值时，我们希望保留周围位的值。使用掩模来实现这一点。掩码包含一个(或多个)位，该位位于目标值中我们要更改的位的位置。例如，在位模式<code class="fe od oe of og b">0101 1111</code>中，如果我们想要将位6的值从1设置为0，我们只需要定义一个位序列，其中设置了1位。为了创建最通用的解决方案，我们只需设置最低有效位。因为我们只需要一个位组，我们将掩码定义为十六进制数<code class="fe od oe of og b">0x1</code>，它指定了位模式<code class="fe od oe of og b">0000 0001</code>。接下来，我们需要根据需要移动该位模式，以便将<code class="fe od oe of og b">1</code>位移动到正确的位置。在我们的例子中，由于我们想改变第6位，我们将把掩码模式左移6位，例如<code class="fe od oe of og b">newMask = 0000 0001 &lt;&lt; 6</code>。这导致<code class="fe od oe of og b">newMask</code>等于<code class="fe od oe of og b">0100 00000</code>，这将<code class="fe od oe of og b">1</code>位放置在我们期望的位置6。我们可以直接将掩码定义为<code class="fe od oe of og b">0100 0000</code>，但这不会产生一个通用的解决方案，该方案适用于在任意位位置(如21-23位)设置位所需的任何掩码。</p><p id="9cf8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如<code class="fe od oe of og b">bcmfuncs.h</code>所示，<code class="fe od oe of og b">BCM_GPIO_FSEL_MASK</code>的值为0x7或<code class="fe od oe of og b">0000 0111</code>，这是因为每个GPIO功能选择模式的长度为3位。因此，对于屏蔽3位序列，这是一个有用的位模式。如果我们按照上面第4行的计算，将这个模式移位21的<strong class="lp ir">移位</strong>，我们将得到一个32位的模式，看起来像这样，<code class="fe od oe of og b">0000 0000 1110 0000 0000 0000 0000 0000</code>。该掩码现在位于位位置21-23，这是GPFSEL1功能选择寄存器中引脚17的功能选择模式的位置。</p><p id="bff8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">总之，<strong class="lp ir">行5 </strong>创建设置3位功能选择模式所需的屏蔽，如所提供的<code class="fe od oe of og b">pin</code>参数中的<code class="fe od oe of og b">mode</code>参数所指定。</p><p id="b632" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第6行</strong>创建新的3位值，该值将被放入GPFSEL1寄存器。回想一下，GPFSEL1是一个32位寄存器。为了使用诸如<code class="fe od oe of og b">mode</code>的3比特值在任意位置(例如，比特21-23)设置3比特序列，我们创建一个值掩码，该值掩码将期望位置的比特设置为期望的值。与上面的掩码一样，最通用的解决方案规定这些位从最低有效位置开始设置。假设在我们的示例中，我们希望将引脚17设置为备用功能1。查看上面的位模式，我们可以看到备用功能1的3位值是<code class="fe od oe of og b">101</code>。<code class="fe od oe of og b">mode</code>参数将包含这个值。为了将引脚17设置为备用功能1，我们需要将<code class="fe od oe of og b">0000 0101</code>的<code class="fe od oe of og b">mode</code>位模式左移21位。与第5行一样，第6行以一种通用的方式做到了这一点，<code class="fe od oe of og b">value = mode &lt;&lt; shift</code>。给定我们的值<code class="fe od oe of og b">mode</code>和计算的值<code class="fe od oe of og b">shift</code>，我们得到<code class="fe od oe of og b">0000 0000 1010 0000 0000 0000 0000 0000</code>的32位<code class="fe od oe of og b">value</code>。</p><p id="25b0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">现在我们有了计算GPFSEL1寄存器新值所需的4个变量，<code class="fe od oe of og b">paddr</code>、<code class="fe od oe of og b">mode</code>、<code class="fe od oe of og b">mask</code>和<code class="fe od oe of og b">value</code>。</p><p id="7974" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第7行</strong>调用函数<code class="fe od oe of og b">bcm_peri_set_bits()</code>完成该操作。该操作在一个单独的函数中完成，因为还有其他寄存器值需要设置，我们将在后面看到。</p><h2 id="fcff" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_peri_set_bits()</h2><p id="4513" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe od oe of og b">bcm_peri_set_bits()</code>是使用如上所述的<code class="fe od oe of og b">mask</code>在位置<code class="fe od oe of og b">paddr</code>将32位序列<code class="fe od oe of og b">v</code>设置为新值<code class="fe od oe of og b">value</code>的功能。和<code class="fe od oe of og b">bcm_fsel()</code>一样，这个函数只用了几行代码就完成了很多工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6139" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第3行</strong>使用<code class="fe od oe of og b">bcm_peri_read()</code>读取位于<code class="fe od oe of og b">paddr</code>的32位值<code class="fe od oe of og b">v</code>。稍后将详细介绍。</p><p id="6634" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第4行</strong>将<code class="fe od oe of og b">v</code>设置为新值。回想一下，使用掩码时，可以设置一部分位，而其余位保持不变。第4行分3步完成。首先，它在当前值<code class="fe od oe of og b">v</code>和掩码的补码之间进行位与运算<code class="fe od oe of og b">&amp;</code>。以上一节中的<code class="fe od oe of og b">BCM_GPIO_FSEL_MASK</code>为例，其位值(为简洁起见，只有位位置16和23)从<code class="fe od oe of og b">... 1110 0000 ...</code>反转到<code class="fe od oe of og b">... 0001 1111 ...</code>。当在求反后的<code class="fe od oe of og b">mask</code>和<code class="fe od oe of og b">v</code>之间发生位与时，如在<code class="fe od oe of og b">(v &amp; ~mask)</code>中，只有原始值<code class="fe od oe of og b">v</code>的位21-23被修改，位21-23被重置为<code class="fe od oe of og b">0</code> s。其余位不变。如果<code class="fe od oe of og b">v</code>的位16-23最初被设置为<code class="fe od oe of og b">... 0100 1010 ...</code>，位16-23的新值现在将看起来像<code class="fe od oe of og b">... 0000 1010 ...</code>。在我们的示例中，引脚17的功能选择位已重置为零。请注意，位置16至20的位保持不变。</p><p id="d8c3" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">下一个操作<code class="fe od oe of og b">(value &amp; mask)</code>仅保留新值<code class="fe od oe of og b">value</code>的位置21-23处的比特值，将剩余比特设置为<code class="fe od oe of og b">0</code>。<code class="fe od oe of og b">value</code>的第16-23位是<code class="fe od oe of og b">... 1010 0000 ...</code>,指定引脚17将被设置为替代功能1。操作<code class="fe od oe of og b">... 1010 0000 ... &amp; ... 1110 0000 ...</code>的结果是<code class="fe od oe of og b">... 1010 0000 ...</code>，这是意料之中的。该操作被指定为<code class="fe od oe of og b">(value &amp; mask)</code>，因为我们不能提前说只有位21-23将被复位到<code class="fe od oe of og b">value</code>。<code class="fe od oe of og b">value</code>和<code class="fe od oe of og b">mask</code>都可以在其他位置设置位。</p><p id="4ccf" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">综上所述，第三步也是最后一步，<code class="fe od oe of og b">(v &amp; ~mask) | (value &amp; mask)</code>将对两个结果进行“或”运算，<code class="fe od oe of og b">... 0000 1010 ... | ... 1010 0000 ...</code>将导致<code class="fe od oe of og b">v</code>被重置为<code class="fe od oe of og b">... 1010 1010 ...</code>。请记住，只有21-23位发生了变化。这在这里由保留其先前值的位16-20示出。同样，<code class="fe od oe of og b">v</code>的其他部分将保持不变。</p><p id="912e" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第5行</strong>通过<code class="fe od oe of og b">bcm_peri_write()</code>将<code class="fe od oe of og b">paddr</code>的32位设置为<code class="fe od oe of og b">v</code>。稍后还会有更多的介绍。</p><h2 id="ee53" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_peri_read()</h2><p id="79fd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe od oe of og b">bcm_peri_read()</code>将从<code class="fe od oe of og b">paddr</code>开始读取32位，并将它们作为32位值返回给调用者。与<code class="fe od oe of og b">bcm_fsel()</code>和<code class="fe od oe of og b">bcm_peri_set_bits()</code>不同，该功能非常简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="87a0" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第4行和第6行</strong>同步对内存的访问，这样读取就不会被中断。</p><p id="aad8" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第5行</strong>简单地将返回值<code class="fe od oe of og b">ret</code>设置为位于<code class="fe od oe of og b">paddr</code>的内容。</p><h2 id="2ea8" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_peri_write()</h2><p id="a533" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe od oe of og b">bcm_peri_write()</code>将从<code class="fe od oe of og b">paddr</code>开始的32位写入<code class="fe od oe of og b">value</code>中包含的值。像<code class="fe od oe of og b">bcm_peri_read()</code>这个功能挺简单的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e54a" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第3行和第5行</strong>同步访问(锁定)从<code class="fe od oe of og b">paddr</code>开始的32位。</p><p id="a432" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第4行</strong>将位于<code class="fe od oe of og b">paddr</code>的32位设置为<code class="fe od oe of og b">value</code>。</p><h2 id="b9bd" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_gpio_write()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="71b2" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><code class="fe od oe of og b">bcm_gpio_write()</code>将32位<code class="fe od oe of og b">value</code>写入指定的<code class="fe od oe of og b">pin</code>。它使用了两个辅助函数，<code class="fe od oe of og b">bcm_gpio_set()</code>和<code class="fe od oe of og b">bcm_gpio_clr()</code>。参数<code class="fe od oe of og b">on</code>用于指定<code class="fe od oe of og b">pin</code>的<code class="fe od oe of og b">value</code>是否应该设置或清除。有一组4个GPIO寄存器:GPSET0和GPSET1，以及GPCLR0和GPCLR1，用于指定引脚的值是高还是低。高电平对应于GPSETn。低电平对应GPCLRn。当<code class="fe od oe of og b">on</code>的值为<code class="fe od oe of og b">1</code>时，与<code class="fe od oe of og b">pin</code>的值相关联的GPSETn寄存器被设置为1。如果<code class="fe od oe of og b">on</code>被设置为<code class="fe od oe of og b">0</code>，则与<code class="fe od oe of og b">pin</code>的值相关联的GPCLRn寄存器被设置为1。GPSETn的值仅在引脚的I/O功能设置为输出时使用。GPCLRn的值同样仅在引脚的I/O功能设置为输出时使用。这些寄存器中<code class="fe od oe of og b">0</code>的值被忽略。回想一下，BCM2835允许为54个引脚指定GPIO功能(预期为40个)。由于每个引脚需要1位来指定是置位还是清零，因此总共需要54位。这解释了为什么设置和清除需要两个32位寄存器。</p><p id="e9ef" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这些寄存器的使用在<a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835 I/O外设数据表</a>第95页第6节中有进一步描述。</p><h2 id="1b87" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_gpio_set()和bcm_gpio_clr()</h2><p id="8b42" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe od oe of og b">bcm_gpio_set()</code>和<code class="fe od oe of og b">bcm_gpio_clr()</code>在功能上是双胞胎。它们只在操作的寄存器上有所不同。<code class="fe od oe of og b">*set()</code>作用于GPSETn寄存器，而<code class="fe od oe of og b">*clr()</code>作用于GPCLRn寄存器。它们负责为所提供的<code class="fe od oe of og b">pin</code>参数在适当的寄存器中设置适当的位偏移。本节将只描述<code class="fe od oe of og b">bcm_gpio_set()</code>。除了在寄存器组上操作之外，它们的实现是相同的。事实上，通过添加另一个参数来指定起始偏移量，它们可以合并成一个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="fbc6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">在<code class="fe od oe of og b">bcm_gpio_set()</code> <strong class="lp ir">中，第3行</strong>计算目标寄存器的地址<code class="fe od oe of og b">paddr</code>。<code class="fe od oe of og b">bcm_gpio</code>是GPIO寄存器的起始偏移量。<code class="fe od oe of og b">BCM_GPSET0</code>是置位和清零寄存器的起始偏移量。回想一下上面bcm_init()部分的讨论，指针算法用于确定给定操作使用的内存偏移量。这就是为什么在这个操作中<code class="fe od oe of og b">BCM_GPSET0</code>被4除。<code class="fe od oe of og b">pin/32</code>用于计算哪个<code class="fe od oe of og b">GP*n</code>寄存器将用于给定的<code class="fe od oe of og b">pin</code>。回想一下，整数除法总是向下舍入。因此<code class="fe od oe of og b">pin 17/32</code>的结果是<code class="fe od oe of og b">0</code>，它指定将使用第一个<code class="fe od oe of og b">GP*n</code>寄存器。这与BCM2835 ARM外设指南一致。由于使用了整数运算，所以<code class="fe od oe of og b">0</code>在<code class="fe od oe of og b">paddr</code>的计算中是正确的。</p><p id="5510" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第4行</strong>计算需要多大的<code class="fe od oe of og b">shift</code>来设置<code class="fe od oe of og b">GP*n</code>寄存器中与<code class="fe od oe of og b">pin</code>相关的适当位。以引脚17为例，<code class="fe od oe of og b">17%32</code>为17，对应于GPSET0中的位17。同样，根据BCM2835 ARM外设指南，这是正确寄存器内的正确偏移量。</p><p id="22f7" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">行5 </strong>然后使用<code class="fe od oe of og b">bcm_peri_write()</code>将<code class="fe od oe of og b">1</code>、<code class="fe od oe of og b">shift</code>位向左移位，以便写入正确寄存器中的正确偏移量。根据第4行的计算，<code class="fe od oe of og b">1</code>向左移动17位。</p><h2 id="f181" class="ng kw iq bd kx nh ni dn lb nj nk dp lf lw nl nm lh ma nn no lj me np nq ll nr bi translated">bcm_close()</h2><p id="6bc9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe od oe of og b">bcm_close</code>释放所有资源，并将所有GPIO偏移量重置为初始值，在本例中为<code class="fe od oe of og b">MAP_FAILED</code>。关于<code class="fe od oe of og b">MAP_FAILED</code>，该值防止对BCM2835外设寄存器进行任何操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="18c1" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第3行</strong>释放<code class="fe od oe of og b">bcm_init()</code>中<code class="fe od oe of og b">mapmem()</code>操作预留的内存。</p><p id="d752" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><strong class="lp ir">第4–14行</strong>将所有寄存器偏移量重置为默认设置。</p><h1 id="a938" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">摘要</h1><p id="1110" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">本文详细介绍了如何在不使用第三方库的情况下，直接与BCM2835的外设寄存器交互，使led闪烁。它首先概述了BCM2835的ARM外设的主要概念，包括在外部设备/外设上运行的I/O功能的类型，BCM2835寻址如何作为描述如何与BCM2835寄存器交互以控制外部设备(如LED)的先决条件。然后描述了控制LED所需的实验室设置。接下来，它给出了主程序使用的代码，并解释了代码的作用。最后，本文介绍了与各种外设相关的BCM2835寄存器直接交互的代码和解释。</p><p id="ee07" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">至此，您应该对如何使用BCM2835支持的各种I/O功能直接对BCM2835进行编程以控制各种外设类型有了很好的理解。虽然SPI等特定I/O功能的底层细节可能有所不同，但BCM2835的编程机制是相同的。</p><p id="b433" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">敬请关注我即将发表的文章“Raspberry Pi GPIO——使用SPI在MAX7219点阵显示模块上显示字母数字字符”,这篇文章将演示如何仅使用BCM2835寄存器的低级访问来控制点阵led显示器。它是本文的一个很好的补充，因为它将介绍一组新的外设寄存器，用于对SPI I/O功能进行编程。</p><p id="5fe6" class="pw-post-body-paragraph ln lo iq lp b lq mk jr ls lt ml ju lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">欢迎对这篇文章的反馈。</p><h1 id="1333" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">参考</h1><ul class=""><li id="ed3b" class="mp mq iq lp b lq lr lt lu lw os ma ot me ou mi nf mv mw mx bi translated">Sunfounder闪烁LED项目是试验板图的来源。这也是本系列关于Raspberry Pi GPIO编程的灵感来源。查看我的<a class="ae mj" href="https://youngkin.github.io/post/sunfoundergpionotesled/" rel="noopener ugc nofollow" target="_blank">闪烁LED项目</a> t了解更多详情。</li><li id="0ef7" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated"><a class="ae mj" href="https://pinout.xyz/" rel="noopener ugc nofollow" target="_blank"> Raspberry Pi GPIO引脚排列图</a>包括物理板引脚号、BCM/GPIO引脚号和WiringPi引脚号。</li><li id="01c4" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">包含这篇文章和其他文章的代码的gpio存储库</li><li id="e74a" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated"><a class="ae mj" href="https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up" rel="noopener ugc nofollow" target="_blank">如何从头开始设置新的树莓Pi</a></li><li id="b2c1" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated"><a class="ae mj" href="https://www.sciencebuddies.org/science-fair-projects/references/how-to-use-a-breadboard" rel="noopener ugc nofollow" target="_blank">如何使用试验板</a></li><li id="3f45" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated"><a class="ae mj" href="https://youngkin.github.io/categories/gpio/" rel="noopener ugc nofollow" target="_blank">树莓Pi上的GPIO编程3B+ </a>包含了我关于树莓Pi上的GPIO编程的文章列表</li><li id="0e53" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated"><a class="ae mj" href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" rel="noopener ugc nofollow" target="_blank">BCM 2835外设指南</a>。</li><li id="8f0c" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">麦克·麦考利的C <a class="ae mj" href="https://www.airspayce.com/mikem/bcm2835/index.html" rel="noopener ugc nofollow" target="_blank">图书馆</a></li><li id="d522" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">C <a class="ae mj" href="http://wiringpi.com/" rel="noopener ugc nofollow" target="_blank"> WiringPi </a>库和相关的<a class="ae mj" href="https://github.com/WiringPi/WiringPi" rel="noopener ugc nofollow" target="_blank"> GitHub库</a></li><li id="7e20" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">Python <a class="ae mj" href="http://abyz.me.uk/rpi/pigpio/" rel="noopener ugc nofollow" target="_blank"> pgpio </a>库</li><li id="0206" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">Python <a class="ae mj" href="https://pypi.org/project/RPi.GPIO/" rel="noopener ugc nofollow" target="_blank"> RPi。GPIO </a>库</li><li id="8d7d" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated">Go <a class="ae mj" href="https://github.com/stianeikeland/go-rpio" rel="noopener ugc nofollow" target="_blank"> go-rpio </a></li><li id="4585" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nf mv mw mx bi translated"><a class="ae mj" href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html" rel="noopener ugc nofollow" target="_blank"> Linux和设备树</a>描述了什么是Linux设备树以及如何使用它。</li></ul></div></div>    
</body>
</html>