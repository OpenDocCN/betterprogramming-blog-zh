<html>
<head>
<title>How to Create a Dockerfile for a Python Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Python应用程序创建docker文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-dockerfile-for-a-python-application-8d078b16bc9a?source=collection_archive---------2-----------------------#2020-09-24">https://betterprogramming.pub/how-to-create-a-dockerfile-for-a-python-application-8d078b16bc9a?source=collection_archive---------2-----------------------#2020-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2407" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建Python容器的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ca347611dcb8e1d422bff9b85f75480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tlRBZ-1TVn2BAQIi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格里芬·伍尔德里奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="a951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将发现如何创建Python Dockerfile文件。我们将涵盖足够让你开始你自己的项目。这个Dockerfile是我的两个宠物项目目前使用的文件。一个是从外部服务中检索图书封面，另一个是为我的博客生成预览。</p><p id="1a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将逐行检查over文件并从中学习。别担心，你不需要任何先验知识。我相信，在这篇文章结束时，您将能够自己做到这一点。在当前的软件开发环境中，拥有Docker知识是必须的。</p><p id="ea5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太多的数据科学项目仅仅因为生产问题而失败。业务人员经常低估软件开发带来的一切。与其一遍又一遍地创建概念证明，不如将更多的注意力放在创建有价值的软件上。通过阅读本文，您将了解到软件开发周期中非常重要的一部分。这篇文章是关于可用的<strong class="lb iu"> </strong>软件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc14" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建应用程序</h1><p id="93cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，我假设您已经创建了一个基本的应用程序。如果还没有，最好用FastAPI实现一个基本的GET请求。在本教程中可以找到一个很好的例子<a class="ae ky" href="https://fastapi.tiangolo.com/tutorial/first-steps/" rel="noopener ugc nofollow" target="_blank">。这是一个很好的锻炼，为什么不自己试试呢？</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a86b0896060d8aec74966378b3258933.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*J0eOKh7kP2x9U-myLLU5Hw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔伊·崔比昂尼的名言。</p></figure><p id="ee61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为拥有一个应用程序对于本文的其余部分至关重要，所以包含了一个主应用程序的源代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您应该只需使用以下命令就可以运行应用程序了:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ff7e" class="nh md it nd b gy ni nj l nk nl"><strong class="nd iu">python </strong>"main.py"</span></pre><p id="6d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从现在开始，我将在下一节详细解释Dockerfile文件的每一行。如果你有不明白的地方，不要害怕在下面的评论中提问！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f77b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建Dockerfile文件</h1><p id="346c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将要创建的docker文件的第一行是关于我们的语言的。随着世界对Python 3越来越熟悉，我选择了最新的Python版本之一也就不足为奇了。如果你对Python其他可用的Docker基本图像感兴趣，这个<a class="ae ky" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank">页面</a>是你的朋友。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e14b" class="nh md it nd b gy ni nj l nk nl">FROM python:3.8</span></pre><p id="6492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当人们写或谈论Docker时，下面的两句话经常被忽略。然而，在我看来，它们非常重要。下面几行代码确保您在容器中所做的一切都是由普通用户完成的。你也没有在Linux中对每个命令都使用<code class="fe nm nn no nd b">sudo</code>，对吗？这些行可以防止您弄乱Docker映像的内部结构，并避免以后出现特权问题。</p><p id="4e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面两行添加了一个<code class="fe nm nn no nd b">user</code>组，一个名为<code class="fe nm nn no nd b">user</code>的用户，以及一个位于目录<code class="fe nm nn no nd b">/home/user</code>下的主目录:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f6aa" class="nh md it nd b gy ni nj l nk nl">RUN useradd -ms /bin/bash user<br/>USER user</span></pre><p id="3e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们很懒——就像优秀的开发人员一样——我们不想将主目录添加到我们将要执行的每个命令中。因此，我们在docker文件中使用下面一行。这确保了我们所做的一切都在主目录中完成:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ae72" class="nh md it nd b gy ni nj l nk nl">WORKDIR /home/user</span></pre><p id="4eb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Docker容器环境之外，使用虚拟环境是最佳实践。我来给你介绍一下<code class="fe nm nn no nd b">requirements.txt</code>文件的样子:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="89f0" class="nh md it nd b gy ni nj l nk nl">mockito~=1.2.2<br/>requests~=2.24.0<br/>Pillow~=7.2.0<br/>pylint~=2.6.0<br/>fastapi~=0.61.1<br/>uvicorn~=0.11.8</span></pre><p id="8b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你处理多个项目时，虚拟环境非常有用。通过这种方式，您可以防止升级或降级您正在其他地方使用的包，这些包可能会破坏您昨晚运行的应用程序。您不希望这种情况发生，您的团队领导也不希望听到这种情况。</p><p id="e2da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在这一行中，我们将所有需要的库从您的主机复制到Docker容器:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0bb0" class="nh md it nd b gy ni nj l nk nl">COPY requirements.txt .</span></pre><p id="4bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个文件，我们可以为我们的应用程序安装所有需要的库。之后，我们不再需要Docker容器中的这个文件，所以我们不要把它放在那里。</p><p id="47f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="np">注意:这个由你自己考虑，但是我没有发现在这里创建第二个Docker层有什么价值。</em></p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f1a4" class="nh md it nd b gy ni nj l nk nl">RUN pip install -r requirements.txt &amp;&amp; rm requirements.txt</span></pre><p id="168e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，来源呢？好了，源代码的时候到了。我们马上复制过来。</p><p id="6c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很难猜测你把你的测试文件放在哪里，但是你不希望它们在你的Docker容器中。如果您想优化您的容器，请记住这一点。为了简单起见，这一部分被省略了。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0ae8" class="nh md it nd b gy ni nj l nk nl">COPY src .</span></pre><p id="2eb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">倒数第二行是为了便于记录。因为我们在端口10000上运行应用程序，所以我们使用<code class="fe nm nn no nd b">expose</code>指令来说明这一点。这样，我们也知道在生产环境中暴露了哪些端口。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9815" class="nh md it nd b gy ni nj l nk nl">EXPOSE 10000</span></pre><p id="87ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行是关于启动应用程序的。因为关于如何启动应用程序的所有内容都包含在<code class="fe nm nn no nd b">main.py</code>中，所以这对于其他应用程序来说非常通用。这样，我们就不必经常打开docker文件。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0e01" class="nh md it nd b gy ni nj l nk nl">ENTRYPOINT [ "python", "main.py"]</span></pre><p id="12e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样——整个Dockerfile文件只有几行。</p><p id="6d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们用一个令人敬畏的标签来构建图像，这样我们就可以与我们的同事分享它:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f381" class="nh md it nd b gy ni nj l nk nl">docker image build . -t "awesome_tag"</span><span id="6ce7" class="nh md it nd b gy nq nj l nk nl">...</span><span id="3487" class="nh md it nd b gy nq nj l nk nl">Successfully built 41612ca5ccfd<br/>Successfully tagged awesome_tag:latest</span></pre><p id="718e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们唯一要做的就是旋转容器！</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9102" class="nh md it nd b gy ni nj l nk nl">docker container run -t awesome_tag:latest -p 10000:10000</span><span id="b021" class="nh md it nd b gy nq nj l nk nl">INFO:     Started server process [1]<br/>INFO:     Waiting for application startup.<br/>INFO:     Application startup complete.<br/>INFO:     Uvicorn running on <a class="ae ky" href="http://0.0.0.0:10000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:10000</a></span></pre><p id="9603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是在Docker中运行一个Python应用程序的全部工作。在这一点上，对于任何项目，您应该能够自己做到这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="253e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="93bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们看到了如何创建Python应用程序并在Docker容器中运行它。为一个小应用程序创建Dockerfile非常简单，就像我们用FastAPI创建的那样，所以我一直建议尽早使用容器。</p><p id="87bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Docker，测试应用程序的新版本变得容易得多，因为您实际上可以在安装了Docker的每个环境中轻松地设置它。如果你还有任何问题，欢迎在评论中提问。我将非常乐意回答所有这些问题。</p></div></div>    
</body>
</html>