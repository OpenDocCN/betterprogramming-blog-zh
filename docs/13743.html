<html>
<head>
<title>Fundamental TLS Certificate Commands You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该知道的基本TLS证书命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fundamental-tls-certificate-commands-you-should-know-88ac321f5274?source=collection_archive---------1-----------------------#2022-09-22">https://betterprogramming.pub/fundamental-tls-certificate-commands-you-should-know-88ac321f5274?source=collection_archive---------1-----------------------#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些简单的命令学习一些PKI基础知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66faedfbb845e93c96913a7df7b29390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eg5vX4yvXFiuSBel8_DjAQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jdent?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰森·登特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/password?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="f688" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">围绕公钥基础设施<a class="ae ky" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank"> (PKI </a>)展开讨论可能是软件开发中最具挑战性的方面之一。在保护通信安全之前，构建应用程序是一件有趣的事情。如果您创建在网络上相互连接的分布式系统，您将在某个时候遇到TLS证书。</p><p id="d0d0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在本文中，我们将直面管理证书的挑战。学习一些生成和检查证书的基本命令可以使管理和保护应用程序变得更加容易。我们将探索如何建立一个可用于测试的私有证书链，并检查每个组件如何作为一个整体组合在一起。</p><h1 id="d233" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成自签名证书</h1><p id="f648" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">这是证书领域中最常见的任务之一。如果你正在建立一个加密网络或者测试一个HTTPS网络服务器，你需要获得某种形式的证书。</p><p id="468a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最快和最简单的方法是生成一个“自签名”证书。这是一个独立的证书，本质上声明:<em class="mz">“我是唯一的权威，我确认我自己的身份。”</em></p><p id="5b8b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这应该是显而易见的，但这实际上不是一个安全或可信的证书。这是因为它验证了自己。是“自签”。没有可靠的上游认证机构对其进行验证以证明其身份。</p><p id="6a88" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你想获得一个有效的、可信的证书，你需要使用像<a class="ae ky" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"> Let's Encrypt </a>这样的免费服务，或者从像<a class="ae ky" href="https://www.digicert.com/" rel="noopener ugc nofollow" target="_blank"> DigiCert </a>这样的公司购买证书。</p><p id="95c3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">出于测试目的，或者对于内部专用的开发网络，自签名证书通常是可以接受的。让我们看看如何使用<code class="fe na nb nc nd b">openssl</code>实用程序生成自签名证书:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4596" class="ni md it nd b gy nj nk l nl nm">openssl req -new \<br/>    -newkey rsa:4096 -nodes \<br/>    -x509 \<br/>    -days 3650 \<br/>    -keyout self_signed.key \<br/>    -out self_signed.pem \<br/>    -subj '/CN=TestCertificate/C=US/ST=CA/L=SF/O=Test'</span></pre><p id="9c4a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们从头开始分解这个命令在每一步的作用:</p><ul class=""><li id="fd02" class="nn no it li b lj lk lm ln lp np lt nq lx nr mb ns nt nu nv bi translated">以<a class="ae ky" href="https://en.wikipedia.org/wiki/PKCS" rel="noopener ugc nofollow" target="_blank"> PKCS10 </a>格式创建新的证书请求。</li><li id="d7b6" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">为这个请求生成一个4096字节长的新私钥。</li><li id="3cc4" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">不要用密码加密私钥。</li><li id="d138" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">输出自签名证书(这是<code class="fe na nb nc nd b">-x509</code>标志)。</li><li id="55ea" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">使证书在10年后过期(对于脱机根ca，更长的过期时间是正常的)。</li><li id="94c4" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">将私钥写入<code class="fe na nb nc nd b">self_signed.key</code>文件。</li><li id="7ee6" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">将证书写入<code class="fe na nb nc nd b">self_signed.pem</code>文件。</li><li id="f0dc" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">将指定的<a class="ae ky" href="https://en.wikipedia.org/wiki/Public_key_certificate#Common_fields" rel="noopener ugc nofollow" target="_blank">主题信息</a>附加到证书上——这些是像国家、州和组织这样的数据。</li></ul><p id="d6f5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一旦我们运行这个命令，我们将留下两个重要的文件:</p><ul class=""><li id="b909" class="nn no it li b lj lk lm ln lp np lt nq lx nr mb ns nt nu nv bi translated">第一个文件以<code class="fe na nb nc nd b">.key</code>结尾，是我们用来形成证书的私钥。这类似于您用来生成SSH密钥对的内容。</li><li id="1009" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">第二个以<code class="fe na nb nc nd b">.pem</code>结尾的文件是证书。一旦你有了证书和密钥，你就可以把它安装到任何需要加密的服务中。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/54da8b20917f1f3f87f9b00f5b4f23b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XmZX562UB2eLcMc4kGuFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Firefox中的自签名证书错误。</p></figure><p id="fb7d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">连接到该服务的客户端将看到这是一个自签名证书，并可能产生某种警告。尽管这不是一个可信的证书，但是从技术上讲，服务之间的流量将在这一点上被加密。</p><p id="4ed6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">接下来，让我们看看如何使用新的自签名证书来签署其他类型的证书。</p><h1 id="d59f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成CSR</h1><p id="acc6" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">现在我们有了一个新的自签名证书，我们实际上可以将该证书用作CA，并开始用它来签署其他证书。这在证书之间创建了一个信任链(尽管是一个脆弱的信任链),并形成了分布式PKI的基础。</p><p id="0f42" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们假设您有一个新主机，您想为其颁发证书。该主机和同一域中的其他主机应该相互信任，并有一个中心参考点。这是认证机构的概念，或称<a class="ae ky" href="https://en.wikipedia.org/wiki/Certificate_authority" rel="noopener ugc nofollow" target="_blank"> CA </a>。我们可以为所有主机生成唯一的证书，并使用单个CA对它们进行签名。</p><p id="c751" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了签署主机证书，我们必须首先创建一个称为证书签署请求的东西(<a class="ae ky" href="https://en.wikipedia.org/wiki/Certificate_signing_request" rel="noopener ugc nofollow" target="_blank"> CSR </a>)。这是由主机创建的特殊请求，发送到CA进行签名，然后返回。</p><p id="4d30" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在让我们为我们的<code class="fe na nb nc nd b">TestHost</code>制作一个新的CSR:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="9131" class="ni md it nd b gy nj nk l nl nm">openssl req -new \<br/>    -newkey rsa:4096 -nodes \<br/>    -keyout host.key \<br/>    -out host.csr \<br/>    -subj '/CN=TestHost/C=US/ST=CA/L=SF/O=Test'</span></pre><p id="bd17" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">同样，让我们一行一行地分析:</p><ul class=""><li id="7998" class="nn no it li b lj lk lm ln lp np lt nq lx nr mb ns nt nu nv bi translated">以<a class="ae ky" href="https://en.wikipedia.org/wiki/PKCS" rel="noopener ugc nofollow" target="_blank"> PKCS10 </a>格式创建新的证书请求。</li><li id="422d" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">为这个请求生成一个4096字节长的新私钥(同样，这个密钥是未加密的，没有密码)。</li><li id="3987" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">将私钥输出到<code class="fe na nb nc nd b">host.key</code>文件。</li><li id="7762" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">将CSR输出到<code class="fe na nb nc nd b">host.csr</code>文件。</li><li id="8d69" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">追加主持人<a class="ae ky" href="https://en.wikipedia.org/wiki/Public_key_certificate#Common_fields" rel="noopener ugc nofollow" target="_blank">主题信息</a>。</li></ul><p id="caca" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一旦我们运行这个命令，我们将有一个新的CSR文件，并使用我们的CA进行签名。接下来让我们看看如何做到这一点。</p><h1 id="5ebb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">签署CSR</h1><p id="b4aa" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">拼图的最后一块是让我们的企业社会责任得到签署。为此，我们将把之前创建的<code class="fe na nb nc nd b">host.csr</code>文件带到CA。这可以在中央服务器、门户等上。在本例中，它位于我们一直在测试的同一台主机上，因此我们现在只需对它进行签名:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="f3fb" class="ni md it nd b gy nj nk l nl nm">openssl x509 -req \<br/>    -in host.csr \<br/>    -CA self_signed.pem \<br/>    -CAkey self_signed.key \<br/>    -CAcreateserial \<br/>    -out host.pem \<br/>    -days 30 -sha256</span></pre><p id="a1ef" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">请系好安全带，再一次一行一行地分析正在发生的事情:</p><ul class=""><li id="db6e" class="nn no it li b lj lk lm ln lp np lt nq lx nr mb ns nt nu nv bi translated">这次我们执行一个<code class="fe na nb nc nd b">x509</code>请求，这意味着我们将签署一个证书，而不是创建一个新的请求。</li><li id="0b2b" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">提供之前创建的主机CSR文件作为输入。</li><li id="27af" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">提供自签名CA证书文件。</li><li id="342f" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">提供自签名的CA私钥文件。</li><li id="d67a" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">创建序列号文件—这将防止在签名过程中产生错误。</li><li id="81d2" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">将签名证书输出为<code class="fe na nb nc nd b">host.pem</code></li><li id="42ee" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">该证书的有效期为30天，并使用SHA256摘要进行签名。</li></ul><p id="f918" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一旦我们完成了这个命令，我们就剩下最终的、已签名的主机证书了。然后，我们可以使用这个证书和这个CA签署的任何其他证书在域中构建一个可信主机系统。</p><p id="f89a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里需要注意的一点是主机的到期时间更短。对于主机证书，大多数建议是30天左右。这迫使每个月更新一次，并确保主机证书(因为主机通常更短暂)不能一次停留数年。</p><h1 id="060e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">检查证书</h1><p id="8812" class="pw-post-body-paragraph lg lh it li b lj mu ju ll lm mv jx lo lp mw lr ls lt mx lv lw lx my lz ma mb im bi translated">由于我们的环境中有许多证书，所以学习如何检查它们是一个好主意。有些证书比其他证书更快过期。虽然脱机根CA的有效期可能为10年，但客户端证书的有效期可能只有24小时。</p><p id="c6df" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们看看如何使用最后一个<code class="fe na nb nc nd b">openssl</code>命令来检查现有证书:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="b689" class="ni md it nd b gy nj nk l nl nm">openssl x509 -text -noout &lt; cert.pem</span></pre><p id="04a0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是一个简单的命令，让我们马上看到相当多的信息。我们可以立即了解关于证书的以下内容:</p><ul class=""><li id="cb82" class="nn no it li b lj lk lm ln lp np lt nq lx nr mb ns nt nu nv bi translated">发行人</li><li id="0b70" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">截止日期</li><li id="a538" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">主题信息</li><li id="4351" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated">加密信息</li></ul><p id="ac91" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">结果中包含更多的信息，比如加密的密钥和密码信息，但是这在诊断问题时通常没有什么帮助。</p><p id="9100" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您想确定证书何时过期或者是谁颁发的，这是一个很好的起点。</p><p id="3da1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们从一开始就看看我们的自签名证书是什么样子的:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="17d3" class="ni md it nd b gy nj nk l nl nm">Certificate:<br/>    Data:<br/>        Version: 1 (0x0)<br/>        Serial Number: 15449774297344832821 (0xd6689fddf532f535)<br/>    Signature Algorithm: sha256WithRSAEncryption<br/>        Issuer: CN=TestCertificate, C=US, ST=CA, L=SF, O=Test<br/>        Validity<br/>            Not Before: Sep 21 01:48:35 2022 GMT<br/>            Not After : Sep 18 01:48:35 2032 GMT<br/>        Subject: CN=TestCertificate, C=US, ST=CA, L=SF, O=Test</span></pre><p id="81b5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我看来相当不错。我们可以很快知道证书的有效期有多长，它来自哪里，是给谁的。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="a1a7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感谢阅读！如果你喜欢这篇文章，请<a class="ae ky" href="https://tateg.medium.com/follow" rel="noopener">关注</a>和<a class="ae ky" href="https://tateg.medium.com/subscribe" rel="noopener">订阅</a>获取最新更新。想要更多吗？看看下面的一些其他帖子:</p><ul class=""><li id="aa17" class="nn no it li b lj lk lm ln lp np lt nq lx nr mb ns nt nu nv bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-simple-way-to-make-rpcs-with-python-52ad8e9286c1"> <em class="mz">用Python制作RPC的简单方法</em> </a></li><li id="a263" class="nn no it li b lj nw lm nx lp ny lt nz lx oa mb ns nt nu nv bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/python-modules-that-make-handling-json-even-faster-f577d8948a5"> <em class="mz">让处理JSON更快的Python模块</em> </a></li></ul></div></div>    
</body>
</html>