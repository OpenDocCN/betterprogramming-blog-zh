<html>
<head>
<title>JavaScript Fundamentals: Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:异步/等待</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-fundamentals-async-await-99bf7ad667d1?source=collection_archive---------5-----------------------#2019-07-16">https://betterprogramming.pub/javascript-fundamentals-async-await-99bf7ad667d1?source=collection_archive---------5-----------------------#2019-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用ES8中的最佳功能，让您的代码更整洁、可读性更强</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97f7b790fb65df4d6770d9c37c3aaae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gr3BwWhhUqspXitc"/></div></div></figure><p id="e61b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Async-await</code>可能是JavaScript最近最伟大的新增内容之一。它不仅使程序员的工作更容易，还使代码看起来干净流畅。</p><p id="c9a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript是一种非常通用的语言，可以执行函数式编程、面向对象编程、服务器端和客户端优化等等。</p><p id="276f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很多时候，在我们日常的JavaScript代码中，我们可能需要在幕后执行许多异步任务。异步任务的实现变得复杂，因为JavaScript是一种同步语言。</p><p id="a5c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将了解ES8发布后带来的两个新功能，即<code class="fe lq lr ls lt b">async-await</code>。</p><p id="61f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">async-await</code>的帮助下，我们现在可以编写看起来完全同步的代码，同时让他们在后台处理异步任务。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4547" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">JavaScript作为一种同步语言</h1><p id="ee77" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">JavaScript是同步单线程语言。异步行为不是JavaScript的直接组成部分。相反，它可以构建在核心JavaScript语言本身之上，并且可以通过浏览器API访问。</p><h2 id="3420" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">什么是事件循环，它是如何工作的？</h2><p id="aa2a" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">为了理解事件循环背后的概念，我们首先需要看看调用堆栈是如何工作的。调用堆栈就像程序当前执行的日志。</p><p id="27cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用调用栈是因为有时即使JavaScript引擎也很难跟踪所有的程序执行；它依靠调用栈来提供有价值的信息。</p><p id="ceb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">调用堆栈非常类似于具有相同操作的普通堆栈，即push <strong class="kw iu"> </strong>和<strong class="kw iu"> </strong> pop <strong class="kw iu">。</strong>一个栈数据结构遵循LIFO(后进先出)的概念，通过push <strong class="kw iu"> <em class="nk">，</em> </strong>我们的意思是把<strong class="kw iu"> <em class="nk"> </em> </strong>的东西放到栈里。</p><p id="b754" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个函数首先执行/调用自身时，JavaScript引擎会将该函数推入调用堆栈。每个函数调用都将自己按顺序推入调用堆栈。</p><p id="2ee2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，pop <strong class="kw iu"> <em class="nk"> </em> </strong>的意思是从栈中取出某个东西。当位于堆栈最顶端的函数执行完毕时，它会从调用堆栈中移除<strong class="kw iu"> <em class="nk"> </em> </strong>，因为它遵循LIFO属性。</p><h2 id="6f72" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">调用堆栈如何工作</h2><p id="e285" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在我们知道了调用栈遵循什么属性和概念，让我们看看它实际上是如何工作的。看看这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这段代码中，我们在<code class="fe lq lr ls lt b">main()</code>函数中有三个<code class="fe lq lr ls lt b">console.log()</code>语句，它只是在终端中记录字符串值。</p><p id="5b6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中两条语句分别出现在第二行和第六行的顶部和底部。另一个语句介于两者之间，将自己包装在一个<code class="fe lq lr ls lt b">setTimeout </code>调用中(使用浏览器API，我们将在后面讨论),等待时间为零毫秒。</p><h2 id="df0c" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">事件循环如何工作</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/cb4a8174787b3c157e5d34a559b03aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s-67vMHDaHVJdKk1"/></div></div></figure><ul class=""><li id="d725" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">当程序启动时，它进入主函数。因此，<code class="fe lq lr ls lt b">main()</code>首先将自己作为一个帧推入调用堆栈。进入主函数后，执行的第一条语句是<code class="fe lq lr ls lt b">console.log(“First”)</code>。这个语句也被浏览器推入堆栈。执行时，弹出画面并在控制台显示<code class="fe lq lr ls lt b"><em class="nk">“</em>First<em class="nk">”</em></code>。</li><li id="16af" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">在执行第一条语句时，下一条语句将其自身推入堆栈(<code class="fe lq lr ls lt b">setTimeout</code>)。该语句使用浏览器API来延迟内部回调函数的执行时间。在将<code class="fe lq lr ls lt b">middle()</code>函数交给浏览器执行后，这个框架将自己弹出堆栈。这是因为它是一个浏览器API，它在零毫秒的某个时间执行。</li><li id="ba75" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">在这个执行之后，第三个语句，或者说<code class="fe lq lr ls lt b">console.log(“Third”)</code>，将自己推到调用栈中执行。这发生在定时器在后台运行以执行<code class="fe lq lr ls lt b">middle()</code>功能时。一旦浏览器将这个框架推入调用堆栈，它就会执行并在控制台中显示<code class="fe lq lr ls lt b">“Third”</code>，弹出最后一个框架。</li><li id="f880" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe lq lr ls lt b">setTimeout </code>函数获得零毫秒的延迟，导致浏览器一收到回调就将其添加到事件队列中，因为执行时间已经到期。</li><li id="1c35" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">一旦最后一条语句执行并弹出调用堆栈，<code class="fe lq lr ls lt b">main()</code>框架也会弹出，从而使其为空。为了让浏览器将事件队列中的任何消息推送到调用堆栈，它必须完全为空。这就是为什么即使延迟为零毫秒，回调仍然需要等待。</li><li id="4956" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">最后，回调<code class="fe lq lr ls lt b">middle()</code>中的语句<code class="fe lq lr ls lt b">console.log(“Second”)</code>将其自身推入调用堆栈并执行，从而将<code class="fe lq lr ls lt b">“Second”</code>打印到控制台中。</li></ul><p id="1c97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是JavaScript的事件循环:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/787c09eb7ebcc55ce304b56c394f6823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XBjn4RtXV6-UeQl3"/></div></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9eaf" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是承诺？</h1><p id="5bd1" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">JavaScript中的承诺就像现实生活中的承诺一样。</p><p id="92bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，你已经答应一个朋友给他买他最喜欢的书。为了实现这一承诺，您需要:</p><ul class=""><li id="d59f" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">去任何一家你可能找到这本书的书店。</li><li id="49fe" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">买下来，带回去给他</li></ul><p id="cdff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这一切发生的时候，你的朋友所做的一切都在等着你。</p><p id="b500" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，如果承诺是别的东西，比如进入你最喜欢的公司，或者买一辆非常贵的车。这些承诺需要更长的时间来实现，因此需要更长的等待时间。</p><p id="5b88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，在JavaScript中，承诺是一个在未来某个时候给出一个值的对象。它可能会返回一个成功的输出或者给我们错误的结果，但是它不会中途停止程序的执行。</p><p id="6885" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">承诺包含三种状态:</p><ul class=""><li id="3d6a" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">感到满足的</li><li id="b181" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">拒绝</li><li id="5415" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">悬而未决的</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/3df5f3bb81fea3a5cce06aebf9fe7811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*avSQpd3eS9fD1Gpi"/></div></div></figure><h2 id="5e69" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">承诺是如何运作的</h2><p id="58f1" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">承诺是一个能够从异步函数同步返回自身的对象。</p><p id="42e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你从一个程序(promise)中请求某样东西，它会一直处于等待状态，直到它结束/完成。</p><p id="452e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦条件得到满足，则承诺被解决(T0)，或被拒绝(T1)。承诺一旦兑现，就无法再兑现。</p><p id="3573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看一下这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f334" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这段代码中，我们传递一个带有两个参数的承诺，<code class="fe lq lr ls lt b">resolve </code>和<code class="fe lq lr ls lt b">reject</code>。它可以有任何名称，但这个例子有助于我们更好地理解。</p><p id="c5e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，假设承诺被解决——它应该做的工作已经完成——并且我们使用<code class="fe lq lr ls lt b">resolve()</code>方法传递它。</p><p id="b663" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为函数已经被解析了，所以它不会抛出任何错误。相反，它将执行success函数，在<code class="fe lq lr ls lt b">first .then()</code>方法中打印消息。</p><p id="2d82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看一下这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="add6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个代码片段中，我们做了同样的事情，但是假设我们想要从这个承诺中得到的请求/结果被拒绝/失败了。</p><p id="77d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们传递一个<code class="fe lq lr ls lt b">reject()</code>方法，由<code class="fe lq lr ls lt b"> .then()</code>方法再次处理。它自动调用错误函数(因为它属于<code class="fe lq lr ls lt b">reject()</code>并且是一个错误)，然后显示错误消息。</p><h2 id="d153" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">承诺的重要规则</h2><p id="0711" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">承诺的标准已经由<a class="ae oe" href="https://promisesaplus.com/implementations" rel="noopener ugc nofollow" target="_blank">Promises/A+specification</a>社区定义。通常，承诺总是遵循一套特定的规则:</p><ul class=""><li id="0ef8" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">promise对象应该总是提供一个<code class="fe lq lr ls lt b">.then()</code>方法。</li><li id="0133" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">待定的<code class="fe lq lr ls lt b">promise </code>将总是转换回解决或拒绝。</li><li id="46ad" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">一个承诺，不管是解决了还是拒绝了，总是被解决了，不能转换到任何其他状态。</li><li id="395d" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">一旦承诺达成，它就有了价值。这一价值不能改变。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7796" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是异步等待？</h1><p id="2461" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">到目前为止，我们一直使用承诺来处理代码中的异步。这很好，但是ES8中的新版本<code class="fe lq lr ls lt b">async-await</code>在允许我们编写超级流畅、看起来同步的代码方面更有帮助。</p><p id="683a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">据<a class="ae oe" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> MDN </a> (Mozilla开发者网):</p><blockquote class="of og oh"><p id="729f" class="ku kv nk kw b kx ky ju kz la lb jx lc oi le lf lg oj li lj lk ok lm ln lo lp im bi translated"><em class="it">“异步函数是通过事件循环异步运行的函数，使用隐式承诺返回其结果。但是使用异步函数的代码的语法和结构更像是使用标准的同步函数。”</em></p></blockquote><p id="02f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们来解开上面这句话的含义。</p><ul class=""><li id="b644" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated"><code class="fe lq lr ls lt b">Async-await</code>非常容易使用，就像任何其他JavaScript函数一样，它也通过我们之前讨论过的事件循环异步运行。</li><li id="7986" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">它与承诺隐式相关，并使用它来返回结果。</li><li id="c490" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">语法结构与编写同步函数相同。</li></ul><h2 id="4ca4" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">异步ˌ非同步(asynchronous)</h2><p id="4bfb" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><code class="fe lq lr ls lt b">Async-await</code>只是承诺的延伸。它使我们能够在不阻塞执行线程的情况下同步编写基于承诺的代码。一个<code class="fe lq lr ls lt b">async </code>函数意味着一个承诺值将会返回。</p><p id="6f5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它通过事件循环异步工作。一个<code class="fe lq lr ls lt b">async </code>函数总是返回一个值。如果没有得到承诺作为返回，JavaScript会自动返回一个解析值。</p><p id="0f91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解这一点，让我们看一下这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a846" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行上面的代码将给出一个带有字符串消息<code class="fe lq lr ls lt b">Hello World</code>的警告输出。</p><p id="948d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着默认情况下，已解决的承诺成功返回。如果反过来，<code class="fe lq lr ls lt b">.then()</code>方法就不会执行。</p><h2 id="df23" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">等待</h2><p id="210f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">关键字<code class="fe lq lr ls lt b">await </code>处理<code class="fe lq lr ls lt b">async-await</code>块的等待部分。该运算符用于等待承诺。</p><p id="a4f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它在<code class="fe lq lr ls lt b">async </code>块中起作用，并等待承诺返回结果。<code class="fe lq lr ls lt b">Await </code>仅使<code class="fe lq lr ls lt b">async </code>功能块等待，而不是整个程序。</p><p id="72ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过查看以下代码来理解这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="aa89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们最后调用<code class="fe lq lr ls lt b">display()</code>函数时，它会调用包含在<code class="fe lq lr ls lt b">await </code>块中的<code class="fe lq lr ls lt b">AwaitExample()</code>函数。</p><p id="bf51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着在承诺在<code class="fe lq lr ls lt b">AwaitExample()</code>函数上自我解析之前，<code class="fe lq lr ls lt b">await </code>关键字将保持<code class="fe lq lr ls lt b">display()</code>方法的执行。</p><p id="40aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它不会停止程序运行，而只会持有<code class="fe lq lr ls lt b">display()</code>方法。两秒钟或2000毫秒后，承诺解决，然后控制台显示。</p><h2 id="7e87" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">使用async-await时要遵循的规则</h2><p id="ccef" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在我们的代码块中使用async-await之前，我们应该注意一些规则。这些规则是使您的功能正常工作所必需的。</p><p id="2264" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们快速看一下:</p><ul class=""><li id="b0b0" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">我们不能在普通函数中使用<code class="fe lq lr ls lt b">await </code>关键字。你必须有一个<code class="fe lq lr ls lt b">async</code>函数才能在里面使用<code class="fe lq lr ls lt b">await </code>。</li><li id="0639" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe lq lr ls lt b">Async-await</code>使执行始终按顺序进行。并行执行一定会更快。</li></ul><p id="1b67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Async-await </code>非常强大，但也有一些注意事项。如果我们正确使用它们，它们有助于使我们的代码非常可读和高效。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c27b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">顺序执行与并行执行</h1><h2 id="9899" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">顺序执行</h2><p id="79ed" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">顾名思义，顺序执行意味着按顺序执行代码。如果我们将其与并行执行相比较，这个过程会慢一点，因为在顺序执行中，一行必须在执行下一行之前完成处理。</p><p id="3c0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们借助一个例子来理解这一点。看一下这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0093" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们只是返回两个承诺函数。但是当第一个调用自己时，需要两秒钟来执行。与此同时，另一个<code class="fe lq lr ls lt b">await </code>功能只是坐在那里。</p><p id="de15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个承诺解决后，下一个<code class="fe lq lr ls lt b">await </code>才开始执行。与并行执行相比，这个过程非常耗时。</p><h2 id="34d8" class="my mc it bd md mz na dn mh nb nc dp ml ld nd ne mn lh nf ng mp ll nh ni mr nj bi translated">并行执行</h2><p id="74ee" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">处理更快执行的更有效的方法是通过并行执行。</p><p id="7e45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，如果不止一个在场，它不会停止其他<code class="fe lq lr ls lt b">await </code>方法的执行。</p><p id="ea52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它并行处理所有的<code class="fe lq lr ls lt b">await </code>方法。这种类型的处理使用<code class="fe lq lr ls lt b">promise.all()</code>方法。让我们借助这个例子来理解这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6eb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个代码片段中，我们使用了一个叫做<code class="fe lq lr ls lt b">promise.all()</code>的方法。这个方法的作用是首先解析iterable内部的所有承诺，然后返回最终结果。</p><p id="722a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，由于各个函数并行运行，因此与顺序执行相比，执行速度要快得多。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="481c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">异步等待中的错误处理</h1><p id="a28b" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">异步函数的另一个非常好的特性是<code class="fe lq lr ls lt b">async-await</code>可以同步处理错误，也可以借助try和catch块。</p><p id="896d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据值是被解析还是被拒绝，我们的try和catch块将显示所需的输出，流程流也将是同步的。</p><p id="552d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="dfb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们观察到，根据由<code class="fe lq lr ls lt b">val </code>变量生成的随机值，承诺要么得到<code class="fe lq lr ls lt b">resolved </code>要么得到<code class="fe lq lr ls lt b">rejected </code>。</p><p id="4df0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果该值为1，则它进行解析，稍后在try块中处理自身。如果反过来，那么JavaScript拒绝这个承诺，并在catch块中处理自己，从而给我们一个平滑的执行流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/32ca5be87771336b1072127405383e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*tpnPEakI9avwmNt00TKgeQ.png"/></div></figure><p id="09a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就把我们带到了这篇文章的结尾。我希望你喜欢现在学习<code class="fe lq lr ls lt b">async-await</code>对JavaScript世界的影响。</p><p id="d4aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读。再见。✌️</p></div></div>    
</body>
</html>