<html>
<head>
<title>Understanding Protocol Buffers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解协议缓冲区</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-protocol-buffers-43c5bced0d47?source=collection_archive---------2-----------------------#2020-04-22">https://betterprogramming.pub/understanding-protocol-buffers-43c5bced0d47?source=collection_archive---------2-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82c4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对原蟾蜍的深入研究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77661c5b6b6b49652c7f6767dffa79e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2G7HXILlV5MUIHeNjiYZPA.png"/></div></div></figure><p id="0eca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在之前的<a class="ae lq" href="https://medium.com/better-programming/understanding-grpc-60737b23e79e" rel="noopener">文章</a>中，我们讨论了与gRPC框架相关的各种概念。在那里，我简要地提到了协议缓冲区，这是gRPC中序列化结构化数据的默认方法。在本文中，我们将深入研究协议缓冲区的概念。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5c19" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是协议缓冲区？</h1><p id="7729" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">协议缓冲区是一种序列化数据的方法，这些数据可以通过网络传输或存储在文件中。JSON和XML等其他格式也用于序列化数据。虽然这些平台已经证明了自己非常灵活和有效，但它们没有完全优化的一个地方是数据要以平台中立的方式在多个微服务之间传输的场景。</p><p id="ec7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是促使谷歌在2008年创建ProtoBuf格式的挑战。从那以后，它在Google内部被广泛使用，并且成为gRPC框架的默认数据格式。最初，Protobuf是为三种主要语言创建的——c++、Java和Python。多年来，许多语言如Go、Ruby、JS、PHP、C#和Objective-C也开始支持Protobufs。Protobuf的当前版本被称为proto3。</p><p id="f1e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像JSON和XML一样，Protobufs是语言和平台中立的。Protobuf被优化为比JSON和XML更快，它去掉了许多通常由数据格式完成的职责，只关注尽可能快地序列化和反序列化数据的能力。另一个重要的优化是通过使传输的数据尽可能小，来考虑使用了多少网络带宽。</p><p id="3edb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要序列化的数据的定义写在称为proto文件(<code class="fe mv mw mx my b">.proto</code>)的配置文件中。这些文件将包含被称为消息的配置。原型文件可以被编译以生成用户编程语言的代码。</p><p id="c324" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们详细看看Protobufs的关键特性。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5952" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">关键特征</h1><h2 id="fb86" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak">二进制传输格式</strong></h2><p id="881b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Protobuf是一种二进制传输格式，这意味着数据是以二进制形式传输的。这比原始字符串更能提高传输速度，因为它占用的空间和带宽更少。由于数据被压缩，CPU的使用也将减少。</p><p id="549f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">唯一的缺点是Protobuf文件或数据不像JSON或XML那样易读</p><p id="ee47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果平台不像富客户端那样支持二进制消息，Protobuf中有将二进制数据序列化为字符串的功能。</p><h2 id="88c2" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak">上下文和数据的分离</strong></h2><p id="4eaf" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在JSON和XML中，数据和上下文是分开的——而在Protobuf中，数据和上下文是分开的。考虑一个JSON例子。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="a960" class="mz lz it my b gy np nq l nr ns">{<br/>  first_name: "Arun",<br/>  last_name: "Kurian"<br/>}</span></pre><p id="64e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，传输的数据得到了一个具有两个属性的对象文本，<code class="fe mv mw mx my b">first_name</code>和<code class="fe mv mw mx my b">last_name</code>，值为<code class="fe mv mw mx my b">Arun</code>和<code class="fe mv mw mx my b">Kurian</code>。这是高度可读的，但这会占用更多的空间。这里，每个JSON消息每次都必须提供这两部分。随着我们数据的增长，传输时间会显著增加。</p><p id="2d3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是对于Protobufs来说，事情就不一样了。我们首先在配置文件中定义一条消息，如下所示:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="7975" class="mz lz it my b gy np nq l nr ns">{<br/>  string first_name = 1;<br/>  string last_name = 2;  <br/>}</span></pre><p id="305c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该配置文件包含上下文信息。数字只是字段的标识符。如果消息格式有点混乱，不要担心——我们稍后将详细研究它。通过使用这种配置，我们可以将编码数据作为“</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="ebae" class="mz lz it my b gy np nq l nr ns">124Arun226Kurian</span></pre><p id="7afb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mv mw mx my b">124Arun</code>的情况下，<strong class="kw iu"> </strong> <code class="fe mv mw mx my b">1</code>代表字段标识符，<code class="fe mv mw mx my b">2</code>代表数据类型(即字符串)，而<code class="fe mv mw mx my b">4</code>是文本的长度。我承认这比JSON更难阅读；然而，与JSON数据相比，这将占用很少的空间。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a970" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">消息格式</h1><p id="6de2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">正如我们之前看到的，数据是基于一种称为<em class="nt">消息的配置作为Protobuf传输的。</em>消息保存在<code class="fe mv mw mx my b">.proto</code>文件中。让我们看一个消息示例:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="e1df" class="mz lz it my b gy np nq l nr ns">syntax = "proto3";</span><span id="8925" class="mz lz it my b gy nu nq l nr ns">message Person {<br/>  uint64 id = 1;<br/>  string email = 2;<br/>  bool is_active = 3;</span><span id="afae" class="mz lz it my b gy nu nq l nr ns">  enum PhoneType {<br/>    MOBILE = 0;<br/>    HOME = 1;<br/>    WORK = 2;<br/>  }</span><span id="b948" class="mz lz it my b gy nu nq l nr ns">   message PhoneNumber {<br/>    string number = 1;<br/>    PhoneType type = 2;<br/>   }<br/>   <br/>  repeated PhoneNumber phones = 4;</span><span id="d6e2" class="mz lz it my b gy nu nq l nr ns">}</span></pre><p id="e8c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上面的例子中，我们可以看到消息是用消息关键字声明的，后跟用户定义的消息名。文字或组件在花括号中声明。每个文字字段可以分为四个部分。它们是:</p><h2 id="1a61" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated">田赛规则</h2><p id="5962" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在Protobuf的proto2 <strong class="kw iu"> </strong>版本中，有类似<code class="fe mv mw mx my b">required</code>、<code class="fe mv mw mx my b">optional</code>和<code class="fe mv mw mx my b">repeated</code>的规则被添加到字段类型或数据类型之前。这在proto3中得到了优化，只保留了<code class="fe mv mw mx my b">repeated</code>规则。如果一个字段表示一组相同类型的元素，那么这个字段就是重复的。如果字段不重复，则不应添加任何规则。</p><h2 id="9259" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak">字段类型</strong></h2><p id="4728" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一个字段可以包含的数据类型分为三类。</p><p id="aac1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一种是标量数据类型，如字符串和数字。第二个是一个<code class="fe mv mw mx my b">enum</code>数据类型。在我们的例子中，这是<code class="fe mv mw mx my b">PhoneType</code>。最后的数据类型是嵌入的消息(就像我们例子中的<code class="fe mv mw mx my b">PhoneNumber</code>)。</p><p id="0d79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像在JSON和XML中一样，当使用消息类型时，我们可以构建消息的层次结构来表示任何类型的数据。Protobuf中可用的标量数据类型有<code class="fe mv mw mx my b">float</code>、<code class="fe mv mw mx my b">int32</code>、<code class="fe mv mw mx my b">int64</code>、<code class="fe mv mw mx my b">uint32</code>、<code class="fe mv mw mx my b">uint64</code>、<code class="fe mv mw mx my b">sint32</code>、<code class="fe mv mw mx my b">sint64</code>、<code class="fe mv mw mx my b">fixed32</code>、<code class="fe mv mw mx my b">fixed64</code>、<code class="fe mv mw mx my b">sfixed32</code>、<code class="fe mv mw mx my b">sfixed6</code>、<code class="fe mv mw mx my b">bool</code>、<code class="fe mv mw mx my b">string</code>和<code class="fe mv mw mx my b">bytes</code>。</p><h2 id="8081" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak">字段名称</strong></h2><p id="6372" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当命名Protobuf中的字段时，有一些约定需要遵循，因为这些约定是Protoc编译器在为您选择的语言生成基于<code class="fe mv mw mx my b">.proto</code>文件的代码时假定的。第一个约定是字段名都应该是小写的。其次，如果字段名中有多个单词，它们应该用下划线隔开。</p><h2 id="e3cd" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak">字段标签</strong></h2><p id="e48d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">字段标记是字段的数字表示，这使我们能够在定义中拥有丰富的字段名称，而无需通过网络发送它们。</p><p id="0428" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用字段标签时，需要考虑一些事情。首先，字段标签在消息中必须是唯一的。其次，它们必须是整数。第三，如果一个字段要从已经使用的定义中删除，它的标签必须声明为<code class="fe mv mw mx my b">reserved</code>以防止它被重新定义。示例:<code class="fe mv mw mx my b">reserved 8;</code></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="503d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">从原型文件生成代码</h1><p id="88a5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Protobuf最重要的组件是协议编译器。协议的安装如下:</p><h2 id="9953" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak">针对Mac用户</strong></h2><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="970f" class="mz lz it my b gy np nq l nr ns">brew tap homebrew/versions<br/>brew install protobuf</span></pre><h2 id="e1ea" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak">针对Ubuntu用户</strong></h2><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="ff5f" class="mz lz it my b gy np nq l nr ns">sudo apt install protobuf-compiler</span></pre><p id="a6b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">键入“,确保编译器是最新的</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="5018" class="mz lz it my b gy np nq l nr ns">protoc --version</span></pre><p id="76a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">向不同语言解释protoc从<code class="fe mv mw mx my b">.proto</code>文件生成代码的方式确实很有挑战性，因为对于不同的生成代码，语法会有所不同。所以我将只为JavaScript生成代码。我建议每个人参考你最喜欢的语言的官方文档。</p><p id="55aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们创建一个小的<code class="fe mv mw mx my b">.proto</code>文件。</p><h2 id="7498" class="mz lz it bd ma na nb dn me nc nd dp mi ld ne nf mk lh ng nh mm ll ni nj mo nk bi translated"><strong class="ak"> src/person.proto </strong></h2><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="a375" class="mz lz it my b gy np nq l nr ns">syntax = "proto3";<br/>message Person {<br/>  uint64 id = 1;<br/>  string email = 2;<br/>}</span></pre><p id="ea2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们为这个<code class="fe mv mw mx my b">.proto</code>生成JavaScript代码。为此，请在终端中键入以下命令:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="60c9" class="mz lz it my b gy np nq l nr ns">protoc --proto_path=src --js_out=js_out_folder src/person.proto</span></pre><p id="e2ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个参数— <code class="fe mv mw mx my b"> proto_path </code> — <code class="fe mv mw mx my b"> </code>是保存<code class="fe mv mw mx my b">.proto</code>文件的地方。<code class="fe mv mw mx my b">js_out=js_out_folder</code>表示我们需要输出JS到用户自定义文件夹<code class="fe mv mw mx my b">js_out_folder</code>。最后一个参数是<code class="fe mv mw mx my b">.proto</code>文件的路径。</p><p id="5401" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在<code class="fe mv mw mx my b">js_out_folde</code> r中生成一个名为<code class="fe mv mw mx my b">person.js</code>的JS文件，生成的文件会相当大，所以我不在这里粘贴整个文件。整个文件可以在这个<a class="ae lq" href="https://gist.github.com/amkurian/e59b2a8f8f0bde14263ae41ef4acae81" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。文件的重要部分是:</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="f1ab" class="mz lz it my b gy np nq l nr ns">proto.Person = function(opt_data) {<br/>  jspb.Message.initialize(this, opt_data, 0, -1, null, null);<br/>};<br/>goog.inherits(proto.Person, jspb.Message);</span><span id="adc3" class="mz lz it my b gy nu nq l nr ns">proto.Person.prototype.getId = function() {<br/>  return /** <a class="ae lq" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));<br/>};</span><span id="bbd1" class="mz lz it my b gy nu nq l nr ns">proto.Person.prototype.setId = function(value) {<br/>  return jspb.Message.setProto3IntField(this, 1, value);<br/>};</span><span id="c169" class="mz lz it my b gy nu nq l nr ns">proto.Person.prototype.getEmail = function() {<br/>  return /** <a class="ae lq" href="http://twitter.com/type" rel="noopener ugc nofollow" target="_blank">@type</a> {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));<br/>};</span><span id="ba08" class="mz lz it my b gy nu nq l nr ns">proto.Person.prototype.setEmail = function(value) {<br/>  return jspb.Message.setProto3StringField(this, 2, value);<br/>};</span></pre><p id="88e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到创建了一个类<code class="fe mv mw mx my b">Person</code>，并且为字段<code class="fe mv mw mx my b">id</code>和<code class="fe mv mw mx my b">email</code>定义了getters和setters。</p><p id="3f5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据语言的不同，语法会有所不同。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="678e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="0e4b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们已经看到，协议缓冲区的设计比传统的数据传输格式(如JSON或XML)更高效、更快。数据压缩可以提高速度，减少CPU的使用。</p><p id="a704" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不能说Protobuf是JSON的简单替代品，但它解决了JSON的许多问题，尤其是在使用微服务架构时。</p><p id="8bcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个代价是数据的可读性大大降低。与优点相比，这算不上什么大缺点。</p><p id="7d42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JSON和Protobuf的速度对比已经<a class="ae lq" href="https://auth0.com/blog/beating-json-performance-with-protobuf/" rel="noopener ugc nofollow" target="_blank">可用</a>。这是一项正在发展的技术，我建议每个人查看官方的<a class="ae lq" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae lq" href="https://github.com/protocolbuffers/protobuf" rel="noopener ugc nofollow" target="_blank">库</a>。</p></div></div>    
</body>
</html>