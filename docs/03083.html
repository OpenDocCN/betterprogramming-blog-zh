<html>
<head>
<title>Build a Health Check Rack Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建健康检查机架中间件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/health-check-rack-middleware-b6b126efbaa8?source=collection_archive---------11-----------------------#2020-01-19">https://betterprogramming.pub/health-check-rack-middleware-b6b126efbaa8?source=collection_archive---------11-----------------------#2020-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e890" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">确保您的应用程序全面健康</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d1223e599d1cb065b3a39b775a5accd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0NJMB-MVZfC92hqm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@hush52?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">嘘奈杜</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="61c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为软件应用程序实现健康检查端点是软件开发过程中的一种模式，也是最佳实践之一。运行状况检查端点可用于多种目的。以下是运行状况检查端点的一些使用案例列表:</p><ul class=""><li id="6e73" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">监控系统:健康检查端点可以用作监控系统的数据源，用于跟踪服务状态。基于端点的响应，可以采取行动。例如，如果其中一个端点响应503错误代码，则向紧急情况管理器发送SMS通知。</li><li id="fbf0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">负载平衡器:负载平衡器或反向代理可以利用健康检查端点来包括或排除服务池中的节点或服务器。例如，以一个负载平衡器为例，它在运行给定服务的一组节点之间平衡负载。如果其中一个节点上的服务停止，负载平衡器将自动停止向该节点转发请求，因此最终用户不会受到影响。</li><li id="98f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">容器集群:像<code class="fe mj mk ml mm b">swarm</code>或<code class="fe mj mk ml mm b">kubernetes</code>这样的容器集群解决方案也可以从服务健康检查端点获得一些好处。例如，<code class="fe mj mk ml mm b">swarm</code>使用服务健康检查来区分健康的服务和不健康的服务，从而重启不健康的服务或根据服务配置采取其他措施。</li><li id="2658" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">软件部署:运行状况检查端点还可用于自动执行部署流程，并通过检查服务依赖关系并在部署前等待它们准备就绪，或者在新版本不正常的情况下回滚到旧的运行状况良好的服务版本，来实现零停机部署。一个很好的例子是为Docker服务推出新的更新。我们可以启动新容器，检查新容器的健康状况，只有在它们健康的情况下才继续替换过程，而不是一步到位地用新容器替换旧容器。</li><li id="e240" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">安装验证:健康检查端点对于调查用例也有很大的帮助，特别是如果这些端点不仅报告服务本身的健康状况，还报告其依赖项的健康状况。一个例子是一个依赖于<code class="fe mj mk ml mm b">Redis</code>、<code class="fe mj mk ml mm b">MySQL</code>和<code class="fe mj mk ml mm b">RabbitMQ</code>的服务，它提供健康端点来报告服务和这些依赖之间的连接状态。</li></ul><p id="dee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这些用例，几乎每个服务都需要实现健康检查端点。健康检查端点的实现非常简单，可以只是一个返回服务状态的静态请求。</p><p id="235f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在几个服务中实现健康检查可能会引入一些可维护性问题，因为我们在所有受支持的服务中复制代码，如果我们决定更新健康端点(出于某种原因)，我们将需要对所有服务进行相同的更改。或者在新服务的情况下，我们需要花一些时间来为新服务实现健康检查和测试。</p><p id="d94a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，特别是在多个团队致力于实现健康检查的情况下，我们可能会在所有支持的服务中出现不一致的健康检查端点。</p><p id="665b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，尝试将健康检查端点实现到软件库中，并将该库与所有支持的服务集成在一起是很有意义的。在Rails/Rack软件应用程序的情况下，这个任务可以通过构建一个<a class="ae ky" href="https://github.com/rack/rack" rel="noopener ugc nofollow" target="_blank"> rack中间件</a>来轻松完成。web请求首先由web服务器处理，如<code class="fe mj mk ml mm b">puma</code>或<code class="fe mj mk ml mm b">unicorn</code>。这些服务器将请求代理给应用服务器。请求将由集成的中间件处理，然后由web框架处理，如<code class="fe mj mk ml mm b">Sinatra</code>或<code class="fe mj mk ml mm b">Rails</code>。该特性有助于为健康检查提供快速响应，因为它不需要由web框架处理，并且可以由中间件层提供给客户端。</p><p id="d1b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将描述构建rack中间件的尝试，该中间件为使用Rack的Ruby应用程序提供健康检查端点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8bf0" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">中间件特性</h1><p id="2eee" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下面是我的Rails应用程序所需的健康检查中间件的需求列表:</p><ul class=""><li id="fecc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">中间件支持多个健康检查端点，这些端点覆盖了服务的健康和依赖性。</li><li id="d42a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">中间件是可配置的。</li><li id="8d8f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">中间件的响应应该是<code class="fe mj mk ml mm b">JSON</code>响应。</li></ul><p id="dad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成列表中的第一项，我决定支持以下健康检查端点:</p><ul class=""><li id="b273" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">\health</code> —静态健康检查端点，可用于检查应用服务器的状态(是否运行)。该端点的响应应该是下面的<code class="fe mj mk ml mm b">JSON</code>:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="8869" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">/db_health</code> —该端点用于检查数据库连接的服务状态，并提供关于服务数据库的一些信息，例如数据库中有多少个表以及<a class="ae ky" href="https://github.com/collectiveidea/delayed_job" rel="noopener ugc nofollow" target="_blank">延迟的作业</a>信息。以下是预期的<code class="fe mj mk ml mm b">JSON</code>响应:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="b650" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">/tcp_dependencies_health</code> —该端点应该报告所有<code class="fe mj mk ml mm b">TCP</code>依赖项的状态(或者<code class="fe mj mk ml mm b">up</code>或者<code class="fe mj mk ml mm b">down</code>)。依赖关系需要使用遵循以下命名约定的环境变量进行配置:<code class="fe mj mk ml mm b">TCP_DEPENDENCY_##</code>。这些环境变量的示例如下所示:</li></ul><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="d9d0" class="nx mv it mm b gy ny nz l oa ob"># ${VAR_NAME}=${host_or_ip}:${port}<br/>TCP_DEPENDENCY_00=mysql:6604<br/>TCP_DEPENDENCY_01=redis:9089</span></pre><p id="339e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用上述变量配置的服务的预期<code class="fe mj mk ml mm b">JSON</code>响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><ul class=""><li id="5b90" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">/http_dependencies_health</code> —此端点应报告所有<code class="fe mj mk ml mm b">HTTP</code>依赖项的状态。此端点的响应将包括每个已配置依赖项的状态代码以及HTTP健康检查响应的正文。需要使用遵循以下命名约定的环境变量为每个服务配置HTTP依赖关系:<code class="fe mj mk ml mm b">HTTP_DEPENDENCY_##</code>。这些环境变量的示例如下所示:</li></ul><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="631d" class="nx mv it mm b gy ny nz l oa ob">#${VAR_NAME}=http://${host_or_ip}:${port}/${health_endpoint}<br/>HTTP_DEPENDENCY_00=<a class="ae ky" href="http://localhost:3000/health" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/health</a><br/>HTTP_DEPENDENCY_01=<a class="ae ky" href="http://localhost:80/health" rel="noopener ugc nofollow" target="_blank">http://localhost:80/health</a><br/>HTTP_DEPENDENCY_02=<a class="ae ky" href="http://localhost:80/health" rel="noopener ugc nofollow" target="_blank">http://localhost:3090/health</a></span></pre><p id="3723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用上述变量配置的服务的预期<code class="fe mj mk ml mm b">JSON</code>响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="bcba" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">履行</h1><p id="10a9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我实现了上面的特性，并发布了一个Rack middleware gem，它封装了所描述的健康检查端点。你可以在<a class="ae ky" href="https://github.com/wshihadeh/deep_health_check" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae ky" href="https://rubygems.org/gems/deep_health_check" rel="noopener ugc nofollow" target="_blank"> RubyGems </a>上找到宝石。将gem与Rack and Rails应用程序集成和使用非常简单，只需执行以下步骤即可完成:</p><ul class=""><li id="2519" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">向Rails应用程序添加gem可以通过向gem文件添加以下代码行来完成:</li></ul><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="bcd3" class="nx mv it mm b gy ny nz l oa ob">gem 'deep_health_check'</span></pre><ul class=""><li id="15d3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过将此行添加到<code class="fe mj mk ml mm b">rails</code>的<code class="fe mj mk ml mm b">application.rb</code>(添加到<code class="fe mj mk ml mm b">rack</code>的应用程序类)来使用应用程序中的中间件:</li></ul><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="4e93" class="nx mv it mm b gy ny nz l oa ob">config.middleware.insert_after Rails::Rack::Logger, DeepHealthCheck::MiddlewareHealthCheck</span></pre><ul class=""><li id="1808" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过环境变量配置<code class="fe mj mk ml mm b">TCP</code>和<code class="fe mj mk ml mm b">HTTP</code>依赖关系。中间件可以为每个<code class="fe mj mk ml mm b">TCP</code>和<code class="fe mj mk ml mm b">HTTP</code>依赖项处理多达100个依赖项。<code class="fe mj mk ml mm b">TCP</code>依赖项应该遵循以下格式:<code class="fe mj mk ml mm b">${host_or_ip}:${port}</code>。<code class="fe mj mk ml mm b">HTTP</code>依赖项应该是有效的HTTP URL。以下是这些配置的一个示例:</li></ul><pre class="kj kk kl km gt nt mm nu nv aw nw bi"><span id="4bfc" class="nx mv it mm b gy ny nz l oa ob">TCP_DEPENDENCY_00=127.0.0.0:8080<br/>TCP_DEPENDENCY_01=127.0.0.0:8080<br/></span><span id="2d0d" class="nx mv it mm b gy oc nz l oa ob">HTTP_DEPENDENCY_00=http://127.0.0.0:8080/health<br/>HTTP_DEPENDENCY_01=http://127.0.0.0:8080/health</span></pre><p id="3e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的环境变量需要对正在运行的应用程序实例可用，这些配置通常可以存储在运行具有所有其他配置(如数据库URL)的应用程序的服务器上。对于容器，这些环境变量可以在部署期间传递给容器。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="30b7" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">保护运行状况检查端点</h1><p id="c909" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">一些中间件支持的端点提供关于数据库或应用程序依赖关系的信息。这些信息不应该向公众公开，因为它可能会给应用程序带来安全风险，使其容易受到攻击。</p><p id="c414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，需要保护这些端点，以减少因暴露它们而带来的安全风险。这个任务可以简单地通过使用基本的auth凭证保护这些端点来实现(当然，还有其他选项)。<a class="ae ky" href="https://github.com/wshihadeh/deep_health_check/blob/master/NGINX.md" rel="noopener ugc nofollow" target="_blank">本页</a>提供了使用基本身份验证凭证完成此任务所需的所有必要步骤。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ac75" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="2ea0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">运行状况检查端点可用于许多目的和使用情形，例如监控或零停机软件部署。大多数应用程序都需要执行健康检查。本文描述了一种为Ruby/Rack应用程序实现和集成健康检查端点的方法。</p></div></div>    
</body>
</html>