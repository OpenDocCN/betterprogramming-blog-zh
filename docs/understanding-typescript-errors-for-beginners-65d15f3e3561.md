# 初学者理解打字稿错误

> 原文：<https://betterprogramming.pub/understanding-typescript-errors-for-beginners-65d15f3e3561>

## 如何减轻编译错误的认知负担，让您开始觉得使用 TypeScript 很有效率

![](img/15b2e356d86297fd4c6854cc97b3e82f.png)

作者插画的矢量艺术

最近，我在 Twitter 上看到了一些关于 TypeScript 的激烈辩论，这恰好与我让一些新开发人员加入一个基于 TypeScript 的项目不谋而合。

这一切都始于詹姆斯·龙(James Long)的一条推文，他是一名有着 15 年经验的开发人员，他质疑它在非常具体的情况下是否有用。我过去加入的开发人员对 TypeScript 也有类似的看法。他们断言这是不值得的，学习曲线太长，并且会降低项目新开发人员的生产力。

James Long 的推文——我仍然不相信探索架构是值得的

我想回应这条推文，并提供我的观点，但已经有这么多的回应，我不想堆积。如此多的人热情地为 TypeScript 辩护，以至于龙先生最终发出了一些其他的推文，包括下面的。我感觉很糟糕——社区应该欢迎和接受新的想法，而不是排斥一个基本的想法，以至于产生抵触情绪。

詹姆斯·朗的推特——永远不要发关于 TypeScript 的推特

我相信 Long 先生遇到的只是一些关于 TypeScript 的额外认知开销，当定期使用 TypeScript 时，这些开销会随着时间的推移而减少。即使在重新架构或者不断重构的时候，如果你已经习惯了的话，在编写剩余代码的过程中，改变类型仍然只占很小一部分时间。

不仅如此，有时候重构真的有助于确保你不会错过任何东西。

但是，我想我应该写一篇文章来帮助 TypeScript 初学者最小化解码一些更隐晦的 TypeScript 错误的认知开销，以便他们可以更快地提高工作效率，而不是堆积在 tweet 响应上。因为，归根结底，这场争论是关于生产率，而不是类型安全。下面是我看到的新 TypeScript 开发人员遇到的一些妨碍他们工作效率的更常见的问题。

# “不可分配”错误并不总是指分配运算符- TS(2322)

当我第一次开始使用 TypeScript 时，我最大的挫折之一是一些错误消息的不确定性。来自像 Scala 和 Rust 这样的强类型语言——其中的错误消息往往会告诉你到底哪里出了问题，以及如何修复它(在 Rust 的情况下，它还会为你点一份披萨，给你按摩一下脖子🤣)—我觉得 TypeScript 中的错误信息有时会让我陷入徒劳无功的境地。

最让我沮丧的错误消息是`not assignable ts(2322)` 错误。清单 1 提供了这样一个错误消息的例子。我会对整个项目进行解析，试图找到我试图将一个“字符串”赋给一个“数字”的地方(使用示例中的类型)，结果却发现“这个文件中根本没有赋值操作符！”

清单 1 —引用 TypeScript 函数的返回类型的错误消息

我最终意识到，有时`ts(2322)`只是说一个函数不能返回你在返回语句中提供的类型。在这个例子中，当我实际上将函数定义为需要返回一个`number`时，我试图返回一个`string`。

在其他语言中，编译器会明确地告诉我，我正试图从一个函数返回错误的类型。但是在 TypeScript 中(它更像是一个静态类型分析器，而不是一个成熟的强类型语言),它反而说我试图给*分配*错误的类型。

下面的表达式(实际上有一个赋值操作符)会抛出同样的错误消息:`const exampleNumber: number = 'ab'`。所以你可以明白为什么这让我如此困惑。也就是说，一旦我意识到这种情况正在发生，我就开始在遇到`ts(2322)`时检查这个场景。

现在，这个错误信息是我的第二天性。理解 TypeScript 就是重复，看到一个错误模式，然后一遍又一遍地解决它。

# 找不到模块 TS 的声明文件(7016)

新的 TypeScript 开发人员在基于 TypeScript 的项目中遇到的一个非常常见的问题是“找不到模块的声明文件…”错误。这个错误只是告诉您，您从 npm 导入的模块没有任何关联的类型，这意味着它是用 JavaScript 开发的，或者 npm 没有附带任何类型文件。

幸运的是，正如您在清单 2 中看到的，错误消息非常有用。它告诉你要解决这个问题，安装来自`@types`“确定类型”模块的类型。“明确类型化”是 npm 上的一个开源名称空间，贡献者可以在其中为他们喜欢的项目发布类型文件，这些项目没有开箱即用的类型。你可以去[明确键入的](https://definitelytyped.org/)网站[搜索你的包](https://www.typescriptlang.org/dt/search?search=)看看是否存在。

清单 TypeScript 中 ts(7016)错误消息的示例

如果您的包不存在于明确类型上，您可以通过在类型声明文件中声明一个同名的模块来退出对该特定模块的类型检查。清单 3 显示了这样一个声明的例子。正如您所看到的，如果您在项目的根目录下添加一个`declarations.d.ts`文件，并确保有一个针对抛出错误的模块的声明，`ts(7016)`应该会消失。

清单 3 —示例类型声明文件。

# 无商标消费品

我经常看到刚接触 TypeScript 的开发人员擅长在他们不理解的代码中复制模式，但最终会在出现问题时询问他们。泛型就是这样一种模式。问题最终出现了，“这些尖括号实际上是什么意思？”

那些尖括号指的是泛型类型，你必须理解泛型，才能读懂类型错误。一个[泛型](https://www.typescriptlang.org/docs/handbook/2/generics.html)是由 TypeScript 提供的一个工具，它允许开发者创建一个可重用的 API，下游开发者实际上可以向 API 提供他们自己的类型来影响它的行为。泛型的 [TypeScript 文档实际上非常好，所以我建议阅读一下以了解更多信息。](https://www.typescriptlang.org/docs/handbook/2/generics.html)

# 处理未定义的错误

TypeScript 初学者的另一个常见错误是认为因为没有编译时错误，所以也就没有运行时错误。例如，我见过工程师从 HTTP 请求的响应中提供预期的类型，TypeScript 编译器在整个应用程序中以这种方式处理响应，因此没有编译时错误。

但是，一旦应用程序运行并且从服务器返回一个对象，整个应用程序就会崩溃，出现白屏死机(在 React 应用程序没有错误边界的情况下),并且控制台中会出现一条错误消息:

> `undefined`的`id’`无法读取属性。"

房地产`id`只是这个特定信息中的一个例子。但重要的是，您要理解来自应用程序外部的数据并不一定是您所说的那种类型。因此，任何时候你使用`as`关键字或者在 API 中使用泛型来转换类型，都有可能转换值，你需要明白那里有运行时错误的机会。

处理这种特殊错误的常见方法是使用可选的链接和 nullish 合并操作符。清单 4 提供了这些操作符的一个例子。

清单 4 —可选链接和无效合并的示例

如您所见，可选链接中提供的问号防止我们得到`Cannot read property 'type' of undefined`错误。如果表达式的左边为空或未定义，双问号(nullish 合并)允许我们默认为另一个值。

之所以有必要这样做，是因为第 1 行中提供给 API 的`<Character>`泛型将响应转换为`Character`类型，它假设在`Character`接口中定义的所有属性都可用。

# 属性“X”在类型“Y”上不存在— TS(2339)

我见过许多初学者在知道他们试图使用的类型上存在一个属性时，对这个错误感到沮丧。通常，他们会遇到比他们试图使用的类型更不具体或抽象的类型，这意味着他们试图访问的属性类型是函数允许他们使用的类型的扩展。

另一种可能的情况是，他们需要使用的类型实际上是联合类型，因此类型系统将只允许他们使用那些联合类型共有的属性(否则无法保证他们想要使用的类型将是可用的)。清单 5 提供了一个扩展类型和联合类型的例子。

清单 5 —如何使用类型保护来处理类型扩展和联合类型。

在本例中，属性`gender`仅在类型`Character`上可用，在类型`Noun`或类型`Setting`上不可用。因此，试图从函数内部访问`gender`将会抛出一个`ts(2339)` TypeScript 错误。

在清单 5 的第一个例子中，`Noun`类型与`Character`和`Setting`都有共同的属性，但是由于函数需要一个`Noun`(`Character`和`Setting`都扩展了它，因此可以作为有效类型传递给这个函数)，所以它只能访问共同的属性。

在示例 2 中也是如此，其中提供了联合类型`Character`和`Setting`。如果我们想访问一个只存在于`Character`上的属性，那么我们必须让类型系统知道`noun`参数是否是一个`Character`。

在这一点上，我看到许多开发人员感到沮丧，并求助于将函数体中的`noun`转换为`any`类型或`Character`。*但是请忍住投*的冲动！

相反，使用类型保护来检查属性`gender`是否存在。如果是的话，那么类型系统可以安全地假设`noun`是其后的`Character`。

清单 5 中的`models.ts`文件的第 16 行提供了一个[类型保护](https://www.typescriptlang.org/docs/handbook/advanced-types.html)的例子。编写类型保护的关键是类型保护函数的返回类型中的关键字`is`。通过声明输入参数`is`是返回类型中的某个类型，类型守卫需要做的就是返回一个布尔值来验证该声明，类型系统会处理剩下的事情。

# 滚动到错误消息的底部

我倾向于给第一次使用 TypeScript 的新开发人员的最大提示是滚动到错误消息的底部。通常错误信息中有很多干扰，很难理解到底是什么问题。清单 6 提供了一个嵌套错误消息的例子。

清单 TypeScript 中的嵌套错误消息

所有的泛型和嵌套状态都与这个特定的错误相关联，很难理解真正的问题是什么。对于新的 TypeScript 开发人员来说，这个错误消息变得令人不知所措——好像编译器在对他们吼叫。有太多事情不对劲了！

然而，这实际上只是说一个`string`不能被赋值给一个类型`Partial<Character>`，并且所有的信息都在错误消息的最后一行。

这到底是怎么回事？为什么错误信息这么大？

TypeScript 正在遍历可能存在类型冲突的树，直到在根处找到确切的问题。在阅读时尝试扫描整个树有时会很有用，但大多数时候最好滚动到错误消息的底部，从问题的基础开始。

即使找到了问题的根源，有时它也可能被您在项目中使用的不同库或框架插入的泛型类型所隐藏。

在这个例子中，`ActionCreatorWithPayload<>`包装了实际的错误，并且来自 Redux Toolkit。如果您没有在错误消息中明确定义泛型，那么可以安全地假设类型的这一部分没有任何问题，而是它所包装的东西(在本例中是`Partial<Character>`)。

# 结论

希望这些提示能帮助你开始觉得使用 TypeScript 更有效率。重复是关键。您遇到的 TypeScript 错误越多，并且知道如何解决它们，下次解决这些相同的错误就越容易。

你将开始学习模式，很快认知开销将会很低，以至于 TypeScript 在运行时错误中为你节省的时间将远远超过心理开销。

我最大的建议是不要放弃使用`any`类型或`@ts-ignore`注释来退出类型检查。你做得越多，而不是真正理解问题是什么，学习 TypeScript 就越难。

此外，让你的生活更简单，不要使用长而复杂的内联类型。使用接口、枚举和类型别名。您的代码将更容易阅读，您的类型将更容易在整个项目中引用。

如果你遇到了其他常见的类型错误，或者需要帮助，请在评论中提出来，我会尽我所能给予回复。

祝你好运！