<html>
<head>
<title>URLSession: Common Pitfalls With Background Download and Upload</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">URLSession:后台下载和上传的常见陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/urlsession-common-pitfalls-with-background-download-upload-tasks-8d479a1698fe?source=collection_archive---------1-----------------------#2019-04-23">https://betterprogramming.pub/urlsession-common-pitfalls-with-background-download-upload-tasks-8d479a1698fe?source=collection_archive---------1-----------------------#2019-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e210" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是小事造成了不同</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17a6279ac8d9deb66a62e8770dcf9533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-y32dox9Ekq_omzFaZXHA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·尼克斯在<a class="ae ky" href="https://unsplash.com/search/photos/escalator?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">URLSession使您能够从后台下载和上传。虽然基础看起来很简单，但要做对却相当困难。从可用的资源和文档来看，有相当多的小事情对于后台上传工作非常重要。</p><p id="9bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的日常工作，我正在为WeTransfer的<a class="ae ky" href="https://collect.wetransfer.com/" rel="noopener ugc nofollow" target="_blank">收集</a>应用程序开发新功能。其中一个功能是后台下载和上传，这两个功能都可以通过应用程序扩展来触发。尽管第一个版本很容易安装，但它有很多缺陷。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e13" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">常见陷阱</h1><p id="c902" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这篇文章中，我将讨论一些常见的陷阱。如果你正在寻找设置后台下载和上传的方法，看看苹果的这个<a class="ae ky" href="https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_in_the_background" rel="noopener ugc nofollow" target="_blank">文档</a>来启动你的实现。当然，在那之后，回头读一读我的经验，让自己远离常见的陷阱。</p><h2 id="6b18" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">1.每个URLSessionConfiguration都需要一个唯一的标识符</h2><p id="f7bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您的主机应用程序通过以下方法传递的标识符重新启动时，如果您从应用程序扩展触发后台下载或上传，这主要是一个问题:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3644" class="mz md it nm b gy nq nr l ns nt">func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -&gt; Void)</span></pre><p id="087e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以忽略传递的标识符，并像对您的主机应用程序一样重新构建URLSession。然而，使用应用程序扩展，您需要处理多个URLSession实例。其中每个都需要自己的自定义标识符，并且在重建会话时也需要使用该标识符。</p><p id="7f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是在阅读了苹果公司的<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1" rel="noopener ugc nofollow" target="_blank">文档</a>后得出这个结论的，该文档指出:</p><blockquote class="nu nv nw"><p id="aa66" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">因为一次只有一个进程可以使用后台会话，所以您需要为包含它的应用及其每个应用扩展创建不同的后台会话。(每个后台会话应该有一个唯一的标识符。)当应用程序在后台启动时，建议您的包含应用程序仅使用由其一个扩展创建的后台会话来处理该扩展的事件。如果您需要在包含您的应用程序中执行其他网络相关任务，请为它们创建不同的URL会话。”</p></blockquote><p id="e32f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们来说，这基本上意味着您需要为任何传入的标识符创建一个新的URLSession，并缓存该实例。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d16e" class="mz md it nm b gy nq nr l ns nt">/// Contains any `URLSession` instances associated with app extensions.<br/>private lazy var appExtensionSessions: [URLSession] = []<br/><br/>/// Creates an identical `URLSession` for the given identifier or returns an existing `URLSession` if it was already registered.<br/>///<br/>/// - Parameter identifier: The `URLSessionConfiguration` identifier to use for recreating the `URLSession`.<br/>/// - Returns: A newly created or existing `URLSession` instance matching the given identifier.<br/>private func session(for identifier: String) -&gt; URLSession {<br/>    if let existingSession = appExtensionSessions.first(where: { $0.configuration.identifier == identifier }) {<br/>        return existingSession<br/>    } else {<br/>        let configuration = URLSessionConfiguration.background(withIdentifier: identifier)<br/>        configuration.sharedContainerIdentifier = appGroup<br/>        let appExtensionSession = URLSession(configuration: configuration, delegate: self, delegateQueue: sessionOperationQueue)<br/>        appExtensionSessions.append(appExtensionSession)<br/>        return appExtensionSession<br/>    }<br/>}</span></pre><h2 id="3bd3" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">2.基于包的标识符</h2><p id="e362" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了安全起见，您可以使用以下代码来确保您的URLSessionConfiguration标识符始终是唯一的:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8074" class="mz md it nm b gy nq nr l ns nt">let appBundleName = Bundle.main.bundleURL.lastPathComponent.lowercased().replacingOccurrences(of: " ", with: ".")<br/>let sessionIdentifier: String = "com.wetransfer.networking.\(appBundleName)"<br/>let configuration = URLSessionConfiguration.background(withIdentifier: sessionIdentifier)</span></pre><h2 id="99c4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">3.不要忘记共享容器标识符</h2><p id="985e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你在应用扩展中实现后台下载和上传，你需要设置共享容器标识符。由于应用程序扩展很快被终止，你需要确保你正在后台URLSession上执行这些数据任务。关于设置共享容器的指导，您可以参考<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1" rel="noopener ugc nofollow" target="_blank">与您的包含应用</a>共享数据。相同的链接包含处理应用程序扩展中常见场景的信息，还包括下载和上传。</p><p id="ad41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以按如下方式设置标识符:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e5ff" class="mz md it nm b gy nq nr l ns nt">let configuration = URLSessionConfiguration.background(withIdentifier: "swiftlee.background.url.session")<br/>configuration.sharedContainerIdentifier = "group.swiftlee.apps"</span></pre><h2 id="4e60" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">4.仅支持从文件上传任务</h2><p id="f05e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这意味着你必须从一个文件上传。首先在本地保存文件，然后从该文件位置开始上传。应用程序退出后，从数据实例或流上传会直接失败。因此，请密切注意这里，因为它可能看起来第一次工作。然而，我们在后台上传，这必须工作！</p><h2 id="3ff3" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">5.这个参数真的很伤人</h2><p id="d707" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我记得自己坐在书桌前，盯着屏幕。直到我插上手机充电器，下载才开始。在阅读了几乎所有方法和参数的文档后，我遇到了<code class="fe ob oc od nm b">isDiscretionary</code>属性:</p><blockquote class="nu nv nw"><p id="4746" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">对于使用<code class="fe ob oc od nm b">background(withIdentifier:)</code>方法创建的配置对象，使用此属性让系统控制何时应该进行传输</p></blockquote><p id="0dd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我开始思考。继续阅读:</p><blockquote class="nu nv nw"><p id="68d2" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">“当传输大量数据时，建议您将该属性的值设置为<code class="fe ob oc od nm b">true</code>。这样做可以让系统将这些传输安排在最适合设备的时间进行。例如，系统可能会延迟传输大文件，直到设备插上电源并通过Wi-Fi连接到网络。”</p></blockquote><p id="8e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这完全说得通！</p><p id="68af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要明确的是，在某些情况下将这个属性设置为<code class="fe ob oc od nm b">true</code>是很好的。然而，对于Collect应用程序的用例，我们需要即时下载和上传。因此，我们必须将该属性设置回其默认值<code class="fe ob oc od nm b">false</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4115" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="092e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就是这样！我的很多心得都与你分享。希望它能节省你的时间和一些麻烦。让我知道你的缺点，这样我就可以继续改进这篇文章。</p><p id="90ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>