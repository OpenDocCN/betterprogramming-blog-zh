<html>
<head>
<title>Python Modules That Make Handling JSON Even Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python模块使得处理JSON更快</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-modules-that-make-handling-json-even-faster-f577d8948a5?source=collection_archive---------1-----------------------#2022-09-08">https://betterprogramming.pub/python-modules-that-make-handling-json-even-faster-f577d8948a5?source=collection_archive---------1-----------------------#2022-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc03" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不仅仅是普通的JSON库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e0547458d83341eee5187db85ec3422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hxhbfOSVLske2JONQYrAA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae ky" href="https://unsplash.com/s/photos/json?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="55e6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">解析JSON是软件开发的必然之恶。如果你正在与一个API交互，在主机之间发送消息或者抓取数据，那么它可能在JSON中。Python附带了标准的<code class="fe mc md me mf b">json</code>库，在大多数情况下，这已经足够了，但是对于某些场景，您可能想要更灵活、更快一些的东西。</p><p id="a98c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您正在构建一个需要大量JSON的应用程序或库，那么投资一个更健壮的模块是值得的。在这篇文章中，我们将看到一些杰出的模块，它们可以让你以普通模块无法想象的方式分割JSON。这些模块中的一些在速度上也比标准的<code class="fe mc md me mf b">json</code>库有了显著的提高。</p><h2 id="04ab" class="mg mh it bd mi mj mk dn ml mm mn dp mo lp mp mq mr lt ms mt mu lx mv mw mx my bi translated">1.<a class="ae ky" href="https://github.com/ijl/orjson#install" rel="noopener ugc nofollow" target="_blank">奥逊</a></h2><div class="mz na gp gr nb nc"><a href="https://github.com/ijl/orjson" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">GitHub - ijl/orjson:快速、正确的Python JSON库，支持dataclasses、datetimes和numpy</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">orjson是一个快速、正确的Python JSON库。它作为JSON最快的Python库进行了基准测试，并且更…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><p id="f5d8" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你要处理大量复杂的JSON对象，并且需要事情发生得<em class="nr">超快</em>，那么<code class="fe mc md me mf b">orjson</code>模块就是为你准备的。这个模块比默认的Python <code class="fe mc md me mf b">json</code>库更快，并且能够处理许多不同的数据类型(包括NumPy)。</p><p id="cd35" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个库的主要好处是速度和效率，它有一些令人印象深刻的统计数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/0c043f0f4d3f813e1aed36271977178d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GTBkNqsIPPFZvffUwIXSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/ijl/orjson" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="ded5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">虽然这不是默认的<code class="fe mc md me mf b">json</code>模块的直接替代，但速度和效率的好处使它对数据管道特别有吸引力。如果您正在与解析瓶颈作斗争，那么这可能是您的模块圣杯。</p><h2 id="a183" class="mg mh it bd mi mj mk dn ml mm mn dp mo lp mp mq mr lt ms mt mu lx mv mw mx my bi translated">2.<a class="ae ky" href="https://github.com/tortilla/tortilla" rel="noopener ugc nofollow" target="_blank">玉米饼</a></h2><div class="mz na gp gr nb nc"><a href="https://github.com/tortilla/tortilla" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">GitHub - tortilla/tortilla:轻松包装web APIs。</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">包装web APIs变得容易。通过pip安装:PIP安装玉米粉圆饼快速使用概述:玉米粉圆饼使用一点…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nt l nn no np nl nq ks nc"/></div></div></a></div><p id="ffb7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">玉米粉圆饼太棒了，它会让你说:“<em class="nr">我的一生都在哪里！？</em>”。这个模块将接受几乎所有的API，并对其进行包装，这样您就可以像使用一组普通的Python方法一样使用它。最好的一点是，结果被存储为普通属性，这样您就可以访问它们，而不必将任何原始的JSON放入适当的位置。</p><p id="bdfc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个模块很神奇。如果你一直在一遍又一遍地手工构建自己的客户端API解析逻辑，那么停下来，后退一步，现在就尝试这个模块。</p><p id="2121" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">查看一个例子，了解玉米饼如何轻松地与<a class="ae ky" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder API </a>一起工作:</p><pre class="kj kk kl km gt nu mf nv nw aw nx bi"><span id="5a47" class="mg mh it mf b gy ny nz l oa ob">import tortilla</span><span id="9cb3" class="mg mh it mf b gy oc nz l oa ob">api = tortilla.wrap('<!-- -->https://jsonplaceholder.typicode.com')</span><span id="8412" class="mg mh it mf b gy oc nz l oa ob">todo = api.todos(1).get()</span><span id="4059" class="mg mh it mf b gy oc nz l oa ob">print(todo)</span><span id="7ec6" class="mg mh it mf b gy oc nz l oa ob">&gt;&gt;&gt; {'userId': 1, 'id': 1, 'title': 'delectus aut autem', 'completed': False}</span></pre><p id="f438" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">你所需要做的就是提供玉米粉圆饼的基本网址，它会自动为你包装好。就像真的玉米饼一样！</p><h2 id="97cd" class="mg mh it bd mi mj mk dn ml mm mn dp mo lp mp mq mr lt ms mt mu lx mv mw mx my bi translated">3.<a class="ae ky" href="https://github.com/jsonpickle/jsonpickle" rel="noopener ugc nofollow" target="_blank"> jsonpickle </a></h2><div class="mz na gp gr nb nc"><a href="https://github.com/jsonpickle/jsonpickle" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">GitHub-JSON pickle/JSON pickle:Python库，用于将任意对象图序列化为…</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">Python库，用于将任意对象图序列化为JSON。它可以接受几乎任何Python对象，并把…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="od l nn no np nl nq ks nc"/></div></div></a></div><p id="a29a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个模块真的很酷，让pickling Python对象更具可读性。大多数其他pickle库将以不可读的格式存储序列化数据。打开其中一个文件，你会看到随机的垃圾。</p><p id="521c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe mc md me mf b">jsonpickle</code>模块将以人类可读的JSON格式存储相同的pickled Python对象。您将能够打开序列化的对象并实际读取它们，而不仅仅是看到乱码。</p><p id="1b0b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，假设我们创建了以下类和对象:</p><pre class="kj kk kl km gt nu mf nv nw aw nx bi"><span id="8cb0" class="mg mh it mf b gy ny nz l oa ob">class Foo:<br/>    self.bar = 1</span><span id="fc9e" class="mg mh it mf b gy oc nz l oa ob">foo = Foo()</span></pre><p id="2261" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们想将这个基本对象序列化为JSON，我们可以使用<code class="fe mc md me mf b">jsonpickle</code>很容易地做到这一点:</p><pre class="kj kk kl km gt nu mf nv nw aw nx bi"><span id="e2ba" class="mg mh it mf b gy ny nz l oa ob">import jsonpickle</span><span id="ed6a" class="mg mh it mf b gy oc nz l oa ob">jsonpickle.dumps(foo)</span><span id="c17f" class="mg mh it mf b gy oc nz l oa ob">&gt;&gt;&gt; '{"py/object": "__main__.Foo", "bar": 1}'</span></pre><p id="8ced" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果您想序列化对象，但让它们继续被一些外部进程、索引器或人读取，这是非常方便的。</p><h2 id="f6e2" class="mg mh it bd mi mj mk dn ml mm mn dp mo lp mp mq mr lt ms mt mu lx mv mw mx my bi translated">4.<a class="ae ky" href="https://github.com/xlwings/jsondiff" rel="noopener ugc nofollow" target="_blank"> jsondiff </a></h2><div class="mz na gp gr nb nc"><a href="https://github.com/xlwings/jsondiff" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">GitHub-XL wings/JSON Diff:Python中的Diff JSON和类JSON结构</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">Python中的Diff JSON和类JSON结构。在…上创建一个帐户，为xlwings/jsondiff的开发做出贡献</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="oe l nn no np nl nq ks nc"/></div></div></a></div><p id="bdf4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">假设你正在和一大堆JSON争论。假设你需要找出这个斑点和你刚刚收集的另一个斑点有什么不同。你可以自己浏览内容，试着找出变化，或者你可以采取更明智的方法:使用<code class="fe mc md me mf b">jsondiff</code>模块。</p><p id="8602" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这个模块为您提供了快速区分两个不同JSON对象的能力。假设您有以下JSON blobs:</p><pre class="kj kk kl km gt nu mf nv nw aw nx bi"><span id="4273" class="mg mh it mf b gy ny nz l oa ob">blob_1 = {'one': 1, 'two': 2, 'three': 3}<br/>blob_2 = {'one': 1, 'two': 22, 'three': 3}</span></pre><p id="3261" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我知道发现差异很容易，但是让<code class="fe mc md me mf b">jsondiff</code>模块为我们找到它:</p><pre class="kj kk kl km gt nu mf nv nw aw nx bi"><span id="35fe" class="mg mh it mf b gy ny nz l oa ob">import jsondiff</span><span id="ef09" class="mg mh it mf b gy oc nz l oa ob">jsondiff.diff(blob_1, blob_2)</span><span id="fa55" class="mg mh it mf b gy oc nz l oa ob">&gt;&gt;&gt; {'two': 22}</span></pre><p id="ca66" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">想象一下用一个包含数千个字符和大量嵌套对象的blob来做这件事。没有<code class="fe mc md me mf b">jsondiff</code>就像大海捞针。使用这个模块的另一个好处是，您可以以编程方式寻找差异，并在API错误进入生产环境之前捕获它们。</p><h2 id="7920" class="mg mh it bd mi mj mk dn ml mm mn dp mo lp mp mq mr lt ms mt mu lx mv mw mx my bi translated">5.<a class="ae ky" href="https://github.com/wolverdude/GenSON" rel="noopener ugc nofollow" target="_blank">根森</a></h2><div class="mz na gp gr nb nc"><a href="https://github.com/wolverdude/GenSON" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">GitHub-wolverdude/GenSON:GenSON是一个强大的、用户友好的JSON模式生成器，内置于…</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">GenSON是一个强大的、用户友好的JSON模式生成器，内置于Python中。GenSON的核心功能是把JSON…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="of l nn no np nl nq ks nc"/></div></div></a></div><p id="eafe" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当您处理大量JSON数据时，您可能还想为JSON blobs设置特定的格式和类型。实现这一点的方法之一是生成一个JSON模式。使用模式，您可以为整个JSON结构指定字段类型、需求和其他属性。</p><p id="c73b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">用Python生成JSON模式的一个很好的库是<a class="ae ky" href="https://github.com/wolverdude/GenSON" rel="noopener ugc nofollow" target="_blank"> GenSON </a>模块。该模块允许您使用非常简单的构建器语法生成JSON模式。现在让我们构建一个简单的模式:</p><pre class="kj kk kl km gt nu mf nv nw aw nx bi"><span id="624f" class="mg mh it mf b gy ny nz l oa ob">from genson import SchemaBuilder</span><span id="7d50" class="mg mh it mf b gy oc nz l oa ob">schema_builder = SchemaBuilder()<br/>schema_builder.add_schema({"type": "object", "properties": {}})<br/>schema_builder.add_object({"my_obj": 123})</span><span id="c6f4" class="mg mh it mf b gy oc nz l oa ob">schema_builder.to_schema()</span><span id="9db1" class="mg mh it mf b gy oc nz l oa ob">&gt;&gt;&gt; {'$schema': '<a class="ae ky" href="http://json-schema.org/schema#'" rel="noopener ugc nofollow" target="_blank">http://json-schema.org/schema#'</a>, 'type': 'object', 'properties': {'my_obj': {'type': 'integer'}}, 'required': ['my_obj']}</span></pre><p id="3d0a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这里，我们构建了一个非常小的模式，但仍然是一个模式。它包含一些基本信息，如模式引用和相关对象的类型信息。</p><p id="4bc0" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">构建一个JSON模式会变得非常复杂。有关类型和其他模式约定的更多细节，请查看官方JSON模式文档。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="de2b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">感谢阅读！如果你喜欢这篇文章，请<a class="ae ky" href="https://tateg.medium.com/follow" rel="noopener">关注</a>和<a class="ae ky" href="https://tateg.medium.com/subscribe" rel="noopener">订阅</a>了解更多内容。在你离开之前，看看我下面的其他一些帖子:</p><ul class=""><li id="a145" class="og oh it li b lj lk lm ln lp oi lt oj lx ok mb ol om on oo bi translated"><a class="ae ky" href="https://medium.com/geekculture/5-cloud-api-development-tools-you-should-use-a3f89d8a6076" rel="noopener"> <em class="nr"> 5你应该使用的云API开发工具</em> </a></li><li id="7e50" class="og oh it li b lj op lm oq lp or lt os lx ot mb ol om on oo bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-poll-sockets-using-python-3e1af3b047"> <em class="nr">如何使用Python轮询套接字</em> </a></li><li id="2853" class="og oh it li b lj op lm oq lp or lt os lx ot mb ol om on oo bi translated"><a class="ae ky" href="https://medium.com/geekculture/5-python-libraries-that-make-everyday-coding-simpler-a04064c305c" rel="noopener"> <em class="nr"> 5个让日常编码更简单的Python库</em> </a></li></ul></div></div>    
</body>
</html>