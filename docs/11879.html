<html>
<head>
<title>An Introduction to Sequelize, a Node.js Object-Relational Mapper (ORM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sequelize简介，Node.js对象关系映射器(ORM)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-sequelize-a-node-js-object-relational-mapper-orm-267a51c2d978?source=collection_archive---------1-----------------------#2022-04-24">https://betterprogramming.pub/an-introduction-to-sequelize-a-node-js-object-relational-mapper-orm-267a51c2d978?source=collection_archive---------1-----------------------#2022-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="be8e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从web应用程序内部管理数据的更好方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/99500994c57f0d8525b0b25507ce81be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0HA_9ZjT9Adjypo1fwhUw.png"/></div></div></figure><h1 id="4c06" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="44ea" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Sequelize 是Node.js的一个流行的对象关系映射器(ORM)。ORM是一个库，负责管理应用程序中的数据，特别是(a)用面向对象的编程语言编写的应用程序，以及(b)在数据库中持久存储数据的应用程序。</p><p id="a45f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">本文首先介绍ORMs，然后概述Sequelize的基本功能，包括:</p><ul class=""><li id="7ae6" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">安装Sequelize</li><li id="547c" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">连接到数据库；</li><li id="41cb" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">定义模型；</li><li id="c995" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">创建模型实例；</li><li id="d43a" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">查询模型；</li><li id="514e" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">创建模型之间的关联；和</li><li id="563c" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">涉及关联的查询。</li></ul><h1 id="55bd" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">先决条件</h1><p id="bcb6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">本文假设您对以下内容有所了解:</p><ul class=""><li id="420d" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">面向对象编程(OOP)；</li><li id="d29b" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">JavaScript和</li><li id="6439" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">结构化查询语言(SQL)。</li></ul><h1 id="1adc" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">什么是ORM，它有什么好处？</h1><p id="691b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">尽管<a class="ae mf" href="https://docs.sqlalchemy.org/en/13/orm/tutorial.html" rel="noopener ugc nofollow" target="_blank">是针对特定ORM </a>编写的，但以下定义可适用于整体ORM:</p><blockquote class="mz na nb"><p id="fc6e" class="lj lk nc ll b lm mg jr lo lp mh ju lr nd mi lu lv ne mj ly lz nf mk mc md me ij bi translated">SQLAlchemy对象关系映射器提供了一种将用户定义的Python类与数据库表相关联，并将这些类(对象)的实例与其对应表中的行相关联的方法。它包括一个透明地同步对象及其相关行之间的所有状态变化的系统(称为工作单元),以及一个根据用户定义的类及其相互之间的定义关系来表达数据库查询的系统。</p></blockquote><p id="c272" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">ORM创建了两种完全不同的数据表示之间的映射:OOP语言的类和类实例(对象),以及关系数据库的表和行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="06dd" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">ORM使这两个组保持同步，因此每当应用程序中的类或实例发生变化时，相应的数据库表或行也会发生变化。</p><p id="f4c2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">数据库语句和查询可以用您选择的编程语言编写，ORM将这些指令转换成数据库可以理解的SQL代码。</p><p id="b7cf" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">编写复杂的SQL查询可能是一个漫长而繁琐的过程，因此使用ORM可以节省开发时间。这里的<a class="ae mf" href="https://stackoverflow.com/questions/494816/using-an-orm-or-plain-sql" rel="noopener ugc nofollow" target="_blank"/>、这里的<a class="ae mf" href="https://stackoverflow.com/questions/40696435/sqlalchemy-orm-vs-raw-sql-queries?noredirect=1&amp;lq=1" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae mf" href="https://www.altexsoft.com/blog/object-relational-mapping/" rel="noopener ugc nofollow" target="_blank"/>讨论了使用ORM与简单编写原始SQL的功效。</p><h1 id="8715" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">Node.js ORMs</h1><p id="a367" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">许多库实现了ORM技术。Node.js世界里有<a class="ae mf" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>、<a class="ae mf" href="https://bookshelfjs.org/" rel="noopener ugc nofollow" target="_blank">书架</a>、<a class="ae mf" href="https://sailsjs.com/documentation/reference/waterline-orm" rel="noopener ugc nofollow" target="_blank">水线</a>、<a class="ae mf" href="https://vincit.github.io/objection.js/" rel="noopener ugc nofollow" target="_blank">异议</a>等等。Sequelize是SQL数据库最流行的Node.js ORM(在撰写本文时GitHub上有26k颗星)。</p><h1 id="8a11" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">序列</h1><p id="2306" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Sequelize的<a class="ae mf" href="https://github.com/sequelize/sequelize" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>包括以下对该库的描述:</p><blockquote class="mz na nb"><p id="21da" class="lj lk nc ll b lm mg jr lo lp mh ju lr nd mi lu lv ne mj ly lz nf mk mc md me ij bi translated">Sequelize是一个易于使用且基于承诺的Node.js ORM工具，适用于Postgres、MySQL、MariaDB、SQLite、DB2、Microsoft SQL Server、Snowflake和IBM i。它具有可靠的事务支持、关系、急切加载和延迟加载、读取复制等特性。</p></blockquote><h1 id="8f32" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">装置</h1><p id="1884" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">本文中的示例使用了SQLite3数据库。</p><p id="0309" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">可以使用节点包管理器(npm)将Sequelize添加到Node.js项目中。还需要安装特定数据库的驱动程序。在终端中键入以下命令将创建一个安装了Sequelize的新Node.js项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="9e3e" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">关系</h1><p id="d6a6" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们需要创建一个<code class="fe ni nj nk nl b">Sequelize </code>类的实例来连接我们的数据库。<code class="fe ni nj nk nl b">Sequelize</code>构造函数根据我们使用的数据库类型采用不同的参数。当使用SQLite3数据库时，我们传递两个参数—数据库方言(' SQLite ')和SQLite3存储文件的路径:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b87b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">使用全功能的关系数据库管理系统(RDBMS ),如MySQL和PostgreSQL，要求我们传递比SQLite3示例中更多的参数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="3298" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">模型</h1><p id="58b0" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">模型是某些软件设计模式的组成部分。模型负责表示和管理应用程序中的数据。在Sequelize中，每个模型都是一个JavaScript类，代表数据库中的一个表。每当定义一个模型时，像Sequelize这样的ORM都会自动创建一个数据库表。</p><h2 id="e0a8" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">定义模型</h2><p id="d143" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了在Sequelize中定义一个模型，我们首先创建一个扩展Sequelize的<code class="fe ni nj nk nl b">Model </code>类的类，然后我们在那个类上调用<code class="fe ni nj nk nl b">init</code>方法，传入我们的模型属性和其他选项:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d7d4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">或者，可以通过调用<code class="fe ni nj nk nl b">sequelize.define(modelName, attributes, options)</code>来定义模型。</p><h2 id="5b50" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">模型属性</h2><p id="c26e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">将属性添加到模型中会在数据库表中创建相应的列。在上面的例子中，<code class="fe ni nj nk nl b">name</code>、<code class="fe ni nj nk nl b">age</code>和<code class="fe ni nj nk nl b">favoriteColor</code>被定义为用户模型属性，因此也是我们的users表中的列名。</p><h2 id="a81d" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">模型数据类型</h2><p id="8489" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">模型的每个属性都必须有一个数据类型。将<code class="fe ni nj nk nl b">DataTypes </code>导入到一个JavaScript文件中，可以访问Sequelize的内置数据类型，包括<code class="fe ni nj nk nl b">String</code>、<code class="fe ni nj nk nl b">Text</code>、<code class="fe ni nj nk nl b">Boolean</code>、<code class="fe ni nj nk nl b">Integer</code>、<code class="fe ni nj nk nl b">Decimal</code>、<code class="fe ni nj nk nl b">Float</code>、<code class="fe ni nj nk nl b">Date.</code></p><h2 id="9312" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">默认值</h2><p id="6d2e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在属性上设置<code class="fe ni nj nk nl b">defaultValue</code>选项可确保在创建模型实例时，如果没有输入其他值，该属性会自动被赋予默认值。</p><h2 id="c993" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">自动表格命名</h2><p id="725f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当我们在上面的例子中定义一个<code class="fe ni nj nk nl b">User</code>模型时，一个名为‘Users’的表被自动添加到数据库中。</p><p id="6c04" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">尽管我们的代码从来没有明确地给我们的表命名，但是在幕后，Sequelize创建了一个表名，它是模型名的复数。</p><h2 id="d4a8" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">自动创建“id”(主键)</h2><p id="1e6f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用Sequelize，我们在定义模型时不需要指定一个<code class="fe ni nj nk nl b">id</code>(主键)属性——sequel ize自动在我们的表中包含一个<code class="fe ni nj nk nl b">id </code>列。</p><h2 id="5b59" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">自动创建“创建日期”和“更新日期”</h2><p id="9570" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当我们定义一个模型时，Sequelize自动包含并管理我们的表中的两个类型为<code class="fe ni nj nk nl b">DATE</code>的列— <code class="fe ni nj nk nl b">createdAt </code>和<code class="fe ni nj nk nl b">updatedAt</code>。</p><h2 id="83b7" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">确认</h2><p id="1e20" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Sequelize提供了预定义的验证器，可以在定义模型属性时进行设置。我们也可以编写定制的验证器。验证器在执行SQL操作之前检查输入的数据。如果数据没有通过验证测试，就不会执行SQL操作。</p><p id="0159" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">例如，如果在定义一个模型时，在一个列上设置了<code class="fe ni nj nk nl b">allowNull: false</code>验证器，那么在创建一个实例时，该列不能为空。</p><p id="bbbf" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">另一个常见的验证是<code class="fe ni nj nk nl b">unique: true</code>。例如，如果在username列上设置了该选项，尝试插入现有用户名将会引发错误。</p><h1 id="ce87" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">模型实例</h1><p id="c5aa" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一旦我们定义了一个模型，我们就可以基于这个模型创建实例。请记住，模型是一个JavaScript类，模型实例是该类的实例(对象)。这些实例映射到数据库表中的行(记录)。</p><p id="f0eb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">当回顾下面Sequelize的实例方法时，您会注意到它们中的许多是异步的。这些方法返回一个<code class="fe ni nj nk nl b">Promise</code>对象，而像<code class="fe ni nj nk nl b">then </code>和<code class="fe ni nj nk nl b">catch</code>这样的承诺方法可以被链接到异步方法的末尾来处理它的返回值。</p><h2 id="7de1" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">创建模型实例(并将它们插入数据库)</h2><p id="d93f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们可以使用<code class="fe ni nj nk nl b">build</code>方法创建一个已定义模型的实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b5c5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">尽管<code class="fe ni nj nk nl b">build</code>方法创建了一个模型实例，但它并没有在数据库表中创建记录。在<code class="fe ni nj nk nl b">build </code>方法之后必须调用<code class="fe ni nj nk nl b">save</code>方法来将实例保存到数据库中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="de7a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然而，确实存在一个捷径——<code class="fe ni nj nk nl b">create</code>方法在一个方法中完成了<code class="fe ni nj nk nl b">build </code>和<code class="fe ni nj nk nl b">save</code>的工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="c7f5" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">更新实例和数据库记录</h2><p id="01f2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Sequelize实例的更新方式与JavaScript中对象的更新方式相同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a245" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">name属性更改为' Ada '后必须调用<code class="fe ni nj nk nl b">save</code>方法来保存对数据库的更改。</p><p id="7920" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">像<code class="fe ni nj nk nl b">create</code>一样，<code class="fe ni nj nk nl b">update </code>方法是同时更新记录并将更改保存到数据库的快捷方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="8696" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">删除实例和数据库记录</h2><p id="9032" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe ni nj nk nl b">destroy</code>方法删除一个实例并将其从数据库中移除:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="497d" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">查询模型</h1><p id="dd06" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Sequelize提供了许多finder方法，每个方法都会生成一个SQL <code class="fe ni nj nk nl b">SELECT</code>查询。例如，使用<code class="fe ni nj nk nl b">findAll</code>方法在SQL中生成一个<code class="fe ni nj nk nl b">SELECT * FROM ...</code>类型的查询:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bde9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe ni nj nk nl b">findByPk</code>是另一种查找方法。它根据作为参数传入的<code class="fe ni nj nk nl b">id</code>(主键)返回单个表记录:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6ee0" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">每个finder方法返回一个<code class="fe ni nj nk nl b">Promise</code>,包含调用该方法的模型的实例。换句话说，您不只是接收查询的数据库结果——sequel ize将数据库查询的每个结果包装在一个实例对象中。每个返回的实例都有几个方便的方法可用。</p><p id="0dbc" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">像<code class="fe ni nj nk nl b">findByPk</code>这样的查找器方法返回单个模型实例，而<code class="fe ni nj nk nl b">findAll</code>返回模型实例的数组。</p><h2 id="8cd8" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">使用“where”过滤查询</h2><p id="61c4" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Sequelize的查询方法可以使用<code class="fe ni nj nk nl b">where</code>选项进行过滤。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d350" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">注意，在我们的示例代码中没有必要包含一个等式操作符——如果没有提供操作符，Sequelize会假设等式成立。</p><p id="1a59" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是当我们需要用<code class="fe ni nj nk nl b">where</code>选项包含一个操作符时，我们可以简单地使用JavaScript内置操作符吗？不。我们需要使用Sequelize定义的运算符。Sequelize的<code class="fe ni nj nk nl b">Op</code>(必须导入到您的文件中)提供了许多操作符，相当于SQL的<code class="fe ni nj nk nl b">WHERE</code>相关操作符。以下是几个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="677a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">下面是一个使用了<code class="fe ni nj nk nl b">where</code>选项以及Sequelize的<code class="fe ni nj nk nl b">Op.and</code>操作符的查询示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="8996" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">联合</h1><p id="d244" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">关系数据库很有价值，因为它们可以在表之间创建关联(关系)。可以创建的关联类型包括一对多、一对一和多对多。</p><p id="8709" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Sequelize提供的函数在组合使用时，可以复制两个模型之间的标准数据库关联。</p><p id="f09a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">四个关联功能如下:</p><ul class=""><li id="bbef" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated"><code class="fe ni nj nk nl b">hasOne</code>协会</li><li id="9091" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><code class="fe ni nj nk nl b">belongsTo </code>协会</li><li id="d188" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><code class="fe ni nj nk nl b">hasMany </code>协会</li><li id="b8fe" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><code class="fe ni nj nk nl b">belongsToMany </code>协会</li></ul><h2 id="5263" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">一对一</h2><p id="fb02" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe ni nj nk nl b">hasOne </code>和<code class="fe ni nj nk nl b">belongsTo </code>函数可以结合使用，在两个表之间创建一对一的关系。如果没有传递外键选项，Sequelize会自动为调用<code class="fe ni nj nk nl b">belongsTo</code>的模型分配一个外键。在这个例子中，概要文件模型获得了一个外键<code class="fe ni nj nk nl b">UserId:</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="fdbf" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">一对多</h2><p id="836c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe ni nj nk nl b">hasMany </code>和<code class="fe ni nj nk nl b">belongsTo</code>函数可以结合使用，在两个表之间创建一对多的关系。同样，调用<code class="fe ni nj nk nl b">belongsTo</code>的模型获得外键——在本例中，Comment模型获得外键<code class="fe ni nj nk nl b">UserId</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="39fd" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">多对多</h2><p id="48fc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于多对多关系，Sequelize使用了<code class="fe ni nj nk nl b">Junction Model</code>的概念，也称为连接表。在这个场景中，Sequelize创建了第三个新模型(因此也是数据库中的第三个表),它包含两个外键列，每个外键列对应一个连接的表。</p><p id="f69f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">电影和演员模型提供了一个多对多关系的很好的例子，因为一个演员可以有许多电影，而一部电影可以有许多演员。在这个例子中，我们使用<code class="fe ni nj nk nl b">belongsToMany </code>函数来创建一个连接模型，它跟踪两个模型之间的关联。我们为我们的连接模型传递了一个名称(‘actor movies’)。该模型将包含外键“movieId”和“actorId”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="e26b" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">涉及关联的查询</h1><p id="143d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果我们正在处理一个模型，并且想要从与主模型相关联的第二个模型中获取数据，该怎么办呢？或者，如果我们想一次从两个关联的模型中获取数据呢？在Sequelize中，我们可以通过使用两种技术中的一种来实现这些目标:惰性加载和急切加载。</p><p id="dc7b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了演示这两种技术，我们将创建一个涉及两个模型之间一对多关系的例子:<code class="fe ni nj nk nl b">User</code>和<code class="fe ni nj nk nl b">Comment</code>(一个用户有许多评论):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="612e" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">惰性装载</h2><p id="c93d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">延迟加载包括首先获取用户数据，然后在我们需要的时候获取评论数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a03a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">以下是console.log()的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cf87" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe ni nj nk nl b">comments</code>变量包含一个对象数组，每个对象代表一个属于id为1的用户的评论。</p><p id="7948" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe ni nj nk nl b">getComments()</code>方法是由Sequelize创建的，允许您获取与您正在处理的模型相关的数据。该方法的名称是从关联模型的名称中生成的。因为我们的关联模型被命名为“Comment”，所以我们的方法被自动命名为“getComments()”。</p><h2 id="220a" class="nm ks iq bd kt nn no dn kx np nq dp lb ls nr ns ld lw nt nu lf ma nv nw lh nx bi translated">急切装载</h2><p id="92b8" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">急切加载包括从多个相互关联的表中获取数据。</p><p id="0c15" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果我们想用SQL来做这件事，我们必须用一个或多个<code class="fe ni nj nk nl b">JOIN</code>子句来构造一个查询。</p><p id="391c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在Sequelize中，我们可以使用一个finder方法，如<code class="fe ni nj nk nl b">findAll</code>或<code class="fe ni nj nk nl b">findByPk</code>，并将<code class="fe ni nj nk nl b">include</code>选项整合到该方法中，以从两个模型中获取数据。</p><p id="3e5d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">当我们这样做时，Sequelize返回的对象的字段包含来自两个关联模型的数据。</p><p id="e930" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于我们的示例，我们将获取所有评论以及每个评论的相关用户:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f8a4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">下面的console.log()输出显示Sequelize返回了一个对象，该对象包含注释字段<code class="fe ni nj nk nl b">body</code>、<code class="fe ni nj nk nl b">id </code>和<code class="fe ni nj nk nl b">userId</code>以及一个名为<code class="fe ni nj nk nl b">user</code>的附加字段，该字段包含用户实例及其所有属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="cee8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">资源</h1><ul class=""><li id="17c6" class="ml mm iq ll b lm ln lp lq ls ny lw nz ma oa me mq mr ms mt bi translated"><a class="ae mf" href="https://sequelize.org/docs/v6/" rel="noopener ugc nofollow" target="_blank">对文件进行排序</a></li><li id="fa1b" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><a class="ae mf" href="https://sequelize.org/api/v6/identifiers.html" rel="noopener ugc nofollow" target="_blank">顺序化API </a></li><li id="88d1" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><a class="ae mf" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a></li></ul><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="1275" class="nm ks iq nl b gy of og l oh oi">Check out my GitHub page!</span><span id="df3c" class="nm ks iq nl b gy oj og l oh oi"><a class="ae mf" href="https://github.com/todd-demone" rel="noopener ugc nofollow" target="_blank">https://github.com/todd-demone</a></span></pre></div></div>    
</body>
</html>