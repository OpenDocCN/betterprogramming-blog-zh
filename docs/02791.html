<html>
<head>
<title>Dockerizing Rails Applications Part 3: CI/CD Integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dockerizing Rails应用程序第3部分:CI/CD集成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerizing-rails-applications-part-3-ci-cd-integration-9f2dcd84780f?source=collection_archive---------2-----------------------#2020-01-01">https://betterprogramming.pub/dockerizing-rails-applications-part-3-ci-cd-integration-9f2dcd84780f?source=collection_archive---------2-----------------------#2020-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d30e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们使用CI/CD工具来自动创建Docker映像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/baeb805cd4f5a8c57a6a713c8c4bd278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hebGmaAPWRj9JFsA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class="kz la gp gr lb lc"><a href="https://medium.com/faun/dockerizing-rails-applications-part-1-writing-the-dockerfile-dc32aa25a0da" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">Dockerizing Rails应用程序第1部分:编写Dockerfile</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">让我们开始编写一个优化的Dockerfiles</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><div class="kz la gp gr lb lc"><a href="https://medium.com/faun/dockerizing-rails-applications-part-2-automation-3092975fa4bb" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">对接Rails应用第2部分:自动化</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">使用Makefiles简化Rails应用程序的docker构建</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="lr l ln lo lp ll lq ks lc"/></div></div></a></div><p id="77cd" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在本系列的第<a class="ae ky" href="https://medium.com/@wshihadeh/dockerizing-rails-applications-part-1-writing-the-dockerfile-dc32aa25a0da" rel="noopener"> 1 </a>和<a class="ae ky" href="https://medium.com/@wshihadeh/dockerizing-rails-applications-part-2-automation-3092975fa4bb" rel="noopener"> 2 </a>部分中，我解释了如何通过为应用程序编写Docker文件来对rails应用程序进行Docker化，并查看了构建Docker映像的一些最佳实践。此外，我还解释了如何实现或创建一个简单、一致且易于使用的界面来构建跨多个应用程序的Docker图像。</p><p id="f326" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在这篇文章中，我将介绍如何使用三种不同的CI/CD工具:<code class="fe mo mp mq mr b">jenkins</code>、<code class="fe mo mp mq mr b">travis</code>和<code class="fe mo mp mq mr b">Github Actions</code>来集成构建Docker映像和将映像推送到docker registry的过程。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="034a" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">詹金斯</h1><p id="f536" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">Jenkins是一个免费的开源自动化服务器，用于自动运行软件部署、编译源代码或执行单元测试等任务。使用<a class="ae ky" href="https://jenkins.io/doc/book/pipeline/" rel="noopener ugc nofollow" target="_blank"> Jenkins Pipelines </a>可以轻松定义自动化任务。我将使用这个特性来定义一个可用于构建Docker映像的管道。</p><p id="b511" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">除了Jenkins管道文件，我还将定义管道参数。这些将用于覆盖我们在之前的<a class="ae ky" href="https://medium.com/@wshihadeh/dockerizing-rails-applications-part-2-automation-3092975fa4bb" rel="noopener">文章</a>中编写的<code class="fe mo mp mq mr b">Makefile</code>中定义的配置项目。</p><p id="8e05" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">管道的下一部分是stages部分。这里我们定义了属于管道的阶段以及这些阶段的执行顺序。</p><p id="bc61" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">对于Docker构建管道，我们需要以下四个阶段</p><ul class=""><li id="b526" class="nw nx it lu b lv lw ly lz mb ny mf nz mj oa mn ob oc od oe bi translated"><strong class="lu iu"> Checkout SCM </strong>:管道从<code class="fe mo mp mq mr b">git</code>中签出应用库，切换到选择的分支。</li><li id="da80" class="nw nx it lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated"><strong class="lu iu">安装先决条件</strong>:我们执行命令<code class="fe mo mp mq mr b">make config</code>来准备构建Docker映像的工作目录。</li><li id="1e8e" class="nw nx it lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated"><strong class="lu iu">构建映像</strong>:管道使用<code class="fe mo mp mq mr b">make build</code>为应用程序构建Docker映像。</li><li id="fffe" class="nw nx it lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated"><strong class="lu iu">推送图片</strong> : <code class="fe mo mp mq mr b">make push</code>将构建好的Docker图片推送至Docker注册表。</li></ul><p id="20f8" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><code class="fe mo mp mq mr b">post</code>段是管道的最后一段。在这里，我们运行可以在执行管道阶段后发生的操作。我们可以执行<code class="fe mo mp mq mr b">make clean</code>命令来删除所有生成的文件或docker图像。</p><p id="c0e5" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">以下是詹金斯流水线的完整实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹金斯文件</p></figure><p id="d0aa" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">上面的詹金斯管道需要手动触发。如果需要用Github推送来触发这个管道，你可以按照这个<a class="ae ky" href="https://medium.com/@wshihadeh/how-too-add-github-webhook-to-a-jenkins-pipeline-62b0be84e006" rel="noopener">帖子</a>中的步骤来做。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="0162" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated"><strong class="ak">特拉维斯·CI</strong></h1><p id="5ebd" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">Travis CI是一个托管的持续集成服务，用于为GitHub中托管的应用程序运行持续集成作业。这项服务对开源项目是免费的。让我们看一下，每当有新的提交被推送到主分支或创建了拉取请求时，我们如何让Travis CI构建Docker映像。</p><p id="efd4" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">只需在GitHub项目中启用<code class="fe mo mp mq mr b">travis ci</code>，并在项目存储库的根目录中引入一个Travis文件，就可以实现Travis CI集成。Travis文件是一个YAML文件，包含所有需要执行的任务，以及集成的配置，比如任务何时被触发。Travis界面的完整描述可以在Travis网站<a class="ae ky" href="https://docs.travis-ci.com/user/customizing-the-build/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们的<code class="fe mo mp mq mr b">.travis.yml</code>文件包括以下配置部分:</p><ul class=""><li id="05b6" class="nw nx it lu b lv lw ly lz mb ny mf nz mj oa mn ob oc od oe bi translated">项目编程语言和版本。</li><li id="a2c6" class="nw nx it lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">Git分支到任务被启用的地方。我们将仅对<code class="fe mo mp mq mr b">master</code>分支进行限制。</li><li id="f7fc" class="nw nx it lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">需要在脚本之前执行的操作。对于这个任务，我们需要确保<code class="fe mo mp mq mr b">travis ci</code>工作者被允许将Docker图像推送到Docker注册中心。因此，我们需要在构建映像并将其推送到注册表之前执行<code class="fe mo mp mq mr b">docker login</code>命令。幸运的是，Travis提供了一种将安全变量存储为环境变量并将其传递给<code class="fe mo mp mq mr b">ci workers</code>的方法——不需要将密码或任何敏感数据以纯文本形式存储在<code class="fe mo mp mq mr b">.travis.yml</code>中。我们可以从项目的配置页面添加这些环境变量，如下所示:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/9c361d9629b65f7e0e517ef7fb551869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWYRl4LWn6g8w-FhBaqI8Q.png"/></div></div></figure><p id="0ec5" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在<code class="fe mo mp mq mr b">.travis.yml</code>中，我们可以引用这些环境变量，而没有暴露秘密配置的风险:</p><pre class="kj kk kl km gt on mr oo op aw oq bi"><span id="943a" class="or na it mr b gy os ot l ou ov">echo $DOCKER_TOKEN | docker login -u $DOCKER_NAMESPACE  --password-stdin</span></pre><p id="bae5" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><code class="fe mo mp mq mr b">travis.yml</code>的下一部分执行实际完成工作的命令。这里，我们将使用命令<code class="fe mo mp mq mr b">make release</code>来构建和发布Docker图像。</p><p id="dcbb" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">最后一部分是通知部分。这是一个可选的步骤，但很高兴有。这允许我们监控作业的状态——当它被触发时，我们会收到一个关于构建状态的Slack通知。</p><p id="a930" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">这里有一个完整的<code class="fe mo mp mq mr b">.travis.yml</code>实现，它将实现上面讨论的要点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="b067" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">可以使用以下命令生成松弛密钥值:</p><pre class="kj kk kl km gt on mr oo op aw oq bi"><span id="cd81" class="or na it mr b gy os ot l ou ov">travis encrypt "${slack_room_token}" --add notifications.slack</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="bc2b" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated"><strong class="ak"> Github动作</strong></h1><p id="e39c" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated"><a class="ae ky" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>是GitHub提供的一项服务，用于自动化CI/CD任务和工作。通过Github的动作，我们可以定义当Github事件被触发时要执行的CI/CD任务。支持事件的列表可在<a class="ae ky" href="https://developer.github.com/webhooks/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="5084" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">要将Docker图像发布任务集成为Github动作，我们需要为我们的工作编写一个工作流。这个工作流只是一个YAML文件，存储在GitHub存储库的根路径(<code class="fe mo mp mq mr b">.github/workflows</code>)中的以下路径下。工作流文件包含执行工作流所需的信息和需要执行的<a class="ae ky" href="https://github.com/marketplace" rel="noopener ugc nofollow" target="_blank">动作</a>列表。GitHub为可以在工作流上执行的操作提供了一个<a class="ae ky" href="https://github.com/marketplace" rel="noopener ugc nofollow" target="_blank">市场</a>。另一方面，您可以开发自己的操作并发布到市场上，这样其他人也可以使用它。</p><p id="b675" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">为了自动化和集成使用GitHub动作构建docker图像的过程，我将介绍两个工作流。</p><h2 id="9e0e" class="or na it bd nb ow ox dn nf oy oz dp nj mb pa pb nl mf pc pd nn mj pe pf np pg bi translated">工作流程一</h2><p id="8b53" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">一旦我们针对<code class="fe mo mp mq mr b">master</code>分支创建了一个拉请求，或者如果一个新的提交被推送到<code class="fe mo mp mq mr b">master</code>分支，第一个工作流就被执行。这个工作流将只执行<code class="fe mo mp mq mr b">make build</code>命令，以确保我们的图像Docker构建没有被破坏(这些动作是为了演示的目的，可以根据需要进行更改)。</p><p id="dc02" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">工作流首先定义何时需要触发操作，然后列出需要执行的步骤。最后一步是根据作业状态发送时差通知。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a249" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">注意，应该创建秘密<code class="fe mo mp mq mr b">SLACK_WEBHOOK_URL</code>并添加到各自的GitHub存储库中。你可以通过执行<a class="ae ky" href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets#creating-encrypted-secrets" rel="noopener ugc nofollow" target="_blank">这些步骤</a>来实现。</p><h2 id="d11d" class="or na it bd nb ow ox dn nf oy oz dp nj mb pa pb nl mf pc pd nn mj pe pf np pg bi translated">第二工作流程</h2><p id="a00b" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">只有在GitHub上发布新版本时，才会执行第二个工作流。它将负责为该版本构建docker映像，并将它们推送到Docker注册中心。</p><p id="334e" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">这个工作流与第一个工作流的第一个区别是触发事件。在第一种情况下，它在每次推送到<code class="fe mo mp mq mr b">master</code>或每次针对主分支机构的公关时被触发，但这个工作流只有在GitHub上发布新版本时才会被触发。如前所述，推送事件不是GitHub提供的唯一事件，事实上，工作流可以利用的事件有很长的<a class="ae ky" href="https://developer.github.com/webhooks/" rel="noopener ugc nofollow" target="_blank">列表</a>。</p><p id="bd2c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">第二个区别是，这个工作流将构建、标记Docker图像并将其推送到Docker注册中心。这意味着我们需要添加一个额外的步骤来验证Docker注册表，这样它就可以将图像推送到注册表中(可以像这里的<a class="ae ky" href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets#creating-encrypted-secrets" rel="noopener ugc nofollow" target="_blank">所描述的那样添加秘密</a>)。</p><p id="b5e2" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">Docker图像的标签也是从GitHub动作负载中提取的，并作为一个<code class="fe mo mp mq mr b">Environment</code>变量传递给<code class="fe mo mp mq mr b">make</code>命令，如下所示:<code class="fe mo mp mq mr b">IMAGE_TAG=${{ github.ref}} make release</code>。</p><p id="e558" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">下面是第二个工作流的完整实现。将这些工作流文件添加到GitHub工作流路径将会自动在各自的存储库上启用Github操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="2bd0" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated"><strong class="ak">结论</strong></h1><p id="5a71" class="pw-post-body-paragraph ls lt it lu b lv nr ju lx ly ns jx ma mb nt md me mf nu mh mi mj nv ml mm mn im bi translated">将构建Docker映像的过程归档和自动化相对简单。要为自动化流程完整构建CI/CD集成管道，请执行以下步骤:</p><ul class=""><li id="db74" class="nw nx it lu b lv lw ly lz mb ny mf nz mj oa mn ob oc od oe bi translated">写一个<code class="fe mo mp mq mr b">Dockerfile</code>将申请归档。</li><li id="d98e" class="nw nx it lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">使用<code class="fe mo mp mq mr b">Makefiles</code>提供简单的命令来构建docker映像。</li><li id="6bd4" class="nw nx it lu b lv of ly og mb oh mf oi mj oj mn ob oc od oe bi translated">使用一个或多个CI/CD工具(<code class="fe mo mp mq mr b">Jenkins</code>、<code class="fe mo mp mq mr b">Travis </code>和<code class="fe mo mp mq mr b">Github Actions</code>等)来自动化你的管道。</li></ul></div></div>    
</body>
</html>