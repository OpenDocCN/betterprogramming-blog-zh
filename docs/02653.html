<html>
<head>
<title>Introduction to Functional Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的函数式编程简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-functional-programming-in-python-3d26cd9cbfd7?source=collection_archive---------8-----------------------#2019-12-15">https://betterprogramming.pub/introduction-to-functional-programming-in-python-3d26cd9cbfd7?source=collection_archive---------8-----------------------#2019-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b317" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是时候卷起袖子开始了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/44c4b17f73d56b1a2a0803e0c0a1f126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBybCbEF-GVa-tc13wd8-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://twitter.com/ninalimpi" rel="noopener ugc nofollow" target="_blank"> Katerina Limpitsouni </a>创作</p></figure><p id="0d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，函数式编程的使用越来越多。因此，许多传统的命令式语言，如Java和Python T21，已经开始支持函数式编程技术。</p><p id="d27c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文介绍了Python中的这些函数式编程技术。本文假设您具备函数式编程的基础知识。如果你不熟悉函数式编程，可以看看FP 上的这篇文章<a class="ae ky" href="https://medium.com/@yannickdot/functional-programming-101-6bc132674ec5" rel="noopener">。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6637" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">一级功能</strong></h1><p id="8bd7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Python中，函数是一级的。这意味着它们可以被视为另一种数据类型，比如<code class="fe mz na nb nc b">int</code>。</p><p id="f358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以将它们赋给变量，将它们作为参数传递给其他函数，将它们存储在其他数据结构中，如<code class="fe mz na nb nc b">dicts</code>，并将它们用作其他函数的返回值。</p><h2 id="209c" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated"><em class="np">作为对象的功能</em></h2><p id="1ca5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于其他数据类型如<code class="fe mz na nb nc b">string</code>、<code class="fe mz na nb nc b">list</code>和<code class="fe mz na nb nc b">int</code>都是对象，所以函数在Python中也是对象。让我们考虑一个示例函数<code class="fe mz na nb nc b">foo</code>，它只是将自己的名字打印到控制台:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="1599" class="nd md it nc b gy nu nv l nw nx">def foo():<br/>   print("foo")</span></pre><p id="b96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于函数是对象，我们可以将函数<code class="fe mz na nb nc b">foo</code>赋给任何变量，然后调用该变量来引用函数。例如，我们可以将它赋给变量<code class="fe mz na nb nc b">bar</code>，如下所示:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="18f0" class="nd md it nc b gy nu nv l nw nx">bar = foo<br/>bar()<br/>#will print "foo" to the console</span></pre><p id="e483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语句<code class="fe mz na nb nc b">bar = foo</code>将<code class="fe mz na nb nc b">foo</code>(我们函数的名字)引用的对象分配给变量<code class="fe mz na nb nc b">bar</code>。</p><h2 id="2e43" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated"><em class="np">作为功能的对象</em></h2><p id="3117" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们使<em class="ny">可调用，</em>如<code class="fe mz na nb nc b">object()</code> <em class="ny">时，对象可以表现为函数。</em>这是使用<code class="fe mz na nb nc b">__call__</code>方法完成的。</p><p id="c922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="633a" class="nd md it nc b gy nu nv l nw nx">class Greeter:<br/>   def __init__(self, greeting):<br/>      self.greeting = greeting<br/>   def __call__(self, name):<br/>      return self.greeting + " " + name</span></pre><p id="0da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们初始化一个<code class="fe mz na nb nc b">Greeter</code>类的对象时，我们就创建一个新的对象，可以用一个新的<code class="fe mz na nb nc b">name</code>来调用它。例如:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="307f" class="nd md it nc b gy nu nv l nw nx">morning = Greeter("good morning") #creates the callable object<br/>morning("john") # calling the object<br/>#prints "good morning john" to the console</span></pre><p id="0193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以调用<code class="fe mz na nb nc b">morning</code>对象的原因是我们在类定义中有<code class="fe mz na nb nc b">__call__</code>方法。为了检查一个对象是否可调用，我们使用内置函数<code class="fe mz na nb nc b">callable</code>:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="aead" class="nd md it nc b gy nu nv l nw nx">callable(morning) #true<br/>callable(145) #false. int is not callable. </span></pre><h2 id="d8fe" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated"><em class="np">数据结构内部的函数</em></h2><p id="a929" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">像其他对象一样，函数可以存储在数据结构中。例如，我们可以创建一个<code class="fe mz na nb nc b">int</code>到<code class="fe mz na nb nc b">func</code>的字典。当<code class="fe mz na nb nc b">int</code>是要执行的程序的简写时，这很有用。</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="06dd" class="nd md it nc b gy nu nv l nw nx"># store in dictionary<br/>mapping = {<br/>   0 : foo,<br/>   1 : bar<br/>}</span><span id="dd69" class="nd md it nc b gy nz nv l nw nx">x = input() #get integer value from user<br/>mapping[x]() #call the func returned by dictionary access</span></pre><p id="5703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，函数可以存储在许多其他数据结构中。</p><h2 id="8726" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated"><em class="np">用作自变量和返回值</em></h2><p id="9173" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数也可以作为其他函数的参数和返回值。接受或返回函数的函数称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank"> <em class="ny">高阶函数</em> </a> <em class="ny"> </em>，是函数式编程的重要组成部分。</p><p id="d631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶函数非常强大。正如雄辩的JavaScript 上的精彩解释<a class="ae ky" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">:</a></p><blockquote class="oa"><p id="b632" class="ob oc it bd od oe of og oh oi oj lu dk translated">"高阶函数允许我们抽象出<em class="np">动作</em>，不仅仅是值."</p></blockquote><p id="e93f" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">考虑一个例子。</p><p id="8a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要遍历一个条目列表并按顺序打印它们。我们可以很容易地构建一个<code class="fe mz na nb nc b">iterate</code>函数:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="1d1e" class="nd md it nc b gy nu nv l nw nx">def iterate(list_of_items):<br/>    for item in list_of_items:<br/>        print(item)</span></pre><p id="ffe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来很酷，但这只是抽象的一个层次。如果我们想在遍历列表时做一些不同的事情(而不是打印)呢？</p><p id="ea85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是高阶函数的用武之地。我们可以创建一个函数<code class="fe mz na nb nc b">iterate_custom</code>,它接受一个要迭代的列表和一个要应用于每一项的函数:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="eac6" class="nd md it nc b gy nu nv l nw nx">def iterate_custom(list_of_items, custom_func):<br/>   for item in list_of_items:<br/>        custom_func(item)</span></pre><p id="601b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这看起来微不足道，但它非常强大。</p><p id="a11a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经提升了一个抽象层，使我们的代码更加可重用。现在，我们不仅可以在想要打印列表时调用该函数，还可以对列表做任何涉及顺序迭代的事情。</p><p id="6d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数也可以被返回以使事情更简单。就像我们如何在<code class="fe mz na nb nc b">dict</code>中存储函数一样，我们也可以使用一个函数作为控制流来决定合适的函数。例如:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="199a" class="nd md it nc b gy nu nv l nw nx">def add(x, y):<br/>    return x + y</span><span id="39ab" class="nd md it nc b gy nz nv l nw nx">def sub(x, y):<br/>    return x - y</span><span id="7a32" class="nd md it nc b gy nz nv l nw nx">def mult(x, y):<br/>    return x * y</span><span id="41bb" class="nd md it nc b gy nz nv l nw nx">def calculator(opcode):<br/>    if opcode == 1:<br/>       return add<br/>    elif opcode == 2:<br/>       return sub<br/>    else:<br/>       return mult </span><span id="873e" class="nd md it nc b gy nz nv l nw nx">my_calc = calculator(2) #my calc is a subtractor<br/>my_calc(5, 4) #returns 5 - 4 = 1 </span><span id="728a" class="nd md it nc b gy nz nv l nw nx">my_calc = calculator(9) #my calc is now a multiplier<br/>my_calc(5, 4) #returns 5 x 4 = 20. </span></pre><h2 id="fe6e" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated"><em class="np">嵌套函数</em></h2><p id="328a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">也可以在其他函数内部定义函数，这些函数被恰当地称为<em class="ny">内部函数。这些对于制作<em class="ny">辅助函数</em>特别有用——小的、可重用的函数，支持主函数作为子模块。</em></p><p id="5377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个问题需要一个特定的函数定义(参数类型或顺序)时，Helper函数是很方便的，但是不遵循约定更容易解决问题。一个很好的例子来自本讲座幻灯片。</p><p id="8a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你想定义一个斐波纳契函数，<code class="fe mz na nb nc b">fib(n)</code>，它有一个参数，<code class="fe mz na nb nc b">n</code>，我们必须返回<code class="fe mz na nb nc b">nth</code>斐波纳契数。</p><p id="bd83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义这种函数的一种可能方式是使用跟踪斐波纳契数列的前两项的辅助函数(因为斐波纳契数只是前两个斐波纳契数的和)。</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="b6be" class="nd md it nc b gy nu nv l nw nx">def fib(n):<br/>    def fib_helper(fk1, fk, k):<br/>        if n == k:<br/>           return fk<br/>        else:<br/>           return fib_helper(fk, fk1+fk, k+1)</span><span id="be90" class="nd md it nc b gy nz nv l nw nx">    if n &lt;= 1:<br/>       return n<br/>    else:<br/>       return fib_helper(0, 1, 1)</span></pre><p id="be89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将计算从函数体转移到函数参数是非常强大的，因为它减少了递归方法中可能出现的冗余计算。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2125" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">单一表达式函数(λ表达式)</strong></h1><p id="45c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们想写一个没有名字的函数呢？如果我们想写一个简短的单行函数(就像上面例子中的函数<code class="fe mz na nb nc b">foo</code>或<code class="fe mz na nb nc b">mult</code>)该怎么办？</p><p id="45c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用Python中的<code class="fe mz na nb nc b">lambda</code>关键字来声明这样的函数。例如:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="ae51" class="nd md it nc b gy nu nv l nw nx">mult = lambda x, y: x * y<br/>mult(1, 2) #returns 2</span></pre><p id="d62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe mz na nb nc b">mult</code>的行为与前面使用传统的<code class="fe mz na nb nc b">def</code>关键字定义的行为完全相同。</p><p id="9dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，lambda函数必须是一行程序，并且不能包含程序员编写的返回语句。</p><p id="435f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，它们总是有一个隐式的返回语句(在上面的例子中，它会说<code class="fe mz na nb nc b">return x * y</code>，但是我们省略了lambda函数的显式返回语句)。</p><p id="f9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda函数更加强大和简洁，因为我们还可以构造匿名函数——没有名字的函数:</p><p id="ac44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">(lambda x, y: x * y)(9, 10) #returns 90</code></p><p id="a2ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个方便的方法，只要我们只需要一次函数，以后就不用了。例如，在填写字典时:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="c7e3" class="nd md it nc b gy nu nv l nw nx">import collections<br/>pre_fill = collections.defaultdict(lambda: (0, 0))<br/>#all dictionary keys and values are set to 0</span></pre><p id="a528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以看看地图，过滤，并减少欣赏λ更多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f2cd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">贴图、过滤、缩小</strong></h1><h2 id="0eff" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">地图</h2><p id="e5b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">map</code>是一个函数，根据指定的过程(函数)将一组输入转换成另一组输入。这类似于前面讨论的<code class="fe mz na nb nc b">iterate_custom</code>函数。例如:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="1b35" class="nd md it nc b gy nu nv l nw nx">def multiply_by_four(x):<br/>    return x * 4</span><span id="faa9" class="nd md it nc b gy nz nv l nw nx">scores = [3, 6, 8, 3, 5, 7]<br/>modified_scores = list(map(multiply_by_four, scores))<br/>#modified scores is now [12, 24, 32, 12, 20, 28]</span></pre><p id="460e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 3中，<code class="fe mz na nb nc b">map</code>函数返回一个<code class="fe mz na nb nc b">map</code>对象，可以将其类型转换为<code class="fe mz na nb nc b">list</code>供我们使用。现在，我们可以定义一个<code class="fe mz na nb nc b">lambda</code>表达式，而不是显式定义<code class="fe mz na nb nc b">multiply_by_four</code>函数:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="73f7" class="nd md it nc b gy nu nv l nw nx">modified_scores = list(map(lambda x: 4 * x, scores))</span></pre><p id="ec21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想对集合中的所有值做一些事情时,<code class="fe mz na nb nc b">map</code>函数很有用。</p><h2 id="7096" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">过滤器</h2><p id="327e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">filter</code>顾名思义，就是帮助“过滤”掉不需要的项目的功能。例如，我们可能希望从<code class="fe mz na nb nc b">scores</code>中过滤掉所有奇数。我们可以使用<code class="fe mz na nb nc b">filter</code>来实现:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="74ce" class="nd md it nc b gy nu nv l nw nx">even_scores = list(filter(lambda x: True if (x % 2 == 0) else False, scores))<br/>#even_scores = [6, 8]</span></pre><p id="ff9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于提供给<code class="fe mz na nb nc b">filter</code>的函数根据具体情况决定是否接受某个项目，因此该函数必须返回一个<code class="fe mz na nb nc b">bool</code>值(如上面的lambda函数所示)，并且必须是一元的(接受一个输入参数)。</p><h2 id="6469" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">减少</h2><p id="3f14" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">reduce</code>是对一组数据进行“汇总”或“概括”的功能。例如，如果我们想计算所有分数的总和，我们可以使用<code class="fe mz na nb nc b">reduce</code>:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="5e15" class="nd md it nc b gy nu nv l nw nx">sum_scores = reduce((lambda x, y: x + y), scores)<br/>#sum_scores = 32</span></pre><p id="6dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比写循环简单多了。注意，提供给<code class="fe mz na nb nc b">reduce</code>的函数需要两个参数:一个代表当前被检查的项目，一个是应用操作的累积结果。</p><p id="de13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，以上只是让您开始使用Python进行函数式编程，尽管是彻底地开始。还有更多信息需要了解，您可以使用以下资源:</p><div class="op oq gp gr or os"><a href="https://kite.com/blog/python/functional-programming/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">在Python - Kite博客中使用函数式编程的最佳实践</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">函数式编程(FP)是一种编码范例，其中的构建块是不可变的值和“纯……</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">kite.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://www.hackerearth.com/practice/python/functional-programming/functional-programming-1/tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">函数式编程教程和笔记| Python | HackerEarth</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">函数式编程是一种编码风格，专注于定义做什么，而不是执行一些动作…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">www.hackerearth.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>