<html>
<head>
<title>Design Patterns: The Decorator Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:装饰者模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decorator-pattern-4f92897e4b4?source=collection_archive---------4-----------------------#2019-05-07">https://betterprogramming.pub/decorator-pattern-4f92897e4b4?source=collection_archive---------4-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3a17" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用装饰模式使您的代码更加整洁和模块化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35d47e8ebd6873717be29cab3ddd2655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_v3nF-R9DSqvde9baEfXYQ.jpeg"/></div></div></figure><h1 id="85d1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">先决条件:</h1><ol class=""><li id="9cb4" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">如果你不是不熟悉“设计模式”这个术语，请务必查看我的<a class="ae me" href="https://medium.com/@Nitin_code/design-patterns-introduction-30b9f3c5f7e" rel="noopener"> <em class="mf">设计模式介绍。</em> </a></li><li id="4d38" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ma mb mc md bi translated">你懂Java或者其他任何面向对象的语言。</li><li id="5429" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ma mb mc md bi translated">你对<a class="ae me" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">继承</a>、<a class="ae me" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态</a>和<a class="ae me" href="https://en.wikipedia.org/wiki/Interface_(computing)" rel="noopener ugc nofollow" target="_blank">接口</a>有了一个基本的概念。</li></ol></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="8ffa" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">要查看完整代码，请查看我的GitHub资源库:</p><div class="nh ni gp gr nj nk"><a href="https://github.com/Ni3verma/Coffe-Shop" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">ni 3 Verma/咖啡店</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Github仓库，我的中等职位，解释装饰模式</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="1906" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">假设你有一家咖啡店，它是周围发展最快的商店。只要看街对面，你就会看到它是另一个分支。你提供四种类型的饮料:自制混合饮料、黑咖啡、无咖啡因咖啡和浓缩咖啡。</p><p id="98ff" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">当你第一次创业时，你这样设计你的类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/d50629b772cbc5c67c846dc2c0cb61bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVCZCIQA7VvFahD8sr5Qpw.png"/></div></div></figure><p id="0b1e" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated"><code class="fe oa ob oc od b">Beverage</code>是抽象类，<code class="fe oa ob oc od b">cost</code>方法也是抽象的。子类将实现它。<code class="fe oa ob oc od b">Beverage</code>有四个子类:<code class="fe oa ob oc od b">HouseBlend</code>、<code class="fe oa ob oc od b">DarkRoast</code>、<code class="fe oa ob oc od b">Decaf</code>和<code class="fe oa ob oc od b">Espresso</code>。它们都覆盖了<code class="fe oa ob oc od b">cost </code>方法并返回自己的<code class="fe oa ob oc od b">cost</code>。这里，我们使用了<strong class="lo iu">继承</strong>。</p><p id="9b3f" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">除了咖啡，你还可以要一些调味品，如蒸牛奶、大豆、摩卡咖啡和鲜奶。您可以像以前一样实现它，并使用继承。这样我们将拥有大量的类:<code class="fe oa ob oc od b">HouseBlendMilk</code>、<code class="fe oa ob oc od b">HouseBlendMocha</code>、<code class="fe oa ob oc od b">HouseBlendSoy</code>、<code class="fe oa ob oc od b">HouseBlendWhip</code>、<code class="fe oa ob oc od b">HouseBlendMilkMocha</code>、<code class="fe oa ob oc od b">HouseBlendMilkSoy</code>等等。这样的例子不胜枚举。我们将有大约100门课要上。</p><p id="5203" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">这就是当我们过度继承时发生事情。很容易导致班级爆炸<strong class="lo iu">。显然有更好的方法来实现这一点。我们找一个吧。</strong></p><h1 id="6e72" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">方法1:</h1><p id="814a" class="pw-post-body-paragraph ms mt it lo b lp lq ju mv lr ls jx mx lt oe mz na lv of nc nd lx og nf ng lz im bi translated">要查看与方法1相关的代码，请单击下面的链接:</p><div class="nh ni gp gr nj nk"><a href="https://github.com/Ni3verma/Coffe-Shop/tree/d6b1e42d7dca41c04d03654566889cb93eb136e8" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">ni 3 Verma/咖啡店</h2><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="oh l nv nw nx nt ny ks nk"/></div></div></a></div><p id="cf36" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">或者，如果您已经克隆了存储库，请检查<code class="fe oa ob oc od b"><a class="ae me" href="https://github.com/Ni3verma/Coffe-Shop/commit/d6b1e42d7dca41c04d03654566889cb93eb136e8" rel="noopener ugc nofollow" target="_blank">simple approach</a></code> <a class="ae me" href="https://github.com/Ni3verma/Coffe-Shop/commit/d6b1e42d7dca41c04d03654566889cb93eb136e8" rel="noopener ugc nofollow" target="_blank">提交</a>。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="51d1" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">在这种方法中，我们将在<code class="fe oa ob oc od b">Beverage</code>类中添加一些布尔变量作为标志。如果是<code class="fe oa ob oc od b">true</code>，说明有调味品，所以加上它的成本。这次的<code class="fe oa ob oc od b">cost()</code>方法是<em class="mf">而不是</em>抽象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="d799" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">在我们像<code class="fe oa ob oc od b">DarkRoast</code>这样的具体<code class="fe oa ob oc od b">Beverage</code>类中，我们将覆盖<code class="fe oa ob oc od b">cost</code>方法，并在通过调用<code class="fe oa ob oc od b">super.cost()</code>计算调料成本后添加<code class="fe oa ob oc od b">cost</code>。</p><p id="d7fa" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">比如说黑咖啡，我们会多加20卢比。</p><pre class="kj kk kl km gt ok od ol om aw on bi"><span id="bc37" class="oo kv it od b gy op oq l or os">@Override    <br/>public int cost(){        <br/>  return super.cost() + 20;  <br/>}</span></pre><p id="414d" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">下面是我们制作牛奶咖啡的方法。它的输出将是家庭混合咖啡的成本+蒸牛奶(调味品)的成本。</p><pre class="kj kk kl km gt ok od ol om aw on bi"><span id="ce96" class="oo kv it od b gy op oq l or os">Beverage b = new HouseBlend();       <br/>b.setMilk(true);        <br/>System.out.println("total cost = "+b.cost());</span></pre><p id="5552" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">我们的代码将完美地工作，但是这个简单的方法有一些问题:</p><ul class=""><li id="08ce" class="lm ln it lo b lp mu lr mw lt ot lv ou lx ov lz ow mb mc md bi translated">如果调味品的价格发生变化，或者要添加新的调味品，我们将不得不修改现有的代码并制定新的方法。请注意，添加新的东西不应该改变现有的代码，因为它可能会导致错误。</li><li id="ddb1" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ow mb mc md bi translated">我们可能会有一些新的饮料，像冰茶。对于这一点，没有添加牛奶调味品的意义，但我们会从饮料类继承。</li><li id="d45b" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ow mb mc md bi translated">如果顾客想要双份摩卡咖啡怎么办？</li></ul><h2 id="086b" class="oo kv it bd kw ox oy dn la oz pa dp le lt pb pc lg lv pd pe li lx pf pg lk ph bi translated">方法2:</h2><p id="3ce4" class="pw-post-body-paragraph ms mt it lo b lp lq ju mv lr ls jx mx lt oe mz na lv of nc nd lx og nf ng lz im bi translated">要查看与之相关的代码，请检查<a class="ae me" href="https://github.com/Ni3verma/Coffe-Shop/commit/ff45635a276aff23fed6875d77c9c14792f6520e#diff-e7de9043f1a8c235dcce04e119ea062cR9" rel="noopener ugc nofollow" target="_blank">提交</a>。</p><p id="f492" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">在这种方法中，我们将使用装饰模式。在这个设计模式中，我们有一个<strong class="lo iu">组件</strong>(像<code class="fe oa ob oc od b">DarkRoast</code>)和<strong class="lo iu">装饰者</strong>(像<code class="fe oa ob oc od b">Whip</code>、<code class="fe oa ob oc od b">Mocha</code>等。).我们用装饰器包装这个组件。这就是我所说的包装:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/d420324370864b95b219b2c942f922c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*QmZgBIvY7l0k9431AIKTmg.png"/></div></figure><p id="f0b8" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">现在，当我们想要计算成本时，我们将调用最外层装饰器上的<code class="fe oa ob oc od b">cost</code>方法，然后它将调用其内部装饰器/组件的<code class="fe oa ob oc od b">cost</code>方法。这将继续下去，直到它到达它的组成部分(<code class="fe oa ob oc od b">DarkRoast</code>这里)。然后<code class="fe oa ob oc od b">DarkRoast</code>会将自己的成本返回给<code class="fe oa ob oc od b">Mocha</code> , <code class="fe oa ob oc od b">Mocha</code>会将自己的成本加到上面，并将总数返回给<code class="fe oa ob oc od b">Whip</code>。<code class="fe oa ob oc od b">Whip</code>会加上自己的成本，并返回合计出来。流程是这样的:</p><p id="839f" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated"><code class="fe oa ob oc od b">DarkRoast</code> = 20、<code class="fe oa ob oc od b">Mocha</code> = 50、<code class="fe oa ob oc od b">Whip</code> = 60的成本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/b02649032df2253d328a8b3634d5d75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*9YKA1ORd-waKHsJgYtZRqw.png"/></div><p class="pk pl gj gh gi pm pn bd b be z dk translated">总费用是130卢比</p></figure><p id="a333" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated"><strong class="lo iu">装饰模式</strong>动态地给一个对象附加额外的责任。它为子类化提供了一个灵活的选择来扩展一个功能。</p><p id="7983" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">既然我们已经对这种模式的工作原理有了一些想法，让我们看看我们将如何实现这种类型的行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/adb59046357519c8754e5ac19d655ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*14AiqaYqPHKj8SRtSekDqQ.png"/></div></figure><ol class=""><li id="6ab6" class="lm ln it lo b lp mu lr mw lt ot lv ou lx ov lz ma mb mc md bi translated"><strong class="lo iu">组件:</strong>是抽象类；具体组件和装饰抽象类都将继承它的行为。</li><li id="edee" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ma mb mc md bi translated"><strong class="lo iu">混凝土构件:</strong>延伸构件。这是我们将要动态添加新行为的对象。它可以单独使用，也可以由装饰者包装。(比如我们可以用<code class="fe oa ob oc od b">Mocha</code>点<code class="fe oa ob oc od b">DarkRoast</code>咖啡或者<code class="fe oa ob oc od b">DarkRoast</code>。)</li><li id="a27f" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ma mb mc md bi translated"><strong class="lo iu"> Decorator: </strong>它也扩展了component，是一个抽象类。</li><li id="6087" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ma mb mc md bi translated"><strong class="lo iu"> Concrete Decorator: </strong>每个Decorator都有一个组件，这意味着它有一个实例变量来保存对组件的引用(虚线表示这一点)。它扩展了Decorator抽象类，如<code class="fe oa ob oc od b">Milk</code>、<code class="fe oa ob oc od b">Soy</code>等。</li></ol><p id="63b2" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">现在让我们看看我们的抽象组件类，在我们的例子中是<code class="fe oa ob oc od b">Beverage.java</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9b41" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated"><code class="fe oa ob oc od b">cost</code>方法是抽象的，因为我们希望所有继承它的类(具体组件和装饰器)覆盖它并提供它们自己的<code class="fe oa ob oc od b">cost</code>。</p><p id="cf9d" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">现在让我们来看一个具体组件类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e858" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">每当我们定义一个具体的组件时，我们将在构造函数中给出它的描述，并覆盖<code class="fe oa ob oc od b">cost</code>方法并返回它的成本。</p><p id="f23b" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">现在是时候看看魔法发生的主类了。让我们看看抽象装饰类；在我们这里是<code class="fe oa ob oc od b">CondimentDecorator.java</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b625" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">注意它还扩展了<code class="fe oa ob oc od b">Beverage</code>。<code class="fe oa ob oc od b">getDescription</code>方法是抽象的，因为我们希望所有具体的装饰者覆盖它，并为它提供自己的实现。因为我们在这里没有实现<code class="fe oa ob oc od b">cost</code>方法，所以每个具体的装饰者也必须覆盖它。此外，我们有一个实例变量<code class="fe oa ob oc od b">beverage</code>，因为我们将在concrete decorator类中需要它。正因为如此，我们才能像这样形成对父方法<code class="fe oa ob oc od b">cost</code>的调用链:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/b02649032df2253d328a8b3634d5d75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*9YKA1ORd-waKHsJgYtZRqw.png"/></div></figure><p id="19d8" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">让我们来看看混凝土装饰师的一门课，<code class="fe oa ob oc od b">Mocha.java</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6efe" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">在<code class="fe oa ob oc od b">constructor</code>中，它将接收一个<code class="fe oa ob oc od b">Beverage</code>，并将其实例变量设置为该变量，然后覆盖这些方法。注意<code class="fe oa ob oc od b">beverage</code>变量是从<code class="fe oa ob oc od b">CondimentDecorator</code>类继承的。</p><p id="9cc1" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">在点咖啡之前，记住装饰者(<code class="fe oa ob oc od b">Whip</code>、<code class="fe oa ob oc od b">Soy</code>)和组件(<code class="fe oa ob oc od b">DarkRoast</code>、<code class="fe oa ob oc od b">Decaf</code>)都扩展了组件(<code class="fe oa ob oc od b">Beverage</code>)类。所以我们可以说:</p><ol class=""><li id="1c1e" class="lm ln it lo b lp mu lr mw lt ot lv ou lx ov lz ma mb mc md bi translated"><code class="fe oa ob oc od b">DarkRoast</code>是一个<code class="fe oa ob oc od b">Beverage</code>。</li><li id="3b8b" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ma mb mc md bi translated"><code class="fe oa ob oc od b">DarkRoast</code>与<code class="fe oa ob oc od b">Mocha</code>同为<code class="fe oa ob oc od b">Beverage</code>。</li><li id="c573" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ma mb mc md bi translated"><code class="fe oa ob oc od b">DarkRoast</code>同<code class="fe oa ob oc od b">Mocha</code>，<code class="fe oa ob oc od b">Whip</code>也是<code class="fe oa ob oc od b">Beverage</code>。</li></ol><p id="8d1c" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">现在让我们点些咖啡吧！😃在您的main方法中，测试以下代码:</p><pre class="kj kk kl km gt ok od ol om aw on bi"><span id="db11" class="oo kv it od b gy op oq l or os">Beverage b1 = new Espresso();<br/>System.out.println(b1.getDescription() + " Rs." + b1.cost());</span><span id="f58a" class="oo kv it od b gy pp oq l or os">// ** OUTPUT **<br/>// Espresso Rs.30</span></pre><p id="c7f6" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">点一杯简单的咖啡，轻松简单；再加个调料吧。</p><pre class="kj kk kl km gt ok od ol om aw on bi"><span id="22c0" class="oo kv it od b gy op oq l or os">Beverage b2 = new DarkRoast();<br/>b2 = new Mocha(b2);<br/>System.out.println(b2.getDescription() + " Rs." + b2.cost());</span><span id="0d1d" class="oo kv it od b gy pp oq l or os">// ** OUTPUT **<br/>// Dark roast, Mocha Rs.70<br/>// Rs 70 = Rs 20(of DarkRoast) + Rs 50(of Mocha)</span></pre><p id="9de3" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated"><code class="fe oa ob oc od b"><em class="mf">b2 = new Mocha(b2)</em></code>。这就是我们所说的装饰一个物体。我们取了一个对象<code class="fe oa ob oc od b">DarkRoast</code>，并用<code class="fe oa ob oc od b">Mocha</code>类来装饰。还记得concrete decorator ( <code class="fe oa ob oc od b">Mocha</code>这里)类在它的<code class="fe oa ob oc od b">constructor</code>中收到了一个<code class="fe oa ob oc od b">beverage</code>？这里我们已经过了<code class="fe oa ob oc od b">b2</code>。所以你可以说在<code class="fe oa ob oc od b">Mocha</code>类中<code class="fe oa ob oc od b">beverage = b2</code>，而此时<code class="fe oa ob oc od b">b2</code>是<code class="fe oa ob oc od b">DarkRoast</code>类的一个对象。当我们计算成本时，<code class="fe oa ob oc od b">beverage.cost </code>会返回b2的成本(<code class="fe oa ob oc od b">DarkRoast</code> = Rs 20)，然后我们在里面加上50，所以结果是Rs 70。</p><p id="c8ac" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">现在让我们添加两种调味品，<code class="fe oa ob oc od b">Mocha</code>和<code class="fe oa ob oc od b">Whip</code>:</p><pre class="kj kk kl km gt ok od ol om aw on bi"><span id="d222" class="oo kv it od b gy op oq l or os">Beverage b2 = new DarkRoast();<br/>b2 = new Mocha(b2); // wrap it with mocha<br/>b2 = new Whip(b2); // wrap it with whip<br/>System.out.println(b2.getDescription() + " Rs." + b2.cost());</span><span id="e6ec" class="oo kv it od b gy pp oq l or os">// ** OUTPUT **<br/>// Dark roast, Mocha, Whip Rs.130<br/>// Rs 130 = Rs 20(of DarkRoast) + Rs 50(of Mocha) + Rs 60(of Whip)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/125ed2b8c4aa3cc80e0440b3d84328e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*HDzctcfBAAwjiObTDUJ9QA.png"/></div></figure><p id="5f30" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">我已经告诉你了，(<code class="fe oa ob oc od b">DarkRoast </code> + <code class="fe oa ob oc od b">Mocha</code>)也是饮料。这就是我们可以在<code class="fe oa ob oc od b">Whip</code>构造函数中传递<code class="fe oa ob oc od b">b2</code>对象的原因。同样，流程与之前类似。当我们调用<code class="fe oa ob oc od b"><em class="mf">b2.cost()</em></code> <em class="mf">，</em>首先它会计算<code class="fe oa ob oc od b">beverage.cost()</code>，对于<code class="fe oa ob oc od b">Whip</code>，饮料就是<code class="fe oa ob oc od b">DarkRoast </code> + <code class="fe oa ob oc od b">Mocha</code>。当我们在这个<code class="fe oa ob oc od b">DarkRoast </code> + <code class="fe oa ob oc od b">Mocha</code>上调用<code class="fe oa ob oc od b">beverage.cost()</code>时，它会调用它的<code class="fe oa ob oc od b">beverage.cost()</code>，对于(<code class="fe oa ob oc od b">DarkRoast </code> + <code class="fe oa ob oc od b">Mocha</code>)系统，饮料是<code class="fe oa ob oc od b">DarkRoast</code>。这里<code class="fe oa ob oc od b">beverage.cost()</code>会给我们20；我们给它加上50 ( <code class="fe oa ob oc od b">Mocha</code> cost)，返回70。这个70由<code class="fe oa ob oc od b">Whip</code>接收，它加60，返回130。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ok od ol om aw on bi"><span id="7e34" class="oo kv it od b gy op oq l or os">Beverage b2 = new DarkRoast();<br/>b2 = new Mocha(b2); // wrap it with mocha<br/>b2 = new Whip(b2); // wrap it with whip</span></pre><p id="a269" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">我知道上面的代码有点混乱。但是当你学习<em class="mf">工厂</em>和<em class="mf">构建器</em>模式时，你将学会以一种更好的方式装饰物体。你们中的一些人可能会说，你从来没有见过这样的代码。但是如果你曾经用Java写了一段代码，那么要接受用户输入，你可以使用<code class="fe oa ob oc od b">Scanner</code> <strong class="lo iu"> </strong>或者<code class="fe oa ob oc od b">InputStreamReader</code> <strong class="lo iu"> </strong>或者其他方法。让我们看看如何通过<code class="fe oa ob oc od b">InputStreamReader</code>读取用户输入:</p><pre class="kj kk kl km gt ok od ol om aw on bi"><span id="33b2" class="oo kv it od b gy op oq l or os">BufferedReader br = <br/>new BufferedReader(new InputStreamReader(System.in));<br/>String s = br.readLine();</span></pre><p id="e40f" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">这里我们将一个<code class="fe oa ob oc od b">InputStreamReader</code>包装在一个<code class="fe oa ob oc od b">BufferedReader</code>中，所以你从一开始就在使用装饰模式，甚至不知道它！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="5dc1" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">最后要注意的重要一点是，尽管<code class="fe oa ob oc od b">Decorator</code>是<code class="fe oa ob oc od b">Component</code>类的子类，我们不能在不传入具体组件的情况下直接创建具体装饰器的对象。例如，这里我们不能直接只订购<code class="fe oa ob oc od b">Mocha</code>，因为它需要一个<code class="fe oa ob oc od b">Beverage</code>来传入构造函数。<code class="fe oa ob oc od b">Mocha</code>是一个装饰器，所以它必须用来装饰<code class="fe oa ob oc od b">Beverage</code>。所以先做一个像<code class="fe oa ob oc od b">DarkRoast</code>、<code class="fe oa ob oc od b">Decaf</code>这样的混凝土构件的物件，或者其他一些咖啡，然后用装修工来装修。</p><p id="5f78" class="pw-post-body-paragraph ms mt it lo b lp mu ju mv lr mw jx mx lt my mz na lv nb nc nd lx ne nf ng lz im bi translated">非常感谢你这么久以来一直支持我。希望你了解了装饰者和组件。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="cc0b" class="ku kv it bd kw kx pr kz la lb ps ld le jz pt ka lg kc pu kd li kf pv kg lk ll bi translated">参考</h1><ul class=""><li id="cf84" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ow mb mc md bi translated"><a class="ae me" href="https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly/dp/0596007124" rel="noopener ugc nofollow" target="_blank">头先设计图案</a>(亚马逊)</li><li id="a9bb" class="lm ln it lo b lp mg lr mh lt mi lv mj lx mk lz ow mb mc md bi translated"><a class="ae me" href="https://github.com/Ni3verma/Coffe-Shop" rel="noopener ugc nofollow" target="_blank">我的GitHub回购了这篇文章</a></li></ul></div></div>    
</body>
</html>