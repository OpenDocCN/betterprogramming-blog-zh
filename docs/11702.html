<html>
<head>
<title>Writing Fast and Maintainable Code With Halide —The Pilot Episode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Halide编写快速且可维护的代码——试播集</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-fast-and-maintainable-code-with-halide-part-1-6a5c3a519250?source=collection_archive---------5-----------------------#2022-04-09">https://betterprogramming.pub/write-fast-and-maintainable-code-with-halide-part-1-6a5c3a519250?source=collection_archive---------5-----------------------#2022-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5dda" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写高性能代码通常以降低可移植性和简洁性为代价——Halide解决了这一问题，我们在谷歌经常使用它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/774999807dd251c8222ac8872401533d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vD5XTKBDoL8wzqBV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由马克-奥利维尔·乔多因在<a class="ae ky" href="https://unsplash.com/photos/NqOInJ-ttqM" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><h1 id="7e9d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="49d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu"> Halide </strong>是一种开源编程语言，旨在使<strong class="lt iu">在现代机器上编写和维护</strong>高性能图像处理或数组处理代码变得更加容易。卤化物目前的目标</p><ul class=""><li id="c47a" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">不同的CPU</li><li id="e840" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">不同的操作系统</li><li id="7bfe" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">不同计算API，如<code class="fe nd ne nf ng b">CUDA</code>、<code class="fe nd ne nf ng b">OpenCL</code>、<code class="fe nd ne nf ng b">OpenGL</code>等。</li></ul><p id="8246" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">Halide不是一种独立的编程语言，而是嵌入在C++中。这意味着您编写C++代码，使用Halide的C++ API构建Halide管道的内存表示。然后，您可以将这个表示编译成一个目标文件，或者JIT编译它并在同一个进程中运行它。你可以在halide-lang.org了解更多。</p><p id="7451" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">Halide在谷歌中使用非常频繁，例如在著名的HDR+算法中，该算法为旗舰Pixel设备上的相机应用程序提供动力。除此之外，Halide管道在Google Photos、Youtube和其他地方大规模运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/1e0c18218e35724ca7b60da61989777c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hxd-wGmYALyELSyb.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nl"> HDR图像(左)&amp;标准图像(右)。在低端Android设备上用谷歌相机拍摄。作者捕获的图像。</em></p></figure><p id="840f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我是来自谷歌的<a class="ae ky" href="https://developers.google.com/camera" rel="noopener ugc nofollow" target="_blank">相机中的TL，在谷歌，我们广泛使用Halide语言来实现我们的功能，如</a><a class="ae ky" href="https://developers.google.com/camera/features#hdr" rel="noopener ugc nofollow" target="_blank"> HDR </a>或<a class="ae ky" href="https://developers.google.com/camera/features#full-resolution-night-mode" rel="noopener ugc nofollow" target="_blank">夜间模式</a>。从标准C++或OpenCV迁移到Halide帮助我们显著提高了ARM芯片组上一些算法的性能，这些芯片组为大多数Android设备提供支持。</p><p id="fe34" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这对于在低端设备上实现这些功能并让所有人都能获得好的照片至关重要。</p><blockquote class="nm nn no"><p id="5b2b" class="lr ls np lt b lu mp ju lw lx mq jx lz nq nh mc md nr ni mg mh ns nj mk ml mm im bi translated">重要声明:本文中的任何观点都是我个人的观点，并不反映我所工作的组织的观点或立场。</p></blockquote><h1 id="f67f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">需求:我为什么要关心另一种编程语言呢？</h1><h2 id="81a6" class="nt la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">规模——让我们先来看看规模</h2><p id="0eff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">随着时间的推移，现代硬件变得非常强大。但是，我们正在处理的问题陈述的规模也是如此。</p><p id="ca8e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">让我们以计算摄影算法为例。如今，移动设备拥有相当大的图像传感器。某些Android设备现在配备了高达108百万像素的摄像头。即使在1300万像素这样的较小分辨率下，一幅图像也有<code class="fe nd ne nf ng b">~13,000,000</code>个像素。如果我们必须运行一个简单的增亮操作，比如</p><pre class="kj kk kl km gt of ng og oh aw oi bi"><span id="fcea" class="nt la it ng b gy oj ok l ol om">f(x) = a * x + b;</span></pre><p id="05fd" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们必须对<code class="fe nd ne nf ng b">~13 million</code>像素运行这个函数。</p><p id="01de" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">但是，对我们有利的是，我们处理的CPU既不是单核的，也不是标量的。因此，我们通常可以利用现代CPU中的多核和<a class="ae ky" href="https://minhazav.medium.com/guide-the-compiler-to-speed-up-your-code-655c1902b262" rel="noopener">对矢量指令的支持</a>，将这些算法的运行时延迟提高多个数量级。</p><h2 id="6483" class="nt la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">例如:3x3模糊</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/41d9f2ce92a8eeca5ce22471a0529aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*V7zacXU3D7bnGL7s.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nl">原图(左)和3x3盒核的盒模糊图(右)。由作者生成的比较。源图像由</em><a class="ae ky" href="https://www.pexels.com/@any-lane" rel="noopener ugc nofollow" target="_blank"><em class="nl"/></a><em class="nl">上的</em> <a class="ae ky" href="https://www.pexels.com/photo/crop-woman-showing-green-grapes-5946087/" rel="noopener ugc nofollow" target="_blank"> <em class="nl">像素</em> </a> <em class="nl">组成。</em></p></figure><p id="1faa" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">你可以用一个3x3的盒式滤镜来模糊图像。对于位置<code class="fe nd ne nf ng b">(x, y)</code>的每个像素，你用它的近邻中所有像素的平均值来替换它。</p><p id="d776" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">强力方法是对每个像素都这样做，因此得到的时间复杂度为<code class="fe nd ne nf ng b">O(K^2 * WH)</code>，因为<code class="fe nd ne nf ng b">K</code>是内核大小(= 3)，而<code class="fe nd ne nf ng b">W</code>和<code class="fe nd ne nf ng b">H</code>分别是图像的宽度和高度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单框模糊示例</p></figure><p id="d698" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">对此的一个改进是利用内核的可分离性。我们可以将单个<code class="fe nd ne nf ng b">3x3</code>内核分解成两个<code class="fe nd ne nf ng b">1x3</code>和<code class="fe nd ne nf ng b">3x1</code>内核。通过这种方式，我们将单个步骤分解为行和列的交互，从而将复杂度降低到<code class="fe nd ne nf ng b">O((K + K)WH)</code>。对于<code class="fe nd ne nf ng b">K=3</code>来说，光是这一点就应该被<code class="fe nd ne nf ng b">~50%</code>优化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3x3框模糊的标准实现</p></figure><p id="342e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">根据<a class="ae ky" href="https://dl.acm.org/doi/10.1145/3150211" rel="noopener ugc nofollow" target="_blank">【3】</a>，作者在<code class="fe nd ne nf ng b"><strong class="lt iu">Intel Core i7-4790</strong></code> <strong class="lt iu"> </strong> CPU上进行了基准测试，发现平均延迟约为<code class="fe nd ne nf ng b"><strong class="lt iu">6.5ms/MP</strong></code>。</p><p id="2354" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这可能适用于一般的用例。然而，</p><blockquote class="oq"><p id="6bed" class="or os it bd ot ou ov ow ox oy oz mm dk translated">为了实现卓越的性能并充分利用现代CPU，我们需要利用矢量化、多线程、切片和融合。</p></blockquote><p id="51cd" class="pw-post-body-paragraph lr ls it lt b lu pa ju lw lx pb jx lz ma pc mc md me pd mg mh mi pe mk ml mm im bi translated">这样做帮助作者在同一个<code class="fe nd ne nf ng b">x86</code> CPU上实现了<strong class="lt iu">快20倍的性能</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">面向x86处理器的3×3盒模糊快速实现</p></figure><p id="02c0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这种方法将平均延迟降低到<code class="fe nd ne nf ng b"><strong class="lt iu">0.30ms/MP</strong></code> <strong class="lt iu"> — </strong>，比<strong class="lt iu">快了20倍</strong>。</p><p id="0036" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这是非常显著的性能提升，但也带来了一些问题:</p><ul class=""><li id="0b9b" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated"><strong class="lt iu">可移植性</strong>:并非所有CPU类型都支持代码中使用的指令，因此，这些指令不能在不同的芯片组之间移植。为了在不同的CPU类型(例如32位架构)上实现最佳性能，我们需要编写另一个类似性质的实现。利用该CPU类型所支持的一组固有特性。</li><li id="9fa9" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><strong class="lt iu">简单性</strong>:这要求团队中的工程师拥有丰富的领域知识——在不同的实现中构建和维护这些算法。实际上，这样的领域知识通常很少。</li><li id="9319" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><strong class="lt iu">可维护性</strong>:如果团队需要更新算法，他们需要支付一些修改的费用，有时甚至是如何构建循环以实现最佳性能。这将比标准方法花费团队更多的工程时间。</li></ul><h2 id="608c" class="nt la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">回答“需要”</h2><p id="1469" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">所以需要有一种方法</p><blockquote class="oq"><p id="8b67" class="or os it bd ot ou ov ow ox oy oz mm dk translated">实现高性能，同时保持代码的可移植性、简单性和可维护性。</p></blockquote><h1 id="6b68" class="kz la it bd lb lc ld le lf lg lh li lj jz pf ka ll kc pg kd ln kf ph kg lp lq bi translated">Halide lang提供什么</h1><blockquote class="oq"><p id="7748" class="or os it bd ot ou ov ow ox oy oz mm dk translated"><strong class="ak">卤化物使我们能够编写更简单的高性能代码</strong></p></blockquote><p id="be16" class="pw-post-body-paragraph lr ls it lt b lu pa ju lw lx pb jx lz ma pc mc md me pd mg mh mi pe mk ml mm im bi translated">—通过将图像处理流水线的算法与如何在特定机器上高效运行该算法分离开来。作为程序员，我们仍然需要定义算法应该如何执行——但是定义这些策略更容易编写、测试和维护。</p><p id="076d" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这种分离也使得分别维护算法和调度变得更加容易。这使得尝试不同的调度更快，否则需要复杂的循环结构改变。</p><p id="ac26" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">同样的<code class="fe nd ne nf ng b">3x3 box blur</code>在卤化物中被写成</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3×3框模糊的卤化物实现</p></figure><p id="5a15" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">上述代码在目标硬件上的平均延迟似乎为<code class="fe nd ne nf ng b"><strong class="lt iu">0.29ms/MP</strong></code>(同上)。</p><p id="7b48" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">上面的时间表告诉编译器生成平铺循环，生成向量指令，并按行顺序并行化循环。做这些通常需要我们用标准C++编写大型的分解循环。</p><p id="bb86" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">通常，当我们开始利用并行时，内存带宽开始成为瓶颈。如果您决定在垂直计算模糊之前进行完整的水平扫描，存储和内存带宽要求会加倍。这些问题通常通过将2D环分解成精心选择尺寸的瓦片，然后将这些环融合来解决。</p><p id="b3fc" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">正如你在上面的代码示例中看到的——Halide代码使这变得更加容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/358d99451e8c4bb46ff41d6542ad16f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*jsYH02pFRGYivkke.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">t <em class="nl"> iled执行for-loop的演示(来源:</em><a class="ae ky" href="https://halide-lang.org/tutorials/tutorial_lesson_05_scheduling_1.html" rel="noopener ugc nofollow" target="_blank"><em class="nl"/></a><em class="nl">，Apache许可)。</em></p></figure><p id="6f90" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">从工程的角度来看，这大大减少了为实现高性能而需要编写的样板代码。</p><p id="51d6" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这应该给了你相当减少工程时间和成本的暗示。</p><h1 id="a164" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">总结—优点和缺点</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以上三种方法的利弊。</p></figure><p id="a612" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">因此可以得出这样的结论</p><blockquote class="oq"><p id="b51e" class="or os it bd ot ou ov ow ox oy oz mm dk translated">TL；DR；<strong class="ak"> Halide语言允许我们编写快速且可维护的代码。</strong></p></blockquote><p id="2e15" class="pw-post-body-paragraph lr ls it lt b lu pa ju lw lx pb jx lz ma pc mc md me pd mg mh mi pe mk ml mm im bi translated">即使是专家也需要时间来编写快速代码</p><blockquote class="oq"><p id="4726" class="or os it bd ot ou ov ow ox oy oz mm dk translated">Halide使探索不同方法的选择空间变得更加容易。</p></blockquote><p id="d9ae" class="pw-post-body-paragraph lr ls it lt b lu pa ju lw lx pb jx lz ma pc mc md me pd mg mh mi pe mk ml mm im bi translated">如果你认为这对你或你的团队有用，你可以<a class="ae ky" href="https://halide-lang.org/#gettingstarted" rel="noopener ugc nofollow" target="_blank">从这里开始</a>。</p><h1 id="2637" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">向开发团队大声喊出来</h1><p id="54d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">非常感谢乔纳森·拉冈-凯利和他的团队提出了Halide并将其开源。本文中的大部分内容来自他们发表的论文— <a class="ae ky" href="https://dl.acm.org/doi/10.1145/3150211" rel="noopener ugc nofollow" target="_blank"> Halide:从高性能图像处理调度中分离算法</a>。</p><p id="9aae" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我很幸运能与一些作者和相关成员一起工作。</p><h1 id="e759" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">文章系列</h1><p id="d9d4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe nd ne nf ng b">Updated: 24th April 2022</code></p><p id="fef0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这篇文章是这类文章系列的先导。</p><p id="1d84" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在接下来的几篇文章中，我打算写一下:</p><div class="pj pk gp gr pl pm"><a rel="noopener  ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-the-general-concepts-4d865466bb8c"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">理解Halide编程语言的一般概念</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">编写快速且可维护的代码</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">better编程. pub</p></div></div><div class="pv l"><div class="pw l px py pz pv qa ks pm"/></div></div></a></div><ul class=""><li id="68fd" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">文章3:使用Halide在Android上进行快速图像处理。</li><li id="158a" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">第4篇:寻找最佳日程安排——自动日程安排。</li></ul><p id="751b" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">您可以在这个列表中找到更多关于高性能编码的文章</p><div class="pj pk gp gr pl"><div role="button" tabindex="0" class="ab bv gv cb fp qb qc bn qd ks ex"><div class="qe l"><div class="ab q"><div class="l di"><img alt="Minhaz" class="l de bw qf qg fe" src="../Images/cd9ac9977d8ffc444abc911dcdb968aa.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/2*QFRzn3asxEXwn_E3bUwdrA.jpeg"/><div class="fb bw l qf qg fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">米纳兹</p></div></div><div class="qj qk gw l"><h2 class="bd iu vv mn fp vw fr fs ps fu fw is bi translated">高性能代码</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi vx au vy vz wa sn wb an eh ei wc wd we el em eo de bk ep" href="https://minhazav.medium.com/list/high-performance-code-7f82f340016e?source=post_page-----6a5c3a519250--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="wf l fo"><span class="bd b dl z dk">7 stories</span></div></div></div><div class="qw dh qx fp ab qy fo di"><div class="di qo bv qp qq"><div class="dh l"><img alt="" class="dh" src="../Images/1cae477e6ef92e608d6b28fc5752d0be.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*o-1FRXCv8hwsN5IMYRxo3Q.jpeg"/></div></div><div class="di qo bv qr qs qt"><div class="dh l"><img alt="" class="dh" src="../Images/7a73323cf1e4e60ef276be0bde43f4ea.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*2yD5NdXGbqIVWpsz"/></div></div><div class="di bv qu qv qt"><div class="dh l"><img alt="" class="dh" src="../Images/9c55b1ab03fddb2665ecfd6eca915668.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*Yo50V9O0FyYS_wpF"/></div></div></div></div></div><p id="f603" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果你想了解这个话题的具体内容，请在评论中标注。</p><h1 id="1fbe" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><ol class=""><li id="5c91" class="mn mo it lt b lu lv lx ly ma rc me rd mi re mm rf mv mw mx bi translated">【halide-lang.org】卤化物</li><li id="b776" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm rf mv mw mx bi translated"><a class="ae ky" href="https://halide-lang.org/tutorials/tutorial_introduction.html" rel="noopener ugc nofollow" target="_blank">卤化物教程</a></li><li id="0fc9" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm rf mv mw mx bi translated"><a class="ae ky" href="https://dl.acm.org/doi/10.1145/3150211" rel="noopener ugc nofollow" target="_blank"> Halide:从高性能图像处理的时间表中分离算法</a> —乔纳森·拉冈-凯利等人的开放存取研究文章。艾尔。</li><li id="e33f" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm rf mv mw mx bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/processing-images-fast-with-native-code-in-android-db8b21001fa9">使用Android中的原生代码快速处理图像</a></li><li id="5ce5" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm rf mv mw mx bi translated"><a class="ae ky" href="https://medium.com/computational-photography/fast-image-processing-in-android-with-renderscript-4bc6992ba48e" rel="noopener">如何使用RenderScript将YUV_420_888 YUV图像转换为位图</a></li><li id="48c1" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm rf mv mw mx bi translated"><a class="ae ky" href="https://blog.minhazav.dev/faster-image-processing-in-android-java-using-multi-threading/" rel="noopener ugc nofollow" target="_blank">使用多线程技术加快Android Java中的图像处理速度</a></li></ol></div><div class="ab cl rg rh hx ri" role="separator"><span class="rj bw bk rk rl rm"/><span class="rj bw bk rk rl rm"/><span class="rj bw bk rk rl"/></div><div class="im in io ip iq"><p id="b498" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><em class="np">原发布于</em><a class="ae ky" href="https://blog.minhazav.dev/write-fast-and-maintainable-code-with-halide/" rel="noopener ugc nofollow" target="_blank"><em class="np">https://blog . minhazav . dev</em></a></p></div></div>    
</body>
</html>