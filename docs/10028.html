<html>
<head>
<title>Should You Use BLoC to Manage State in Flutter?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中应该使用阻塞来管理状态吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-use-bloc-to-manage-state-in-flutter-4f504ebc8711?source=collection_archive---------3-----------------------#2021-11-16">https://betterprogramming.pub/should-you-use-bloc-to-manage-state-in-flutter-4f504ebc8711?source=collection_archive---------3-----------------------#2021-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b03e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于Flutter最受欢迎的州经理的三集系列</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f5623d795f8af22165a864f821b3659f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T4BDmN9LerhyiUCI.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@fabiraw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法比安·阿尔伯特</a>在<a class="ae kv" href="https://unsplash.com/s/photos/mobile-device?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d5f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个由三部分组成的系列中，我将对Flutter使用最广泛的状态管理器进行并排比较。</p><p id="e7dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多工具，但是它们之间缺乏清晰的对比。这是一个遗憾，因为选择错误的状态管理器并不容易从你开始构建的地方撤销。</p><p id="8d67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我给你一个简短的指导手册。首次使用前请仔细阅读！第二个最受欢迎的州经理叫做<a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> Flutter bloc </a>，是这篇博客的主题。下面是第一部分的链接。</p><ul class=""><li id="e073" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://javascript.plainenglish.io/how-to-manage-state-in-flutter-with-provider-661ff322dd22" rel="noopener ugc nofollow" target="_blank">第1部分:如何使用提供者管理Flutter中的状态</a></li></ul><h2 id="a0c3" class="mb mc iq bd md me mf dn mg mh mi dp mj lf mk ml mm lj mn mo mp ln mq mr ms mt bi translated">什么是颤动集团？</h2><p id="3a51" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated"><a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank">颤振模块</a>封装的名称来源于<a class="ae kv" href="https://medium.com/r?url=https%3A%2F%2Fwww.flutterclutter.dev%2Fflutter%2Fbasics%2Fwhat-is-the-bloc-pattern%2F2021%2F2084%2F" rel="noopener">模块设计模式</a>。BLoC是“业务逻辑组件”的缩写，与大多数状态管理器一样，它旨在将业务逻辑从视图中分离出来。</p><p id="8e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flutter bloc包为您提供了在应用程序中实现bloc模式的所有工具。这个包的核心围绕着两个主要的概念“Cubits”和“Blocs ”,我将简单解释一下。</p><h2 id="e582" class="mb mc iq bd md me mf dn mg mh mi dp mj lf mk ml mm lj mn mo mp ln mq mr ms mt bi translated">用Cubit管理状态</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/76dfc8a8705c1de8c60b78598531e59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6ZSlGw5Yha1DuT0urzAig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="http://1/#/coreconcepts?id=cubit" rel="noopener ugc nofollow" target="_blank">包:bloc文档</a></p></figure><p id="3041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Cubit管理状态对于以前使用过状态管理器的人来说可能很熟悉。</p><ul class=""><li id="72f9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">状态在<code class="fe na nb nc nd b"><a class="ae kv" href="https://bloclibrary.dev/#/coreconcepts?id=cubit" rel="noopener ugc nofollow" target="_blank">Cubit</a></code> <a class="ae kv" href="https://bloclibrary.dev/#/coreconcepts?id=cubit" rel="noopener ugc nofollow" target="_blank">类</a>中存储和处理。此外，Cubit公开了一系列状态变化。</li><li id="dcd8" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated"><code class="fe na nb nc nd b"><a class="ae kv" href="https://bloclibrary.dev/#/flutterbloccoreconcepts?id=blocprovider" rel="noopener ugc nofollow" target="_blank">BlocProvider</a></code>使腕尺可被视图访问。</li><li id="aced" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated"><code class="fe na nb nc nd b"><a class="ae kv" href="https://bloclibrary.dev/#/flutterbloccoreconcepts?id=blocbuilder" rel="noopener ugc nofollow" target="_blank">BlocBuilder</a></code>监听变化的状态，并相应地呈现用户界面。</li></ul><p id="3e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，管理递增计数器的状态将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="980b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式非常类似于带有提供者的状态管理，我在本系列的第一部分中描述过。因此，Flutter Bloc的真正价值不是在Cubit中，而是在实际的Bloc本身中。</p><h2 id="0200" class="mb mc iq bd md me mf dn mg mh mi dp mj lf mk ml mm lj mn mo mp ln mq mr ms mt bi translated">用Bloc管理状态</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/bf0eae36cfdf4f9898bf6e9e19c91b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_TQw6xQSCdLj7elNoGVwg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://bloclibrary.dev/#/coreconcepts?id=bloc" rel="noopener ugc nofollow" target="_blank">包:bloc文档</a></p></figure><p id="79eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bloc的独特卖点是<em class="nl">事件</em>。Cubit只是发送状态更新，而不提供关于变更的<em class="nl">根源</em>的额外信息。</p><p id="ed65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要你的状态是简单的，就像反例一样，这就不是问题。但是假设你的计数器有10种不同的递增方式。您将如何调试意外的状态更新，或者根据变化原因区分您的应用程序的行为？简而言之，缺乏可追溯性造成了一个真正的问题。</p><pre class="kg kh ki kj gt nm nd nn no aw np bi"><span id="81f3" class="mb mc iq nd b gy nq nr l ns nt">// A Bloc transition</span><span id="3b38" class="mb mc iq nd b gy nu nr l ns nt"><strong class="nd ir">Transition {<br/>  currentState: Counter(0),<br/>  event: Increment,<br/>  nextState: Counter(1)<br/>}</strong></span><span id="299e" class="mb mc iq nd b gy nu nr l ns nt"><strong class="nd ir">Transition {<br/>  currentState: Counter(0),<br/>  nextState: Counter(1)<br/>}</strong></span></pre><p id="33d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bloc通过引入事件解决了这个问题。事件提供关于<em class="nl">为什么</em>状态已经改变的信息。事件使您可以完全控制应用程序的状态流。对于不仅仅是增加计数器的应用程序来说，这是非常理想的。</p><p id="e366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是每个伟大的礼物都是有代价的。Blocs比Cubits更冗长。状态和事件需要额外的样板文件，如下例所示。但是，在我看来，这是值得付出的代价。从长远来看，可追溯性是应用程序可管理性的先决条件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="c7a5" class="mb mc iq bd md me mf dn mg mh mi dp mj lf mk ml mm lj mn mo mp ln mq mr ms mt bi translated"><strong class="ak">谁应该使用颤振闭锁</strong></h2><p id="728c" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">那么现在你已经掌握了Flutter bloc包，你真的应该使用它吗？</p><h2 id="9bb0" class="mb mc iq bd md me mf dn mg mh mi dp mj lf mk ml mm lj mn mo mp ln mq mr ms mt bi translated"><strong class="ak">优点</strong></h2><ul class=""><li id="44fe" class="ls lt iq ky b kz mu lc mv lf nv lj nw ln nx lr lx ly lz ma bi translated">作为第二受欢迎的状态管理器，该包得到了很好的维护，并证明了它的价值。</li><li id="5d0a" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated">该软件包提供基于非事件的库比特以及基于事件的块，能够适应您的应用需求。</li><li id="d23e" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated">有很多方法可以防止UI的冗余更新。例如，集团国家利用<a class="ae kv" href="https://pub.dev/packages/equatable" rel="noopener ugc nofollow" target="_blank">等同于</a>。Equatable将旧状态与新状态进行比较，并在状态不变时阻止更新。此外，<a class="ae kv" href="https://bloclibrary.dev/#/flutterbloccoreconcepts?id=bloclistener" rel="noopener ugc nofollow" target="_blank"> BlocListener </a>有一个<code class="fe na nb nc nd b">listenWhen</code>属性，它作为一个看门人，只允许访问想要的更新。总之，这个包提供了关注应用程序性能的工具。</li><li id="4c30" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated"><a class="ae kv" href="https://bloclibrary.dev/#/" rel="noopener ugc nofollow" target="_blank">文档</a>非常出色，详细阐述了不仅仅是核心内部的东西。这里有大量的例子，一种方法的优点和缺点，最佳和不好的实践，以及关于包核心概念的背景信息。</li></ul><h2 id="06b3" class="mb mc iq bd md me mf dn mg mh mi dp mj lf mk ml mm lj mn mo mp ln mq mr ms mt bi translated"><strong class="ak">缺点</strong></h2><ul class=""><li id="5bbd" class="ls lt iq ky b kz mu lc mv lf nv lj nw ln nx lr lx ly lz ma bi translated">Flutter Bloc包的巨大尺寸使它很难学习。当面对一个质量工具的大工具箱时，很难选择一个合适的。对于不熟悉流和基于事件的状态管理的开发人员来说，学习曲线尤其陡峭。</li><li id="f836" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated">这个方案有着可疑的荣誉，它需要所有州政府官员中最多的样板文件。尤其是基于事件的块非常冗长。要设置前面提到的基本计数器块，您需要三个单独的文件:一个用于计数器的状态，一个用于计数器的事件，一个用于实际的块。尽管有很好的<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc" rel="noopener ugc nofollow" target="_blank">扩展</a>来自动化样板文件的创建，你的代码库仍然会像一个喂养良好的幼儿一样成长。</li></ul><p id="6daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，在我看来，Flutter bloc是大多数Flutter应用程序的发展方向。它克服了提供者基于事件的状态管理的不足。此外，它的工具集是广泛的，使其可用于更简单和更复杂的应用程序。这些优势使得陡峭的学习曲线是值得的。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="869b" class="of mc iq bd md og oh oi mg oj ok ol mj jw om jx mm jz on ka mp kc oo kd ms op bi translated"><em class="oq">资源</em></h1><ul class=""><li id="c325" class="ls lt iq ky b kz mu lc mv lf nv lj nw ln nx lr lx ly lz ma bi translated">Flutter_bloc包:<a class="ae kv" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank">https://pub.dev/packages/flutter_bloc</a></li><li id="fbcd" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated">集团设计模式:<a class="ae kv" href="https://medium.com/r?url=https%3A%2F%2Fwww.flutterclutter.dev%2Fflutter%2Fbasics%2Fwhat-is-the-bloc-pattern%2F2021%2F2084%2F" rel="noopener">https://medium.com/r?URL = https % 3A % 2F % 2fwww . flutter clutter . dev % 2ff lutter % 2f basics % 2f bloc-pattern是什么%2F2021%2F2084%2F </a></li><li id="5a71" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated">区块库文档:<a class="ae kv" href="https://bloclibrary.dev/" rel="noopener ugc nofollow" target="_blank">https://bloclibrary.dev/</a></li><li id="6351" class="ls lt iq ky b kz ne lc nf lf ng lj nh ln ni lr lx ly lz ma bi translated">用于生成块样板文件的扩展:<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc" rel="noopener ugc nofollow" target="_blank">https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc </a></li></ul></div></div>    
</body>
</html>