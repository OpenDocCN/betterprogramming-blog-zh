<html>
<head>
<title>Build a Like Modifier for Any View in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为SwiftUI中的任何视图构建Like修改器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-like-modifier-a0ad41e0c4c7?source=collection_archive---------2-----------------------#2020-05-02">https://betterprogramming.pub/swiftui-like-modifier-a0ad41e0c4c7?source=collection_archive---------2-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4795" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给任何人“被喜欢”的能力</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/03ff0c017e2f06cb3b457d05cf856608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRj5qlvMeFuUm11Ppl2iWA.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">保罗·坎德罗在<a class="ae lc" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0469" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个简短的教程将带您完成创建带有手势和动画的自定义弹出窗口的过程。然后您将扩展这个<code class="fe ki kj kk kl b">ViewModifier</code>以允许它被您项目中的任何<code class="fe ki kj kk kl b">View</code>使用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c7d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">入门</strong></h1><ul class=""><li id="fb44" class="my mz it lf b lg na lj nb lm nc lq nd lu ne ly nf ng nh ni bi translated">首先创建一个新文件<code class="fe ki kj kk kl b">LikeModifier.swift</code>。</li><li id="97b6" class="my mz it lf b lg nj lj nk lm nl lq nm lu nn ly nf ng nh ni bi translated">从下面添加基本的<code class="fe ki kj kk kl b">ViewModifier</code>存根。到目前为止，当我们将修饰符添加到我们的视图中时，它将返回原来的内容。</li></ul><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="54af" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建“喜欢”覆盖</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7018c599a868e21260ef3ace7906a935.png" data-original-src="https://miro.medium.com/v2/resize:fit:160/format:webp/0*slXGd_tmkJIaulx8.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">类似的覆盖层</p></figure><p id="d790" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我们的<code class="fe ki kj kk kl b">content</code>被双击时，我们希望在右上角显示类似的覆盖图。首先，我们必须创建它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2c07" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">跟踪用户交互</h1><p id="1348" class="pw-post-body-paragraph ld le it lf b lg na ju li lj nb jx ll lm nr lo lp lq ns ls lt lu nt lw lx ly im bi translated">现在有趣的部分来了。直到用户双击<code class="fe ki kj kk kl b">content</code>，我们才能显示覆盖图。为了跟踪这一点，我们需要添加一个名为<code class="fe ki kj kk kl b">liked</code>的<code class="fe ki kj kk kl b">@State</code>变量。</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="5c32" class="ny mh it kl b gy nz oa l ob oc">@State var liked: Bool = false</span></pre><p id="e175" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，在我们的<code class="fe ki kj kk kl b">body</code>函数中，我们更新了<code class="fe ki kj kk kl b">content</code>，使<code class="fe ki kj kk kl b">TapGesture</code>在触发前接受<code class="fe ki kj kk kl b">2</code>点击——然后，当它触发时，它翻转<code class="fe ki kj kk kl b">liked</code>的值。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bfc4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">动画覆盖</h1><p id="4da6" class="pw-post-body-paragraph ld le it lf b lg na ju li lj nb jx ll lm nr lo lp lq ns ls lt lu nt lw lx ly im bi translated">现在我们通过<code class="fe ki kj kk kl b">liked</code>变量跟踪<code class="fe ki kj kk kl b">content</code>的状态，我们可以隐藏和显示视图。为此，我们使用了<code class="fe ki kj kk kl b">scaleEffect</code>和<code class="fe ki kj kk kl b">opacity</code>的组合。将这些功能添加到我们的覆盖图的末尾:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="6711" class="ny mh it kl b gy nz oa l ob oc">.opacity(self.liked ? 1.0 : 0)<br/>.scaleEffect(self.liked ? 1.0 : 0, anchor: .center)<br/>.animation(.easeIn(duration: 0.2))</span></pre><p id="626b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在转到您项目的<code class="fe ki kj kk kl b">ContentView.swift</code>并使用以下代码测试<code class="fe ki kj kk kl b">LikeModifier</code>:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="073e" class="ny mh it kl b gy nz oa l ob oc">Rectangle()<br/>    .cornerRadius(10)<br/>    .frame(width: 200, height: 200, alignment: .center)<br/>    .modifier(LikeModifier())</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b2c834c9724730d843cc3ec410133670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*wgoxWLpy2FYjcJxG.gif"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">工作中的LikeModifier</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="96d7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">添加回拨</h1><p id="e949" class="pw-post-body-paragraph ld le it lf b lg na ju li lj nb jx ll lm nr lo lp lq ns ls lt lu nt lw lx ly im bi translated">这很好，但是如果用户与<code class="fe ki kj kk kl b">View</code>交互时没有收到更新，这又有什么用呢？当我们初始化<code class="fe ki kj kk kl b">LikeModifier</code>时，我们将传递一个在<code class="fe ki kj kk kl b">TapGesture</code>被触发时调用的函数，向<code class="fe ki kj kk kl b">LikeModifier</code>添加一个回调:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="810b" class="ny mh it kl b gy nz oa l ob oc">struct LikeModifier: ViewModifier { @State var liked: Bool = false var callback:()-&gt;() func body(content: Content) -&gt; some View { content // ... // Overlay here // ... .gesture( TapGesture(count: 2) .onEnded({ withAnimation { self.liked = !self.liked } // Fire the callback so we can update the model. self.callback() }) ) } }</span></pre><p id="7f30" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在您可以将您的测试代码更新为:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="de51" class="ny mh it kl b gy nz oa l ob oc">Rectangle()<br/>    .cornerRadius(10)<br/>    .frame(width: 200, height: 200, alignment: .center)<br/>    .modifier(LikeModifier {<br/>    	// Update model here...<br/>    })</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9a12" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">延伸<code class="fe ki kj kk kl b">View</code></h1><p id="f4bf" class="pw-post-body-paragraph ld le it lf b lg na ju li lj nb jx ll lm nr lo lp lq ns ls lt lu nt lw lx ly im bi translated">如果你愿意的话，你也可以扩展<code class="fe ki kj kk kl b">View</code>类，以便更容易地添加<code class="fe ki kj kk kl b">LikeModifier</code>:</p><pre class="kn ko kp kq gt nu kl nv nw aw nx bi"><span id="0d78" class="ny mh it kl b gy nz oa l ob oc">extension View {<br/>    func onFavorite(callback: @escaping ()-&gt;()) -&gt; some View {<br/>        return self.modifier(LikeModifier(callback: callback))<br/>    }<br/>}</span></pre><p id="1e20" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这使得你的代码更具可读性，并减少了样板文件。</p><p id="2c6d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">感谢阅读！保重。</p></div></div>    
</body>
</html>