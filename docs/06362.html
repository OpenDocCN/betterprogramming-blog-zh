<html>
<head>
<title>4 Reasons to Avoid Using Array.reduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免使用Array.reduce的4个理由</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/think-again-before-you-use-array-reduce-28f785b5aea9?source=collection_archive---------0-----------------------#2020-09-25">https://betterprogramming.pub/think-again-before-you-use-array-reduce-28f785b5aea9?source=collection_archive---------0-----------------------#2020-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b727" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不用它编写更可读的JavaScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ccf037451551515e2931cfe1e7588440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIz0kYD036KHfWsP8q1m8g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="276b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着函数式编程(FP)范式的兴起，我们构建JavaScript应用程序的方式每年都在变化。由于这个原因，数组方法非常流行，因为你可以将它们链接起来(例如<code class="fe lr ls lt lu b">map.filter.map.flatMap</code>)。一些开发人员认为使用标准的<code class="fe lr ls lt lu b">for</code>或<code class="fe lr ls lt lu b">while</code>循环是老一套。</p><p id="9366" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中一个方法是<code class="fe lr ls lt lu b">Array.reduce.</code>它不像其他标准数组方法那样简单，例如:<code class="fe lr ls lt lu b">Array.filter</code>或<code class="fe lr ls lt lu b">Array.map.</code>在本文中，我想谈谈<code class="fe lr ls lt lu b">Array.reduce</code>的潜在缺点，并向您展示您可能不需要使用它。我们开始吧。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="2256" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">1.Array.reduce可能很难理解</h1><p id="76fb" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><a class="ae mz" href="https://medium.com/search?q=Array.reduce" rel="noopener">如果你在Medium </a>上搜索 <code class="fe lr ls lt lu b"><a class="ae mz" href="https://medium.com/search?q=Array.reduce" rel="noopener">Array.reduce</a></code> <a class="ae mz" href="https://medium.com/search?q=Array.reduce" rel="noopener">，大部分文章都侧重于解释它是如何工作的。当我在私人窗口中谷歌“Array.reduce explain”(不带引号)，我得到</a><a class="ae mz" href="https://www.google.com/search?q=Array.reduce+explain" rel="noopener ugc nofollow" target="_blank">190万个结果</a>，但当我做同样的搜索“Array.filter explain”，我得到<a class="ae mz" href="https://www.google.com/search?q=Array.filter+explain" rel="noopener ugc nofollow" target="_blank">93万个结果</a>。这表明<code class="fe lr ls lt lu b">Array.reduce</code>不像其他数组方法那样简单。</p><p id="794f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">乍看起来,“累加器”变量背后的推理并不简单。如果你不懂<code class="fe lr ls lt lu b">Array.reduce</code>，我建议先看其中一篇文章再继续。我会等的。</p><p id="ab84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你来自函数式编程(FP)背景，你可能已经对使用<code class="fe lr ls lt lu b">Array.reduce</code>感到很舒服了。但是，尽管JavaScript提供了必要的内置来支持FP，大多数JavaScript开发人员(还)不熟悉它。我和许多有才华的JavaScript开发者一起工作过，他们都在为<code class="fe lr ls lt lu b">Array.reduce.</code>而奋斗</p><p id="7593" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在使用<code class="fe lr ls lt lu b">Array.reduce</code>之前，考虑以不同的方式编写相同的逻辑。尽管不同的版本不能保证更好的可读性，但它给了你一个比较的机会。这可能有助于未来的读者更容易理解它。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="a9dd" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">2.可选初始值参数的搜索</h1><p id="a5f3" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">不看剩下的代码能告诉我<code class="fe lr ls lt lu b">acc</code> <strong class="kx ir"> </strong>持有什么吗？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0308" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要理解<code class="fe lr ls lt lu b">acc</code>是什么，你需要出去搜索一下。你要么需要定位<code class="fe lr ls lt lu b">Array.reduce</code>的最后一个参数，要么从reducer函数中推断出来。</p><p id="fc3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是您的搜索可能不会产生任何结果，因为初始值是一个可选参数。这使得搜索变得更加困难，因为你可能在寻找不存在的东西。</p><p id="4baf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我看来，这是一个奇怪的API设计。累加器参数实际上可以是任何东西或者数组中的第一项。其他面向FP的语言很好地解决了这个问题，例如，Scala有单独的<code class="fe lr ls lt lu b"><a class="ae mz" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#reduce[B%3E:A](op:(B,B)=%3EB):B" rel="noopener ugc nofollow" target="_blank">.reduce</a> </code>和<code class="fe lr ls lt lu b"><a class="ae mz" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#fold[A1%3E:A](z:A1)(op:(A1,A1)=%3EA1):A1" rel="noopener ugc nofollow" target="_blank">.fold</a></code>方法。前者不接受初始参数，而后者明确要求一个参数作为第一个参数。</p><p id="d6c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当reducer函数的主体不仅仅是几行时，弄清楚<code class="fe lr ls lt lu b">acc</code>包含什么变得更加具有挑战性。一种解决方法是提取reducer函数，以便于定位初始值参数。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="4c19" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">3.你是减少，过滤，还是映射？</h1><p id="3b87" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Array.reduce</code>是一个强大的方法，您可能会无意中误用它，使代码更难阅读。你可以错误地使用<code class="fe lr ls lt lu b">Array.reduce</code>来模仿现有的内置数组方法。</p><p id="7f83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看下面的例子，其中误用了<code class="fe lr ls lt lu b">Array.reduce</code>而不是<code class="fe lr ls lt lu b">Array.filter</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3962" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个误用<code class="fe lr ls lt lu b">Array.reduce</code>而不是<code class="fe lr ls lt lu b">Array.map</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9ab1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管人们总是可以误用任何方法，但我相信<code class="fe lr ls lt lu b">Array.reduce</code>的灵活性增加了机会。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="ae47" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">4.您总是可以用不同的方式编写相同的代码</h1><p id="f27c" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">这是一个主观的论点，所以不要全信。可读性是一个非常主观的体验，因人而异。开发人员使用FP方法越多，回读起来就越容易。</p><p id="02ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在这方面的经验是，许多前端开发人员还没有完全适应<code class="fe lr ls lt lu b">Array.reduce</code>。</p><p id="486a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Array.reduce</code>的唯一功能是累积东西(数字、字符串、数组等。).您还可以使用它来展平嵌套数组，但由于有了<code class="fe lr ls lt lu b">Array.flat</code>，这不再是必要的了。没见过其他实际用法。而且你总是可以用一种更易读的方式来编码“积累”的东西。</p><p id="2d72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看几个例子，从初级到高级。</p><h2 id="6b8e" class="nd md iq bd me ne nf dn mi ng nh dp mm le ni nj mo li nk nl mq lm nm nn ms no bi translated">聚合数字</h2><p id="77bb" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">让我们从一个教科书用例开始。当您想从数组中创建一个聚合时,<code class="fe lr ls lt lu b">Array.reduce</code>非常有用。下面的示例计算数组的总和:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a297" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的代码执行同样的计算:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e1c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，这里有什么不同呢？两个版本几乎相同，除了<code class="fe lr ls lt lu b">Array.reduce</code>方法没有创建可变变量(<code class="fe lr ls lt lu b">total</code>)。对于重视不变性的工程师来说，这是一个很大的缺点。另一方面，后一个版本可以被高年级和低年级学生轻松阅读。在某些情况下，你可以选择其中之一。</p><h2 id="c81d" class="nd md iq bd me ne nf dn mi ng nh dp mm le ni nj mo li nk nl mq lm nm nn ms no bi translated">从数组构建对象</h2><p id="4500" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Array.reduce</code>不仅用于原始值。您也可以用它来生成对象和数组。下面是从嵌套数组对创建对象的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b4e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，这个例子来自于过去<code class="fe lr ls lt lu b">Object.fromEntries</code>还不存在的时代。否则，您可以像下面这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="8b88" class="nd md iq bd me ne nf dn mi ng nh dp mm le ni nj mo li nk nl mq lm nm nn ms no bi translated">分组对象</h2><p id="7027" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">下面是一个基于函数对元素进行分组的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f209" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧，如果你已经做到这一步，我希望你明白其中的逻辑。如果你不知道，这里有一个更简单的版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="fb63" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">外卖食品</h1><ul class=""><li id="66c7" class="np nq iq kx b ky mu lb mv le nr li ns lm nt lq nu nv nw nx bi translated"><code class="fe lr ls lt lu b">Array.reduce</code>通常服务于一个目的，即从数组中累加单个值。您通常可以使用其他数组方法，如<code class="fe lr ls lt lu b">Array.forEach</code>、<code class="fe lr ls lt lu b">Array.filter</code>或<code class="fe lr ls lt lu b">Array.map</code>，以更易读的方式编写这样的逻辑。考虑用一个手动定义的临时“累加器”变量来代替——特别是当你的reducer函数很长的时候。</li><li id="47b9" class="np nq iq kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated">要弄清楚累加器变量包含的内容，需要确定是否提供了可选的初始值参数。它可能在那里，也可能不在那里。弄清楚这一点很有挑战性——尤其是对于长减速器函数。</li><li id="bb4c" class="np nq iq kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated"><code class="fe lr ls lt lu b">Array.reduce</code>容易被误用。reducer函数可用于提供其他内置数组方法的功能，如<code class="fe lr ls lt lu b">Array.filter, Array.map or Array.indexOf</code>。</li></ul><p id="371d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文中的论点并不意味着你应该不惜一切代价放弃<code class="fe lr ls lt lu b">Array.reduce</code>，而是提醒你考虑替代方案。<code class="fe lr ls lt lu b">Array.reduce</code>在各种情况下都非常有用，我将在以后的文章中介绍它们，敬请关注。</p><p id="1e09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你对<code class="fe lr ls lt lu b">Array.reduce</code>还有其他创造性的使用案例吗？请在评论中告诉我。</p><p id="6c11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p><p id="37f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我编辑了这篇文章，里面有来自不同人的有用的评论。</p></div></div>    
</body>
</html>