<html>
<head>
<title>Automating Background Color Removal with Python and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和OpenCV自动去除背景色</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automating-white-or-any-other-color-background-removal-with-python-and-opencv-4be4addb6c99?source=collection_archive---------11-----------------------#2019-11-25">https://betterprogramming.pub/automating-white-or-any-other-color-background-removal-with-python-and-opencv-4be4addb6c99?source=collection_archive---------11-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c45" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">图像处理基础</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f991dc2e55077c34307a14efc973a42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*rj4DmlbX2G4Aq_TfuvnmJg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">绝对是最好的组合</p></figure><p id="97a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几天前，我面临一个项目，当草图被放入某个文件夹时，需要去掉它们的白色背景。这一切都发生在硬件扫描仪中。</p><p id="d828" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个草图的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f985349ff3ce16d93ef3051598bb0ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*tb__c_DOJJ2bMBsq7w-s7g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">示例图</p></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="a813" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一步是安装这个项目的依赖项，如下所列。我们也将使用<strong class="kw iu"> Python 3.7。</strong></p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="1c05" class="mc md it ly b gy me mf l mg mh">opencv_python==4.1.0.25</span><span id="950f" class="mc md it ly b gy mi mf l mg mh">pip install opencv-python</span><span id="fb74" class="mc md it ly b gy mi mf l mg mh">numpy==1.16.4</span><span id="712d" class="mc md it ly b gy mi mf l mg mh">pip install numpy</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="a6cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们将开始导入项目所需的所有模块:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="fc1a" class="mc md it ly b gy me mf l mg mh"><em class="mj">import</em> cv2</span><span id="de5b" class="mc md it ly b gy mi mf l mg mh"><em class="mj">import</em> os</span><span id="9814" class="mc md it ly b gy mi mf l mg mh"><em class="mj">import</em> string</span><span id="e4a9" class="mc md it ly b gy mi mf l mg mh"><em class="mj">import</em> random</span><span id="4d67" class="mc md it ly b gy mi mf l mg mh"><em class="mj">from</em> os <em class="mj">import</em> listdir</span><span id="7756" class="mc md it ly b gy mi mf l mg mh"><em class="mj">from</em> os.path <em class="mj">import</em> isfile, join, splitext</span><span id="fbe9" class="mc md it ly b gy mi mf l mg mh"><em class="mj">import</em> time</span><span id="a340" class="mc md it ly b gy mi mf l mg mh"><em class="mj">import</em> sys</span><span id="1940" class="mc md it ly b gy mi mf l mg mh"><em class="mj">import</em> numpy <em class="mj">as</em> np</span><span id="326d" class="mc md it ly b gy mi mf l mg mh"><em class="mj">import</em> argparse</span></pre><p id="d5b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们创建三个不同的变量:要监视的文件夹的名称、图像处理后将存放的文件夹的名称，以及监视文件夹时的轮询时间(即，检查文件夹中的更改的频率——在我们的例子中是一秒钟)</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="08b1" class="mc md it ly b gy me mf l mg mh">watch_folder = ‘toprocess’</span><span id="51dd" class="mc md it ly b gy mi mf l mg mh">processed_folder = ‘processed’</span><span id="6f65" class="mc md it ly b gy mi mf l mg mh">poll_time = 1</span></pre><p id="39ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，文件夹“toprocess”和“processed”将位于python脚本的同一个目录中。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="223f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将转到我们的主函数，它将监视我们的“toprocess”目录，如果发生任何变化，将处理放入该文件夹的图像。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="e672" class="mc md it ly b gy me mf l mg mh">before = dict([(f, None) <em class="mj">for</em> f in os.listdir(watch_folder)])</span><span id="2b6d" class="mc md it ly b gy mi mf l mg mh"><em class="mj">while</em> 1:</span><span id="0f32" class="mc md it ly b gy mi mf l mg mh">  time.sleep(poll_time)</span><span id="7ecd" class="mc md it ly b gy mi mf l mg mh">  after = dict([(f, None) <em class="mj">for</em> f in os.listdir(watch_folder)])</span><span id="0bbd" class="mc md it ly b gy mi mf l mg mh">  added = [f <em class="mj">for</em> f in after <em class="mj">if</em> not f in before]</span><span id="0704" class="mc md it ly b gy mi mf l mg mh">  removed = [f <em class="mj">for</em> f in before <em class="mj">if</em> not f in after]</span><span id="e79b" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  if</em> added:</span><span id="2a4c" class="mc md it ly b gy mi mf l mg mh">    print(“Added “, “, “.join(added))</span><span id="11a2" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  if</em> added[0] is not None:</span><span id="cdc1" class="mc md it ly b gy mi mf l mg mh">    processImage(added[0])</span><span id="b3e7" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  if</em> removed:</span><span id="358c" class="mc md it ly b gy mi mf l mg mh">    print(“Removed “, “, “.join(removed))</span><span id="017e" class="mc md it ly b gy mi mf l mg mh">  before = after</span></pre><p id="fd62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码无限循环运行，直到脚本被终止。启动时，它将文件存储在名为“before”的字典内的目录中。接下来，无限循环中的步骤用伪代码分解如下:</p><ul class=""><li id="9336" class="mk ml it kw b kx ky la lb ld mm lh mn ll mo lp mp mq mr ms bi translated">休眠指定的轮询时间(1秒)。</li><li id="109c" class="mk ml it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">将目录中的文件信息存储在名为after的字典中。</li><li id="386d" class="mk ml it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">通过比较后的<strong class="kw iu">和<strong class="kw iu">前的</strong>存储已添加的内容(如果前的<em class="mj">不是f，则</em>后的<em class="mj">是f)。</em></strong></li><li id="7ec3" class="mk ml it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">通过比较之前中的<strong class="kw iu">和之后<strong class="kw iu">中的</strong>来存储已经移除的内容。</strong></li><li id="4d57" class="mk ml it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">检查最后添加的元素(added[0])，如果它在那里，那么调用一个函数，我们将在文件上的<strong class="kw iu"> processImage </strong>中讨论这个函数。</li><li id="b3c7" class="mk ml it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">如果删除，只需打印一些信息让用户知道。</li><li id="3ad1" class="mk ml it kw b kx mt la mu ld mv lh mw ll mx lp mp mq mr ms bi translated">最后，将目录中的最新文件从之前更新到之后。</li></ul></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="93ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在是<code class="fe my mz na ly b">processImage</code>函数，它是程序的核心。这就是OpenCV背景去除魔术发生的地方。代码解释如下(需要基本的OpenCV知识):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3024" class="mc md it ly b gy me mf l mg mh">def processImage(<em class="mj">fileName</em>):</span><span id="15d8" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  # Load in the image using the typical imread function using our watch_folder path, and the fileName passed in, then set the final output image to our current image for now</em></span><span id="b33a" class="mc md it ly b gy mi mf l mg mh">  image = cv2.imread(watch_folder + ‘/’ + fileName)</span><span id="5ce4" class="mc md it ly b gy mi mf l mg mh">  output = image</span><span id="1e4e" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  # Set thresholds. Here, we are using the Hue, Saturation, Value color space model. We will be using these values to decide what values to show in the ranges using a minimum and maximum value. <br/></em><strong class="ly iu"><em class="mj">THESE VALUES CAN BE PLAYED AROUND FOR DIFFERENT COLORS</em></strong></span><span id="8dfd" class="mc md it ly b gy mi mf l mg mh">  hMin = 29  # Hue minimum</span><span id="a669" class="mc md it ly b gy mi mf l mg mh">  sMin = 30  # Saturation minimum</span><span id="92a4" class="mc md it ly b gy mi mf l mg mh">  vMin = 0   # Value minimum (Also referred to as brightness)</span><span id="a3cb" class="mc md it ly b gy mi mf l mg mh">  hMax = 179 # Hue maximum</span><span id="34d6" class="mc md it ly b gy mi mf l mg mh">  sMax = 255 # Saturation maximum</span><span id="f508" class="mc md it ly b gy mi mf l mg mh">  vMax = 255 # Value maximum</span><span id="cc21" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  # Set the minimum and max HSV values to display in the output image using numpys' array function. We need the numpy array since OpenCVs' inRange function will use those.</em></span><span id="452f" class="mc md it ly b gy mi mf l mg mh">  lower = np.array([hMin, sMin, vMin])</span><span id="d7df" class="mc md it ly b gy mi mf l mg mh">  upper = np.array([hMax, sMax, vMax])</span><span id="fd0d" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  # Create HSV Image and threshold it into the proper range.</em></span><span id="0d9a" class="mc md it ly b gy mi mf l mg mh">  hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV) # Converting color space from BGR to HSV</span><span id="9c16" class="mc md it ly b gy mi mf l mg mh">  mask = cv2.inRange(hsv, lower, upper) # Create a mask based on the lower and upper range, using the new HSV image</span><span id="dd20" class="mc md it ly b gy mi mf l mg mh">  # Create the output image, using the mask created above. This will perform the removal of all unneeded colors, but will keep a black background.</span><span id="f7a7" class="mc md it ly b gy mi mf l mg mh">  output = cv2.bitwise_and(image, image, <em class="mj">mask</em>=mask)</span><span id="2f20" class="mc md it ly b gy mi mf l mg mh">  # Add an alpha channel, and update the output image variable</span><span id="b48a" class="mc md it ly b gy mi mf l mg mh">  *_, alpha = cv2.split(output)</span><span id="5acf" class="mc md it ly b gy mi mf l mg mh">  dst = cv2.merge((output, alpha))</span><span id="29fa" class="mc md it ly b gy mi mf l mg mh">  output = dst</span><span id="074a" class="mc md it ly b gy mi mf l mg mh">  # Resize the image to 512, 512 (This can be put into a variable for more flexibility), and update the output image variable.</span><span id="50f6" class="mc md it ly b gy mi mf l mg mh">  dim = (512, 512)</span><span id="6987" class="mc md it ly b gy mi mf l mg mh">  output = cv2.resize(output, dim)</span><span id="9552" class="mc md it ly b gy mi mf l mg mh">  # Generate a random file name using a mini helper function called <strong class="ly iu">randomString</strong> to write the image data to, and then save it in the processed_folder path, using the generated filename.</span><span id="2f1a" class="mc md it ly b gy mi mf l mg mh">  file_name = randomString(5) + ‘.png’</span><span id="423b" class="mc md it ly b gy mi mf l mg mh">  cv2.imwrite(processed_folder + ‘/’ + file_name, output)</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="648c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常简单的函数，它可以很好地完成工作。同样，调整阈值可以得到更好的结果。我们需要讨论的最后一件事是为文件名生成随机字符串的迷你助手函数。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="bcc4" class="mc md it ly b gy me mf l mg mh">def randomString(<em class="mj">length</em>):</span><span id="81dd" class="mc md it ly b gy mi mf l mg mh">  letters = string.ascii_lowercase</span><span id="13e5" class="mc md it ly b gy mi mf l mg mh"><em class="mj">  return</em> ‘’.join(random.choice(letters) <em class="mj">for</em> i <em class="mj">in</em> range(length))</span></pre><p id="86a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的函数。它使用“字符串”库获取字母，然后根据您传入的长度加入随机选择的字符。传入长度为5的将生成一个包含5个字符的字符串。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="8d24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">处理的结果如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c2edc4eafc07f8b12ce33d4bcd33f7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*0Tle1eoaEQLA-s9jDkZZyw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">移除背景</p></figure><p id="486f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，这个结果可以通过调整数值和更好的扫描质量来改善。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="01cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">谢谢你坚持到这篇文章的结尾。我希望它对你即将到来的项目有所帮助。</p></div></div>    
</body>
</html>