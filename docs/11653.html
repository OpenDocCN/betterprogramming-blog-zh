<html>
<head>
<title>A Deep Dive Into Go Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究Go并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/deep-dive-into-concurrency-of-go-93002344d37b?source=collection_archive---------1-----------------------#2022-04-06">https://betterprogramming.pub/deep-dive-into-concurrency-of-go-93002344d37b?source=collection_archive---------1-----------------------#2022-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4361" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在并发性方面最健壮的编程语言</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae79c391cfea74bdd15564d12a13bd70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d43GQk9pm6wNJO_KHt1-JA.jpeg"/></div></div></figure><p id="ab3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据StackOverflow开发者调查和<a class="ae lq" href="https://www.tiobe.com/tiobe-index/go/" rel="noopener ugc nofollow" target="_blank"> TIOBE </a>指数，Go(或Golang)已经获得了更多的关注，尤其是在后端开发者和从事基础设施自动化工作的DevOps团队中。这就有足够的理由来谈论Go和它处理并发性的聪明方法。</p><p id="4297" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go以其对并发性的一流支持而闻名，即一个程序同时处理多件事情的能力。随着计算机从更快地运行单个代码流转到同时运行更多的代码流，并发运行代码正成为编程中更关键的部分。</p><p id="54f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">程序员可以通过将程序设计成并发运行来使程序运行得更快，这样程序的每个部分都可以独立于其他部分运行。Go中的三个特性，goroutines、channels和selects，在结合在一起时使并发变得更加容易。</p><p id="2565" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Goroutines解决了在一个程序中运行并发代码的问题，通道解决了并发运行代码之间安全通信的问题。</p><p id="b429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">毫无疑问，Goroutines是Go的最佳功能之一！它们是非常轻量级的，不像操作系统线程，而是数百个Goroutines可以复用到一个操作系统线程上(Go有它的运行时调度程序),上下文切换的开销最小！简单地说，goroutines是线程上的轻量级和廉价的抽象。</p><p id="765c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是Go的并发方法是如何工作的呢？今天，我想试着向你们解释这一点。本文更关注Go的并发实体的编排，而不是这些实体本身。所以今天我们不会依赖太多的代码片段。</p><h1 id="896e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">运行时调度程序</h1><p id="a82f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">也就是说，它的工作是将可运行的goroutines (G)分布到运行在一个或多个处理器(P)上的多个worker OS线程(M)上。处理器正在处理多个线程。线程正在处理多个goroutines。处理器依赖于硬件；处理器的数量取决于CPU核心的数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/cb3346be58783bab9f767a9caaaebf98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dnvSnnFjELxn6rEioZa-jA.jpeg"/></div></div></figure><ul class=""><li id="9224" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><strong class="kw iu"> G </strong> = <strong class="kw iu"> </strong> Goroutine</li><li id="407c" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">M  =操作系统线程</li><li id="58ea" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">处理器</li></ul><p id="18c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个新的goroutine被创建，或者一个现有的goroutine变为可运行时，它被推到当前处理器的可运行go routine列表中。当处理器执行完一个goroutine时，它首先尝试从它的可运行goroutine列表中弹出一个go routine。如果列表是空的，处理器选择一个随机的处理器，并试图窃取一半的可运行的goroutines。</p><h1 id="947b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是Goroutine？</h1><p id="30ef" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Goroutines是与其他函数同时运行的函数。Goroutines可以被认为是OS线程之上的轻量级线程。与线程相比，创建一个Goroutine的成本很小。因此，Go应用程序同时运行数千个Goroutines是很常见的。</p><p id="9e16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Goroutines被复用到更少数量的OS线程。在一个有成千上万个goroutines的程序中，可能只有一个线程。如果该线程中的任何一个Goroutine阻塞说等待用户输入，那么就创建另一个OS线程，或者拉出一个暂停的(空闲的)线程，并将剩余的go routine移动到已创建的或未暂停的OS线程。所有这些都由Go的运行时调度程序负责。goroutine有三种状态:正在运行、可运行和不可运行。</p><h2 id="4e41" class="nd ls it bd lt ne nf dn lx ng nh dp mb ld ni nj md lh nk nl mf ll nm nn mh no bi translated">Goroutines与Threads</h2><p id="e0d6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为什么不像Go那样使用简单的操作系统线程呢？这是一个公平的问题。如上所述，Goroutines已经运行在OS线程之上。但区别在于多个Goroutines运行在单个OS线程上。</p><p id="40c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一个goroutine不需要太多内存，只需要2kB的堆栈空间。它们通过按需分配和释放堆存储来增长。相比之下，线程从一个大得多的空间开始，还有一个称为保护页的内存区域，作为一个线程的内存和另一个线程的内存之间的保护。</p><p id="4a78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Goroutines在运行时很容易创建和销毁，但是线程有很大的安装和拆卸成本；它必须向操作系统请求资源，并在完成后返回。</p><p id="86e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行时被分配了几个线程，所有的goroutines都在这些线程上被多路复用。在任何时间点，每个线程都将执行一个goroutine。如果该例程被阻塞(函数调用、系统调用、网络调用等)。)，它将被另一个将在该线程上执行的goroutine换出。</p><p id="6dd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，Go使用了Goroutines和Threads，这两者在并发执行函数的组合中是必不可少的。但是Go正在使用Goroutines，这使得Go成为了一种比它初看起来更好的编程语言。</p><h2 id="7be6" class="nd ls it bd lt ne nf dn lx ng nh dp mb ld ni nj md lh nk nl mf ll nm nn mh no bi translated">Goroutines队列</h2><p id="6197" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Go在两个层次上管理goroutines，本地队列和全局队列。本地队列附加到每个处理器，而全局队列是公共的。</p><p id="69ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只有当本地队列已满时，go routine才进入全局队列，并且当Go将Go routine列表注入调度器时，例如从网络轮询器或在垃圾收集期间休眠的Go routine，它们也被推入全局队列。</p><h1 id="80fa" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">偷窃作品</h1><p id="7bfd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当处理器没有任何Goroutines时，它会按顺序应用以下规则:</p><ul class=""><li id="b36b" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated">从自己的本地队列中提取工作</li><li id="0964" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">从网络轮询器提取工作</li><li id="e435" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">从另一个处理器的本地队列中窃取工作</li><li id="0d15" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated">从全局队列中提取工作</li></ul><p id="56b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于处理器可以在任务用完时从全局队列中取出工作，第一个可用的处理器将运行goroutine。这个行为解释了为什么一个goroutine在不同的P上运行，并展示了Go如何通过在资源空闲时让其他Go routine运行来优化系统。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/2ee13ecc213605e5084b252fc73744f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mvXwiCMLWi6pzAL34DkUg.jpeg"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">偷工减料图</p></figure><p id="c412" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个图表中，你可以看到P1用完了goroutines。因此，Go的运行时调度程序将从其他处理器获取goroutines。如果每隔一个处理器运行队列为空，它将检查来自网络轮询器的已完成IO请求(系统调用、网络请求)。如果这个网络轮询器为空，处理器将尝试从全局运行队列中获取goroutines。</p><h1 id="7397" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">运行并调试</h1><p id="863f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这个代码片段中，我们创建了20个goroutine函数。每个人都会休眠一秒钟，然后数到1e10 (10，000，000，000)。让我们通过将env设置为<code class="fe nu nv nw nx b">GODEBUG=schedtrace=1000</code>来调试Go调度程序。</p><h2 id="d6da" class="nd ls it bd lt ne nf dn lx ng nh dp mb ld ni nj md lh nk nl mf ll nm nn mh no bi translated">密码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="eb01" class="nd ls it bd lt ne nf dn lx ng nh dp mb ld ni nj md lh nk nl mf ll nm nn mh no bi translated">结果</h2><p id="3963" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">结果显示了全局队列中带有<code class="fe nu nv nw nx b">runqueue</code>的goroutines的数量，以及方括号<code class="fe nu nv nw nx b">[5 8 3 0]</code>中的本地队列(分别为<code class="fe nu nv nw nx b">P0</code>和<code class="fe nu nv nw nx b">P1</code>)。正如我们在grow属性中看到的，当本地队列达到256个等待goroutines时，下一个队列将会在全局队列中堆积。</p><ul class=""><li id="40b5" class="mp mq it kw b kx ky la lb ld mr lh ms ll mt lp mu mv mw mx bi translated"><code class="fe nu nv nw nx b">gomaxprocs</code>:配置的处理器</li><li id="b6f6" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><code class="fe nu nv nw nx b">idleprocs</code>:处理器未被使用。Goroutine跑步。</li><li id="8f8c" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><code class="fe nu nv nw nx b">threads</code>:线程正在使用中。</li><li id="6521" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><code class="fe nu nv nw nx b">idlethreads</code>:线程未被使用。</li><li id="a48b" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><code class="fe nu nv nw nx b">runqueue</code>:全局队列中的Goroutines。</li><li id="8c86" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><code class="fe nu nv nw nx b">[1 0 0 0]</code>:每个处理器的本地运行队列中的Goroutines。</li></ul><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="48d0" class="nd ls it nx b gy oe of l og oh">idleprocs=1 threads=6 idlethreads=0 runqueue=0 [1 0 0 0]<br/>idleprocs=2 threads=3 idlethreads=0 runqueue=0 [0 0 0 0]<br/>idleprocs=4 threads=9 idlethreads=2 runqueue=0 [0 0 0 0]<br/>idleprocs=0 threads=5 idlethreads=0 runqueue=0 [5 8 3 0]<br/>idleprocs=4 threads=9 idlethreads=2 runqueue=0 [0 0 0 0]<br/>idleprocs=0 threads=5 idlethreads=0 runqueue=8 [2 2 1 3]<br/>idleprocs=4 threads=9 idlethreads=2 runqueue=0 [0 0 0 0]<br/>idleprocs=0 threads=5 idlethreads=0 runqueue=10 [3 1 0 2]<br/>idleprocs=4 threads=9 idlethreads=2 runqueue=0 [0 0 0 0]<br/>idleprocs=0 threads=5 idlethreads=0 runqueue=9 [4 0 3 0]<br/>idleprocs=4 threads=9 idlethreads=2 runqueue=0 [0 0 0 0]<br/>idleprocs=0 threads=5 idlethreads=0 runqueue=10 [2 1 1 2]<br/>idleprocs=4 threads=9 idlethreads=2 runqueue=0 [0 0 0 0]<br/>idleprocs=0 threads=5 idlethreads=0 runqueue=6 [2 1 0 0]</span></pre><p id="8b59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读我关于Go并发性的文章。我希望你能学到一些新东西。</p><p id="f986" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><div class="kj kk kl km gt op"><a rel="noopener  ugc nofollow" target="_blank" href="/build-a-scalable-api-in-go-with-gin-131af7f780c0"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">在Go with Gin中构建可伸缩的API</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">使用Gin、GORM和Postgres在Go中创建可伸缩API的指南</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">better编程. pub</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>