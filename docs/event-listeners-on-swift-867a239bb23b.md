# 在 Swift 中构建事件监听器

> 原文：<https://betterprogramming.pub/event-listeners-on-swift-867a239bb23b>

## 如何在不增加保留周期的情况下在 iOS 上设计事件监听器

![](img/f8bb211d6c3af283099a03e43adb32cd.png)

李·坎贝尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片。

今天，我们将讨论如何创建一个基于事件监听器的实现。这种实现将是无保留周期的。我还将简要描述事件监听器是如何工作的，以及为什么我们在实现它们时必须关注保留周期。

# 事件侦听器概述

有时，您希望通知一个或多个对象某个事件已经发生。例如，可能是用户注销或登录了应用程序。这种事情可以通过使用委托轻松完成。一个对象实现一个协议，并成为用户身份验证状态的“监听器”。但是当不止一个对象想要监听用户 auth 状态时会发生什么呢？一个代表已经不够了。

每当我们想要传播一个事件已经发生在每个人身上的信息时，我们可以使用几种方法。其中之一是通知。工作起来就像一个广播，通知所有的类关于你的事件，你可能只需要实现一个函数来接收通知。它们的问题是，操作系统会通知基本上所有的类关于你的事件。有时候，我们不想这样，因为额外的努力根本没有被利用。

除了其他可能性之外，每当我必须将一个事件通知给多个类并且使用通知没有意义时，我会考虑一个折中的办法:通知多个委托，并将这些委托称为侦听器。

# 认证改变通知器

假设我有一个名为`AuthManager`的类。我会说这个类是单例的，这样我们的例子就不那么复杂了。`AuthManager`有几个功能，包括`logIn(username: String, password: String)`和`logout()`。这是使这些事件发生的大部分逻辑所涉及的地方。听起来`AuthManager`不太适合通知其他对象用户的 auth 状态已经改变。

我们可以想象我们可以要求`AuthManager`通知注册对象的授权状态的变化。要注册一个新对象，我们可以在`AuthManager`上调用一个函数，比如`addListener(_ listener: AuthChangeListener)`。什么是`AuthChangeListener`？这部分将像一个删除按钮。我们创建了一个协议，其中包含一些对监听者有用的方法。在这个简单的例子中，我们只有一个名为`authStateDidChange(isLogged: Bool)`的方法，我们将接收一个标志作为参数。此标志将指示用户是注销还是登录。

授权更改侦听器的协议。无论是谁实现这个协议，都可以注册为授权更改的监听器。

现在我们知道了我们的协议，让我们看看`addListener`的实现会是什么样子。

正如你在上面看到的，每当调用`addListener`时，我们就把那个监听器添加到我们保存在`AuthManager.` 中的监听器私有列表中，这很简单。每当 auth 状态发生变化时，我们只需迭代侦听器列表，调用`authStateDidChange`函数。

如果数组没有为它存储的对象保留一个强引用，这种方法将非常有效。我们正在创造一个保留周期。我们必须找到一种方法来保存一个引用，但是是一个弱引用。

# WeakReference 类

我在 kot Lin[的`WeakReference`中寻找灵感来创建一些东西，这些东西将保持我们对象的弱引用。我们也称它为`WeakReference`。它将在初始化器中接收一个值，这个值就是我们的对象。我们将把这个对象存储在一个弱变量中，如果它死了，就释放这个对象。这将完美地解决我们的问题。](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.ref/-weak-reference/index.html)

我们的解决方案简单易行，就像编码一样。现在就应用到我们的`AuthManager`上吧。

现在我们有了一个`AuthChangeListener`类型的`WeakReference`列表。当我们比较这个侦听器是否已经注册时，情况发生了变化:现在我们比较 value，它是由`WeakReference`类保存的实际侦听器。为了添加到列表中，我们创建了一个新的`WeakReference`，在初始化器中传递监听器。最后，当通知我们的 auth 状态发生变化时，我们只需检查对象，调用它的 value 属性。

# 僵尸

正如你所想象的，数组现在保留了一个对`WeakReference`的强引用，而不是我们的监听器对象。这是可以的，因为如果它们还活着，它不会对我们的记忆或者程序的行为产生大的影响。我喜欢做的一件事就是清理这些最终出现的僵尸`WeakReferences`。当通知更改或添加新的侦听器时，我会这样做。要移除所有僵尸，你只需从列表中移除所有值为`nil`的`WeakReferences`。

# 结论

我希望你喜欢这首曲子。如果您有任何问题或发现实现中的错误，请留下评论。