<html>
<head>
<title>The Downsides of Coding With Laravel Octane</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Laravel辛烷编码的缺点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-downsides-of-coding-with-laravel-octane-17f4a7a4ea85?source=collection_archive---------0-----------------------#2021-04-08">https://betterprogramming.pub/the-downsides-of-coding-with-laravel-octane-17f4a7a4ea85?source=collection_archive---------0-----------------------#2021-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3366" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不修改代码就不会有最高的性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f4261b1fb2d3eee2c8edfa013bd22624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tApaZ_oWEjTRhZFa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>拍摄的照片。</p></figure><p id="8a36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Laravel Octane是几周前宣布的<a class="ae kv" href="https://laravel-news.com/laravel-octane" rel="noopener ugc nofollow" target="_blank">,承诺在每秒处理的请求方面将框架推向月球。直到今天(beta版)</a><a class="ae kv" href="https://laravel-news.com/laravel-octane-beta" rel="noopener ugc nofollow" target="_blank">才公开给大家测试</a>，与第一方Laravel包兼容(如<a class="ae kv" href="https://nova.laravel.com/" rel="noopener ugc nofollow" target="_blank"> Nova </a>或<a class="ae kv" href="https://laravel.com/docs/8.x/telescope" rel="noopener ugc nofollow" target="_blank">望远镜</a>)开箱。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="5485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Laravel Octane推动边界的工作方式本质上很简单:它不是“启动”每个请求的应用程序，而是完全执行<em class="lu"/><strong class="ky ir"/>一次，并将其保存到内存的共享部分。一旦完成，Octane将产生多个PHP工作器，它们将接收这个共享的应用程序实例。这些进程同时处理多个请求，而不是一个。</p><p id="4f1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你们中的许多人所知，PHP本质上是一个单线程进程，即使在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/a-look-at-the-new-php-8-1-fibers-feature-979489399918"> PHP纤程</a>到来之后，它仍然是单线程进程。Laravel Octane不使用PHP纤程，但是它在一个定制的HTTP服务器上运行应用程序，对PHP有更严格的控制。对于后者，需要<a class="ae kv" href="https://roadrunner.dev/" rel="noopener ugc nofollow" target="_blank">走鹃</a>或<a class="ae kv" href="https://www.swoole.co.uk/" rel="noopener ugc nofollow" target="_blank"> Swoole </a>。</p><p id="cb8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">惊人的性能确实伴随着一些代码警告。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="8859" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">一个实例来统治他们</h1><p id="84b9" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">如果你解决了问题，你就太棒了。但是对于那些仍然迷路的人来说，这是它如何工作的一个非常简化的版本:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/d4925d100c6494191f6e0f92a3551f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMJ8QfLOpLBcZqojB6-bfg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个非常业余和简化的例子，如何拉韦勒辛烷工程</p></figure><p id="d0ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当服务器启动时，应用程序通过注册和引导所有服务来启动，甚至包括那些标记为“延迟”的服务，我们称之为“引导”然后，这个新实例在所有PHP工作人员之间共享。这与普通PHP进程的工作方式相反。通常，应用程序会在每次请求进入和响应发出时启动并销毁。</p><p id="bad5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将引用这篇关于Laravel Octane如何工作的<a class="ae kv" href="https://divinglaravel.com/laravel-octane-bootstrapping-the-application-and-handling-requests" rel="noopener ugc nofollow" target="_blank">精彩而广泛的潜水Laravel文章</a>——特别是应用程序和服务单件是如何分发的——这将立即清除您的思维:</p><blockquote class="na nb nc"><p id="6598" class="kw kx lu ky b kz la jr lb lc ld ju le nd lg lh li ne lk ll lm nf lo lp lq lr ij bi translated">容器中的绑定可以注册为单件，这些特殊的绑定在应用程序的生命周期中只解析一次。解析后的实例将存储在容器缓存中，相同的实例将在应用程序的生命周期中重用。</p><p id="a0c9" class="kw kx lu ky b kz la jr lb lc ld ju le nd lg lh li ne lk ll lm nf lo lp lq lr ij bi translated">(…)实例通过调用<code class="fe ng nh ni nj b">$app-&gt;resolve('singleton')</code>或<code class="fe ng nh ni nj b">$app-&gt;make('singleton')</code>来解析。因此，如果您在服务提供者的<code class="fe ng nh ni nj b">boot</code>或<code class="fe ng nh ni nj b">register</code>方法中<strong class="ky ir">解析</strong>任何单例，这些单例将持续存在。在处理请求时被解析的单例不会持久，当在Octane下运行时，它们会在每个请求上被构造。你不需要担心这些。"</p></blockquote><p id="c89d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为应用程序已经被引导了，所以应用程序以极快的速度工作，因为不需要再次引导。现在，想象一下恶作剧:一个服务单体将为来自任何人的所有请求保存相同的数据！<a class="ae kv" href="https://github.com/laravel/octane#dependency-injection--octane" rel="noopener ugc nofollow" target="_blank">这也适用于配置存储库和容器本身</a>。胡说。</p><p id="ae70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想破坏Laravel Octane，您甚至可以通过为每个请求将数据堆积到一个<code class="fe ng nh ni nj b">Class</code>静态属性中来进行简单的内存泄漏。</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="e733" class="no md iq nj b gy np nq l nr ns">MyLeaker::$pileUp = Str::random(100);</span></pre></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="a52b" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">牢记Laravel辛烷编码</h1><p id="3cd3" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">既然你知道它是如何工作的，那么就很容易理解应用程序作为一个整体，在所有请求的所有方面都是相同的。在引导中全局地改变状态将会在所有请求上反弹，除此之外，它将只对当前请求起作用。一旦请求发出，应用程序并不会死亡，而是会立即为下一个进入服务器的请求服务。</p><p id="dca4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住这一点，如果你打算用Laravel Octane创建一个应用程序或者创建一个承诺相同的包，这里是我的建议:</p><ul class=""><li id="311f" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated">如果你希望它们只被解析一次，并且在不同的请求中保持不变，那么注册单例是安全的。</li><li id="77dc" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">如果您希望从配置中获得不变性<strong class="ky ir"> </strong>，那么注入配置是安全的。</li><li id="603c" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">注入容器来解析在bootstrap中注册的服务是安全的，但不要添加或修改其中的内容并期望它持久化。</li><li id="66c4" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">总是尝试使用<code class="fe ng nh ni nj b">request()</code>外部控制器。</li><li id="3a50" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">永远不要使用静态属性。尽可能使用常数。</li></ul><p id="ef01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，引导时的应用程序状态不同于请求时的应用程序实例。此外，单例不应该直接绑定到请求。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="81be" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="c8a4" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">虽然Laravel Octane不会以任何方式造成破坏，但作为一名开发人员，您将不得不仔细检查您的依赖项是否存在Laravel Octane不兼容性——尤其是那些处理许多单例的依赖项。</p><p id="52cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为告诉开发者你的代码已经被修改，以便以非破坏性的方式使用Laravel Octane是很方便的。我甚至将我的储存库标记为“Laravel Octane Compatible ”,一旦修改，人们可以更快更安全地进入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/1c5cdace063e05c828250e39e949499c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LqddgUKR302saSbTPr6Pw.png"/></div></div></figure><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="684a" class="no md iq nj b gy np nq l nr ns">[![Laravel Octane Compatible](https://img.shields.io/badge/Laravel%20Octane-Compatible-success?style=flat&amp;logo=laravel)](<em class="lu">https://github.com/laravel/octane</em>)</span></pre><p id="6018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于其他方面，Laravel Octane不是必需的，因为许多应用程序瓶颈都与未优化的数据库查询、缓慢的会话存储或缓慢的外部API请求有关。像往常一样，对你的应用程序进行基准测试，检查速度慢的原因，因为Laravel Octane可能只会给你带来更多的头痛而不是解决方案。</p></div></div>    
</body>
</html>