<html>
<head>
<title>3 Ways to Implement the Singleton Pattern in TypeScript With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js在TypeScript中实现单例模式的3种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-ways-to-implement-the-singleton-pattern-in-typescript-with-node-js-75129f391c9b?source=collection_archive---------0-----------------------#2020-10-25">https://betterprogramming.pub/3-ways-to-implement-the-singleton-pattern-in-typescript-with-node-js-75129f391c9b?source=collection_archive---------0-----------------------#2020-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">选择最符合您需求的方式</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/6c91a5e0c090b68ffcea878b774d284c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWTl47NNOuj2nDIFKYe-TA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@shotsbywolf?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Geert Pieters </a>在<a class="ae kz" href="https://unsplash.com/s/photos/single-class?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="c591" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">单例模式是实现起来最简单的创造性设计模式之一。除了易于理解之外，它不需要写那么多行代码。</p><p id="587f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我的职业生涯中，我遇到过使用不同单体实现变体的代码。我认为在一篇文章中编译这些类型的实现会很棒，这样读者可以在他们未来的项目中使用它作为参考。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="edfc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">单人审查</h1><p id="ef14" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">让我们先快速回顾一下单例模式试图解决什么问题。单例模式用于维护一个对象的单个<em class="na">实例，而无需创建新的实例——即使该实例在我们应用程序的不同部分使用。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/47182ba14ef71ab063f5ab8e01014dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*-DMrn3qEm3_50IeVkXlT2A.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者的Singleton高层图。</p></figure><p id="29fe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种方法适用于您不想重复的对象实例化。实现的一些例子是日志记录、缓存和数据库连接。</p><p id="7ce4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我们将以日志记录为例。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7ba0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">问题—日志示例</h1><p id="2a99" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">这里有一个示例问题:我有一个用于支付处理的Node.js应用程序，它使用了一个<code class="fe nc nd ne nf b">Logger</code>类。在本例中，我们希望保留一个logger实例，并确保在整个支付应用程序中共享<code class="fe nc nd ne nf b">Logger</code>状态。为了简单起见，假设我们需要确保记录器需要跟踪应用程序中记录的消息总数。确保计数器在应用程序中被全局跟踪意味着我们需要一个单例类来实现这一点。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7a90d4a483aab415bf180a0be0f01451.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*7RGSs1aUf-0yMYzSymSG_w.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者给出的示例应用程序的高级示意图。</p></figure><p id="dfb5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们看一下我们将要使用的每个类。</p><h2 id="83b5" class="nh me it bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated">记录器类:Logger.ts</h2><p id="9832" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">一个基本的logger类，允许它的客户端记录带有时间戳的消息。它还允许客户端检索记录的消息总数。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="6622" class="nh me it bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated">付款类别:Payment.ts</h2><p id="7c11" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated"><code class="fe nc nd ne nf b">Payment</code>处理类处理付款。它记录付款实例化和付款处理:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="a353" class="nh me it bd mf ni nj dn mj nk nl dp mn lj nm nn mp ln no np mr lr nq nr mt ns bi translated">app的入口:index.ts</h2><p id="3e21" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">入口点创建一个<code class="fe nc nd ne nf b">Logger</code>类的实例并处理付款。它还通过<code class="fe nc nd ne nf b">Payment</code>类处理付款:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c7f9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们运行上面的代码，我们将得到以下输出:</p><pre class="kk kl km kn gt nv nf nw nx aw ny bi"><span id="2d56" class="nh me it nf b gy nz oa l ob oc"># Run the app<br/>tsc &amp;&amp; node dist/creational/singleton/problem/index.js</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi od"><img src="../Images/1c66da558cd656be2d619fe1861712c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*M5fCdVwhXr-xdDQRNkN1Ig.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者输出截图。</p></figure><p id="04c8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意，尽管显示了<code class="fe nc nd ne nf b">3</code>条记录的消息，日志计数仍停留在<code class="fe nc nd ne nf b">1</code>处。计数保持在<code class="fe nc nd ne nf b">1</code>，因为在<code class="fe nc nd ne nf b">index.ts</code>和<code class="fe nc nd ne nf b">Payment.ts</code>中分别创建了一个新的<code class="fe nc nd ne nf b">Logger</code>实例。这里的日志计数仅代表<code class="fe nc nd ne nf b">index.ts</code>中记录的内容。然而，我们还想在<code class="fe nc nd ne nf b">Payment</code>类中包含记录的消息数量。</p><p id="8bb6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是使用单例设计模式解决这个问题的不同方法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="68d5" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">GitHub存储库(可选)</h1><p id="b378" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">如果您想了解下面的TyepScript代码示例，我使用的代码可以在下面的GitHub存储库中找到:</p><div class="oe of gp gr og oh"><a href="https://github.com/ardydedase/dp-node-ts" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">ardydedase/dp-node-ts</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">在GitHub上创建一个帐户，为ardydedase/dp-node-ts开发做贡献。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kt oh"/></div></div></a></div><p id="e139" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">克隆一个本地副本或者直接在Gitpod中运行。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="71c3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案1:添加一个单独的单例类</h1><p id="600c" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">我们可以在<code class="fe nc nd ne nf b">Logger.ts</code>文件中添加一个<code class="fe nc nd ne nf b">Singleton</code>类。这里的解决方案是你标准的“从书本上拿来的”单例实现，在它自己的<code class="fe nc nd ne nf b">Singleton</code>类中。</p><p id="cdd5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们熟悉的<code class="fe nc nd ne nf b">getInstance()</code>方法确保了总有一个实例。您还会意识到TypeScript允许我们声明私有构造函数，保证没有其他方法来实例化<code class="fe nc nd ne nf b">Singleton</code>类。直接使用<code class="fe nc nd ne nf b">Logger</code> <em class="na"> </em>类<em class="na"> </em>而不使用<code class="fe nc nd ne nf b">Singleton</code>类可以绕过<code class="fe nc nd ne nf b">getInstance()</code>提供的singleton。我们可以在解决方案2中解决这个问题。</p><p id="df63" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe nc nd ne nf b">Logger.ts</code>文件现在看起来如下。注意添加到文件中的<code class="fe nc nd ne nf b">Singleton</code>类:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="61bd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe nc nd ne nf b">Singleton.getInstance()</code> <em class="na"> </em>实例化<code class="fe nc nd ne nf b">Logger</code>类并确保始终有一个实例:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f716" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面的代码显示了<code class="fe nc nd ne nf b">Payment</code>类如何使用<code class="fe nc nd ne nf b">Singleton</code>类:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7b87" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们运行<code class="fe nc nd ne nf b">index.ts</code>，我们将通过使用单例设计模式得到我们想要的结果:</p><pre class="kk kl km kn gt nv nf nw nx aw ny bi"><span id="e59c" class="nh me it nf b gy nz oa l ob oc"># Run the app<br/>tsc &amp;&amp; node dist/creational/singleton/separateClass/index.js</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/ca673df81a037891be11c4f49a3c9f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*s8LdC51aDfbPdaCbTodblw.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者输出截图。</p></figure><p id="a8d3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最终的日志计数是<code class="fe nc nd ne nf b">3</code>，这意味着我们的<code class="fe nc nd ne nf b">Singleton</code>类正在按预期工作。</p><p id="2394" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种方法简单方便。然而，创建一个新的类并不总是最好的解决方案。有时候，我们需要处理的类越少越好(如解决方案2所示)。</p><p id="1d73" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果已经有一个现有的类需要转换成singleton，我经常看到这种用法。与其修改<code class="fe nc nd ne nf b">Logger</code>类本身，不如创建一个单独的<code class="fe nc nd ne nf b">Singleton</code>类来调用现有的类。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1246" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案2:修改你想作为单例使用的类</h1><p id="c6eb" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">这里的方法是修改<code class="fe nc nd ne nf b">Logger</code>类，这样它就可以自己实现singleton，而不必编写另一个类。好处是没有办法绕过作为单例的类的实例化(不像解决方案#1)。</p><p id="3bae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们修改<code class="fe nc nd ne nf b">Logger</code>类，这样单体实例化就发生在类中:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="976b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是我们对解决方案#1所做的一些更改:</p><ul class=""><li id="37b2" class="ox oy it lc b ld le lg lh lj oz ln pa lr pb lv pc pd pe pf bi translated">我们已经将<code class="fe nc nd ne nf b">getInstance</code>方法移到了<code class="fe nc nd ne nf b">Logger</code>类中。</li><li id="419c" class="ox oy it lc b ld pg lg ph lj pi ln pj lr pk lv pc pd pe pf bi translated">我们已经将<code class="fe nc nd ne nf b">Logger</code>类的构造函数转换为private，使得该类的实例化只在该类中可用。</li></ul><p id="4bfb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们更新<code class="fe nc nd ne nf b">Payment</code>类以使用singleton <code class="fe nc nd ne nf b">Logger</code>类的<code class="fe nc nd ne nf b">getInstance</code>方法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e0be" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们更新入口点以使用singleton <code class="fe nc nd ne nf b">Logger</code>类的<code class="fe nc nd ne nf b">getInstance</code>方法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6879" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">运行应用程序将输出我们预期的结果，其中最终的日志计数是<code class="fe nc nd ne nf b">3</code>:</p><pre class="kk kl km kn gt nv nf nw nx aw ny bi"><span id="c82b" class="nh me it nf b gy nz oa l ob oc"># Run the app<br/>tsc &amp;&amp; node dist/creational/singleton/sameClass/index.js</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/ad1b2af47a842b72a4c5b1e21e67baa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*3FEsGiZKRxXe4-aWEudS8g.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者输出截图。</p></figure><p id="30b5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当您从一开始就确定您正在编写的类将是单例类时，请使用这种方法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="782a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解决方案3:最简单的方法——模块单件</h1><p id="bd05" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">对于这种方法，我们将利用节点模块像单例一样的行为。</p><p id="60cc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将在<code class="fe nc nd ne nf b">Logger.ts</code>文件中执行以下操作:</p><ul class=""><li id="c9b2" class="ox oy it lc b ld le lg lh lj oz ln pa lr pb lv pc pd pe pf bi translated">移除<code class="fe nc nd ne nf b">Logger</code>类中的<code class="fe nc nd ne nf b">getInstance</code>方法。</li><li id="4b16" class="ox oy it lc b ld pg lg ph lj pi ln pj lr pk lv pc pd pe pf bi translated">在<code class="fe nc nd ne nf b">Logger</code>类中公开构造函数。</li><li id="e28c" class="ox oy it lc b ld pg lg ph lj pi ln pj lr pk lv pc pd pe pf bi translated">导出<code class="fe nc nd ne nf b">Logger</code>类的一个新实例。</li></ul><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5afe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意我们是如何从以前的解决方案中找到这条捷径的。然后我们将从我们的<code class="fe nc nd ne nf b">Logger</code>类和<code class="fe nc nd ne nf b">index.ts</code>文件中导入这个单例类。</p><p id="9522" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从<code class="fe nc nd ne nf b">Payment</code>类导入<code class="fe nc nd ne nf b">Logger</code>单例类:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ace8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从入口点导入<code class="fe nc nd ne nf b">Logger</code>单例类:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="09ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">上面的代码应该和前面的解决方案有相同的结果，证明它是单例的。运行以下命令后:</p><pre class="kk kl km kn gt nv nf nw nx aw ny bi"><span id="d47b" class="nh me it nf b gy nz oa l ob oc"># Run the app<br/>tsc &amp;&amp; node dist/creational/singleton/simple/index.js</span></pre><p id="ee2f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们应该会看到以下输出:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/cc4e24fdd4a897852131bb35efa87a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Xa6BkfIv43yxu_V98rp3xg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者输出截图。</p></figure><p id="b4d2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="na">注意:</em> <a class="ae kz" href="https://medium.com/@maheshkumawat_83392/node-js-design-patterns-singleton-pattern-series-1-1e0ab71e3edf" rel="noopener"> <em class="na">在使用Node.js模块时，有一些注意事项</em> </a> <em class="na">需要注意，在这些模块中，并不总是保证单例性。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1c56" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="f3b8" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">如果您有一个想要转换成singleton的现有类，而不修改该现有类，那么解决方案#1通常是适用的。如果你正在编写一个新的类，并且你事先知道它将是一个单例类，那么解决方案#2是有效的。只要你知道不保证单例的注意事项，我会推荐解决方案#3。</p><p id="0b56" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">解决方案#1和#2要求我们编写更多的代码。然而，这两种解决方案都保证了单例性。</p></div></div>    
</body>
</html>