<html>
<head>
<title>How To Securely Implement Authentication in Single Page Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在单页面应用程序中安全地实现身份验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-securely-implement-authentication-in-single-page-applications-670534da746f?source=collection_archive---------0-----------------------#2019-12-17">https://betterprogramming.pub/how-to-securely-implement-authentication-in-single-page-applications-670534da746f?source=collection_archive---------0-----------------------#2019-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ef8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索OAuth、OpenID Connect及其常见的安全隐患</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fa0bf0b16da8e53588ed6f8ad6b68b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JYTUM-p14CcGcw6i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@jantined?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>拍摄的照片</p></figure><p id="f3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将重点讨论单页面应用程序中的身份验证。使用<a class="ae ky" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth </a>和<a class="ae ky" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID Connect (OIDC) </a>的正确流程是什么，在实现它时安全隐患在哪里？阅读完本文后，您应该能够为您的新应用程序正确地设计登录，并知道您当前的应用程序是否正在安全地使用OAuth/OIDC。</p><p id="cc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意:对于单页面应用程序来说是正确的，对于其他形式的应用程序来说不一定是正确的，比如移动应用程序或经典的web应用程序(老派，嘘！).这里描述的一些概念仍然适用于这些类型的应用程序，其他的可能是错误的，甚至是不安全的。因此，请务必小心，始终确保将正确的概念应用到正确的应用中。</p><p id="4de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是关于这个主题的一系列文章中的第一篇。在这里，我想为理解OAuth和OIDC的必要部分打下基础，并概述导致某些架构决策的安全考虑。在后续文章中，我将使用不同的授权服务器提供者实现示例，并讨论它们之间的差异。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5f45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单页应用程序</h1><p id="2b94" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">单页面应用程序通常将所有的业务逻辑打包在用<a class="ae ky" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae ky" href="https://vuejs.org" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>、<a class="ae ky" href="https://angular.io" rel="noopener ugc nofollow" target="_blank"> Angular </a>或类似语言编写的JavaScript前端部分中，并从后端API加载必要的数据。为了保护后端数据免受未经授权的访问，这些应用程序要求用户通过单独的授权服务器进行身份验证，并在成功登录后获得一个令牌。然后在调用后端时可以使用这个令牌，API可以在后端验证令牌的有效性，从而验证调用用户的真实性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/1441f200cdb698cf2b49a5066974592a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Od6StPj_Uhcct7lac5OjiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单页应用程序的基本设置</p></figure><p id="ccaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">授权服务器可以完全自行开发，也可以使用现有的第三方解决方案(如<a class="ae ky" href="https://www.keycloak.org" rel="noopener ugc nofollow" target="_blank"> Keycloak </a>)自行托管。第三种选择是使用认证即服务提供商，最受欢迎的选择是<a class="ae ky" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>和<a class="ae ky" href="https://www.okta.com" rel="noopener ugc nofollow" target="_blank"> Okta </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bf7a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">OAuth和OpenID连接</h1><p id="1c78" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所有这些认证和授权选项将或多或少地实现一套完整的<a class="ae ky" href="https://tools.ietf.org/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> OAuth v2 </a>和<a class="ae ky" href="https://openid.net/specs/openid-connect-core-1_0.html" rel="noopener ugc nofollow" target="_blank"> OpenID Connect 1.0 </a>规范。OAuth首先出现，并定义了本文中描述的大部分授权过程。这包括授权流、授权访问令牌的使用，以及实现和使用这些机制时的安全性考虑。OAuth的问题在于，它被设计成<em class="na">授权</em>(证明用户被允许执行某个动作)持有适当访问令牌的任何人访问API等资源。然而，这并不允许API基于该信息对用户进行认证(以证明请求用户确实是他们所声称的那个人)。输入OpenID Connect。</p><p id="ea5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OpenID Connect (OIDC)在OAuth之上添加了一个身份验证层，并定义了一个可以传递给应用程序的ID令牌。该ID令牌具有允许应用程序唯一标识用户的信息，并且由授权服务器额外签名。OIDC还对OAuth定义的授权流做了一些调整，并引入了<a class="ae ky" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> JSON Web Tokens (JWT) </a>作为交换信息的默认格式(例如在ID令牌中)。如今，OAuth和OpenID Connect交织得如此之深，以至于经常很难理解哪个部分属于哪个规范。在大多数真实的用例中，这种区别是不必要的，只要您理解如何安全地结合使用这两种标准。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc6f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">证明</h1><p id="2f9e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当谈到web应用程序中的身份验证时，开发人员的脑海中会立即跳转到登录<strong class="lb iu"> </strong>页面，用户在这里输入他们的用户名和密码，以证明他们确实是他们所声称的那个人。虽然这肯定是它最重要的方面，并且我们将在这篇文章的大部分时间里讨论这个主题，但是另外两个方面也需要解决:会话刷新和注销。</p><p id="f214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会话刷新是指在当前令牌过期时为用户获取新令牌的过程。这个特性对于用户体验至关重要——理想情况下，它让用户不必每隔一小时输入一次密码。现代web应用程序的用户习惯于在首次登录应用程序后很长时间内不必输入密码。想想看:你上一次在使用脸书的网络应用程序时输入密码是什么时候？可能不会很久，除非你换了浏览器或电脑。</p><p id="5fa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果用户想要结束会话，web应用程序还应该为用户提供显式注销的可能性。虽然这不是一个会被频繁使用的特性，但它仍然很重要。假设一个用户想要在同一个应用程序中使用两个帐户用于不同的目的。我自己使用两个GitHub账户已经有一段时间了，一个用于我的工作邮箱，另一个用于私人项目。要切换账号，我先注销一个，然后再登录另一个(不要告诉Github，他们好像不喜欢这样)。</p><p id="94eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，用户只是想注销您的应用程序，因为他们使用的是共享电脑，不想让其他人使用该帐户。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">注册</h1><p id="9dff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">自2019年初以来，OAuth工作组一直在<a class="ae ky" href="https://mailarchive.ietf.org/arch/browse/oauth/?gbt=1&amp;index=6yWC59HcsIx4VWNOPb2FWNUUlUs" rel="noopener ugc nofollow" target="_blank">讨论</a>现代浏览器中spa的新建议。这导致了一个<a class="ae ky" href="https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-04" rel="noopener ugc nofollow" target="_blank">草案</a>，它总结了当前所有针对spa(或者他们称之为基于浏览器的应用)的安全最佳实践。这个和另一个重要的当前<a class="ae ky" href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13" rel="noopener ugc nofollow" target="_blank">草案文档</a>是关于浏览器应用中OAuth的安全考虑，是这篇文章大部分的基础。<br/> <br/>这些出版物的关键部分之一涵盖了将<a class="ae ky" href="https://oauth.net/2/grant-types/authorization-code/" rel="noopener ugc nofollow" target="_blank">授权代码流</a>与<a class="ae ky" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> PKCE </a>(发音:pixie)一起用于单页应用程序。在理解这篇文章中的概念时，理解这个流程已经让你离终点很近了。那么，让我们看看它是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><ol class=""><li id="3abd" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">用户单击客户端应用程序中的登录按钮。</li><li id="0e7a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">客户端应用程序生成一个名为代码验证器的<a class="ae ky" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" rel="noopener ugc nofollow" target="_blank">加密随机</a>一次性密钥，对其进行哈希处理(结果称为代码挑战)并存储两个值。</li><li id="c903" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">客户端应用程序生成另一个称为状态参数的加密随机一次性密钥并存储它。</li><li id="74ab" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">客户端应用程序将用户的浏览器重定向到授权服务器。重定向请求包含代码质询(哈希值)、重定向目标和状态作为URL参数。</li><li id="1376" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">授权服务器显示登录表单，用户输入他们的用户名和密码。</li><li id="a3f0" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">授权服务器验证用户名和密码，并在成功时生成加密随机授权码，并存储该密码挑战。</li><li id="00f6" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">授权服务器将用户的浏览器重定向回应用程序。重定向包含授权码和状态参数。</li><li id="ae91" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">客户端应用程序将存储的状态值与授权服务器返回的状态值进行比较。</li><li id="4258" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">通过XHR邮政请求，客户端应用程序将授权代码和代码验证器发送到授权服务器。</li><li id="57e1" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">授权服务器验证授权代码和代码验证器。后者通过对其进行哈希运算，然后将其与存储的密码挑战进行比较来验证。</li><li id="89b0" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">成功时，授权服务器用访问令牌和ID令牌进行响应。</li><li id="c78d" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">客户端应用程序将两个令牌都存储在内存中。</li></ol><p id="6ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些步骤之后，客户端应用程序已经获得了必要的令牌来调用API并从那里加载数据。很简单，对吧？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0de6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重定向保护</h1><p id="c45f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上述授权代码流中的一个关键步骤是从授权服务器重定向回客户端应用程序。重定向目标在原始请求中传递给授权服务器，在执行重定向之前，授权服务器必须仔细验证目标。如果攻击者能够操纵重定向目标参数或模拟它，他们就可能窃取授权代码，或者在最坏的情况下，甚至获得受害用户的令牌。</p><p id="6e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这类攻击，授权服务器必须只允许URL的显式白名单作为重定向目标。URL必须用协议和路径完全限定，而不能使用正则表达式、通配符或白名单域。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="25d9" class="nw md it ns b gy nx ny l nz oa">// good redirect target<br/><a class="ae ky" href="https://www.allthingsauth.dev/callback" rel="noopener ugc nofollow" target="_blank">https://www.allthingsauth.dev/callback</a></span><span id="7911" class="nw md it ns b gy ob ny l nz oa">// bad redirect target<br/>*.allthingsauth.dev/*</span></pre><p id="2753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在授权代码流中，我们还使用了PKCE，这是为了避免在重定向步骤中发送访问令牌。相反，它在POST请求中用授权码交换访问令牌。这个POST请求受到在<a class="ae ky" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> PKCE </a>扩展中指定的代码挑战和验证器值的保护。在重定向的URL中发送访问令牌会增加攻击面，因为它可能被窃取或无意中泄露，例如在浏览器历史记录、浏览器内扩展或通过SSL端接代理。这些问题存在于旧的<a class="ae ky" href="https://oauth.net/2/grant-types/implicit/" rel="noopener ugc nofollow" target="_blank">隐式流</a>中，但是现在通过授权代码流和PKCE得到了解决。</p><h2 id="0ebc" class="nw md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">SSL / TLS</h2><p id="56df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如今，用<a class="ae ky" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> TLS </a>(以前称为SSL)来保护你的应用程序是绝对必要的。当用户的数据从浏览器发送到服务器时，它会保护用户的数据，并帮助浏览器确保应用程序试图与之对话的服务器确实是它所声称的那个服务器。对于单页面应用程序设置，如上所述，这意味着您的所有主机都需要TLS证书:托管客户端应用程序的服务器、API服务器和授权服务器。</p><p id="d83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中描述的OAuth的大多数安全性考虑都严重依赖于TLS提供的安全性。没有TLS，您甚至不应该开始担心身份验证，而是去获得TLS证书。幸运的是，如今通过<a class="ae ky" href="https://letsencrypt.org" rel="noopener ugc nofollow" target="_blank"> Let's Encrypt </a>，通过<a class="ae ky" href="https://aws.amazon.com/certificate-manager/pricing/" rel="noopener ugc nofollow" target="_blank"> AWS </a>中的托管DNS zone，甚至通过<a class="ae ky" href="https://help.github.com/en/github/working-with-github-pages/securing-your-github-pages-site-with-https" rel="noopener ugc nofollow" target="_blank"> GitHub Pages </a>托管你的个人博客，为你的网站获取它既容易又便宜。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7693" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">令牌存储</h1><p id="6c18" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从我们的auth服务器获得一个访问令牌(可能还有一个ID令牌)后，问题就出现了:我们究竟应该把这个令牌存储在哪里，以便可以在API调用中进一步访问它，但它仍然尽可能地免受攻击？我想到了三个可能的选择:</p><ul class=""><li id="c1f2" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu on nj nk nl bi translated">饼干</li><li id="27a8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu on nj nk nl bi translated">HTML5存储(本地存储或会话存储)</li><li id="818a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu on nj nk nl bi translated">在JavaScript对象的内存中</li></ul><p id="bcb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这些选项中，cookies是最不可取的解决方案。为了能够在进一步的JavaScript逻辑中使用令牌，cookie必须在没有<code class="fe oo op oq ns b">httpOnly</code>标志的情况下存储。不幸的是，这也使他们很容易成为<a class="ae ky" href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)" rel="noopener ugc nofollow" target="_blank">跨站脚本(XSS) </a>攻击的目标。此外，在某些情况下，令牌可能容易受到<a class="ae ky" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" rel="noopener ugc nofollow" target="_blank"> CSRF攻击</a>。</p><p id="0822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oo op oq ns b">LocalStorage</code>和<code class="fe oo op oq ns b">sessionStorage</code>是相似的:两者都是键值存储，可以通过JavaScript访问。两者之间唯一的区别是在页面会话结束后<code class="fe oo op oq ns b">sessionStorage</code>被清除，而<code class="fe oo op oq ns b">localStorage</code>被保留。这个特性使得localStorage不适合存储令牌。不幸的是，当标签或浏览器关闭时，<code class="fe oo op oq ns b">sessionStorage</code>通常不会被完全清除，因为现代浏览器支持在浏览器关闭后重新打开标签或恢复会话。这是根据<a class="ae ky" href="https://html.spec.whatwg.org/multipage/webstorage.html#the-sessionstorage-attribute" rel="noopener ugc nofollow" target="_blank">规范</a>制定的，但并不一定会让我们的生活变得更轻松。这两种HTML5存储机制都可以通过JavaScript读取，因此很容易被XSS攻击。</p><p id="25f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得在内存中的JavaScript对象中存储访问和ID标记成为最佳解决方案。它提供了针对XSS攻击的最佳保护——在XSS攻击中注入的内联脚本限制了对应用程序其余部分的对象范围的访问。这当然取决于所使用的框架和对象的实现方式。但是这会让我们走得太远，并将成为未来文章的素材。当页面或选项卡关闭时，内存中的对象也会被破坏，即使选项卡重新打开功能也无法恢复该对象。这种情况甚至会在简单的页面重新加载时破坏对象(<code class="fe oo op oq ns b">sessionStorage</code>在页面重新加载后仍然存在)。这给用户带来了不便，但应该可以通过良好的会话刷新机制来解决，如下所述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/0f3ec45e4e9d4b89e548d7888f1ab854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIUiR5AQinXvKf6lK2ri9Q.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="16dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">跨站点脚本保护</h1><p id="4f76" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当用户的令牌存储在浏览器中时，它们容易受到<a class="ae ky" href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)" rel="noopener ugc nofollow" target="_blank">跨站点脚本(XSS) </a>攻击，攻击者在受害者的浏览器中执行恶意的JavaScript代码。如果攻击者在您的应用程序中发现这样的漏洞，他们将能够窃取受害者的令牌，并因此访问受害者的帐户。我们如何防止这种情况发生？</p><p id="1875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在单页面应用程序的世界里，现在大多数框架都有内置的机制来防止XSS攻击。对于<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks" rel="noopener ugc nofollow" target="_blank">反应</a>、<a class="ae ky" href="https://vuejs.org/v2/guide/security.html#HTML-content" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>、<a class="ae ky" href="https://angular.io/guide/security#xss" rel="noopener ugc nofollow" target="_blank">角度</a>都是如此。如果你坚持这些原则，你的应用程序应该是安全的。不幸的是，历史上XSS漏洞经常是通过第三方库<a class="ae ky" href="https://snyk.io/vuln/npm:handlebars:20151207" rel="noopener ugc nofollow" target="_blank"/>引入<a class="ae ky" href="https://snyk.io/vuln/npm:react-dom:20180802" rel="noopener ugc nofollow" target="_blank"/><a class="ae ky" href="https://sqreen.github.io/VueXSSDemo/#/vux" rel="noopener ugc nofollow" target="_blank">。在您的应用程序中防止这些问题要困难得多，但是使用一个可靠的工具检查您的第三方库中已知的漏洞是可以做到的。从个人经验来说，我可以推荐</a><a class="ae ky" href="https://snyk.io/test/" rel="noopener ugc nofollow" target="_blank"> snyk.io </a>或者<a class="ae ky" href="https://jeremylong.github.io/DependencyCheck/" rel="noopener ugc nofollow" target="_blank"> OWASP依赖检查器</a>。</p><p id="7796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一条抵御XSS攻击的好防线是内容安全策略(CSP)。通过正确的设置，这可以非常有效地减少跨站点脚本:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="53f1" class="nw md it ns b gy nx ny l nz oa">Content-Security-Policy: default-src ‘none’; script-src ‘self’; style-src ‘self’ cdn.example.com; connect-src ‘self’</span></pre><p id="c23f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在单页面应用程序和身份验证的上下文中讨论这个标题的所有细节很容易成为另一篇文章的素材。也许过会儿。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec07" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">CSRF保护</h1><p id="3a33" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用授权代码流执行身份验证时，我们需要保护我们的用户免受<a class="ae ky" href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" rel="noopener ugc nofollow" target="_blank"> CSRF攻击</a>，攻击者可以欺骗受害者授权登录请求。</p><p id="885d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种攻击，我们手头有两种机制:PKCE扩展和状态参数。前者确保启动授权代码流的客户端应用程序与稍后用授权代码交换令牌的应用程序是同一个应用程序。这可以防止CSRF攻击，因为攻击者无法在第二次请求中提供代码验证值，所以授权服务器可以识别攻击。</p><p id="1dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，PKCE扩展足以防止CSRF攻击，但它只给授权服务器检测攻击的机会。使用state参数，客户端应用程序也可以检测到CSRF攻击并停止身份验证过程。这是可能的，因为客户端应用程序随机选择状态参数值，然后将其与服务器响应中的值进行比较。因此，对CSRF保护同时使用PKCE扩展和状态参数是一种很好的做法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6d77" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">会话刷新</h1><p id="b3cd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当用户的当前访问令牌过期时，我们需要一种方法来更新它。为了避免要求用户再次输入密码，我们必须使用另一个已经存储在浏览器中的密码。我经常看到的方法是使用刷新令牌，将另一个令牌与访问和ID令牌一起存储在客户端应用程序中。这个刷新令牌通常是长期有效的，并且可以在授权服务器上交换一个新的访问令牌。这种方法的优点是它在最初的<a class="ae ky" href="https://tools.ietf.org/html/rfc6749#section-10.4" rel="noopener ugc nofollow" target="_blank"> OAuth规范</a>中有描述，因此被大多数授权服务器实现所支持。</p><blockquote class="os"><p id="52e4" class="ot ou it bd ov ow ox oy oz pa pb lu dk translated">更新令牌，还是不更新令牌，这是一个问题。</p></blockquote><p id="02d4" class="pw-post-body-paragraph kz la it lb b lc pc ju le lf pd jx lh li pe lk ll lm pf lo lp lq pg ls lt lu im bi translated">刷新令牌的一大缺点是它们必须持久存储在客户端应用程序中。正如我们所知，在浏览器中，这只能通过非会话cookies或<code class="fe oo op oq ns b">localStorage</code>来实现，而这两种选项本质上都是不安全的，因为它们容易受到针对客户端应用程序的XSS攻击。此外，如果攻击者窃取了这样的刷新令牌，他们基本上可以创建任意多的访问令牌，并接管帐户。刷新令牌几乎和密码本身一样强大，你也不会将它存储在浏览器中，对吗？尽管最初的OAuth规范允许在基于浏览器的应用程序中使用刷新令牌，但主要的身份验证即服务提供商(Auth0和Okta)选择不允许单页面应用程序使用刷新令牌流，以保护他们的用户。</p><p id="9594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个单页面应用程序决定冒这个险，向他们的用户提供刷新令牌，那么必须采取<a class="ae ky" href="https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-04#section-8" rel="noopener ugc nofollow" target="_blank">特殊的</a> <a class="ae ky" href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-4.12" rel="noopener ugc nofollow" target="_blank">预防措施</a>。刷新令牌必须仅供单次使用，这意味着在刷新令牌被用来获得新的访问令牌之后，还必须授予新的刷新令牌，并且旧的刷新令牌必须被无效。刷新令牌还必须有一个过期时间，无论令牌是否已被使用，或者新令牌是否已被重复颁发，都会强制执行该时间。如果第一个刷新令牌在一周内有效，即使用户保持每小时生成新的访问和刷新令牌，当前活动的刷新令牌的有效期也不能长于最初的一周。这意味着刷新令牌的有效期将随着时间的推移而变短。</p><p id="bf5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在再读一遍最后一段，每读一次<em class="na">刷新令牌这个词就拍一张！</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不可见刷新</h1><p id="7d83" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一种应该被认为更安全，并且至少对用户友好的方法是不可见的(或者无声的)刷新。这个过程不是OIDC官方规范的一部分，但是像Auth0或Okta这样的大型身份验证即服务提供商支持它。不可见的会话刷新利用了这样一个事实，即当用户最初输入他们的用户名和密码时，一个会话cookie存储在授权服务器上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/a3234cd3a044be6cbe79f544b1443be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QeLovJoTk5V82X2gswJ5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单页应用程序的不可见会话刷新</p></figure><p id="5bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在现代浏览器中启动不可见的刷新，客户端应用程序打开一个不可见的iframe(通过将其宽度和高度设置为0 ),并在其源中加载授权服务器的URL。URL包含<code class="fe oo op oq ns b">prompt=none</code>参数，该参数告诉授权服务器<a class="ae ky" href="https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest" rel="noopener ugc nofollow" target="_blank">不要与浏览器进行任何交互</a>。此外，它通常包含一个特定于供应商的URL参数，该参数告诉授权服务器通过web消息进行响应(例如Auth0中的<code class="fe oo op oq ns b">response_mode=web_message</code>)。这样，授权服务器将通过检查用户与授权服务器的会话是否仍然有效来检查它是否可以静默地对用户进行身份验证。这是可能的，因为根据HTTP标准，iframe触发的请求将自动包含用户与授权服务器的会话cookie。</p><p id="5b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果认证成功，授权服务器将<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" rel="noopener ugc nofollow" target="_blank">向包含授权码的父窗口发送</a>一条<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent" rel="noopener ugc nofollow" target="_blank">网络消息</a>。父窗口(客户端应用程序)将侦听消息，提取授权码，然后执行PKCE流。在此之后，客户端应用程序将拥有一个新的令牌，整个过程对用户来说是完全不可见的。</p><p id="bf05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种不可见刷新的安全性主要依赖于现代浏览器中web消息传递标准的安全性和授权服务器上的会话cookie。因为cookie只在传统的浏览器发起的HTTPs请求中发送(不是通过JS发起的XHR请求)，所以会话cookie可以使用所有可用的cookie保护机制:<code class="fe oo op oq ns b">httpOnly</code>、<code class="fe oo op oq ns b">secure</code>和<code class="fe oo op oq ns b">sameSite</code>标志。总的来说，在我看来，这种方法远远优于基于刷新令牌的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a99" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过重定向刷新</h1><p id="1934" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果由于某种原因无法进行不可见的刷新，后备解决方案可以是在访问令牌过期时通过浏览器重定向到授权服务器进行刷新。如果这是用<code class="fe oo op oq ns b">prompt=none</code>标志执行的，授权服务器将检查用户的会话cookie，类似于静默刷新。如果会话仍然有效，它将使用授权码重定向回客户端应用程序，而无需用户交互。</p><p id="3df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法具有良好的安全属性，因为与静默刷新类似，它也依赖于授权服务器的会话cookie的安全性。缺点是将执行完整的页面重新加载，尽管用户不必与授权服务器交互，但它在浏览器中是可见的，因为两个重定向将连续发生。页面重载的另一个负面影响是单页面应用程序中的状态丢失。这种效果的影响取决于应用程序的性质以及重定向后它能以多快的速度重新加载。良好的缓存和其他性能增强器，如web workers或服务器端渲染，可以改善体验。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1bd7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">注销</h1><p id="07d0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当用户通过点击客户端应用程序中的相应按钮发起注销时，需要发生两件事情:必须通知授权服务器，并且必须从客户端应用程序中删除任何令牌。有趣的是，OAuth和OIDC规范都没有描述如何处理这样的注销。在大多数情况下，简单地重定向到授权服务器的注销端点(例如在Auth0的情况下是<code class="fe oo op oq ns b">/v2/logout</code>)就足够了。这将触发授权服务器终止用户会话，并从用户浏览器中删除其会话cookies。之后，将发生重定向回应用程序—通过完成这个重定向周期，客户端应用程序将丢失其状态，并且存储在内存中的任何令牌都将被自动删除。如果令牌存储在其他位置，比如<code class="fe oo op oq ns b">sessionStorage</code>，那么这些令牌必须在重定向之前被明确删除。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="48f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！如果您已经学了这么多，现在您应该知道PKCE的身份验证代码流如何用于单页面应用程序，以及哪些部分对于使用它的应用程序的安全性很重要。如果你像我一样，现在渴望在这么多理论之后看到并编写一些实际的代码，请继续关注下一部分，我将在真实的场景中实现所有这些。</p></div></div>    
</body>
</html>