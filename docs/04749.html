<html>
<head>
<title>WebSockets in Swift Using URLSession’s WebSocketTask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用URLSession的WebSocketTask的Swift中的WebSockets</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/websockets-in-swift-using-urlsessions-websockettask-bc372c47a7b3?source=collection_archive---------3-----------------------#2020-05-06">https://betterprogramming.pub/websockets-in-swift-using-urlsessions-websockettask-bc372c47a7b3?source=collection_archive---------3-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8795" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有第三方库的WebSockets</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8be875fbeb648e21d176d4e58bc9d918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yvUdXeF6SphOdMAB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@marvelous?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marvin Meyer </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="39d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WebSockets允许在不同方之间建立非常快速的双向安全网络连接。这不同于HTTP协议，仅在我们需要实时更新时使用。例如，您使用的所有聊天应用程序都是使用WebSockets构建的。使用相同的协议显示股票市场更新。</p><p id="8ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简单地使用URL连接到一个<code class="fe lv lw lx ly b">WebSocket</code>频道，并可以监听来自该频道的所有更新。例如，如果我们连接到某个特定实体的股票频道，我们将会收到关于该股票价格的及时更新。我们可以随时关闭连接。</p><p id="346c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不止一个客户端可以连接到一个<code class="fe lv lw lx ly b">WebSocket</code>通道，WebSockets的职责是向所有连接到它的客户端发送更新。</p><p id="82dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试WebSocket连接，我们使用了两个不同的术语:<code class="fe lv lw lx ly b">PING</code>和<code class="fe lv lw lx ly b">PONG</code>。客户端将向WebSocket URL发送一个<code class="fe lv lw lx ly b">PING</code>，作为响应，通道将向客户端发回一个<code class="fe lv lw lx ly b">PONG</code>。这个循环建立了客户和渠道之间的持续连接。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f6ae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">iOS中的WebSockets</h1><p id="6461" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">直到iOS 12，还没有对WebSockets的第一手支持，尽管我们可以在我们的项目中使用第三方库来使用WebSockets。最常见的开源库之一是<a class="ae ky" href="https://github.com/daltoniam/Starscream" rel="noopener ugc nofollow" target="_blank">红蜘蛛</a>。</p><p id="44d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看看文档，如果你愿意，在你的应用程序中支持iOS 12或以前的iOS版本。但是在本文中，我们将了解iOS库中用于直接处理WebSockets的新功能。</p><p id="0425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从创建一个新的空操场开始(所有这些在Xcode项目中也会起作用)。</p><h2 id="a12a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">URLSessionWebSocketDelegate</h2><p id="186f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">该协议包含两种不同的方法，可用于检查我们是否建立了与通道的连接或断开了通道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经创建了一个类<code class="fe lv lw lx ly b">WebSocket</code>，它将符合<code class="fe lv lw lx ly b">URLSessionWebSocketDelegate</code>协议。</p><p id="36da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个协议有两个我们将使用的方法:第一个方法在客户端与通道建立连接时调用，第二个方法在客户端与通道断开连接时调用。每当我们的客户机与web socket通道连接或断开时，我们将简单地打印出<code class="fe lv lw lx ly b">Web Socket did connect</code>和<code class="fe lv lw lx ly b">Web Socket did disconnect</code>。</p><h2 id="f66e" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">建立连接</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="567e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使用<code class="fe lv lw lx ly b">URLSession</code>创建了一个具有<code class="fe lv lw lx ly b">default</code>配置的<code class="fe lv lw lx ly b">session</code>，我们的<code class="fe lv lw lx ly b">WebSocket</code>类作为代理，以及<code class="fe lv lw lx ly b">OperationQueue</code>。我们使用了一个免费的<code class="fe lv lw lx ly b">WebSocket</code>频道网址<code class="fe lv lw lx ly b">wss://echo.websocket.org</code>。任何人都可以使用WebSockets发送和接收消息。</p><p id="80f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS 13在<code class="fe lv lw lx ly b">URLSession</code>中有一个名为<code class="fe lv lw lx ly b">webSocketTask</code>的新任务——它主要用于创建一个使用给定URL连接到<code class="fe lv lw lx ly b">WebSocket</code>频道的任务。在最后一行，我们简单地<code class="fe lv lw lx ly b">resume()</code>了WebSocket任务，这样我们就可以与通道建立连接。</p><p id="9714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe lv lw lx ly b">webSocketTask.resume()</code>后，我们将与通道建立连接，我们的委托方法将被调用。请记住，我们使用了两个委托方法，这次我们建立了一个通道，因此将调用第一个方法。它将在调试控制台中打印出<code class="fe lv lw lx ly b">Web Socket did connect</code>。</p><h2 id="c510" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">乒乓球</h2><p id="82e7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">建立连接后，及时检查我们的连接是否仍然建立是一个非常好的做法。这可以通过向通道发送一个<code class="fe lv lw lx ly b">PING</code>来完成，作为响应，通道将向我们发回一个<code class="fe lv lw lx ly b">PONG</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经创建了一个新方法，<code class="fe lv lw lx ly b">ping</code>，它将用于每五秒钟测试一次我们与通道的连接。</p><p id="81b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">webSocketTask</code>为我们提供了<code class="fe lv lw lx ly b">sendPing</code>，它会自动向频道URL发送一个<code class="fe lv lw lx ly b">ping</code>，如果我们没有从频道收到一个<code class="fe lv lw lx ly b">PONG</code>返回，它会给我们一个带有错误的响应。我们只是打印出错误，以防我们的连接不再建立。在生产中，如果由于某种原因丢失了连接，我们可以使用它来再次创建连接。</p><p id="b271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们成功地从通道接收到一个<code class="fe lv lw lx ly b">PONG</code>，我们在五秒钟后使用全局队列再次调用<code class="fe lv lw lx ly b">ping</code>方法。这将确保我们每五秒钟检查一次连接，如果连接断开，我们将打印错误并停止。</p><p id="019e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好的做法是一旦连接建立就开始ping通道，所以我们将从一个在连接建立后调用的委托方法中调用<code class="fe lv lw lx ly b">ping</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="ba0a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">关闭连接</h2><p id="8713" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">出于某种原因，如果我们希望在我们的应用程序进入后台或用户关闭应用程序时关闭连接，那么从客户端关闭连接并通知通道此连接关闭的原因是一个好的做法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="83d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先创建一个<code class="fe lv lw lx ly b">reason</code>字符串并将其转换为<code class="fe lv lw lx ly b">Data</code>，然后我们将简单地调用<code class="fe lv lw lx ly b">cancel</code>，提供我们刚刚创建的原因。这将简单地关闭我们与通道的连接。</p><h2 id="21ff" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">发送/接收消息</h2><p id="c464" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用WebSockets发送和接收消息的最重要部分来了。由于我们使用的是示例通道<code class="fe lv lw lx ly b">WebSocket</code>，我们自己必须发送和接收相同的消息。但是在现实世界中，通道可以向客户端发送消息，反之亦然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了两种不同方法:<code class="fe lv lw lx ly b">send</code>和<code class="fe lv lw lx ly b">receive</code>。让我们逐一了解。</p><p id="c9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">webSocketTask.send</code>可用于向通道发送<code class="fe lv lw lx ly b">String</code>消息或<code class="fe lv lw lx ly b">Data</code>消息。在本演示中，我们只发送一条<code class="fe lv lw lx ly b">String</code>消息。我们已经使用全局队列在一秒钟后一次又一次地调用<code class="fe lv lw lx ly b">send()</code>方法。这将确保我们每秒钟都在发送和接收消息。如果发送消息时出现错误，回调将被错误调用，我们可以诊断错误。但是我们不会在这个演示中这样做。</p><p id="017d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">webSocketTask.receive</code>用于从我们连接的频道接收消息。在<code class="fe lv lw lx ly b">success</code>的情况下，它要么给我们发送一个<code class="fe lv lw lx ly b">String</code>消息，要么发送一个<code class="fe lv lw lx ly b">Data</code>消息。在<code class="fe lv lw lx ly b">failure</code>的情况下，它会简单地给我们发送一个错误消息。</p><p id="bd6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一点需要注意的是，为了继续从通道接收消息，我们必须一次又一次地调用<code class="fe lv lw lx ly b">receive</code>方法。所以每次我们收到一条消息，我们都要再次调用<code class="fe lv lw lx ly b">receive</code>方法，这将确保我们也收到所有未来的消息。</p><p id="8876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一件事:我们将从我们的委托方法中调用<code class="fe lv lw lx ly b">send()</code>和<code class="fe lv lw lx ly b">receive()</code>，这样我们就可以开始使用<code class="fe lv lw lx ly b">WebSocket</code>通道接收消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您运行Playground，您将在调试控制台中看到这些消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/fcb0c445352dead2b7bd13b7964b0be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x05hlGSY77F6Buq-OuymIg.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="232d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包扎</h1><p id="224a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">感谢你阅读这篇文章。希望你通过这篇文章获得了一些知识。</p><p id="6b38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以从<a class="ae ky" href="https://github.com/samarth4487/WebSocketsDemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载完整的源代码。</p></div></div>    
</body>
</html>