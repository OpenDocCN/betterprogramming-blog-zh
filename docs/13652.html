<html>
<head>
<title>Serverless API Essentials — Idempotency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器API基础——等幂</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serverless-api-essentials-idempotency-e753b7b49680?source=collection_archive---------6-----------------------#2022-09-14">https://betterprogramming.pub/serverless-api-essentials-idempotency-e753b7b49680?source=collection_archive---------6-----------------------#2022-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce61" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无服务器API设计的很大一部分是处理重试或意外的重新提交。没有它，数据完整性就会荡然无存。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff1e5b32c206e6458f31370b3c2f253e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYg_aEUrIYdJ6nLrfXthVA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Freepik上的<a class="ae ky" href="https://www.freepik.com/free-vector/wall-post-concept-illustration_7769804.htm#query=duplicate&amp;position=2&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">故事集</a></p></figure><p id="2c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次涉足云开发时，我和我的团队一头扎进了现代软件设计的各个方面<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/starting-over-with-purpose-my-serverless-adventure-99f0c051d73a">。我们进行的最有趣的讨论之一是关于幂等性的。</a></p><p id="d44c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是因为我们会围绕它进行学术讨论，而是因为我们没有人知道如何发音。我们会在房间里走来走去，用不同的方式说它，当有人用听起来正确的方式发音时，我们会点头。我们都不知道这是什么意思，但至少说起来很有趣。</p><p id="8076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们开始试图理解<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/7-aws-serverless-design-principles-for-solutions-architects-2be22717713b#a4fe">的含义</a>以及如何在我们的无服务器应用上实现它时，我们开始产生分歧。</p><p id="4635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幂等性(读作eye-dem-POE-ten-see)的核心听起来像是软件工程的一个简单方面。它指的是多次调用都会产生相同结果的操作。</p><p id="2dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但事情没那么简单。幂等性有很多方面，我最近发现<em class="lv">没有多少人同意</em>。</p><p id="488a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我带着一个棘手的等幂问题在LinkedIn和Twitter上进行了民意调查，看看社区是怎么想的。我提出的问题是:</p><blockquote class="lw lx ly"><p id="82da" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it">当原始请求仍在处理时，如果出现重复请求，您会对幂等端点做什么？</em></p></blockquote><p id="1c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这本身就是一个很有针对性的问题。我没有问什么是幂等性，也没有问它的任何主要方面。但我对一切都有自己的看法。我觉得自己像是设了一个捕捉兔子的陷阱，却捕捉到了熊、鹿、兔子、浣熊和秃鹰。</p><p id="b59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入讨论幂等性的细节以及什么是错的或者不是错的之前，让我们看一下结果。我收到了325份回复，分布非常有趣。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/3ee28d1b6b5eaa884a46a4ea46861fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ptza2S2YtMWA81qa.png"/></div></div></figure><p id="2d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们对在这种情况下该做什么有不同的看法。<em class="lv">这似乎是因为在行业中幂等性的含义不明确</em>。因此，让我们来探究一下它的各个组成部分。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="e561" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">幂等原理</h1><p id="923b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如果幂等简单到每次用相同的有效载荷运行操作时<em class="lv">都做相同的事情，就没有必要写这篇文章了。每个人都会同意，这将是一个非常明确的概念。但是，在实现过程中，幂等性有几个问题需要考虑，这也是它如此困难的原因。</em></p><h2 id="4482" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">对系统的影响</h2><p id="93c6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当我们谈到幂等性的时候，大家可以一致同意，幂等性的调用对系统的影响是一样的，不管对同一个有效载荷调用了多少次操作。但这实际上意味着什么呢？在这个问题上你可以有几种不同的方式。</p><p id="84a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">运算本质上是幂等的</strong> —这意味着完整的运算可以在设计或代码中无需额外考虑的情况下运行。一个很好的例子就是PUT操作。PUT将用请求中的内容替换数据实体的所有现有值。这是一种严格的一对一替换，只是简单地进行覆盖。这可以被调用一次或100次，并且它将导致数据实体保持相同的状态。</p><p id="b0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人认为删除操作也是幂等的。多次调用端点来删除对象不会多次删除该对象。它将删除它一次，然后对后续调用执行空操作。</p><p id="2018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这仅仅触及了删除的表面。如果将删除数据实体时触发的事件或写入的审计日志考虑在内，它真的与第一次调用它时的效果相同吗？也许是在数据实体上，但不是在整个系统上。</p><p id="272d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">操作必须编码为等幂</strong>——我倾向于认为这类操作是为了确保您不会让调用者意外地创建重复项。调用者可能是使用API的最终用户，也可能是对失败的事件处理程序执行重试的自动机制<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/3-ways-to-retry-failures-in-your-serverless-application-84b5102f620">。</a></p><p id="5a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理支付就是一个很好的例子。如果呼叫者意外地多次呼叫您的端点试图付款，您最不想做的事情就是对他们进行多次收费。通过以幂等的方式构建API，可以保证付款只被处理一次。</p><p id="dea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从编码的角度来看，实现幂等的最常见方式是在请求中接受一个<code class="fe nt nu nv nw b">idempotency-key</code>头。如果您的操作是异步的并且没有头，那么您可以在有效负载中包含一个<code class="fe nt nu nv nw b">idempotency-key</code>属性，或者使用类似请求id的东西(只要它在重试时不会改变)。</p><p id="6e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nt nu nv nw b">idempotency-key</code>作为锁和查找键来保存响应并在后续调用中返回结果。</p><h2 id="416e" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">对来电者的回应</h2><p id="542c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这就是很多争论的地方。有些人认为，为了使操作幂等，每次调用的响应必须相同。其他人认为严格的幂等性止于服务器端。</p><p id="1154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在民意测验结果中看到不同的意见。那些认为响应应该与呼叫者相同的人回答“<em class="lv">等待原始的</em>”。其他人认为幂等性可以通过根据系统正在做的事情返回不同的结果来实现。</p><p id="5f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个很好的例子就是关于删除的争论。当成功执行删除时，删除资源通常会返回一个<em class="lv"> 204 No Content </em>状态代码。但是，当您再次尝试删除该资源时，无论是意外还是故意的，该怎么办呢？你还会返回一个<em class="lv"> 204 </em>来为调用者提供幂等响应吗？还是因为不存在而返回<em class="lv"> 404未找到</em>或<em class="lv"> 410消失</em>状态代码？</p><p id="e362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回一个<em class="lv"> 404 </em>或<em class="lv"> 410 </em>状态代码会对系统产生相同的影响(不包括下游事件)，所以有些人仍然认为它是幂等的。</p><p id="3855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于使用幂等键的调用，我们有不同的方法。</p><p id="aeb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用幂等键时，它保存一个记录，锁定所提供的键。一旦处理完成，它将结果保存到幂等记录并解锁密钥。如果另一个请求带有相同的键，它将返回保存在记录中的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/ad6ce22ae7bbccb8422a649d9b59aee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DIvwn726_I_KHcPr.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nx">使用等幂键时的工作流程图。来源:</em><a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/latest/utilities/idempotency/#choosing-a-payload-subset-for-idempotency" rel="noopener ugc nofollow" target="_blank"><em class="nx">AWS Lambda power tools文档</em> </a></p></figure><p id="3c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型的流动是我的调查问题的来源。它是在询问当一个重复的请求进来的时候，你应该做什么。由于记录是基于键锁定的，所以在系统上也会出现同样的效果，但是您向调用者发回什么呢？</p><p id="4d77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阅读了许多关于民意调查的评论，并与<a class="ae ky" href="https://twitter.com/andmoredev" rel="noopener ugc nofollow" target="_blank">安德烈斯·莫雷诺</a>、<a class="ae ky" href="https://twitter.com/kevinswiber" rel="noopener ugc nofollow" target="_blank">凯文·斯韦博</a>和<a class="ae ky" href="https://twitter.com/mattbonig" rel="noopener ugc nofollow" target="_blank">马修·博尼格</a>进行了几次精彩的交谈后，我得出结论<strong class="lb iu">立即回报成功</strong>。</p><p id="cdb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我最初发布民意调查时，这听起来似乎是最不正确的选择。这甚至不是投票的一个选项！但是有道理。如果您返回一个<em class="lv"> 202 Accepted </em>状态代码，这向调用者表明服务器上正在运行一个进程。您可以选择在响应中返回一个指向“get status”端点的url，以便调用者可以自己检查状态。</p><p id="fb61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等待响应是对资源的浪费。你会毫无必要地告诉你的应用程序等待回应，只是为了让来电者对<em class="lv">有同样的</em>感受。使用无服务器，你只是在浪费金钱，强迫一个Lambda函数等待。既然可持续性是<a class="ae ky" href="https://docs.aws.amazon.com/wellarchitected/latest/sustainability-pillar/sustainability-pillar.html" rel="noopener ugc nofollow" target="_blank">良好架构框架</a>的支柱，强迫等待将违背AWS最佳实践。</p><p id="a6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4XX错误表示呼叫者做错了什么。在这种情况下，他们没有等待足够长的时间来完成处理，这不是调用者的错。这也不是服务器端错误(5XX状态代码)。这意味着抛出一个错误实际上并不适用。您最不希望的事情是调用者采取纠正措施，通过更改请求或发送更多次请求，因为他们收到了一个错误。</p><p id="fe1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对幂等运算的响应因原始请求的状态而异:</p><ul class=""><li id="4b59" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><strong class="lb iu"> Completed successfully </strong> —从缓存中取出原始状态代码和响应体，如<a class="ae ky" href="https://gomomento.com" rel="noopener ugc nofollow" target="_blank"> Momento </a>，并返回给调用者。</li><li id="e40e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">已完成，但出现故障</strong> —操作再次尝试，就像是原始操作一样。</li><li id="ba96" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">进行中</strong> —返回成功，不做任何操作。</li></ul><h2 id="54da" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">活下去的时间</h2><p id="685a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如前所述，幂等键将保存一个记录以防止重复。但是这个记录能存在多久呢？</p><p id="2ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您永远保留它，这意味着没有其他调用方能够再次使用该密钥，这可能是也可能不是一件坏事。这带来了另一个好的观点。</p><blockquote class="om"><p id="496b" class="on oo it bd op oq or os ot ou ov lu dk translated"><em class="nx">您应该总是根据幂等键来验证请求有效负载。</em></p></blockquote><p id="384a" class="pw-post-body-paragraph kz la it lb b lc ow ju le lf ox jx lh li oy lk ll lm oz lo lp lq pa ls lt lu im bi translated">我们举个例子。在这个<a class="ae ky" href="https://github.com/allenheltondev/serverless-idempotency-momento" rel="noopener ugc nofollow" target="_blank">参考架构项目</a>中，用户可以将他们的山羊添加到系统中，这样他们就可以将山羊产品(肥皂、牛奶、奶酪等)联系起来..)来卖。</p><p id="c289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果两个山羊养殖户同时在系统中添加他们的山羊，但使用相同的幂等键，会发生什么情况？这些不是重复的请求——这就是幂等性要解决的问题。相反，这些是使用相同密钥的竞争请求。</p><p id="beb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，系统应该验证带有密钥的请求体，并验证它是否与原始请求体匹配。这是(大多数情况下)保证防止重复的唯一方法。</p><p id="40b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在参考项目中，我们获取请求体的<a class="ae ky" href="https://github.com/allenheltondev/serverless-idempotency-momento/blob/main/layers/index.js#L41" rel="noopener ugc nofollow" target="_blank">散列，并将其保存在键旁边。如果另一个请求带有相同的关键字，但没有相同的散列，则返回一个<em class="lv"> 400错误请求</em>，指出有效负载与原始请求的有效负载不匹配。</a></p><p id="59ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们没有使幂等键过期，我们可能会不必要地遇到这样的冲突。当然，您可以强制幂等键的格式为某种UUID或时间戳/哈希组合，但这增加了一些操作开销，从长远来看可能不值得。</p><p id="abba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过终止或设置幂等键的生存时间，您正在将该值释放回可用的键池中。</p><p id="db59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，您的目标是防止重复条目进入系统，因此请将您的生存时间设置为比最大重试持续时间稍长一点。如果您有一个退避和重试策略，在24小时内自动重试失败的异步进程50次，那么将您的生存时间设置为25小时。</p><p id="8d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于同步或请求/响应调用，您的生存时间可能会显著缩短。API端点发送副本的可能用例是意外双击提交按钮。在这种情况下，副本会立即出现。为了子孙后代的利益，我们可以将这些调用的生存时间设置为大约一个小时，以捕获任何进入的流氓请求。</p><h2 id="bb34" class="nh ml it bd mm ni nj dn mq nk nl dp mu li nm nn mw lm no np my lq nq nr na ns bi translated">记录存储器</h2><p id="08d6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们已经详细讨论了跟踪和存储幂等记录的需要。该记录具有简单的键/值访问模式，需要在一段时间后过期。同样至关重要的是，查找要非常快，以防止在“意外双击”场景中或对于多次交付的事件出现重复。</p><p id="3244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">听起来是一个很好的缓存用例。</em></p><p id="fe59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，缓存是一个<a class="ae ky" href="https://aws.amazon.com/caching/" rel="noopener ugc nofollow" target="_blank">高速数据层</a>，它存储一小组瞬态数据。这正是我们存储幂等记录所需要的。</p><p id="4436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来不像一个纯粹主义者，但是当我构建无服务器应用程序时，我更希望所有的都是无服务器的。使用亚马逊Elasticache打破了这种模式。这种服务是按小时付费的，没有我在使用无服务器服务时所习惯的灵活性。</p><p id="8d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我选择了<a class="ae ky" href="https://www.gomomento.com/" rel="noopener ugc nofollow" target="_blank"> Momento </a>，这是一个完全无服务器的缓存解决方案。它与AWS无服务器服务采用相同的<em class="lv">付费使用</em>模式，包括<a class="ae ky" href="https://www.gomomento.com/pricing" rel="noopener ugc nofollow" target="_blank">50GB/月免费层</a>。由于它是无服务器的，它会自动扩展以匹配流量并增加缓存的大小，而不用担心数据节点。</p><p id="7db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将记录保存到缓存而不是数据库有助于遵循最低特权原则。由于我们没有建立到DynamoDB的连接，我们可以从任何需要幂等的Lambda函数中省略<em class="lv"> GetItem </em>、<em class="lv"> PutItem </em>和<em class="lv"> DeleteItem </em>权限，因为我们没有管理幂等记录。这将我们的功能锁定为操作所需的权限。</p><p id="a221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于缓存的数据是短期的，所有记录都会自动过期。这种行为可以在DynamoDB中通过在记录中包含一个TTL来模仿，但是删除一个带有TTL的记录是不准确的。它可能在到期日之后48小时内到期<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/howitworks-ttl.html#:~:text=TTL%20typically%20deletes%20expired%20items%20within%2048%20hours%20of%20expiration." rel="noopener ugc nofollow" target="_blank">。通过将记录放入缓存，您可以保证不会有任何幂等记录停留的时间超过它们应该停留的时间。</a></p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="87eb" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">摘要</h1><p id="4eb8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">幂等性是一个很大的话题，在开发界引起了很大的争议。根据您对幂等的定义，您实现它的方式可能会有很大的不同。</p><p id="05e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，似乎确实有一个普遍共识。无论您如何实现幂等性，<em class="lv">重复调用应该对系统产生相同的影响</em>。</p><p id="070c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那里我们开始分歧。但是我很乐意分享我的观点，努力让他们为人所知，并希望开始在一些想法上保持一致。</p><ul class=""><li id="f73e" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">幂等性并不能保证给调用者相同的响应，但是这是一个不错的奖励。</li><li id="4e54" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">具有相同幂等键的并发调用应该导致成功的响应和空操作。</li><li id="e883" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">幂等键的生存时间应该比回退/重试机制的总时间稍长。</li><li id="349b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">我们认为自然幂等的操作，如删除和放置，实际上可能不是。它依赖于由于变化而发生的下游动作。</li><li id="091b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">如果可能的话，使用缓存机制来代替幂等记录的数据库，以获得更快的响应和及时的记录过期。</li></ul><p id="c43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然我们需要记住这是软件，大多数软件问题的答案是什么？视情况而定。在实施解决方案之前，考虑您的使用案例。基于不同的API，您甚至可能有不同的策略！</p><p id="d220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些软件包可以非常好地处理幂等性。无服务器Python开发者应该强烈考虑<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-python/latest/utilities/idempotency/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda Powertools </a>库。它处理我们今天讨论的一切，加上一些扩展的用例，比如当你的Lambda函数超时时。注意，在撰写本文时，它只在Python中可用。<a class="ae ky" href="https://awslabs.github.io/aws-lambda-powertools-typescript/latest/" rel="noopener ugc nofollow" target="_blank">类型脚本Lambda Powertools </a>不支持它。</p><p id="2f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章一点也不全面，我敢肯定，它惹恼了一些人。不管你是否同意我的观点，知道别人相信什么是好的。</p><p id="e544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你开始和一个人谈论等幂时，记住首先要平级。你可能说的不是同一件事。</p><p id="1b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>