<html>
<head>
<title>Finding Bugs in Code Programmatically Using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go以编程方式查找代码中的bug</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/finding-bugs-in-code-programmatically-using-go-c5599796e89e?source=collection_archive---------7-----------------------#2022-10-03">https://betterprogramming.pub/finding-bugs-in-code-programmatically-using-go-c5599796e89e?source=collection_archive---------7-----------------------#2022-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a995" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写一个静态代码分析器来发现代码中的错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/630227b8fba379243b2390676f74a988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUVbQTqEaR18BE-2RCqJWA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>从<a class="ae kv" href="https://www.pexels.com/photo/antique-book-hand-knowledge-207681/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</p></figure><p id="98b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一篇基于一年前我在gopherCon举办的关于Go中静态分析的研讨会的博文。研讨会的内容远远超出了我在本文中所能涵盖的范围，因此您可以在这里查看研讨会<a class="ae kv" href="https://github.com/amit-davidson/GopherCon2021IsraelStaticAnalysisWorkshop" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="8c5b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">动机</h1><p id="95dd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据维基百科，静态代码分析是在不执行计算机程序的情况下对它们进行的分析。您可能已经熟悉了进行静态分析的工具:</p><ul class=""><li id="22b6" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">用于检测样式错误并修复它们的棉绒。</li><li id="d428" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">内置的IDE分析器，用于检测不同的问题，如无限循环、不可达代码和声明冗余。</li><li id="4121" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">go分析器<a class="ae kv" href="https://github.com/dominikh/go-tools" rel="noopener ugc nofollow" target="_blank"> staticcheck </a>和开源平台<a class="ae kv" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"> SonarQube </a>。</li></ul><p id="5533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你为什么要在乎？当在有许多开发人员的团队中工作时，代码分析器是必不可少的。它们被用在CI/CD过程中，以确保没有坏的实践、错误和反模式被推送到主repo。</p><p id="31d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go语言提供了用于创建静态代码分析器的<a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis" rel="noopener ugc nofollow" target="_blank"> go/analysis </a>包。在讨论如何编写这些工具之前，我们需要介绍一些理论。</p><h1 id="2963" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">大西洋时间</h1><p id="691a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">抽象语法树(AST)是一种将编程语言的语法表示为分层树状结构的方式。让我们来看看下面的程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e90c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是程序的AST。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8c4359cb7a855720741ec641191f456f.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*uNZLomA1WVXy-GGhpeTTfQ.png"/></div></figure><p id="7350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni nj b">[]ast.Decl</code>包含文件中所有的顶级声明——imports和main函数。在<code class="fe ng nh ni nj b"><a class="ae kv" href="http://ast.FuncDecl" rel="noopener ugc nofollow" target="_blank">ast.FuncDecl</a></code>内部，也就是<code class="fe ng nh ni nj b">main</code>函数声明，我们有一个<code class="fe ng nh ni nj b"><a class="ae kv" href="https://golang.org/pkg/go/ast/#BlockStmt" rel="noopener ugc nofollow" target="_blank">ast.blockStmt</a></code>。它是函数语句的列表——主函数的实际代码。我们可以继续沿着树往下走，但是您可以很容易地将树节点与实际代码匹配起来。(为了简洁起见，我删除了树中的一些节点)。</p><p id="195b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go提供了<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/go/ast" rel="noopener ugc nofollow" target="_blank">go/ast</a></code>包。AST包包含了用来表示Go中语法树的类型，就像上面的树一样。我们来看看<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/go/ast#AssignStmt" rel="noopener ugc nofollow" target="_blank">ast.AssignStmt</a></code>。以下代码来自<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/go/ast" rel="noopener ugc nofollow" target="_blank">go/ast</a></code>包:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e7a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">表达式<code class="fe ng nh ni nj b">a := 5</code>是一个赋值，所以它在AST中被表示为一个<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/go/ast#AssignStmt" rel="noopener ugc nofollow" target="_blank">ast.AssignStmt</a></code>，如下所示:</p><ul class=""><li id="71b6" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe ng nh ni nj b">Lhs</code>是【a】</li><li id="0aff" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe ng nh ni nj b">TokPos</code> [2](字符“:”的位置)</li><li id="2dea" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe ng nh ni nj b">Tok</code> [:=]</li><li id="d499" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe ng nh ni nj b">Rhs</code>是【5】</li></ul><p id="4ff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包中所有类型的列表有<a class="ae kv" href="https://pkg.go.dev/go/ast#pkg-index" rel="noopener ugc nofollow" target="_blank">长</a>，但是它符合您的实际期望。您还可以使用这个<a class="ae kv" href="http://goast.yuroyoro.net/" rel="noopener ugc nofollow" target="_blank">站点</a>查看代码的AST树。</p><h1 id="5e1d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编写分析器</h1><p id="2285" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这一部分，我们将编写一个静态分析器来检测函数参数是否被覆盖。这被认为是一种代码味道，因为它使得在调试过程中很难知道什么参数被传递给了一个函数。你可以在这里查看分析器<a class="ae kv" href="https://github.com/amit-davidson/ArgOverwritten" rel="noopener ugc nofollow" target="_blank">的全部代码。</a></p><p id="ac79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们来看一个分析器的典型结构。我们为每一遍创建一个名为<code class="fe ng nh ni nj b">passes</code>的目录。每一遍都是对我们代码的检查。它们中的每一个都生活在自己的包中，包括它的逻辑和测试。然后我们创建一个<code class="fe ng nh ni nj b">main</code>文件，该文件执行模块拥有的通道。</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="8ba0" class="no lt iq nj b gy np nq l nr ns">│── README.md<br/>│── cmd<br/>│   └── analyzerName<br/>│       └── main.go<br/>│── go.mod<br/>│── go.sum<br/>└── passes<br/>    └── passName<br/>        │── analyzer.go<br/>        │── analyzer_test.go<br/>        └── testdata</span></pre><p id="91ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis" rel="noopener ugc nofollow" target="_blank">go/analysis</a></code>包为模块化静态分析工具定义了一个API。首先，所有的通道都应该创建一个<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis#hdr-Analyzer" rel="noopener ugc nofollow" target="_blank">analysis.Analyzer</a></code>的实例。它描述了一个分析函数:它的名称、文档、标志、与其他分析器的关系，当然还有它的逻辑。</p><p id="85a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从向<code class="fe ng nh ni nj b"><a class="ae kv" href="https://github.com/amit-davidson/ArgOverwritten/blob/master/passes/ArgOverwritten/analyzer.go" rel="noopener ugc nofollow" target="_blank">analyzer.go</a></code>添加分析器开始。我们还将添加它的名称和文档。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ff4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe ng nh ni nj b"><a class="ae kv" href="https://github.com/amit-davidson/ArgOverwritten/blob/master/passes/ArgOverwritten/analyzer.go" rel="noopener ugc nofollow" target="_blank">analyzer.go</a></code>文件中的<code class="fe ng nh ni nj b">run</code>函数。它包含分析器的实际逻辑。它接收类型为<code class="fe ng nh ni nj b">*<a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis#hdr-Pass" rel="noopener ugc nofollow" target="_blank">analysis.Pass</a></code>的参数。<code class="fe ng nh ni nj b">*<a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis#hdr-Pass" rel="noopener ugc nofollow" target="_blank">analysis.Pass</a></code>提供信息和操作，用于向分析仪的<code class="fe ng nh ni nj b">Run</code>功能报告有关被分析包的诊断。</p><p id="5bd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看下面代码中的第51–53行。我们遍历所有文件，并对每个文件运行<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/go/ast#Inspect" rel="noopener ugc nofollow" target="_blank">ast.Inspect</a></code>函数。这个函数以深度优先的顺序遍历给定文件的AST树。该函数还被赋予了visitor函数，它接收一个AST节点，这就是逻辑发生的地方。</p><p id="e6b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第3–18行，我们验证给定的节点与我们的条件匹配:</p><ul class=""><li id="9b43" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">第3–15行确保节点类型是函数——常规函数或lambda函数。此外，在第13–15行，我们排除了没有主体的函数，比如汇编例程。</li><li id="d78c" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在第16–18行，没有参数的函数被排除在外。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="03e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们迭代第20-25行的每个参数，并从中构造一个集合。第27-47行是奇迹发生的地方。</p><p id="76d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从作为根节点的函数体开始遍历树。然后在函数体中搜索修改了变量的语句- <code class="fe ng nh ni nj b">AssignStmt</code>(例如a = 5)和<code class="fe ng nh ni nj b">IncDecStmt</code>(例如i++)。</p><p id="404c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们检查参与语句的标识符，如果它是集合中的一个参数(arguments)，那么它被认为是一个错误，我们调用report函数。这是我写的一个辅助函数，下面可以看到它的代码。它所做的只是包装对<code class="fe ng nh ni nj b">pass.Report</code>的调用，该调用实际上通知用户一个错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="693f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将添加一个新的<code class="fe ng nh ni nj b">main</code>文件和一个使用我们刚刚编写的分析器的<code class="fe ng nh ni nj b">main</code>函数。要运行分析仪，您必须使用单次/多次检查器进行单次/多次检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="bd3b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">运行我们的分析仪</h1><p id="3a62" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然我们的分析器已经准备好了，我们想在一个实际的文件上运行它。我们可以使用以下命令运行它:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="edea" class="no lt iq nj b gy np nq l nr ns">go install path/to/analyzer<br/>go vet -vettool=$(which analyzername) path/to/files</span></pre><p id="e4de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个命令将分析器作为二进制文件安装，第二个命令使用<code class="fe ng nh ni nj b">go vet</code>运行它。这样，您可以轻松地将其集成到您的IDE或CI/CD环境中。</p><p id="9d0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以使用<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis/analysistest" rel="noopener ugc nofollow" target="_blank">analysistest</a></code>包测试我们的代码。使用<code class="fe ng nh ni nj b">analysistest.Run</code>，可以对带有测试文件的名为<code class="fe ng nh ni nj b">testdata</code>的包运行分析器，并检查它是否报告了所有预期的诊断。期望用“//想要...”来表达输入代码中的注释，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a2a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们必须从下面的测试文件中调用<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis/analysistest#Run" rel="noopener ugc nofollow" target="_blank">analysistest.Run</a></code>。</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="4cf0" class="no lt iq nj b gy np nq l nr ns">analysistest.Run(t, analysistest.TestData(), Analyzer)</span></pre><p id="5eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个参数是<code class="fe ng nh ni nj b">*testing.T</code>，第二个是测试文件的路径，很容易由<code class="fe ng nh ni nj b"><a class="ae kv" href="https://pkg.go.dev/golang.org/x/tools/go/analysis/analysistest#pkg-variables" rel="noopener ugc nofollow" target="_blank">analysistest.TestData()</a></code>提供给我们，第三个是实际的分析器本身。</p></div></div>    
</body>
</html>