<html>
<head>
<title>3 Refactoring Techniques To Keep a Clean, Simple, and Readable Django Codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3保持Django代码库干净、简单和可读的重构技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/refactors-you-need-to-know-to-for-your-django-project-8a56b0dee34f?source=collection_archive---------2-----------------------#2022-04-09">https://betterprogramming.pub/refactors-you-need-to-know-to-for-your-django-project-8a56b0dee34f?source=collection_archive---------2-----------------------#2022-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="277b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用姜戈？你需要重构这些东西！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dc1ef9634f69e2e4341f7448413b22ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZmhOjR2a84IEZrzY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><blockquote class="kw kx ky"><p id="4e13" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这篇文章是为了CSUI的软件工程项目课程2022的个人复习而写的。</p></blockquote><h1 id="429c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">介绍</h1><p id="91a7" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">重构是你必须为所有项目做的最重要的实践之一。即使当您的项目相对较小和简单时，重构代码总是被鼓励的，并且是更可读、简单和更整洁的代码的最佳实践。在本文中，我将向您展示一些当您选择使用Django(尤其是Django REST框架)作为框架时可以重构的东西！我们走吧！</p><h1 id="9c39" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">目录</h1><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="fd14" class="nb lx iq mx b gy nc nd l ne nf">1. <a class="ae kv" href="#9754" rel="noopener ugc nofollow">(Django Models) Custom Model Manager</a><br/>2. <a class="ae kv" href="#fd3d" rel="noopener ugc nofollow">(Django Models) Select Related and Prefetch Related</a><br/>3. <a class="ae kv" href="#7a88" rel="noopener ugc nofollow">(Django REST Views) Class Based Views with Mixins and Generics</a><br/><a class="ae kv" href="#4376" rel="noopener ugc nofollow">Conclusion</a></span></pre></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="9ac5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">在这些例子中，我将使用我为我的软件工程项目课程2022制作的这些模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="9754" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">1.Django模型—定制模型管理器</h1><blockquote class="kw kx ky"><p id="a449" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">根据<a class="ae kv" href="https://docs.djangoproject.com/en/4.0/topics/db/managers/" rel="noopener ugc nofollow" target="_blank"> Django文档</a>，“Django中的模型管理器是一个接口，通过它向Django模型提供数据库查询操作。”</p></blockquote><p id="e71c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">您可能没有意识到这一点，但是您可能在使用Django模型时使用过Django的模型管理器。当你写<code class="fe np nq nr mx b">Term.objects.all()</code>的时候，默认管理器中间的‘对象’是Django提供给所有模型的。</p><p id="bdde" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">事情变得有趣起来:您可以创建自己的定制模型管理器，它可以为您和您的模型做其他方便的事情。</p><p id="81fa" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">例如，如果我想获取某个特定学期的所有课程(即学期“2021/2022–1”)，并且我想按课程名称对它们进行排序，那么通常我们可能会这样写:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="02d0" class="nb lx iq mx b gy nc nd l ne nf">Course.objects.filter(term__name="2021/2022-1").order_by("name")</span></pre><p id="77d1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">老实说，这没有什么大问题，但是如果你在代码中多次使用这种精确的过滤和排序，你会发现你会一遍又一遍地重复代码。这种冗长的筛选和排序会降低代码的可读性。如果您使用自定义模型管理器和QuerySet，情况会有所改善，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="34e5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">不要忘记将新的定制管理器分配给模型。您可以覆盖默认的“对象”管理器，或使用不同的名称创建新的自定义管理器。为此，我将覆盖默认的“对象”管理器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="46f8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">有了这个，你可以像以前一样写这个:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="8bf7" class="nb lx iq mx b gy nc nd l ne nf">Course.objects.<!-- -->get_by_term_name_with_ordered_name("<!-- -->2021/2022-1<!-- -->")</span></pre><p id="0868" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">您可以看到它比之前的代码可读性更好，而且更简单，没有重复<code class="fe np nq nr mx b">.filter</code>和<code class="fe np nq nr mx b">.order_by</code>。当然，这个例子可能看起来并没有改善多少代码，但是您可以根据自己的需要使用定制管理器。这可以显著提高代码的可读性，并防止重复代码。</p><h1 id="fd3d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak"> 2。Django型号选择相关和预取相关</strong></h1><p id="5664" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">你可能还不知道<code class="fe np nq nr mx b">select_related</code>和<code class="fe np nq nr mx b">prefetch_related</code>，但是Django提供的这些功能真的很有用。在我看来，这是提高数据库查询性能的必备工具。这是因为当您已经向QuerySet查询了一组对象，然后您想要访问它的外键对象的属性时，Django将再次查询数据库，以获得您正在调用的每个对象的每个外键属性。</p><p id="cb23" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">猜一猜:如果执行下面的代码，Django会对数据库进行多少次查询？</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="25cb" class="nb lx iq mx b gy nc nd l ne nf">courses = Course.objects.filter(credit=4) #for example returns 2 obj</span><span id="a175" class="nb lx iq mx b gy ns nd l ne nf">for course in courses:<br/>  print(course.term.name)</span></pre><p id="80b4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">你可能认为应该是一个，对吗？在执行<code class="fe np nq nr mx b">Course.objects.filter</code>时应该查询数据库？对不起，但是那个答案是不正确的。正确答案是将有三次数据库查询调用。</p><p id="caac" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">怎么会？显然，第一个查询在过滤器上。之后，因为queryset中有两个<code class="fe np nq nr mx b">Course</code>对象，<code class="fe np nq nr mx b">courses</code>，并且代码要求外键的属性，(<code class="fe np nq nr mx b">course.term.name</code>，那么对于<code class="fe np nq nr mx b">for</code>循环的每一次迭代，Django将对数据库进行一次额外的查询调用。</p><p id="75de" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">这是因为首字母<code class="fe np nq nr mx b">Course.objects.filter</code>没有术语名称的信息。想象一下，如果你正在做1000次或者更多的迭代。光是这个你就要查询数据库1000次。</p><p id="ad48" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">为了防止这种情况发生，您可以使用<code class="fe np nq nr mx b">select_related</code>和<code class="fe np nq nr mx b">prefetch_related</code>来获取初始过滤器查询的外键属性。您可以搜索这两者之间的差异，但简而言之，当对象属性是单个对象(如<code class="fe np nq nr mx b">OneToOneField</code>或<code class="fe np nq nr mx b">ForeignKey</code>)时，您可以使用<code class="fe np nq nr mx b">select_related</code>，而当您要获得多个单个对象或一组事物时，您可以使用<code class="fe np nq nr mx b">prefetch_related</code>(<code class="fe np nq nr mx b">ManyToManyFields</code>或反过来<code class="fe np nq nr mx b">ForeignKey</code>)。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="bce7" class="nb lx iq mx b gy nc nd l ne nf">courses = Course.objects.filter(credit=4).select_related("term")</span><span id="572b" class="nb lx iq mx b gy ns nd l ne nf">for course in courses:<br/>  print(course.term.name)</span></pre><p id="c70b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">通过添加<code class="fe np nq nr mx b">select_related("term")</code>，您将在第一次查询中查询<code class="fe np nq nr mx b">courses</code>对象的外键“term”的所有信息。因此，Django不需要为<code class="fe np nq nr mx b">fo</code> r循环的每次迭代查询数据库。</p><p id="2b2c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">这将显著提高您的数据库查询性能(更像是防止大量的数据库查询)，并且我个人认为，通过明确地告诉读者您稍后将需要某个外键的这些属性，这将使您的代码更具可读性。</p><h1 id="7a88" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated"><strong class="ak"> 3。Django REST视图——带有混合和泛型的基于类的视图</strong></h1><blockquote class="kw kx ky"><p id="7385" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意:我将讨论Django REST框架的基于类的视图。Django的基于类的视图有点不同，你可以查看Django文档<a class="ae kv" href="https://docs.djangoproject.com/en/4.0/topics/class-based-views/" rel="noopener ugc nofollow" target="_blank">了解更多信息</a></p></blockquote><p id="81ff" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">许多Django用户可能已经熟知基于类的视图。但在我看来，你应该适度使用基于阶级的观点。对于复杂的视图，我认为基于类的视图可能会降低可读性(对于那些不熟悉基于类的视图的人来说)并且缺乏灵活性。</p><p id="838a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">但是对于简单的视图，尤其是Django REST Framework (DRF)中的REST视图，您肯定应该使用基于类的视图和所提供的mixins和泛型，因为这要简单得多，需要的代码更少，并且提高了可读性(对于那些已经知道基于类的视图的人来说)。</p><p id="23da" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">例如，对于基于函数的视图，我会像这样写<code class="fe np nq nr mx b">GetAndDeleteTermViews</code>，记住你应该首先为你的模型创建序列化器来序列化数据。在这种情况下，我将我的名字命名为<code class="fe np nq nr mx b">TermSerializer</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="41ca" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">上面的代码在功能上没有大问题。它应该能正常工作。但是你可以看到更复杂的逻辑，它会变得更加混乱。将会有更多的代码行，和/或更多的if和elifs。这将降低代码的可读性。下面是基于类的视图、混合和泛型的相同功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8c82" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">如您所见，它更加简单，可读性更好。另一个优点是所有可能发生的错误(比如对象不存在时的404)都已经被Django处理了。对于对基于类的视图有基本了解的读者来说，这将花费更少的开发时间并提高可读性。</p><h1 id="4376" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="0cfc" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">我认为这些是你在Django项目中必须考虑的基本重构。这些绝对不是你需要重构的所有东西。你应该搜索更多需要重构的东西，但是我发现很多刚接触Django的人并不了解这些东西——比如Django中的model manager和<code class="fe np nq nr mx b">select_related</code> / <code class="fe np nq nr mx b">prefetch_related</code>。</p><p id="42d0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">你在重构代码上付出的所有努力肯定会得到回报，得到更干净、简单、可读和改进的代码。</p><h1 id="e6b5" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">参考</h1><div class="nt nu gp gr nv nw"><a href="https://docs.djangoproject.com/en/4.0/topics/db/managers/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">经理| Django文档| Django</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">默认情况下，Django会向每个Django模型类添加一个名为的。但是，如果您想将用作字段名，或者如果…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">docs.djangoproject.com</p></div></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/#select-related" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">QuerySet API参考| Django文档| Django</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">Django提供了一系列的细化方法，可以修改返回的结果类型，也可以修改</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">docs.djangoproject.com</p></div></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://www.django-rest-framework.org/tutorial/3-class-based-views/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">基于3类的视图- Django REST框架</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">我们也可以使用基于类的视图来编写API视图，而不是基于函数的视图。正如我们将看到的，这是一个…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">www.django-rest-framework.org</p></div></div></div></a></div></div></div>    
</body>
</html>