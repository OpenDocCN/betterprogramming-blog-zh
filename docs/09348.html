<html>
<head>
<title>5 Tips to Customise Python Command-Line Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定制Python命令行界面的5个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-tips-to-customise-python-command-line-interfaces-691b0b39f610?source=collection_archive---------7-----------------------#2021-08-12">https://betterprogramming.pub/5-tips-to-customise-python-command-line-interfaces-691b0b39f610?source=collection_archive---------7-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca25" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建更好的命令行工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f56d5966a2fcc7ea7b08dfec9a5e6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xv6SdFc-C3wIBUXo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@james2k?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹姆斯·柯文</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bd90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的一个非常常见的用法是创建一个工具箱，来帮助您完成重复的任务。</p><p id="7f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在阅读这篇文章，我认为您已经用Python创建了自动化脚本。</p><p id="b31a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，也许在某个时候，你开始重构你的脚本，使它成为一个合适的命令行工具。添加参数、配置、提示和指令。随着时间的推移，我发现总有一组我喜欢添加到我的CLI中的通用功能。</p><p id="11f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信对你来说也一定是一样的。因此，每当我创建一个新的命令行时，我决定编译并分享我倾向于添加到命令行中的最佳技巧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4cec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.选择正确的工具来分析你的论点</h1><p id="6bef" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从自动化脚本到CLIs的第一个升级是允许参数。参数为您的程序声明值，并使其可自定义。</p><p id="488d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一点是肯定的，我讨厌使用原生的argparse包。这个包非常冗长，这意味着它需要大量代码来完成简单的任务。这里有一个来自<a class="ae ky" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> argparse </a>文档的简单例子供参考:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<a class="ae ky" href="https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html" rel="noopener ugc nofollow" target="_blank"> POSIX实用程序约定</a>和<a class="ae ky" href="https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html" rel="noopener ugc nofollow" target="_blank"> GNU扩展</a>，我们传递参数的方式已经标准化。</p><p id="c280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为解析参数是基于约定的，所以您可以找到一个Python包来帮助您编写更好、更智能的命令行。</p><p id="8e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">都有自己的长处和短处。但在我看来，最好的还是<a class="ae ky" href="http://docopt.org/" rel="noopener ugc nofollow" target="_blank"> docopt </a>。</p><p id="7bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迫使你专注于文档，并神奇地为你解析所有的参数。让我们使用Docopt编写相同的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ecf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你注意到了吗？我们真正做的只是为我们的命令行编写文档，其余的由<code class="fe nb nc nd ne b">docopt</code>处理。这个一行程序实现了这个目的:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="7663" class="nj md it ne b gy nk nl l nm nn">arguments = docopt(__doc__, version='Utility 20.0')</span></pre><p id="c3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docopt将文件的文档字符串(<strong class="lb iu"> doc </strong>)和您调用的命令作为输入，并返回一个包含所有标志和位置参数的字典。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="b181" class="nj md it ne b gy nk nl l nm nn">{'--help': False,<br/> '--sum': False,<br/> 'N': ['test']}</span></pre><p id="8af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/xNok/pystatemachine/blob/master/example_build_better_cli/2_docopt.py" rel="noopener ugc nofollow" target="_blank">这是GitHub上第一个例子的代码</a>，还有<a class="ae ky" href="https://github.com/xNok/pystatemachine/tree/master/example_build_better_cli" rel="noopener ugc nofollow" target="_blank">说明</a>。</p><h1 id="86de" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">2.实施一次演习</h1><p id="43b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常，在为自动化创建CLI时，您希望能够知道您的CLI将执行什么操作而不会产生任何影响。</p><p id="cc25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您很想编写一个简单的模拟机制，让您可以运行命令行，但跳过所有有影响的更改，比如对API的HTTP调用。</p><p id="ca6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是<a class="ae ky" href="https://github.com/haarcuba/dryable" rel="noopener ugc nofollow" target="_blank"> dryable </a>是一个简单的Python包，由于巧妙使用了<a class="ae ky" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank"> decorator </a> s，使得实现变得简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我在这个例子中也重用了docopt。添加一个新的参数<code class="fe nb nc nd ne b">--dry-run</code>很容易，这个参数将反映在dict <code class="fe nb nc nd ne b">arguments</code>中，dict<code class="fe nb nc nd ne b">arguments</code>保存所有被docopt解析过的参数。</p><p id="a4c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe nb nc nd ne b">dryable.set(arguments['--dry-run'])</code>来激活或不激活标志<code class="fe nb nc nd ne b">--dry-run</code>的存在。如果dryable被激活，那么所有用<code class="fe nb nc nd ne b">@dryable.Dryable()</code>装饰的功能都将被跳过。</p><p id="2820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/xNok/pystatemachine/blob/master/example_build_better_cli/3_dryable.py" rel="noopener ugc nofollow" target="_blank">这是GitHub上第二个例子的代码</a>，还有<a class="ae ky" href="https://github.com/xNok/pystatemachine/tree/master/example_build_better_cli#2-implement-a-dry-run" rel="noopener ugc nofollow" target="_blank">的说明</a>。</p><h1 id="7c69" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">3.创建. rc文件</h1><p id="f264" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦命令行达到一定的复杂性，每次都定义所有参数会变得非常乏味。</p><p id="c51b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经熟悉了<code class="fe nb nc nd ne b">.rc</code>文件，比如<code class="fe nb nc nd ne b">.npmrc</code>、<code class="fe nb nc nd ne b">.bashrc</code>。<code class="fe nb nc nd ne b">.vimrc</code>。这些文件是特定命令行界面的配置文件。他们的名字被编入法典；它以<code class="fe nb nc nd ne b">.</code>开头，然后是CLI的名称，后跟<code class="fe nb nc nd ne b">rc</code>。</p><p id="c724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们参考维基百科得到一个合适的定义，我们会得到:</p><blockquote class="nt nu nv"><p id="401e" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated"><em class="it">在类Unix系统的上下文中，术语rc代表短语“运行命令”。它用于包含命令启动信息的任何文件。</em></p></blockquote><p id="c773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的CLI中支持一个<code class="fe nb nc nd ne b">rc</code>文件使得通过将该文件提交到您的存储库来共享项目旁边的配置变得容易。它还防止用户重复他们经常使用的参数。这简化了命令行的使用。</p><p id="2414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用docopt，创建一个<code class="fe nb nc nd ne b">.rc</code>文件很容易。在我们的例子中，只需将生成的名为<code class="fe nb nc nd ne b">arguments</code>的字典保存到一个文件中。给你一个<code class="fe nb nc nd ne b">.rc</code>文件。现在您需要做的就是检查该文件是否存在。每当调用该命令时，就会将您的<code class="fe nb nc nd ne b">.rc</code>文件的内容与<code class="fe nb nc nd ne b">arguments</code>文件合并。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="937c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们之前的例子中，您必须始终包含<code class="fe nb nc nd ne b">--agg=sum</code>才能让命令工作。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="1393" class="nj md it ne b gy nk nl l nm nn">python .\2_docopt.py 2 3 --agg=sum</span></pre><p id="90cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你知道自己只想用<code class="fe nb nc nd ne b">sum</code>并且厌倦了重复自己怎么办？用我们的名为<code class="fe nb nc nd ne b">.foorc</code>的<code class="fe nb nc nd ne b">.rc</code>文件很容易知道。将以下内容添加到<code class="fe nb nc nd ne b">.foorc</code>:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="92bf" class="nj md it ne b gy nk nl l nm nn">{<br/>  "--sum": true<br/>}</span></pre><p id="d194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你自由了，可以不用<code class="fe nb nc nd ne b">--agg</code>运行命令行了</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="0388" class="nj md it ne b gy nk nl l nm nn">python .\4_rc_file.py 2 3</span></pre><p id="37aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是代码和<a class="ae ky" href="https://github.com/xNok/pystatemachine/blob/master/example_build_better_cli/.foorc" rel="noopener ugc nofollow" target="_blank">。本例中的foorc </a>和<a class="ae ky" href="https://github.com/xNok/pystatemachine/tree/master/example_build_better_cli#3-creating-a-rc-file" rel="noopener ugc nofollow" target="_blank">有说明</a>。</p><h1 id="91ff" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">4.安装命令行</h1><p id="46de" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦您的命令行脚本开始看起来像其他开发人员会使用的东西。你可能想让它可以安装。</p><p id="42a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是创建想要共享的命令行的基础。CLI将被添加到路径中，因此您可以直接调用它，而无需调用python脚本。</p><p id="1891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用pip时，安装命令行发生在安装阶段。以下<code class="fe nb nc nd ne b">setup.py</code>将安装CLI:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4cbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的部分是<code class="fe nb nc nd ne b">entry_point</code>属性。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c1fa" class="nj md it ne b gy nk nl l nm nn">'console_scripts': [<br/>    'foobar=5_setup:main'<br/>],</span></pre><p id="0181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉python注册一个名为<code class="fe nb nc nd ne b">foobar</code>的控制台脚本，该脚本将调用<code class="fe nb nc nd ne b">5_setup.py</code>的方法<code class="fe nb nc nd ne b">main</code>(<code class="fe nb nc nd ne b">5_setup.py</code>与<code class="fe nb nc nd ne b">4_rc_file.py</code>相同，但一切都包装在方法<code class="fe nb nc nd ne b">main()</code>中)。使用pip安装命令行:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="291e" class="nj md it ne b gy nk nl l nm nn">pip install .</span></pre><p id="a9ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么您的新命令行应该如预期的那样工作:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="92ef" class="nj md it ne b gy nk nl l nm nn">foobar 2 3 --agg=max</span></pre><p id="9fa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个额外的提示是，如果您在涉及pip时使用标志<code class="fe nb nc nd ne b">-e</code>，您将在可编辑模式下安装CLI。</p><p id="3b45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，代码中的更改将在调用您的命令时直接反映出来，这在您的CLI仍处于开发阶段时非常方便。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c53b" class="nj md it ne b gy nk nl l nm nn">pip install -e .</span></pre><p id="bb2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需按照这些说明<a class="ae ky" href="https://github.com/xNok/pystatemachine/tree/master/example_build_better_cli#4-installing-the-command-line" rel="noopener ugc nofollow" target="_blank">进行尝试</a></p><h1 id="f4c2" class="mc md it bd me mf no mh mi mj np ml mm jz nq ka mo kc nr kd mq kf ns kg ms mt bi translated">5.使命令行可扩展</h1><p id="3614" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦你的命令行成熟了，很多用户都在使用它并添加新的特性，你可能想要一个插件系统。以便您的CLI仅包含核心功能，但其他用户可以扩展它。</p><p id="caeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从这篇文章中学会了这个窍门。通常，在开发开源工具时，您希望为其他人留下一些空间来扩展您的CLI功能。</p><p id="6a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，并不是每个特性都对社区有用。因此，您可能希望将该特定功能保留在核心之外，而使用插件机制使其成为可选功能。</p><p id="5b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，这种方法是为您的CLI创建插件系统的一种简单方式。</p><p id="0859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们当前的实现中，我们可以用标志<code class="fe nb nc nd ne b">--agg</code>定义我们想要使用的聚合函数。我们还没有实施任何基于该标志的具体行动。演示前面的例子是没有用的。让我们解决这个问题。</p><p id="bdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现一个方法，该方法采用一个数字列表、一个聚合器的名称和一个聚合器的映射。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能可按如下方式使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，您会受到您在字典中列出的聚合器的限制。如果有人想为你的系统提供一个插件，用非常花哨的操作符来应用于一个数字序列，该怎么办？</p><p id="f776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用python <code class="fe nb nc nd ne b">entry_points</code>并不太难。让我们重构代码，使其具有可扩展性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d4ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">get_aggregators</code>函数将读取所有名为<code class="fe nb nc nd ne b">aggregators</code>的<code class="fe nb nc nd ne b">entry_points</code>，并将它们添加到我们的可能动作字典中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="50f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在只需创建一个定义了名为<code class="fe nb nc nd ne b">aggregators</code>的<code class="fe nb nc nd ne b">entry_points</code>的新包并安装它。</p><p id="b60a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个<code class="fe nb nc nd ne b">setup.py</code>来安装你的新插件。注意第<code class="fe nb nc nd ne b">fancy = fancy:main</code>行，这意味着聚合器调用fancy引用了yo插件包中的文件<code class="fe nb nc nd ne b">fancy.py</code>和方法<code class="fe nb nc nd ne b">main</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个非常奇特的now运算符</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在安装你的新软件包，我的叫做<code class="fe nb nc nd ne b">extandable_fancy_aggregator</code></p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c35d" class="nj md it ne b gy nk nl l nm nn">python -m pip install -e ./extandable_fancy_aggregator</span></pre><p id="747c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你自己试试吧</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="fbcc" class="nj md it ne b gy nk nl l nm nn">python .\6_extandable.py 1 2 --agg=fancys</span></pre><p id="152e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个，你需要<a class="ae ky" href="https://github.com/xNok/pystatemachine/tree/master/example_build_better_cli/extandable_fancy_aggregator" rel="noopener ugc nofollow" target="_blank">这个包</a> <code class="fe nb nc nd ne b"><a class="ae ky" href="https://github.com/xNok/pystatemachine/tree/master/example_build_better_cli/extandable_fancy_aggregator" rel="noopener ugc nofollow" target="_blank">extandable_fancy_aggregator</a></code>和例子的<a class="ae ky" href="https://github.com/xNok/pystatemachine/blob/master/example_build_better_cli/6_extandable.py" rel="noopener ugc nofollow" target="_blank">代码。你可以在这里找到说明。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="40eb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5308" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">随着你的Python脚本成长为一个完整的命令行，我采用了上面的五个元素。我喜欢将它们视为改善我的开发工作生活的一种方式。</p><ol class=""><li id="795f" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">在解析参数时让我的生活变得简单</li><li id="736a" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">实施一次演习以控制局面</li><li id="854c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">实现<code class="fe nb nc nd ne b">.rc</code>,因为命令变大了，我讨厌写长命令行。</li><li id="0aca" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">安装脚本作为一个完整的命令行，我可以使用了</li><li id="ce4d" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">使命令行可扩展以促进协作，并使内核尽可能小</li></ol><p id="5f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>