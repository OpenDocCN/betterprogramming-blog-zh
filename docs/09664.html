<html>
<head>
<title>How To Abstract SSH Commands in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中抽象SSH命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-run-ssh-commands-with-python-8111ee8ab405?source=collection_archive---------2-----------------------#2021-09-23">https://betterprogramming.pub/how-to-run-ssh-commands-with-python-8111ee8ab405?source=collection_archive---------2-----------------------#2021-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Popen从Python脚本中执行有效的ssh调用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b97e31228fcfd2e4bad7f33b48c3f786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Dnd9woqoHQ7qyx9mk1C6w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@arget?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿吉特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/hacking?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢用Python构建脚本。解决恼人的问题、收集一些基本数据或运行一些命令完全是轻而易举的事情。能够连接到远程机器并在其上执行命令是事情变得有点棘手的地方。</p><p id="b8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Ansible这样的大型工具可以抽象出大量的连接逻辑，但是像这样的工具可能会矫枉过正，并且比简单的脚本需要更长的设置时间。</p><p id="be73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去，我曾多次求助于发出原始的系统调用，或者试图在Bash中完成一些事情。在脚本中向ssh传递带有多个参数的复杂命令会变得很快。那么，在不离开Python的舒适环境的情况下，有什么简单、轻松的方法可以做到这一点呢？当然是Python的标准库之一。</p><p id="f34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索<code class="fe lv lw lx ly b">Subprocess</code>库。具体来说，我们将看看如何使用<code class="fe lv lw lx ly b">Popen</code>来抽象ssh系统调用，并使管理长时间运行的命令变得更加容易。让我们来看看。</p><h1 id="0e0d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">入门指南</h1><p id="bb27" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在我们继续之前，准备一两台测试主机通过ssh访问是很有帮助的。理想情况下，您应该已经在这些远程主机上的<code class="fe lv lw lx ly b">authorized_keys</code>中拥有了您的公共ssh密钥。这将通过ssh提供对主机的访问，而不必在命令行上输入密码或将其存储在某个文件中(这不是一个好的做法)。</p><p id="81c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您习惯于在ssh中使用密码，并且不知道从哪里开始，请查看关于生成新的ssh密钥对的GitHub文章<a class="ae ky" href="https://docs.github.com/en/github-ae@latest/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续执行脚本之前，确保您可以通过命令行上的ssh访问测试主机。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="cadd" class="lz ma it bd mb mc nd me mf mg ne mi mj jz nf ka ml kc ng kd mn kf nh kg mp mq bi translated">基本脚本</h1><p id="e3dc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们看看如何构建一个简单的Python脚本来在远程主机上运行ssh命令:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="6546" class="nm ma it ly b gy nn no l np nq">#!/usr/bin/env python3</span><span id="9507" class="nm ma it ly b gy nr no l np nq">import time<br/>from subprocess import Popen, PIPE</span><span id="93e8" class="nm ma it ly b gy nr no l np nq">def run_ssh_cmd(host, cmd):<br/>    cmds = ['ssh', '-t', host, cmd]<br/>    return Popen(cmds, stdout=PIPE, stderr=PIPE, stdin=PIPE)</span></pre><p id="c698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了很多事情，所以让我们一次分解一个元素。</p><p id="fa11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从<code class="fe lv lw lx ly b">subprocess</code>获取所需的<code class="fe lv lw lx ly b">Popen</code>和<code class="fe lv lw lx ly b">PIPE</code>对象，然后构建一个简单的方法来运行ssh命令(稍后将详细介绍时间库)。使用<code class="fe lv lw lx ly b">Popen</code>我们传递一个命令列表和它们各自的参数；<code class="fe lv lw lx ly b">cmds</code>的变数。这有点冗长，但比简单地传递一个插入的字符串更安全、更干净。</p><p id="4b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个列表中，我们调用<code class="fe lv lw lx ly b">ssh</code>，然后使用<code class="fe lv lw lx ly b">-t</code>参数分配一个伪终端。接下来，我们传递要连接的主机和要在该主机上运行的以下命令。</p><p id="a7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法返回了一个<code class="fe lv lw lx ly b">Popen</code>对象，我们为底层调用的所有输入和输出设置了管道。接下来我们将探索如何使用管道进行输出。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="f6e5" class="lz ma it bd mb mc nd me mf mg ne mi mj jz nf ka ml kc ng kd mn kf nh kg mp mq bi translated">构建用于输出的命令</h1><p id="b23d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们假设我们想要连接到一个远程主机并列出主目录的内容。我们将在现有脚本中添加以下内容:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="b8e0" class="nm ma it ly b gy nn no l np nq">results = run_ssh_cmd('my_remote_host.com', 'ls -l').stdout.read()<br/>print(results)</span></pre><p id="a22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从<code class="fe lv lw lx ly b">Popen</code>命令中获得<code class="fe lv lw lx ly b">stdout</code>，我们在之前设置的相应管道上调用<code class="fe lv lw lx ly b">read()</code>。现在应该可以执行ssh命令，并在控制台中显示目录的内容。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="1867" class="lz ma it bd mb mc nd me mf mg ne mi mj jz nf ka ml kc ng kd mn kf nh kg mp mq bi translated">构建无输出的命令</h1><p id="c9ee" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果我们真的不关心ssh命令的输出会怎么样呢？如果我们需要并行运行一堆缓慢的命令，而不是等着它们一个一个地完成，那该怎么办？使用<code class="fe lv lw lx ly b">Popen</code>我们可以轻松实现这一点。让我们更新我们的脚本:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="a1f4" class="nm ma it ly b gy nn no l np nq">ssh_cmds = []<br/>ssh_cmds.append(run_ssh_cmd('host1.com', 'cmd 1'))<br/>ssh_cmds.append(run_ssh_cmd('host2.com', 'cmd 2'))</span><span id="ad35" class="nm ma it ly b gy nr no l np nq">while all(cmd.poll() is None for cmd in ssh_cmds):<br/>    time.sleep(1)<br/>    print('not done yet')</span><span id="6089" class="nm ma it ly b gy nr no l np nq">print('done!')</span></pre><p id="f27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个新版本的脚本中，我们多次发出<code class="fe lv lw lx ly b">run_ssh_cmd</code>方法，并将结果存储在一个列表中(不是每次都从管道中读取)。</p><p id="ede6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个<code class="fe lv lw lx ly b">while</code>循环中，我们检查每个命令的结果是否仍然是<code class="fe lv lw lx ly b">None</code>，然后在等待一秒钟后再次尝试。直到列表中的所有命令不再是<code class="fe lv lw lx ly b">None</code>时，该循环才会返回。如果您担心命令花费太长时间或被挂起，您可以添加一个超时。</p><p id="d4f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连接超时可以直接添加到<code class="fe lv lw lx ly b">ssh</code>中，使用:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="fbea" class="nm ma it ly b gy nn no l np nq">-o ConnectTimeout=10</span></pre><p id="fb95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想给<code class="fe lv lw lx ly b">while</code>循环添加一个超时，您可以添加一个新变量，并在每次循环迭代后递增。一旦变量达到一定的秒数，发出<code class="fe lv lw lx ly b">break</code>并引发错误。</p><p id="46fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个脚本，我们可以并行启动一系列<code class="fe lv lw lx ly b">ssh</code>命令，然后等待它们同时完成。现在让我们来看看清理任何不需要的输出。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="d2eb" class="lz ma it bd mb mc nd me mf mg ne mi mj jz nf ka ml kc ng kd mn kf nh kg mp mq bi translated">让SSH更安静</h1><p id="91cb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果您注意到控制台中底层ssh调用的无关输出，您可能希望将其静音。在这种情况下，如果您想让<code class="fe lv lw lx ly b">ssh</code>更安静地执行，可以在底层ssh调用中添加<code class="fe lv lw lx ly b">-q</code>标志。</p><p id="b848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您仍然注意到额外的输出，您可能需要抑制<code class="fe lv lw lx ly b">stderr</code>。您可以通过添加以下内容将<code class="fe lv lw lx ly b">stderr</code>连接到<code class="fe lv lw lx ly b">/dev/null</code>:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="e934" class="nm ma it ly b gy nn no l np nq">ssh -t &lt;host&gt; &lt;cmd&gt; 2&gt; /dev/null</span></pre><p id="4f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您连接到新主机，并注意到系统提示您接受主机密钥，您可以通过向<code class="fe lv lw lx ly b">ssh</code>命令参数添加以下内容来禁用严格的密钥检查:</p><pre class="kj kk kl km gt ni ly nj nk aw nl bi"><span id="4bd8" class="nm ma it ly b gy nn no l np nq">-o StrictHostKeyChecking=no</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="f4a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！如果你喜欢这个故事，可以考虑看看我的<a class="ae ky" href="https://medium.com/swlh/4-simple-libraries-to-quickly-benchmark-python-code-8d3dfd288d7a" rel="noopener"> 4简单库，快速测试Python代码</a>文章，创建一个高效的Python开发工作流。</p></div></div>    
</body>
</html>