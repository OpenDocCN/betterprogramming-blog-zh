<html>
<head>
<title>Code Structuring and Error Handling in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的代码结构和错误处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/node-js-best-practices-structuring-and-error-handling-ebcf24c85547?source=collection_archive---------7-----------------------#2020-03-02">https://betterprogramming.pub/node-js-best-practices-structuring-and-error-handling-ebcf24c85547?source=collection_archive---------7-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e6b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">节点最佳实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7418a89b47cf42f2f5a7d7349238ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sLuvOVfjtQac-cJ7yfOiYQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Clem Onojeghuo 在<a class="ae ky" href="https://unsplash.com/s/photos/structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量的应用程序。为了使维护它们变得更容易，我们必须为人们设置一些遵循的准则。</p><p id="7477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解编写Node.js应用程序时的一些基本最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="303a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">按组件构建解决方案</h1><p id="6a42" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个节点应用程序的代码应该像任何其他类型的应用程序一样被分成组件。大代码文件很难阅读和搜索。做任何事情也需要大量的滚动。</p><p id="9ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，我们可以将代码分成模块。Node.js支持常见的js和ES模块，因此我们可以选择如何将文件组织到模块中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0881" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将组件分层并在其边界内保持Express</h1><p id="1834" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个组件都应该包含层。它应该有单独的文件专门用于端点、幕后逻辑和数据访问代码。</p><p id="b5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关注点的清晰分离很容易模拟和测试。我们不应该将请求和响应对象传递到逻辑和数据访问层，因为这使得我们的代码在任何地方都依赖于它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b5e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将常用实用程序包装为npm包</h1><p id="5d37" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Npm包是有用的发布库，可以像loggers、encryption等一样在任何地方重用。如果我们写了自己的解决方案。这样，我们可以在任何地方分享它们，并在任何需要的应用程序中使用它们。</p><p id="a1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们不必公开，所以我们不必担心暴露任何我们不想暴露的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="41d9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将Express“应用程序”和“服务器”分开</h1><p id="9439" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们应该将<code class="fe mz na nb nc b">app</code>对象与<code class="fe mz na nb nc b">server</code>入口点分开。这样，我们可以通过直接调用它们来测试控制器代码，而不是被迫通过调用HTTP调用来测试。</p><p id="7005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过HTTP调用从测试中获取覆盖率报告要困难得多，而且速度也较慢。拥有大的代码文件也不好，因为它们很难阅读。</p><p id="666e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以将<code class="fe mz na nb nc b">app</code>与入口点分开，如下所示:</p><p id="269b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">index.js</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f9be" class="nh md it nc b gy ni nj l nk nl">const app = require('./app');<br/>const http = require('http');<br/>app.set('port', 3000);<br/>const server = http.createServer(app);<br/>server.listen();</span></pre><p id="2a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">app.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dc40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们在<code class="fe mz na nb nc b">app.js</code>而不是<code class="fe mz na nb nc b">index.js</code>中创建了Express <code class="fe mz na nb nc b">app</code>对象。我们导出最后一行中的<code class="fe mz na nb nc b">app</code>对象。</p><p id="6d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们在<code class="fe mz na nb nc b">index.js</code>中导入它，用<code class="fe mz na nb nc b">app</code>调用<code class="fe mz na nb nc b">http.createServer</code>来创建HTTP服务器。最后，我们在它上面调用<code class="fe mz na nb nc b">listen</code>来监听请求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f780" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用环境感知和安全配置</h1><p id="8521" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们从环境变量中读取应用程序的配置。例如，<code class="fe mz na nb nc b">dotenv</code> npm包是从<code class="fe mz na nb nc b">.env</code>文件和操作系统的环境变量中读取环境变量的好方法。</p><p id="2693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下使用<code class="fe mz na nb nc b">dotenv</code>从<code class="fe mz na nb nc b">.env</code>文件中获取配置，然后如下检索它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将把配置从<code class="fe mz na nb nc b">env</code>文件加载到<code class="fe mz na nb nc b">process.env</code>，因为我们已经:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c141" class="nh md it nc b gy ni nj l nk nl">require('dotenv').config()</span></pre><p id="eea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以在任何地方随心所欲地使用这些值。鉴于<code class="fe mz na nb nc b">.env</code>已经:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b683" class="nh md it nc b gy ni nj l nk nl">DB_HOST=localhost<br/>DB_USER=root<br/>DB_PASS=s1mpl3</span></pre><p id="00b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会得到:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9cdc" class="nh md it nc b gy ni nj l nk nl">{ <br/>  "NODE_VERSION":"10.17.0",<br/>  "HOSTNAME":"813e55f05734",<br/>  "YARN_VERSION":"1.19.1",<br/>  "HOME":"/home/runner",<br/>  "PATH":"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",<br/>  "NODE_PATH":"/usr/local/lib/node_modules:/home/runner/node_modules",<br/>  "PWD":"/home/runner",<br/>  "TERM":"xterm-256color",<br/>  "DB_HOST":"localhost",<br/>  "DB_USER":"root",<br/>  "DB_PASS":"s1mpl3"<br/>}</span></pre><p id="4d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为<code class="fe mz na nb nc b">process.env</code>的值。</p><p id="c1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还支持从其他文件和操作系统的环境变量列表中加载配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/1bead401544095b50268030bc6070e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XIBDXg9y5UzBuVun"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">桑迪·米勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d950" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用async-await或Promises进行异步错误处理</h1><p id="c064" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">回调地狱绝对是我们想要避免的。因此，如果我们必须将多段异步代码链接在一起，我们应该使用promises或者它的简写，<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>。</p><p id="e22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以通过写下以下内容来使用承诺来捕捉错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以编写以下代码来做同样的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="098e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个例子都通过顺序运行异步代码来链接它们。它们每一个都依赖于前一个的值，所以我们别无选择，只能把它们链起来。</p><p id="593a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用承诺或<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>使这变得容易。在这两个例子中，我们都有<code class="fe mz na nb nc b">catch</code>来捕捉错误。他们只是位于不同的地方。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9906" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4d0a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有一些简单的方法可以清理Node.js代码。我们应该将大块代码分成小模块。此外，我们应该通过使用承诺或<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>来消除回调嵌套。</p><p id="c0c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将环境变量存储在一个安全的位置，并通过库获取它们。</p></div></div>    
</body>
</html>