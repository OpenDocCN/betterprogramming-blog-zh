<html>
<head>
<title>Make an NFT Minter on the NEAR Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在近距离协议上做一个NFT Minter</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-an-nft-minter-on-the-near-protocol-56ac3c5c1f45?source=collection_archive---------6-----------------------#2022-02-04">https://betterprogramming.pub/make-an-nft-minter-on-the-near-protocol-56ac3c5c1f45?source=collection_archive---------6-----------------------#2022-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9fda" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用rust在NEAR协议上创建NFT</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/05e0c0385330b2d4cd6a96cfe131bf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU4OoD2Ql03WEo3L8Bm_0Q.jpeg"/></div></div></figure><h2 id="646f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">介绍</h2><p id="8490" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">NFT或不可替换令牌是具有关联元数据的唯一令牌。NFTs不能用别的东西代替。它们可以被购买，并且喜欢加密货币。在本指南中，我们将为near协议创建一个智能合同，以创建NFT。</p><h2 id="0511" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是近协议？</h2><p id="ae17" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><a class="ae mg" href="https://near.org/" rel="noopener ugc nofollow" target="_blank">近协议</a>是新一代的第1层区块链，它解决了交易速率慢、吞吐量有限和兼容性差等问题。它是基于惊人的分片概念开发的，这意味着当网络利用率高时，节点会被分割成更小的分片，并在这些分片上进行并行计算。这个网络可以根据高需求进行自我扩展。</p><h2 id="7bd1" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">先决条件</h2><p id="39dc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">来创建我们需要的近乎智能的契约。</p><ul class=""><li id="0907" class="mh mi iq lp b lq mj lt mk la ml le mm li mn mf mo mp mq mr bi translated"><strong class="lp ir"> Rust — </strong> Rust是一种高性能通用编程语言，我们将使用它来创建一个智能合同。有一本非常好的<a class="ae mg" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">书</a>可供学习铁锈。</li><li id="5017" class="mh mi iq lp b lq ms lt mt la mu le mv li mw mf mo mp mq mr bi translated"><a class="ae mg" href="https://docs.near.org/docs/tools/near-cli" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">Near CLI</strong></a><strong class="lp ir">——</strong>命令行界面，用于与Near区块链连接和交互。</li><li id="4ad7" class="mh mi iq lp b lq ms lt mt la mu le mv li mw mf mo mp mq mr bi translated"><strong class="lp ir">近距离钱包— </strong>在开始我们的项目之前，我们需要一个近距离钱包。查看本<a class="ae mg" href="https://docs.near.org/docs/develop/basics/create-account" rel="noopener ugc nofollow" target="_blank">指南</a>了解如何设置近距离钱包。</li></ul><h2 id="e511" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">设置</strong></h2><p id="7085" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">首先，创建一个货物项目。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7043" class="kr ks iq my b gy nc nd l ne nf">cargo new nft --lib</span></pre><p id="6fa8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">转到项目文件夹nft你会看到。<br/> <code class="fe nj nk nl my b"><strong class="lp ir">src/lib.rs </strong></code> <strong class="lp ir"> — </strong>这是我们将要编写智能合同的地方<br/> <code class="fe nj nk nl my b"><strong class="lp ir">Cargo.toml </strong></code> <strong class="lp ir"> — </strong>这是我们的项目配置文件</p><p id="0f05" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">前往<code class="fe nj nk nl my b">cargo.toml</code>并添加</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a8fc" class="kr ks iq my b gy nc nd l ne nf">[lib]<br/>crate-type = ["cdylib", "rlib"]</span><span id="ec6a" class="kr ks iq my b gy nm nd l ne nf">[dependencies]<br/>near-sdk = "*"<br/>near-contract-standards = "*"</span></pre><h2 id="f9c5" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">入门</strong></h2><p id="feed" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">让我们从我们的智能合同脚手架开始。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a18b" class="kr ks iq my b gy nc nd l ne nf">use near_sdk::{<br/>    near_bindgen,<br/>    borsh::{self, BorshDeserialize, BorshSerialize}<br/>};</span><span id="4bd0" class="kr ks iq my b gy nm nd l ne nf">near_sdk::setup_alloc!();</span><span id="9eff" class="kr ks iq my b gy nm nd l ne nf">#[near_bindgen]<br/>#[derive(BorshDeserialize, BorshDeserialize)]<br/>pub struct Contract {}</span><span id="f129" class="kr ks iq my b gy nm nd l ne nf">#[near_bindgen]<br/>impl Contract {}</span></pre><p id="fb77" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">这看起来像一个奇怪的代码，现在什么也不做，让我们简化它。NEAR遵循有状态方法，因此struct Contract将保存我们的契约状态，而在实现契约中，我们将编写更改状态的函数。</p><p id="3ae9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">这里要注意的一点是，我们实现了一些宏并派生了一些特征。<code class="fe nj nk nl my b">#[near_bindgen]</code>宏将状态转换成有效形式，以便在近链上运行。<code class="fe nj nk nl my b">BorshDeserialize</code>、<code class="fe nj nk nl my b">BorshDeserialize</code>是来自<a class="ae mg" href="https://borsh.io/" rel="noopener ugc nofollow" target="_blank"> borsh </a>机箱的特征，用于状态的反序列化和序列化。</p><p id="93e8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">现在，让我们为NFT创建我们的州。您知道，NFT是一个唯一的令牌和与之相关联的元数据。根据这个定义，我们的状态看起来像这样。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="5e50" class="kr ks iq my b gy nc nd l ne nf">use near_contract_standards::non_fungible_token::{<br/>    metadata::NFTContractMetadata, NonFungibleToken,<br/>};</span><span id="430c" class="kr ks iq my b gy nm nd l ne nf">pub struct Contract {<br/>    token: NonFungibleToken,<br/>    metadata: LazyOption&lt;NFTContractMetadata&gt;,<br/>}</span></pre><p id="1b64" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">现在，这个状态总是需要一个默认值，所以我们需要一个初始化函数来设置默认状态。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ee39" class="kr ks iq my b gy nc nd l ne nf">#[derive(BorshSerialize, BorshStorageKey)]<br/>pub enum StorageKey {<br/>    NonFungibleToken,<br/>    Metadata,<br/>    TokenMetadata,<br/>    Enumeration,<br/>    Approval<br/>}</span><span id="7af0" class="kr ks iq my b gy nm nd l ne nf">#[near_bindgen]<br/>impl Contract {<br/>    #[init]<br/>    pub fn new(owner_id: ValidAccountId) -&gt; Self {<br/>        Self {<br/>            token: NonFungibleToken::new(<br/>                StorageKey::NonFungibleToken,<br/>                owner_id,<br/>                Some(StorageKey::TokenMetadata),<br/>                Some(StorageKey::Enumeration),<br/>                Some(StorageKey::Approval)<br/>             ),<br/>             metadata: LazyOption::new(<br/>                StorageKey::Metadata,<br/>                Some(&amp;NFTContractMetadata {<br/>                    spec: NFT_METADATA_SPEC.to_string(),<br/>                    name: "Example Name".to_string(),<br/>                    symbol: "Example".to_string(),<br/>                    icon: Some("ANY_SVG".to_string()),<br/>                    base_uri: None,<br/>                    reference: None,<br/>                    reference_hash: None,<br/>                 })<br/>             ),<br/>        }<br/>    }<br/>}</span></pre><p id="934b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">带有#[init]宏的函数将总是首先执行。通常用于设置默认状态。对于令牌标准和元数据标准，我推荐检查<a class="ae mg" href="https://nomicon.io/Standards/NonFungibleToken/Core.html" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae mg" href="https://nomicon.io/Standards/NonFungibleToken/Metadata.html" rel="noopener ugc nofollow" target="_blank">这个</a>链接。</p><p id="5b5c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">现在，一切都为我们的初始化器和状态设置好了。让我们制作NFT铸造函数。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ad21" class="kr ks iq my b gy nc nd l ne nf">impl Contract {<br/>    <br/>    ......<br/>    <br/>    #[payable]    <br/>    pub fn nft_mint(<br/>        &amp;mut self,<br/>        token_id: TokenId,<br/>        receiver_id: ValidAccountId,<br/>        token_metadata: TokenMetadata,<br/>    ) -&gt; Token {<br/>        self.token.mint(token_id, receiver_id, Some(token_metadata))<br/>    }<br/>}</span></pre><p id="bcd7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">让我们将它部署到链中。运行以下命令进行构建:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="54c2" class="kr ks iq my b gy nc nd l ne nf">cargo build --target wasm32-unknown-unknown --release</span></pre><p id="b809" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">运行以下命令进行部署:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a15f" class="kr ks iq my b gy nc nd l ne nf">near deploy --wasmFile target/wasm32-unknown-unknown/release/nft.wasm --accountId "your near account username"</span></pre><p id="2133" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv la ng lx ly le nh ma mb li ni md me mf ij bi translated">这将返回一个程序id，可用于调用智能合约的RPC。您可以使用near CLI或javascript客户端与合同进行交互。</p></div></div>    
</body>
</html>