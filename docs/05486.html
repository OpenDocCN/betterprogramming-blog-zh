<html>
<head>
<title>How to Use useDrag With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将useDrag与React一起使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-usedrag-with-react-134b02b58da3?source=collection_archive---------3-----------------------#2020-07-13">https://betterprogramming.pub/how-to-use-usedrag-with-react-134b02b58da3?source=collection_archive---------3-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a196" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">因为非交互性是一种阻力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9704ad47ecd687cf0b05305a95d8455e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTy5t4TN8frd1DSntHmb6Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">保罗·基亚布兰多在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/finger-painting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a84e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">拖放式</h1><p id="5d04" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">谁不记得自己第一次在手机上重新整理app是什么时候？应用程序图标满天飞。然而，不知何故，它们神奇地排列成整齐的行和列。如今，这种体验是默认的。人们几乎不会注意到它。当首次推出时，它是最先进的，甚至令人瞠目结舌。早在智能手机出现之前，拖放就是一个众所周知的概念。但随着触摸界面的引入，它成为了一个广为人知的现象。</p><p id="a6ef" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对虚拟拖拽有一定的感觉。事物变得有形。能够在屏幕上主动移动项目是一种令人愉快的感觉。不是所有的用例都是实用的。工作的人肯定有他们的位置。例如，拖放上传就是一个很好的模式。</p><p id="f6be" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这篇文章着眼于向另一个流行的模式添加拖动功能，即<em class="mz">开关</em>，也称为<em class="mz">切换</em>。向开关添加阻力可能不是特别有用。不过，有时将概念开玩笑地结合起来是有益的。即使最终结果并不那么有价值，其他有趣的结论也可能会出现。本文讨论的演示是由奥列格·弗罗洛夫拍摄的<a class="ae ky" href="https://dribbble.com/shots/5429846-Switcher-XLIV" rel="noopener ugc nofollow" target="_blank">可滴镜头的翻拍。这是最终结果的视频:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">useDrag切换的视频</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="498f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">useDrag库</h1><p id="ec69" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe nc nd ne nf b">useDrag</code>是<a class="ae ky" href="https://github.com/react-spring/react-use-gesture" rel="noopener ugc nofollow" target="_blank">反应-使用-手势</a>库的一部分。这是一个丰富的反应手势库。一定要去看看，因为这里有一些有用的例子和代码。</p><p id="2684" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们开始吧！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e779" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">纯反应组分</h1><p id="6c1a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先要做的是创建一个纯React功能组件。当使用React组件时，开始考虑组件应该有什么属性和状态几乎总是一个好主意。总会有某种输入或输出和/或状态。这个特定的组件需要知道触发器是否被切换。让我们加入一个状态和一些虚拟内容来开始吧。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4c24" class="nk lh it nf b gy nl nm l nn no">function Toggle() {<br/>  const [toggled, setToggled] = useState(false);</span><span id="a689" class="nk lh it nf b gy np nm l nn no">  return (&lt;div&gt;TOGGLE GOES HERE&lt;/div&gt;)<br/>}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="828e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">反作用弹簧</h1><p id="5125" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">方式<code class="fe nc nd ne nf b">useDrag works</code>，或者说<code class="fe nc nd ne nf b">useGesture</code>，是它建立在另一个叫做<a class="ae ky" href="https://www.react-spring.io/" rel="noopener ugc nofollow" target="_blank"> react-spring </a>的库之上。react-use-gesture库可以独立工作——您不必将两者结合起来。然而，当您结合使用它们时，您可以获得最大的收益。React-spring是一个基于spring物理的动画库。它很好地集成到React中，并允许制作非常精细的动画。</p><p id="77e2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你以前没有用过react-spring，可能会有点混乱。动画部分隐藏在<code class="fe nc nd ne nf b">useSpring</code>调用的后面。这种结构在开始时可能会感觉有点落后。然而，一旦你习惯了反作用力弹簧的做事方式，它会变得非常强大。作为库的用户，你不需要担心动画的内部工作。相反，您可以专注于将哪些样式属性连接到哪些返回值。这些值被称为<em class="mz">道具</em>。这些都可以作为道具(因此得名)传递给任何标记。例如，它可能是您想要连接到旋转动画的图像。在这篇文章中，我们正在寻找一个旋钮，我们想动画水平。</p><p id="2447" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是使用<code class="fe nc nd ne nf b">useSpring</code>时的事件链:</p><ul class=""><li id="e664" class="nq nr it ma b mb mu me mv mh ns ml nt mp nu mt nv nw nx ny bi translated">我们从调用<code class="fe nc nd ne nf b">useSpring</code>钩子开始。该函数返回一组更新的动画值。这里的“更新”是指与动画当前所在的帧相对应的值。<code class="fe nc nd ne nf b">useSpring</code>将保持钩子内部的状态。</li><li id="43be" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">如果动画属性没有期望的行为，它们可以再次被调整，或者用技术术语来说，被插值。这可能是遵循不同的轨迹，不同的行为，或者你有什么。</li><li id="4965" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">这些值通过CSS-in-JS注入到样式中。</li><li id="a369" class="nq nr it ma b mb nz me oa mh ob ml oc mp od mt nv nw nx ny bi translated">样式规则最终通过style/className属性应用于标记。</li></ul><p id="ade0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">另一个关键部分是组件的重新呈现。为了让任何东西在屏幕上移动，React元素需要在整个动画期间更新自己。这一部分可能会增加混乱，因为所有这些都发生在引擎盖下。</p><p id="45c9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们将在下一节研究<code class="fe nc nd ne nf b">useDrag</code>。现在，让我们看看如何让<code class="fe nc nd ne nf b">useSpring</code>就位。本教程使用了接受函数作为参数的<code class="fe nc nd ne nf b">useSpring</code>版本。挂钩有不同的版本。这种差异非常微妙，很难发现。根据您传递的参数不同，这些变量的行为会有所不同。更高级的选项，我们在这里使用的，返回一个名为<em class="mz"> set </em>的更新函数。通过回调，组件自己决定何时触发其视图元素的移动。在这种情况下，我们希望当用户点击开关时，旋钮会显示动画。</p><p id="b831" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><em class="mz"> x </em>是水平平移值。当样式应用于标记时，react-spring将这个<em class="mz"> x </em>值转换为CSS翻译转换。注意:这只适用于react-spring的第9版。在写这篇文章的时候，版本9还不是官方的，它在next标签下。最后但同样重要的是，我们还需要初始化<em class="mz"> x </em>值。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="ca84" class="nk lh it nf b gy nl nm l nn no">const [{ x }, set] = useSpring(() =&gt; ({<br/>  x: 0,<br/>}));</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c041" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第一部分。一个简单的开关</h1><p id="cdff" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们想逐步建立这个东西，以获得它的感觉。因此，让我们从根本上打破这种束缚。一个开关，最简单的形式是一个背景和一个旋钮。对这两个部分建模的最快方法是使用矩形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/46e585bbd8d3f746491b3a507ff5cb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9fI3HH0Sdmy86J67HVinw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单切换模型</p></figure><p id="b5d1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下面是CSS-in-JS中的样式:一个较大的矩形和一个较小的正方形。背景是浅灰色，手柄是深灰色。注意进入<code class="fe nc nd ne nf b">knobStyle</code>的<em class="mz"> x </em>。如上所述，将<code class="fe nc nd ne nf b">useSpring</code>返回值注入到样式中可以实现动画。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4bb5" class="nk lh it nf b gy nl nm l nn no"><br/>const backgroundStyle = {<br/>  backgroundColor: "#ddd",<br/>  cursor: "pointer",<br/>  height: 50,<br/>  width: 100,<br/>};</span><span id="ddc2" class="nk lh it nf b gy np nm l nn no">const knobStyle = {<br/>  x,<br/>  backgroundColor: "#444",<br/>  height: 50,<br/>  width: 50,<br/>};</span></pre><p id="8df9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下面是相应的标记。为了让react-spring工作，JSX元素需要以animated关键字为前缀。下面的旋钮使用了一个动画div，因为我们希望它以<em class="mz"> x </em>平移值向侧面移动。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="0397" class="nk lh it nf b gy nl nm l nn no">&lt;div // Background<br/>  style={backgroundStyle}<br/>&gt;<br/>  &lt;animated.div // Knob<br/>    style={knobStyle}<br/>  &gt;&lt;/animated.div&gt;<br/>&lt;/div&gt;</span></pre><p id="701d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">现在我们有了代码，我们只差一个触发器了。一个简单的<code class="fe nc nd ne nf b">onClick</code>处理程序就能搞定。注意我们都需要更新状态和触发动画。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="98db" class="nk lh it nf b gy nl nm l nn no">&lt;div // Background<br/>  style={backgroundStyle}<br/>  onClick={() =&gt; {<br/>    set({ x: toggled ? 0 : 50 });<br/>    setToggled(!toggled);<br/>  }}<br/>&gt;<br/>  ...<br/>&lt;/div&gt;</span></pre><p id="c523" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是我们目前掌握的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/4959d4da5cdada414a1edcb08dd82e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Pm1knhaf6e1ONW3BoWLZEA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轻敲开关</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c891" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第二部分。移动到useDrag</h1><p id="9f1e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，是时候把<code class="fe nc nd ne nf b">useDrag</code> <em class="mz"> </em>扔进等式里了。由于切换已经开始工作，所以从tap开始比较合适。点击是<code class="fe nc nd ne nf b">useDrag</code>功能集的一部分。这是它的返回值之一。下面是调用钩子的代码:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="820d" class="nk lh it nf b gy nl nm l nn no">const bind = useDrag(({ down, tap }) =&gt; {<br/>  if (!down &amp;&amp; tap) {<br/>    set({ x: toggled ? 0 : RANGE });<br/>    setToggled(!toggled);<br/>  }<br/>});</span></pre><p id="d508" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">处理程序看起来非常相似。这与用于调用set函数和设置状态是一样的。不过，与之前的版本相比，还是有一点小小的不同。由于拖动处理程序是有状态的，我们需要查看状态变量<code class="fe nc nd ne nf b">down</code>和<code class="fe nc nd ne nf b">tap</code>。这两个参数将确保用户通过<code class="fe nc nd ne nf b">down</code>变量释放触摸，并且足够短(即短到足以被认为是轻击)。如果是这种情况，那么<code class="fe nc nd ne nf b">tap</code>变量被设置为<code class="fe nc nd ne nf b">true</code>。同样，就像动画一样，我们需要将拖动处理程序应用到React节点。这就是绑定函数的用途。下面是我们如何通过传播它的返回值将它应用到节点:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="ba3f" class="nk lh it nf b gy nl nm l nn no">&lt;animated.div // Knob<br/>  style={knobStyle}<br/>  {...bind()}<br/>&gt;&lt;/animated.div&gt;</span></pre><h2 id="2d7b" class="nk lh it bd li og oh dn lm oi oj dp lq mh ok ol ls ml om on lu mp oo op lw oq bi translated">伸出旋钮</h2><p id="b4b4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在这个阶段，我们只能通过实际点击旋钮本身来操作开关。这更符合真实(就像在现实生活中)开关的工作方式。虚拟开关允许用户点击后台的任何地方进行切换。它们实际上更加用户友好。一个简单的技巧是让底部容器看起来对触摸有反应。我们可以通过在透明区域的两侧延伸旋钮来做到这一点。将旋钮包装在一个更大的、不可见的包含div中解决了这个问题。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f5a4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第三部分。拖延的</h1><p id="419b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">为了让拖拽工作起来，我们需要改变我们更新react-spring的方式。它需要持续，而不是像我们现在这样。目前，唯一触发移动的是当用户释放触摸时触发的独立事件。为了使它流畅，我们想在每次用户水平拖动旋钮时设置<em class="mz"> x </em>值。这就是拖动处理程序的美妙之处。它让我们改变每一帧的外观。方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nb l"/></div></figure><p id="ece0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里发生了一些事情。</p><p id="781a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">首先，在点击处理程序和新的拖动逻辑之间有一个分离。在编码时，关注点分离几乎总是一个好主意。注意结束tap处理程序的return语句。它确保两个处理程序不会同时运行。</p><p id="e150" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">其次，对于用户释放触摸的情况，存在阈值逻辑。如果用户中途释放旋钮，我们希望旋钮动画化到它的一个极端，也就是说，我们希望将切换设置为完全打开或关闭。为了实现这一点，我们将<em class="mz"> x </em>位置设置为我们希望旋钮结束的位置，即使这可能会导致数值跳变。这是因为在最后一次释放触摸后不再有帧。动画库将优雅地将旋钮动画到开始或结束位置。</p><p id="80f3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们在这里看到的第三种情况是拖动本身。如果用户拖动，我们传递的是视图上的<em class="mz"> x </em>值，以相等的量移动手柄，即，与前一帧相比，对应于用户移动手指的量。</p><p id="bccd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">另一件需要注意的事情是我们添加到<code class="fe nc nd ne nf b">useDrag</code>调用中的配置。该配置做两件事。首先，它设定了界限。这将保持旋钮在适当的位置，防止它误入歧途。其次，它初始化了价值。如果动画中断，需要后一部分来重新启动拖动会话。如果是这样，我们希望旋钮从其当前位置开始，而不是从其极端位置开始。你可以在这里阅读更多关于<code class="fe nc nd ne nf b"><a class="ae ky" href="https://use-gesture.netlify.app/docs/options/#initial" rel="noopener ugc nofollow" target="_blank">initial</a></code> <a class="ae ky" href="https://use-gesture.netlify.app/docs/options/#initial" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> </em>配置的信息</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f8bd3f9f5f1a1be9d4c3a5c72d7bfb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bFs8XnNpKhOdfhiYr5035A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拖动并点击开关</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4de1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第四部分。橡皮带</h1><p id="ee13" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">橡皮筋总是很可爱。它增加了取悦用户的魅力时刻。要启用它，只需在配置中添加以下内容:</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="ebe9" class="nk lh it nf b gy nl nm l nn no">{<br/>  ...<br/>  bounds: ...,<br/>  rubberband: true,<br/>}</span></pre><p id="6d1e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您想要对rubberbanding进行更细粒度的控制，您可以自己实现。作为一个练习，我已经在下面演示的源代码中实现了它。我使用下面的平方加速算法。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="924b" class="nk lh it nf b gy nl nm l nn no">const RB_RANGE = 5;<br/>const rubberband = (x) =&gt;<br/>  x &gt; RB_RANGE ? RB_RANGE : RB_RANGE * (x / RB_RANGE) * (x / RB_RANGE);</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8aa0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第五部分。让它发光</h1><p id="8eaf" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">有了模型，很容易加入一些CSS来突出整个事情。只是增加圆角使开关更值得信赖。我通过使用剪辑路径变形和添加一点颜色，进一步调整了演示和可滴镜头。我不会在这里详细讨论造型。有关CSS动画的更多信息，请参考下面的源代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d46a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">第六部分。源代码</h1><p id="ba62" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这是Codepen上的完整源代码</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os nb l"/></div></figure><p id="1e51" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你做到了这一步，感谢你的阅读，祝你好运！</p><p id="cfe7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">干杯，<br/>米凯尔</p></div></div>    
</body>
</html>