<html>
<head>
<title>Solidity: Playing With Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实:玩弄琴弦</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-playing-with-strings-aca62d118ae5?source=collection_archive---------4-----------------------#2020-09-28">https://betterprogramming.pub/solidity-playing-with-strings-aca62d118ae5?source=collection_archive---------4-----------------------#2020-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="91bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开始使用可靠性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/925e72aca01859b3d687da90cf2cbdcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O8QzLOh7HE65dAcX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@martimbraz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马蒂姆·布拉兹</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d46a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字符串代表了每一种编程语言的核心，因为你知道，计算机经常与人交互。因此，处理字符串是任何语言中最先开发的功能之一。此外，第一个测试传统上是<a class="ae kv" href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program" rel="noopener ugc nofollow" target="_blank">打印字符串</a>“Hello，world！”</p><p id="37f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.1/" rel="noopener ugc nofollow" target="_blank">扎实</a>也不例外。它有对字符串的本地支持，但它们的使用仍然不像在JavaScript、Python或Java等高级语言中那样完整。例如，开箱即用，Solidity不提供比较或连接字符串的本地方式。然而，文档为两个依赖于<code class="fe ls lt lu lv b">abi.encodePacked()</code>(我们将在后面讨论)比较两个字符串的函数提供了一个有效的解决方案:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e2d4" class="ma mb iq lv b gy mc md l me mf">keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2)) </span></pre><p id="e535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要连接两个字符串:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d284" class="ma mb iq lv b gy mc md l me mf">abi.encodePacked(s1, s2)</span></pre><p id="75f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解这两个简单函数的内部机制，像往常一样，我们将使用一个简单的玩具实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2e03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像往常一样，使用<a class="ae kv" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix </a>就可以舒服地玩了。编译完成后，您将能够直接从接口调用这两个方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/34c9aa811a13f0bd1655a52141fff652.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*k6IRXJWuwfXlsLCRYCxwtw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">调用方法的接口。</p></figure><p id="4973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用这两个方法将签署一个包含对传递参数的方法的调用的事务。执行字符串串联后，事务的输出显示在控制台窗口中(要完整显示结果，请记住单击右侧的小箭头):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/f8f9b969c0fa6497736ef9c7502e90f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ag33gEYo7UbBUBr9zQJOw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“连接”方法的执行。</p></figure><p id="74d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个简单实现的核心是函数<code class="fe ls lt lu lv b">abi.encodePacked()</code>，它执行作为参数传递的变量的紧密打包。在下图中(取自<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#non-standard-packed-mode" rel="noopener ugc nofollow" target="_blank">文档</a>，您可以看到每个参数的位是如何在输出中简单地连接起来的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/2f4f5c357535fdd63855d4b6b842574e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*svUelXdjHOadeiHo03gELA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">传递给encodePacked的参数实际上是如何打包的示例。</p></figure><p id="c9fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种编码中有趣的一点是<em class="ml">天生模糊</em>，所以没有办法解码。在下面的代码中，我们简单地通过比较两组不同字符串的编码来测试这种模糊性。通过就地打包，两次调用将返回精确的字节序列，因为两次调用都将返回字符串<code class="fe ls lt lu lv b">"aab"</code>，而不考虑输入字符串的不同长度:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="135e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于其气体效率，通过使用<code class="fe ls lt lu lv b">keccak256()</code>来比较编码的结果在可靠性方面是一种常见的方法。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="2319" class="mt mb iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="9a37" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">基本的字符串操作不是由Solidity本身提供的，而是通过对一些本机和有效使用的非常标准化的使用提供的。</p><p id="7d0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有更复杂的字符串<a class="ae kv" href="https://github.com/willitscale/solidity-util" rel="noopener ugc nofollow" target="_blank">操作</a> <a class="ae kv" href="https://github.com/Arachnid/solidity-stringutils" rel="noopener ugc nofollow" target="_blank">库</a>可用。甚至还有一个JSON解析器库。</p><p id="981c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我个人的建议是这种操控尽量低。给用户的消息、复杂的JSON操作等。应该远离区块链。区块链应该被视为一个专门的后端，其性能依赖于所涉及的每个变量的表示。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="21d0" class="mt mb iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">参考</h1><ol class=""><li id="14df" class="np nq iq ky b kz nk lc nl lf nr lj ns ln nt lr nu nv nw nx bi translated"><a class="ae kv" href="https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#non-standard-packed-mode" rel="noopener ugc nofollow" target="_blank">坚固性7.1文档</a></li><li id="9673" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><a class="ae kv" href="https://github.com/Arachnid/solidity-stringutils" rel="noopener ugc nofollow" target="_blank">String&amp;slice utility library for Solidity</a></li><li id="c3d8" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><a class="ae kv" href="https://github.com/willitscale/solidity-util" rel="noopener ugc nofollow" target="_blank">坚固性标准实用程序</a></li></ol></div></div>    
</body>
</html>