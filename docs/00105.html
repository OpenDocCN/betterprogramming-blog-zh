<html>
<head>
<title>Is JavaScript Synchronous or Asynchronous? What the Hell is a Promise?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript是同步的还是异步的？承诺到底是什么？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-javascript-synchronous-or-asynchronous-what-the-hell-is-a-promise-7aa9dd8f3bfb?source=collection_archive---------0-----------------------#2018-02-25">https://betterprogramming.pub/is-javascript-synchronous-or-asynchronous-what-the-hell-is-a-promise-7aa9dd8f3bfb?source=collection_archive---------0-----------------------#2018-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2e8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习在单线程环境中工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/95727539f53013d4077c00df203b36fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iz3Mf5g491dTwmHNj_YFFw.jpeg"/></div></div></figure><p id="2d1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为人，我们喜欢结构。我们喜欢分类、描述，并把我们知道的一切放进整洁的小盒子里。这也是我一开始觉得JavaScript如此令人困惑的原因。是脚本语言还是编程语言？是用在前端还是后端？</p><p id="2c28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript的奇妙之处在于，大多数时候，两者都有一点。多年来，JavaScript发展如此之快，以至于很难归类。今天，我将深入探讨JavaScript是同步的还是异步的，以及幕后的工作流是什么样子的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1d46" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">JavaScript是同步的</h1><p id="d256" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">剧透:从根本上说，JavaScript是一种同步、阻塞、单线程语言。这仅仅意味着一次只能进行一个操作。然而，这还不是故事的全部！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/148bcb3d89c968ca1fee5f1dd0159208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeTnKC6L2eMHj9ICv4k4Eg.jpeg"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图片由Aleks Shineleva提供</p></figure><p id="7cb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您必须发出一个昂贵的数据库请求，该怎么办？当PG和Postgres为你的音乐库抓取800首你需要的歌曲时，你不会想无所事事。同步代码让程序员的生活变得非常困难，因此JavaScript社区开发了一些很好的解决方法。</p><p id="7ad3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你听到人们说JavaScript是一种异步语言时，他们的意思是你可以操纵JavaScript以异步的方式让<em class="mz">表现</em>。不是烤进去的，但是有可能！以下是实现这一点的几种方法:</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="b71b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">异步回调</h1><p id="ee4e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">陷入同步世界的最早和最直接的解决方案是使用异步回调(想想<code class="fe na nb nc nd b">setTimeout()</code>)。</p><p id="6675" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以数据库请求为例:异步回调允许您调用回调函数，该函数将数据库请求(以及任何其他嵌套的回调)发送到您的应用程序，在应用程序中等待来自数据库的响应，从而释放您的代码的其余部分以继续运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/1ca91ac84f43e967b53bfa14dbc6a2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iOmFwC3PWUD8RFLsxzBXQ.jpeg"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图片由Aleks Shineleva提供</p></figure><p id="f6ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦数据库请求完成，结果(和任何其他嵌套代码)将被发送到队列，然后通过事件循环进行处理。</p><p id="6ca6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里的图表中，您可以看到它与同步代码的不同之处。函数C与E、F和G一起被发送到浏览器、队列和事件循环。</p><blockquote class="ne nf ng"><p id="873b" class="ku kv mz kw b kx ky ju kz la lb jx lc nh le lf lg ni li lj lk nj lm ln lo lp im bi translated">如果你想对这一过程有一个精彩、清晰的解释，可以看看菲利普·罗伯茨的演示。</p></blockquote><p id="b65f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这是一个很好的解决方案，但它仍有不足之处。由于您无法准确预测函数C何时解析，因此您必须在其中嵌套所有依赖函数。这很快变得一团糟，并导致无人愿意处理的臭名昭著的回调地狱。正是这种环境激发了这种希望。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="75d3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">承诺</h1><p id="21ee" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">为了处理回调地狱，像Bluebird或Q这样的库允许程序员清理他们的语法并编写异步操作但看起来同步的代码。这使得代码更容易阅读，运行速度更快。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/ce524490aa63dac96caf57ffb9532b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nz9FpTpmWO8yi39PFvkQbg.jpeg"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图片由Aleks Shineleva提供</p></figure><p id="60e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了承诺，我们就能够将它们分离出来，而不是将所有依赖项捆绑到一个代码块中，然后将整个代码块发送给浏览器。</p><p id="760f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将异步回调(函数C)发送到浏览器，并使用<code class="fe na nb nc nd b">.then()</code>将所有其他依赖项(E、F和G)放在一边，只在函数C返回并运行时运行它们。</p><p id="4c50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这允许我们以更模块化、可读性更强的方式编码，同时仍然获得异步编程的好处。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="56d4" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">异步/等待</strong></h1><p id="1171" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">承诺是奇妙的——事实上如此奇妙，以至于ES6将它们作为一种标准引入到语言中。但是使用promises仍然会让异步代码感觉有点不可靠，所以我们现在有了漂亮的Async/Await来帮助我们！</p><p id="617b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很多关于Async/Await的博客文章和书籍(我确定),所以我不会深入探讨，但可以说Async/Await允许您:</p><ul class=""><li id="7e7b" class="nl nm it kw b kx ky la lb ld nn lh no ll np lp nq nr ns nt bi translated">继续使用承诺</li><li id="6754" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">编写看上去和感觉上同步的异步代码</li><li id="052b" class="nl nm it kw b kx nu la nv ld nw lh nx ll ny lp nq nr ns nt bi translated">清理您的语法，使您的代码更易于阅读</li></ul><p id="f23a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想看更多的东西，下面是我在Async/Await上最喜欢的一些博客文章和视频:</p><div class="nz oa gp gr ob oc"><a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">JavaScript的Async/Await违背承诺的6个原因(教程)</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">如果你错过了，从7.6版本开始，Node现在支持异步/等待。如果你还没有尝试过…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">hackernoon.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="http://nikgrozev.com/2017/10/01/async-await/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">用图表和例子解释Await和Async</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">JavaScript ES7中的async/await语法使得协调异步承诺变得更加容易。如果你需要…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">nikgrozev.com</p></div></div><div class="ol l"><div class="or l on oo op ol oq ks oc"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="475e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！卡特彼勒税:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/a1de01fb767a5f1304a6b12902ee4ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zokAXkOyXi9IxautNROjUA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">Anouk在读完所有这些后也筋疲力尽了。</p></figure></div></div>    
</body>
</html>