# 如何使用函数式编程创建强大的应用程序

> 原文：<https://betterprogramming.pub/how-to-use-functional-programming-to-create-powerful-applications-aadfd83ad74c>

## 用 Swift 中的例子解释

![](img/ee1025134312f78b707f9b0576582327.png)

达里奥在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

OOPS 在大企业中曾经风光一时。由于自身的缺陷，它带来了巨大的成功，也失败了。

尽管如此，由于所有关于继承的花哨功能和不良副作用，它在每个程序员心中都有一席之地，原因有二:

*   没有对象的概念(基本上是包装)，很难想象封装
*   更深层次的原因来了:作为人类，在计算机发明之前，我们已经不断地将世界分类为物种(进一步:种族、民族、国籍)、学科和类型。整个现代科学和社会的起源就在于这些分类。计算也不能例外。

即使在函数式编程范例中，语言也是从陈述开始的:

> (这里，在这种语言中:)函数是一级*对象*。

FP 带来了这些免责声明，不是作为 OOPS 的完全替代，而是作为一个通过程序员的客观镜头分类的世界之巅的智能层。

# 范围

一段时间以前，FP 对我来说只是一些在技术面试中脱口而出的样板定义。

我没有计算机学位，我也从来没有觉得有必要学习 FP 作为范例。我使用过它，但只是作为一种实用工具，从未把它当作一个概念。

直到我开始使用 Rx Observables 和 JS Promise 等概念，(具体来说:当我开始遇到它们的问题时)我才完全意识到 FP 的神奇世界。

即便如此，我的挖掘也没有超出常规:

*   纯函数没有副作用
*   OOP 太糟糕了，以至于每个人都开始厌恶它(更多的是因为他们的命运一辈子都与它联系在一起)。
*   函数是函数式语言中的一级对象(并不是说我知道它真正的意思)

我从未问过自己真正重要的问题:

*   如何根据函数而不是对象来考虑你的项目
*   如何把基于 OOP 的项目变成基于函数的项目？

在本文中，我试图用尽可能简单的术语来解释这些问题。

这篇文章不是学术性的。它不是来自对函数式语言的大量研究。如果你正在寻找这样的内容，我建议你谷歌一下最受欢迎的函数式编程书籍，跳过这篇文章。

让我们通过清除定义部分来深入研究。

# 作为对象的功能:

函数[是一级对象](https://en.wikipedia.org/wiki/First-class_function)是什么意思？

## 三种症状

*   它们可以作为参数传递给其他函数。示例:

```
let value = otherFunction(myFunction("Hello"))
```

*   函数可以作为其他函数的值返回。示例:

```
myFunction() -> (Integer -> Integer) {
    return {
        i in 
        return i*2
    }
}
```

*   可以将函数分配给变量，并存储在数据结构中(例如函数数组)。示例:

```
let myVariable1 = myFunction(5)
let myVariable2 = myFunction(5)
let myVariable3 = myFunction(5)
let functionArray = [myVariable1, myVariable2, myVariable3]
```

说完这些，让我们深入研究两个案例，在这两个案例中，FP 可以成为改变你的编程能力的极其强大的工具。

# #1:何时使用函数作为参数

这里有个秘密:我刚才举的那些例子，从我开始编程到现在，我至少遇到过 1000 次。我从没想过这有什么特别的。

直到我遇到一个真实世界的用例。

让我们来看看利息计算器组件:

现在，您突然觉得需要对输入执行一些验证，但是您不想弄乱初始化。因为财务规则是不稳定的，所以每个利息计算器都是有效的对象。你能做的就是改变利息的计算方式。

因此，如果参数变得无效，您将从`interestCalculator`返回一个错误。

但是，如果您希望错误以字符串形式报告，但又希望利息以双倍形式返回，该怎么办呢？

> 每当蛋糕准备好了，面包师*就会叫你*。

此外，如果一些异步处理可能会中断利息计算器怎么办？你显然不希望客户无限期地等待。

这和你为你的兄弟姐妹的生日从你最喜欢的面包师那里预定一个蛋糕没什么不同。每当蛋糕准备好了，面包师*就会叫你*。

考虑下面的代码，其中有一个额外的函数用于`interactiveInterestCalculation()`:

`interactiveInterestCalculation()` 做你最喜欢的面包师做的事情:只要你预定的结果准备好了，它就会叫你。如果丢弃所有 return 语句，也可能需要多次报告中间状态。

## 使用案例:

*   **高阶函数** : *映射*，*过滤器*和 *Reduce* 使用输入回调转换数据
*   **进度指示器:**数据下载/处理进度回调
*   **定时事件**(每 x 秒触发一次回调的计时器，调用一次回调)
*   **结果/错误报告者**:承诺(`interactiveInterestCalculation()`也是简化的)

# #2:何时使用函数作为返回值

这个用例就是我在标题中写下“强大的*”*这个词的原因。这是因为返回函数会将函数调用的权力转移给客户端。

换句话说，当您从一个函数返回一个函数时，您提供了(返回函数的)定义，但是客户端拥有调用返回函数的所有权力。

> 无论你什么时候打电话给帮助热线，它都会给你菜谱。你想什么时候做蛋糕就什么时候做蛋糕，或者干脆不做蛋糕。

不像上面第一条中的蛋糕烘焙师，在这里，你只需拨打食谱制作热线。语音问你想做什么菜，你一说就把菜谱叙述出来了。你什么时候觉得舒服就做这道菜。或者你可以简单地选择跳过制作部分。

从函数开发人员的角度:创建逻辑并返回它；客户端调用该函数。这种权力属于客户，而责任和调用的资源也必须属于他。

> “如果你给一个人一条鱼，你可以喂他一天。如果你教一个人钓鱼，你就喂了他一辈子。”

如果你对这句谚语很熟悉，那么这个用例就是小菜一碟。

让我们再来看看利息计算器组件，其中包含一些更有用的定制:

这里，`specialInterestCalculation()`根据在`InterestCalculator()`对象创建时传递的值返回一个适当的函数。返回的函数(`lowRateInterestFunction`、`highReturnInterestFunction`、`lowTenurePenaltyFunction`或最后一个未命名的罚息计算函数)。

每当客户想要计算利息时，他只需调用返回的函数:

```
let f = specialInterestCalculation()// Long, long afterward, in a module far far away
let interest = f()
```

## **总结一下**

使用函数作为返回值，您可以将执行逻辑(稍后调用的客户端:`f()`)与处理逻辑(之前调用的客户端:`specialInterestCalculation()`)完全分离。

# 奖励:函数式编程的真正力量

让我们再举一个函数返回函数的例子，来体会函数式编程的真正威力。

让我们想象一下，银行决定增加它的储蓄客户群。为了成为新闻头条，该公司决定奖励其现有客户一笔可观的彩票奖金。

*   彩票功能必须完全随机化。
*   为了透明起见，彩票功能必须基于客户端输入(事先通过 web 表单提交的随机数，就像彩票一样)运行。
*   结果出来后，银行会公布大家提交的抽奖功能码和随机数，这样就没人能叫屈了。
*   彩票功能必须足够强大。因此，在预先确定的时间(同一时间)在所有客户端的机器(台式机/移动设备)上运行彩票功能将是一个明智的选择。

如您所见，`calculateLotteryReward()`满足了所有需求。它返回一个函数并快速退出。这个返回的函数通过随机数在客户端和服务器端都足够随机化。

```
//Submit your random number by 31st March 2022
let f = calculateLotteryReward(57)// On 1 April, 2022
let paymentAmount = f(); // I won $1M+ interest from the bank!
```

如上所述，在提交日期之前的任何时候， *f* 都将被*解析并返回*。但是要到愚人节才会执行。当它出现时，它将在客户机上，所以这个巨大的循环不会永远阻塞服务器。

安全性(如何在 4 月 1 日之前将函数返回值传输到客户机而不让客户机看到)和随机化(获胜的几率等)不在本次讨论的范围之内。也可以是客户机和服务器都驻留在安全网络上，或者在不同的进程中驻留在同一台机器上。见鬼，我甚至还没有测试我的随机化逻辑。

我只是用它来演示函数式编程如何以高度灵活和分离的方式分配工作负载。

# 结论

通常，你的基于 OOP 的项目充斥着糟糕的、不直观的代码，除了要求太多和让步太少之外，没有任何用处。如果使用得当，函数式编程会给他们带来巨大的力量。

唯一要记住的是，永远不要从第一天起就担心自己的功能性——这只会让学习曲线变得更陡，你会很快发现自己陷入了理论的深渊。

以基于 OOP 的类设计的自然进程来看待事物。有了这些小步，总有一天你可以移山。