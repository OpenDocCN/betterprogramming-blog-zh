<html>
<head>
<title>4 New Type Annotation Features in Python 3.11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.11中的4项新类型注记功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-new-type-annotation-features-in-python-3-11-84e7ec277c29?source=collection_archive---------3-----------------------#2022-05-02">https://betterprogramming.pub/4-new-type-annotation-features-in-python-3-11-84e7ec277c29?source=collection_archive---------3-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c6ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TypedDict、任意文字字符串等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8de4a35b6412409fb90404d10e34f611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fwA0wmFohfxNxOOE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rubaitulazad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">鲁拜图·阿扎德</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2022年4月25日，Python发布了最新的alpha-3 . 11 . 0 a7，它代表了3.11开发的alpha阶段的最后一个版本。它将在5月初进入测试阶段，最终正式版3.11预计将于2022年10月发布。</p><p id="d60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道让您的应用程序适应最新的Python需要做大量的工作，而且大多数时候，您不需要这样做，因为您的应用程序可能在旧版本上运行良好。然而，如果你是那种喜欢尝试新事物的人，让我们从Python 3.11开始吧！</p><p id="2912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您不想修改您当前的应用程序，因为3.11仍处于alpha阶段，但这并不妨碍我们用docker映像来尝试它——一个独立于您的应用程序的独立虚拟容器。</p><p id="9b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些新特性中，我想在本文中重点介绍类型注释。Python是一种动态类型语言，类型注释被许多类型检查器使用，这些检查器可以提供实时代码分析。许多代码错误，比如类型不匹配，可以在你编码的时候被识别出来。因此，Python 3.11中类型注释的改进将帮助我们编写无错误的代码。</p><p id="3062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们正在测试alpha版本，这些功能可能会发生变化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2b95" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><h2 id="e8f2" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">用Docker安装Python 3.11</h2><p id="780a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果你的电脑上没有安装Docker，你可以去<a class="ae ky" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">docker.com</a>找到安装说明。dockers的想法是创建一个可复制的容器，简化应用程序的开发。</p><p id="e020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦安装了docker，就可以在命令行工具上运行下面的命令。就我而言，我使用Mac电脑上的终端应用程序。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="73d5" class="mu md it nm b gy nq nr l ns nt">docker run -t -d python:3.11-rc-bullseye</span></pre><p id="a195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令提取带有标签<code class="fe nu nv nw nm b">python:3.11-rc-bullseye</code>的图像。以防你想知道这个标签是什么意思。<code class="fe nu nv nw nm b">3.11</code>代表Python的版本，<code class="fe nu nv nw nm b">rc</code>表示发布候选，<code class="fe nu nv nw nm b">bullseye</code>是Debian版本<a class="ae ky" href="https://www.debian.org/releases/bullseye/" rel="noopener ugc nofollow" target="_blank">靶心</a>，此图基于此Debian版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/9b98ed0d82b4ef3bc44f866222754b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SaO9dX8PzRL88WviZNyYaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker应用程序中的Python图像</p></figure><p id="ae2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经成功安装了这个镜像，你应该可以看到上面的东西，一个在容器/应用列表中的镜像。您可以将鼠标放在此图像上，并单击CLI图标，这将启动终端应用程序。</p><p id="0966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以简单地键入<code class="fe nu nv nw nm b">python</code>，这将在终端中启用Python控制台，如下所示。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="a2b9" class="mu md it nm b gy nq nr l ns nt"># python<br/>Python 3.11.0a7 (main, Apr 20 2022, 17:55:51) [GCC 10.2.1 20210110] on linux<br/>Type "help", "copyright", "credits" or "license" for more information.<br/>&gt;&gt;&gt;</span></pre><p id="9171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从提示中，我们可以看到它是Python 3 . 11 . 0 . a7——3.11的第七个alpha版本。我们还可以通过运行以下代码来验证它:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4954" class="mu md it nm b gy nq nr l ns nt">&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; sys.version<br/>'3.11.0a7 (main, Apr 20 2022, 17:55:51) [GCC 10.2.1 20210110]'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="caa5" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">在Visual Studio代码中使用容器(VSC)</h2><p id="9c98" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">使用命令行界面可以探索一些基本特性。然而，就编写代码而言，这并不是最愉快的。因此，我们可能希望使用类似IDE的代码编辑器，比如<a class="ae ky" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code (VSC) </a>。尽管有其他可供选择的Python IDEs，但出于本教程的目的，我们将坚持使用VSC。</p><p id="887b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您已经在计算机上安装了VSC，要让您的VSC与docker镜像一起工作，您需要安装<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers" rel="noopener ugc nofollow" target="_blank">远程容器</a>扩展。安装完成后，您应该能够在侧边栏上看到一个选项卡，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/89d4dd5bc569eb6da9d784a7575fce82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMhvGjaSCk9_k8xhbEFkfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将VSC系在容器上</p></figure><p id="257a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击选项卡后，您可以看到VSC填充了可用的容器——特别是Python 3.11容器。右键单击容器，您可以将VSC附加到容器。通过附加，将使用容器弹出一个新窗口。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1905" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">创建用于评估的Python文件</h2><p id="46b9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您可以打开一个文件夹作为我们的项目。为了简单起见，我们只是使用默认的根文件夹，你可以找到下面的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ee3163b3bbec22a6e7994cf6a15c09ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKArA6dFXhk3-vn-xIP-FQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打开文件夹</p></figure><p id="a701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件夹中，为了便于评估，我们创建了一个名为<code class="fe nu nv nw nm b">test11.py</code>的Python文件。您可以通过在终端中调用<code class="fe nu nv nw nm b">python -m test11.py</code>来运行该文件(如果您安装了python 3，您可能必须使用<code class="fe nu nv nw nm b">python3 -m test11.py</code>)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a191" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关于打字的4个新特性</h1><h2 id="a632" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">1.自我-类别类型</h2><p id="4974" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">当我们在一个类中定义方法时，我们经常需要返回同一个类的一个实例。在许多情况下，返回值是我们用来调用该方法的实例对象。首先考虑下面的例子。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e67a" class="mu md it nm b gy nq nr l ns nt">class Box:<br/>    def paint_color(self, color):<br/>        self.color = color<br/>        return self</span></pre><p id="d06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码没有使用任何类型提示，可能不清楚。所以我们可以添加更具体的打字信息。有些人可能会想到以下解决方案。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="bf14" class="mu md it nm b gy nq nr l ns nt">class Box:<br/>    def paint_color(self, color: str) -&gt; Box:<br/>        self.color = color<br/>        return self</span></pre><p id="02ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，你不能让它工作，因为，在<code class="fe nu nv nw nm b">Box</code>类的主体中，你不能使用<code class="fe nu nv nw nm b">Box</code>，因为它还没有被定义！因此，现有的解决方法是使用类型变量，它充当待定义类型的代理，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7968" class="mu md it nm b gy nq nr l ns nt">from typing import TypeVar</span><span id="50b0" class="mu md it nm b gy oa nr l ns nt">TBox = TypeVar("TBox", bound="Box")</span><span id="50c6" class="mu md it nm b gy oa nr l ns nt">class Box:<br/>    def paint_color(self, color: str) -&gt; TBox:<br/>        self.color = color<br/>        return self</span></pre><p id="f16d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个不便之处是，当你想改变类名时，比如说我们想把它重命名为<code class="fe nu nv nw nm b">Container</code>，我们可能需要做如下的改变，类名、<code class="fe nu nv nw nm b">TBox</code>定义和<code class="fe nu nv nw nm b">paint_color</code>方法中返回值的类型，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="26f9" class="mu md it nm b gy nq nr l ns nt">from typing import TypeVar</span><span id="565b" class="mu md it nm b gy oa nr l ns nt">TContainer = TypeVar("TContainer", bound="Container")</span><span id="da9d" class="mu md it nm b gy oa nr l ns nt">class Container:<br/>    def paint_color(self, color: str) -&gt; TContainer:<br/>        self.color = color<br/>        return self</span></pre><p id="972f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在您的项目中有许多这样的用法，这些变化可能是不小的。随着Python 3.11中<code class="fe nu nv nw nm b">Self</code>类型的引入，事情变得更加简单。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="26de" class="mu md it nm b gy nq nr l ns nt">from typing import Self</span><span id="f849" class="mu md it nm b gy oa nr l ns nt">class Box:<br/>    def paint_color(self, color: str) -&gt; Self:<br/>        self.color = color<br/>        return self</span></pre><p id="cf54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该熟悉实例方法中的参数<code class="fe nu nv nw nm b">self</code>，它是实例对象。作为对应，<code class="fe nu nv nw nm b">Self</code>表示使用它的类别。在上面的例子中，我们使用<code class="fe nu nv nw nm b">Self</code>来表示返回值是一个“Self”类型的对象，它被解释为<code class="fe nu nv nw nm b">Box</code>类。</p><p id="4f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了不需要创建类型变量的好处之外，还有其他在官方<a class="ae ky" href="https://peps.python.org/pep-0673/" rel="noopener ugc nofollow" target="_blank"> PEP 673 </a>中讨论的好处，包括在子类中的使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3d7c" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">2.任意文字字符串</h2><p id="7b78" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">第二个特性也与类型注释有关。我们来回顾一下现状。当我们定义一个接受字符串的函数时，我们可以使用<code class="fe nu nv nw nm b">Literal</code>类型，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c583" class="mu md it nm b gy nq nr l ns nt">from typing import Literal</span><span id="a735" class="mu md it nm b gy oa nr l ns nt">def paint_color(color: Literal["red", "green", "blue", "yellow"]):<br/>    pass</span></pre><p id="6c10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，当我们希望一个函数接受一个字符串文字时，您必须指定兼容的字符串文字。但是，由于选项有限，当前代码分析认为这是一个错误(警告)，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ff8cf46fc5d941a68dec0145de03958f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0NfhymOzI_rE7F6mRYVYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与定义的字符串文字不兼容的函数调用</p></figure><p id="f039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个限制，Python 3.11引入了一个新的通用类型<code class="fe nu nv nw nm b">LiteralString</code>，它允许用户输入任何字符串文字，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="b5bd" class="mu md it nm b gy nq nr l ns nt">from typing import LiteralString<br/><br/><br/>def paint_color(color: LiteralString):<br/>    pass<br/><br/><br/>paint_color("cyan")<br/>paint_color("blue")</span></pre><p id="ffa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用<code class="fe nu nv nw nm b">Literal</code>类型时，<code class="fe nu nv nw nm b">LiteralString</code>类型为您提供了使用任何字符串文字而不是特定字符串文字的灵活性。更具体的<code class="fe nu nv nw nm b">LiteralString</code>适用的用例，比如构造文字SQL查询字符串，可以参考官方<a class="ae ky" href="https://peps.python.org/pep-0675/" rel="noopener ugc nofollow" target="_blank"> PEP 675 </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0bce" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">3.可变泛型</h2><p id="ccd9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们可以使用<code class="fe nu nv nw nm b">TypeVar</code>创建具有单一类型的泛型，就像我们之前对<code class="fe nu nv nw nm b">Box</code>所做的那样。当我们进行数值计算时，比如在<code class="fe nu nv nw nm b">NumPy</code>和<code class="fe nu nv nw nm b">TensorFlow</code>中基于数组的运算，我们使用具有不同维度和形状的数组。</p><p id="5f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们为这些不同的形状提供类型注释时，为每个可能的形状提供类型信息可能很麻烦，这需要一个类的单独定义，因为现有的<code class="fe nu nv nw nm b">TypeVar</code>一次只能处理一种类型。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="cdb5" class="mu md it nm b gy nq nr l ns nt">from typing import Generic, TypeVar</span><span id="ba17" class="mu md it nm b gy oa nr l ns nt">Dim1 = TypeVar('Dim1')<br/>Dim2 = TypeVar('Dim2')<br/>Dim3 = TypeVar('Dim3')</span><span id="197d" class="mu md it nm b gy oa nr l ns nt">class Shape1(Generic[Dim1]):<br/>    pass</span><span id="7831" class="mu md it nm b gy oa nr l ns nt">class Shape2(Generic[Dim1, Dim2]):<br/>    pass</span><span id="dc28" class="mu md it nm b gy oa nr l ns nt">class Shape3(Generic[Dim1, Dim2, Dim3]):<br/>    pass</span></pre><p id="a6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，对于三维，我们必须定义三种类型和它们各自的类，这并不清楚，并且代表了我们应该小心的高度重复。Python 3.11引入了<code class="fe nu nv nw nm b">TypeVarTuple</code>，允许你使用多种类型创建泛型。使用这个特性，我们可以重构前面代码片段中的代码，得到如下代码:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c308" class="mu md it nm b gy nq nr l ns nt">from typing import Generic, TypeVarTuple</span><span id="e19d" class="mu md it nm b gy oa nr l ns nt">Dim = TypeVarTuple('Dim')</span><span id="fc91" class="mu md it nm b gy oa nr l ns nt">class Shape(Generic[*Dim]):<br/>    pass</span></pre><p id="c178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它是一个<code class="fe nu nv nw nm b">tuple</code>对象，所以您可以使用一个带星号的表达式来解包它包含的对象，在我们的例子中，它的类型数量是可变的。上面的Shape类可以是任何形状，这大大提高了灵活性，并且不需要为不同的形状创建单独的类。</p><p id="a61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于使用<code class="fe nu nv nw nm b">TypeVarTuple</code>的更多详细信息，请参考官方<a class="ae ky" href="https://peps.python.org/pep-0646/" rel="noopener ugc nofollow" target="_blank"> PEP 646 </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="55b9" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">4.TypedDict —灵活的关键要求</h2><p id="e8e5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在Python中，字典是一种强大的数据类型，它以键值对的形式保存数据。这些键是任意的，您可以使用任何适用的键来存储数据。但是，有时您希望拥有一个包含特定键和特定类型值的结构化字典。在这种情况下，您可以使用<code class="fe nu nv nw nm b">TypedDict</code>类型。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8bc3" class="mu md it nm b gy nq nr l ns nt">from typing import TypedDict</span><span id="0e91" class="mu md it nm b gy oa nr l ns nt">class Name(TypedDict):<br/>    first_name: str<br/>    last_name: str</span></pre><p id="6dab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图，我们定义了<code class="fe nu nv nw nm b">Name</code>，它有<code class="fe nu nv nw nm b">first_name</code>和<code class="fe nu nv nw nm b">last_name</code>作为必需的键，它们的值应该是字符串。</p><p id="a013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道有的人可能有中间名(说对应的键是<code class="fe nu nv nw nm b">middle_name</code>)，有的人没有。即<code class="fe nu nv nw nm b">Name</code>类作为<code class="fe nu nv nw nm b">TypedDict</code>，应该允许<code class="fe nu nv nw nm b">middle_class</code>缺失。没有直接的注释使键成为可选的，当前的解决方法是创建一个使用所有必需键的超类，而子类包括可选的键，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7c25" class="mu md it nm b gy nq nr l ns nt">from typing import TypedDict</span><span id="c537" class="mu md it nm b gy oa nr l ns nt">class _Name(TypedDict):<br/>    first_name: str<br/>    last_name: str</span><span id="2c2a" class="mu md it nm b gy oa nr l ns nt">class Name(_Name, total=False):<br/>    middle_name: str</span></pre><p id="9b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图，<code class="fe nu nv nw nm b">_Name</code>级有<code class="fe nu nv nw nm b">first_name</code>和<code class="fe nu nv nw nm b">last_name</code>，而<code class="fe nu nv nw nm b">Name</code>有<code class="fe nu nv nw nm b">middle_name</code>。值得注意的是，我们需要将<code class="fe nu nv nw nm b">total</code>指定为<code class="fe nu nv nw nm b">False</code>，这意味着键<code class="fe nu nv nw nm b">middle_name</code>可以在<code class="fe nu nv nw nm b">Name</code>类中省略。</p><p id="5227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个超类来满足这种业务需求是不方便的，我们应该有一个更好的解决方案——Python 3.11引入了<code class="fe nu nv nw nm b">NotRequired</code>作为类型限定符，以表明<code class="fe nu nv nw nm b">TypedDict</code>可能缺少一个键。用法非常简单，如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d292" class="mu md it nm b gy nq nr l ns nt">from typing import TypedDict, NotRequired</span><span id="4352" class="mu md it nm b gy oa nr l ns nt">class Name(TypedDict):<br/>    first_name: str<br/>    middle_name: NotRequired[str]<br/>    last_name: str</span></pre><p id="8395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，我们不再需要超类/子类结构。相反，我们只是指定这个<code class="fe nu nv nw nm b">TypedDict</code>中不需要<code class="fe nu nv nw nm b">middle_name</code>——这样不是简洁多了吗？<em class="oc">请注意，您可能会看到</em> <code class="fe nu nv nw nm b"><em class="oc">NotRequired</em></code> <em class="oc">无法导入，我猜图像可能有问题。</em></p><p id="bed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有太多可选键，可以使用required指定那些必需的键，而不是将那些可选键指定为非必需的。因此，针对上述问题的替代等效解决方案如下所示:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e7aa" class="mu md it nm b gy nq nr l ns nt">from typing import TypedDict, Required</span><span id="4364" class="mu md it nm b gy oa nr l ns nt">class Name(TypedDict, total=False):<br/>    first_name: Required[str]<br/>    middle_name: str<br/>    last_name: Required[str]</span></pre><p id="1967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在代码片段中，我们将<code class="fe nu nv nw nm b">total</code>指定为<code class="fe nu nv nw nm b">False</code>，这使得所有的键都是可选的。同时，我们将这些必需的键标记为<code class="fe nu nv nw nm b">Required</code>，这意味着其他键可能会丢失。</p><p id="42c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关此功能的更多信息，请参考官方<a class="ae ky" href="https://peps.python.org/pep-0655/" rel="noopener ugc nofollow" target="_blank"> PEP 655 </a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4ae4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4fce" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在本文中，我们回顾了Python 3.11中关于类型注释的四个新特性。这些新特性允许您通过使用更强大的类型提示来编写更干净的代码。</p><p id="c787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，Python 3.11的最终正式版本是2022年10月。你准备好了吗？</p></div></div>    
</body>
</html>