# 自动化测试以及为什么你应该使用它

> 原文：<https://betterprogramming.pub/automated-testing-why-you-should-use-it-28a1beda1bdd>

## 让我们谈谈自动化测试方法，比如单元测试、端到端测试和集成测试

![](img/e7f4338f2b1b3465e3ddda00a96e5e19.png)

戴维·特拉维斯在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上拍摄的照片

如果你是一名高级开发人员，你必须知道如何编写测试。不知道怎么样？那么你可能更多的是一个中级开发人员，即使你在你的公司有一个高级职位。

如果你是初级/中级开发人员，并想成为高级开发人员，你必须在简历中加入单元测试，这样才能获得更好的工作。如今，大多数拥有优秀程序员的好公司都会实践单元测试。

> *“质量永远不会出事；它总是智慧努力的结果。”—约翰·罗斯金*

到本文结束时，我们将讨论单元测试可以在您的团队中改进的某些方面，例如开发成本和手动测试代码的成本。您还将了解测试的类型，以及如何从自动化测试中获益。

# 什么是自动化测试？

简单地说，自动化测试是编写代码的实践，它独立于被测试的软件。

自动化测试的主要目的是在应用程序进入生产之前找到它的破损部分。

使用自动化测试是否意味着你将发布无错误的软件？当然不是。

但是自动化测试有助于在软件发布前发现这些错误。让我给你一个自动化测试如何工作的例子。看看这段代码:

```
function calculateCostOfMilk(typeOfMilk) {   

   if (typeOfMilk === 'wholeMilk') return 3.05;     else if (typeOfMilk === 'skimMilk') return 1.40;      return 0.00;
}
```

假设我们有一个刚刚构建的应用程序，并且想要手动测试它。上面的函数是在我们用数据填充表单并提交表单后调用的函数。

假设我们的应用程序中有多个很长的表单，需要不同类型的输入。手动启动浏览器、填写不同类型的表单以及测试所有组件可能需要几个小时，甚至几天。

这增加了生产成本，并最终减缓了应用程序本身的发布和开发。通过自动化测试，我们可以编写代码来填充这些表格，并直接测试我们的功能。试试这个:

```
var result = calculateCostOfMilk('wholeMilk');var result = calculateCostOfMilk('skimMilk');
```

这比手工测试更容易，而且只需要几分之一秒。

# 成本增加

许多开发人员认为，使用自动化测试会增加开发成本，因为您必须编写实际的应用程序本身，然后再为该应用程序编写测试代码。

编写测试确实需要更多的时间，但是它有助于减轻将来发布脆弱代码的风险，并且有助于构建可维护的代码库。

我并不是说自动化测试会阻止你释放代码中的 bugs 这不是真的。但是它确实有助于您发布更高质量的代码。

当你的老板打电话告诉你应用程序的一个关键部分不工作时，它还可以帮助你避免在凌晨 3 点回到办公室。

你会希望你的朋友早点和你分享这篇文章。

# 从长远来看，这样更便宜

一些开发人员认为手动测试是测试应用程序的最佳方式，因为成本较低。这些人争论的是我喜欢称之为*的成本观点。*

你看，这就是大多数人在比较完成一件事所花的时间时给出的理由。

现在就花时间和金钱以正确的方式去做，这样就不会浪费时间和金钱去尝试在错误的时间做正确的事情。

使用自动化测试，您可以创建一个单独的项目来编写测试。在该项目中，您将编写代码并直接调用具有不同输入的函数，并验证这些函数返回正确的输出。

正如您所看到的，为您的应用程序编写测试确实需要更多的时间，但是随着您的项目规模的扩大和获得更多的可移动部分，如果您不使用自动化，您最终会增加成本并花费更多的时间来测试您的应用程序。

# 有益的测试

自动化测试的好处是它们是可重用的。你写一次，运行一百万次。

许多团队发现每次提交都运行测试是有益的。使用这种方法，它可以确保在主分支接受拉请求之前捕捉到重大更改。

我个人喜欢给团队一个命令，让他们同时运行林挺和测试。

开发人员知道在打开 pr 之前运行它，因为如果有 lint 错误或测试失败，CI/CD 系统将标记 pull 请求并阻止它被合并。

目标是生产没有突破性的变化。

使用这种方法，您可以在几分之一秒内测试应用程序函数中的所有执行路径。

编写自动化测试也有助于您编写更好的代码。当编写测试时，您不得不考虑应用程序中每个函数的边界情况。您为这些函数编写测试，为它们提供各种输入，并确保它们的行为符合您的预期。

这将有助于你生产出质量更好、缺陷更少的软件。我们应用程序中的许多错误都是不可预见的边缘情况的结果。你的一个函数接收到一个你忘记预测的输入…然后嘣！

比我的写作生涯还快！

通过自动化测试，您可以确保每个功能在不同的环境下使用不同的输入，并且那些干扰性的错误不会出现在产品中。

# 测试类型

有许多不同类型的测试，但我在这篇文章中重点关注的三种是:

1.  单位
2.  综合
3.  端到端

记住，没有一种测试适合所有人。您可以使用不同类型的测试，这取决于您正在构建的应用程序的类型以及您的团队所偏好的覆盖范围。

我们一会儿会讨论这些。现在，我们只需要知道有三种不同类型的测试可以在应用程序的各个部分上执行。

## 单元测试

单元测试是软件开发人员的一种增长趋势，它决定了代码的某些部分在不同的环境下是否如预期的那样运行。

在单页应用程序的上下文中，单元测试只关注组件。如果我们在模板中有一个失败，那么我们直到运行时才能知道。单元测试很快，写起来也不复杂，但是它们不能给我们太多关于应用程序的可预测性。

从角度来说，它在没有模板和许多其他外部资源(如文件系统、数据库和 API 端点)的情况下测试应用程序的某些组件。

例如，在 Angular 应用程序中，我们将模板、服务和应用程序的其他部分绑定到我们的组件中。

单元测试将只测试 Angular 应用程序的组件，而不涉及模板、服务等。

如果你的组件依赖于一个服务，我们会给它一个该服务的假实例。类似地，如果你的组件依赖于一个路由器，你会给它一个路由器的假实例。

在单元测试中，我们假设服务和路由器正在做它们的工作。因此，这使我们能够专注于组件，以确保其正常工作。让我们深入一些代码，以便更好地理解单元测试是如何工作的。

```
export class VoteComponent {   
    totalVotes: number;       upVote() {   
        this.totalVotes++;  
     }
}
```

上面是我们的组件，它基本上是一个简单的 TypeScript 类。每次调用`upVote()`方法时,`totalVotes`属性都会改变。

让我们假设模板中有一个按钮，它像这样调用`upVote()`方法:

```
{{ totalVotes }}<button (click)="upVote()">up</button>
```

当点击按钮时，我们期望调用`upVote`方法，并且`totalVotes`属性应该增加 1。

如果测试注意到不同的行为，它会被标记出来——开发人员可以去修复它。

## 整合测试

集成测试提供了用外部资源测试组件的能力。

还记得我们的`VoteComponent`吗？集成测试能够将我们的`VoteComponent`视为一个角度组件。

为了更好地理解这一点，由于集成测试也测试外部资源，我们需要在一个角度环境中运行它。

也许你需要在特定的构建结果和环境中测试应用，并期待特定的结果——集成测试会处理它。

在这种情况下，我们需要指示 Angular 一起编译我们的`VoteComponent`和它的模板。所以测试知道这两个。

由于我们必须在 Angular 环境中运行，因此需要编写更多的测试代码，但我们将对组件的功能更有信心，因为测试将在了解模板和组成模板的组件的情况下运行我们的应用程序。

现在，类似于单元测试，我们仍将为这个组件提供一个假服务。

虽然集成测试更加可靠，但是它们仍然很脆弱，因为我们只测试了应用程序的几个部分:组件和模板。

这种类型的测试不把我们的应用程序作为一个整体来看。

## 端到端测试

这种类型的测试将启动应用程序、测试登录、填写联系表单等。

这让我们对发布的软件更有信心，但是端到端的测试又慢又脆弱。

它们之所以缓慢，是因为测试本身背后的所有机制，以及被覆盖的代码的高百分比。

通过端到端测试，我们将整个应用程序作为一个整体进行测试。

测试运行需要时间，因为它将模拟一个真实的用户。它们很脆弱，因为对模板中 HTML 的一个更改可能会破坏整个测试。

对于您对应用程序所做的每一个更改，您都必须调整测试代码以正确工作。

端到端测试只针对应用程序的关键部分。这在某些场景下实际上是很棒的。

# 结论

既然您已经了解了不同类型的测试、它们的优缺点、何时使用它们以及它们是如何工作的，那么您现在就有了学习不同测试方法之一的基础。

不管你使用什么类型的测试，我保证你会构建出高质量的软件，并且在产品中看到更少的错误。

单元测试更容易编写，所以我建议从那里开始。

请记住，没有一个测试适合所有场景。有些情况下，你会使用其中一个而不是另一个。

干杯！