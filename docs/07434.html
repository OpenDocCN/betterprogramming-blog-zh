<html>
<head>
<title>5 Advanced Python Function Concepts Explained With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个高级Python函数概念，并举例说明</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-advanced-python-function-concepts-explained-with-examples-dcf10389ac9a?source=collection_archive---------3-----------------------#2021-01-14">https://betterprogramming.pub/5-advanced-python-function-concepts-explained-with-examples-dcf10389ac9a?source=collection_archive---------3-----------------------#2021-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aeb3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">兰姆达斯，装饰，partials，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/23ef6496799f2811be2818b0a61d7fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ycV0LvmIIKpZjKA5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aurelien_romain?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aurelien Romain </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="3af5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的程序是一个工厂，函数就是操纵机器使你的程序运行的工人。在一个典型的工厂里，有不同类型的工人负责不同的工作。相应地，你的程序在功能上应该是通用的。为了编写健壮的函数，你的编码库应该包括必要的工具，让你用最好的工人来装备你的程序。</p><p id="3ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释Python中与函数相关的五个高级概念。在我们开始讨论之前，让我们假设我们理解了Python函数的基本形式，如下面的代码片段中所注释的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python函数的基本形式</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="bb91" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">1.未确定的参数(*args和**kwargs)</h1><p id="166b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当我们定义函数时，我们可以有位置参数和关键字参数。位置参数通过它们的位置来解析，而关键字参数通过它们的参数名(即关键字或标识符)来解析。我们来看看内置<code class="fe nb nc nd ne b">print</code>函数的签名:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="2b91" class="nj mf it ne b gy nk nl l nm nn"><strong class="ne iu">print</strong>(<em class="no">*objects</em>, <em class="no">sep=' '</em>, <em class="no">end='\n'</em>, <em class="no">file=sys.stdout</em>, <em class="no">flush=False</em>)</span></pre><p id="90d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">objects</code>参数是位置性的(我们很快会谈到星号)。所有其他参数都有它们唯一的标识符(例如，<code class="fe nb nc nd ne b">sep</code>，<code class="fe nb nc nd ne b">end</code>)，因此它们是关键字参数。顺便提一下，当传递关键字参数时，我们可以有不同的顺序，因为它们是由它们的标识符解析的。但是，位置参数严格按照位置进行解析。下面是一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">传递参数</p></figure><p id="e8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到，我为<code class="fe nb nc nd ne b">objects</code>参数传递了两个字符串。这是可能的，因为在<code class="fe nb nc nd ne b">objects</code>参数前面有一个星号，它表示位置参数的数量不确定。当您看到这种函数签名时，您可以传递任意数量的适用位置参数。</p><p id="6739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了位置参数，关键字参数也可以有一个可变的数字，通常用<code class="fe nb nc nd ne b">**kwargs</code>表示。例如，您可能见过字典的构造函数签名，如下所示:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="fba5" class="nj mf it ne b gy nk nl l nm nn"><em class="no">class </em>dict<!-- -->(<em class="no">**kwarg</em>)</span></pre><p id="b091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以将任何关键字参数传递给<code class="fe nb nc nd ne b">dict()</code>构造函数来创建新的dictionary对象。下面是一些简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同数量的关键字参数</p></figure><ul class=""><li id="ffaa" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">前五行代码向您展示了我们如何通过指定任意数量的关键字参数来使用<code class="fe nb nc nd ne b">dict()</code>构造函数来创建新的<code class="fe nb nc nd ne b">dict</code>对象。</li><li id="82f1" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在自定义函数中(第7-9行)，当我们调用函数时，传递的关键字参数被打包到一个名为<code class="fe nb nc nd ne b">kwargs</code>的字典中。为了在函数体中访问这些参数，我们可以迭代字典中的条目(第8行)。</li></ul><p id="908e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们之前没有提到，但是使用不同数量的位置参数传递给函数的位置参数被打包到一个元组对象中。要了解关于打包和解包这些参数的更多信息，请参考以前的<a class="ae ky" href="https://medium.com/swlh/how-to-pack-and-unpack-data-in-python-tuples-and-dictionaries-55d218c65674" rel="noopener">媒体文章</a>。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="977b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">2.匿名函数</h1><p id="0d08" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Lambda函数是Python中的匿名函数。它们通常被用作一个内嵌函数来执行一个小任务。例如，在内置的<code class="fe nb nc nd ne b">sorted()</code>函数中，如果我们想要应用一些高级的排序规范，我们可以设置<code class="fe nb nc nd ne b">key</code>参数。下面是一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">λ排序函数</p></figure><ul class=""><li id="1646" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">默认情况下，<code class="fe nb nc nd ne b">sorted()</code>函数根据数值对这些数字进行排序。</li><li id="ee0a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">但是，我们希望按照除以3后的余数对数字进行排序。在这种情况下，我们可以为<code class="fe nb nc nd ne b">key</code>参数指定一个lambda函数(<code class="fe nb nc nd ne b">lambda x:x % 3</code>)。</li><li id="9dd8" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">lambda函数的一般格式为<code class="fe nb nc nd ne b">lambda params: expr</code>。lambda关键字表示lambda函数的声明，后跟一个参数列表和一个带有单个表达式的冒号。在我们的例子中，表达式是为每个数字计算<code class="fe nb nc nd ne b">3</code>的模。</li></ul><p id="1031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据科学中，我们经常使用熊猫图书馆进行数据处理。Lambda函数对于从现有数据列中提取信息也很有用。下面的代码向您展示了一个简单的示例，它使用lambda函数将数据映射到pandas <code class="fe nb nc nd ne b">Series</code>数据对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">串联映射中的λ函数</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="4267" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">3.部分功能</h1><p id="206f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">部分函数是通过应用部分参数来利用现有函数的函数。这个定义听起来不太直白。通过一个简单的例子可以更好地理解这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部分功能</p></figure><ul class=""><li id="010d" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">greeting</code>函数接受两个参数。我们通过设置这两个参数来使用这个函数。</li><li id="aa88" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在特定的用例中，我们总是使用相同的问候词。在这种情况下，我们可以通过将固定的问候词应用于<code class="fe nb nc nd ne b">greeting</code>函数来创建一个部分函数。</li><li id="d1c3" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">functools</code>模块有<code class="fe nb nc nd ne b">partial</code>方法，可以方便地创建部分函数。如下例所示，部分函数被称为<code class="fe nb nc nd ne b">say_hi</code>，它的调用相当于通过对<code class="fe nb nc nd ne b">word</code>参数应用“Hi”来调用问候函数。</li></ul><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="abc6" class="nj mf it ne b gy nk nl l nm nn">&gt;&gt;&gt; say_hi<br/>functools.partial(&lt;function greeting at 0x1177c9040&gt;, 'Hi')</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="b97d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">4.关闭</h1><p id="455b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Python不是唯一有闭包概念的语言。许多其他主流语言(例如Swift)都有闭包的特性。本质上，闭包是内部函数，它捕获外部函数中定义的非局部变量。让我们来看看下面的代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关闭示例</p></figure><ul class=""><li id="ced4" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">make_incrementer</code>是外部功能，而<code class="fe nb nc nd ne b">incrementer</code>是内部功能。</li><li id="9f11" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">内部函数使用<code class="fe nb nc nd ne b">counter</code>变量，该变量定义在外部函数的范围内，因此被视为非局部变量。</li><li id="e150" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">外部函数返回内部函数作为返回值。</li><li id="f3d9" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">我们可以通过调用这个<code class="fe nb nc nd ne b">make_incrementer</code>函数来创建一个闭包。值得注意的是，创建的闭包将捕获非局部变量，如下所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">捕获非局部变量</p></figure><ul class=""><li id="dfeb" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">闭包捕获了两个非局部变量(<code class="fe nb nc nd ne b">counter</code>和<code class="fe nb nc nd ne b">step</code>)。</li><li id="5ac8" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">要访问非局部变量，我们可以使用<code class="fe nb nc nd ne b">__closure__</code>和<code class="fe nb nc nd ne b">cell_contents</code>来检索值。在本例中，您可以看到<code class="fe nb nc nd ne b">counter</code>变量正在按照预期的方式递增。</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="944f" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">5.装修工</h1><p id="9a2f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在上一节中，我们讨论了闭包。我们应该理解闭包只是一种通用的技术实现方法，可以用于不同的目的。一个特别的目的是用Python创建装饰器。顾名思义，装饰器是应用附加功能(即装饰)而不改变原始功能预期工作的高阶功能。在解释它们是什么之前，让我们先看看下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰示例</p></figure><ul class=""><li id="5938" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">上面的代码片段实现了一个计时装饰器。我们可以看到调用<code class="fe nb nc nd ne b">calculate_sum</code>函数大约需要0.00018秒。</li><li id="409f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">如果我们仔细观察，我们会注意到<code class="fe nb nc nd ne b">logging_time</code>函数是外层函数，如前一节所述。</li><li id="c17d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">要使用这个装饰器，我们只需在外部函数名前使用<code class="fe nb nc nd ne b">@</code>符号，并将其放在要装饰的函数上方。请注意，修饰函数是<code class="fe nb nc nd ne b">logging_time</code>函数的内部函数，如下图所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="aa86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这一节并不打算让您全面了解Python中的decorators。相反，它只是给你一个概念证明，向你展示decorators可以帮助我们删除一些样板代码。在上面的例子中，我们可以对任何想要评估性能速度的函数使用这个计时装饰器。如果想学习更高级的decorators用例，请参考<a class="ae ky" href="https://medium.com/better-programming/python-decorators-5-advanced-features-to-know-17dd9be7517b" rel="noopener">我之前的文章</a>。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="14b1" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated"><code class="fe nb nc nd ne b">Conclusion</code></h1><p id="503f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在本文中，我们回顾了与Python函数相关的五个高级概念。这里有一个快速回顾:</p><ul class=""><li id="ae09" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">在Python中，<code class="fe nb nc nd ne b">*args</code>和<code class="fe nb nc nd ne b">**kwargs</code>表示不确定数量的位置和关键字参数。当我们调用函数时，我们需要学习如何使用它们，当我们自己声明函数时，我们可能也想包含它们。</li><li id="770f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">Lambda函数作为内嵌函数来执行小型任务非常有用，通常在几个内置函数中设置为<code class="fe nb nc nd ne b">key</code>参数(例如<code class="fe nb nc nd ne b">sorted</code>、<code class="fe nb nc nd ne b">min</code>和<code class="fe nb nc nd ne b">max</code>)。</li><li id="5a96" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">部分函数是通过部分应用特定参数从现有函数创建的函数对象。如果我们需要为某些参数调用具有固定值的特定函数，这种技术可以节省我们一些时间。</li><li id="226a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">闭包是一种可以用来创建捕获额外信息的函数的技术。在Python中，闭包可以通过返回在外部函数范围内定义的内部函数来创建。</li><li id="e6ab" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">装饰器是返回要被装饰的内部函数的高阶函数。通过装饰，被装饰的函数将具有装饰函数定义的额外行为，同时保持其自己的预期功能。</li></ul></div></div>    
</body>
</html>