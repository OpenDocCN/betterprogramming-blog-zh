<html>
<head>
<title>Breaking Down Celery ≥4.x With Python and Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和Django分解芹菜≥4.x</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/breaking-down-celery-4-x-with-python-and-django-e95eeb7de2a6?source=collection_archive---------4-----------------------#2020-05-15">https://betterprogramming.pub/breaking-down-celery-4-x-with-python-and-django-e95eeb7de2a6?source=collection_archive---------4-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用芹菜分配您的Python任务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3cb65e5cee787cad93b511a15b0ef405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46BaM9wAWwE8r4xPl-t2AA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/pelambung-601793/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=769129" rel="noopener ugc nofollow" target="_blank"> pelambung </a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=769129" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="793a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着数据对更快计算方式的需求增加，处理大量数据已成为一种必然。如果你花了一定的时间编程，你会意识到同步阻塞的编程方式只能让你到此为止。最终，您碰壁了，需要转向分布式模型来扩展您的计算性能。</p><p id="bdb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到Python中的分布式计算和异步工作时，主流框架——工具箱中必须知道的——是<a class="ae ky" href="http://www.celeryproject.org" rel="noopener ugc nofollow" target="_blank">芹菜</a>。</p><p id="f234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Celery是一个利用高级消息队列协议(AMQP)在一个或多个节点上实现分布式计算的消息队列模型的包，高级消息队列协议是用于面向消息的中间件的<a class="ae ky" href="https://en.wikipedia.org/wiki/Open_standard" rel="noopener ugc nofollow" target="_blank">开放标准</a> <a class="ae ky" href="https://en.wikipedia.org/wiki/Application_layer" rel="noopener ugc nofollow" target="_blank">应用层</a>协议。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/6ea98ced97d4a8eb31433f2cb97d9b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iENRKlQlqeVOcYjEQHR-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">高级Python芹菜架构流</p></figure><p id="5760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Celery不仅仅是一个执行分布式异步工作的框架，它还有助于自动化日常工作，例如通过类似cron的表达式调度任务，或者通过celery chords执行大数据map-reduce风格的分布式工作。</p><p id="505b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">芹菜版本3.x和4.x之间有巨大的差异，很容易迷失在杂草中。本文旨在帮助您配置和运行最新的celery 4 . x版本，无论是独立的还是在您的Django应用程序中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="480d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">先决条件</h1><ul class=""><li id="0194" class="mv mw it lb b lc mx lf my li mz lm na lq nb lu nc nd ne nf bi translated">确保你已经安装了Python ≥ 3.6和更高版本——你可以在这里获得一个副本<a class="ae ky" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="a049" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">安装您选择的代理。理解架构是围绕可伸缩性设计的非常重要，因此尽早选择正确的代理非常重要。代理是中间件，以无缝、分布式的方式促进Python服务之间的通信。</li></ul><p id="eb75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">芹菜为以下经纪人提供现成的支持:</p><ul class=""><li id="870c" class="mv mw it lb b lc ld lf lg li nl lm nm lq nn lu nc nd ne nf bi translated"><a class="ae ky" href="https://www.rabbitmq.com/download.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>(可提供自托管或托管服务)。</li><li id="d720" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Redis(可提供自托管或托管服务，参见Redis部分下面的链接)。</li><li id="fd26" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">AWS SQS(提供免费层，通常不免费)。我个人不喜欢使用这个代理，因为它需要相当多的SQS权限来动态创建队列，在一些生产环境中这可能是不可接受的。</li><li id="892e" class="mv mw it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">Zookeeper 是一个分布式共享数据服务，从Celery 4.x开始仍处于试验阶段。</li></ul><p id="e4f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将重点放在Redis上。要让其他后端工作，您不需要做太多的更改——主要是在初始化celery类时更改URL。</p><p id="3a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想跳过Redis安装，可以选择利用托管云Redis。尝试<a class="ae ky" href="https://redislabs.com/redis-enterprise-cloud/pricing/" rel="noopener ugc nofollow" target="_blank"> redislabs </a>，它有一个免费层，您可以使用它进行测试运行，参见“当您需要运行独立的Celery时”一节。</p><h2 id="569c" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">如何在MAC上安装Redis broker？</h2><p id="e983" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">对于Redis，替代操作系统请参考<a class="ae ky" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank"> Redis快速入门指南</a></p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3531" class="no me it oe b gy oi oj l ok ol">$ brew install redis</span></pre><p id="da67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些有用的命令。</p><p id="bf89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算机启动时启动Redis:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="58d0" class="no me it oe b gy oi oj l ok ol">$ ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgents</span></pre><p id="7c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe om on oo oe b">launchctl</code>启动Redis服务器:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c363" class="no me it oe b gy oi oj l ok ol">$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plistt</span></pre><p id="9e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保Redis的安装能够正常工作，执行这个命令，它将返回<code class="fe om on oo oe b">PONG</code>:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ced7" class="no me it oe b gy oi oj l ok ol">$ redis-cli ping</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="15cf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">当你需要运行独立芹菜</h1><p id="078c" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">让我们准备一个清新的环境。我们将创建一个简单的程序，演示如何在独立的Python应用程序中使用celery。我们将使用requests库对CoinDesk的比特币价格指数(XBP) API进行简单的REST API调用，获取比特币价格。</p><p id="bf1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用下面的文件夹和文件结构创建一个名为<code class="fe om on oo oe b">celery_demo</code>的新文件夹:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/ff971c5048a3d15e80de2e50e51fd9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPV8jqFjkCY1_PZlDH97mg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">芹菜示范项目结构</p></figure><p id="2aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个Python虚拟环境，这样可以更好地隔离Python包并防止依赖冲突。<code class="fe om on oo oe b">cd</code>到您的<code class="fe om on oo oe b">celery_demo</code>文件夹，并创建一个虚拟环境，其中最后的<code class="fe om on oo oe b">venv</code>是虚拟环境的名称。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="7690" class="no me it oe b gy oi oj l ok ol">$ python3 -m venv venv</span></pre><p id="e0cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">激活您的<code class="fe om on oo oe b">venv</code>虚拟环境:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="fbf5" class="no me it oe b gy oi oj l ok ol">source venv/bin/activate</span></pre><p id="6392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们安装所需的Python包和用于Redis代理的<a class="ae ky" href="https://github.com/andymccurdy/redis-py" rel="noopener ugc nofollow" target="_blank"> Redis Python包</a>:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="424a" class="no me it oe b gy oi oj l ok ol">$ pip install celery[redis] requests</span></pre><p id="ffa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下代码添加到<code class="fe om on oo oe b">celery_demo/celery_tasks/tasks.py</code>。这段代码<strong class="lb iu"> </strong>演示了如何将任何python函数转换成Celery任务并执行异步调用。函数顶部的<code class="fe om on oo oe b">@task</code>装饰器将我们的基本Python函数标记为芹菜任务。我们的示例函数从CoinDesk获取最新的比特币价格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">芹菜任务. py</p></figure><p id="44a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建另一个名为<code class="fe om on oo oe b"><strong class="lb iu"> celery_demo/run_task.py</strong></code> <strong class="lb iu"> t </strong> hat的python脚本，我们将用它来测试我们的芹菜味道。您可以像运行任何其他norm Python脚本一样运行它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">芹菜跑_task.py</p></figure><p id="c79f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用Redislab托管服务，您需要通过设置<code class="fe om on oo oe b">REDIS_URL</code>环境变量来添加Redislab URL。下图显示了托管Redis实例的位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/eb3c2e3f0518974a5a122cc823e3874c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDDtFbGwW27-UDN4OkAlkA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果不使用本地Redis，请将redislab.com Redis URL复制到环境变量中</p></figure><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="e08e" class="no me it oe b gy oi oj l ok ol">$ export REDIS_URL=redis://{YOUR_DATABASE_NAME}:{YOUR_REDISLAB_PASSWORD}@redis-16062.c52.us-east-1-4.ec2.cloud.redislabs.com:16062/0</span></pre><p id="7e9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们执行我们的芹菜应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/844d82eea3afcd1bc974b458fc384af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgCLLoTR3jSygemtuGrKvQ.png"/></div></div></figure><p id="db7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我正在使用我的Pycharm IDE运行脚本。如果您在终端上，您可以发出这个命令来获得相同的结果:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="a27d" class="no me it oe b gy oi oj l ok ol">$ python run_task.py</span></pre><p id="8527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有注意到所有的东西都被返回为假的？这是因为我们还没有启动worker您发送给Celery的请求已经排队，但没有得到服务。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c7b6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">发射芹菜</h1><p id="f7ff" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">要启动Celery，您需要提供broker参数，这是通过队列发送消息所必需的。如果要检索已完成的函数或任务返回的状态和结果数据，需要设置back end参数，如以下代码所示:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="5dc1" class="no me it oe b gy oi oj l ok ol">app = Celery('tasks', broker=os.environ.get('REDIS_URL', 'redis://localhost:6379/0'), <strong class="oe iu">backend</strong>='redis')</span></pre><p id="7fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Redis作为我们的后端参数。注意:你除了Redis还有其他选项，比如<a class="ae ky" href="http://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank">SQLAlchemy</a>/<a class="ae ky" href="http://djangoproject.com/" rel="noopener ugc nofollow" target="_blank">Django</a>ORM、<a class="ae ky" href="http://memcached.org/" rel="noopener ugc nofollow" target="_blank"> Memcached </a>、<a class="ae ky" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>、<a class="ae ky" href="https://docs.celeryproject.org/en/stable/userguide/configuration.html#conf-rpc-result-backend" rel="noopener ugc nofollow" target="_blank">RPC</a>(<a class="ae ky" href="http://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank">rabbit MQ</a>/AMQP)，或者你可以定义自己的定制后端比如AWS S3或者<a class="ae ky" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> MiniO </a>。更多详情<a class="ae ky" href="https://docs.celeryproject.org/en/stable/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="9405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在尝试启动一个Celery worker，然后打开另一个终端窗口，激活虚拟环境，再次启动Python脚本。</p><p id="1fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一号航站楼窗口:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="9ff4" class="no me it oe b gy oi oj l ok ol">$ celery -A celery_tasks.tasks worker -l info</span></pre><p id="6176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二号终端窗口:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1bad" class="no me it oe b gy oi oj l ok ol">$ python run_task.py</span></pre><p id="e2f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="53a9" class="no me it oe b gy oi oj l ok ol"><strong class="oe iu">-A</strong>, <strong class="oe iu">--app is the </strong>app instance to use <!-- -->module.attr_name</span><span id="6a4c" class="no me it oe b gy ou oj l ok ol"><strong class="oe iu">-l</strong>, <strong class="oe iu">--loglevel is </strong>logging level, options are DEBUG, INFO, WARNING, ERROR, CRITICAL, or FATAL</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c632" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">定期任务独立Python芹菜</h1><p id="61b0" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">Celery提供了运行cron的能力，就像被称为周期性任务的计划作业一样。在遵循相同的生产者-消费者模型时，它们的工作方式略有不同。在周期性任务的上下文中，术语生产者是指<code class="fe om on oo oe b">Beat</code>(参见前面的芹菜流程图)，它向工人发送信号，以在特定的时间间隔/cron表达式中执行工作。</p><p id="f806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用独立定期调度程序的配置来覆盖我们的<code class="fe om on oo oe b">tasks.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">芹菜独立定期任务</p></figure><p id="b5a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Celery要求workers和beat都在运行，以便执行预定的作业。以下命令在一个命令中启动workers和beat，尽管在生产环境中它们需要作为独立的服务运行:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="09fb" class="no me it oe b gy oi oj l ok ol">$ celery -A celery_tasks.tasks worker -l info -B</span></pre><p id="e015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能不希望在同一个命令中运行Celery worker和Beat的主要原因是，本质上您创建了一个单点故障，并且否定了客户端消费者-生产者模型——通常Beat和worker应该在单独的隔离进程中执行，这些进程要么通过supervisor运行，要么在K8s pods或docker容器中运行。如果您喜欢在单独的进程中运行，您可以在不同的终端窗口中执行以下命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="e336" class="no me it oe b gy oi oj l ok ol">$ celery -A celery_tasks.tasks worker -l info</span><span id="f70b" class="no me it oe b gy ou oj l ok ol">$ celery -A celery_tasks.tasks beat -l info</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4859" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">将芹菜添加到Django 3.0应用程序中</h1><p id="3023" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">让我们看看如何将相同的芹菜任务配置到Django项目中。理想情况下，您应该为您的新Django项目创建一个新的虚拟环境。确保在Django项目中运行之前运行的pip install Celery和Redis命令。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8b56" class="no me it oe b gy oi oj l ok ol">$ pip install django</span></pre><p id="1a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用默认的Django admin start项目来自动生成一个简单的HelloWorld Django应用程序，这样我们就可以用我们之前创建的celery任务对它进行改进。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="fdd9" class="no me it oe b gy oi oj l ok ol"><strong class="oe iu">$</strong> django-admin startproject django_celery_site</span></pre><p id="aea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了Django应用程序，您的文件夹结构应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/1aaf7560372fddd1cd0919c061cbaf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVJAaLIIzJKLgWbQ9vkIew.png"/></div></div></figure><p id="f5d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe om on oo oe b">cd</code>放入内层的django_celery_site文件夹，外层的并不重要，你可以根据自己的需要重新命名。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="138b" class="no me it oe b gy oi oj l ok ol">$ cd django_celery_site</span></pre><p id="096f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在Django项目中加入芹菜。我们需要做的第一件事是创建以下文件django <code class="fe om on oo oe b">_celery_site/django_celery_site/celery.py</code>，并在下面添加以下代码，由用于注册我们的任务的celery上下文组成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe om on oo oe b">celery.py</code></p></figure><p id="07a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe om on oo oe b">Celery()</code>对象包含Celery任务和配置。通过定义<code class="fe om on oo oe b">config_from_object</code>和<code class="fe om on oo oe b">namespace</code>，我们将在Django的<code class="fe om on oo oe b">settings.py</code>中设置任何以<code class="fe om on oo oe b">'CELERY_'</code>开头的变量。我称之为“名称空间配置”。</p><p id="bf76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，不必在Django settings.py文件中指定配置。您可以选择在初始化Celery <code class="fe om on oo oe b">app</code>上下文的同一个文件中添加所有的Celery配置。</p><p id="df1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的settings.py将包含以<code class="fe om on oo oe b">CELERY</code>开头的所有内容的以下芹菜名称空间配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Django芹菜设置. py</p></figure><p id="eeb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe om on oo oe b">USE_TZ = True</code>(时区激活)，则确保设置相应的<code class="fe om on oo oe b">CELERY_TIMEZONE</code>。</p><p id="0b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是确保Django在初始化时加载芹菜<code class="fe om on oo oe b">app</code>，在<code class="fe om on oo oe b">django_celery_site/django_celery_site/__init__.py</code>中添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">姜戈芹菜__init__。巴拉圭</p></figure><p id="8e50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建您的<code class="fe om on oo oe b">django_celery_site/django_celery_site/tasks.py</code>,您的所有Python任务都将由Celery调用:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="9d19" class="no me it oe b gy oi oj l ok ol">from __future__ import absolute_import, unicode_literals<br/>from celery import task, shared_task<br/><br/><br/>@task()<br/>def latest_bitcoin_price(currency_code: str = None) -&gt; object:<br/>    <em class="ow"># Copy same bitcoin logic here our task will virtually peform the same logic as within our standalone celery example<br/>    </em>pass</span></pre><p id="b347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了启动您的芹菜，请使用启动芹菜的项目名称。因为您的<code class="fe om on oo oe b">celery.py</code>位于<code class="fe om on oo oe b">django_celery_site</code>中，所以这是您需要运行worker的目录。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="a23d" class="no me it oe b gy oi oj l ok ol">$ celery -A django_celery_site worker -l info <!-- -->--concurrency=1 -n wkr1@hostname<br/>e<!-- -->$</span></pre><h1 id="3e4a" class="md me it bd mf mg ox mi mj mk oy mm mn jz oz ka mp kc pa kd mr kf pb kg mt mu bi translated">姜戈方式的定期任务</h1><p id="d256" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">运行Django周期性任务可以通过启用Django项目settings.py中的一些配置来实现。由于周期性任务不需要返回结果，我们可以创建原始任务的副本，将其命名为<code class="fe om on oo oe b">latest_bitcoin_price_notify_task</code>，并进行一些小的修改，以便可以将结果推送到第三方服务<a class="ae ky" href="https://www.pushsafer.com/" rel="noopener ugc nofollow" target="_blank">pushsafe.com</a>。</p><p id="b403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用pushsafe是出于说明的目的——对于生产部署，有更多可扩展的解决方案，如带有Firebase云消息的SNS。</p><p id="026f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在我们的<code class="fe om on oo oe b">settings.py</code>中定义一个新条目<code class="fe om on oo oe b">CELERY_BEAT_SCHEDULE</code>，如图所示:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="376a" class="no me it oe b gy oi oj l ok ol">CELERY_BEAT_SCHEDULE = {<br/>    'latest_bitcoin_price_notify_task': {<br/>        'task': 'latest_bitcoin_price_notify',<br/>        'schedule': crontab(minute='*/1'),<br/>        'args': ('USD')<br/>    },<br/>}</span></pre><p id="9455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe om on oo oe b">PUSHSAFER_PRIVATE_KEY</code>添加到环境变量中:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8fc5" class="no me it oe b gy oi oj l ok ol">$ export PUSHSAFER_PRIVATE_KEY=yourprivatekeyhere</span></pre><p id="4ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这些放在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">芹菜任务推送通知</p></figure><p id="6035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在开发环境中，为了方便起见，我们可以使用all in one命令:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3f45" class="no me it oe b gy oi oj l ok ol">$ celery -A django_celery_site worker -l info -B</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b9cc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最后的想法</h1><p id="0fab" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在本文中，我们已经看到了如何快速地将发行版添加到Python应用程序中。在下一系列芹菜教程中，我们将会看到芹菜的最佳实践。</p><p id="81a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，请在下面留下反馈和评论。快乐编码。</p><div class="pc pd gp gr pe pf"><a href="https://medium.com/better-programming/python-celery-best-practices-ae182730bb81" rel="noopener follow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">Python芹菜最佳实践</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">帮助您用Celery构建可伸缩的分布式应用程序的提示和技巧</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">medium.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div></div></div>    
</body>
</html>