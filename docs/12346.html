<html>
<head>
<title>A Standard Template Library (STL) Tutorial Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">标准模板库(STL)教程系列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-standard-template-library-stl-tutorial-series-9379bcbcd2fb?source=collection_archive---------10-----------------------#2022-05-30">https://betterprogramming.pub/a-standard-template-library-stl-tutorial-series-9379bcbcd2fb?source=collection_archive---------10-----------------------#2022-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="320b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">现代有效的C++</h2><div class=""/><div class=""><h2 id="fa1a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">第1部分:概述和动机</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/b3dd83eddcc599133bfee2049a9f82dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*kY_brgmRKlAHTjjA1wu3Wg.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">作者图片</p></figure><p id="225b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">几个部分中的第一部分介绍了标准模板库(STL)。</p><pre class="ks kt ku kv gt lz ma mb mc aw md bi"><span id="a501" class="me mf it ma b gy mg mh l mi mj">· <a class="ae mk" href="#872b" rel="noopener ugc nofollow">The C++ Standard Library (SL)</a><br/>  ∘ <a class="ae mk" href="#16ac" rel="noopener ugc nofollow">What does SL offer?</a><br/>  ∘ <a class="ae mk" href="#dc1c" rel="noopener ugc nofollow">Why use the C++ SL?</a><br/>· <a class="ae mk" href="#0ef8" rel="noopener ugc nofollow">A Brief Overview of STL</a><br/>  ∘ <a class="ae mk" href="#d522" rel="noopener ugc nofollow">Why STL?</a><br/>· <a class="ae mk" href="#cd59" rel="noopener ugc nofollow">In Summary</a><br/>  ∘ <a class="ae mk" href="#6b88" rel="noopener ugc nofollow">What's Next?</a><br/>· <a class="ae mk" href="#65b1" rel="noopener ugc nofollow">References</a></span></pre><h1 id="d4b2" class="ml mf it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">C++标准库(SL)</h1><p id="2c5f" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">作为一名开发人员，尤其是在像C++这样非常成熟和稳定的软件语言中，为其核心库打下坚实的基础是非常重要的。在C++中，这是标准库，已经持续集成到从C++98到C++23的主要版本中[1]。</p><h2 id="16ac" class="me mf it bd mm nh ni dn mq nj nk dp mu lm nl nm mw lq nn no my lu np nq na iz bi translated">SL提供什么？</h2><p id="00b3" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">如图1所示，C++ SL的核心是STL。正如我们将在几篇博客中深入讨论的，STL是一个通用库，它提供了有效的算法解决方案来管理数据集合。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/9eff197679b11a39f07896f23423e362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xwoq7AazJ0zrdBd6sjUUw.png"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">图1 C++标准库(<em class="nw"> SL </em>)大多由STL组成。作者创作的插图。</p></figure><p id="4d6c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，STL之外的其他组件是SL的一部分。综上所述，SL还提供了[2]:</p><ul class=""><li id="d5c2" class="nx ny it lf b lg lh lj lk lm nz lq oa lu ob ly oc od oe of bi translated">字符串类</li><li id="f9c7" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">数字类</li><li id="a003" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">流I/O类的标准版本</li><li id="269d" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">基本内存分配</li><li id="495a" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">异常类</li><li id="1869" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">运行时类型信息</li></ul><p id="e635" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来让我们专注于STL。</p><h2 id="dc1c" class="me mf it bd mm nh ni dn mq nj nk dp mu lm nl nm mw lq nn no my lu np nq na iz bi translated">为什么要使用C++ SL？</h2><p id="4ff2" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">底线是，对C++的基本理解——尤其是有效的现代代码库——取决于对它的SL和不同头文件的了解，因此也是部分提供的接口。</p><p id="eb56" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用C++标准库的理由:</p><ol class=""><li id="0abf" class="nx ny it lf b lg lh lj lk lm nz lq oa lu ob ly ol od oe of bi translated">代码重用。没有必要重新发明轮子。</li><li id="8bb7" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly ol od oe of bi translated">高效—更快，同时使用更少的资源:现代C++编译器通常针对C++标准库代码进行优化。</li><li id="9cb3" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly ol od oe of bi translated">准确，更少的错误。</li><li id="0ac1" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly ol od oe of bi translated">简洁、可读的代码；减少控制流。</li><li id="45c7" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly ol od oe of bi translated">标准化，保证可用性。</li><li id="fa42" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly ol od oe of bi translated">编写库的角色模型。</li><li id="568e" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly ol od oe of bi translated">良好的数据结构和算法知识。</li></ol><h1 id="0ef8" class="ml mf it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">STL概述</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi om"><img src="../Images/b4d5143ac708d04216ce2033e507d244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bnqw-g8b2c7p9l-f.png"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">STL的组成部分。来源:[3]</p></figure><p id="457a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">数据结构和算法如上所述(参见第7项)。这些构成了STL的大部分。让我们先来看看STL的组件。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi on"><img src="../Images/4c6c0a29a60d28ad7db54c8635827411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VqGIooMJxIY8WQ2A"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated"><strong class="bd oo">图3 </strong> A是所有数据科学中的典型场景。作者创作的插图。</p></figure><p id="8c67" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如以前关于内存管理的博客系列(c.f .，[4]和[5])所述，我们有程序(例如，导入、控制流、i/o)，还有外部资源(例如，数据)。由于数据读入内存时没有任何结构，我们希望将数据点组织在一个容器中(即数据结构)。</p><p id="6f9c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，让我们假设在这个简单的例子中有两种数据类型。因此，我们想知道每个数据点的类型，是通过关联还是分组(图4)。</p><div class="ks kt ku kv gt ab cb"><figure class="op kw oq or os ot ou paragraph-image"><img src="../Images/de1672812cf35dd21bba0041b37b5861.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*QegthKcETR-Yx0-I8R85xw.png"/></figure><figure class="op kw ov or os ot ou paragraph-image"><img src="../Images/5bbe691f51e03ee040b805aa9d5aeb0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*j3T5zJWXBLO2Cu0rthnYlg.png"/><p class="kz la gj gh gi lb lc bd b be z dk ow di ox oy translated"><strong class="bd oo">图4。</strong>左边是按类型排列的数据点(如名义标签)，右边是组关联(如聚类)。作者创作了插图。</p></figure></div><p id="6ca5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">参见图4，考虑以下内容。对于这两种情况，理想的数据结构是如何操作的？我们需要更多的信息吗？</p><p id="d8c8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我们只暗示了STL提供的主要组件之一，容器(即数据结构)。算法呢？因此，回头看图3，现在回到左侧(即，程序本身)。我们想用算法来操作数据集。STL的另一个主要部分。</p><h2 id="d522" class="me mf it bd mm nh ni dn mq nj nk dp mu lm nl nm mw lq nn no my lu np nq na iz bi translated"><strong class="ak">为什么是STL？</strong></h2><p id="c331" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">好了，我们已经确定了容器和算法的需求和实际意义。让我们观察一下<code class="fe oz pa pb ma b">M</code>容器在<code class="fe oz pa pb ma b">N</code>算法上运行的情况。如图5所示，这将花费<code class="fe oz pa pb ma b">M*N</code>运行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/181d9240f8fdaafe8c7a11e72c989b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*PSExE2nt4t5ouzAxoWHY2g.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">图5<code class="fe oz pa pb ma b">M</code>N个算法的容器花费M*N个不同的脚本需要实现。作者创作的插图。</p></figure><p id="681d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">STL通过迭代器将两个高度配对的组件之间的接口一般化，以桥接这两个高度配对的组件。我们将在本系列的第4部分深入研究，<code class="fe oz pa pb ma b">Iterators</code>提供了一种只需要实现<code class="fe oz pa pb ma b">N+M</code>不同代码片段的方法(图6)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/84b0a80f16573642021c1f8ad1a15896.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*8Hqc_e3HigtTOhWWT8XXZQ.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">图6用于N个算法的M个容器花费M+N个不同的脚本需要被实现。作者创作的插图。</p></figure><p id="c9bc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">通常，如果我们想要支持<code class="fe oz pa pb ma b">A</code>算法和<code class="fe oz pa pb ma b">C</code>容器，我们需要<code class="fe oz pa pb ma b">A × C</code>实现。我们必须为每个容器<code class="fe oz pa pb ma b">C</code>实现<code class="fe oz pa pb ma b">A</code>算法。</p><ul class=""><li id="e87c" class="nx ny it lf b lg lh lj lk lm nz lq oa lu ob ly oc od oe of bi translated">解决这个问题的一个方法是使用多态性。但这会降低效率。</li><li id="60b2" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">STL用迭代器解决了这个问题。容器为实现的算法工作提供迭代器。因此，STL只需要为<code class="fe oz pa pb ma b">A</code>算法和<code class="fe oz pa pb ma b">C</code>容器提供<code class="fe oz pa pb ma b">A + C</code>实现。</li></ul><h1 id="cd59" class="ml mf it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated"><strong class="ak">总之</strong></h1><ul class=""><li id="d516" class="nx ny it lf b lg nc lj nd lm pe lq pf lu pg ly oc od oe of bi translated">STL的主要组件是算法和容器。</li><li id="473a" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">通常，如果我们想要支持<code class="fe oz pa pb ma b">A</code>算法和<code class="fe oz pa pb ma b">C </code>容器，我们需要<code class="fe oz pa pb ma b">A × C</code>实现。我们必须为每个容器<code class="fe oz pa pb ma b">C</code>实现<code class="fe oz pa pb ma b">A</code>算法。</li><li id="5097" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">使用STL有很多原因，所以在C++中尽可能使用它！</li><li id="ee35" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">它允许重用已经发明的代码。没有必要重新发明轮子！</li><li id="7b1d" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">它已经过优化，可能比你的算法和数据结构的实现更有效。</li><li id="f9bf" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">它可能比您(最初)编写的代码更少错误。</li><li id="35a3" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">STL是标准化的，并保证可以通过C++标准库获得。</li><li id="c57f" class="nx ny it lf b lg og lj oh lm oi lq oj lu ok ly oc od oe of bi translated">同样，使用它将为您提供数据结构和算法的良好知识。</li></ul><h1 id="6b88" class="ml mf it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">下一步是什么？</h1><p id="4aa7" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">接下来，我们将深入研究STL容器。然后，我们将讨论算法，之后将讨论迭代器。此外，最后一部分涵盖函子(在图2中，但超出了范围…现在)。</p><h1 id="65b1" class="ml mf it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">参考</h1><p id="0d20" class="pw-post-body-paragraph ld le it lf b lg nc kd li lj nd kg ll lm ne lo lp lq nf ls lt lu ng lw lx ly im bi translated">[1]<a class="ae mk" href="https://en.cppreference.com/w/cpp" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp</a></p><div class="ph pi gp gr pj pk"><a href="https://en.cppreference.com/w/cpp" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">C++参考</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">基本概念关键字预处理表达式声明初始化函数语句类重载…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">en.cppreference.com</p></div></div></div></a></div><p id="3399" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">[2]https://docs.oracle.com/cd/E19957-01/806-3569/Standard.html<a class="ae mk" href="https://docs.oracle.com/cd/E19957-01/806-3569/Standard.html" rel="noopener ugc nofollow" target="_blank"/></p><div class="ph pi gp gr pj pk"><a href="https://docs.oracle.com/cd/E19957-01/806-3569/Standard.html" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">C++标准库</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">当在默认(标准)模式下编译时，编译器可以访问C++…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">docs.oracle.com</p></div></div></div></a></div><p id="2655" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">[3]<a class="ae mk" href="https://www.mygreatlearning.com/blog/standard-template-library-in-c/" rel="noopener ugc nofollow" target="_blank">https://www . mygreatlearning . com/blog/standard-template-library-in-c/</a></p><div class="ph pi gp gr pj pk"><a href="https://www.mygreatlearning.com/blog/standard-template-library-in-c/" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">C++中的标准模板库</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">标准模板库是C++的最新版本。STL为程序员提供了有效存储数据的方法，并实现了数据的存储。</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">www.mygreatlearning.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py kx pk"/></div></div></a></div><p id="76c8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">[4]<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/understanding-smart-pointers-in-cpp-6c3854593503">https://better programming . pub/understanding-smart-pointers-in-CPP-6c 3854593503</a></p><div class="ph pi gp gr pj pk"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-smart-pointers-in-cpp-6c3854593503"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">现代C++:智能指针的近距离观察</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">《理解智能指针》续集betterprogramming.pub</h3></div></div><div class="pt l"><div class="pz l pv pw px pt py kx pk"/></div></div></a></div><p id="48b1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">[5]<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/understanding-smart-pointer-iii-909512a5eb05">https://better programming . pub/understanding-smart-pointer-iii-909512 a5 EB 05</a></p><div class="ph pi gp gr pj pk"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-smart-pointer-iii-909512a5eb05"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">通过直观的视觉效果解释C++智能指针</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">我的C++指针系列的第3部分</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">better编程. pub</p></div></div><div class="pt l"><div class="qa l pv pw px pt py kx pk"/></div></div></a></div><pre class="ks kt ku kv gt lz ma mb mc aw md bi"><span id="f788" class="me mf it ma b gy mg mh l mi mj"><strong class="ma jd">Want to Connect?</strong></span><span id="8024" class="me mf it ma b gy qb mh l mi mj">Follow Dr. Robinson on <a class="ae mk" href="https://www.linkedin.com/company/superannotate/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>