<html>
<head>
<title>Understandable Dependency Injection in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中可理解的依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understandable-dependency-injection-in-javascript-fab97062c34c?source=collection_archive---------1-----------------------#2022-01-13">https://betterprogramming.pub/understandable-dependency-injection-in-javascript-fab97062c34c?source=collection_archive---------1-----------------------#2022-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解依赖注入容器，并知道如何移除它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/62f3ccddaf622defec81268667649439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m_dOxT8eug15sPP5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">布莱克·康纳利在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="efcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我演示了一个易于理解和使用的依赖注入设置，它在执行浏览器或服务器应用程序以及运行测试时都有效。</p><p id="c410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在<a class="ae kv" href="https://github.com/tmj-code/understandable-dependency-injection-in-javascript" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到一个非常简单的例子(基本上是本文中的代码)以及一个扩展的例子。</p><h1 id="2792" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简介:什么是依赖注入</h1><p id="5bef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">依赖注入(或简称为DI)是一种构建应用程序的方法，这样您就不会在本地创建依赖项，而是从应用程序的其他地方获得这些依赖项。</p><p id="6e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中,<code class="fe mp mq mr ms b">PostController</code>依赖于<code class="fe mp mq mr ms b">PostService</code>从一些API获取帖子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6794" class="mx lt iq ms b gy my mz l na nb">/* --- ./post-controller.js --- */<br/>export default class PostController {<br/>    _postService;<br/>    _posts = [];<br/>    <br/>    constructor(postService) {<br/>      this._postService = postService;<br/>    }<br/>    <br/>    get posts() { return [..._posts]; }</span><span id="9c6a" class="mx lt iq ms b gy nc mz l na nb">    loadPost() {<br/>      this._postService.getList()<br/>          .then(posts =&gt; {<br/>              this._posts.length = 0;<br/>              this._posts.push(...posts);<br/>          });<br/>    }<br/>}</span></pre><p id="c813" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是<code class="fe mp mq mr ms b">PostController</code>并没有创造出一个<code class="fe mp mq mr ms b">PostService</code>；相反，它是通过构造函数提供的。这意味着<code class="fe mp mq mr ms b">PostController</code>唯一需要知道的就是如何使用<code class="fe mp mq mr ms b">PostService</code>。</p><p id="9d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DI的一个结果是测试变得容易多了，因为我们可以在测试期间简单地在构造函数中注入一个模拟的<code class="fe mp mq mr ms b">PostService</code>。</p><p id="e7f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">软件不容易。一个开发人员同时要记在脑子里的东西越多，留给他做出好的解决方案的脑力就越少。DI通过以集中和可预测的方式提供服务，消除了一些心理压力。</p><h1 id="8954" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">依赖注入容器</h1><p id="1a67" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">想象一下，在一个web应用程序中，我们有一个显示帖子列表的视图。它使用后置控制器来提供逻辑，本身只处理显示。我们不想担心如何创建控制器，所以我们要求有人提供给我们。</p><p id="d208" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们称之为依赖注入容器(以下简称:容器),因为它包含了提供服务实例的逻辑。</p><p id="ecbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在不对您可能使用的任何框架进行假设的情况下，显示帖子的视图可能如下所示:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c244" class="mx lt iq ms b gy my mz l na nb">/* --- ./post-view.js --- */<br/>import container from './di-container';</span><span id="6488" class="mx lt iq ms b gy nc mz l na nb">export default function PostView(rootElement) {<br/>    const controller = container.postController();</span><span id="30e2" class="mx lt iq ms b gy nc mz l na nb">    const list = document.createElement('ul');<br/>    rootElement.appendChild(list);</span><span id="48c5" class="mx lt iq ms b gy nc mz l na nb">    controller.loadPosts()<br/>        .then(() =&gt; {<br/>            while (list.lastChild) {<br/>                list.removeChild(list.lastChild);<br/>            }<br/>            <br/>            controller.posts.forEach(post =&gt; {<br/>                const item = document.createElement('li');<br/>                item.innerText = post.title;<br/>                list.appendChild(item);<br/>            });</span><span id="84b3" class="mx lt iq ms b gy nc mz l na nb">            rootElement.appendChild(list);<br/>        });<br/>}</span></pre><p id="2b56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本例中的视图只是呈现了一个带有文章标题的项目符号列表。</p><p id="5a25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个简短的例子中，我们看到导入的容器如何拥有一个返回<code class="fe mp mq mr ms b">PostController</code> <em class="nd"> : </em> <code class="fe mp mq mr ms b">const controller = container.postController();</code>实例的方法</p><p id="2656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看导入的文件<code class="fe mp mq mr ms b">di-container.js</code>中发生了什么:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6d86" class="mx lt iq ms b gy my mz l na nb">/* --- ./di-container.js --- */<br/>const postServiceFactory = () =&gt; <br/>  new PostService(/* possibly some arguments */);<br/>const postControllerFactory = () =&gt; <br/>  new PostController(postServiceFactory());</span><span id="99b7" class="mx lt iq ms b gy nc mz l na nb">const container = {<br/>  postController: postControllerFactory<br/>};</span><span id="3944" class="mx lt iq ms b gy nc mz l na nb">Object.freeze(container);</span><span id="477c" class="mx lt iq ms b gy nc mz l na nb">export default container;</span></pre><p id="b823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义<code class="fe mp mq mr ms b">twofunctions</code>每一个都交付一个依赖项。然后我们将它们公开为一个简单的对象(<code class="fe mp mq mr ms b">const container = {...};</code>)，只包含视图需要的服务:<code class="fe mp mq mr ms b">PostController</code>工厂函数。</p><p id="261b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以公开这个函数来创建一个<code class="fe mp mq mr ms b">PostService</code>，但是我们不要这样做，除非我们需要在某个视图中显式地使用它。</p><p id="4ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能注意到了上面的<code class="fe mp mq mr ms b">Object.freeze(container);</code>线。这是一个内置的JavaScript特性:被冻结的对象不能再被修改；您不能更改其属性，也不能添加新的属性。</p><p id="7ac0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然DI并不要求这样，但这是好的，因为我们可能会在许多不同的地方导入容器，我们不希望允许这些地方中的任何一个地方改变容器，从而破坏所有的地方。</p><p id="088f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面代码的唯一问题是，任何导入容器的人都会得到相同的依赖设置，无论是运行应用程序还是进行测试。如果我们要测试<code class="fe mp mq mr ms b">PostView</code>，我们将得到真正的<code class="fe mp mq mr ms b">PostController</code>，里面有一个真正的<code class="fe mp mq mr ms b">PostService</code>，从而在测试中调用真正的API。</p><p id="cf4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不希望这样，所以让我们看看如何解决这个问题。</p><h1 id="e7ca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">从容器中移除依赖项创建</h1><p id="b98f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将从容器中移除创建代码，并将其放在其他地方。这使得容器非常简单:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="45f8" class="mx lt iq ms b gy my mz l na nb">/* --- ./di-container.js --- */<br/>export default { };</span></pre><p id="52f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只是一个物体，仅此而已。如果您使用的是TypeScript，您确实需要更多，因为我们希望我们的容器公开类型化的方法:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="92fa" class="mx lt iq ms b gy my mz l na nb">/* --- ./di-container.ts --- */<br/>export default { } as any as {<br/>  postController: () =&gt; PostController<br/>};</span></pre><p id="c5e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们对TypeScript撒谎，声称容器有一个方法返回一个<code class="fe mp mq mr ms b">PostController</code>(在<a class="ae kv" href="https://github.com/tmj-code/understandable-dependency-injection-in-javascript" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的扩展示例中有一个稍微好一点的解决方案)。</p><p id="f6c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缺少的方法将使我们的视图失败，就像在JavaScript版本中一样，除非我们采取措施来确保该方法确实存在。那么我们在哪里做呢？</p><p id="7151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当在浏览器或服务器上运行我们的应用程序时，我们通常会有一个入口点:例如，在前端，一个HTML页面会加载<code class="fe mp mq mr ms b">main.js</code>，而一个服务器进程会在后端加载<code class="fe mp mq mr ms b">index.js</code>。测试时，每个测试都是自己的入口点。</p><p id="e745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将创建代码放在这个入口点，我们就能够在现实生活中使用一个设置，在测试中使用另一个设置(或多个设置)。它可能看起来像这样:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="a740" class="mx lt iq ms b gy my mz l na nb">/* --- ./main.js or ./index.js --- */<br/>import container from './di-container';<br/>import PostService from './post-service';<br/>import PostController from './post-controller';</span><span id="a62f" class="mx lt iq ms b gy nc mz l na nb">const postServiceFactory = () =&gt; <br/>  new PostService(/* possibly some arguments */);<br/>const postControllerFactory = () =&gt; <br/>  new PostController(postServiceFactory());</span><span id="3a7a" class="mx lt iq ms b gy nc mz l na nb">container.postController = postControllerFactory;</span><span id="b413" class="mx lt iq ms b gy nc mz l na nb">Object.freeze(container);</span><span id="6e33" class="mx lt iq ms b gy nc mz l na nb">/* ... more application initialization code ... */</span></pre><p id="5630" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来和以前几乎一样，除了现在是应用程序入口点定义如何设置服务。我们可以在测试设置中有类似的代码，只是带有模拟的服务。</p><p id="d5c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，在测试中，我们只需要模拟那些与每个测试相关的服务，例如省略<code class="fe mp mq mr ms b">PostService</code>设置。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6094" class="mx lt iq ms b gy my mz l na nb">/* --- ./post-view-test.js */<br/>import PostControllerMock from './post-controller-mock';</span><span id="3362" class="mx lt iq ms b gy nc mz l na nb">const postControllerFactory = () =&gt;<br/>  new PostControllerMock(/* some test data */);<br/>container.postController = postControllerFactory;</span><span id="7770" class="mx lt iq ms b gy nc mz l na nb">Object.freeze(container);</span><span id="f93b" class="mx lt iq ms b gy nc mz l na nb">/* ... test code ... */</span></pre><h1 id="db25" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加更多服务</h1><p id="5b2d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">添加更多服务时，您需要执行以下操作:</p><ul class=""><li id="5720" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">在<code class="fe mp mq mr ms b">index.js</code>(或者无论你的入口点是什么)中，你创建服务工厂，并在<code class="fe mp mq mr ms b">Object.freeze</code>之前将其设置为容器上的一个属性。</li></ul><p id="8dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于TypeScript(还有一步):</p><ul class=""><li id="c6a1" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">在<code class="fe mp mq mr ms b">di-container.ts</code>中，您将方法定义添加到容器导出中，就像我们对上面的<code class="fe mp mq mr ms b">PostController</code>所做的一样。</li></ul><p id="678b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有许多服务(这可能是典型的情况)，您应该考虑将容器设置转移到一个单独的文件中，以保持您的<code class="fe mp mq mr ms b">index.js</code>较小。请参见扩展示例。</p><h1 id="2713" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="3370" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">依赖注入看起来很神奇，但是这里我展示了一种既容易理解又容易使用的方法。它对JavaScript和TypeScript都有效，并且在运行测试时也有效。</p><p id="253e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好处:</p><ul class=""><li id="c8e6" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">易于理解，因为没有魔法(第三方包)或高级语言功能涉及。</li><li id="195f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">集中化，因此您的应用程序只需要在一个地方进行配置。</li><li id="4ebf" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">随着应用程序的增长，易于扩展新的服务。</li><li id="3ff9" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">支持测试，因为您使用模拟服务为每个测试单独设置了容器。</li></ul><p id="3a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，对于Typescript:</p><ul class=""><li id="aa20" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">类型安全，因为类型是直接从容器中推断出来的。</li><li id="5352" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">可跟踪，因为您可以跟踪每个服务，直到它被创建的地方。</li></ul><p id="afce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你以前没有使用过依赖注入吗？那就考虑试试吧。你会很快发现它使应用程序更简单，更容易理解，更容易维护和更新。</p></div></div>    
</body>
</html>