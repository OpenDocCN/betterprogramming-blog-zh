<html>
<head>
<title>Hilt — A New Dependency Injection Library for Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">hilt——一个新的Android依赖注入库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hilt-a-new-dependency-injection-library-for-android-e6e00e719aeb?source=collection_archive---------3-----------------------#2020-06-18">https://betterprogramming.pub/hilt-a-new-dependency-injection-library-for-android-e6e00e719aeb?source=collection_archive---------3-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b67f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解你需要知道的关于希尔特的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/762399b066590911fd77498960202b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AXGVFlsBGvr1WgGp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mjaswanth?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Matam Jaswanth </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="c101" class="le lf it la b gy lg lh l li lj">1. <a class="ae ky" href="#93ff" rel="noopener ugc nofollow">What's Dependency Injection?</a><br/>2. <a class="ae ky" href="#3156" rel="noopener ugc nofollow">Choosing the Right Technique for Your App</a><br/>3. <a class="ae ky" href="#9c80" rel="noopener ugc nofollow">History of DI in Android</a><br/>4. <a class="ae ky" href="#a8ae" rel="noopener ugc nofollow">Introducing Hilt—A Native DI Solution</a><br/>5. <a class="ae ky" href="#22dd" rel="noopener ugc nofollow">Terminology</a><br/>6. <a class="ae ky" href="#dae5" rel="noopener ugc nofollow">Integration</a><br/>7. <a class="ae ky" href="#4059" rel="noopener ugc nofollow">Hilt Setup</a><br/>8. <a class="ae ky" href="#c2af" rel="noopener ugc nofollow">Hilt With Third-Party Dependencies</a><br/>9. <a class="ae ky" href="#15ed" rel="noopener ugc nofollow">Hilt With ViewModels</a></span></pre></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="e45f" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">什么是依赖注入？</h1><p id="93ff" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated"><em class="ne">依赖注入(DI) </em>是类获取其他类引用的独特方式。例如，假设类<code class="fe nf ng nh la b">BananaMilkshake</code>需要<code class="fe nf ng nh la b">Milk</code>类。在这里，<code class="fe nf ng nh la b">BananaMilkShake</code>依赖于<code class="fe nf ng nh la b">Milk</code>类。通常这些必需的类，像<code class="fe nf ng nh la b">Milk</code>，被称为依赖。</p><p id="38ea" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">实施DI为您提供了以下优势:</p><ul class=""><li id="f390" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ns nt nu nv bi translated">代码的可重用性</li><li id="73aa" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated">易于重构</li><li id="3444" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated">易于测试</li></ul><p id="b065" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">有三种类型的依赖注入。</p><ol class=""><li id="484b" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ob nt nu nv bi translated">在类本身中创建所需的对象(就像在<code class="fe nf ng nh la b">BananaMilkshake</code>类中创建的<code class="fe nf ng nh la b">Milk</code>类对象)</li><li id="2d4d" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ob nt nu nv bi translated">从其他地方获取所需的对象(比如Android-activity组件中的上下文)</li><li id="fc6f" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ob nt nu nv bi translated">提供所需的类对象作为参数(可以通过构造函数来创建)</li></ol></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="3156" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">为您的应用选择正确的技术</h1><p id="ad23" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">正如Android团队建议的那样，如果你的应用包含三个或更少的屏幕，你可以不使用DI。但是三屏以上的，总是推荐用DI。</p><p id="2b36" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">如果您对DI提供的功能有深入的了解，那么选择它会更容易。</p><ul class=""><li id="d7ad" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ns nt nu nv bi translated"><strong class="mk iu">可重用性:</strong>随着项目的扩展，创建依赖关系的多个实现将变得更加容易，但是有了DI反转控制，依赖类不再控制依赖关系的创建方式</li><li id="2dc3" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><strong class="mk iu">易于重构:</strong>依赖关系的对象创建可以在编译时检查，而不是在运行时隐藏</li><li id="e50f" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><strong class="mk iu">易于测试:</strong>有了DI，就不会是一个产生依赖关系的类，所以测试会更容易</li></ul></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="9c80" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">Android中DI的历史</h1><p id="f2e3" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">早在Android开发初期，我们连DI这个概念都没有。开发人员根据需要创建对象，这导致了资源的过度使用和代码的不可重用性。</p><p id="1bcd" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">慢慢地，开发人员开始使用<code class="fe nf ng nh la b">ServiceGenerator</code>。<code class="fe nf ng nh la b">ServiceGenerator</code>是一个单例类，它将在必要时创建所需类的对象。如果我们再次请求这个类，它将返回之前创建的对象。</p><p id="cc0e" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">这个解决方案在一定程度上解决了这个问题。但是在<code class="fe nf ng nh la b">ServiceGenerator</code> s中，维护对象的作用域是非常忙碌的，就像内存管理一样。然后是Android中DI的强大<a class="ae ky" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank">匕首</a>库。</p><p id="2e52" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">Dagger和Dagger2对在Android上实现DI产生了巨大的影响。他们为开箱即用的开发带来了许多便利的特性:</p><ul class=""><li id="b857" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ns nt nu nv bi translated">创建您在手动DI部分中手动实现的<code class="fe nf ng nh la b">AppContainer</code>代码(应用程序图)</li><li id="f222" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated">为应用程序图中可用的类构建工厂。这就是依赖性在内部得到满足的方式，也是我们不需要编写所有样板代码的原因。</li><li id="bc82" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated">重用依赖项或创建类型的新实例取决于您如何使用范围配置类型</li><li id="0482" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated">Dagger还通过释放不再使用的对象来关心内存管理</li></ul><p id="b71f" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">Dagger库几乎解决了我们在实现DI时面临的所有问题。但是学习曲线非常深，尽管有Dagger代码生成，我们仍需要编写如此多的样板代码。</p><p id="9a61" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">最近，Yigit Boyar在一个视频中表示，Android团队收到的49%的请求都是要求他们增强DI实现流程。这是为Android开发Hilt的主要原因。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="a8ae" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">介绍Hilt——一个本地DI解决方案</h1><p id="7b68" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">Hilt构建在Dagger之上，提供了一种在Android应用中实现DI的标准方法。因此，Hilt比Dagger工作得好得多——而且对开发人员来说实现起来也不太复杂。</p><p id="ae1e" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">要使用Dagger库实现DI，我们需要自己编写模块、组件等等。最重要的是，每次我们创建一个新的Android组件——比如<code class="fe nf ng nh la b">Activity</code>、<code class="fe nf ng nh la b">Fragment</code>或<code class="fe nf ng nh la b">Service</code>——我们都需要手动将它们添加到各自的模块中，以便在必要时注入它们。</p><p id="82cd" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">专为Android开发的Hilt采取了为开发者节省大量时间的措施。我们不再需要通过如此复杂的设置来注入<code class="fe nf ng nh la b">Fragment</code>、<code class="fe nf ng nh la b">Activity</code>或<code class="fe nf ng nh la b">ViewModel</code> s。</p><p id="b9db" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">对于Hilt，我们可以使用如下注释:</p><ul class=""><li id="9953" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">@HiltAndroidApp</code>:我们需要将这个注释应用到我们的应用程序类，这将触发代码生成并创建基本组件</li><li id="a992" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">@AndroidEntryPoint</code> : Hilt创建一个依赖容器到它被分配的Android组件，这样它就可以注入依赖项</li></ul><p id="e80f" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">在本文接下来的部分中，您将详细了解这些注释。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="22dd" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">术语</h1><h2 id="ded6" class="le lf it bd ls oc od dn lw oe of dp ma mr og oh mc mv oi oj me mz ok ol mg om bi translated">@HiltAndroidApp</h2><p id="6d18" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">这个注释触发了Hilt的代码生成，包括应用程序的一个基类。应用程序容器是应用程序的父容器，这意味着其他容器(来自Android组件)可以访问它提供的依赖关系。</p><h2 id="d0d3" class="le lf it bd ls oc od dn lw oe of dp ma mr og oh mc mv oi oj me mz ok ol mg om bi translated">@ androdidentrypoint</h2><p id="400f" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">这个注释为每个Android组件生成一个单独的Hilt组件，这样它们就可以注入必要的依赖项。</p><h2 id="4523" class="le lf it bd ls oc od dn lw oe of dp ma mr og oh mc mv oi oj me mz ok ol mg om bi translated">@注入</h2><p id="4d06" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">这用于请求依赖项的构造函数、字段或方法中。</p><h2 id="e372" class="le lf it bd ls oc od dn lw oe of dp ma mr og oh mc mv oi oj me mz ok ol mg om bi translated">@模块</h2><p id="e8b7" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">这用于创建依赖类对象的类(对于您不拥有的类，例如，第三方库类，如OkHttp或Retrofit)。</p><h2 id="63eb" class="le lf it bd ls oc od dn lw oe of dp ma mr og oh mc mv oi oj me mz ok ol mg om bi translated">@InstallIn</h2><p id="0dd2" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">还应该用@InstallIn对Hilt模块类进行注释，以指定模块的范围。例如，如果我们用<code class="fe nf ng nh la b">@InstallIn(ActivityComponent::class)</code>注释模块，那么模块将绑定到活动生命周期。</p><h2 id="3fff" class="le lf it bd ls oc od dn lw oe of dp ma mr og oh mc mv oi oj me mz ok ol mg om bi translated">@提供</h2><p id="9389" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">这用于模块类内部的方法，并提供依赖对象。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="dae5" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">综合</h1><p id="9549" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">打开根<code class="fe nf ng nh la b">build.gradle</code>，在dependencies节点下添加下面的Hilt依赖项。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="96f9" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">出于代码生成的目的，我们需要添加Hilt插件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f727" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">最后，我们需要添加所需的依赖项来访问项目中的Hilt库。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a82d" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">就是这样；我们已经成功整合了刀柄库。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="40f9" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">刀柄设置</h1><p id="b1ea" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">我们不需要复杂的设置来使用Hilt实现基本的DI。首先，我们需要用<code class="fe nf ng nh la b">@HiltAndroidApp</code>注释我们的应用程序类，这样应用程序组件就会被创建。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用句柄注释一个“应用程序”类</p></figure><p id="fc82" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">所以现在我们可以在application类中注入类，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在“应用程序”类中注入类</p></figure><p id="8b1e" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">现在我们有了应用程序级的组件，我们可以为其他用<code class="fe nf ng nh la b">@AndroidEntryPoint</code>注释的Android组件提供依赖关系。</p><p id="325e" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">首先，让我们看看如何用这个注释实现<code class="fe nf ng nh la b">Activity</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用句柄注释对“活动”进行注释</p></figure><p id="73a4" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">Hilt目前支持以下Android组件:</p><ul class=""><li id="4af2" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">Application</code>(通过使用<code class="fe nf ng nh la b">@HiltAndroidApp</code>)</li><li id="f05f" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">Activity</code></li><li id="f3c9" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">Fragment</code></li><li id="3d50" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">View</code></li><li id="d7fc" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">Service</code></li><li id="8ec2" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><code class="fe nf ng nh la b">BroadcastReceiver</code></li></ul><p id="ac57" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">现在可以在那些用<code class="fe nf ng nh la b">@AndroidEntryPoint</code>标注的组件中注入依赖关系。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将依赖项注入“活动”</p></figure><p id="bf2f" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">在这里，我们需要注意的是，在使用Hilt和Android组件时:</p><ul class=""><li id="4624" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ns nt nu nv bi translated">如果你用<code class="fe nf ng nh la b">@AndroidEntryPoint</code>注释一个Android组件，比如一个<code class="fe nf ng nh la b">Fragment</code>，那么被注释的<code class="fe nf ng nh la b">Fragment</code>所依赖的其他类也应该用<code class="fe nf ng nh la b">@AndroidEntryPoint</code>来注释</li><li id="ab17" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated">如果父类是抽象的，我们不需要用<code class="fe nf ng nh la b">AndroidEntryPoint</code>来注释它们</li><li id="4daf" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated">当在<code class="fe nf ng nh la b">Activity</code>上使用句柄注释时，注入发生在<code class="fe nf ng nh la b">onCreate</code>函数中，所以确保以安全的方式使用那些依赖项</li></ul></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="c2af" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">带有第三方依赖项的句柄</h1><p id="d2ae" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">要将第三方依赖(如翻新)注入到像<code class="fe nf ng nh la b">Activity</code> s这样的Android组件中，我们需要使用模块。模块不过是用<code class="fe nf ng nh la b">@Module</code>标注的普通类，我们可以在其中创建第三方依赖的对象。让我们看看如何创建一个模块类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带柄的简单@模块类</p></figure><p id="8f47" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated"><code class="fe nf ng nh la b">@InstallIn</code>注释提供了与Android组件的模块绑定。这里，我们使用了<code class="fe nf ng nh la b">ApplicationComponent</code>，所以<code class="fe nf ng nh la b">NetworkModule</code>绑定到应用程序生命周期。</p><p id="d107" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">Hilt提供了更多的组件，可以用来将依赖关系绑定到Android类——请看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c4424198314920e83d435c73f0322704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0izuhEk7ZF4v1pzrM4kDHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截图来自Android开发者官方网站</p></figure><p id="aace" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">现在我们需要创建将<code class="fe nf ng nh la b">return</code>类型作为期望依赖项的函数。在这种情况下，依赖项是Retrofit和OkHttp。我们还需要用<code class="fe nf ng nh la b">@Provides</code>注释这些函数，这样Hilt就会知道它们。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带第三方库的刀柄模块</p></figure></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="15ed" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">带视图模型的刀柄</h1><p id="d27c" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">到目前为止，我们已经看到了如何使用Android组件和第三方库。现在，是时候向前迈出一步，与<code class="fe nf ng nh la b">ViewModel</code>注射一起工作了。</p><p id="57c1" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">在继续前进之前，我们必须在我们的项目中添加一些额外的库，以使Hilt与<a class="ae ky" href="https://developer.android.com/jetpack" rel="noopener ugc nofollow" target="_blank"> Jetpack </a>库如<code class="fe nf ng nh la b">ViewModel</code> s和<code class="fe nf ng nh la b">WorkManager</code>一起工作。</p><p id="251a" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">在应用程序级<code class="fe nf ng nh la b">build.gradle</code>文件的dependencies标签下包含以下库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="271c" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">这些库为像<code class="fe nf ng nh la b">ViewModel</code>和<code class="fe nf ng nh la b">WorkManger</code>这样的Jetpack库提供了扩展，以便与Hilt一起工作。他们将生成样板代码，为开发人员节省大量时间。</p><p id="e6da" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">现在我们从<code class="fe nf ng nh la b">ViewModel</code>类开始。首先，我们需要将<code class="fe nf ng nh la b">@ViewModelInject</code>包含在<code class="fe nf ng nh la b">ViewModel</code>构造函数中。这将告诉Hilt如何提供<code class="fe nf ng nh la b">ViewModel</code>的实例。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有“注入”注释的视图模型</p></figure><p id="c65d" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">现在，在像<code class="fe nf ng nh la b">Activity</code>和<code class="fe nf ng nh la b">Fragment</code>这样的Android组件中，我们可以不使用<code class="fe nf ng nh la b">@inject</code>而直接使用<code class="fe nf ng nh la b">by viewModels()</code>委托功能。看一看:</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="afe6" class="le lf it la b gy lg lh l li lj">private val <!-- -->mainViewModel<!-- -->: <!-- -->MainViewModel<!-- --> <strong class="la iu">by viewModels()</strong></span></pre><p id="5ac1" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">如果要使用<code class="fe nf ng nh la b">Activity</code>级的<code class="fe nf ng nh la b">ViewModel</code>，我们需要应用<code class="fe nf ng nh la b">by activityViewModels()</code>委托函数，而不是<code class="fe nf ng nh la b">by viewModels()</code>。仅此而已——你很适合带柄的MVVM建筑。</p><p id="7e93" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated"><strong class="mk iu">重要提示:</strong> Hilt仍然是它的Alpha阶段，所以你需要Android Studio Canary版本才能使用它。由于它仍处于Alpha阶段，所以不要在生产层面上使用它。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="f852" class="lr lf it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">奖金</h1><p id="351d" class="pw-post-body-paragraph mi mj it mk b ml mm ju mn mo mp jx mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">要了解更多关于DI的信息，请阅读下面的文章。</p><ul class=""><li id="277a" class="nn no it mk b ml ni mo nj mr np mv nq mz nr nd ns nt nu nv bi translated"><a class="ae ky" href="https://medium.com/better-programming/dependency-injection-in-android-with-dagger2-d260b8a72bb0" rel="noopener">“使用Dagger2在Android中进行依赖注入”</a></li><li id="36c5" class="nn no it mk b ml nw mo nx mr ny mv nz mz oa nd ns nt nu nv bi translated"><a class="ae ky" href="https://proandroiddev.com/exploring-dagger-hilt-and-whats-main-differences-with-dagger-android-c8c54cd92f18" rel="noopener ugc nofollow" target="_blank">“探索匕首-剑柄和匕首-安卓的主要区别”</a></li></ul><p id="0670" class="pw-post-body-paragraph mi mj it mk b ml ni ju mn mo nj jx mq mr nk mt mu mv nl mx my mz nm nb nc nd im bi translated">目前就这些——希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>