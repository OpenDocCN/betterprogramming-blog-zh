<html>
<head>
<title>Firestorm: An ORM for Firestore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">firestor:Firestore的orm</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/firestorm-an-orm-for-firestore-82ffa8a646c8?source=collection_archive---------5-----------------------#2019-08-13">https://betterprogramming.pub/firestorm-an-orm-for-firestore-82ffa8a646c8?source=collection_archive---------5-----------------------#2019-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="68e2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">确保类型安全，用Firestorm写更干净的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de5520bf735e388bfafc24e9929b521c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EA8znabdYiLArShmX7UuMQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank"> Firestore </a>标志</p></figure><p id="d8c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Firestorm是一个Firestore表单。如果你从未使用过Firestore，它是一个NoSQL数据库，可以让你启动你的项目，而不必担心可扩展性。</p><p id="5fc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你熟悉<a class="ae kv" href="https://medium.com/better-programming/solid-principles-simple-and-easy-explanation-f57d86c47a7f" rel="noopener">坚实的原则</a>，你会知道每个模块/类应该有一个单一的职责。当使用原生Firestore库编写代码时，很容易在业务逻辑中混淆访问数据库的代码。此外，您接收的数据将是JSON格式，如果您使用的是TypeScript，那么您可能会享受到类型安全的好处。</p><p id="0a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Firestorm通过将您的集合(和子集合)定义为模型，允许您轻松地从数据库层抽象出来，然后您可以使用这些模型来执行创建、读取、更新和删除<strong class="ky ir"> ( </strong> CRUD)操作。这有助于确保类型安全，并有助于编写更干净的代码。</p><h1 id="ccc2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">要求</h1><p id="8c8e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Firestorm依赖于使用TypeScript的<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank">实验装饰器</a>来定义你的模型。请确保您的<code class="fe mp mq mr ms b">tsconfig.json</code> ( <code class="fe mp mq mr ms b">ES5</code>是最低目标)中包含以下内容:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="e820" class="mx lt iq ms b gy my mz l na nb">{<br/>  "compilerOptions": {<br/>    "target": "ES5",<br/>    "experimentalDecorators": true,<br/>    "emitDecoratorMetadata": true,<br/>  }<br/>}</span></pre><h1 id="7dde" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">装置</h1><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d20a" class="mx lt iq ms b gy my mz l na nb">$ npm install firebase-firestorm</span></pre><h1 id="3b23" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">入门指南</h1><p id="77e4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这一节中，我们将带你看一个使用帖子、评论和作者的基本博客数据库的例子。</p><h2 id="6208" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">1.初始化火焰风暴</h2><p id="6c19" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一初始化你的Firestore应用程序，就给<code class="fe mp mq mr ms b">firestorm.initialize(firestore, options?)</code>打电话。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="60ba" class="mx lt iq ms b gy my mz l na nb">import * as firestorm from 'firebase-firestorm';<br/>...<br/>const firestore = firebase.initializeApp(...);<br/>firestorm.initialize(firestore, /* options */);<br/>...</span></pre><h2 id="dcf4" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">2.定义根集合</h2><p id="ca73" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这里我们有一个代表一个<code class="fe mp mq mr ms b">posts</code>集合的类。实体类通常是非具体化的，因为它们表示集合中的单个文档。要定义根集合，您必须:</p><ul class=""><li id="3fec" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">从<code class="fe mp mq mr ms b">Entity</code>类扩展而来。</li><li id="7329" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">用<code class="fe mp mq mr ms b">@rootCollection(opts: ICollectionConfig)</code>注释你的类。</li><li id="59f5" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">声明一系列字段，用<code class="fe mp mq mr ms b">@field(opts: IFieldConfig)</code>标注。</li></ul><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="7bec" class="mx lt iq ms b gy my mz l na nb">import { Entity, rootCollection, field } from 'firebase-firestorm';</span><span id="2a8b" class="mx lt iq ms b gy ob mz l na nb">@rootCollection({<br/>  name: 'posts',<br/>})<br/>export default class Post extends Entity {<br/>  @field({ name: 'title' })<br/>  title!: string;</span><span id="bda5" class="mx lt iq ms b gy ob mz l na nb">  @field({ name: 'content' })<br/>  content!: string;<br/>}</span></pre><h2 id="e11c" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">3.定义子集合</h2><blockquote class="oc od oe"><p id="178c" class="kw kx of ky b kz la jr lb lc ld ju le og lg lh li oh lk ll lm oi lo lp lq lr ij bi translated"><em class="iq">你的每一个模型，无论它们代表一个根集合还是子集合，都必须从提供的</em> <code class="fe mp mq mr ms b"><em class="iq">Entity</em></code> <em class="iq">类中扩展。</em></p></blockquote><p id="e4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们希望<code class="fe mp mq mr ms b">posts</code>集合中的文档有一个<code class="fe mp mq mr ms b">comments</code>的子集合。首先，我们需要为评论创建一个类。注意我们没有用<code class="fe mp mq mr ms b">@rootCollection</code>来注释这个类。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d5b3" class="mx lt iq ms b gy my mz l na nb">import { Entity, rootCollection, field } from 'firebase-firestorm';</span><span id="0445" class="mx lt iq ms b gy ob mz l na nb">export default class Comment extends Entity {<br/>  @field({ name: 'content' })<br/>  content!: string;</span><span id="27e7" class="mx lt iq ms b gy ob mz l na nb">  @field({ name: 'by' })<br/>  by!: string;<br/>}</span></pre><p id="7dd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe mp mq mr ms b">Post</code>类，我们可以使用<code class="fe mp mq mr ms b">@subCollection(opts: ISubcollectionConfig)</code>装饰器添加<code class="fe mp mq mr ms b">Comment</code>作为子集合。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="983c" class="mx lt iq ms b gy my mz l na nb">import { Entity, ICollection, rootCollection, field } from 'firebase-firestorm';<br/>import Comment from './Comment';</span><span id="1325" class="mx lt iq ms b gy ob mz l na nb">@rootCollection({<br/>  name: 'posts',<br/>})<br/>export default class Post extends Entity {<br/>  ...<br/>  @subCollection({<br/>    name: 'comments',<br/>    entity: Comment, // we must define the entity class due to limitations in Typescript's reflection capabilities. Progress should be made on this issue in future releases.<br/>  })<br/>  comments!: ICollection&lt;Comment&gt;;<br/>  ...<br/>}</span></pre><h2 id="1f9e" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">4.定义文档参考</h2><p id="bebe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，我们希望<code class="fe mp mq mr ms b">posts</code>集合中的文档引用<code class="fe mp mq mr ms b">authors</code>集合(另一个根集合)中的作者。首先，我们定义<code class="fe mp mq mr ms b">Author</code>实体:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5047" class="mx lt iq ms b gy my mz l na nb">import { Entity, rootCollection, field } from 'firebase-firestorm';</span><span id="8180" class="mx lt iq ms b gy ob mz l na nb">@rootCollection({<br/>  name: 'authors',<br/>})<br/>export default class Author extends Entity {<br/>  @field({ name: 'name' })<br/>  name!: string;<br/>}</span></pre><p id="d37f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以使用<code class="fe mp mq mr ms b">@documentRef(opts: IDocumentRefConfig)</code>装饰器添加一个对<code class="fe mp mq mr ms b">Post</code>实体的<code class="fe mp mq mr ms b">Author</code>引用:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="18db" class="mx lt iq ms b gy my mz l na nb">import { Entity, ICollection, IDocumentRef, rootCollection, field } from 'firebase-firestorm';<br/>import Author from './Author';</span><span id="d2d9" class="mx lt iq ms b gy ob mz l na nb">@rootCollection({<br/>  name: 'posts',<br/>})<br/>export default class Post extends Entity {<br/>  ...<br/>  @documentRef({<br/>    name: 'author',<br/>    entity: Author, // we must define the entity class due to limitations in Typescript's reflection capabilities. Progress should be made on this issue in future releases.<br/>  })<br/>  author!: IDocumentRef&lt;Author&gt;;<br/>  ...<br/>}</span></pre><h2 id="1665" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">5.查询/更新数据</h2><p id="092e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们已经建立了模型，我们准备开始查询。调用<code class="fe mp mq mr ms b">Collection(entity : IEntity)</code>将返回用户可以用来操作数据的方法列表。</p><p id="d703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">获取文件</strong></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0a72" class="mx lt iq ms b gy my mz l na nb">...<br/>const post = Collection(Post).get('post-1').then((post : Post) =&gt; {<br/>  console.log(post);<br/>});<br/>...</span></pre><p id="e702" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">得到一个子集合</strong></p><p id="03f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，<code class="fe mp mq mr ms b">Comment</code>是<code class="fe mp mq mr ms b">Post</code>的子集合。您可以从检索到的文档或文档引用中获取子集合。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="ef2b" class="mx lt iq ms b gy my mz l na nb">// Comment subcollection from document.<br/>const post = Collection(Post).get('post-1').then((post : Post) =&gt; {<br/>  const commentCollection = post.collection(Post);<br/>});</span><span id="0595" class="mx lt iq ms b gy ob mz l na nb">// Comment subcollection from document ref.<br/>const postRef = Collection(Post).doc('post-1');<br/>const commentCollection = postRef.collection(Post);</span></pre><p id="d590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询数据</strong></p><p id="1b9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe mp mq mr ms b">find(query : ICollectionQuery)</code>方法来查询数据。完整的选项列表可在<a class="ae kv" href="https://lmcq.github.io/firebase-firestorm/" rel="noopener ugc nofollow" target="_blank">文档</a>中找到，但它们本质上与Firestore提供的选项相同。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6296" class="mx lt iq ms b gy my mz l na nb">const posts = Collection(Post).find({<br/>    where: [<br/>      ['title', '==', 'Example Title'],<br/>      ...<br/>    ],<br/>  });</span></pre><p id="2acf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创建文档</strong></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="30a0" class="mx lt iq ms b gy my mz l na nb">...<br/>  const post = new Post();<br/>  post.id = 'post-1'; // id is optional, if it is not defined it will be generated by firestore.<br/>  post.title = 'Untitled';<br/>  let savedPost : Post;<br/>  Collection(Post).create(post).then((_savedPost : Post) =&gt; {<br/>    savedPost = _savedPost;<br/>  });<br/>...</span></pre><p id="3896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更新文件</strong></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9ef6" class="mx lt iq ms b gy my mz l na nb">...<br/>  const post = new Post();<br/>  post.id = 'post-1'; // id is required.<br/>  post.title = 'Untitled';<br/>  let savedPost : Post;<br/>  Collection(Post).update(post).then((_savedPost : Post) =&gt; {<br/>    savedPost = _savedPost;<br/>  });<br/>...</span></pre><p id="5708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">移除文件</strong></p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="474f" class="mx lt iq ms b gy my mz l na nb">...<br/>  Collection(Post).remove('post-id').then(...);<br/>...</span></pre><h2 id="7b54" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">6.格式化数据</h2><p id="c14a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">实体的一个实例可能包含一些属性，比如您不希望包含的子集合，例如，如果您正在构建一个REST API。在一个实体的实例上调用<code class="fe mp mq mr ms b">toData()</code>方法将产生一个普通的JSON对象，只包含原始数据、嵌套的JSON对象和已经使用<code class="fe mp mq mr ms b">.get()</code>方法检索的文档引用。例如:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="258d" class="mx lt iq ms b gy my mz l na nb">import { Collection } from 'firebase-firestorm';<br/>import Author from './Author';<br/>import Post from './Post';</span><span id="ba91" class="mx lt iq ms b gy ob mz l na nb">Collection(Post).get('post-1').then((post: Post) =&gt; {<br/>  console.log(post.toData());<br/>  /*<br/>  Output:<br/>  {<br/>    id: ...,<br/>    title: ...,<br/>    content: ...<br/>  }<br/>  */<br/> post.author.get().then((author: Author) =&gt; {<br/>   console.log(post.toData());<br/>   /*<br/>    Output:<br/>    {<br/>      id: ...,<br/>      title: ...,<br/>      content: ...,<br/>      author: {<br/>        id: ...,<br/>        name: ...<br/>      }<br/>    }<br/>   */<br/> });<br/>});</span></pre><h1 id="aee2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">自定义数据类型</h1><h2 id="5bc8" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">数组</h2><p id="7a43" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Firestore文档可以包含字符串、数字、对象等数组。在Firestorm中定义数组就像在<code class="fe mp mq mr ms b">Entity</code>文件中将属性指定为数组类型一样简单。例如:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c5fe" class="mx lt iq ms b gy my mz l na nb">class Example extends Entity {<br/>  @field({ name: 'example_property_1' })<br/>  property1!: string[];</span><span id="6210" class="mx lt iq ms b gy ob mz l na nb">  @field({ name: 'example_property_2' })<br/>  property2!: IDocumentRef&lt;AnotherEntity&gt;[];<br/>}</span></pre><h2 id="51d3" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">嵌套数据</h2><p id="2062" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Firestore文档可以包含嵌套对象(或地图)。对于嵌套对象，您需要创建一个新的类来表示该对象，并在您的<code class="fe mp mq mr ms b">Entity</code>中添加一个带有该类的属性，用<code class="fe mp mq mr ms b">@map</code>装饰器包装。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="12f1" class="mx lt iq ms b gy my mz l na nb">class Example extends Entity {<br/>  @map({ name: 'nested_object' })<br/>  nestedObject!: Nested;<br/>}</span><span id="4d4e" class="mx lt iq ms b gy ob mz l na nb">class Nested {<br/>  @field({ name: 'nested_property' })<br/>  nestedProperty!: string;<br/>}</span></pre><p id="4d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后使用这个实体:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="f8d3" class="mx lt iq ms b gy my mz l na nb">...<br/>const nested = new Nested();<br/>nested.nestedProperty = 'test';<br/>const example = new Example();<br/>example.nestedObject = nested;<br/>...</span></pre><h2 id="9322" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">地理点</h2><p id="2044" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">地理点存储位置数据，可用于野外。我们为Firestore的GeoPoint提供了一个包装类，它基本上提供相同的功能。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="210b" class="mx lt iq ms b gy my mz l na nb">class Example extends Entity {<br/>  @geopoint({<br/>    name: 'geopoint_property',<br/>  })<br/>  geopoint!: IGeoPoint;<br/>}</span></pre><p id="2bb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后指定一个地理点:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="ca8c" class="mx lt iq ms b gy my mz l na nb">...<br/>  const example = new Example();<br/>  example.geopoint = new Geopoint(latitude, longitude);<br/>...</span></pre><h2 id="1440" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">时间戳</h2><p id="2c5d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可以在您的<code class="fe mp mq mr ms b">Entity</code>文件中表示日期和时间数据。像GeoPoints一样，我们的时间戳表示本质上是Firestore的包装。您可以将该字段的选项设置为<code class="fe mp mq mr ms b">updateOnWrite</code>，它在创建或更新文档时使用服务器时间戳，或者使用<code class="fe mp mq mr ms b">updateOnCreate</code>或<code class="fe mp mq mr ms b">updateOnUpdate</code>。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="aca8" class="mx lt iq ms b gy my mz l na nb">class Example extends Entity {<br/>  @timestamp({<br/>    name: 'timestamp_property',<br/>    updateOnWrite: true,<br/>  })<br/>  timestamp!: ITimestamp;<br/>}</span></pre><h1 id="3e69" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">重要问题</h1><ul class=""><li id="c734" class="nn no iq ky b kz mk lc ml lf oj lj ok ln ol lr ns nt nu nv bi translated">根集合、子集合和嵌套映射的所有文件都必须有一个唯一的类名，这是由于元数据存储将所有内容联系在一起的方式。我们正在寻找解决这个问题的方法。</li><li id="7669" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">确保地理点、时间戳和文档参考等字段的类型前面有<code class="fe mp mq mr ms b">I</code>，例如<code class="fe mp mq mr ms b">IDocumentRef</code>、<code class="fe mp mq mr ms b">ITimestamp</code>、<code class="fe mp mq mr ms b">IGeoPoint</code>。</li></ul><h1 id="0f8a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">限制</h1><ul class=""><li id="bd4e" class="nn no iq ky b kz mk lc ml lf oj lj ok ln ol lr ns nt nu nv bi translated">目前不支持使用快照监听文档更新</li><li id="c81e" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">目前不支持事务和批量写入</li><li id="fc0b" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">不支持脱机存在</li></ul><h1 id="b73b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包扎</h1><p id="c1e5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这应该足够让你开始了。有关更多信息，请查看<a class="ae kv" href="https://github.com/lmcq/firebase-firestorm" rel="noopener ugc nofollow" target="_blank"> Github </a>上的回购协议，或查看<a class="ae kv" href="https://lmcq.github.io/firebase-firestorm/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div></div>    
</body>
</html>