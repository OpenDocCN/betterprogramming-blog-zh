<html>
<head>
<title>How to Find Vulnerability in Smart Contracts — Unexpected Ether</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何发现智能合同中的漏洞—意想不到的以太</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-find-vulnerability-in-smart-contracts-unexpected-ether-89f157ce2888?source=collection_archive---------5-----------------------#2022-02-07">https://betterprogramming.pub/how-to-find-vulnerability-in-smart-contracts-unexpected-ether-89f157ce2888?source=collection_archive---------5-----------------------#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2263" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">黑掉一个游戏智能合约，学习其防范措施</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/863624365aabec6a6bc56d231e37e354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuJOoiVOZuh25jY0A37GDw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://unsplash.com/@stillnes_in_motion" rel="noopener ugc nofollow" target="_blank">静止不动</a></p></figure><p id="09d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，当您向协定发送ether时，它必须执行回退函数或协定中定义的另一个函数。这里有两个例外，ether可以存在于一个契约中而不执行任何代码。依赖于发送给它们的所有以太网的代码执行的协定在以太网被强制发送的情况下容易受到攻击。</p><h1 id="cab2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">🔓漏洞</h1><p id="af63" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一种典型的防御性编程技术是<em class="mp">不变量检查</em>，这种技术在强制执行正确的状态转换或验证操作方面很有价值。这种方法包括定义一组不变量(不需要改变的度量或参数),并检查它们在一次(或多次)操作后不会改变。不变量的一个例子是<code class="fe mq mr ms mt b">totalSupply</code>固定发行<a class="ae kv" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md" rel="noopener ugc nofollow" target="_blank"> ERC20令牌</a>。因为任何函数都不应该改变这个不变量。</p><p id="06a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是，有一个显而易见的不变量可能很容易使用，但实际上可能被外部用户操纵(尽管智能合约中规定了规则)。这是合同中存储的当前乙醚。通常，当开发人员第一次了解可靠性时，他们会有一个误解，认为契约只能通过可支付函数来接受。这种误解会导致契约对其中的以太平衡有错误的假设，从而导致各种漏洞。这个漏洞的关键是<code class="fe mq mr ms mt b">this.balance</code>的(不正确)使用。</p><p id="1a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两种方法可以(强制)将以太发送到不使用payable函数或不执行契约上任何代码的契约:</p><h2 id="2b3c" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">1.自毁</h2><p id="5c22" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">每个契约将能够执行<code class="fe mq mr ms mt b">selfdestruct</code>功能，从契约地址中删除所有字节码，并将存储在那里的所有以太网发送到参数指定的地址。如果指定的地址也是协定，则不会调用任何函数(包括回退)。因此，<code class="fe mq mr ms mt b">selfdestruct</code>函数可以被强制发送以太到任何契约，而不管该契约中可能存在的任何代码，甚至是没有可支付函数的契约。这意味着攻击者可以创建一个具有<code class="fe mq mr ms mt b">selfdestruct</code>功能的契约，向它发送以太，调用<code class="fe mq mr ms mt b">selfdestruct(target)</code>并强制以太被发送到<code class="fe mq mr ms mt b">target</code>契约。</p><h2 id="baf3" class="mu lt iq bd lu mv mw dn ly mx my dp mc lf mz na me lj nb nc mg ln nd ne mi nf bi translated">2.当前乙醚</h2><p id="e542" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">另一种让以太进入契约的方法是用以太预加载契约地址。协定地址是确定性的—事实上，该地址是根据创建协定的地址的Keccak-256(类似于SHA-3)哈希和创建协定的事务随机数计算出来的。具体来说，它的形式如下:</p><pre class="kg kh ki kj gt ng mt nh ni aw nj bi"><span id="e13a" class="mu lt iq mt b gy nk nl l nm nn">address = sha3(rlp.encode([account_address,transaction_nonce]))</span></pre><p id="2b2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们探讨一下在这种情况下可能出现的一些陷阱。考虑一下<code class="fe mq mr ms mt b">EtherGame.sol</code>中过于简单的契约。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2c9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个契约代表一个简单的游戏(自然会涉及比赛条件)，玩家向契约发送0.5以太，希望自己成为第一个到达三个里程碑之一的玩家。里程碑以以太命名。第一个到达里程碑的人可以在游戏结束后分享以太。当到达10以太的最后一个里程碑时，游戏结束；用户可以要求他们的奖励。</p><p id="0cce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">EtherGame</code>合同的问题来自于<code class="fe mq mr ms mt b">this.balance</code>14号线和32号线的不良使用。攻击者可以通过<code class="fe mq mr ms mt b">selfdestruct</code>函数(前面已经讨论过)强制发送少量乙醚(比如0.1乙醚)来阻止任何未来的玩家到达里程碑。<code class="fe mq mr ms mt b">this.balance</code>由于这0.1以太的贡献，永远不会是0.5以太的倍数，因为所有合法玩家只能发送0.5以太的增量。这防止了第18、21和24行上的所有‘if’条件为真。</p><p id="c8ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更糟糕的是，错过一个里程碑的攻击者可以强行送出10个以太(或者等量的将契约平衡转移到<code class="fe mq mr ms mt b">finalMileStone</code>以上的以太)，可以永远锁定契约中的所有奖励。这是因为由于第32行上的需求(即，因为<code class="fe mq mr ms mt b">this.balance</code>大于<code class="fe mq mr ms mt b">finalMileStone</code>，所以<code class="fe mq mr ms mt b">claimReward</code>功能将总是恢复。</p><h1 id="7d3b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">预防技术</h1><p id="7f3a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种漏洞通常是由于滥用<code class="fe mq mr ms mt b">this.balance</code>而产生的。如果可能，合同逻辑应该防止依赖合同余额的精确值，因为它可以被人为操纵。如果应用基于<code class="fe mq mr ms mt b">this.balance</code>的逻辑，您将不得不处理意外的余额。</p><p id="f07e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要沉积乙醚的精确量，应使用自定义变量，该变量在可支付函数中递增，以安全地跟踪沉积乙醚。该变量不受通过<code class="fe mq mr ms mt b">selfdestruct</code>调用发送的强制以太网的影响。</p><p id="9ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，修正后的<code class="fe mq mr ms mt b">EtherGame</code>契约看起来可能是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="da0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们创建了一个新变量<code class="fe mq mr ms mt b">depositedWei</code>，它跟踪已知的乙醚沉积，我们在测试中使用的就是这个变量。请注意，我们不再引用<code class="fe mq mr ms mt b">this.balance</code>。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="d213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果还没有，请查看另一个漏洞“可重入性”:</p><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/preventing-smart-contract-attacks-on-ethereum-a-code-analysis-bf95519b403a"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">防止对以太坊的智能合约攻击——代码分析</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">让我们编写一个易受攻击的智能合约代码，看看攻击是如何工作的，并了解修复它的预防技术</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">better编程. pub</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kp oa"/></div></div></a></div></div></div>    
</body>
</html>