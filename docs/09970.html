<html>
<head>
<title>Mastering TypeScript Template Literal Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握TypeScript模板文本类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-typescript-template-literal-types-f4131a94ffb1?source=collection_archive---------0-----------------------#2021-11-09">https://betterprogramming.pub/mastering-typescript-template-literal-types-f4131a94ffb1?source=collection_archive---------0-----------------------#2021-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2886" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用awesome模板文字类型特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b03b38e20310d654c5b92c87c5e79140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0vEuygJivm2cUirhOapOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者捕获</p></figure><p id="3427" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Typescript从早期阶段就有了模板文本。当您想要从静态字符串创建类型时，它们非常有用。直到Typescript 4.1版本，我们才看到模板文字类型。在以后的版本中，Typescript团队已经完善了它的特性并修复了一些奇怪的地方。因此，它现在是一个成熟的特性。</p><p id="a765" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么是模板文字类型？他们只是一个字符串文字，但类固醇。现在，您可以向模板文本添加类型变量，Typescript将为您创建一个具有所有可能组合的类型。因此，您可以用一种快速简单的方式组合其他类型。</p><p id="337a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了做得更好，Typescript现在附带了一些字符串操作实用程序，可以帮助您动态转换任何字符串文字。</p><p id="74b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看到如何使用它们以及它的用例是什么。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="61de" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">基本用法</h1><p id="b893" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">模板文字类型用于产生字符串和字符串类型的任意组合。输出将是所有可能组合的联合字符串。</p><p id="e114" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个语法示例:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="ce82" class="nd mc it mz b gy ne nf l ng nh">type attrs = "Phone" | "Name";</span><span id="8b15" class="nd mc it mz b gy ni nf l ng nh">type target = <strong class="mz iu">`get${attrs}`;</strong></span><span id="5bba" class="nd mc it mz b gy ni nf l ng nh">// ✅ Result<br/>// target = "getPhone" | "getName";</span></pre><p id="cbca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">语法很简单，但是可读性很强，功能也很强大。</p><p id="619c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了更好地说明它的神奇之处，我们先来看一个例子。假设我们想要一个映射<code class="fe nj nk nl mz b">CSS</code>填充规则类型的类型。</p><p id="4ea2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码很简单:我们只需创建所有可能组合的并集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="21fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码像预期的那样工作，但是有点冗长。<code class="fe nj nk nl mz b">margin</code>规则几乎是相同的，但是使用这种方法，我们将不能重用任何东西。我们最终会得到大量重复的代码。</p><p id="8c09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次让我们通过使用模板文字类型来解决前面的<code class="fe nj nk nl mz b">css</code>类型映射问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7cd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们观察代码是如何变得更加简单和声明性的。如果我们想创建<code class="fe nj nk nl mz b">margin</code>类型，我们可以重用<code class="fe nj nk nl mz b">Direction</code>类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c1ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在Javascript中有这个变量，我们可以通过使用<code class="fe nj nk nl mz b">typeof</code>操作符来提取它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="785f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">限制</h1><p id="5e21" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">模板文字类型中允许的参数有哪些？我们可以使用对象或自定义类型吗？不，只允许原语的子集。</p><p id="2c0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一允许的是:<code class="fe nj nk nl mz b">string</code>、<code class="fe nj nk nl mz b">number</code>、<code class="fe nj nk nl mz b">bigint</code>、<code class="fe nj nk nl mz b">boolean</code>、<code class="fe nj nk nl mz b"> null</code>、<code class="fe nj nk nl mz b">undefined</code>或其中任何一个的联合组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e570" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在上面的例子中看到，通过使用一个复杂的，它会失败，因为它不知道如何将其序列化为字符串。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d9ba" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">字符串操作实用程序</h1><p id="4f1a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">除了这个新特性，Typescript还发布了一组实用工具来帮助处理字符串。它们并不排斥模板文字类型，但是当与它们结合使用时会很方便。</p><p id="fc27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是实用程序的完整列表:</p><ul class=""><li id="17ed" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><strong class="la iu">大写&lt; StringType &gt; </strong>:将字符串文字转换成大写。</li><li id="287c" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">小写&lt; StringType &gt; </strong>:将字符串文字转换为小写。</li><li id="b2a1" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">大写&lt; StringType &gt; </strong>:将第一个字母大写。</li><li id="047d" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">不大写&lt; StringType &gt; </strong>:将首字母小写。</li></ul><p id="31f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个这些实用程序运行的例子。它们只接受一个字符串作为参数，否则在编译时会抛出一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="526e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在更复杂的场景中使用它们。让我们将字符串文字类型与这些实用程序的用法结合起来。让我们连接两个类型，但是转换它们，使它们符合我们的CamelCase语法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b752" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们试图构造模板文字类型时，这些实用程序会有所帮助。它们通过让我们操纵字符串类型来组合一些新的类型，帮助我们建立一个真实的来源。我们不必创建只有微小差异的新字符串类型。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0d1e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">推理</h1><p id="f16b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在第一个例子中，我们已经看到了如何从现有的类型组合出新的类型。</p><p id="99c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们将看到如何使用模板文字类型从组合类型中提取类型。为此，我们将使用<code class="fe nj nk nl mz b">infer</code>关键字。这个关键字允许我们在一个条件类型中从另一个类型推导出一个类型。</p><p id="fa79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来做一个例子。让我们尝试提取一个字符串的根节点<code class="fe nj nk nl mz b">margin</code>，而不是组成<code class="fe nj nk nl mz b">marginRight</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0d94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上让我们了解了这个特性有多强大。我们不仅可以创造类型，还可以解构它们。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="bdf7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">模板字符串类型作为判别式</h1><p id="1e5e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当使用联合时，在Typescript中有一个使用文本类型的字段是很常见的。然后，您可以使用该字段缩小当前类型的范围。</p><p id="00ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Typescript 4.5之前，您不能对该字段使用模板文字类型。现在，这个4.5版本将在今年11月发布。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a25b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这说明了这个特性在每个Typescript版本中是如何变得越来越成熟的。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8565" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">与重新映射一起使用</h1><p id="2593" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">从Typescript 4.1开始，我们可以重新映射属性。这个特性本身就很棒。但是，如果我们将它与模板文字类型结合起来，我们可以实现一些很酷的行为。</p><p id="cab3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了展示我们可以实现什么，让我们创建一个实用程序来取消任何对象的键的大写。我们如何做到这一点？我们可以简单的组合<code class="fe nj nk nl mz b">Template Literal Types</code> + <code class="fe nj nk nl mz b">Remapping</code> + <code class="fe nj nk nl mz b">Uncapitalize utility</code>就搞定了。</p><p id="122a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5680" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为奖励，现在让我们做一个更复杂的场景。让我们创建一个重新映射实用程序，将<code class="fe nj nk nl mz b">Aysnc</code>添加到我们的方法中，并返回函数返回类型的<code class="fe nj nk nl mz b">Promise</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="70af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">语法可能有点难，但它只是使用了相同的工具:<code class="fe nj nk nl mz b">Template Literal Types</code> + <code class="fe nj nk nl mz b">Remapping</code> + <code class="fe nj nk nl mz b">Uncapitalize utility</code>。</p><h1 id="a139" class="mb mc it bd md me oc mg mh mi od mk ml jz oe ka mn kc of kd mp kf og kg mr ms bi translated">包裹</h1><p id="8123" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们已经看到模板文字类型是多么简单和强大。它的语法与<code class="fe nj nk nl mz b">ES6</code>相同，使用起来很直观。</p><p id="c258" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们将帮助我们保持代码干燥，并帮助我们建立一个单一的真理来源。这是所有Typescript代码库的最终目标。</p><p id="600e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这三个特性配合得非常好。如果没有模板文字类型，重映射就不会如此强大。它会感觉太手动或笨重。这是它的完美补充。</p><p id="c889" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，它还不是一个完整的功能。它将在未来的版本中不断发展。将来有一件很棒的事情，那就是创建我们自己的字符串操作工具的能力。这将有助于我们进一步微调它的行为，并使它适应我们的特定用例。</p><p id="cae3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ce05" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">有关系的</h1><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">TypeScript:映射类型的简明介绍</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">学习构建自己的一套TypeScript工具</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>