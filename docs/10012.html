<html>
<head>
<title>Golang 1.18: What You Need To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 1.18:你需要知道的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab?source=collection_archive---------2-----------------------#2021-11-15">https://betterprogramming.pub/golang-1-18-what-you-need-to-know-a5701f7e14ab?source=collection_archive---------2-----------------------#2021-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d08f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Go 1.18中有两个主要的东西你需要知道:类型参数(泛型)和模糊测试，但是为什么它们如此重要呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df4e4afddf3d8ac5925a6352660bb682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9yTYiRv0blFXZyAl.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Go Logo由Go作者—<a class="ae ky" href="https://blog.golang.org/go-brand" rel="noopener ugc nofollow" target="_blank">https://blog.golang.org/go-brand</a></p></figure><p id="604c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Golang团队正在努力开发Golang 1.18，该版本将于2022年2月发布，看起来这将是一个大版本。Golang 1.18将引入泛型(称为类型参数)以及模糊测试，这有可能永远改变我们开发和测试Golang程序的方式！下面我们来看看这两个新特性。</p><h1 id="a858" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">类型参数(又名泛型)</h1><p id="3909" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">类型参数(在其他语言中也称为泛型)将允许Go程序员用占位符类型名定义函数和方法。这将允许开发人员编写可以在项目的不同部分重用的代码，但仍然一般地为他们期望它支持的所有类型的数据工作。</p><p id="538c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个普通的Go函数(1.18之前)，它返回两个输入的最小数目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="95e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们接受两个整数作为参数。<code class="fe mu mv mw mx b">min(1,2)</code>和<code class="fe mu mv mw mx b">min(2,1)</code>都将返回<code class="fe mu mv mw mx b">1</code>。到目前为止还不错，但是当你想得到两个浮点值的最小数目时会发生什么呢？我们将不得不编写一个新的函数，它将两个浮点值作为参数，并且我们将无法重用第一个函数中的代码。函数的主体仍然是完全相同的代码。如果我们想获得两个float64值中的最小值，我们必须再次引入相同的函数，将float64作为参数。</p><p id="9190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看看Go中的泛型:</p><p id="8514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">泛型带来的最大变化是，现在可以用任意的占位符类型名来定义函数，这个占位符类型名以后将作为其他类型的参数。在Go中，泛型是以<code class="fe mu mv mw mx b">type T</code>的形式编写的。</p><p id="72ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以用任何占位符类型名称定义一个函数，该名称稍后将由另一个参数填充。因此，让我们将之前的示例重构为新的通用方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，代码有点长。首先，我们有一个接口，它将所有数值类型声明为一个名为“numeric”的新类型这意味着我们可以在泛型中使用<code class="fe mu mv mw mx b">float64</code>和<code class="fe mu mv mw mx b">int</code>。然后我们像以前一样定义一个新的函数<code class="fe mu mv mw mx b">min</code>。</p><p id="2de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的是，现在函数的头部有一个类型参数:<code class="fe mu mv mw mx b">min[T numeric]…</code>。这告诉Go类型<code class="fe mu mv mw mx b">T</code>应该是数字类型，所以我们在接口中声明的任何类型都可以。之后，一切又恢复正常，我们像以前一样声明函数，只是我们用<code class="fe mu mv mw mx b">T</code>替换了<code class="fe mu mv mw mx b">int</code>。</p><p id="8eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果现在调用新函数，Go将检查用户提供的类型是否适合接口。如果是，它将在整个函数中用该类型替换<code class="fe mu mv mw mx b">T</code>。所以如果我们输入一个类型为<code class="fe mu mv mw mx b">int</code>的数字，我们也会得到一个整数。如果我们输入一个<code class="fe mu mv mw mx b">float64</code>，我们将得到一个<code class="fe mu mv mw mx b">float64</code>返回，以此类推。因此，我们现在有了一个单一的“全能”函数，而不是编写12个内容完全相同，但Go中每个数值类型的参数类型不同的函数。</p><h1 id="586d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模糊测试</h1><p id="423b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除了泛型，Go还将在Golang版本中从一开始就内置模糊测试。模糊测试允许对大量不同的输入进行测试。例如，我们有一个函数，它接受两个数字作为参数，并对它们进行处理。我们现在要确保函数在单元测试中正常工作。</p><p id="fe70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常的方法是为我们期望函数处理的每个数字编写一个测试。如果我们的输入数据是[0，100]、[200，100]和[1234，4321]，那么我们总共有三个测试。但是如果用户输入了我们没有想到的东西呢？也许是负数？所以我们也必须测试这些。还有很多。</p><p id="e9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数的最初开发者可能不会考虑大数，因为他们认为没有人会在函数中插入一个大数，但也许有人会这样做。因此，他们还必须覆盖这些，以避免程序崩溃。对于数字，这可能很容易，但是如果测试只在输入[-1337，1337]时失败，该怎么办呢？</p><p id="478a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有其他数字工作正常。开发人员不可能测试每一个可能的输入值。这就是模糊测试的由来。模糊测试在你的函数中输入大量的随机值来测试它们。这是如何做到的:</p><p id="bb15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试必须在*_test.go文件中作为名为<code class="fe mu mv mw mx b">FuzzXxx</code>的函数，并且应该带有一个<code class="fe mu mv mw mx b">*testing.F</code>参数，就像<code class="fe mu mv mw mx b">TestXxx</code>函数带有一个<code class="fe mu mv mw mx b">*testing.T</code>参数一样。这是模糊测试的基本语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二行，你可以看到我们有一个正常的测试参数<code class="fe mu mv mw mx b">t *testing.T</code>和<code class="fe mu mv mw mx b">n int</code>。</p><p id="1f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数<code class="fe mu mv mw mx b">t</code>是你对普通单元测试所做的一切。但是后面的参数更有意思。您实际上可以使用任何类型，Go将自动运行带有随机参数输入的主体，这符合您的类型。</p><p id="2ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们的测试函数接受一个数字类型，Go将用随机数运行它。然后，您可以像平常一样检查错误，并且不必担心测试集。一切都将由模糊测试包来处理。</p><h1 id="4fd0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="4b81" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你是Golang开发人员，即将发布的Go 1.18将带来两个重大变化，可能会改变你在代码中使用泛型和模糊测试的方式。</p><p id="4cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了泛型，程序员可以创建函数来处理任何类型，而不必为每个数字类型编写12个不同的版本。模糊测试允许开发人员针对随机值运行单元测试，这有助于确保测试中覆盖更多可能的输入数据。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="3067" class="lv lw it bd lx ly nf ma mb mc ng me mf jz nh ka mh kc ni kd mj kf nj kg ml mm bi translated">有关系的</h1><div class="nk nl gp gr nm nn"><a href="https://blog.marvinjwendt.com/golang-community-spaces-that-you-need-to-know-776dd75b95d5" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">你需要知道的Golang社区空间！</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Go是一种编程语言，在过去的十年里，它的流行程度有了显著的提高。Go开发者…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">blog.marvinjwendt.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div></div></div>    
</body>
</html>