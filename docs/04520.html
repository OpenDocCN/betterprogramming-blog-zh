<html>
<head>
<title>You Should Stop Using Traditional Functions As Top-Level Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该停止使用传统函数作为JavaScript的顶层函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-we-should-stop-using-traditional-functions-as-top-level-functions-368cd5c30b9a?source=collection_archive---------4-----------------------#2020-04-19">https://betterprogramming.pub/why-we-should-stop-using-traditional-functions-as-top-level-functions-368cd5c30b9a?source=collection_archive---------4-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d08d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">函数应该是嵌套的和特定的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8a05efe03712c15c67a49991f1f7f74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_9yzHDfis9EcsCzd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易斯·汉瑟</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="3383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们用关键字<code class="fe lv lw lx ly b">function</code>定义函数。这是ES6之前提供的选项。</p><p id="15eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看为什么我们应该停止使用它们作为顶级函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="97e6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么我们使用传统的JavaScript函数作为顶层函数？</h1><p id="584f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们通常使用传统函数，因为在ES6之前我们别无选择，我们不知道箭头函数的存在，或者我们在某些情况下需要不同的<code class="fe lv lw lx ly b">this</code>(比如当我们定义构造函数时)。</p><p id="ac09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，传统的功能令人困惑，因为有些功能开发者很容易忽略。</p><h2 id="f2b8" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">提升</h2><p id="81f1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">传统的JavaScript函数在被定义为函数声明时会被提升。</p><p id="e58f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="a7a9" class="nd mh it ly b gy nt nu l nv nw">console.log(calcArea(1, 3));</span><span id="e972" class="nd mh it ly b gy nx nu l nv nw">function calcArea(width, height) {<br/>  return width * height;<br/>}</span></pre><p id="48e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们在定义<code class="fe lv lw lx ly b">calcArea</code>之前调用了它，因为函数声明被放在了顶部。</p><p id="228d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果我们写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="0c5e" class="nd mh it ly b gy nt nu l nv nw">console.log(calcArea(1,3));</span><span id="c913" class="nd mh it ly b gy nx nu l nv nw">const calcArea = function(width, height) {<br/>  return width * height;<br/>}</span></pre><p id="7eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到一个错误，因为<code class="fe lv lw lx ly b">calcArea</code>没有被提升到顶部。用不同的方式定义做不同事情的顶级函数是非常令人困惑的。</p><p id="8436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，箭头函数从来不会被提升，因为我们不能用函数声明来定义它们。它们只有在赋给变量或常量时才会被命名。</p><p id="9437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们必须写:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="1632" class="nd mh it ly b gy nt nu l nv nw">const calcArea = (width, height) =&gt; {<br/>  return width * height;<br/>}</span><span id="1a66" class="nd mh it ly b gy nx nu l nv nw">console.log(calcArea(1,3));</span></pre><p id="3e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来调用<code class="fe lv lw lx ly b">calcArea</code>函数。没有别的称呼了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e93d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">混淆这个值和混淆构造函数</h1><p id="a793" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">传统函数内部的<code class="fe lv lw lx ly b">this</code>值不同于其外部的<code class="fe lv lw lx ly b">this</code>值。</p><p id="5a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">this</code>的值是在传统函数内部的函数。这对于创建传统函数很有用。</p><p id="5ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="66db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们从<code class="fe lv lw lx ly b">console.log</code>得到‘简·史密斯’,因为我们创建了一个<code class="fe lv lw lx ly b">Person</code>的实例，其中<code class="fe lv lw lx ly b">'Jane'</code>设置为<code class="fe lv lw lx ly b">this.firstName</code>并且<code class="fe lv lw lx ly b">'Smith'</code>设置为<code class="fe lv lw lx ly b">this.lastName</code>。</p><p id="eba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于习惯于用其他面向对象语言开发的程序员来说，我们可以从中创建实例的函数总是令人困惑。</p><p id="e77e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能够在一个函数内部分配函数就更令人困惑了。</p><p id="1f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了补救这一点，我们可以用JavaScript编写类，这是构造函数的语法糖。</p><p id="f4e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将<code class="fe lv lw lx ly b">Person</code>构造函数重写为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="de45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这要清楚得多，因为它包含了程序员在一个类中习惯使用的东西，这是一个传入参数来实例化该类的<code class="fe lv lw lx ly b">constructor</code>。它还有<code class="fe lv lw lx ly b">fullName</code>方法，这是一个传统的函数，就像我们上面提到的一样。只是现在我们可以用速记来写了。</p><p id="54ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道<code class="fe lv lw lx ly b">this</code>是<code class="fe lv lw lx ly b">Person</code>实例，不像<code class="fe lv lw lx ly b">Person</code>的构造函数。</p><p id="c80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以毫不费力地扩展<code class="fe lv lw lx ly b">Person</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们创建了扩展了<code class="fe lv lw lx ly b">Person</code>类的<code class="fe lv lw lx ly b">Employee</code>类，如<code class="fe lv lw lx ly b">extends</code>关键字所示。</p><p id="71eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以通过使用<code class="fe lv lw lx ly b">Person</code>构造函数的参数调用<code class="fe lv lw lx ly b">super</code>来调用<code class="fe lv lw lx ly b">Employee</code>类<code class="fe lv lw lx ly b">constructor</code>中的<code class="fe lv lw lx ly b">Person</code>构造函数。</p><p id="b20e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也比构造函数清晰得多。要扩展构造函数，我们必须将子构造函数的原型设置为父构造函数的原型。我们还必须记住设置父构造函数的实例变量。如果我们忘记了，JavaScript解释器不会警告我们。</p><p id="3e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果我们忘记在子类中调用<code class="fe lv lw lx ly b">super</code>，我们将得到一个错误。</p><p id="133e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使使用传统函数更加混乱，我们可以使用传统函数自带的<code class="fe lv lw lx ly b">call</code>、<code class="fe lv lw lx ly b">apply</code>和<code class="fe lv lw lx ly b">bind</code>方法来改变<code class="fe lv lw lx ly b">this</code>的值。这造成了更多的问题，因为我们可能将其设置为错误的值。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="db94" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参数对象</h1><p id="fef7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">传统函数有<code class="fe lv lw lx ly b">arguments</code>对象，这是一个类似数组的对象，包含我们传递给传统函数的所有值。</p><p id="1205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它具有欺骗性，因为它是一个类似数组的对象，而不是一个数组。<code class="fe lv lw lx ly b">arguments</code>具有<code class="fe lv lw lx ly b">length</code>属性，可以用循环迭代，但是所有的数组方法都丢失了。</p><p id="4de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES6或更高版本有<code class="fe lv lw lx ly b">rest</code>操作符来获取超过我们传入的参数数量的参数。</p><p id="69bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以如下使用<code class="fe lv lw lx ly b">rest</code>操作符:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="988f" class="nd mh it ly b gy nt nu l nv nw">const getRestArgs = (a, b, ...rest) =&gt; rest;<br/>console.log(getRestArgs(1, 2, 3, 4, 5, 6));</span></pre><p id="5d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">getRestArgs(1, 2, 3, 4, 5, 6)</code>将记录<code class="fe lv lw lx ly b">[3, 4, 5, 6]</code>，因为前两个参数被设置为参数<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>。用<code class="fe lv lw lx ly b">...</code>表示的<code class="fe lv lw lx ly b">rest</code>操作符将把剩余的参数放到操作符后面的数组中。在这种情况下，<code class="fe lv lw lx ly b">rest</code>就是那个数组。</p><p id="5066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">箭头函数不绑定到<code class="fe lv lw lx ly b">arguments</code>，所以如果我们不关心<code class="fe lv lw lx ly b">this</code>的值，这是一个很好的选择。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8913" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="e9e2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是时候停止使用传统函数作为顶层函数了。它们令人困惑，因为如果它们被定义为函数声明，它们可能会被提升。</p><p id="3324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，<code class="fe lv lw lx ly b">this</code>令人困惑——尤其是当我们不想定义构造函数的时候。</p><p id="7552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想定义构造函数，我们应该使用类。它们可以从其他类继承，我们可以使用它们内部的传统函数作为方法。</p><p id="6f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想定义不是构造函数的顶级函数，那么我们应该使用箭头函数，因为我们不必担心<code class="fe lv lw lx ly b">this</code>的值。</p><p id="e8bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，既然我们有了rest操作符，那么<code class="fe lv lw lx ly b">arguments</code>对象基本上是无用的。</p><p id="af00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们应该创建类或箭头函数来代替顶层的传统函数。</p></div></div>    
</body>
</html>