<html>
<head>
<title>Testing in Node.js Using Mocha and Chai (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mocha和Chai在Node.js中进行测试(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-in-node-js-using-mocha-and-chai-part-2-5b5c56bf2075?source=collection_archive---------15-----------------------#2020-09-02">https://betterprogramming.pub/testing-in-node-js-using-mocha-and-chai-part-2-5b5c56bf2075?source=collection_archive---------15-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a773" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试Node.js APIs的高级用例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4aae73d52e8088a07c5f7cf1f25ded88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kC-xl8XOmmaDm_GUI-eChw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae ky" href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="f8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们向您介绍了Node.js 中测试的<a class="ae ky" href="https://medium.com/better-programming/testing-in-node-js-using-mocha-and-chai-part-1-d5a9e91f4b06" rel="noopener">基础。正如我们所承诺的，本文继续上一篇文章的内容，讨论与测试一个</a><a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>程序相关的更高级的概念。</p><p id="ea24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将向您介绍测试软件的第二层，集成测试，以及常见的测试实践，如模仿和存根。</p><p id="22e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们了解什么是集成测试，以及我们为什么需要它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1b50" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是集成测试？</h1><p id="6cb9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">集成测试将几个单元(我们在单元测试中测试过的)组合在一起，并作为一个组进行测试。它检查系统中与单元之间的交互相关的错误。</p><p id="28ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用集成测试来测试来自数据库、远程API和API端点的数据检索。集成测试的使用增加了测试覆盖的代码的广度。</p><p id="b06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，集成测试是开发人员的责任。但是由独立测试人员来执行测试的情况并不少见。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4a60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Node.js与Mocha和Chai的集成测试</h1><p id="9b3e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从Node.js集成测试开始，我们将使用<a class="ae ky" href="https://www.npmjs.com/package/mocha" rel="noopener ugc nofollow" target="_blank"> Mocha </a>和<a class="ae ky" href="https://www.npmjs.com/package/chai" rel="noopener ugc nofollow" target="_blank"> Chai </a> npm包。出于测试目的，我们将使用带有REST端点的Express服务器。为了在测试期间向这个服务器发送HTTP请求，我们使用了一个名为<a class="ae ky" href="https://www.npmjs.com/package/chai-http" rel="noopener ugc nofollow" target="_blank"> Chai HTTP </a>的新包。在继续之前，请确保使用npm install命令安装Chai HTTP。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试异步函数</h1><p id="1970" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用Mocha测试异步函数时，我们必须遵循与上一教程中使用的格式略有不同的格式。尽管我使用了<em class="mz"> new </em>这个词来描述这种格式，但它对于Node.js开发人员来说并不陌生。我们可以传递一个回调，或者如果异步函数返回一个承诺，在<code class="fe na nb nc nd b">it</code>函数中使用承诺或async/await来处理异步代码，就像我们通常在Node.js中做的那样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2109" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">编写测试API的测试用例</h1><p id="2a68" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于集成测试的第一个实现，我们使用REST API，它根据请求从数据库中检索相关数据，并将它们发送回客户端。为了测试实现的清晰性，假设数据库(我们使用的是MongoDB数据库)和应用程序的数据模型已经设置好了。</p><p id="2c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">POST <code class="fe na nb nc nd b">route /dogs</code>用于使用通过POST请求从客户端发送的数据将新狗保存到数据库中。我们在这一步中使用的<code class="fe na nb nc nd b">Dog</code>模型有三个属性:狗的名字、年龄和品种。我们需要通过HTTP请求将这些数据传递给<code class="fe na nb nc nd b">/dog</code>路由来创建一条新的狗。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="77c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理完API的所有路由时，不要忘记导出<code class="fe na nb nc nd b">app</code>对象，以便我们可以访问服务器进行测试。</p><pre class="kj kk kl km gt ng nd nh ni aw nj bi"><span id="3faf" class="nk md it nd b gy nl nm l nn no">module.exports = app</span></pre><p id="b14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试目录中创建一个名为<code class="fe na nb nc nd b">dogs.js</code>的文件，为这条路径编写测试用例。在这个文件中，我们正在测试这个路由，看它是否响应了我们期望的结果。在这种情况下，这是一个新狗被成功保存到数据库的确认。</p><p id="58e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，因为我们只是测试这段代码，所以在测试用例完成后，我们需要让数据库保持初始状态。因此，我们必须在每个测试用例之后删除输入到数据库中的每个新记录。我们可以用摩卡的<code class="fe na nb nc nd b">afterEach</code>钩子来实现这个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用async/await来处理异步路由处理功能。然后，我们使用Chai(它正在使用<code class="fe na nb nc nd b">chai-http</code>)向服务器发送POST请求。我们可以使用<code class="fe na nb nc nd b">send</code>方法发送POST请求的主体。Chai的<code class="fe na nb nc nd b">expect</code>函数用于断言响应等于我们所期望的。</p><p id="81e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当测试复杂得多的API端点时，您可以遵循相同的测试过程。如果测试涉及到从数据库中输入或检索数据，确保使用Mocha的<code class="fe na nb nc nd b">beforeEach</code>和<code class="fe na nb nc nd b">afterEach</code>函数输入和删除记录，使数据库保持初始状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4795" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对Sinon使用存根</h1><p id="ee69" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">存根被用作被测试组件使用的函数的临时替代。我们使用存根来模拟给定函数的行为。使用存根而不是函数的实际实现的原因因情况而异。当我们只想测试单个单元的行为时，存根在单元测试中特别有用。在集成测试中，当给定的函数尚未实现，但需要测试当前组件时，使用存根。当几个组件被绑定到另一个组件上进行集成测试时，如果我们想测试只有几个组件如何一起工作，我们可以使用存根来替换其中的一些组件。</p><p id="00a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设上面的POST <code class="fe na nb nc nd b"> /dogs</code>路由有中间件检查发送请求的用户是否登录。(可以适当实现<code class="fe na nb nc nd b">isLoggedIn</code>函数。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="58ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但目前，我们只想测试将狗的详细信息保存到数据库并发送响应的功能。换句话说，我们现在不想测试路由处理功能和中间件如何协同工作。所以我们可以创建一个存根来代替中间件功能。</p><p id="3837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用名为<a class="ae ky" href="https://www.npmjs.com/package/sinon" rel="noopener ugc nofollow" target="_blank"> Sinon </a>的npm包为Node.js程序创建存根。在继续之前，您应该继续将软件包安装到您的应用程序中。</p><p id="20e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用Sinon的<code class="fe na nb nc nd b">callsFake</code>函数来创建中间件存根。我们在每个测试用例之前使用<code class="fe na nb nc nd b">beforeEach</code>钩子创建这个存根。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在每个测试用例之前重新导入app对象，所以我们也把它放在了<code class="fe na nb nc nd b">beforeEach</code>钩子中。在每个测试用例之后，我们需要恢复存根。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6722" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用Nock模仿HTTP请求</h1><p id="1c9f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果被测试的组件必须从外部API或服务中检索数据，它需要向这个API/服务发送一个HTTP请求，并等待响应到达。如果我们没有显式地测试到这个API的连接性，不向外部API发送实际的请求可以减少测试时间，并保证测试不会因为不良的网络连接等原因而失败。如果我们没有向API发送实际的请求，我们需要在测试期间伪造这个请求，这种做法被称为模仿HTTP请求。</p><p id="5d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们使用另一个名为<a class="ae ky" href="https://www.npmjs.com/package/nock" rel="noopener ugc nofollow" target="_blank"> Nock </a>的npm模块来模拟对外部API的HTTP请求。它拦截外部请求，并允许我们返回定制的响应，以适应特定的测试用例。</p><p id="7e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的API有路由GET <code class="fe na nb nc nd b">/dogs/:breed</code>。它通过向<a class="ae ky" href="https://dog.ceo/dog-api/documentation/" rel="noopener ugc nofollow" target="_blank">狗API </a>发送请求来返回给定狗品种的子品种。(<a class="ae ky" href="https://dog.ceo/api/breed/" rel="noopener ugc nofollow" target="_blank">https://dog.ceo/api/breed/</a>/列表)。我们的应用服务器向Dog API发送GET请求，然后从Dog API返回的数据被发送回客户机。</p><p id="8f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用包<a class="ae ky" href="https://www.npmjs.com/package/superagent" rel="noopener ugc nofollow" target="_blank"> Superagent </a>向外部API发送请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="87c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它从URL中检索品种名称，并向Dog API发送GET请求以获取子品种。</p><p id="db91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以测试这条路线是否有问题。因为我们模拟了对外部API的请求，并在测试期间发送了一个定制响应，所以我们需要将这个定制响应保存在一个文件中，以便能够在任何时候检索它。我将它保存在测试目录中一个名为<code class="fe na nb nc nd b">response.js</code>的文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为上述路线编写测试用例。类似于我们之前所做的，这里我们定义了使用Nock在<code class="fe na nb nc nd b">beforeEach</code>钩子内发送的模拟HTTP请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="04ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们向<code class="fe na nb nc nd b">/dogs/:breed</code>路由发送GET请求时，Nock拦截对Dog API的调用，并返回我们保存在文件中的自定义响应。我们可以适当地改变响应的输出，以用于不同的测试用例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d85a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5b80" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在今天的教程中，我们讨论了集成测试和何时应用集成测试，以及两种常见但高级的测试实践:stubbing和mock。至此，我们的“Node.js中的测试”系列文章就结束了。我们希望你喜欢这些教程，并且至少获得了如何为你的程序编写测试用例的基本概念。</p><p id="b34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>