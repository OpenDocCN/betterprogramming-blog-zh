<html>
<head>
<title>Handling Errors in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中处理错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-errors-in-python-9f1b32952423?source=collection_archive---------0-----------------------#2020-06-18">https://betterprogramming.pub/handling-errors-in-python-9f1b32952423?source=collection_archive---------0-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="621d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中优雅地处理错误的最佳实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb257a2fa77dd7e69d6bebde2a7d1bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Q0r5yz5xvYX7X4l4rWyjA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/photos/XEB8y0nRRP4" rel="noopener ugc nofollow" target="_blank"> Alexandru Acea </a>在<a class="ae ky" href="https://unsplash.com/photos/XEB8y0nRRP4" rel="noopener ugc nofollow" target="_blank"> Upsplash </a>上拍摄。</p></figure><blockquote class="kz"><p id="89ff" class="la lb it bd lc ld le lf lg lh li lj dk translated">"最大的错误是认为我们永远不会犯错。"托马斯·卡莱尔</p></blockquote><p id="ac55" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me lj im bi translated">在开发可维护和健壮的代码时，添加大量的错误处理是至关重要的。错误可以分为几类:逻辑错误、生成错误、编译时错误和运行时错误。在本文中，我们将关注处理运行时错误——程序运行时发生的错误。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d836" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated"><em class="ne">为什么我们需要错误处理？</em></h1><h2 id="8b7f" class="nf mn it bd mo ng nh dn ms ni nj dp mw lt nk nl my lx nm nn na mb no np nc nq bi translated">1.防止程序在发生错误时崩溃</h2><ul class=""><li id="7bb5" class="nr ns it lm b ln nt lq nu lt nv lx nw mb nx lj ny nz oa ob bi translated">如果程序中出现错误，我们不希望程序意外地对用户崩溃。相反，错误处理可以用来通知用户错误发生的原因，并优雅地退出导致错误的进程。</li></ul><h2 id="067c" class="nf mn it bd mo ng nh dn ms ni nj dp mw lt nk nl my lx nm nn na mb no np nc nq bi translated">2.节省调试错误的时间</h2><ul class=""><li id="b59b" class="nr ns it lm b ln nt lq nu lt nv lx nw mb nx lj ny nz oa ob bi translated">按照第一个原因，让程序显示一个错误而不是立即崩溃将会在调试错误时节省大量时间。</li><li id="9165" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj ny nz oa ob bi translated">可以更新错误处理程序内部的逻辑，以便为开发人员显示有用的信息，例如代码回溯、错误类型等。</li></ul><h2 id="76b6" class="nf mn it bd mo ng nh dn ms ni nj dp mw lt nk nl my lx nm nn na mb no np nc nq bi translated"><strong class="ak"> 3。帮助定义项目需求</strong></h2><ul class=""><li id="496b" class="nr ns it lm b ln nt lq nu lt nv lx nw mb nx lj ny nz oa ob bi translated">如果程序由于错误的输入而崩溃，错误处理器可以通知用户错误发生的原因，并定义程序的需求和约束。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4f10" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">错误处理实践</h1><p id="ec0a" class="pw-post-body-paragraph lk ll it lm b ln nt ju lp lq nu jx ls lt oh lv lw lx oi lz ma mb oj md me lj im bi translated">在本文中，我们将讨论以下内容:</p><ul class=""><li id="3953" class="nr ns it lm b ln ok lq ol lt om lx on mb oo lj ny nz oa ob bi translated">使用<code class="fe op oq or os b">try - except</code>和<code class="fe op oq or os b">try - except - finally</code>进行异常处理</li><li id="14ff" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj ny nz oa ob bi translated">断言</li><li id="a7f2" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj ny nz oa ob bi translated">何时使用异常与断言</li></ul><p id="a7a8" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">如果您应用了这些错误处理技术，您将会感谢自己。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="2460" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">捕捉和处理异常</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/425cfa8671e3034dc22f849e465dfe41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcAYALAxd3AqDIGOnnhdFQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jakob Owens 在<a class="ae ky" href="https://unsplash.com/photos/PVPsGlhs3rU" rel="noopener ugc nofollow" target="_blank">上拍的照片。</a></p></figure><p id="f62b" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">如果您有一个可能失败的代码块，您可以通过将该代码放在一个<code class="fe op oq or os b">try: … except: …</code> <strong class="lm iu"> </strong>块中来管理任何异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="4d93" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">错误处理按如下方式执行:</p><ol class=""><li id="fcea" class="nr ns it lm b ln ok lq ol lt om lx on mb oo lj oz nz oa ob bi translated">执行<code class="fe op oq or os b">try</code>块中的语句。</li><li id="fd88" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj oz nz oa ob bi translated">如果语句成功，则跳过两个<code class="fe op oq or os b">except</code>子句，运行<code class="fe op oq or os b">finally</code>子句中的代码。</li><li id="0ef8" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj oz nz oa ob bi translated">如果<code class="fe op oq or os b">try</code>块中的语句失败，则执行第一个<code class="fe op oq or os b">except</code>语句中的代码。如果由于<code class="fe op oq or os b">ValueError</code>(即不能将非数字转换为整数)语句失败，则运行<code class="fe op oq or os b">except ValueError</code>块中的代码。</li><li id="0f1e" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj oz nz oa ob bi translated">如果<code class="fe op oq or os b">try</code>块内的语句失败且错误不是<code class="fe op oq or os b">ValueError</code>，则检查第二个<code class="fe op oq or os b">except</code>语句。如果语句由于<code class="fe op oq or os b">ZeroDivisionError</code>失败(即整数被零除)，则运行<code class="fe op oq or os b">except ZeroDivisionError</code>块内的代码。</li><li id="64ff" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj oz nz oa ob bi translated">无论最后一个任务是在<code class="fe op oq or os b">try</code>块中还是在<code class="fe op oq or os b">except</code>块中,<code class="fe op oq or os b">finally</code>子句总是在最后一个任务完成后执行。</li></ol><h2 id="1ae9" class="nf mn it bd mo ng nh dn ms ni nj dp mw lt nk nl my lx nm nn na mb no np nc nq bi translated">处理异常时要注意的事情</h2><ul class=""><li id="24a1" class="nr ns it lm b ln nt lq nu lt nv lx nw mb nx lj ny nz oa ob bi translated">不要让代码吞掉异常。我们不希望简单地忽略错误而不被发现。如果你需要吞下一个异常来避免一个基本问题，程序的架构需要重新评估。</li></ul><pre class="kj kk kl km gt pa os pb pc aw pd bi"><span id="9c60" class="nf mn it os b gy pe pf l pg ph">try:<br/>    y = 100 / x</span><span id="e31e" class="nf mn it os b gy pi pf l pg ph">except ZeroDivisionError:<br/>    pass </span></pre><ul class=""><li id="e631" class="nr ns it lm b ln ok lq ol lt om lx on mb oo lj ny nz oa ob bi translated">不要在可能无法到达的<code class="fe op oq or os b">try</code>语句中声明新变量。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="7bef" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">引发异常</h1><p id="c886" class="pw-post-body-paragraph lk ll it lm b ln nt ju lp lq nu jx ls lt oh lv lw lx oi lz ma mb oj md me lj im bi translated">您可能需要重新引发一个异常来中止脚本。例如，如果我们不能确定是哪种错误导致了异常，我们可能希望重新引发它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="1cfd" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">用户定义的异常</h1><p id="5aab" class="pw-post-body-paragraph lk ll it lm b ln nt ju lp lq nu jx ls lt oh lv lw lx oi lz ma mb oj md me lj im bi translated">有几种类型的内置异常类继承自同一个基类<code class="fe op oq or os b">Exception</code>。这些内置类的完整列表可以在官方文档中找到<a class="ae ky" href="https://docs.python.org/3/library/exceptions.html#Exception" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="04bf" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">也可以创建一个从基类<code class="fe op oq or os b">Exception</code>继承的定制异常类。如果开发人员希望集成更复杂的日志记录系统或进一步检查对象，可能需要一个自定义类。</p><p id="1963" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">定义<code class="fe op oq or os b">Exception</code>类时需要<code class="fe op oq or os b">__init__()</code>和<code class="fe op oq or os b">__str__()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="19d1" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">断言</h1><p id="e4a0" class="pw-post-body-paragraph lk ll it lm b ln nt ju lp lq nu jx ls lt oh lv lw lx oi lz ma mb oj md me lj im bi translated">断言评估表达式为真或假。如果表达式为false，python将引发一个<code class="fe op oq or os b">AssertionError</code>异常。在测试代码时，断言可以作为一个强大的开发工具。</p><p id="68b7" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">断言的语法是<code class="fe op oq or os b">assert Expression[, Arguments]</code>:</p><pre class="kj kk kl km gt pa os pb pc aw pd bi"><span id="6a4c" class="nf mn it os b gy pe pf l pg ph">a = 20<br/>assert a &lt; 10, "something went wrong"</span></pre><p id="b0dd" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">上面的代码会抛出这个错误:</p><pre class="kj kk kl km gt pa os pb pc aw pd bi"><span id="0cd8" class="nf mn it os b gy pe pf l pg ph">Traceback (most recent call last):<br/>  File "file.py", line 2, in &lt;module&gt;<br/>    assert a &lt; 10,  "something went wrong"<br/>AssertionError: something went wrong</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="48ae" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">那么什么时候我们应该使用断言还是异常呢？</h1><p id="4bce" class="pw-post-body-paragraph lk ll it lm b ln nt ju lp lq nu jx ls lt oh lv lw lx oi lz ma mb oj md me lj im bi translated">这实际上取决于具体情况，这里有争论的余地。在我看来，由于用户输入、硬件、网络等原因，在处理外部输入和输出时应该使用异常。当您想要正常退出程序、记录数据并通知用户为什么会出现这样的错误时，应该使用异常。</p><p id="c4a4" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">断言有一种快速失败的方法，应该用来查找代码中的错误和检测bug。</p><p id="a733" class="pw-post-body-paragraph lk ll it lm b ln ok ju lp lq ol jx ls lt ot lv lw lx ou lz ma mb ov md me lj im bi translated">如果您的生产代码中有断言，我的建议是确保异常处理被设置为捕捉任何<code class="fe op oq or os b">AssertionErrors</code>。万一断言在生产中失败，至少代码会通过理想地退出程序、记录问题并通知用户来安全地处理异常。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="50f9" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">额外资源</h1><ul class=""><li id="cd80" class="nr ns it lm b ln nt lq nu lt nv lx nw mb nx lj ny nz oa ob bi translated"><a class="ae ky" href="https://docs.python.org/3/tutorial/errors.html" rel="noopener ugc nofollow" target="_blank"> Python 3错误处理</a></li><li id="3444" class="nr ns it lm b ln oc lq od lt oe lx of mb og lj ny nz oa ob bi translated"><a class="ae ky" href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" rel="noopener ugc nofollow" target="_blank"> Python 3断言</a></li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="cb35" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="89b7" class="pw-post-body-paragraph lk ll it lm b ln nt ju lp lq nu jx ls lt oh lv lw lx oi lz ma mb oj md me lj im bi translated">编码快乐！</p></div></div>    
</body>
</html>