<html>
<head>
<title>7 Typescript Utility Types for React Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React开发人员的7种类型脚本实用程序类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-typescript-utility-types-for-react-developers-9c16fc99647f?source=collection_archive---------13-----------------------#2022-06-08">https://betterprogramming.pub/7-typescript-utility-types-for-react-developers-9c16fc99647f?source=collection_archive---------13-----------------------#2022-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="41a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">促进你每天的发展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc3132a32513e417bcf81199a60dbc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ueuRsN7ZaM5ybX8jle-IHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7e13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在没有TypeScript的情况下进行React开发几乎是不可想象的。这两种技术已经成为非常强大的组合，使开发人员能够大规模地创建高质量和可维护的React应用程序。TypeScript在这个过程中起着不可或缺的作用。</p><p id="015a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，成为一名优秀的React开发人员并不会自动转化为优秀的TypeScript开发人员。编写高质量的TypeScript代码是一项独立的技能，就像编写高质量的React代码一样。当两种技能结合在一起时，这一点更加突出。</p><p id="d42f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了帮助解决这个问题，本文介绍了七种不同的TypeScript实用工具类型。根据个人经验，这些实用程序类型对开发人员的日常工作非常有帮助。它们适用于常见的React开发实践或面向React开发。掌握它们将显著提高您作为TypeScript React开发人员的素质。</p><h1 id="c21d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><code class="fe mm mn mo mp b">Pick</code></h1><p id="90c0" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe mm mn mo mp b">Pick</code>实用程序类型允许您基于现有的对象类型或接口构建一个新的对象类型。它接受两个参数:现有的对象类型或接口，以及应该包含在结果对象类型中的键的字符串文字或字符串文字的联合。</p><p id="3b1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于React开发人员来说，当一个组件的props与另一个组件或数据类型共享类型时，这尤其有用。您可以使用<code class="fe mm mn mo mp b">Pick</code>实用程序，而不是在新类型中手动指定所有类型。这也在类型之间创建了一个显式的连接，并在所有相关的类型之间自动对齐类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="89e4" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><code class="fe mm mn mo mp b">Omit</code></h1><p id="917b" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe mm mn mo mp b">Omit</code>实用程序类型与之前讨论的<code class="fe mm mn mo mp b">Pick</code>实用程序类型非常相似，但基本上相反。不是用键指定要包含在构造的对象类型或接口中，而是指定应该排除的对象类型或接口。当您想要重用现有对象类型的大部分或者只想排除其中的一小部分时，这将非常有用。</p><p id="0312" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就React开发中的用例而言，它们类似于<code class="fe mm mn mo mp b">Pick</code>的用例。考虑从另一个组件的props或数据类型中接管类型。然而，微小的区别是<code class="fe mm mn mo mp b">Omit</code>对于应该排除而不是包含的条目更加明确。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="dfae" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><code class="fe mm mn mo mp b">Partial</code></h1><p id="f67b" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe mm mn mo mp b">Partial</code>实用程序类型允许您构建一个新的对象类型，其中原始对象类型或接口中的所有属性都设置为可选。基本上，它创建了一个与原始类型相比的类型子集。</p><p id="8c8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于React开发，这在为组件提供支持的测试或实用函数中尤其有用。在这些场景中，通常不需要一次提供所有的道具。道具的不同部分可能来自不同的来源或功能，而所有这些部分一起构成了一套道具。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="cd38" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><code class="fe mm mn mo mp b">NonNullable</code></h1><p id="75a0" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在React中，您经常会处理可选或可空的值。考虑可选的属性、可能丢失的数据或过滤丢失的值。在所有这些情况下，TypeScript会让你知道这些变量也可以是<code class="fe mm mn mo mp b">undefined</code>或<code class="fe mm mn mo mp b">null</code>。</p><p id="60e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在某些场景中，你想要向TypeScript指明这是不可能的，或者它们不能是<code class="fe mm mn mo mp b">undefined</code>或<code class="fe mm mn mo mp b">null</code>。想象一下初始化一个组件的属性，这个属性被标记为可选的，但是在使用它的组件中是明确设置的。在这些情况下，<code class="fe mm mn mo mp b">NonNullable</code>实用程序类型可以用来构建一个没有<code class="fe mm mn mo mp b">null</code>和<code class="fe mm mn mo mp b">undefined</code>的新类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="474e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><code class="fe mm mn mo mp b">React.ComponentProps</code></h1><p id="962c" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">有时，您无法访问组件的prop的TypeScript类型，而只能访问组件本身。当不希望向外界公开组件的属性类型时，可以考虑使用外部库的组件。虽然这是可以理解的，但它使得重用或扩展现有类型变得困难。手动实现它们会引入冗余并增加维护负担。</p><p id="7793" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，在这些场景中，您可以使用React的<code class="fe mm mn mo mp b">ComponentProps</code>实用程序类型来访问props的组件类型。顾名思义，它接受组件的类型作为它的参数，并将使用组件的属性类型构造一个新的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="5b2a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><code class="fe mm mn mo mp b">React.MouseEventHandler</code></h1><p id="b6a7" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">React应用程序不可或缺的一部分是用户交互性。实现这一点的常见方式是通过事件处理程序，最突出的是鼠标事件。键入这些事件处理程序的困难之处在于它有多个部分。有完整的事件处理程序本身、提供给处理程序的事件和潜在的返回值。</p><p id="ec26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当开始使用React中的TypeScript时，很容易分别键入这些部分。虽然这是一个短期的解决方案，但它不能很好地适应未来。相反，您可以利用React的实用程序类型<code class="fe mm mn mo mp b">MouseEventHandler</code>。它是专门为这些用例设计的，并为目标HTML元素接受一个可选参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="039b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><code class="fe mm mn mo mp b">React.PropsWithChildren</code></h1><p id="f790" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">React最大的特点之一是它的可组合性，允许组件从外部嵌套到其他组件中。大多数时候，这是通过React中的自然<code class="fe mm mn mo mp b">children</code>道具完成的。</p><p id="22ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">告诉TypeScript组件接受<code class="fe mm mn mo mp b">children</code>属性的方法之一是在属性的类型中显式声明。许多采用了TypeScript的React开发人员会对类似于<code class="fe mm mn mo mp b">children: ReactNode</code>的东西很熟悉。</p><p id="68f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，实现这一点的另一种方法是通过React的实用程序类型<code class="fe mm mn mo mp b">PropsWithChildren</code>。它自动用各自的类型构造一个新的类型，并把它标记为可选的和可空的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="dfa3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">最后的想法</h1><p id="b465" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在现代React开发中，不涉及TypeScript几乎是不可想象的。它极大地提高了代码的质量和可维护性。然而，能够正确使用TypeScript本身是一种完全独立的技能。这尤其适用于TypeScript和React的组合。</p><p id="6c17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了帮助解决这个问题，本文介绍了对React开发人员有用的七种不同的TypeScript实用工具类型。这些实用程序要么在常见的React开发实践中有用，要么专门面向React开发。理解和掌握这些类型将显著提高您键入的React代码的质量。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ne mp nf ng aw nh bi"><span id="90c9" class="ni lv it mp b gy nj nk l nl nm"><strong class="mp iu">Want to Connect?</strong></span><span id="b31c" class="ni lv it mp b gy nn nk l nl nm">If you liked this article, consider checking out the other entries in the <a class="ae no" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">Uncommon React</a> newsletter and my <a class="ae no" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank">Twitter</a> for future updates.</span></pre></div></div>    
</body>
</html>