<html>
<head>
<title>A Quick Guide to Arrays in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity中的数组快速指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-arrays-in-solidity-c6e96479c64a?source=collection_archive---------4-----------------------#2022-03-02">https://betterprogramming.pub/mastering-arrays-in-solidity-c6e96479c64a?source=collection_archive---------4-----------------------#2022-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8524" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">添加、删除、修改元素</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8134654702767f8add30a07b3785e516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ac7VE6XMl2GsEJxrQeBsyw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jjying" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="f963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Solidity编程语言中的数组可以保存原始数据类型，如整数、布尔和字符串。数组可以用固定大小或动态大小初始化。如果我们将它们与其他更高级的编程语言相比较，可以用来处理数组的函数非常有限。尽管如此，我们可以添加、删除、获取数组的大小等等。</p><h1 id="dd6a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">初始化数组</h1><p id="c724" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以创建一个坚固的数组，它可以包含动态的或者固定大小的元素。</p><p id="e345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用固定大小的阵列可以降低气体成本，但我们并不总是能够预测元素的大小。</p><h1 id="e5d8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">动态大小</h1><p id="7c45" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Solidity中创建动态数组时，我们需要提供它可以容纳的数据类型。不幸的是，数组不能在一个数组中有多种数据类型。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="10e7" class="mx lw it mt b gy my mz l na nb">uint256[] array;</span></pre><h1 id="5ef3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">固定大小</h1><p id="2ca3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">另一种选择是提供数组可以容纳的元素的大小。这可以节省汽油成本，尤其是在以太坊区块链创建智能合约时。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c557" class="mx lw it mt b gy my mz l na nb">uint256[10] array;</span></pre><p id="e15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，Solidity用默认值填充数组，对于<code class="fe nc nd ne mt b">uint256</code>是0(零)。</p><p id="3c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以在初始化数组时提供值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="48cf" class="mx lw it mt b gy my mz l na nb">uint256[] array = [1,2,3];</span></pre><h1 id="2481" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">添加元素</h1><p id="94a0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以为动态类型的数组添加一个新元素。为此，我们需要使用<code class="fe nc nd ne mt b">push</code>方法。它将一个元素添加到数组的末尾。</p><p id="a9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个向保存<code class="fe nc nd ne mt b">uint256</code>值的数组添加100的例子。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d843" class="mx lw it mt b gy my mz l na nb">array.push(100);</span></pre><h1 id="24a9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更改元素</h1><p id="2bcc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当改变一个元素时，我们需要提供索引和新值。</p><p id="f61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想改变数组中第一个元素的值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="074e" class="mx lw it mt b gy my mz l na nb">array[0] = 101;</span></pre><h1 id="a04e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">获取数组的大小</h1><p id="62d0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了得到数组的大小，我们应该使用<code class="fe nc nd ne mt b">length</code>函数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f8c4" class="mx lw it mt b gy my mz l na nb">uint256 size = array.length;</span></pre><h1 id="1dc8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">去除</h1><p id="178a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以使用<code class="fe nc nd ne mt b">delete</code>函数从数组中移除一个元素。这里的问题是它不会改变数组的大小。它重置为默认值，例如在<code class="fe nc nd ne mt b">uint256</code>的情况下为0(零)。</p><p id="f1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本示例将数组中的第一个元素重置为0(零)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3780" class="mx lw it mt b gy my mz l na nb">delete array[0];</span></pre><p id="3533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要删除一个元素并改变数组的长度，我们可以从想要删除的元素向上移动所有的元素。然后弹出最后一个元素，因为不再需要它了。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5e94" class="mx lw it mt b gy my mz l na nb">for (uint256 i = _index; i &lt; _array.length - 1; i++) {<br/>    _array[i] = _array[i + 1];<br/>}<br/>_array.pop();</span></pre><h1 id="af16" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="98b6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Solidity编程语言中的数组可以保存原始数据类型，如<code class="fe nc nd ne mt b">uint</code>、<code class="fe nc nd ne mt b">boolean</code>、<code class="fe nc nd ne mt b">address</code>或<code class="fe nc nd ne mt b">string</code>。我们可以创建一个固定或动态大小的数组。固定大小的阵列对天然气成本的影响较小。我们可以改变元素，删除，得到数组的大小。</p><h1 id="1120" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">链接</h1><ul class=""><li id="afd3" class="nf ng it lb b lc mn lf mo li nh lm ni lq nj lu nk nl nm nn bi translated"><a class="ae ky" href="https://gist.github.com/fassko/de8a9ca0657d25d656b7ad19b1705ce2" rel="noopener ugc nofollow" target="_blank">样本代码</a></li><li id="461c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.11/types.html" rel="noopener ugc nofollow" target="_blank">官方文件</a></li><li id="af4b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://solidity-by-example.org/array/" rel="noopener ugc nofollow" target="_blank">示例的可靠性—数组</a></li></ul></div></div>    
</body>
</html>