<html>
<head>
<title>Getting Started With Solana for Solidity Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Solidity开发人员的Solana入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-solana-for-solidity-developers-ee97a9bdf7ed?source=collection_archive---------5-----------------------#2022-04-12">https://betterprogramming.pub/getting-started-with-solana-for-solidity-developers-ee97a9bdf7ed?source=collection_archive---------5-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db5d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过比较以太坊和索拉纳的编程模型开始你的索拉纳之旅</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bab5c11e6ab187f0edbf92b09cebf2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYRX0YZQh22d7r8ex5VxPg.png"/></div></div></figure><p id="d3ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你熟悉以太坊和固体，你可能会尝试一下索拉纳生态系统。索拉纳的快速区块链充满希望，令人兴奋。另外，你增加了你的网络3知识的表面积。</p><p id="aa09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果你从来没有看过Solana程序，它的语法非常可怕，文档看起来就像是一个开发者重新编写的笔记。没有连贯性，有些部分要等到后面的章节你才能理解。</p><p id="84a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么我创作了这个“Solana Ramp for Solidity Devs”<a class="ae ln" href="https://www.solidnoob.com/solana-ramp" rel="noopener ugc nofollow" target="_blank">系列</a>来温和地向你介绍Solana，没有痛苦和挫折。本系列的第一篇文章是“Ethereum与Solana的编程模型比较”,本质上只是在ETH与SOL中如何编写程序的概念差异。</p><p id="0063" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不会深入了解索拉纳如何在幕后工作，比如它的历史证明等等。这将在另一篇文章中讨论。</p><p id="6bc9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是这篇文章的提纲:</p><ul class=""><li id="944f" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">以太坊vs索拉纳的存储状态</li><li id="10c4" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">索拉纳账户</li><li id="c339" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">程序派生地址</li></ul><h1 id="bd22" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">以太坊vs索拉纳的存储状态</h1><p id="aa7b" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在以太坊中，您习惯于将状态权限存储在智能契约本身中。看看这个简单的合同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0848" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它只存储了一个变量<code class="fe nb nc nd ne b">author</code>，并有一个助手<code class="fe nb nc nd ne b">publish</code>函数来改变<code class="fe nb nc nd ne b">author</code>变量。您部署这个契约，代码及其状态存储在一个地址。您可以使用该地址来引用合同并读取其数据(例如在Etherscan上)。</p><p id="df17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是索拉纳不一样。</p><p id="d043" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">索拉纳合同是无国籍的。把它们看作只是指令。它们不存储任何数据/状态。那么数据存储在哪里呢？它存储在单独的“帐户”中。帐户保存数据。当您调用Solana合约的函数时，您需要将数据传递给该函数。</p><p id="c56d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以上面的<code class="fe nb nc nd ne b">publish</code>函数需要引用存储数据的账户。该函数将增加发布的数量，但是<code class="fe nb nc nd ne b">author</code>变量仍然存储在同一个帐户中(不是在合同中)。合同的状态没有改变。如果您来自Java世界，Solana契约就像Java中的静态类。</p><blockquote class="nf ng nh"><p id="4b71" class="kr ks ni kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated"><em class="iq">顺便说一句，智能合约在索拉纳被称为</em>程序<em class="iq">。</em></p></blockquote><p id="c64d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是上面的简单合同在Solana中的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6c27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意数据是如何存储在一个单独的<code class="fe nb nc nd ne b">AuthorAccount</code>中的，并且这个数据是通过引用<code class="fe nb nc nd ne b">publish</code>函数(通过<code class="fe nb nc nd ne b">Context</code>)传入的。<code class="fe nb nc nd ne b">solana_example</code>程序本身不存储任何东西。它只是对传入的数据进行操作。(<code class="fe nb nc nd ne b">AuthorData</code>有点像需要将<code class="fe nb nc nd ne b">AuthorAccount</code>传递给<code class="fe nb nc nd ne b">publish</code>函数的包装器)。</p><p id="57ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我知道语法很吓人。这是锈和锚(索拉纳框架)。让我想起了刚开始iOS开发，第一次遇到Objective C的日子。不要担心，我们将在本<a class="ae ln" href="https://www.solidnoob.com/solana-ramp" rel="noopener ugc nofollow" target="_blank">系列</a>的第二篇文章中更详细地查看语法。会更有意义的，我保证。</p><p id="ea62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将代码与数据分开使得升级程序变得容易。在Solana中，可以在重用相同数据帐户的同时，将新版本的程序重新部署到相同的地址，这是一种不丢失数据的升级。(这个在以太坊就难做多了)。</p><h1 id="1aca" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">索拉纳账户</h1><p id="8c82" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">“账户”是一个模糊的词。它在不同的上下文中有很多意思。在索拉纳，一个账户仅仅意味着一个存储单元。它只是一个存储任意数据的容器。</p><p id="6b61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有两种类型的账户。首先是一个“数据账户”,它只是为我们已经提到的<code class="fe nb nc nd ne b">AuthorAccount</code>这样的程序存储数据。第二种类型是“程序帐户”，用于“托管”程序代码。当你在Solana上部署一个程序时，它的代码存储在一个“程序账户”中。</p><p id="b683" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">举个例子:如果你有一个计数器程序，允许你增加一个计数器，你必须创建两个账户:一个账户存储程序代码，另一个账户存储计数器值。</p><p id="a878" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">帐户有公钥/地址，以便能够引用它们，并且它们有私钥，用于在签名中证明修改帐户的权限</p><blockquote class="nf ng nh"><p id="fa66" class="kr ks ni kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated"><em class="iq">“权威”这个词在索拉纳世界里用得相当多。它只是意味着所有者——私钥的持有者。</em></p></blockquote><p id="ca6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">账户也存储余额。索拉纳天平。索拉纳的本币单位是索尔和兰波特(为纪念索拉纳最大的技术影响力而命名，<a class="ae ln" href="https://en.wikipedia.org/wiki/Leslie_Lamport" rel="noopener ugc nofollow" target="_blank">莱斯利·兰波特</a>)。1索尔= 10⁹兰波特斯。这些是ETH和wei的类似物。</p><p id="ff80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了创建一个帐户，Solana需要在其存储上分配空间。Solana上的存储不是免费的，所以创建一个帐户也不是免费的。你需要为“托管”你的账户向索拉纳支付租金。但是不用担心。如果你把两年的租金存入你的账户，你就可以免交租金。每个人都这样做，所以Solana上的存储基本上是免费的。</p><p id="7df9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是索拉纳账户中存储的所有信息的摘要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/c3b4441d594eecaa655cd1883b869db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AtZkEwCLL9aiy0kxLacxw@2x.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">来自索拉纳<a class="ae ln" href="https://solana.wiki/zh-cn/docs/account-model/" rel="noopener ugc nofollow" target="_blank">维基</a></p></figure><p id="cf33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nb nc nd ne b">data</code>字段根据账户是否为<code class="fe nb nc nd ne b">executable</code>存储代码或任意数据。我们稍后会谈到<code class="fe nb nc nd ne b">owner</code>领域。</p><p id="bbac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以太坊也有两种类型的账户:</p><ul class=""><li id="189d" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">外部拥有—可由您的钱包生成的常规帐户(只需生成一个私钥，然后导出公钥和地址，您就拥有了一个帐户)。这些账户仅仅存储余额和随机数。</li><li id="4b32" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">智能合约帐户—这些帐户存储EVM代码，并且还有一个可用于存储任意数据的存储映射。</li></ul><p id="9f69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是以太坊账户中存储的内容，以供比较:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/66a45566a50c023a42b010827ad39683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggvaeyR5-lYOySGLDGlpQA@2x.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">来自索拉纳<a class="ae ln" href="https://solana.wiki/zh-cn/docs/account-model/" rel="noopener ugc nofollow" target="_blank">维基</a></p></figure><p id="8fa3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nb nc nd ne b">codeHash</code>用于存储代码，<code class="fe nb nc nd ne b">storageRoot</code>用于存储任意数据。对于不可执行的帐户，<code class="fe nb nc nd ne b">storageRoot</code>被设置为一个特殊的“空”散列，表示该帐户没有存储空间。</p><p id="f6d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在以太坊，只有“可执行账户”才有存储。但是在Solana中，<em class="ni">所有的</em>账号都可以存储数据。但是，可执行帐户数据专门用于不可变字节代码。所有其他数据都存储在非可执行账户中，这些账户由可执行账户<em class="ni">拥有</em>。</p><p id="a16f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们来谈谈索拉纳账户的<code class="fe nb nc nd ne b">owner</code>字段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/b69a7380605ab18723a5530479d70058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_aUHBYc0hb7ub2OwnJ69g@2x.png"/></div></div></figure><p id="3cc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了确保契约不能修改另一个契约的状态，每个数据帐户分配一个拥有者程序，该程序对状态变化具有独占控制权。默认情况下，所有者程序是Solana的系统程序(有点像操作系统)。</p><p id="37fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了所有者之外，任何人都不能修改数据帐户的状态。任何人都可以将钱存入账户，但只有账户所有人可以提取余额。</p><p id="efef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一点上，你知道如何程序和帐户对索拉纳的工作。但是索拉纳有一点笨拙是以太坊没有的。</p><p id="925d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您在Solana上部署了一个程序，并且还在AWS上部署了一个传统的web2前端来与程序进行交互。每次调用程序，都需要传入数据账号(修改状态)。您需要拥有数据帐户的私钥，以便能够更改数据帐户的状态。</p><p id="ccb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">钥匙的管理就落在你身上了。你打算把它存放在哪里？作为环境变量？这不太符合web3。将这个密钥存储在程序本身中会很好，使它更像以太坊——一种将存储附加到程序的方法。</p><p id="e4e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">程序派生地址(PDA)解决了这个问题。</p><h1 id="2fab" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">程序派生地址(PDA)</h1><p id="b8ab" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">PDA本质上允许您将数据存储帐户附加到无状态程序帐户。一种让索拉纳类似以太坊的方法。</p><p id="002a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它是如何工作的？在程序中，你只是从程序控制的变量中生成一个地址。这成为一个派生帐户(一个程序派生的地址)。Solana OS提供了一个助手函数来导出这个地址。</p><p id="0e56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更具体地说，PDA是从一个程序ID和一个种子集合中派生出来的。程序ID是Solana程序的地址。种子可以由程序任意选择(我们将看到种子在哪里变得有用)。</p><p id="f8c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该过程是确定性的:种子和程序ID的组合通过sha256散列函数运行，以查看它们是否生成位于椭圆曲线上的公钥(大约有50%的结果公钥将位于椭圆曲线上)。如果它确实位于椭圆曲线上，我们简单地添加一些东西来稍微篡改我们的输入，然后再试一次。这个蒙混因素的技术术语是<code class="fe nb nc nd ne b">bump</code>。在Solana中，我们从<code class="fe nb nc nd ne b">bump = 255</code>开始，简单地向下迭代<code class="fe nb nc nd ne b">bump = 254</code>、<code class="fe nb nc nd ne b">bump = 253</code>等。直到我们得到一个不在椭圆曲线上的地址</p><blockquote class="nf ng nh"><p id="0e45" class="kr ks ni kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated"><strong class="kt ir">“位于椭圆曲线上”是什么意思</strong>？当一个公钥位于椭圆曲线上时，意味着存在一个对应的私钥，使得整个私钥密码算法能够工作。</p></blockquote><p id="19ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有一个名为<code class="fe nb nc nd ne b">findProgramDerivedAddress</code>的功能可以抽象出整个过程。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="4a0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">唷，那是一大堆技术性的东西。如果我把你弄丢了，实际上PDA是由程序ID和一些种子生成的，所以结果地址没有相应的私钥。现在，这个PDA是如何为Solana程序附加存储的呢？</p><p id="f858" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">PDA解决了几个问题:</p><ul class=""><li id="3cf9" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><strong class="kt ir">无需管理/跟踪存储账户的私钥。</strong>只需从程序中导出一个地址，并使用该地址/帐户作为存储。如何确保其他人不会修改派生帐户？因为没有对应的派生地址的私钥。所以没人能修改这个账号。Solana OS确保只有程序被允许修改PDA。你如何确保其他程序不能得到相同的PDA？他们不能，因为他们的程序ID会不同。</li><li id="d447" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><strong class="kt ir">PDA也可用于在单独的账户中存储用户特定信息</strong>。这就是种子变得有用的地方。一种常见的做法是使用最终用户的公钥作为种子来生成PDA，从而允许我们的程序将有关该用户的信息存储在它自己的独立帐户中。通过使用不同的种子，程序可以确定性地获得任意数量的地址。这些种子可以象征性地标识地址的使用方式。例如，您可以使用用户的公钥和令牌的符号作为种子，并获得一个帐户来存储关于特定令牌的用户信息(每个用户和每个令牌都将有一个新的PDA帐户)。</li></ul><p id="0fb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">总结一下</strong>，PDA只是一个拥有者是程序的账户，不像其他账户<em class="ni">一样有私钥。</em>由于没有相关的私钥，外部用户无法为PDA生成有效的签名。只有种子产生PDA的程序才能控制它——这是由Solana OS强制执行的。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="f50c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“Solana vs以太坊编程模型的差异”到此为止。你可以在<a class="ae ln" href="https://www.solidnoob.com/solana-ramp" rel="noopener ugc nofollow" target="_blank"> SolidNoob </a>上查看整个“Solana Ramp for Solidity Devs”系列和更多关于Solidity noobs的内容。</p><p id="a1f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我计划做更多的Solana介绍文章，如“语法差异”和“ERC-721/ERC20实现的差异”。</p><pre class="kg kh ki kj gt nz ne oa ob aw oc bi"><span id="fd07" class="od md iq ne b gy oe of l og oh"><strong class="ne ir">Want to Connect?</strong></span><span id="92f9" class="od md iq ne b gy oi of l og oh">Follow me on <a class="ae ln" href="https://twitter.com/nazar_ilamanov" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>