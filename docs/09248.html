<html>
<head>
<title>Build a Highly Available Kubernetes Operator Using Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang构建高度可用的Kubernetes操作符</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-highly-available-kubernetes-operator-using-golang-fe4a44c395c2?source=collection_archive---------0-----------------------#2021-08-03">https://betterprogramming.pub/building-a-highly-available-kubernetes-operator-using-golang-fe4a44c395c2?source=collection_archive---------0-----------------------#2021-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="706a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始开发一个简单的Kubernetes操作符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/85318969135e371696948c2e6b75d7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ksGOJh5IiBO1ierC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@exdigy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张秀坤·吕克曼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在Kubernetes集群中运行的任务变得重复时，这可能意味着我们没有利用Kubernetes提供的所有特性，因为它是为自动化而设计的。通常，这些任务由操作员来执行，操作员对系统应该如何运行有深入的了解，知道如何部署应用程序，以及如何解决问题。</p><p id="df2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建操作符之前，我们应该考虑标准的方法，为我们的应用程序选择正确的Kubernetes资源。例如，如果我们的应用程序是有状态的，<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/es/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">StatefulSet</a></code>可能比常规的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/es/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">Deployment</a></code>更适合我们的需求，因为它提供了额外的特性，比如惟一的网络标识符、持久存储、有序部署等等。</p><p id="d7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这种方法不成功，标准资源不能覆盖我们应用程序的特定领域逻辑，我们将需要扩展Kubernetes行为来实现自动化，并实现一个<strong class="lb iu"> Kubernetes操作符</strong>。</p><p id="f556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用<a class="ae ky" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a>库构建一个<a class="ae ky" href="https://github.com/mmontes11/echoperator" rel="noopener ugc nofollow" target="_blank"> hello world operator </a>，对其进行修改以实现高可用性，并使用Helm将其部署到Kubernetes集群。</p><h1 id="ec16" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是Kubernetes操作员？</h1><p id="ecf1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">操作符是Kubernetes的扩展，它处理<a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">自定义资源定义(CRDs) </a>来处理我们应用程序的特定用例。为此，它们遵循<a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank">操作符模式</a>，特别是<a class="ae ky" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank">控制循环</a>，这是一个非终止循环，确保集群的状态满足用户在CRDs中声明定义的要求。</p><p id="588a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运算符的一些用例可以是:</p><ul class=""><li id="c5f5" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">创建一个应用程序<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/es/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">Deployment</a></code>，并根据流量模式和其他指标自动扩展副本的数量。</li><li id="3f16" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">获取和恢复<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/es/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">StatefulSet</a></code>的备份，例如数据库。</li><li id="c158" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">扩展标准资源以添加新功能并提供更大的灵活性。例如<a class="ae ky" href="https://github.com/traefik/traefik" rel="noopener ugc nofollow" target="_blank"> Traefik </a>定义了<code class="fe lv lw lx ly b"><a class="ae ky" href="https://doc.traefik.io/traefik/routing/providers/kubernetes-crd/#kind-ingressroute" rel="noopener ugc nofollow" target="_blank">IngressRoute</a></code> CRD来扩展标准<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">Ingress</a></code>。</li></ul><p id="a57b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，由于开发一个操作符可能是复杂的，我们将构建一个非常基本的操作符来观察一些CRD并创建它们的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">Job</a></code>对应资源。</p><h1 id="5fdd" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">运营商的架构</h1><p id="d74b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">操作员的主要目标是观察Kubernetes API的变化并对其做出反应，以确保集群的状态满足CRDs中所定义的要求。由于集群中的事件数量可能会很大，因此正确设计您的操作员对于确保其良好的性能和可伸缩性至关重要:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/584bddea28414a47bed4415e5620e23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iUGfo0l9kENY6TP2.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank">客户——到引擎盖下</a>。图片由Kubernetes docs提供。</p></figure><p id="56c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将关注以下<a class="ae ky" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a>组件:</p><ul class=""><li id="c31b" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">客户端集</strong>:客户端与不同的<a class="ae ky" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#-strong-api-groups-strong-" rel="noopener ugc nofollow" target="_blank"> API组</a>交互</li><li id="8f67" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu"> informer </strong>:跟踪API中的变化。</li><li id="d239" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">索引器</strong>:索引内存中的API对象，避免API调用。</li><li id="d2e4" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu"> workerqueue </strong>:内存队列，用于以并发安全的方式处理与API对象相关的事件。这样，我们可以确保不会在两个不同的工作人员中同时处理同一个事件。</li><li id="8dd7" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu"> leaderelection </strong>:在多个副本中选出一个使用Kubernetes <a class="ae ky" href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1" rel="noopener ugc nofollow" target="_blank"> lease </a>对象的领导者的机制。</li></ul><h1 id="b11f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">自定义资源定义</h1><p id="64f7" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在我们开始编码我们的操作符之前，我们需要定义它将处理的CRDs。与任何其他API一样，Kubernetes允许您使用OpenAPI模式定义其自定义API对象。下面是一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义资源定义</p></figure><p id="0129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">CustomResourceDefinition</a></code>资源将由Helm在安装我们的图表时创建；我们只需要把它放在<a class="ae ky" href="https://github.com/mmontes11/charts/tree/main/charts/echoperator/crds" rel="noopener ugc nofollow" target="_blank"> crds </a>文件夹中。我们将进一步讨论舵轮图的细节。</p><p id="f0f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在下面的代码中定义运算符使用的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CRD戈朗类型</p></figure><p id="50c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些结构被注释，用于生成与我们的CRD相关的客户机集和通知器，以及它们的深度复制方法。为此，我们将使用以下基于<a class="ae ky" href="https://github.com/kubernetes/code-generator" rel="noopener ugc nofollow" target="_blank">k8s.io/code-generator</a>的脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码生成脚本</p></figure><h1 id="3666" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">控制器</h1><p id="312a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们需要配置的第一件事是到Kubernetes API的连接。这里有两个选项:</p><ul class=""><li id="0fce" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu"> KUBECONFIG </strong>:指向KUBECONFIG文件的环境变量。适合本地发展。</li><li id="93b6" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu"> InClusterConfig </strong>:使用pod的服务帐户令牌来访问API，因此也需要正确配置<a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC </a>。稍后我们将详细解释这一点。</li></ul><p id="3bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们创建了连接，我们就可以实例化一个核心Kubernetes客户端集，并使用我们的CRDs客户端集将它们作为依赖项传递给操作者(即控制器):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建客户端集并将它们传递给控制器</p></figure><p id="72e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们可以配置控制器的通知器，这样我们就可以开始接收关于我们感兴趣的资源的事件。为此，我们将使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://pkg.go.dev/k8s.io/client-go/tools/cache#SharedIndexInformer" rel="noopener ugc nofollow" target="_blank">cache.SharedIndexInformer</a></code>，并将通知者和索引器的职责集中在同一个对象中。换句话说，该对象维护自己更新的索引，并允许您配置事件处理程序，以便获得有关资源更改的通知。唯一的要求是它需要在启动时同步。</p><p id="55c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件将在<code class="fe lv lw lx ly b"><a class="ae ky" href="https://pkg.go.dev/k8s.io/client-go/util/workqueue#RateLimitingInterface" rel="noopener ugc nofollow" target="_blank">workerqueue.RateLimiterInterface</a></code>中排队。这用于将待处理的工作排队，而不是在事件发生后立即执行。这样，我们可以确保一次只处理固定数量的对象，并且我们不会在不同的工作人员中同时处理相同的项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制器</p></figure><h1 id="8f76" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">工人</h1><p id="4ecb" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">worker的职责是通过执行确保集群处于所需状态的操作来处理队列中的事件。为此，工人实现了一个非终止的控制循环，它根据用户的要求调节状态。在我们的例子中，调节状态意味着创建一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">Job</a></code>来响应add <code class="fe lv lw lx ly b">Echo</code>事件。</p><p id="6ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了以编程方式创建Kubernetes资源，我们将使用k8s.io/api的<a class="ae ky" href="https://github.com/kubernetes/api" rel="noopener ugc nofollow" target="_blank"/>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以编程方式创建Kubernetes对象</p></figure><p id="9c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件类型决定了调用哪个方法，以及我们将在哪里创建或更新相应的对象。值得注意的是，当控制器启动时，出于一致性原因，我们将接收add事件，因此我们需要检查我们是否已经创建了对象，以避免创建两次。实现这一点的策略是从对象元获取一个键，并检查它是否已经存在于索引中。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工人</p></figure><h1 id="bf95" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">以高可用性运行控制器</h1><p id="9363" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">部署控制器之前的最后一件事是根据配置决定使用哪种架构:独立架构还是高可用性架构。这正是运行者的责任，但是在本文中，我们将关注高可用性。</p><p id="8572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高可用性意味着运行控制器的多个副本，以确保如果领导者失败，另一个副本将获得领导权并开始运行控制循环来处理CRD。</p><p id="defa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是为解决像这样的分布式系统问题而设计的，并提供现成的解决方案来处理这些问题。在这种情况下，一个<a class="ae ky" href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/" rel="noopener ugc nofollow" target="_blank"> lease </a>对象会做这件事；它会认为是分布式互斥体，只能有一个副本，表示对应的副本是领导者，在这种情况下。</p><p id="a1c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很棒，但是Kubernetes如何有效地做到这一点呢？</p><p id="0620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes使用一个名为<a class="ae ky" href="https://etcd.io/" rel="noopener ugc nofollow" target="_blank"> etcd </a>的分布式键值存储，与其他键值存储不同，它为<a class="ae ky" href="https://etcd.io/docs/v3.4/dev-guide/interacting_v3/#watch-key-changes" rel="noopener ugc nofollow" target="_blank">提供了一个本机机制来监视开箱即用的键</a>。这使得消费者无需进行长时间的轮询或消耗额外的网络就能反应性地获得更改。</p><p id="2d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<a class="ae ky" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a>包含了<a class="ae ky" href="https://pkg.go.dev/k8s.io/client-go@v0.21.3/tools/leaderelection" rel="noopener ugc nofollow" target="_blank"> leaderelection </a>包，该包也使用下面的<a class="ae ky" href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/" rel="noopener ugc nofollow" target="_blank"> lease </a>对象为此提供了一个抽象。下面是这段代码的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">控制器运行器</p></figure><p id="a5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看领导者选举如何与我们的控制器一起工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/a1eeccfc0b15de2e9263dbfa6301fffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cVpxWw0xiiTsHlxbAKZ_iw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">领导人选举</p></figure></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="57ca" class="lz ma it bd mb mc nv me mf mg nw mi mj jz nx ka ml kc ny kd mn kf nz kg mp mq bi translated">部署到Kubernetes集群</h1><p id="d1dc" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们操作员的代码现在可以部署了。下一步将是创建一个舵图。我们将首先定义用于配置Kubernetes资源的<code class="fe lv lw lx ly b">values.yml</code>。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">舵图的值</p></figure><p id="e1f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，有一个用于配置高可用性的对象<code class="fe lv lw lx ly b">ha</code>。完成后，现在我们可以有条件地在我们的<code class="fe lv lw lx ly b">configmap</code>中创建与高可用性相关的键，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置图</p></figure><p id="8bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果启用了高可用性，部署将设置<code class="fe lv lw lx ly b">replicas</code>键，并引用此<code class="fe lv lw lx ly b">configmap</code>将其键导出为pod中的环境变量。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署</p></figure><p id="fa86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在部署<code class="fe lv lw lx ly b">spec</code>中指定了一个定制<code class="fe lv lw lx ly b">serviceAccountName</code>。原因是我们需要为该帐户定义安全策略，以便我们可以从pod访问CRDs。否则，我们将使用<code class="fe lv lw lx ly b">default</code>服务帐户访问它们，该帐户没有访问CRDs的权限。</p><p id="7df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后台，当在部署中使用服务帐户时，带有令牌(<code class="fe lv lw lx ly b">/var/run/secrets/kubernetes.io/serviceaccount/token</code>)的卷将被装载到pod上，以便它们可以在Kubernetes API中进行身份验证。</p><p id="a683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了定义令牌的安全策略，我们将使用Kubernetes <a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC </a>:</p><ul class=""><li id="66a0" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu"> ServiceAccount </strong>:集群中被授予权限的主体。</li><li id="a0ca" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu"> ClusterRole </strong>:集群中的集群作用域角色，可以对某些资源执行某些操作。</li><li id="287e" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu"> ClusterRoleBinding </strong>:给服务账户分配一个角色。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RBAC</p></figure><p id="a470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以部署我们的操作员，执行以下命令:</p><pre class="kj kk kl km gt oa ly ob bn oc od bi"><span id="c5f6" class="oe ma it ly b be of og l oh oi">helm repo add mmontes https://mmontes11.github.io/charts<br/>helm install echoperator mmontes/echoperator</span></pre><h1 id="d38b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">创造一个CRD</h1><p id="491c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最后但同样重要的是，让我们看看我们的操作符如何创建一个<a class="ae ky" href="https://github.com/mmontes11/echoperator/blob/develop/manifests/hello-world.yml" rel="noopener ugc nofollow" target="_blank">hello world</a><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/mmontes11/echoperator/blob/develop/manifests/hello-world.yml" rel="noopener ugc nofollow" target="_blank">Echo</a></code><a class="ae ky" href="https://github.com/mmontes11/echoperator/blob/develop/manifests/hello-world.yml" rel="noopener ugc nofollow" target="_blank">CRD</a>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你好，CRD回声报</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/e4d3783f0cc9787992c9ec378d3b4261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bZq3qi-I8Y4LFVNZ4jUV3g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建hello world Echo CRD</p></figure><h1 id="9170" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包扎</h1><p id="35f0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">构建一个Kubernetes操作符是一个定制的解决方案，只有当标准的Kubernetes资源不能满足您的应用程序的特定领域的需求时，才应该考虑这个解决方案。原因是解决一个非常具体的问题需要大量的时间和Kubernetes对你的团队的了解。</p><p id="e5b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您认为您的用例足够先进，并且您已经决定承担成本，那么Kubernetes社区中有很好的工具可以支持您:</p><ul class=""><li id="ef6d" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><a class="ae ky" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank">客户端-go </a></li><li id="a049" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://github.com/kubernetes-sigs/kubebuilder" rel="noopener ugc nofollow" target="_blank"> kubebuilder </a></li><li id="1365" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank">运营商sdk </a></li></ul><p id="fc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一种选择，你可以考虑利用这段时间投资自动化你的开发生命周期，使用<a class="ae ky" href="https://about.gitlab.com/topics/gitops/" rel="noopener ugc nofollow" target="_blank"> GitOps </a>实践并继续使用标准资源。</p><p id="929e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">黑客快乐！感谢阅读。</p><h1 id="e9b2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">资源</h1><div class="ok ol gp gr om on"><a href="https://github.com/mmontes11/echoperator" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">GitHub-mmontes 11/echo operator:用于处理echo CRDs的简单Kubernetes操作符🤖</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">处理echo CRDs的简单Kubernetes算子。Kubernetes操作符模式实现使用的客户端-go…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://github.com/mmontes11/charts/tree/main/deploy/charts/echoperator" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">图表/部署/图表/e主菜单上的操作员11/图表</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div><ul class=""><li id="2033" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">https://github.com/kubernetes/api<a class="ae ky" href="https://github.com/kubernetes/api" rel="noopener ugc nofollow" target="_blank"/></li><li id="47a1" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">【https://github.com/kubernetes/apimachinery T4】</li><li id="ff10" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/client-go</a></li><li id="cbec" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://github.com/kubernetes/code-generator" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/code-generator</a></li><li id="16eb" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://pkg.go.dev/k8s.io/client-go@v0.21.3/tools/leaderelection" rel="noopener ugc nofollow" target="_blank">https://pkg . go . dev/k8s . io/client-go @ v 0 . 21 . 3/tools/leader election</a></li><li id="8aaa" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/extend-kubernetes/operator/</a></li><li id="b2b5" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/architecture/controller/</a></li><li id="296a" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/extend-kubernetes/API-extension/custom-resources/</a></li><li id="99a9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/job/</a></li><li id="acc6" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/reference/kubernetes-API/cluster-resources/lease-v1/</a></li><li id="5ee4" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><a class="ae ky" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/reference/access-authn-authz/RBAC/</a></li></ul></div></div>    
</body>
</html>