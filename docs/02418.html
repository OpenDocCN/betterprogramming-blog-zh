<html>
<head>
<title>What Is [object Object] in JavaScript: Object.prototype.toString</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:Object . prototype . tostring中的[object Object]是什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-object-object-in-javascript-object-prototype-tostring-1db888c695a4?source=collection_archive---------0-----------------------#2019-11-29">https://betterprogramming.pub/what-is-object-object-in-javascript-object-prototype-tostring-1db888c695a4?source=collection_archive---------0-----------------------#2019-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">[object Object]的更深一层的解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87af7eaf1cd29c2b9baf52a6514a4185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rM_g7xu1fyyHgJbY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伊利亚·巴甫洛夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名JavaScript开发人员，您可能使用过或者至少听说过<code class="fe lv lw lx ly b">toString</code>方法。</p><p id="7682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您热衷于为开源GitHub项目贡献您的经验，您也将有机会看到他们如何检查参数的类型。</p><p id="c27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天，我看到了一个相当诡异的东西——<code class="fe lv lw lx ly b">[object Object]</code>。嗯，我第一次看的时候不知道它是什么意思。</p><p id="b76d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这是打印数据时的某种控制台错误，所以我习惯用<code class="fe lv lw lx ly b">console.dir</code>，而不是<code class="fe lv lw lx ly b">console.log</code>来表示对象。</p><p id="972e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我从<a class="ae ky" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> MDN </a>看到了这个:</p><blockquote class="lz"><p id="05e9" class="ma mb it bd mc md me mf mg mh mi lu dk translated">“每个对象都有一个<code class="fe lv lw lx ly b">toString()</code>方法，当对象被表示为一个文本值时，或者当一个对象以一种应该是字符串的方式被引用时，这个方法会被自动调用。”</p></blockquote></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9a90" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">先决条件</h1><p id="12ff" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了更好地理解这篇文章将要谈论的内容，你应该知道JavaScript中的<code class="fe lv lw lx ly b">prototype</code>和<code class="fe lv lw lx ly b">prototype chain</code>是什么。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3860" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="0ef9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe lv lw lx ly b">Object.prototype.toString</code>是一个打印出传递给<code class="fe lv lw lx ly b">toString</code>的类名的方法。</p><p id="888e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据ECMAScript的规范，您可以从中获得几个值。当您检查对象的类的类型时，这可能会很有帮助。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fe72" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">JavaScript对象的类型</h1><p id="6e48" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">是一种表示…什么的方法？</p><p id="63ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解这到底意味着什么，您应该知道JavaScript有哪些数据类型。基本上，JavaScript有七种原始数据类型和其他类型，<code class="fe lv lw lx ly b">Object</code>。</p><ul class=""><li id="61f3" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Boolean" rel="noopener ugc nofollow" target="_blank">布尔型</a></li><li id="d131" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Null" rel="noopener ugc nofollow" target="_blank">空值</a></li><li id="54cf" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Undefined" rel="noopener ugc nofollow" target="_blank">未定义</a></li><li id="c8e8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Number" rel="noopener ugc nofollow" target="_blank">编号</a></li><li id="c83f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/BigInt" rel="noopener ugc nofollow" target="_blank"> BigInt </a></li><li id="3101" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/String" rel="noopener ugc nofollow" target="_blank">弦</a></li><li id="25de" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" rel="noopener ugc nofollow" target="_blank">符号</a></li><li id="4af3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Object" rel="noopener ugc nofollow" target="_blank">对象</a></li></ul><p id="4ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些是<code class="fe lv lw lx ly b">Object</code>的实例，有些不是。每种类型的<code class="fe lv lw lx ly b">toString</code>打印出来的内容略有不同，但它们都在相同的逻辑下工作。</p><p id="c110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看有没有办法看出他们的类型。</p><p id="21dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe lv lw lx ly b">Null</code>和<code class="fe lv lw lx ly b">Undefined</code>，列表中的每个成员都是<code class="fe lv lw lx ly b">Object</code>类的一个实例。</p><p id="19f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个对象是<code class="fe lv lw lx ly b">Object</code>的实例，就意味着这个对象的<code class="fe lv lw lx ly b">[[prototype]]</code>，也就是大多数浏览器中的<code class="fe lv lw lx ly b">__proto__</code>，引用<code class="fe lv lw lx ly b">Object.prototyp</code> <em class="ob"> e </em>作为其原型链的最终链接位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/53eb906c034f4ece2585d2c11085b004.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*ZLewbavJpIVNEpmgIp_dpg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">除了Null和Undefined之外，所有都是对象的实例</p></figure><p id="c863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这个简短的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/85d84d98ecdf89adbc41919a2f516a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*upghBSnhX3a2tvlEDHLBWQ.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/b87c23ed8526295a19df9d9862337130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6kTUJGDToJ0SNy-Y02Erw.png"/></div></div></figure><p id="e780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个名为<code class="fe lv lw lx ly b">worker</code> <em class="ob"> </em>的随机函数类，它的方法覆盖了打印内容的<code class="fe lv lw lx ly b">Object.prototype.toString</code>(我们很快就会深入研究它，不要担心)。</p><p id="788b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我通过调用<code class="fe lv lw lx ly b">toString</code>打印出<code class="fe lv lw lx ly b">newWorker</code>的名字。那么，这有什么关系呢？</p><p id="7631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，任何对象都可以拥有自己的方法，即使这个名称对于它们的<code class="fe lv lw lx ly b">super</code>类中的q method来说是多余的。在这个例子中，一旦调用了<code class="fe lv lw lx ly b">toString</code>，JavaScript引擎就会开始寻找<code class="fe lv lw lx ly b">newWorker</code>的作用域中是否有<code class="fe lv lw lx ly b">toString</code>。</p><p id="8d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有，引擎会获取并调用它。如果没有，那么引擎寻找<code class="fe lv lw lx ly b">newWorker</code>的<code class="fe lv lw lx ly b">[[prototype]]</code>(同样，在大多数浏览器中是<code class="fe lv lw lx ly b">__proto__</code>)并在<code class="fe lv lw lx ly b">[[prototype]]</code>的范围内寻找<code class="fe lv lw lx ly b">toString</code>。</p><p id="9e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有，那么引擎获取并调用它，如果没有，当它寻找<code class="fe lv lw lx ly b">newWorker</code>的<code class="fe lv lw lx ly b">[[prototype]]</code>时做同样的事情。</p><p id="eec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种情况是<code class="fe lv lw lx ly b">newWorker</code>的<code class="fe lv lw lx ly b">[[prototype]]</code>的<code class="fe lv lw lx ly b">[[prototype]]</code>。如果<code class="fe lv lw lx ly b">[[prototype]]</code>是<code class="fe lv lw lx ly b">null</code>，当到达<code class="fe lv lw lx ly b">Object</code>，或者<code class="fe lv lw lx ly b">toString</code>存在于此过程范围内，发动机停止。</p><p id="6716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为原型链接。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3a46" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">[object Object]是Object.prototype.toString的精确算法的结果</h1><p id="a9ff" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">那<code class="fe lv lw lx ly b">Object.prototype.toString</code>到底是做什么的？它检测一个对象的类别并告诉你它是什么。让我们看一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在本文前面提到的每一种数据类型都可以作为参数传递给<code class="fe lv lw lx ly b">toString</code>，而<code class="fe lv lw lx ly b">Object.prototype.toString</code>打印出传递的参数的类名。</p><p id="c402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你使用<code class="fe lv lw lx ly b">toString</code> <em class="ob"> </em>获取类类型时，要记住的一件事是确保在<code class="fe lv lw lx ly b">Object</code>上使用<code class="fe lv lw lx ly b">Function.prototype.call</code>或<code class="fe lv lw lx ly b">Function.prototype.apply</code>。</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="1bbc" class="ol mr it ly b gy om on l oo op">'call' in Object; //true</span></pre><p id="3349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么需要调用<code class="fe lv lw lx ly b">Function.prototype.call</code>或者<code class="fe lv lw lx ly b">Function.prototype.apply</code>？</p><p id="1877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来想想那两个函数是做什么的。它们所做的是允许您将某个对象传递给<code class="fe lv lw lx ly b">call</code>或<code class="fe lv lw lx ly b">apply</code>以使用参数作为它们的<code class="fe lv lw lx ly b">thisArg</code>属性，这就是所谓的<code class="fe lv lw lx ly b">this</code>。</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="f549" class="ol mr it ly b gy om on l oo op">function print() {<br/>  console.log(this);<br/>}</span><span id="72d6" class="ol mr it ly b gy oq on l oo op">print(); // Window<br/>print.call([1, 2, 3]); // [1, 2, 3]<br/>print.apply([1, 2, 3]); // [1, 2, 3]</span></pre><p id="b5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在例子中可以看到，<code class="fe lv lw lx ly b">call</code>和<code class="fe lv lw lx ly b">apply</code>把<code class="fe lv lw lx ly b">[1, 2, 3]</code>做成<code class="fe lv lw lx ly b">print</code>的<code class="fe lv lw lx ly b">this</code>，而<code class="fe lv lw lx ly b">print()</code>的<code class="fe lv lw lx ly b">this</code>只是<code class="fe lv lw lx ly b">Window</code>的对象。</p><p id="5f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是文档告诉我们的关于<code class="fe lv lw lx ly b">toString</code>如何工作的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/9c225244ac8b30eaa05ca1e7ce9c7b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_t-JYuj3wSr_zPlA_u62eA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你可以点击查看<a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="34f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们采取第一个。想象这段代码如下所示。</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="0d32" class="ol mr it ly b gy om on l oo op">Object.prototype.toString.call(undefined);</span></pre><p id="a054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个上下文中，“如果<code class="fe lv lw lx ly b">this</code>值未定义”，<code class="fe lv lw lx ly b">this</code>是指你传入<code class="fe lv lw lx ly b">toString</code>的对象调用<code class="fe lv lw lx ly b">Function.prototype.call</code>或<code class="fe lv lw lx ly b">Function.prototype.apply</code>。</p><p id="5b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得那些函数让自变量折腾<code class="fe lv lw lx ly b">thisArg</code>，也就是<code class="fe lv lw lx ly b">this</code>吗？这就是为什么我们必须使用<code class="fe lv lw lx ly b">call</code>或<code class="fe lv lw lx ly b">apply</code>，因为<code class="fe lv lw lx ly b">toString</code>的第一个条件。这种情况下，<code class="fe lv lw lx ly b">this</code>就是<code class="fe lv lw lx ly b">undefined</code>。所以，返回<code class="fe lv lw lx ly b">[object Undefined]</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/74c0dc4c060614e30fab96f553dad140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*pl8QbHKCiHewAlBXlF1T4w.png"/></div></div></figure><p id="1a55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常正确！下一个！</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="66a6" class="ol mr it ly b gy om on l oo op">Object.prototype.toString.call(null);</span></pre><p id="641c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">this</code>这个参数的<code class="fe lv lw lx ly b">null</code>不是<code class="fe lv lw lx ly b">undefined</code>，所以跳过第一个条件。</p><p id="9b00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是第二个问题，“如果<code class="fe lv lw lx ly b">this</code>值为空”，对于这个例子来说是完美的！然后，让我们看看这个例子是否像第二个条件所说的那样肯定打印了<code class="fe lv lw lx ly b">[object Null]</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f2686f246084c421953744d48e045ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*4p7IwI9q8mj3xx7XekXHzQ.png"/></div></figure><p id="29c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是啊，简单模式！</p><p id="b707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那<code class="fe lv lw lx ly b">Array</code>呢？我没有把它放在这篇文章开始的数据类型列表中。<code class="fe lv lw lx ly b">Array</code>不也是JavaScript拥有的一类类型吗？嗯，听起来很有道理。再看第三到第六个条件。</p><ol class=""><li id="7e04" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ou nt nu nv bi translated">设<code class="fe lv lw lx ly b">O</code>为<code class="fe lv lw lx ly b">ToObject</code>(该值)</li><li id="dcf1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ou nt nu nv bi translated">设<code class="fe lv lw lx ly b">isArray</code>为<code class="fe lv lw lx ly b">IsArray(O)</code></li><li id="75ae" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ou nt nu nv bi translated">如果<code class="fe lv lw lx ly b">isArray</code>为真，设<code class="fe lv lw lx ly b">builtinTag</code>为<code class="fe lv lw lx ly b">“Array”</code></li></ol><p id="5ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，即使我们不知道<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-toobject" rel="noopener ugc nofollow" target="_blank">ToObject</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-isarray" rel="noopener ugc nofollow" target="_blank">IsArray</a></code>是什么，我们知道这些条件谈打印<code class="fe lv lw lx ly b">“Array”</code>如果我们把<code class="fe lv lw lx ly b">Array</code>类型对象传入<code class="fe lv lw lx ly b">toString</code> <em class="ob">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/714f54e42b8eae14004ab31b6dc1d4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*pzqDfyNOcJc0D1opPb9aaA.png"/></div></figure><p id="bc87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还是那句话，没错！现在，轮到你将我在本文开头列出的所有数据类型与来自<code class="fe lv lw lx ly b">toString</code>算法的结果进行比较。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="902d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">定制的toString</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="6642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们简单检查了一下<code class="fe lv lw lx ly b">newWorker</code>代码。在那个例子中，我们定制了<code class="fe lv lw lx ly b">toString</code>方法，因为它打印了我们在创建<code class="fe lv lw lx ly b">worker</code>类的实例时设置的名称。</p><p id="e1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也解释了这是怎么可能的。像这样，有一个对象继承了<code class="fe lv lw lx ly b">Object</code>，但是内部有一个定制的<code class="fe lv lw lx ly b">toString</code>方法。</p><p id="5ef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://mathjs.org/" rel="noopener ugc nofollow" target="_blank">Math</a></code>是一个奇妙的数学内置JavaScript库，帮助我们获得许多不同种类的预先计算的值或方法，以便于计算。</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="f4b5" class="ol mr it ly b gy om on l oo op">Math instanceof Object; // true<br/>'toString' in Math; // true</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/8da89b338e67b8f11748749a13058da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmrNXXH8DUAWG6QnA4YwFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://chromium.googlesource.com/v8/v8/+/4.3.21/src/math.js?autodive=0%2F%2F" rel="noopener ugc nofollow" target="_blank">铬</a>中的Math.js</p></figure><p id="bfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Chromium中，当引擎编译<code class="fe lv lw lx ly b">math.js</code>时，运行<code class="fe lv lw lx ly b">SetUpMath</code>，您将看到:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="8fcc" class="ol mr it ly b gy om on l oo op">%AddNamedProperty($Math, symbolToStringTag, "Math", ...);</span></pre><p id="ec29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们不知道这段代码到底是做什么的，但是有一点我们可以知道，当<code class="fe lv lw lx ly b">Math</code>被声明的时候，它的属性，名为<code class="fe lv lw lx ly b">symbolToStringTag</code>，会被赋给<code class="fe lv lw lx ly b">“Math”</code>。</p><p id="dbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，您可以在浏览器控制台中检查这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/a71cd1a0accf899a1b58aafa5d68ad85.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*O9ZYoDOrxGJf4rREdQSROw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">您可以通过console.dir(Math)看到这一点</p></figure><p id="8338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，<code class="fe lv lw lx ly b">Symbol.toStringTag</code>是做什么的？</p><p id="1239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Symbol.toStringTag</code>众所周知的符号是一个字符串值属性，用于创建对象的默认字符串描述。它由<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" rel="noopener ugc nofollow" target="_blank">Object.prototype.toString()</a></code>方法在内部访问。</p><p id="f6c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，总的来说，有一些内置的JavaScript对象有一个定制的<code class="fe lv lw lx ly b">toString</code>方法来打印不同的返回值，这不是我们之前看到的<a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring" rel="noopener ugc nofollow" target="_blank">ECMAScript toString Edition</a>中的情况之一。</p><p id="0e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之所以会这样，是因为默认调用<code class="fe lv lw lx ly b">Object.prototype.toString</code>的<code class="fe lv lw lx ly b">Symbol.toStringTag</code>，在一些核心脚本文件中声明。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/cd791f7235bb4489ab69b09ee1e2f3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*lfvxqusmA5tAE9tczWl1iQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">您甚至可以定制一个定制的内置对象的toString</p></figure><p id="eccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且你也可以自己做<code class="fe lv lw lx ly b">toString</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="aefd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">typeof与toString</h1><p id="072a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">您可能听说过JavaScript中的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank">typeof</a></code>操作符，它用于检查类型。</p><p id="e808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，<code class="fe lv lw lx ly b">toString</code>似乎也可以检查类型，因为总会有一些东西附加在<code class="fe lv lw lx ly b">“[object]”</code>上，比如<code class="fe lv lw lx ly b">[object Math]</code>。<code class="fe lv lw lx ly b">typeof</code>将指示未赋值操作数类型的字符串返回给您。</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="2502" class="ol mr it ly b gy om on l oo op">typeof Math; // "object"<br/>typeof true; // "boolean"<br/>typeof 42; // "number"</span></pre><p id="3961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，有什么不同呢？</p><p id="f972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者之间的简单区别是你不能覆盖<code class="fe lv lw lx ly b">typeof</code>的功能，而你可以用<code class="fe lv lw lx ly b">toString</code>覆盖。</p><p id="073f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，使用<code class="fe lv lw lx ly b">typeof</code>比<code class="fe lv lw lx ly b">toString</code>更简单，因为您应该解析并剪切字符串以获得“类型”部分，比如来自<code class="fe lv lw lx ly b">[object Math]</code>的“数学”。但是，<code class="fe lv lw lx ly b">typeof</code>并不总是取代<code class="fe lv lw lx ly b">Object.prototype.toString</code>所做的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="be24" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="edcc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe lv lw lx ly b">Function.prototype.apply</code>，由于它的核心逻辑，返回给你一个你传递给方法的对象的类。</p><p id="fbdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些内置函数有自己定制的<code class="fe lv lw lx ly b">toString</code>方法，比如<code class="fe lv lw lx ly b">Math</code>和<code class="fe lv lw lx ly b">HTMLDocument</code>。为了确保你的代码中对象的类型，你应该在<code class="fe lv lw lx ly b">typeof</code>和<code class="fe lv lw lx ly b">toString</code>之间做好决定。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1a78" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">资源</h1><ul class=""><li id="5366" class="nn no it lb b lc ni lf nj li oz lm pa lq pb lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" rel="noopener ugc nofollow" target="_blank">MDN中的object . prototype . tostring</a></li><li id="fc92" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" rel="noopener ugc nofollow" target="_blank">MDN中的JavaScript数据类型和数据结构</a></li><li id="e8f8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring" rel="noopener ugc nofollow" target="_blank">ECMAScript版本中的object . prototype . tostring</a></li><li id="36b7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://chromium.googlesource.com/v8/v8/+/4.3.21/src/math.js?autodive=0%2F%2F" rel="noopener ugc nofollow" target="_blank">来自Chromium源代码的src/math . js</a></li><li id="9212" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag" rel="noopener ugc nofollow" target="_blank">MDN中的symbol . tostring tag</a></li><li id="2f9f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank">MDN中的类型</a></li></ul></div></div>    
</body>
</html>