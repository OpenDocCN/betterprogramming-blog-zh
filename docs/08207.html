<html>
<head>
<title>Dealing With Code Smells and Metrics in Complex Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理复杂软件中的代码味道和度量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dealing-with-code-smells-and-metrics-in-complex-software-879f9fc4a767?source=collection_archive---------13-----------------------#2021-04-06">https://betterprogramming.pub/dealing-with-code-smells-and-metrics-in-complex-software-879f9fc4a767?source=collection_archive---------13-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3305" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道软件复杂性何时出现以及如何处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2baf97f33ba0f087aaf9decefe1d6c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a-QZfRmwu6NiFEMs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nattyflo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Flo P </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2a51" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么代码复杂性是一个重要而严肃的话题？</h1><blockquote class="ly lz ma"><p id="abf0" class="mb mc md me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">“可靠性的主要敌人是复杂性。复杂系统往往不会被任何人完全理解。如果没有人能够了解一个复杂系统的一小部分，那么就没有人能够预测攻击者破坏该系统的所有方式。”——<a class="ae ky" href="https://www.springer.com/gp/book/9780387405339" rel="noopener ugc nofollow" target="_blank">实用互联网安全</a>作者约翰·r·瓦卡</p></blockquote><p id="dc4f" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">如果很复杂，那就是无法理解。如果无法理解，那就是无法解释。如果我们不能理解和解释代码，我们就不能扩展或改变它。如果我们只了解整个系统的一部分，每一次进化都将是代价高昂的，错误和倒退将是无限的。</p><p id="a57b" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">那么代码中有什么复杂的味道呢？有确定性的方法来衡量复杂性吗？有工具可以自动控制和测量复杂性吗？</p><p id="7999" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">让我们一起发现吧！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2f3a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">什么时候软件被认为是复杂的(复杂的味道)？</h1><h2 id="d2b9" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">复杂性公式</h2><p id="ef96" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">我们可以用这个公式来总结软件的复杂性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/5ec53861c95bc0d2c051f1ba0e267f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpL9cX8w4MlfZaKFPW_bTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复杂度公式(图片由作者提供)</p></figure><p id="1faf" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">复杂程度与上述因素成反比:</p><ul class=""><li id="77c0" class="nt nu it me b mf mg mi mj my nv mz nw na nx mx ny nz oa ob bi translated">虽然我们的代码很容易测试、理解和扩展，但复杂性很低(&lt; 1 ).</li><li id="6790" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">When one of the factors decreases, the complexity increases.</li></ul><p id="3908" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">Code must be written for the needs of today and for tomorrow’s easy understanding, expansion, and evolution. Complexity is the major constraint that dampens the evolution of software.</p><p id="e234" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">Whenever we add new code, we have to ask ourselves: Is it clear enough that we can easily understand it after two years without having viewed it?</p><p id="d55a" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">The idea is not to fill our code with comments but to write an understandable code.</p><p id="88c4" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">There are two types of complexities: one related to code and the other related to design. So what are the smells of code and design complexity? How can we detect them?</p><h2 id="1f0a" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">Complexity smells</h2><p id="b70b" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">Personally, I consider unit testing as the first level of complexity control. If<strong class="me iu"> </strong>)代码很难测试，它很复杂。</p><p id="3cae" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">单元测试是技术控制的一种手段，可理解性是人类控制的一种手段:如果代码不直观，它就是复杂的。例如，如果我们的同事在理解代码方面有困难，不要试图说服他们:这很复杂！</p><p id="3e49" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">可扩展性是通过理解现有代码(之前)、进行更改(中)和影响(之后)所花费的时间来衡量的。如果这个时间是高的，那么它是复杂的。如果产生的无序度很大，那么这个设计就是糟糕的。</p><p id="d7d1" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">可扩展性衡量我们的设计和架构有多健壮、灵活和超前。</p><p id="e35b" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">那么是什么使得代码难以测试和理解呢？是什么让软件难以扩展？让我们看看。</p><h2 id="94c2" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">是什么让代码难以测试？</h2><p id="0edd" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">让我们看看这两个流程图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/128ca10f9ad8a5fbdeb40118ab1e6913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1OB6EaT-7Vlg533eiPcuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单和复杂的流程图(图片由作者提供)</p></figure><p id="7f64" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">怎么了?</p><p id="7e61" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">流程图A清晰、简单、易于理解。</p><p id="bc78" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">流程图B很复杂，很难理解。为什么？</p><p id="3f06" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">因为:</p><ul class=""><li id="da62" class="nt nu it me b mf mg mi mj my nv mz nw na nx mx ny nz oa ob bi translated">许多决策分支(if/else)</li><li id="eacd" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">大量嵌套的决策分支</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/bff25bf57ed32c7e44b86eea9dc2c0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vm6gDQXRRlqoY8AIm4ddKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可测性公式(图片由作者提供)</p></figure><p id="0804" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">为什么？<strong class="me iu"> </strong>软件是为用户制作的，每一条路径都是单元测试必须覆盖和达到的可能用例。我们不能等待出现错误，但是由于单元测试，我们可以预见。</p><p id="7247" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">单元测试是开发的代码很好地响应需求并在任何条件下(空、空、服务器关闭、错误等)都表现良好的第一个验证器。单元测试就像我们的第一批软件用户。</p><h2 id="63af" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">是什么让代码难以理解？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/0d8678dda135af5a94a0ff6b9ed3465a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TWlKMPpW4ABq26Gvk0enQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">易懂公式(图片由作者提供)</p></figure><p id="2279" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">功能不好的气味有哪些？</strong></p><p id="b872" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">让我们来看看这个例子:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="3105" class="nb lh it ol b gy op oq l or os">function doSomething(lastName, firstName, gender, birthDay, birthPlace, address, phones, socialLinks) {<br/>  if (!lastName<br/>    || !lastName.length<br/>    || !firstName<br/>    || !firstName.length<br/>    || !gender<br/>    || !gender.length)<br/>    return "User information unavailable !";<br/>  const nameLine = `${gender.toUpperCase()} ${firstName} - ${lastName}`;<br/>  let birthdayLine = '';<br/>  if (birthDay &amp;&amp; birthDay.length) {<br/>    if (birthPlace &amp;&amp; birthPlace.length) {<br/>      birthdayLine = `Burn the ${birthDay} at ${birthPlace}`;<br/>    } else {<br/>      birthdayLine = `Burn the ${birthDay}`;<br/>    }<br/>  }<br/>  let addressLines = [];<br/>  if (address<br/>    &amp;&amp; address.zipCode<br/>    &amp;&amp; address.zipCode.length<br/>    &amp;&amp; address.address1<br/>    &amp;&amp; address.address1.length) {<br/>    addressLines.push(`Address : ${address.address1}`);<br/>    addressLines.push(`Zip Code : ${address.zipCode}`);<br/>    if (address.city &amp;&amp; address.city.length) {<br/>      addressLines.push(`City : ${address.city}`);<br/>    }<br/>    if (address.state &amp;&amp; address.state.length) {<br/>      addressLines.push(`State : ${address.state}`);<br/>    }<br/>  }<br/>  if (phones<br/>    &amp;&amp; Array.isArray(phones)<br/>    &amp;&amp; phones.length) {<br/>    for (let i = 0; i &lt; phones.length; i++) {<br/>      const phone = phones[i];<br/>      if (phone.type<br/>        &amp;&amp; phone.type.length<br/>        &amp;&amp; phone.value<br/>        &amp;&amp; phone.value.length) {<br/>        phones[i] = `Phone ${phone.type} : ${phone.value}`;<br/>      }<br/>    }<br/>  }<br/>  if (socialLinks<br/>    &amp;&amp; Array.isArray(socialLinks)<br/>    &amp;&amp; socialLinks.length) {<br/>    for (let i = 0; i &lt; socialLinks.length; i++) {<br/>      const link = socialLinks[i];<br/>      if (link.type<br/>        &amp;&amp; link.type.length<br/>        &amp;&amp; link.value<br/>        &amp;&amp; link.value.length) {<br/>          socialLinks[i] = `Social ${link.type} : ${link.value}`;<br/>      }<br/>    }<br/>  }<br/>  return ([<br/>    nameLine,<br/>    birthdayLine,<br/>    addressLines,<br/>    phones,<br/>    socialLinks,<br/>  ])<br/>}</span></pre><p id="6007" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">怎么了？</strong></p><ul class=""><li id="4aa1" class="nt nu it me b mf mg mi mj my nv mz nw na nx mx ny nz oa ob bi translated">函数的意图不清楚(错误的名称:doSomething)</li><li id="5fbc" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">大型函数:许多语句</li><li id="9e8f" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">许多责任</li><li id="98ea" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">许多参数:我们必须记住每个参数的顺序和类型</li><li id="4d38" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">许多决策路径</li><li id="07e5" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">副作用(电话和社交链接突变)</li><li id="9d04" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">输出格式:我们必须记住返回值的顺序</li></ul><p id="dea4" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">糟糕的函数是难以理解的复杂代码的最明显的气味和症状。</p><p id="8dd9" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">恶名</strong></p><p id="ee51" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">让我们看看这个例子:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="ee49" class="nb lh it ol b gy op oq l or os">const format = m =&gt; {<br/>  if (m === 0) return `00`;<br/>  if (m &lt; 10)  return `0${m}`;<br/>  if (m &gt;= 10) return `${m}`;<br/>}</span></pre><p id="0df1" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">这个函数计算什么？它是为了什么目的而创造的？什么是<code class="fe ot ou ov ol b">m</code>？它是一个匿名函数:它没有明确的角色，也没有明确的意图。</p><p id="cd1c" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">每个函数和变量都是为特定的角色和意图而创建的，名字必须简单明了地说出和表达出来(不要依赖注释)。</p><p id="9b31" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">现在让我们来看看这个增强的示例:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="2602" class="nb lh it ol b gy op oq l or os">const formatAmountValue = amount =&gt; {<br/>  if (amount === 0) return `00`;<br/>  if (amount &lt; 10)  return `0${amount}`;<br/>  if (amount &gt;= 10) return `${amount}`;<br/>}</span></pre><p id="8c4f" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">现在很清楚，这个函数的作用是根据功能需求格式化金额。很容易找到并调试这个函数。</p><p id="c406" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">功能名称比技术名称更有表现力。随着时间的推移，我们忘记了技术上的<em class="md">为什么是</em>，但是功能上的是直观的。</p><p id="43fd" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">回调</strong></p><blockquote class="ly lz ma"><p id="ea1c" class="mb mc md me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">“首先，我们的大脑以顺序的、阻塞的、单线程的语义方式计划事情，但是回调以一种相当非线性的、非顺序的方式表达异步流，这使得对这样的代码进行适当的推理变得更加困难。对代码进行不合理的推理是导致严重错误的不良代码。”— <a class="ae ky" href="https://www.oreilly.com/library/view/you-dont-know/9781491905197/" rel="noopener ugc nofollow" target="_blank">你不知道的JS: Async &amp;性能</a>凯尔·辛普森。</p></blockquote><p id="cf79" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">让我们看看下面的例子:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="7c4e" class="nb lh it ol b gy op oq l or os">axios.get(‘/get/users’)<br/> .then(function(response) {<br/> document.getElementById(‘users’).innerHTML = response.data.map((user) =&gt; (<br/> ‘&lt;li class=”row”&gt;’ +<br/> ‘&lt;img src=”<a class="ae ky" href="https://avatars.githubusercontent.com/u/'" rel="noopener ugc nofollow" target="_blank">https://avatars.githubusercontent.com/u/'</a> + user.avatar + ‘?s=50" class=”col-md-1"/&gt;’ +<br/> ‘&lt;div class=”col-md-3"&gt;’ +<br/> ‘&lt;strong&gt;’ + user.name + ‘&lt;/strong&gt;’ +<br/> ‘&lt;div&gt;Github: &lt;a href=”<a class="ae ky" href="https://github.com/'" rel="noopener ugc nofollow" target="_blank">https://github.com/'</a> + user.github + ‘“ target=”_blank”&gt;’ + user.github + ‘&lt;/a&gt;&lt;/div&gt;’ +<br/> ‘&lt;div&gt;Twitter: &lt;a href=”<a class="ae ky" href="https://twitter.com/'" rel="noopener ugc nofollow" target="_blank">https://twitter.com/'</a> + user.twitter + ‘“ target=”_blank”&gt;’ + user.twitter + ‘&lt;/a&gt;&lt;/div&gt;’ +<br/> ‘&lt;/div&gt;’ +<br/> ‘&lt;/li&gt;&lt;br/&gt;’<br/> )).join(‘’);<br/> })<br/> .catch(function(err) {<br/> document.getElementById(‘users’).innerHTML = ‘&lt;li class=”text-danger”&gt;’ + err.message + ‘&lt;/li&gt;’;<br/> });</span></pre><p id="9a8b" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">很难理解代码的意图:每个块在哪里开始，在哪里结束？代码流不是顺序的，但它会偏离，创建新的并行分支，并深入(get =&gt; then =&gt; map)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/d752f16c5fbac7e179478e8d28a4704e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFx4lhXd_f9vK8uaDbJLow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同步流与回调流(图片由作者提供)</p></figure><p id="7a4f" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">如果我们希望在显示最终结果之前获得每个用户的详细信息，该怎么办？</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="37d6" class="nb lh it ol b gy op oq l or os">axios.get('/get/users')<br/>  .then(function(response) {<br/>      <strong class="ol iu">response.data.map((user) =&gt; {<br/>          axios.get(`/get/user?id=${user.id}`)<br/>            .then(function(response) {<br/>              ...<br/>            })<br/>            .catch(function(err) {<br/>              ...<br/>            });<br/>        };<br/>      });</strong><br/>  }.catch(function(err) {<br/>    document.getElementById('users').innerHTML = '&lt;li class="text-danger"&gt;' + err.message + '&lt;/li&gt;';<br/>  });</span></pre><p id="c97a" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">很难思考和理解输出代码。</p><blockquote class="ly lz ma"><p id="edee" class="mb mc md me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">“我们需要比试镜更好的东西。”—你不知道的JS: Async &amp; Performance作者凯尔·辛普森。</p></blockquote><h2 id="19e9" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">是什么让软件难以扩展？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/19265f976a82c63c1a5e16c4173eb368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMMcxXbGkKfiOxmoDIvqtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扩展公式(图片由作者提供)</p></figure><p id="6379" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">扩展软件与设计和架构高度相关。如果代码结构良好且模块化，并且变更图清晰且定义良好，那么扩展将会很容易。</p><p id="9f69" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">当我们想要扩展或修改软件时，我们在将来收获架构设计和定义活动的回报。面向未来的设计！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/85240ce99164c3f44b37d9e4107190b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZaFdjvf9agAO2v2pIrRgg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可扩展和进化的设计(图片由作者提供)</p></figure><p id="c1a9" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">当我们在开发中前进时，有没有一种确定的方法来度量复杂的程度或水平？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7e60" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">有哪些可用的指标？</h1><h2 id="b474" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">为什么指标很重要？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/d6dafacaad9e89f3b033e6f5d680e767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yg4ewLMDyXEQgtdCzflimQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">受控与非受控系统(图片由作者提供)</p></figure><p id="7ae5" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">一个不受控制的系统随着时间的推移以任意和不确定的方式进化:它的状态没有任何回报，也不能进行优化。</p><p id="4fad" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">然而，受控系统遵循明确定义的路径，其演化是可预测和可优化的。</p><p id="a267" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">每当我们在开发中前进时，度量帮助我们遵循最佳路径以获得良好的软件质量，如果必要的话，它们会纠正我们。</p><h2 id="cb73" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">圈复杂度(McCabe公式)</h2><p id="02f0" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">圈复杂度是根据代码中的路径数计算的。这正是我们想要的，让我们来看看。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="6fef" class="nb lh it ol b gy op oq l or os">(1) start<br/>(2)if (X) then <br/>(3) if (Y) then <br/>(4)   perform A<br/>      perform B<br/>    else <br/>(5)   perform C<br/>      perform D<br/>(6) endif <br/>(7) endif<br/>(8) end</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/ff5fce9814cd87c7b717faa0e9160a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXfn6_X4dcxt0435ZDaVGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">圈复杂度计算(图片由作者提供)</p></figure><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="ea52" class="nb lh it ol b gy op oq l or os">e = 9<br/>n = 8<br/>Cyclomatic Complexity = 9 - 8 + 2 = 4</span></pre><p id="043e" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">V(G)是条件分支的数量。<br/> V(G) = 1对于一个只由顺序语句组成的程序。</p><p id="97c9" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">圈数越高，函数的执行路径就越多，理解起来就越困难。</p><p id="ace5" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">提示:</strong>以下情况圈数加一:<code class="fe ot ou ov ol b">if</code> (…)、<code class="fe ot ou ov ol b">for</code> (…)、<code class="fe ot ou ov ol b"> while</code> (…)、<code class="fe ot ou ov ol b">case</code> …:、<code class="fe ot ou ov ol b">catch</code> (…)、<code class="fe ot ou ov ol b">&amp;&amp;</code>、<code class="fe ot ou ov ol b">||</code>、<code class="fe ot ou ov ol b">?</code>、<code class="fe ot ou ov ol b">#if</code>、<code class="fe ot ou ov ol b">#ifdef</code>、<code class="fe ot ou ov ol b">#ifnde</code> f、<code class="fe ot ou ov ol b">#elif</code>。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="d805" class="nb lh it ol b gy op oq l or os">int sumOfPrimes(int max) {              <strong class="ol iu">// +1</strong><br/>  int total = 0;<br/>  OUT: for (int i = 1; i &lt;= max; ++i) { <strong class="ol iu">// +1</strong><br/>    for (int j = 2; j &lt; i; ++j) {       <strong class="ol iu">// +1</strong><br/>      if (i % j == 0) {                 <strong class="ol iu">// +1</strong><br/>        continue OUT;<br/>      }<br/>    }<br/>    total += i;<br/>  }<br/>  return total;<br/>} <strong class="ol iu">// Cyclomatic Complexity 4</strong></span></pre><p id="767d" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">循环数高的模块和函数比循环数低的模块需要更多的测试用例。</p><p id="0821" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">每个函数必须有至少和它的圈数一样多的测试用例。</p><p id="51e3" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">如何通过圈数控制代码复杂度:</p><ul class=""><li id="e411" class="nt nu it me b mf mg mi mj my nv mz nw na nx mx ny nz oa ob bi translated"><strong class="me iu">如果圈数是1-10，</strong>那么代码是结构化的、写得好的、高度可测试的，成本和工作量更少。</li><li id="8d60" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated"><strong class="me iu">如果圈数是10–20，</strong>那么代码是复杂的，可测试性中等，成本和工作量中等。</li><li id="80e6" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated"><strong class="me iu">如果圈数是20–40，</strong>那么代码非常复杂，弱可测试性，并且成本和工作量很高。</li><li id="88bd" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated"><strong class="me iu">如果圈数是&gt; 40，</strong>根本不可测试，成本和精力都很高。</li></ul><p id="5b60" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">在周期的早期使用这个度量标准可以降低拥有复杂代码的风险。</p><p id="53cb" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">关于圈复杂度的更多信息:</p><div class="pb pc gp gr pd pe"><a href="http://www.mccabe.com/iq_research.htm" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">麦凯布智商研究图书馆</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">麦凯布智商研究图书馆我们已经为您提供了所有的研究工具，您将需要确认麦凯布是…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www.mccabe.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="42ab" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">认知复杂性</h2><blockquote class="ly lz ma"><p id="bc4f" class="mb mc md me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">“认知复杂性打破了使用数学模型评估软件可维护性的惯例。它从圈复杂度设置的先例开始，但使用人类的判断来评估应该如何计算结构，并决定应该向模型中添加什么。”认知复杂性:一种测量可理解性的新方法。</p></blockquote><p id="3c91" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">那是什么意思？让我们看看。</p><p id="62a6" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">代码A: </strong></p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="52fd" class="nb lh it ol b gy op oq l or os">int sumOfPrimes(int max) {              // +1<br/>  int total = 0;<br/>  OUT: for (int i = 1; i &lt;= max; ++i) { // +1<br/>    for (int j = 2; j &lt; i; ++j) {       // +1<br/>      if (i % j == 0) {                 // +1<br/>        continue OUT;<br/>      }<br/>    }<br/>    total += i;<br/>  }<br/>  return total;<br/>} // Cyclomatic Complexity 4</span></pre><p id="1114" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">代码B: </strong></p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="fb1f" class="nb lh it ol b gy op oq l or os">String getWords(int number) {   // +1<br/>    switch (number) {<br/>      case 1:                   // +1<br/>        return "one";<br/>      case 2:                   // +1<br/>        return "a couple";<br/>      default:                  // +1<br/>        return "lots";<br/>    }<br/>  } // Cyclomatic Complexity 4</span></pre><p id="ac00" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">这两个代码的圈复杂度是4。然而，如果我们依靠人类的理解，我们可以看到代码A比代码b更复杂。</p><p id="0ee0" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">所以让我们看看认知复杂性是如何重新审视这两个代码的。</p><p id="0dad" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">代码A: </strong></p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="0024" class="nb lh it ol b gy op oq l or os">                                        // Cyclomatic   Cognitive<br/>int sumOfPrimes(int max) {              // +1<br/>  int total = 0;<br/>  OUT: for (int i = 1; i &lt;= max; ++i) { // +1    +1<br/>    for (int j = 2; j &lt; i; ++j) {       // +1    +2 (nesting=1)<br/>      if (i % j == 0) {                 // +1    +3 (nesting=2)<br/>        continue OUT;                   // +1<br/>      }<br/>    }<br/>    total += i;<br/>  }<br/>  return total;<br/>}                                       // =4     =7</span></pre><p id="5c0f" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">代码B: </strong></p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="0636" class="nb lh it ol b gy op oq l or os">// Cyclomatic Complexity    Cognitive Complexity<br/>String getWords(int number) { //          +1<br/>  switch (number) {           //                                  +1<br/>    case 1:                   //          +1<br/>      return "one";<br/>    case 2:                   //          +1<br/>      return "a couple";<br/>    default:                  //          +1<br/>      return "lots";<br/>  }<br/>}                             //          =4                      =1</span></pre><p id="7325" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">似乎更符合逻辑，更正确。那么认知复杂性是如何工作的呢？</p><div class="pb pc gp gr pd pe"><a href="https://blog.sonarsource.com/cognitive-complexity-because-testability-understandability" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">SonarSource博客</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">SonarSource构建世界级的代码质量和代码安全工具。我们的产品，SonarLint，SonarQube和SonarCloud…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">blog.sonarsource.com</p></div></div></div></a></div><h2 id="cdf3" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">软件熵</h2><blockquote class="ly lz ma"><p id="76b7" class="mb mc md me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw mx im bi translated">“热力学第二定律原则上规定，一个封闭系统的无序度不能减少，只能保持不变或增加。这种无序的一个量度是熵。这个定律对软件系统来说似乎也是合理的；当一个系统被修改时，它的无序度，或者说熵，往往会增加。这就是所谓的软件熵。”—<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_entropy" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Software_entropy</a></p></blockquote><p id="e942" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">从技术上讲，熵(无序)可以通过以下方式来衡量:</p><ul class=""><li id="649c" class="nt nu it me b mf mg mi mj my nv mz nw na nx mx ny nz oa ob bi translated">源代码管理系统中每次提交时更改的文件数</li><li id="9ec0" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">我们引入的错误、失败和回归的数量</li></ul><p id="3dff" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">这是我们通过添加或修改特征，从上一个平衡状态引入的无序度。</p><p id="b848" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">如果每次变化带来越来越多的bug或失败，那么熵就在增加。</p><p id="b406" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">如果熵很高，那么代码就很复杂，设计也很糟糕。</p><p id="874e" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">对抗熵的唯一方法是代码审查、频繁的代码审查和重构。</p><h2 id="bb8c" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">霍尔斯特德度量</h2><p id="b588" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">我认为霍尔斯特德度量是最合理、最准确、最接近书面代码的。为什么？让我们看看。</p><p id="6adc" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">首先，代码是由什么组成的？</p><p id="0b33" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">代码=操作数+运算符</p><p id="9f5b" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">运算符:</strong> main，()，{}，int，scanf，&amp;，=，+，/，printf，，；<br/> <strong class="me iu">操作数:</strong>变量(a，b，c，I)，常量(1，2，3)。</p><p id="61a0" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">对于给定的函数，考虑:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="1766" class="nb lh it ol b gy op oq l or os">n1 = the number of distinct operators<br/>n2 = the number of distinct operands<br/>N1 = the total number of operators<br/>N2 = the total number of operands</span></pre><p id="a1ba" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">从这些数字中，可以计算出几个重要的指标:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="9e18" class="nb lh it ol b gy op oq l or os">Program length (N) = N = N1 + N2<br/>Vocabulary size (n) = n = n1 + n2<br/>Program volume (V) = V = N * log2(n)<br/>Difficulty level (D) = D = ( n1 / 2 ) * ( N2 / n2 )<br/>Effort to implement (E) = E = V * D<br/>Time to implement (T) = T = E / 18<br/>Number of delivered bugs (B) = B = (E^2/3) / 3000</span></pre><p id="5574" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">厉害！Halstead度量密切依赖于我们写了什么，以及我们如何根据代码(操作数和运算符)进行推理。他们衡量功能的整体质量。</p><p id="ef48" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">让我们看一个例子来更好地理解:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="2e1a" class="nb lh it ol b gy op oq l or os">main(){<br/>    int a, b, c, avg;<br/>    scanf("%d %d %d", &amp;a, &amp;b, &amp;c);<br/>    avg = (a + b + c) / 3;<br/>    printf("avg = %d", avg);<br/>}</span><span id="2754" class="nb lh it ol b gy pt oq l or os">The unique operators are: <br/>main, (), {}, int, scanf, &amp;, =, +, /, printf, ,, ;</span><span id="c981" class="nb lh it ol b gy pt oq l or os">The unique operands are: <br/>a, b, c, avg, "%d %d %d", 3, "avg = %d"</span><span id="3ac5" class="nb lh it ol b gy pt oq l or os">n1 = 12, n2 = 7, n = 19<br/>N1 = 27, N2 = 15, N = 42<br/>V = 42 * log2(19) = 178.4<br/>D = 12/2 * 15/7 = 12.85<br/>E = 12.85 * 178.4 = 2292.44<br/>T = 2292.44/18 = 127.357 seconds<br/>B = 0.05</span></pre><p id="9762" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">霍尔斯特德卷(五)</strong>描述了一个算法实现的大小。如果函数要保持清晰易懂，它的体积必须小:运算符数量少，操作数数量少，词汇量小(小函数)。函数的体积应该至少为20，最多为1，000。大于1，000的体积表明该函数可能做了太多的事情。</p><p id="1ce1" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">难度等级(D) </strong>与操作数总数和唯一操作数数之比成正比。如果在程序中多次使用相同的操作数，就更容易出错。</p><p id="7064" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">实现(E)或理解一个程序的努力</strong>与程序的量和难度成正比。大型函数具有较高的(E)。</p><p id="f802" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">交付的bug数量(B) </strong>估计实现中的错误数量。一个文件中交付的bug应该少于两个。</p><p id="f2fd" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">Halstead metrics是一种基于我们所写的和我们如何思考来有效地测量和预测代码的复杂性和质量的重要方法。</p><p id="002f" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">在软件开发中，一切都是可测量和可预测的。</p><p id="1788" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">关于霍尔斯特德指标的更多详情:</p><div class="pb pc gp gr pd pe"><a href="https://www.verifysoft.com/en_halstead_metrics.html" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">霍尔斯特德度量</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">使用Testwell CMT++和CMTJava(复杂性测量工具)测量霍尔斯特德指标霍尔斯特德复杂性指标…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www.verifysoft.com</p></div></div><div class="pn l"><div class="pu l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="09cf" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">保养率指数</h2><p id="b4f7" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">可维护性指数表明何时重写代码比修改代码更便宜和/或风险更小。让我们看看怎么做。</p><p id="8a86" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">维修性指数= MI = MIwoc + MIcw</p><p id="d04e" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu"> MIwoc </strong>:无注释的维修性指标<br/> <strong class="me iu"> MIcw </strong>:维修性指标注释权重</p><p id="a4cb" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated"><strong class="me iu">MIwoc</strong>= 171 5.2 * lnV 0.23 * G 16.2 * lnL</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="a15f" class="nb lh it ol b gy op oq l or os"><strong class="ol iu">V</strong> is the Halstead Volume.<br/><strong class="ol iu">G</strong> is the total Cyclomatic Complexity.<br/><strong class="ol iu">L</strong> is the number of Source Lines of Code (SLOC).</span></pre><p id="a478" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">太棒了——一个汇集了所有指标的指标！</p><p id="adeb" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">MIcw = 50 * sin(√2.4 * C)</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="1f37" class="nb lh it ol b gy op oq l or os"><strong class="ol iu">C</strong> average percent of lines of comments.</span></pre><p id="ae11" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">心肌梗塞病例:</p><ul class=""><li id="4bbe" class="nt nu it me b mf mg mi mj my nv mz nw na nx mx ny nz oa ob bi translated">85及以上:<strong class="me iu">良好的</strong>可维护性</li><li id="e6b0" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">65–85:<strong class="me iu">中等</strong>可维护性</li><li id="2624" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">&lt; 65: <strong class="me iu">维护困难</strong></li></ul><p id="1916" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">MI值甚至可以是负值:(</p><p id="81e6" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">关于可维护性指数的更多细节:</p><div class="pb pc gp gr pd pe"><a href="http://web.archive.org/web/20021120101304/http://www.stsc.hill.af.mil/crosstalk/2001/08/welker.html" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">STSC相声-软件可维护性指数重温-2001年8月</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">爱达荷国家工程和环境实验室软件可维护性指数在…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">web.archive.org</p></div></div><div class="pn l"><div class="pv l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="2786" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">模块性(内聚力、传出耦合、传入耦合和不稳定性指标)</h2><div class="pb pc gp gr pd pe"><a rel="noopener  ugc nofollow" target="_blank" href="/inside-software-modularity-and-related-metrics-2e5af2b447dc"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">我们如何度量软件的模块性和依赖性？</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">什么是模块化，有哪些度量标准可以用来衡量模块化？</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">better编程. pub</p></div></div><div class="pn l"><div class="pw l pp pq pr pn ps ks pe"/></div></div></a></div><p id="8cf4" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">有什么工具可以自动测量这些指标吗？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="35a4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">有哪些可用的工具？</h1><h2 id="8a5a" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">静态分析器JavaScript代码的ESlint</h2><p id="5745" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">除了确保最佳实践，ESLint还可用于检测一些已知的复杂气味:</p><div class="pb pc gp gr pd pe"><a href="https://eslint.org/docs/rules/complexity" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">复杂性-规则</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">圈复杂度衡量程序源代码中线性独立路径的数量。这个规则…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">eslint.org</p></div></div><div class="pn l"><div class="px l pp pq pr pn ps ks pe"/></div></div></a></div><p id="70ed" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">我们可以找到一些规则来限制:</p><ul class=""><li id="5915" class="nt nu it me b mf mg mi mj my nv mz nw na nx mx ny nz oa ob bi translated">圈复杂度(<code class="fe ot ou ov ol b"><a class="ae ky" href="https://eslint.org/docs/rules/complexity" rel="noopener ugc nofollow" target="_blank">complexity</a></code>)</li><li id="b66a" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">功能最大深度(<code class="fe ot ou ov ol b"><a class="ae ky" href="https://eslint.org/docs/rules/max-depth" rel="noopener ugc nofollow" target="_blank">max-depth</a></code></li><li id="239d" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">功能最大行数(<code class="fe ot ou ov ol b"><a class="ae ky" href="https://eslint.org/docs/rules/max-lines-per-function" rel="noopener ugc nofollow" target="_blank">max-lines-per-function</a></code></li><li id="df6a" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">函数max语句(<code class="fe ot ou ov ol b"><a class="ae ky" href="https://eslint.org/docs/rules/max-statements" rel="noopener ugc nofollow" target="_blank">max-statements</a></code>)</li><li id="a8bd" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">函数最大参数(<code class="fe ot ou ov ol b"><a class="ae ky" href="https://eslint.org/docs/rules/max-params" rel="noopener ugc nofollow" target="_blank">max-params</a></code>)</li><li id="6ad8" class="nt nu it me b mf oc mi od my oe mz of na og mx ny nz oa ob bi translated">最大嵌套回调(<code class="fe ot ou ov ol b"><a class="ae ky" href="https://eslint.org/docs/rules/max-nested-callbacks" rel="noopener ugc nofollow" target="_blank">max-nested-callbacks</a></code>)</li></ul><p id="8c99" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">强烈建议从开发开始就激活和配置这些规则，以免欠债。</p><h2 id="90d8" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">静态分析器——Sonar for Java代码</h2><p id="e670" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">正如ESLint对于JavaScript代码很强大一样，Sonar对于Java代码也很强大。</p><div class="pb pc gp gr pd pe"><a href="https://rules.sonarsource.com/java" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">规则浏览器</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">编辑描述</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">rules.sonarsource.com</p></div></div></div></a></div><p id="dbe1" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">我认为声纳是唯一引入认知复杂性概念的工具:</p><div class="pb pc gp gr pd pe"><a href="https://www.sonarsource.com/resources/white-papers/cognitive-complexity.html" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">认知复杂性</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">认知复杂性提供了一种新的衡量代码理解难度的方法——这让开发人员感到…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">www.sonarsource.com</p></div></div><div class="pn l"><div class="py l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="3d9e" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">ES6-Plato — JavaScript源代码复杂性可视化工具</h2><div class="pb pc gp gr pd pe"><a href="https://github.com/es-analysis/plato" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">es-分析/柏拉图</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">JavaScript源代码可视化、静态分析和复杂性工具- es-analysis/plato</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="pz l pp pq pr pn ps ks pe"/></div></div></a></div><p id="5a60" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">一个报告示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/6a1a18ee30c06fc71ad423dce8df77a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3KZhVMW3kWeKsKcOHBHuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ES6-柏拉图—作者图片</p></figure><p id="9b18" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">正如我们所看到的，MI分数考虑了Halstead容量、圈复杂度和每个源文件的行数。</p><p id="6156" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">使用Halstead提供的错误分数来计算估计的错误数。</p><p id="bf05" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">复杂度分数基于圈复杂度的计算:</p><div class="pb pc gp gr pd pe"><a href="https://github.com/the-simian/es6-plato/blob/master/lib/reporters/complexity/index.js#L48" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">-猿人/es6-柏拉图</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">JavaScript源代码可视化、静态分析和复杂性工具- the-simian/es6-plato</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="qb l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="be38" class="nb lh it bd li nc nd dn lm ne nf dp lq my ng nh ls mz ni nj lu na nk nl lw nm bi translated">Git改变历史和拉请求</h2><p id="8fda" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">我认为Git的变化历史和拉取请求是度量熵和所产生的无序的最确定和早期的指标。</p><p id="4c5a" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">如果一个小的改变改变了许多文件，那么出现错误和退化的风险将会很高。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1bf4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="c05f" class="pw-post-body-paragraph mb mc it me b mf nn ju mh mi no jx mk my np mn mo mz nq mr ms na nr mv mw mx im bi translated">在本文中，我们发现了为什么复杂性很重要，原因是什么，以及哪些参数和工具可用于处理复杂性。</p><p id="a8bb" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">当代码难以测试、理解和扩展时，就被认为是复杂的。</p><p id="2102" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">多决策路径、大函数、回调和缺乏模块化是复杂性最重要的特征。</p><p id="6a64" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">强烈建议在开发过程中使用提到的各种度量标准来控制复杂性的发展，这样你就不会背上沉重的债务。工具使控制变得容易和自动化。</p><p id="b46d" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">我们强调了主要指标和原因。然而，还有其他非技术的但是人为的原因，比如这些公理:“单元测试很难做和维护”，“我没有时间”，“我改天再回顾它”，以及“它有效，不要碰它！”</p><p id="dace" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">如果我们的开发文化不改变，度量、公式、数学和理论就没有附加值:如果我们继续将单元测试视为道具或争议的主题，如果我们不使用工具，如果我们继续将代码视为一组要编写的行，而不是质量活动的反映。</p><p id="07ea" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">技术和人为因素必须存在，并且必须相互配合以达到最佳和必要的质量等级。</p><p id="78a4" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">战斗的最后一个公理:“太晚了。”完美的软件是不存在的，但是每一个软件在其生命周期中都在不断地迭代改进。你只需要计划允许这种灵活性的结构。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="a3c5" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">谢谢你看了我的故事。</p><p id="6bc0" class="pw-post-body-paragraph mb mc it me b mf mg ju mh mi mj jx mk my mm mn mo mz mq mr ms na mu mv mw mx im bi translated">你可以在<strong class="me iu"/>GitHub:【https://github.com/helabenkhalfallah】T2找到我</p></div></div>    
</body>
</html>