<html>
<head>
<title>Managing Jetpack Compose UI State With Sealed Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用密封类管理Jetpack撰写UI状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/managing-jetpack-compose-ui-state-with-sealed-classes-d864c1609279?source=collection_archive---------2-----------------------#2022-05-20">https://betterprogramming.pub/managing-jetpack-compose-ui-state-with-sealed-classes-d864c1609279?source=collection_archive---------2-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="84fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用密封类处理可组合视图的可能状态</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4f78be3605c881bf483d6ece5876f7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QsAJS0v7Wozc7uVE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@oandersonrian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Anderson Rian </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新UI以符合给定的状态是大多数Android开发人员的常规任务。最常见的工作之一是在来自API请求的加载、错误和成功状态之间转换。</p><p id="d70c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在XML视图系统中管理UI状态是一个非常标准的过程，通常包括设置视图的属性以反映当前状态，并根据需要隐藏/显示视图。例如，隐藏加载视图，显示内容视图，并用所需的内容填充它。除了它的主要缺陷:人为错误，这个过程没有太多可谈的。</p><p id="f85e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您作为Android开发人员的职业生涯中，您可能会盯着一个基于视图绑定的屏幕看几分钟(对于非常复杂的布局甚至几个小时)，试图了解为什么您的UI没有正确更新，过了一段时间后发现您忘记了一个<code class="fe ls lt lu lv b">myView.visibility = View.GONE</code>，这是一个普遍的错误，它是由手动更新每个可能状态的视图造成的。</p><h1 id="f203" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">状态和重组</h1><p id="8d67" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Jetpack Compose旨在通过使用<code class="fe ls lt lu lv b">State</code>类来创建实际的反应式屏幕，更改状态的值会触发依赖于该相同状态的可组合函数的重新组合，换句话说，如果我们的状态对象持有一个字符串值，则每次更改时都会触发一个新的组合，提供更新的字符串值，而无需手动设置方法。这对每一个组合<code class="fe ls lt lu lv b">State&lt;T&gt;</code>都是有效的，所以如果我们的UI状态保存在一个状态对象中，我们可以自动更新UI的每一个状态变化。</p><p id="1f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是说够了，让我们做一些真正的代码。</p><h1 id="63f3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">设计我们的UI状态</h1><p id="ad3e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">首先，让我们创建一个负责描述屏幕可能状态的密封类，这个特殊的用例需要3种不同的情况:加载、出错和就绪。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gist1:创建UIState密封类</p></figure><p id="0fb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在这个场景中，包含任何数据的唯一状态是<code class="fe ls lt lu lv b">Success</code>，这是因为我们的用例不需要任何加载或错误状态的附加信息。</p><h1 id="f169" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">处理状态更改</h1><p id="86c6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们的用例遵循MVVM模式，因此屏幕的当前状态将存储在视图模型中。</p><p id="bae8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个私有的<code class="fe ls lt lu lv b">MutableStateFlow</code>将用于保存UI状态，一个公共的StateFlow为我们的Compose视图传播这个信息，一个模拟的实现使用一个延迟来模拟由异步请求引起的加载状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="176a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们知道一旦ViewModel被实例化，就会启动一个API请求，所以我们可以安全地假设屏幕的起始状态是loading。</p><h1 id="8c52" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">对状态变化做出反应</h1><p id="3f19" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">AlbumState设置就绪后，我们将转到UI，让它根据存储在ViewModel中的当前状态进行反应和重组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7016" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个布局由两个不同的可组合函数组成，<code class="fe ls lt lu lv b">AlbumScreen</code>包含注入的<code class="fe ls lt lu lv b">ViewModel</code>，以及它的无状态伴随内容，负责布局配置。</p><p id="cf6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内容包含一个默认的材质设计框架，该框架包含一个顶栏和一个<code class="fe ls lt lu lv b">when</code>案例，负责通知每个<code class="fe ls lt lu lv b">AlbumState</code>应该显示什么。当运行应用程序时，我们可以看到我们的行为正在按预期工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/5a1d0614bd3e4880ffb06c1d8aab71e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/1*hMSEr0svsJBXWLribRS31Q.gif"/></div></figure><h1 id="7f23" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">预览多个状态</h1><p id="2d64" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">预览可以帮助开发人员看到正在编写的合成UI的可视化表示。</p><p id="2b90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免重新启动应用程序来查看每个状态的视觉结果，我们可以使用一个带注释的预览功能和一个<code class="fe ls lt lu lv b">PreviewParameter</code>提供程序来呈现我们所有状态的唯一预览。</p><p id="1374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这样做，我们可以断言两件事:每个屏幕的布局都是正确设计的，并且所有可能的状态都是互斥的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="512e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">声明一个<code class="fe ls lt lu lv b">PreviewParameterProvider&lt;T&gt;</code>允许在预览注释函数中使用这个提供者，它的工作方式是为包含在值序列中的每个值生成一个新的预览。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e31d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在“设计”选项卡中，我们可以看到为每个状态生成的其他预览:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e39df7c5dfe90ec6a318676db12d7718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/1*Ov2i9G8GSzm52afuDVN8Eg.gif"/></div></figure><h1 id="9830" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">单元测试UI状态</h1><p id="9f14" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">屏幕状态现在存储在ViewModel中，所以编写单元测试来保证状态被正确更新是很有趣的。由于UI的状态是StateFlow，我们可以使用Turbine库来更容易地收集我们的流的每个值。</p><blockquote class="mx my mz"><p id="0bfc" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">下面的测试是用Kotlin协同程序版本1.6.1编写的。测试API可能会根据您使用的版本而变化。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="209b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">UI状态检测测试</h1><p id="b06d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">插装测试对于保证组件显示给定状态的正确布局非常有用。这些测试可以用UI测试的组合标准库来编写。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/19a7bb81212a14eb2ab3a71d1a4ab978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWy_6t_yzI90zg9QLp1Yyw.png"/></div></div></figure><p id="0b6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，对于每种状态，将使用不同的composable，因此可以添加一个测试标签用于我们的测试。测试标签将作为我们测试的标识符，所以我们可以断言哪个组件显示在屏幕上。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="6152" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">什么时候应该对UI状态使用密封类？</h1><p id="a748" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当UI有一组互斥的布局时，密封状态非常有用。这种方法(如果正确实现的话)保证了在任何给定的时间只有一个屏幕状态是可见的，避免了同时呈现多个状态可能导致的错误。</p><h1 id="7a24" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">何时不对UI状态使用密封类</h1><p id="9a3f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当UI不需要互斥的布局时，使用密封类来处理状态可能一点用都没有，有时，甚至是一个只会增加状态管理复杂性的问题。对于这些情况，最好使用包含所需信息的单个数据类。</p><p id="0fc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的示例代码可从以下网址获得:</p><p id="8831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/Alaksion/ComposeStateSample" rel="noopener ugc nofollow" target="_blank">https://github.com/Alaksion/ComposeStateSample</a></p></div></div>    
</body>
</html>