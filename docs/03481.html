<html>
<head>
<title>Best Practices for Using Optionals in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用选项的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-for-using-optionals-in-swift-e9ac093ad50d?source=collection_archive---------9-----------------------#2020-02-12">https://betterprogramming.pub/best-practices-for-using-optionals-in-swift-e9ac093ad50d?source=collection_archive---------9-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="31d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">因看到“致命错误:在展开可选值时意外发现nil”而沮丧？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8eac1edf5e6211917887035776c204cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyBKB4lMNwyzZjAn2iAgtA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@elleirva?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Avrielle Suleiman </a>在<a class="ae ky" href="https://unsplash.com/s/photos/best-practice?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f3ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在Swift项目中非常频繁地使用期权。如果使用不当，我们会在Xcode中遇到这个错误。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="858f" class="ma mb it lw b gy mc md l me mf">Fatal error: Unexpectedly found nil while unwrapping an Optional value</span></pre><p id="9743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当它在应用程序运行时发生，应用程序就会可靠地崩溃，导致应用程序在应用程序商店的审查过程中立即被拒绝。</p><p id="8f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，防止这种情况发生非常重要——理想情况下是在应用程序开发阶段。</p><p id="d0b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将回顾在Swift中使用选件的最佳实践。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="66cd" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">什么是可选的？</h1><p id="3cd6" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">可选数据类型要么代表一个值，要么根本不代表任何值。</p><p id="f59a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在下面的代码中，我们声明了一个名为<code class="fe nj nk nl lw b">name</code>的可选字符串。如您所见，<code class="fe nj nk nl lw b">name</code>变量可以有<code class="fe nj nk nl lw b">John</code>的赋值，也可以在设置为<code class="fe nj nk nl lw b">nil</code>后没有值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对可选字符串有了初步的感受之后，让我们看看Apple是如何定义可选的。</p><blockquote class="no"><p id="c88e" class="np nq it bd nr ns nt nu nv nw nx lu dk translated">"一种表示包装值或<code class="fe nj nk nl lw b">nil</code>，即没有值的类型."</p></blockquote><p id="78bf" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">这种数据类型的声明如下。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f83c" class="ma mb it lw b gy mc md l me mf">@frozen enum Optional&lt;Wrapped&gt;</span></pre><p id="4642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所知，这是一个通用的枚举，但是它有什么情况呢？可选有两种情况。</p><p id="cddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl lw b">none</code>事例是没有任何值，通常表示为<code class="fe nj nk nl lw b">nil</code>，而<code class="fe nj nk nl lw b">some(Wrapped)</code>事例是已定义数据类型的包装值，如<code class="fe nj nk nl lw b">Int</code>、<code class="fe nj nk nl lw b">String</code>、<code class="fe nj nk nl lw b">Dictionary</code>，以及自定义的<code class="fe nj nk nl lw b">struct</code> s和<code class="fe nj nk nl lw b">class</code> es。</p><p id="c358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，一些人认为可选性可以被看作是一些数据类型的容器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="ff13" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">声明</h1><p id="a8cc" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">有多种方法可以声明可选的。需要注意的一点是，如果我们声明一个可选的，我们必须明确包装的数据类型，因为可选的是一个泛型枚举，因此这个泛型数据类型的使用必须涉及一个具体的数据类型，比如<code class="fe nj nk nl lw b">Int</code>和<code class="fe nj nk nl lw b">String</code>。</p><p id="4ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的声明有错误:<code class="fe nj nk nl lw b">Reference to generic type ‘Optional’ requires arguments in &lt;…&gt;</code>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="53d0" class="ma mb it lw b gy mc md l me mf">var optionalValue: Optional?</span></pre><h2 id="2757" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">使用尾随问号</h2><p id="bd6a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">声明可选的最常见方式是在特定数据类型后使用一个尾随问号(<code class="fe nj nk nl lw b">?</code>)。</p><p id="e26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码创建了各种数据类型的选项，包括<code class="fe nj nk nl lw b">Int</code>、<code class="fe nj nk nl lw b">String</code>、<code class="fe nj nk nl lw b">Array</code>、<code class="fe nj nk nl lw b">Dictionary</code>、<code class="fe nj nk nl lw b">struct</code>和<code class="fe nj nk nl lw b">class</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，当我们声明一个可选的通用数据类型时，比如<code class="fe nj nk nl lw b">Array</code>和<code class="fe nj nk nl lw b">Dictionary</code>，我们必须明确这些通用数据类型的确切数据类型。</p><p id="a008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的声明错误地使用了没有数据特异性的通用数据类型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="53cf" class="ma mb it lw b gy mc md l me mf">var names: Array?<br/>var information: Dictionary?</span></pre><p id="b774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以像在上面的代码片段中一样，为<code class="fe nj nk nl lw b">Array</code>和<code class="fe nj nk nl lw b">Dictionary</code>指定元素的数据类型。</p><p id="5b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift中一个有趣的特性是，你可以在可选数据类型后面附加一个问号，使其成为可选的可选数据类型，如果你愿意，可以重复多次。好像下面的东西。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8ce6" class="ma mb it lw b gy mc md l me mf">var optional0: String? // an optional String<br/>var optional1: String?? // an optional String?<br/>var optional2: String??? // an optional String??<br/>...and so on</span></pre><h2 id="020c" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">使用可选的<wrapped/></h2><p id="3416" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">另一种不太常用的声明选项的方式是使用<code class="fe nj nk nl lw b">Optional&lt;Wrapped&gt;</code>的形式，其中<code class="fe nj nk nl lw b">Wrapped</code>是特定的数据类型。下面的代码片段向您展示了上面显示的相同变量的声明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该注意的是，这两种声明方式具有完全相同的效果，但是使用问号的第一种方式是首选的，因为它具有更好的可读性。</p><h2 id="b9a4" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">使用结尾感叹号</h2><p id="b620" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">声明可选选项的另一种相对常见的方式是在数据类型(例如，<code class="fe nj nk nl lw b">Int</code>)后面添加一个感叹号(<code class="fe nj nk nl lw b">!</code>)，这被称为<em class="oo">隐式展开的可选选项</em>。</p><p id="5bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不熟悉这个术语，也不用担心，因为我们将在本文的后面详述这个概念。下面给出了一些相关的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ef0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所料，<code class="fe nj nk nl lw b">lastName</code>变量是<code class="fe nj nk nl lw b">Optional&lt;String&gt;</code>数据类型。然而，如果你在一个使用<code class="fe nj nk nl lw b">Optional&lt;Wrapped&gt;</code>方法声明的可选元素后面附加一个感叹号，事情会有所不同。</p><p id="22f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你看到的<code class="fe nj nk nl lw b">firstName</code>变量，它的类型是可选的<code class="fe nj nk nl lw b">String?</code>，而不是可选的<code class="fe nj nk nl lw b">String</code>。</p><p id="7b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结果分享了创建可选选项的相同概念，将多个问号附加到一个数据类型，就像我们在第一部分中介绍的<code class="fe nj nk nl lw b">String</code>(<em class="oo">使用问号</em>部分)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9ccc" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">赋值</h1><p id="138e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当我们声明选项时，如果我们愿意，我们可以给这些变量赋值。如果我们不指定任何值，所有选项都有默认的“值”— <code class="fe nj nk nl lw b">nil</code>，没有值。</p><p id="6034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码向您展示了各种赋值是如何完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="824b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以使用可选变量的<code class="fe nj nk nl lw b">none</code> case给可选变量赋值，这使得变量有一个<code class="fe nj nk nl lw b">nil</code>值。类似地，我们可以使用<code class="fe nj nk nl lw b">some&lt;Wrapped&gt;</code>案例将包装数据类型的值赋给可选的。</p><p id="1304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以给可选变量赋一个可选值。在这个例子中，当我们使用<code class="fe nj nk nl lw b">middleName</code>字符串访问<code class="fe nj nk nl lw b">Dictionary&lt;String, String&gt;</code>中的键值时，返回的数据类型是<code class="fe nj nk nl lw b">String?</code>类型，因为这个键很可能不在<code class="fe nj nk nl lw b">Dictionary</code>中。</p><p id="90c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，即使我们知道键(例如，<code class="fe nj nk nl lw b">firstName</code>)存在，返回的数据类型仍然是<code class="fe nj nk nl lw b">String?</code>，因为在运行时，<code class="fe nj nk nl lw b">Dictionary</code>的键列表总是会发生变化。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="744b" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">展开选项</h1><p id="e2d4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">为了在大多数上下文中使用选项，我们需要解开选项以访问它们的包装值，如果不是<code class="fe nj nk nl lw b">nil</code>。我们有不同的方案来展开期权，总结如下。</p><h2 id="6657" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">强制展开</h2><p id="85e5" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当我们确定可选的包含一个值时，我们可以使用变量名后面的感叹号(<code class="fe nj nk nl lw b">!</code>)来无条件地解开这个值。</p><p id="13c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，当我们声明一个可选变量时，我们在数据类型后面使用感叹号，这与变量后面的展开不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="9d8f" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">隐式展开</h2><p id="cc23" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在<em class="oo">声明</em>部分，我们简要提到了<em class="oo">隐式展开选项</em>的概念。在这里，我们解释一下它是什么。</p><p id="d8d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上我们是用感叹号来声明某一类型的可选变量，就说<code class="fe nj nk nl lw b">String</code>，变量名叫做<code class="fe nj nk nl lw b">jobTitle</code>。</p><p id="39b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次使用这个变量时，我们可以省略强制解包操作符(即后置<code class="fe nj nk nl lw b">!</code>)来解包可选的。实际上，编译器会无条件地为我们解开这个选项，这就是为什么它被称为<em class="oo">隐式解开</em>。</p><p id="2d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，即使我们没有明确地在变量后面使用后置的<code class="fe nj nk nl lw b">!</code>,我们仍然有责任确保可选的不是<code class="fe nj nk nl lw b">nil</code>,因为强制展开仍然在幕后发生。</p><p id="3de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当可选的恰好是<code class="fe nj nk nl lw b">nil</code>时，解包会导致本文开头所示的致命错误。请看下面一些相关的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="99d2" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">可选绑定</h2><p id="87a9" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">因为如果我们使用强制解包，一些行为可能是不可预测的，所以我们可以使用<em class="oo">可选绑定</em>，它有条件地解包一个可选的。</p><p id="cab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，我们可以使用<code class="fe nj nk nl lw b">if let</code>、<code class="fe nj nk nl lw b">guard let</code>和<code class="fe nj nk nl lw b">switch</code>，前两者使用得更多。相关的例子如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9a50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于上面的代码有几点需要注意。当我们使用<code class="fe nj nk nl lw b">if let </code>语句时，我们可以访问直接花括号中的命名变量(第4-6行),但不能访问它们之外的变量。</p><p id="1f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，当我们使用<code class="fe nj nk nl lw b">guard let</code>语句时，可以在它的外部访问命名变量(第15行)，但不能在紧接的花括号中访问(第11-13行)。</p><p id="ebbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe nj nk nl lw b">switch</code>语句，这只是因为<code class="fe nj nk nl lw b">Optional</code>数据类型是一个通用枚举，因此允许我们针对<code class="fe nj nk nl lw b">none</code>情况检查一个可选值(即<code class="fe nj nk nl lw b">nil</code>)。</p><h2 id="59e9" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">可选链接</h2><p id="64a6" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">有时，如果一个选项是<code class="fe nj nk nl lw b">nil</code>我们也没问题，我们只是不使用<code class="fe nj nk nl lw b">nil</code>选项执行进一步的操作。在这种情况下，我们可以通过在可选变量后使用后缀问号(<code class="fe nj nk nl lw b">?</code>)来使用可选绑定。</p><p id="9b6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="afa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，<code class="fe nj nk nl lw b">firstInitial0</code>和<code class="fe nj nk nl lw b">firstInitial1</code>变量都成功创建为可选的<code class="fe nj nk nl lw b">Boolean</code>变量，前者为<code class="fe nj nk nl lw b">true</code>，后者为<code class="fe nj nk nl lw b">nil</code>。</p><p id="d630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，这种可选的链接方法允许我们安全地访问可选的属性和方法，因为如果可选的是<code class="fe nj nk nl lw b">nil</code>，它会将<code class="fe nj nk nl lw b">nil</code>赋给声明的变量。</p><h2 id="05d3" class="ma mb it bd mo od oe dn ms of og dp mw li oh oi my lm oj ok na lq ol om nc on bi translated">零合并</h2><p id="ad6b" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">这也是处理期权的一种常见方式。基本上，我们使用nil-coalescing操作符(<code class="fe nj nk nl lw b">??</code>)来为一个声明的变量提供一个默认值，如果可选的是<code class="fe nj nk nl lw b">nil</code>。下面给出一个简单的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dbea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，使用键访问<code class="fe nj nk nl lw b">Dictionary</code>的元素的数据类型是可选的。根据值是否为<code class="fe nj nk nl lw b">nil</code>，零合并操作符后的默认值将被分配给声明的变量。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4e10" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">外卖食品</h1><p id="9ef4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">本文回顾了有关在Swift中正确使用选项的各个方面。这里有一个外卖的快速总结。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/33eb54af22a29123b21128118a2ecbb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tl4jnu3as6lr4l9_hdxuuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift中可选的最佳实践</p></figure><p id="f245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。Swift快乐编码。</p></div></div>    
</body>
</html>