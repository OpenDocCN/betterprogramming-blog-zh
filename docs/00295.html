<html>
<head>
<title>JavaScript: An In-Depth Look at Prototypal Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:对原型继承的深入研究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-prototypal-inheritance-in-depth-fb46ea20b9cd?source=collection_archive---------0-----------------------#2019-02-24">https://betterprogramming.pub/javascript-prototypal-inheritance-in-depth-fb46ea20b9cd?source=collection_archive---------0-----------------------#2019-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="432b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">借助代码示例和控制台输出，深入了解JavaScript继承和实现它所涉及的概念。它的目标读者是对JavaScript如何工作有基本了解，并且希望以一种详细的方式理解JavaScript继承的人。我们将把范围限制在ECMAScript5，这是ECMAScript6 (ES2015)之前的版本。</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/4396202bc16e22e0ead636de26df3742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pl9OyXXrLH_5JiQB8vNx3w.jpeg"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图片由<a class="ae lf" href="https://unsplash.com/photos/86b0GW7aLUw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Taras Shypka </a>在<a class="ae lf" href="https://unsplash.com/search/photos/chrome-extensions?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="a177" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">JavaScript继承很难</h2><p id="bd2c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">人们经常认为JavaScript的继承比其他编程语言(如Java)中典型的经典继承模式更容易理解，因为它冗长且概念复杂，如变量作用域(<code class="fe me mf mg mh b">private</code>、<code class="fe me mf mg mh b">protected</code>、<code class="fe me mf mg mh b">friend</code>、<code class="fe me mf mg mh b">interface</code>等)。)在这些语言中找到。虽然这些概念在JavaScript中并不存在，但它有自己的一套特性和概念，并不总是容易理解，例如<code class="fe me mf mg mh b">this</code> <strong class="js iu">、</strong> <code class="fe me mf mg mh b">call</code> <strong class="js iu">、</strong> <code class="fe me mf mg mh b">prototype</code> <strong class="js iu">、</strong> <code class="fe me mf mg mh b">new</code> <strong class="js iu">、</strong>函数构造函数<strong class="js iu">、</strong><code class="fe me mf mg mh b">constructor</code><strong class="js iu">、</strong>等等。</p><p id="46a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，作为一名前端开发人员，我发现我的大部分工作都围绕着使用JavaScript库/框架，而不是原生JavaScript。这些库很好地抽象了这些语言特性，并为我们提供了它们自己的API，这导致了更快的应用程序设置，并使编写应用程序代码变得更快更容易。然而，这样做的缺点是，随着时间的推移，不使用原生JavaScript会削弱我们对这些概念的理解——一切都变得有点模糊。当然，我们可以只用标准的JavaScript APIs来构建应用程序，很多人更喜欢这样。但是JavaScript社区的很大一部分，尤其是前端的，通常都使用库。要成为一名更好的开发人员，我们必须很好地掌握这些概念。今天，我们将致力于加强控制。</p><h1 id="60e2" class="mi lh it bd li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv mw mx lx my bi translated">班级</h1><p id="5564" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">与其他编程语言不同，JavaScript没有任何名为<code class="fe me mf mg mh b">class</code>的语言结构。</p><blockquote class="mz na nb"><p id="126e" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated">JavaScript中的类是使用函数实现的。每当我们使用一个函数来创建一个类时，它就被称为函数构造器。所有对象都是使用函数构造函数和关键字<code class="fe me mf mg mh b"><em class="it">new</em></code>创建的。</p></blockquote><p id="a568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript的新版本ES2015引入了<code class="fe me mf mg mh b">class</code>关键字，但这仅仅是在函数构造函数上的语法糖衣。“函数构造函数”和“类”可以互换使用，因为它们在JavaScript中表达了相同的概念。稍后我们将看到<em class="ko">为什么</em>这样的函数被称为函数<em class="ko">构造函数</em>。让我们创建我们的第一个类:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="a05c" class="lg lh it mh b gy nj nk l nl nm">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="465b" class="lg lh it mh b gy nn nk l nl nm">var person = new Person('John');</span></pre><p id="b8d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然语法非常简单，但这里有几个概念。让我们试着去理解它们。</p><h2 id="088a" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">新建，构造函数</h2><p id="c5f9" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">首先，我们创建一个函数<code class="fe me mf mg mh b">Person</code>(它还不是函数构造器！).第一个字母大写仅仅是一种约定，表示它将被用作函数构造函数。接下来，我们使用<code class="fe me mf mg mh b">new</code>操作符创建一个<code class="fe me mf mg mh b">Person</code>的实例。让我们看看<code class="fe me mf mg mh b">new</code>在引擎盖下做了什么:</p><ul class=""><li id="9c30" class="no np it js b jt ju jx jy kb nq kf nr kj ns kn nt nu nv nw bi translated">它将<code class="fe me mf mg mh b">this</code>的值设置为正在创建的实例。通常，<code class="fe me mf mg mh b">this</code>指向调用<em class="ko">函数的对象。</em>如果<code class="fe me mf mg mh b">new</code>没有执行这一步，<code class="fe me mf mg mh b">this</code>就会指向语句<code class="fe me mf mg mh b">var person = new Person('John')</code>执行的上下文中的对象。你可以在这里阅读更多关于<code class="fe me mf mg mh b">this</code> <a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">的内容</a>。</li><li id="5ca6" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">从函数中隐式返回<code class="fe me mf mg mh b">this</code>，也就是说，我们不必在函数的末尾写<code class="fe me mf mg mh b">return this;</code>。请注意，这种隐式返回只发生在我们没有显式指定要返回什么的时候。</li><li id="ee9d" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">将<code class="fe me mf mg mh b">person</code>的<code class="fe me mf mg mh b">constructor</code>设置为<code class="fe me mf mg mh b">Person</code>。这是<code class="fe me mf mg mh b">Person</code>成为<code class="fe me mf mg mh b">person</code>的函数<em class="ko">构造器</em>的步骤。如果您记录了<code class="fe me mf mg mh b">person.constructor</code>，您将会看到以下输出:</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6997e4241c2ef067f102fa3bc44a8296.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*k3GivqXeqLlgfxMdcrwreg.png"/></div></figure><p id="19a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在关键字<code class="fe me mf mg mh b">constructor</code>上多停留一会儿。在基于类的语言中，每当我们创建一个类蓝图时，我们在类中显式地指定它的<code class="fe me mf mg mh b">constructor</code>函数，并且每次从类中创建一个新对象时运行它。构造函数的工作是初始化被创建的对象。</p><p id="1f3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，我们如何指定一个JavaScript类的构造函数呢？我们没有。在JavaScript中，类的构造函数就是类本身。每次创建新对象时，都会运行函数构造函数。</p><blockquote class="mz na nb"><p id="23d5" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated">我们可以通过查询<code class="fe me mf mg mh b"><em class="it">object.constructor</em></code>知道任何对象的函数构造器/类。</p></blockquote><p id="875b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意这里的<em class="ko">对象</em>不能被解释为对象文字——它们也可以是原始数据类型。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="eece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看JavaScript中一些常见数据类型的内置函数构造函数，以便更清楚地理解:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/61b5a90ced5ecdfe31687d03ecbd75fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*4pl3M2ok62bTvS7t7GBAwQ.png"/></div></figure><p id="9328" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你们中的一些人可能会想，“<em class="ko">嘿，我们没有在这里使用</em> <code class="fe me mf mg mh b">new</code> <em class="ko">来创建一个实例。那么，为什么在</em> <code class="fe me mf mg mh b">Person</code> <em class="ko">的例子中需要而在这里不需要呢？背后的原因是所有这些实例都是使用内置函数构造函数创建的。JavaScript为我们提供了更简单的API来初始化这样的实例，并且不需要我们使用<code class="fe me mf mg mh b">new</code>来创建它们。但这并不意味着我们<em class="ko">不能</em>利用<code class="fe me mf mg mh b">new</code>来创造它们:</em></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c8553e46937f176a84faa2991fb69c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*cY32SLwasziFuPRSFxF5lA.png"/></div></figure><p id="d899" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>使用<code class="fe me mf mg mh b">new</code>创建内置函数构造器的实例可能会导致潜在的错误。例如，考虑以下代码:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2982082b7a0430e6bcaee666b5fd33dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*_IbuX_xz5EfJfewMlGdZmw.png"/></div></figure><p id="9f76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，你会期望<code class="fe me mf mg mh b">a</code>和<code class="fe me mf mg mh b">b</code>相等，但是它们不相等。为什么？因为:</p><blockquote class="mz na nb"><p id="284d" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated"><code class="fe me mf mg mh b"><em class="it">new</em></code>总是创建<code class="fe me mf mg mh b"><em class="it">object</em></code>数据类型的实例。创建的实例，不管它包含什么数据类型，都遵循普通对象的所有规则。</p></blockquote><p id="f451" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe me mf mg mh b">a</code>和<code class="fe me mf mg mh b">b</code>不相等，因为它们是对象，并且两个对象不会被<code class="fe me mf mg mh b">==</code>或<code class="fe me mf mg mh b">===</code>视为相等，除非它们指向内存中的同一个对象，而不管它们是否具有相同的值。乍一看，这似乎是反直觉的，尤其是在这个例子中，因为我们期望存储相同数字的两个变量是相等的。</p><h1 id="0b9d" class="mi lh it bd li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv mw mx lx my bi translated">原型遗传</h1><p id="1d44" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">JavaScript遵循原型继承模式。让我们通过一个一个的概念来理解它。</p><h2 id="549f" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">原型</h2><p id="9802" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">创建类时的一个常见用例是向它添加方法。让我们看看如何做到这一点:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="3fb2" class="lg lh it mh b gy nj nk l nl nm">function Person(name) {<br/>  this.name = name;<br/>  this.printName = function() {<br/>    console.log('Hi! My name is ' + this.name);<br/>  }<br/>}</span><span id="637d" class="lg lh it mh b gy nn nk l nl nm">var john = new Person('John');<br/>john.printName();               /<strong class="mh iu">/ Hi! My name is John</strong><br/>var jane = new Person('Jane');<br/>jane.printName();               <strong class="mh iu">// Hi! My name is Jane</strong></span></pre><p id="5252" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的问题是，对于每个新的<code class="fe me mf mg mh b">Person</code>实例，都会创建一个新的<code class="fe me mf mg mh b">printName</code>副本，它存在于实例中，浪费了不必要的内存。我们真的不需要在每次创建一个实例时都有一个新的<code class="fe me mf mg mh b">printName</code>副本，因为它是恒定的，并且在所有实例中表现相同。为了解决这个问题，我们使用了<code class="fe me mf mg mh b">prototype</code>关键字。</p><blockquote class="mz na nb"><p id="3154" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated">JavaScript中的所有函数默认都有一个<code class="fe me mf mg mh b"><em class="it">prototype</em></code>属性，其值是一个对象。如果一个函数被用作函数构造器，那么所有使用该函数创建的对象都可以访问该函数的原型对象。</p></blockquote><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="15ce" class="lg lh it mh b gy nj nk l nl nm">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="da0e" class="lg lh it mh b gy nn nk l nl nm">Person.prototype.printName = function() {<br/>  console.log('Hi! My name is ' + this.name);<br/>}</span><span id="e8ae" class="lg lh it mh b gy nn nk l nl nm">var john = new Person('John');<br/>john.printName();               <strong class="mh iu">// Hi! My name is John</strong><br/>var jane = new Person('Jane');<br/>jane.printName();               <strong class="mh iu">// Hi! My name is Jane</strong></span></pre><p id="8811" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，<code class="fe me mf mg mh b">printName</code>在定义<code class="fe me mf mg mh b">Person</code> <br/>时只在内存中创建一次，它存在于<code class="fe me mf mg mh b">Person.prototype</code>上。除了节省内存之外，向<code class="fe me mf mg mh b">prototype</code>添加方法和变量的另一个很大的好处是，无论我们何时向<code class="fe me mf mg mh b">prototype</code>添加任何东西，所有创建的实例都可以立即访问它，而不管它们是何时创建的。例如:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="4875" class="lg lh it mh b gy nj nk l nl nm">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="fe36" class="lg lh it mh b gy nn nk l nl nm">var person = new Person('John');</span><span id="33c3" class="lg lh it mh b gy nn nk l nl nm">Person.prototype.printName = function() {<br/>  console.log('Hi! My name is ' + this.name);<br/>}</span><span id="c60f" class="lg lh it mh b gy nn nk l nl nm">person.printName();       <strong class="mh iu">// Hi! My name is John</strong></span></pre><p id="c91e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在上面的例子中没有使用<code class="fe me mf mg mh b">prototype</code>而直接在<code class="fe me mf mg mh b">Person</code>上定义了<code class="fe me mf mg mh b">printName</code>，那么<code class="fe me mf mg mh b">person</code>对象将无法访问<code class="fe me mf mg mh b">printName</code>，因为<code class="fe me mf mg mh b">person</code>是在<code class="fe me mf mg mh b">printName</code>被添加到<code class="fe me mf mg mh b">Person</code>之前被实例化的。通常，我们并不知道在定义类的时候需要添加到类中的所有方法/常量。<code class="fe me mf mg mh b">prototype</code> <br/>使我们能够在以后向一个类中添加内容，并使这些内容在所有实例中可用——即使它们是在过去创建的。</p><h2 id="8f10" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">原型链</h2><p id="a314" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">当我们调用<code class="fe me mf mg mh b">person.printName</code>时，<code class="fe me mf mg mh b">printName</code>并不直接存在于<code class="fe me mf mg mh b">person</code>上。那么，JavaScript是怎么知道它会存在于<code class="fe me mf mg mh b">Person.prototype</code>上的呢？<code class="fe me mf mg mh b">person</code>上一定有<em class="ko">的东西</em>告诉它使用<code class="fe me mf mg mh b">Person.prototype.printName</code>。那东西就是<code class="fe me mf mg mh b">__proto__</code>属性。</p><blockquote class="mz na nb"><p id="76d6" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated">JavaScript中的所有对象都有一个名为“dunder proto”的<code class="fe me mf mg mh b"><em class="it">__proto__</em></code>属性，通常表示为<code class="fe me mf mg mh b"><em class="it">[[Prototype]]</em></code>，它包含对创建对象的类的<code class="fe me mf mg mh b"><em class="it">prototype</em></code>的引用。</p></blockquote><p id="5746" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，当我们做<code class="fe me mf mg mh b">person.printName</code>时，实际发生的是JavaScript首先检查<code class="fe me mf mg mh b">printName</code>是否直接存在于<code class="fe me mf mg mh b">person</code>上。它没有，所以使用<code class="fe me mf mg mh b">person.__proto__</code>来访问找到<code class="fe me mf mg mh b">printName</code>的<code class="fe me mf mg mh b">Person</code>的<code class="fe me mf mg mh b">prototype</code>。下面是<code class="fe me mf mg mh b">person.__proto__</code>的样子:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi on"><img src="../Images/324c42b7bd7668711ce8a61daedcb77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*imfqsyb0SrLdsSNJIRlBEg.png"/></div></figure><p id="41b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe me mf mg mh b">Person</code>的原型上没有<code class="fe me mf mg mh b">printName</code>会怎样？如果是这种情况，那么<code class="fe me mf mg mh b">Person.prototype.__proto__</code>将被查询，以此类推。这种顺序的自底向上查找来评估对象的属性被称为<em class="ko">原型链接</em>。</p><p id="698a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还记得我们在关于<code class="fe me mf mg mh b">constructor</code>关键词的部分做了<code class="fe me mf mg mh b">person.constructor</code>吗？<code class="fe me mf mg mh b">constructor</code>是否直接存在于<code class="fe me mf mg mh b">person</code>上？答案是否定的。<code class="fe me mf mg mh b">person.constructor</code>实际上指的是<code class="fe me mf mg mh b">Person.prototype.constructor</code>。我们已经知道，无论何时创建一个函数，它都有一个默认的包含原型对象的属性。默认情况下，这个原型对象的<code class="fe me mf mg mh b">constructor</code>属性也设置为函数本身，这样每当我们引用使用该函数创建的任何对象上的<code class="fe me mf mg mh b">constructor</code>时，都可以使用它。</p><p id="9fcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，这个原型链有多高呢？JavaScript中的所有类都继承自<code class="fe me mf mg mh b">Object</code>类。每当我们查找一个对象的属性时，<code class="fe me mf mg mh b">Object.prototype</code>就是查找过程的范围。换句话说:</p><blockquote class="mz na nb"><p id="620e" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated"><code class="fe me mf mg mh b"><em class="it">Object</em></code>是Javascript中所有类的基类，因此<code class="fe me mf mg mh b"><em class="it">Object.prototype</em></code>是原型链的根<em class="it"> </em>。</p></blockquote><p id="d44d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果那份财产甚至在<code class="fe me mf mg mh b">Object.prototype</code>上都不存在，那么它就被视为不存在。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="72ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看一个我们大多数人都用过的原型链接的简单实例:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="8a39" class="lg lh it mh b gy nj nk l nl nm">var arr = new Array(1, 2, 3);<br/>arr.forEach(function(item) {<br/>  console.log(item);<br/>});</span></pre><p id="6def" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当执行<code class="fe me mf mg mh b">arr.forEach</code>时，JavaScript首先检查<code class="fe me mf mg mh b">forEach</code>是否直接存在于<code class="fe me mf mg mh b">arr</code>上。它没有，所以它在内部检查<code class="fe me mf mg mh b">arr.__proto__</code>，因为<code class="fe me mf mg mh b">Array</code>是<code class="fe me mf mg mh b">arr</code>的函数构造器，所以它指向<code class="fe me mf mg mh b">Array.prototype</code>。它在那里找到<code class="fe me mf mg mh b">forEach</code>并调用它。<code class="fe me mf mg mh b">toString</code>是遍历原型链后发现的另一个方法的例子。它住在<code class="fe me mf mg mh b">Object.prototype</code>。</p><p id="0483" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong><code class="fe me mf mg mh b">__proto__</code>属性不应该被覆盖，因为它会破坏原型链。它也不应该用于读取值，因为访问它非常慢。你可以在这里详细了解<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/The_performance_hazards_of__%5B%5BPrototype%5D%5D_mutation" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="ae4d" class="mi lh it bd li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv mw mx lx my bi translated">创建子类</h1><p id="ea06" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">子类是这样一个类，它从另一个类继承属性，但也有自己的唯一属性，这些属性覆盖父类的属性或不存在于父类中。让我们创建第一个子类:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="a881" class="lg lh it mh b gy nj nk l nl nm"><strong class="mh iu">// base class</strong><br/>function Loader(isLoading) {<br/>  this.isLoading = isLoading;<br/>}</span><span id="452f" class="lg lh it mh b gy nn nk l nl nm">Loader.prototype.showLoader = function() {<br/>  console.log('loader visible!');<br/>}</span><span id="e3f2" class="lg lh it mh b gy nn nk l nl nm">Loader.prototype.hideLoader = function() {<br/>  console.log('loader hidden');<br/>}</span><span id="fc9e" class="lg lh it mh b gy nn nk l nl nm"><strong class="mh iu">// subclass</strong><br/>function ProgressBarLoader(isLoading, loadedPercent) {<br/>  Loader.call(this, isLoading);<br/>  this.loadedPercent = loadedPercent || 0;<br/>}</span><span id="0ac0" class="lg lh it mh b gy nn nk l nl nm">ProgressBarLoader.prototype = Object.create(Loader.prototype);<br/>ProgressBarLoader.prototype.constructor = ProgressBarLoader;</span><span id="9c6b" class="lg lh it mh b gy nn nk l nl nm">ProgressBarLoader.prototype.showLoadedPercent = function() {<br/>  console.log('progress %: ', this.loadedPercent);<br/>}</span><span id="8f47" class="lg lh it mh b gy nn nk l nl nm">ProgressBarLoader.prototype.setPercent = function(percent) {<br/>  this.loadedPercent = percent;<br/>}</span><span id="b611" class="lg lh it mh b gy nn nk l nl nm">var progressBarLoader = new ProgressBarLoader(false, 0);<br/>progressBarLoader.showLoader();         <strong class="mh iu">// loader visible</strong><br/>progressBarLoader.hideLoader();         <strong class="mh iu">// loader hidden</strong> <br/>progressBarLoader.showLoadedPercent();  <strong class="mh iu">// progress %: 0</strong></span></pre><p id="5b86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里发生了很多事情。让我们逐一检查它们:</p><h2 id="d2ca" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">呼叫</h2><blockquote class="mz na nb"><p id="ad8b" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated"><code class="fe me mf mg mh b"><em class="it">call</em></code>是一个函数，它帮助我们调用一个带有参数的方法，并将其<code class="fe me mf mg mh b"><em class="it">this</em></code>上下文设置为一个显式指定的对象。该对象作为<code class="fe me mf mg mh b"><em class="it">call</em></code>的第一个参数传入。</p></blockquote><p id="91cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们创建一个<code class="fe me mf mg mh b">ProgressBarLoader</code>对象时，<code class="fe me mf mg mh b">Loader</code>在我们的<code class="fe me mf mg mh b">ProgressBarLoader</code>对象的上下文中被调用，属性<code class="fe me mf mg mh b">isLoading</code>被添加到该对象中。这样，<code class="fe me mf mg mh b">Loader</code>的属性被添加(或者，<em class="ko">继承，借用</em>)到任何使用<code class="fe me mf mg mh b">ProgressBarLoader</code>创建的实例中。这里需要注意的一点是，这些属性和方法是在类的实例化时添加的，而不是在定义时添加的。</p><p id="1466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在执行完<code class="fe me mf mg mh b">call</code>语句后，将<code class="fe me mf mg mh b">loadedPercent</code>属性添加到对象中，该属性是<code class="fe me mf mg mh b">ProgressBarLoader</code>独有的。</p><p id="a6cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>需要注意的是<code class="fe me mf mg mh b">call</code>语句应该是子类中的第一条语句，以避免父类中同名的属性覆盖子类中的属性。</p><h2 id="8b1e" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">从子类调用父方法</h2><p id="d2c6" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">考虑一个例子，其中具有父子关系的两个类具有相同的方法名，但是相同方法的不同实现:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="1c57" class="lg lh it mh b gy nj nk l nl nm">function Parent() {<br/>}</span><span id="5551" class="lg lh it mh b gy nn nk l nl nm">Parent.prototype.printMe = function() {<br/>  console.log('This is parent class!');<br/>}</span><span id="31d4" class="lg lh it mh b gy nn nk l nl nm">function Child() {<br/>  Parent.call(this);<br/>}</span><span id="90ab" class="lg lh it mh b gy nn nk l nl nm">Child.prototype.printMe = function() {<br/>  console.log('This is child class!');<br/>}</span><span id="6959" class="lg lh it mh b gy nn nk l nl nm">var child = new Child();<br/>child.printMe();        <strong class="mh iu">// This is child class!</strong></span></pre><p id="87ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当在一个<code class="fe me mf mg mh b">Child</code>对象上调用<code class="fe me mf mg mh b">printMe</code>时，调用<code class="fe me mf mg mh b">Child.prototype.printMe</code>。如果我们想在一个<code class="fe me mf mg mh b">Child</code>对象上调用<code class="fe me mf mg mh b">Parent</code>的<code class="fe me mf mg mh b">printMe</code>呢？我们可以通过使用<code class="fe me mf mg mh b">call</code>来实现这一点:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="5543" class="lg lh it mh b gy nj nk l nl nm">Parent.prototype.printMe.call(child);   <strong class="mh iu">// This is parent class!</strong></span></pre><p id="4977" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们直接调用<code class="fe me mf mg mh b">Parent.prototype.printMe</code>。但是它是使用<code class="fe me mf mg mh b">call</code>调用的，这帮助我们告诉JavaScript<code class="fe me mf mg mh b">printMe</code>必须在<code class="fe me mf mg mh b">Child</code>对象的上下文中调用。</p><p id="a4be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是可行的，但是不方便每次我们想调用父类的方法时都编写<code class="fe me mf mg mh b">Parent.prototype.printMe.call</code>。为了解决这个问题，让我们给<code class="fe me mf mg mh b">Child</code>添加一个方法，提供一个方便的API来调用<code class="fe me mf mg mh b">Parent</code>的<code class="fe me mf mg mh b">printMe</code>:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="da68" class="lg lh it mh b gy nj nk l nl nm">Child.prototype.printParentMe = function() {<br/>  Parent.prototype.printMe.call(this);<br/>}</span><span id="3730" class="lg lh it mh b gy nn nk l nl nm">var child = new Child();<br/>child.printParentMe();      <strong class="mh iu">// This is parent class!</strong></span></pre><h2 id="f973" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">对象.创建</h2><blockquote class="mz na nb"><p id="fbaa" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated"><code class="fe me mf mg mh b"><em class="it">Object.create</em></code>从现有对象创建一个新对象，该新对象可以访问现有对象的属性。</p></blockquote><p id="b9fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="cd5c" class="lg lh it mh b gy nj nk l nl nm">var loader = {<br/>   showLoader: function() {<br/>     console.log('loader is visible!');<br/>   },<br/>   hideLoader: function() {<br/>     console.log('loader is hidden!');<br/>   }<br/>};</span><span id="cf3f" class="lg lh it mh b gy nn nk l nl nm">var progressBarLoader = Object.create(Loader);</span><span id="f309" class="lg lh it mh b gy nn nk l nl nm">progressBarLoader.showLoader();    <strong class="mh iu">// loader is visible!</strong><br/>progressBarLoader.hideLoader();    <strong class="mh iu">// loader is hidden!</strong></span></pre><p id="ecbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，<code class="fe me mf mg mh b">Object.create</code>在引擎盖下做什么呢？它是从<code class="fe me mf mg mh b">loader</code>复制所有内容并添加到<code class="fe me mf mg mh b">progressBarLoader</code>吗？不是。是把<code class="fe me mf mg mh b">progressBarLoader</code>的<code class="fe me mf mg mh b">__proto__</code>设置成<code class="fe me mf mg mh b">loader</code>！</p><p id="dc5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们调用<code class="fe me mf mg mh b">progressBarLoader.showLoader</code>时，JavaScript检查<code class="fe me mf mg mh b">progressBarLoader</code>上是否存在<code class="fe me mf mg mh b">showLoader</code>。它没有，所以它使用<code class="fe me mf mg mh b">progressBarLoader</code>的<code class="fe me mf mg mh b">__proto__</code>沿着原型链向上，找到那里的方法并调用它。</p><p id="712b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在子类示例中，<code class="fe me mf mg mh b">Object.create</code>的用法如下:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="bbff" class="lg lh it mh b gy nj nk l nl nm">ProgressBarLoader.prototype = Object.create(Loader.prototype);</span></pre><p id="3893" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如果没有这条语句会发生什么:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oo"><img src="../Images/fa3be1ece47a8deeb2f6014dff803413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNnRSKSrTWPuJ__U7ExVTA.png"/></div></div></figure><p id="1849" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当调用<code class="fe me mf mg mh b">progressBarLoader.showLoader</code>时，JavaScript首先检查<code class="fe me mf mg mh b">progressBarLoader</code>上的方法。它没有在那里找到它，而是在<code class="fe me mf mg mh b">progressBarLoader</code>的原型上检查它。现在，<code class="fe me mf mg mh b">progressBarLoader</code>的原型是什么？它的<code class="fe me mf mg mh b">ProgressBarLoader</code>和<code class="fe me mf mg mh b">showLoader</code>在它的原型上不存在。因此，我们使用<code class="fe me mf mg mh b">Object.create</code>将<code class="fe me mf mg mh b">Loader.prototype</code>添加到<code class="fe me mf mg mh b">progressBarLoader</code>的<code class="fe me mf mg mh b">__proto__</code>中。它看起来是这样的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b57732398878c69b499e2a2d05e8dae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*j2CPwE2Efn13wuuYsb_XZw.png"/></div></figure><p id="62ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以在不影响使用<code class="fe me mf mg mh b">Object.create</code>添加的<code class="fe me mf mg mh b">Loader.prototype</code>方法的情况下向<code class="fe me mf mg mh b">ProgressBarLoader.prototype</code>添加内容:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="0041" class="lg lh it mh b gy nj nk l nl nm">ProgressBarLoader.prototype.showLoadedPercent = function() {<br/>  console.log('progress %: ', this.loadedPercent);<br/>}</span><span id="726b" class="lg lh it mh b gy nn nk l nl nm">ProgressBarLoader.prototype.setPercent = function(percent) {<br/>  this.loadedPercent = percent;<br/>}</span></pre><h2 id="b15a" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">子类.原型.构造函数</h2><p id="f2c5" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">让我们来理解一下的意义:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="d960" class="lg lh it mh b gy nj nk l nl nm">ProgressBarLoader.prototype.constructor = ProgressBarLoader;</span></pre><p id="5bfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设在我们的例子中没有这个语句。<code class="fe me mf mg mh b">ProgressBarLoader.prototype.constructor</code>会指向什么？通常，当我们创建一个函数时，比如说<code class="fe me mf mg mh b">fn</code>，那么<code class="fe me mf mg mh b">fn.prototype.constructor</code>就会指向<code class="fe me mf mg mh b">fn</code>本身。但是<code class="fe me mf mg mh b">ProgressBarLoader.prototype.constructor</code>指向<code class="fe me mf mg mh b">Loader</code>是因为在语句中:</p><pre class="kq kr ks kt gt nf mh ng nh aw ni bi"><span id="ec0a" class="lg lh it mh b gy nj nk l nl nm">ProgressBarLoader.prototype = Object.create(Loader.prototype);</span></pre><p id="074d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们设置<code class="fe me mf mg mh b">ProgressBarLoader.prototype</code>为参考<code class="fe me mf mg mh b">Loader.prototype</code>，<code class="fe me mf mg mh b">Loader.prototype.constructor</code>为<code class="fe me mf mg mh b">Loader</code>！为什么这是一个问题？这个<a class="ae lf" href="https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>线程完美的解释了这一点。因此，我们将<code class="fe me mf mg mh b">ProgressBarLoader.prototype.constructor</code>设置为<code class="fe me mf mg mh b">ProgressBarLoader</code>。</p><p id="3a57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>因为<code class="fe me mf mg mh b">ProgressBarLoader</code>被认为是<code class="fe me mf mg mh b">Loader</code>的子类，所以可以假设<code class="fe me mf mg mh b">ProgressBarLoader.constructor</code>将等于<code class="fe me mf mg mh b">Loader</code>。然而，事实并非如此。还是和<code class="fe me mf mg mh b">Loader</code>一样等于<code class="fe me mf mg mh b">Function</code>。这是因为，如我们所知，<code class="fe me mf mg mh b">constructor</code>属性指向<em class="ko">函数</em> <em class="ko">构造函数</em>，而<code class="fe me mf mg mh b">ProgressBarLoader</code>的函数构造函数仍然是<code class="fe me mf mg mh b">Function</code>。</p><p id="0e3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在JavaScript中:</p><blockquote class="mz na nb"><p id="b23f" class="jq jr ko js b jt ju jv jw jx jy jz ka nc kc kd ke nd kg kh ki ne kk kl km kn im bi translated">创建子类只是借用基类的方法和属性。</p></blockquote><p id="2909" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在两个类之间只创建了一个<em class="ko">原型链接</em>，其他都没有改变。这与许多面向对象编程语言不同，在面向对象编程语言中，基类和子类之间有更严格的继承关系。</p><h2 id="2f1e" class="lg lh it bd li lj lk dn ll lm ln dp lo kb lp lq lr kf ls lt lu kj lv lw lx ly bi translated">“原型”一词的用法</h2><p id="fd06" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">每当有人在句子中使用“原型”这个词时，它可能有两种意思——关键字<code class="fe me mf mg mh b">prototype</code>或<code class="fe me mf mg mh b">__proto__</code>。要弄清楚这两个词指的是哪一个，就要理解它的使用环境。如果我们在谈论一个函数，那么“原型”指的是<code class="fe me mf mg mh b">prototype</code>关键字。如果讨论的主体是一个客体，那么‘原型’就是指<code class="fe me mf mg mh b">__proto__</code>。</p><h1 id="7ddb" class="mi lh it bd li mj mk ml ll mm mn mo lo mp mq mr lr ms mt mu lu mv mw mx lx my bi translated">结束了！</h1><p id="717f" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">首先，感谢您花时间阅读这篇文章！</p><p id="3afc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们今天讨论的概念很复杂，通常需要时间来掌握，尤其是对于刚开始使用JavaScript的人。所以如果你仍然对他们没有100%的信心，不要担心！很正常。这不是你的错。要接近100，可能需要从多种来源进行多次阅读——以及编写JavaScript代码的一些实际经验。</p><p id="1e56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有任何问题或反馈，请在评论中提出！如果你觉得这篇文章对你有所帮助，请鼓掌以示感谢！😄</p></div></div>    
</body>
</html>