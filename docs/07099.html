<html>
<head>
<title>k0s: Kubernetes in a Single Binary</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k0s:单个二进制中的Kubernetes</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/k0s-kubernetes-in-a-single-binary-224bb43f4520?source=collection_archive---------7-----------------------#2020-12-07">https://betterprogramming.pub/k0s-kubernetes-in-a-single-binary-224bb43f4520?source=collection_archive---------7-----------------------#2020-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1bc6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这种新的Kubernetes分布的初步研究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2216ca0fb33de312157cbcfcb1c79070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TIVX-JBq7-H9oNxh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="17e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔥更新:自从撰写本文以来，k0s已经增加了许多附加特性。请查看<a class="ae ky" href="https://itnext.io/k0s-multi-node-cluster-with-k0sctl-922fc2cb4dc8" rel="noopener ugc nofollow" target="_blank">这篇新文章</a>，它详细介绍了单节点或多节点k0s集群的简单设置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="661c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几天前，一个朋友告诉我关于<a class="mc md ep" href="https://medium.com/u/fedcaa2e9074?source=post_page-----224bb43f4520--------------------------------" rel="noopener" target="_blank"> Mirantis </a>名为<a class="ae ky" href="https://k0sproject.io" rel="noopener ugc nofollow" target="_blank"> k0s </a>的新Kubernetes发行版。我们都知道并热爱K8s，对吧？我们也屈服于<a class="ae ky" href="https://k3s.io" rel="noopener ugc nofollow" target="_blank"> K3s </a>，这是由<a class="mc md ep" href="https://medium.com/u/bd97d20d9140?source=post_page-----224bb43f4520--------------------------------" rel="noopener" target="_blank"> Rancher Labs </a>制造的轻型Kubernetes，不久前捐赠给了<a class="ae ky" href="https://cncf.io" rel="noopener ugc nofollow" target="_blank"> CNCF </a>。现在是时候发现一个新的分布:<a class="ae ky" href="https://k0sproject.io" rel="noopener ugc nofollow" target="_blank"> k0s </a>。</p><p id="c268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简要介绍k0s之后，我们将按照以下步骤设置一个三节点集群:</p><ul class=""><li id="8f70" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">配置三台虚拟机(<a class="ae ky" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank">多路</a>运行中)</li><li id="7566" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">在每个服务器上安装k0s</li><li id="725a" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">设置简单的k0s集群配置文件</li><li id="d796" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">正在初始化集群</li><li id="4f54" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">访问集群</li><li id="34ae" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">添加工作节点</li><li id="6607" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">添加用户</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="485d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">k0s是什么？</h1><p id="40ee" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">k0s是一个全新的Kubernetes发行版。当前版本是0.8.0。2020年12月出版；整个项目的第一次提交是在2020年6月。</p><p id="9391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">k0s作为单个二进制文件提供，不依赖于任何操作系统。因此，它被定义为零摩擦/零深度/零成本库伯内特分布。</p><p id="1241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最新k0s版本:</p><ul class=""><li id="84a0" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">提供经过认证的(CIS基准)Kubernetes 1.19</li><li id="f798" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">使用<a class="ae ky" href="https://containerd.io" rel="noopener ugc nofollow" target="_blank">容器id</a>作为默认的容器运行时</li><li id="7373" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">支持英特尔(x86-64)和ARM (ARM64)架构</li><li id="b1c4" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">使用集群内<a class="ae ky" href="https://etcd.io" rel="noopener ugc nofollow" target="_blank"> etcd </a></li><li id="3b91" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">默认情况下使用<a class="ae ky" href="https://www.projectcalico.org/" rel="noopener ugc nofollow" target="_blank"> Calico </a>网络插件(从而启用网络策略)</li><li id="fcfb" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">启用Pod安全策略准入控制器</li><li id="f668" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">使用带有<a class="ae ky" href="https://coredns.io" rel="noopener ugc nofollow" target="_blank">核心DNS </a>的DNS</li><li id="ac9b" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">通过<a class="ae ky" href="https://github.com/kubernetes-sigs/metrics-server" rel="noopener ugc nofollow" target="_blank">指标服务器</a>公开集群指标</li><li id="054b" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">允许使用水平窗格自动缩放(HPA)</li></ul><p id="efae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">未来的版本中将会推出许多出色的功能，其中包括:</p><ul class=""><li id="f3d9" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">微虚拟机运行时(真的很期待测试这个)</li><li id="50a4" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">零停机集群升级</li><li id="f17d" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">集群备份和恢复</li></ul><p id="42d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很漂亮，对吧？我们现在将看到如何使用k0s来部署一个三节点集群。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="87ac" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">调配虚拟机</h1><p id="c44b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">首先，我们将创建三个虚拟机；每个都将是我们集群中的一个节点。在本文中，我将选择快速简单的方法，使用强大的<a class="ae ky" href="https://multipass.run" rel="noopener ugc nofollow" target="_blank"> Multipass </a>(非常喜欢这个工具)在MacOS上配置本地虚拟机。</p><p id="5885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下命令在xhyve上创建了三个Ubuntu实例。每个虚拟机有5 GB磁盘、2 GB内存和2个虚拟CPU:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="12f1" class="nu mt it nq b gy nv nw l nx ny">for i in 1 2 3; do <br/>  multipass launch -n node$i -c 2 -m 2G<br/>done</span></pre><p id="cdfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以列出虚拟机，以确保它们都运行良好:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b4ad" class="nu mt it nq b gy nv nw l nx ny"><strong class="nq iu">$ multipass list</strong><br/>Name      State       IPv4             Image<br/>node1     Running     192.168.64.11    Ubuntu 20.04 LTS<br/>node2     Running     192.168.64.12    Ubuntu 20.04 LTS<br/>node3     Running     192.168.64.13    Ubuntu 20.04 LTS</span></pre><p id="b753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面，我们将在每个节点上安装k0s。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a5bd" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">获取最新的k0s版本</h1><p id="3bb5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">最新的k0s版本可以从<a class="ae ky" href="https://github.com/k0sproject/k0s/releases/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>下载。</p><p id="a33e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个方便的安装脚本:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="5eb6" class="nu mt it nq b gy nv nw l nx ny">curl -sSLf get.k0s.sh | sudo sh</span></pre><p id="7944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用它在所有节点上安装k0s:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="7a46" class="nu mt it nq b gy nv nw l nx ny">for i in 1 2 3; do<!-- --> <br/>  multipass exec node$i -- bash -c "<!-- -->curl -sSLf get.k0s.sh | sudo sh"<br/>done</span></pre><p id="3b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本在<code class="fe nz oa ob nq b">/usr/bin/k0s</code>中安装k0s。我们可以通过不带任何参数地运行二进制文件来获得所有可用的命令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/4a8c8fe97146ee0ff253294ce35bacc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jp3MRxk1-ldH7v6IeAZDDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">k0s可用命令</p></figure><p id="bfb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以查看当前版本:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e8fe" class="nu mt it nq b gy nv nw l nx ny">$ k0s version<br/>v0.8.0</span></pre><p id="0a40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在下面的步骤中使用其中的一些命令。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="526d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">创建配置文件</h1><p id="090a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">首先，我们必须定义一个包含k0s创建集群所需信息的配置文件。从<code class="fe nz oa ob nq b">node1</code>我们可以使用<code class="fe nz oa ob nq b">default-config </code>命令来获得完整的默认配置。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e1d0" class="nu mt it nq b gy nv nw l nx ny"><strong class="nq iu">ubuntu@node1:~$ k0s default-config<br/></strong>apiVersion: k0s.k0sproject.io/v1beta1<br/>kind: Cluster<br/>metadata:<br/>  name: k0s<br/>spec:<br/>  api:<br/>    address: 192.168.64.11<br/>    sans:<br/>    - 192.168.64.11<br/>    - 192.168.64.11<br/>    extraArgs: {}<br/>  controllerManager:<br/>    extraArgs: {}<br/>  scheduler:<br/>    extraArgs: {}<br/>  storage:<br/>    type: etcd<br/>    kine: null<br/>    etcd:<br/>      peerAddress: 192.168.64.11<br/>  network:<br/>    podCIDR: 10.244.0.0/16<br/>    serviceCIDR: 10.96.0.0/12<br/>    provider: calico<br/>    calico:<br/>      mode: vxlan<br/>      vxlanPort: 4789<br/>      vxlanVNI: 4096<br/>      mtu: 1450<br/>      wireguard: false<br/>  podSecurityPolicy:<br/>    defaultPolicy: 00-k0s-privileged<br/>  workerProfiles: []<br/>extensions: null<br/>images:<br/>  konnectivity:<br/>    image: us.gcr.io/k8s-artifacts-prod/kas-network-proxy/proxy-agent<br/>    version: v0.0.13<br/>  metricsserver:<br/>    image: gcr.io/k8s-staging-metrics-server/metrics-server<br/>    version: v0.3.7<br/>  kubeproxy:<br/>    image: k8s.gcr.io/kube-proxy<br/>    version: v1.19.4<br/>  coredns:<br/>    image: docker.io/coredns/coredns<br/>    version: 1.7.0<br/>  calico:<br/>    cni:<br/>      image: calico/cni<br/>      version: v3.16.2<br/>    flexvolume:<br/>      image: calico/pod2daemon-flexvol<br/>      version: v3.16.2<br/>    node:<br/>      image: calico/node<br/>      version: v3.16.2<br/>    kubecontrollers:<br/>      image: calico/kube-controllers<br/>      version: v3.16.2<br/>  repository: ""<br/>telemetry:<br/>  interval: 10m0s<br/>  enabled: true</span></pre><p id="e4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它允许我们定义，除了别的以外:</p><ul class=""><li id="4a7e" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">API服务器、控制器管理器和调度程序的启动选项</li><li id="ca8f" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">可用于保存集群信息的存储器(<a class="ae ky" href="https://etcd.io" rel="noopener ugc nofollow" target="_blank"> etcd </a>)</li><li id="33e4" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">网络插件及其配置(<a class="ae ky" href="https://www.projectcalico.org/" rel="noopener ugc nofollow" target="_blank"> Calico </a>)</li><li id="beea" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">控制平面组件的容器图像的版本</li><li id="c3a8" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">启动集群时应该部署的一些附加舵图</li></ul><p id="9c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将这个配置保存到一个文件中，并根据我们的需要进行修改。在本文中，我们将使用一个非常简单的配置，并将其保存在<code class="fe nz oa ob nq b">/etc/k0s/k0s.yaml</code> <em class="od">中。</em></p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2183" class="nu mt it nq b gy nv nw l nx ny">apiVersion: k0s.k0sproject.io/v1beta1<br/>kind: Cluster<br/>metadata:<br/>  name: k0s<br/>spec:<br/>  api:<br/>    address: 192.168.64.11<br/>    sans:<br/>    - 192.168.64.11<br/>  network:<br/>    podCIDR: 10.244.0.0/16<br/>    serviceCIDR: 10.96.0.0/12</span></pre><p id="e17b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>因为我们将在<code class="fe nz oa ob nq b">node1</code>初始化集群，这个节点将是服务于API服务器的节点。该节点的IP地址用于上述配置文件中的<code class="fe nz oa ob nq b">api.address</code>和<code class="fe nz oa ob nq b">api.sans</code> <em class="od"> </em>(主题别名)。如果我们有额外的主节点和一个负载平衡器，我们将在<code class="fe nz oa ob nq b">api.sans</code>设置中使用每个节点的IP地址和一个负载平衡器(或相关的域名)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b4f2" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">集群的初始化</h1><p id="a10f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">首先，在<code class="fe nz oa ob nq b">node1</code>上，我们创建一个systemd <code class="fe nz oa ob nq b">Unit</code>文件来管理k0s。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9048" class="nu mt it nq b gy nv nw l nx ny">[Unit]<br/>Description="k0s server"<br/>After=network-online.target<br/>Wants=network-online.target<br/> <br/>[Service]<br/>Type=simple<br/>ExecStart=/usr/bin/k0s server -c /etc/k0s/k0s.yaml --enable-worker<br/>Restart=always</span></pre><p id="6627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的主命令是在<code class="fe nz oa ob nq b">ExecStart</code>中指定的命令；它运行k0s服务器，提供我们在上一步中创建的配置文件。我们还指定了<code class="fe nz oa ob nq b">--enable-worker</code>选项，因此第一个主节点也作为一个工作节点。</p><p id="6c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将这个文件复制到<code class="fe nz oa ob nq b">/lib/systemd/system/k0s.service</code>，重新加载systemd，并启动我们新创建的服务</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cf4c" class="nu mt it nq b gy nv nw l nx ny">ubuntu@node1:~$ sudo systemctl daemon-reload</span><span id="a4aa" class="nu mt it nq b gy oe nw l nx ny">ubuntu@node1:~$ sudo systemctl start k0s.service</span></pre><p id="59b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于好奇，我们可以检查k0s服务器启动的进程:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="04c1" class="nu mt it nq b gy nv nw l nx ny"><strong class="nq iu">ubuntu@node1:~$ sudo ps aux | awk ‘{print $11}’ | grep k0s<br/></strong>/usr/bin/k0s<br/>/var/lib/k0s/bin/etcd<br/>/var/lib/k0s/bin/konnectivity-server<br/>/var/lib/k0s/bin/kube-controller-manager<br/>/var/lib/k0s/bin/kube-scheduler<br/>/var/lib/k0s/bin/kube-apiserver<br/>/var/lib/k0s/bin/containerd<br/>/var/lib/k0s/bin/kubelet</span></pre><p id="eec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的输出中，我们可以看到所有主组件都在运行(<code class="fe nz oa ob nq b">kube-apiserver</code>、<code class="fe nz oa ob nq b">kube-controller-manager</code>、<code class="fe nz oa ob nq b">kube-scheduler</code>等)。)以及师傅和工人通用的部件(<code class="fe nz oa ob nq b">containerd</code>、<code class="fe nz oa ob nq b">kubelet</code>)。k0s负责管理全部。</p><p id="4afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了一个单节点集群。在下一步中，我们将看到如何访问它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a84a" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">访问集群</h1><p id="bf11" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">首先，我们需要获得集群创建期间生成的<code class="fe nz oa ob nq b">kubeconfig</code>文件；那个是在<code class="fe nz oa ob nq b">/var/lib/k0s/pki/admin.conf</code>的<code class="fe nz oa ob nq b">node1</code>上创建的。我们需要使用该文件在您的本地机器上配置<a class="ae ky" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>。</p><p id="6209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从<code class="fe nz oa ob nq b">node1</code>中获得集群的<code class="fe nz oa ob nq b">kubeconfig</code>:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="eeb0" class="nu mt it nq b gy nv nw l nx ny"># Get kubeconfig file<br/>$ multipass exec node1 cat /var/lib/k0s/pki/admin.conf &gt; k0s.cfg</span></pre><p id="e182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们用<code class="fe nz oa ob nq b">node1</code>的外部IP地址替换内部IP地址:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cff1" class="nu mt it nq b gy nv nw l nx ny"># Replace IP address<br/>$ NODE1_IP=$(multipass info node1 | grep IP | awk '{print $2}')<br/>sed -i '' "s/localhost/$NODE1_IP/" k0s.cfg</span></pre><p id="b98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们配置本地kubectl客户机与k0s API服务器通信:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9aa1" class="nu mt it nq b gy nv nw l nx ny">export KUBECONFIG=$PWD/k0s.cfg</span></pre><p id="087f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在访问新集群时运行的第一个命令可能是列出所有可用节点的命令，让我们试试:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="60a1" class="nu mt it nq b gy nv nw l nx ny"><strong class="nq iu">$ kubectl get no</strong><br/>NAME    STATUS   ROLES    AGE   VERSION<br/>node1   Ready    &lt;none&gt;   78s   v1.19.4</span></pre><p id="cc81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不奇怪。<code class="fe nz oa ob nq b">node1</code>是我们的第一个集群的主节点，但是由于我们在启动命令中指定的<em class="od"> </em> <code class="fe nz oa ob nq b">--enable-worker</code>标志，它也是一个工作者节点。如果没有那个标志，<code class="fe nz oa ob nq b">node1</code>将只是一个工人，不会出现在这里的节点列表中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="61fd" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">添加工作节点</h1><p id="9f01" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了将<code class="fe nz oa ob nq b">node2</code>和<code class="fe nz oa ob nq b">node3</code>添加到我们的集群中，我们首先需要从<code class="fe nz oa ob nq b">node1</code>创建一个join令牌(这一步很常见，因为它用在用kubeadm创建的Docker Swarm和Kubernetes集群中)。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9e5f" class="nu mt it nq b gy nv nw l nx ny">$ TOKEN=$(k0s token create --role=worker)</span></pre><p id="138d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令生成一个长(非常长)的令牌。使用它，我们可以将<code class="fe nz oa ob nq b">node2</code>和<code class="fe nz oa ob nq b">node3</code>加入我们的集群:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ad9d" class="nu mt it nq b gy nv nw l nx ny">ubuntu@node2:~$ k0s worker $TOKEN</span><span id="9102" class="nu mt it nq b gy oe nw l nx ny">ubuntu@node3:~$ k0s worker $TOKEN</span></pre><p id="49a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在一个真实的集群中，我们将使用systemd(或另一个supervisor)来管理工作节点的k0s进程，就像我们对主节点所做的那样。</p><p id="06f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的三节点集群现在已经启动并运行，我们可以通过再次列出节点来看到这一点:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="4321" class="nu mt it nq b gy nv nw l nx ny"><strong class="nq iu">$ kubectl get no<br/></strong>NAME    STATUS  ROLES    AGE   VERSION<br/>node1   Ready   &lt;none&gt;   30m   v1.19.4<br/>node2   Ready   &lt;none&gt;   35s   v1.19.4<br/>node3   Ready   &lt;none&gt;   32s   v1.19.4</span></pre><p id="dcb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以检查跨所有名称空间运行的pod:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/19f4e3b9ce7a9ff1a2aea2a2ffa04c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1V0hLmoT_zcGe-3OS1UtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跨所有命名空间在集群中运行的pod列表</p></figure><p id="c315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意一些事情:</p><ul class=""><li id="49f6" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">像往常一样，我们可以看到<code class="fe nz oa ob nq b">kube-proxy</code>豆荚，网络插件(基于Calico)，以及一个核心域名豆荚</li><li id="c048" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><code class="fe nz oa ob nq b">api-server</code>、<code class="fe nz oa ob nq b">scheduler</code>和<code class="fe nz oa ob nq b">controller-manager</code>窗格没有出现在此列表中，因为它们作为常规进程运行，不在窗格内</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a4f2" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">添加用户</h1><p id="fc05" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">k0s 0 . 8 . 0版本带来了<code class="fe nz oa ob nq b">user</code>子命令。它允许我们为额外的用户/组创建一个<code class="fe nz oa ob nq b">kubeconfig</code>。例如，下面的命令创建名为<code class="fe nz oa ob nq b">demo</code>的新用户的<code class="fe nz oa ob nq b">kubeconfig</code>文件，该文件位于名为<code class="fe nz oa ob nq b">development</code>的虚拟组中。</p><p id="ec68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在Kubernetes中，用户和组由集群外的管理员管理，这意味着K8s中没有用户-非组资源。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="f465" class="nu mt it nq b gy nv nw l nx ny">$ sudo k0s user create demo --groups development &gt; demo.kubeconfig</span></pre><p id="55d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解，我们将从这个<code class="fe nz oa ob nq b">kubeconfig</code>文件中提取客户端的证书，并从其base64表示中对其进行解码:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="ba34" class="nu mt it nq b gy nv nw l nx ny">$ cat demo.kubeconfig | grep client-certificate-data | awk '{print $2}' | base64 --decode &gt; demo.crt</span></pre><p id="ad02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用一个<code class="fe nz oa ob nq b">openssl</code>命令来获取该证书的内容:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="594f" class="nu mt it nq b gy nv nw l nx ny"><strong class="nq iu">ubuntu@node1:~$ openssl x509 -in demo.crt -noout -text<br/></strong>Certificate:<br/>    Data:<br/>        Version: 3 (0x2)<br/>        Serial Number:<br/>            71:8b:a4:4d:be:76:70:8a:...:07:60:67:c1:2d:51:94<br/>        Signature Algorithm: sha256WithRSAEncryption<br/>        <strong class="nq iu">Issuer: CN = kubernetes-ca</strong><br/>        Validity<br/>            Not Before: Dec  2 13:50:00 2020 GMT<br/>            Not After : Dec  2 13:50:00 2021 GMT<br/>        <strong class="nq iu">Subject: O = development, CN = demo</strong><br/>        Subject Public Key Info:<br/>            Public Key Algorithm: rsaEncryption<br/>                RSA Public-Key: (2048 bit)<br/>                Modulus:<br/>                    00:be:87:dd:15:46:91:98:eb:b8:38:34:77:a4:99:<br/>                    da:4b:d6:ca:09:92:f3:29:28:2d:db:7a:0b:9f:91:<br/>                    65:f3:11:bb:6c:88:b1:8f:46:6e:38:71:97:b7:b5:<br/>                    9b:8d:32:86:1f:0b:f8:4e:57:4f:1c:5f:9f:c5:ee:<br/>                    40:23:80:99:a1:77:30:a3:46:c1:5b:3e:1c:fa:5c:</span></pre><ul class=""><li id="5de2" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated"><code class="fe nz oa ob nq b">issuer</code>属性是<code class="fe nz oa ob nq b">kubernetes-ca</code>，是我们k0s集群的认证机构</li><li id="4174" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><code class="fe nz oa ob nq b">Subject</code>是<code class="fe nz oa ob nq b">O = development, CN = demo</code>；这一部分很重要，因为这是用户名和用户组出现的地方。因为证书是由集群的CA签署的，<code class="fe nz oa ob nq b">api-server</code>中的一个插件能够根据证书主题中的通用名称(CN)和组织(O)来认证用户/组。</li></ul><p id="74e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们告诉kubectl使用这个新的<code class="fe nz oa ob nq b">kubeconfig</code>文件中定义的上下文:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b1a8" class="nu mt it nq b gy nv nw l nx ny">$ export KUBECONFIG=$PWD/demo.kubeconfig</span></pre><p id="37b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们再次列出集群的节点:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="09da" class="nu mt it nq b gy nv nw l nx ny"><strong class="nq iu">$ kubectl get no<br/></strong>Error from server (Forbidden): nodes is forbidden: User “demo” cannot list resource “nodes” in API group “” at the cluster scope</span></pre><p id="7b46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此错误消息是意料之中的。即使用户已经通过了<code class="fe nz oa ob nq b">api-server</code>的认证(与用户请求一起发送的证书已经由集群证书颁发机构签名)，他们也无权在集群中执行任何操作。</p><p id="c2ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过创建<code class="fe nz oa ob nq b">Role</code> / <code class="fe nz oa ob nq b">ClusterRole</code>可以很容易地添加额外的权限，并通过<code class="fe nz oa ob nq b">RoleBinding</code> / <code class="fe nz oa ob nq b">ClusterRoleBinding</code>绑定到用户，但我将此作为读者的练习。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce93" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="ccd9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">k0s绝对值得一看。用一个二进制文件来管理所有的进程是一个非常有趣的方法。</p><p id="23a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们只是快速浏览了一下k0s，但是我会确保跟踪它的发展，并在以后的文章中专门介绍这个新的、有前途的Kubernetes发行版。一些未来的功能看起来很有前途，我真的很期待测试它们。</p></div></div>    
</body>
</html>