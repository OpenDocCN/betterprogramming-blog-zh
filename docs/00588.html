<html>
<head>
<title>The Reduce ({…Spread}) Anti-Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Reduce ({…Spread})反模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-reduce-spread-anti-pattern-fc0c1c0b23f6?source=collection_archive---------3-----------------------#2019-06-15">https://betterprogramming.pub/the-reduce-spread-anti-pattern-fc0c1c0b23f6?source=collection_archive---------3-----------------------#2019-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4048" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速了解发动机内部</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7da1dd0de5363b90d112d36ee844391b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_XZk-_lcA1XNpP4mKqTICw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@wezlar11" rel="noopener ugc nofollow" target="_blank">迪安·普</a>在<a class="ae kv" href="https://unsplash.com/photos/C8NDn4xk9zs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fe7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">性能是计算中的一个常见话题，但在前端领域尤其常见，因为最新的Javascript技术正在争夺前端的宝座。有些人可能会说<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>已经赢了，使用数字似乎也是如此。因此，在这篇文章中，我想谈谈我在前端世界中更频繁看到的一段有问题的代码，因为Javascript语法正在发展，组件正在取而代之。</p><p id="a76e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能遇到过这样的情况，您想要将一组对象贴图合并成一个单独的对象。以下是该问题的两种常见解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然后一个<code class="fe lu lv lw lx b">for loop</code>可能更容易阅读，但前一个<code class="fe lu lv lw lx b">reduce </code>很好。随着React社区越来越多地采用更加函数化的编程风格，T2变得越来越常见，通常避免迭代语句，而支持函数表达式，函数表达式可以很容易地内联到组件中。我个人两个都喜欢。</p><p id="408b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不太喜欢这种最新出现的风格:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些不熟悉对象文字中<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">展开语法(</a> <code class="fe lu lv lw lx b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">...</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">)的人来说，它的行为与</a><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"> Object.assign </a>非常相似。您可以使用它来迭代源对象的属性，以将它们复制到目标对象中。在这种情况下，我们复制到一个新创建的对象。你能看出问题吗？我指的不是对象初始化，这只是一个小问题。</p><p id="05c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">隐藏迭代！当<code class="fe lu lv lw lx b">Array#Map</code>和工作人员更新时，经常看到编码人员过度使用它们，经常是连续地，多次地使用相同的数据集。现在，随着spread operator进入蜜月期，开发人员开始尝试新的、令人兴奋的编程模式；一些好的(<code class="fe lu lv lw lx b">...</code>对于配置对象来说很棒)，一些不好的。</p><p id="d059" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，当审查包含<code class="fe lu lv lw lx b">reduce...spread</code>的代码时，spread操作符的神奇性质有些麻烦。当试图说服人们因为嵌套循环而避免这种模式时，我经常会遇到“<em class="ly">什么循环？”</em>、<em class="ly">过早优化！"</em>，或者<em class="ly">“那就是突变！”</em>因此，下面，我们将快速深入引擎内部，找出缺失的循环，讨论优化和计算复杂性，最后讨论函数式编程。</p><h2 id="dcc0" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">快速了解Javascript引擎</h2><p id="1929" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当Javascript代码在类似浏览器的东西中遇到时，该代码的执行由Javascript引擎处理。有好几个引擎存在，但是我们要具体说一下Chrome和Node的默认引擎:<a class="ae kv" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> v8 </a>。v8发动机如何工作是一个复杂的话题，但这个<a class="ae kv" href="https://www.youtube.com/watch?time_continue=3&amp;v=p-iiEDtpy6I" rel="noopener ugc nofollow" target="_blank">精彩的演示</a>涵盖了基本知识。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/e95faceed78c2222edba96f1762b65d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6r9RfMmb3humUU2U.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="my"> V8的编译器管道—归功于</em><a class="ae kv" href="https://twitter.com/fhinkel" rel="noopener ugc nofollow" target="_blank"><em class="my">@ fhinkel</em></a></p></figure><p id="30fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，有三个组件构成v8引擎执行的编译层:解析器，它生成一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树(AST)</a>；一个解释器，它生成<a class="ae kv" href="https://en.wikipedia.org/wiki/Bytecode" rel="noopener ugc nofollow" target="_blank">字节码</a>；以及一个优化的编译器，生成<a class="ae kv" href="https://en.wikipedia.org/wiki/Machine_code" rel="noopener ugc nofollow" target="_blank">机器码</a>。</p><p id="28f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些都是在运行时(而不是在一个单独的编译步骤中)在一个称为<a class="ae kv" href="https://en.wikipedia.org/wiki/Just-in-time_compilation" rel="noopener ugc nofollow" target="_blank">实时(JIT) </a>编译的过程中执行的。</p><p id="0829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过查看v8的解释器生成的字节码，<a class="ae kv" href="https://v8.dev/docs/ignition" rel="noopener ugc nofollow" target="_blank"> Ignition </a>，我们可以更准确地了解我们的Javascript代码实际上在做什么。</p><p id="5079" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的字节码是从<code class="fe lu lv lw lx b">reduce ...spread</code>生成的，重要的位用粗体表示。</p><pre class="kg kh ki kj gt mz lx na nb aw nc bi"><span id="ef95" class="lz ma iq lx b gy nd ne l nf ng">// bytecode<br/>StackCheck<br/><strong class="lx ir">CreateObjectLiteral [0], [0], #41, r0</strong><br/>Mov r0, r1<br/>Mov a0, r2<br/><strong class="lx ir">CallRuntime [CopyDataProperties], r1-r2</strong><br/>LdaNamedProperty a1, [1], [1]<br/>ToName r1<br/>LdaNamedProperty a1, [2], [3]<br/>StaDataPropertyInLiteral r0, r1, #0, [5]<br/>Ldar r0<br/>Return</span><span id="8c50" class="lz ma iq lx b gy nh ne l nf ng">// builtin code generation<br/>SetOrCopyDataProperties( /* … */ ) {<br/> // …<br/> <strong class="lx ir">ForEachEnumerableOwnProperty(</strong><br/> context, source_map, CAST(source), kEnumerationOrder,<br/> [=](TNode&lt;Name&gt; key, TNode&lt;Object&gt; value) {<br/> <strong class="lx ir">CallBuiltin(Builtins::kSetPropertyInLiteral</strong>, context, target, key, value);<br/> },<br/> if_runtime);<br/> // …<br/>}</span></pre><p id="a7a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字节码将生成进行运行时调用的代码，该代码映射到用我们正在寻找的循环生成的内联内建。我想我们毕竟是在执行嵌套迭代…</p><h2 id="59d6" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">决定我们的计算复杂度</h2><p id="19dd" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">讨论一段代码的复杂性需要了解该代码在运行时将使用的资源量。具体来说，当比较我们的<code class="fe lu lv lw lx b">reduce mutate</code>解决方案和<code class="fe lu lv lw lx b">reduce ...spread</code>时，我们将讨论它们各自的<a class="ae kv" href="https://en.wikipedia.org/wiki/Time_complexity" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>；换句话说，在给定输入大小的情况下，每个解决方案需要运行多长时间。这些时间近似值通常用<a class="ae kv" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大𝑂符号</a>表示，例如:𝑂(1表示<a class="ae kv" href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time" rel="noopener ugc nofollow" target="_blank">常数时间</a>，或者𝑂(n表示<a class="ae kv" href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time" rel="noopener ugc nofollow" target="_blank">线性时间</a>。</p><p id="f396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算迭代一组大小为<code class="fe lu lv lw lx b">n</code>的数据(在我们的例子中为<code class="fe lu lv lw lx b">reduce</code>)的代码的时间复杂度，需要找到我们在解决方案中关心的常数时间操作，并确定该操作将执行多少次。</p><p id="e186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我们来说，我们感兴趣的基本操作是将数据插入到我们的对象中，<a class="ae kv" href="https://en.wikipedia.org/wiki/Associative_array#Comparison" rel="noopener ugc nofollow" target="_blank">，这通常是一个恒定时间的操作</a>。我们可以看到这在一个解决方案中用Javascript和<code class="fe lu lv lw lx b">acc[item.name] = item.value;</code>表示，在另一个解决方案中用<code class="fe lu lv lw lx b">Builtins::kSetPropertyInLiteral</code>生成的机器码表示。这些代码路径可能有不同的实现这一事实并不重要。重要的是它们都是常数时间。</p><p id="730f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在<code class="fe lu lv lw lx b">reduce mutate</code>中看到，对于reduce的每次迭代，我们的基本操作只发生一次。换句话说，对于大小为<code class="fe lu lv lw lx b">n</code>的输入数组，它发生了<code class="fe lu lv lw lx b">n</code>次，因此我们可以将其归类为线性时间:𝑂(n).</p><p id="8856" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用<code class="fe lu lv lw lx b">reduce...spread</code>，它实际上执行一些其他操作。具体来说，它执行一个新对象文字的创建，然后再次迭代(在本例中是嵌套迭代，因为它在我们之前的迭代中)现有的属性键，然后为每个<em class="ly">嵌套</em>迭代执行我们的基本操作。</p><p id="5366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的基地行动进行了多少次了？嗯，这很复杂。它不会精确地执行内部循环<code class="fe lu lv lw lx b">n</code>次，因为内部循环受到它需要复制的密钥数量的限制。然而，就我们的目的而言，说它在执行<code class="fe lu lv lw lx b">n * n</code>的同一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Computational_complexity_theory" rel="noopener ugc nofollow" target="_blank">类</a>解决方案中就足够了，或者n^2时报，称之为𝑂(n^2)，因为随着<code class="fe lu lv lw lx b">n</code>趋向于无穷大，它无论如何都会向那个方向发展。但是，为了更准确的描述，我们可以记为<a class="ae kv" href="https://cs.stackexchange.com/a/4608" rel="noopener ugc nofollow" target="_blank">𝜃(𝑛^2)≡𝑂(𝑛^2)</a>。</p><p id="c836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ly">注意:</em> </strong> <em class="ly">以上假设在你的目标对象中没有生成重复的键。对于我见过的大多数将对象数组映射到对象key- &gt;值的例子来说，这是正确的，我认为这是一个合理的假设。然而，在有些情况下，这显然是不正确的，比如专门用于计算重复项的解决方案(想想字数)。在那些情况下，使用</em> <code class="fe lu lv lw lx b"><em class="ly">reduce...spread</em></code> <em class="ly">模式仍然会被归类为𝑂(𝑛^2(因为大o符号是上界的近似值)。但是通过考虑最佳情况(所有副本)和一般情况的复杂性，实际运行时间可能会得到更准确的反映。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/984c02f9622833e553324238b40a9411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ip2309w-Fv3M8Nx.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="my">功劳归于</em> <a class="ae kv" href="https://commons.wikimedia.org/w/index.php?curid=50321072" rel="noopener ugc nofollow" target="_blank"> <em class="my"> Cmglee —自己的工作，抄送BY-SA 4.0 </em> </a></p></figure><p id="e760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在提供的图表中看到不同的算法分类对于不同的输入大小是如何执行的。类分组代表不同算法的可比较的运行时特征。例如，两个不同的𝑂(n算法可能具有不同的执行时间，但是随着它们所操作的输入大小的增长，它们的运行时间将彼此相当地增长。理解代码通常如何执行有助于为我们试图解决的问题编写适当的解决方案。它还可以帮助我们了解代码的某些性能特征，甚至不用运行它！</p><p id="7c8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，我们的一个解决方案是𝑂(n的，另一个是𝑂(n2)…的。这真的很糟糕吗？担心这个不就是优化过早的一个案例吗？优化编译器不会拯救我们吗？嗯，看我们的信息图表似乎表明，𝑂(n)和𝑂(n2)有非常不同的性能特征。让我们看看它们在实际的基准测试中表现如何。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/3e0bf75e2663ff0ddd299673b7ee51f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmEJrzho0nO3mEMl-eHq-Q.png"/></div></div></figure><p id="5656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这些测试中包含了我们讨论的两个解决方案，<code class="fe lu lv lw lx b">reduce mutate</code>和<code class="fe lu lv lw lx b">reduce...spread</code>。我还加入了一些额外的基准，包括上面提到的<code class="fe lu lv lw lx b">for..of</code>，以及一些使用不可变数据结构的解决方案，这些都是我们后面讨论函数式编程时用到的。您可以在这里<a class="ae kv" href="https://gist.github.com/snapwich/7604b2d827f320e470a07e088e0293f3" rel="noopener ugc nofollow" target="_blank">看到用于运行这些基准测试的代码</a>。</p><p id="c0b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一点可以立即注意到，当涉及少量物品时，<code class="fe lu lv lw lx b">reduce mutate</code>和<code class="fe lu lv lw lx b">for..of</code>比竞争对手快得多。为什么会这样，我不太清楚。我认为这可能与优化器有关，但我无法通过基准预热(以确保我们所有结果中的JIT优化)或限制测试周期来使峰值正常化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/a1b5a24069ee1b76508ba408a62ef5ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yoNMRSGLXfUCVnYxBbY1aA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/459ba3eae9498f01b9014f7d7d92bd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrIh4ZPdZZZTdEv-3NrQ5w.png"/></div></div></figure><p id="3db4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，这并不是非常重要，因为我们在这里是为了看看不同的时间复杂度对我们的代码意味着什么。当我们查看上图中的<code class="fe lu lv lw lx b">ops/s relative to: reduce spread O(n^2)</code>并观察它与其他解决方案的长期对比时，就能发现真正的问题。然后我们再看<code class="fe lu lv lw lx b">ops/s relative to: for..of 𝑂(n)</code>，看看对比如何。</p><p id="f5c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看出区别了吗？如果我们将任何一个𝑂(n)解决方案与其他解决方案进行比较，我们会发现它们的性能基本上是其他𝑂(n)解决方案的几倍。例子:点击<code class="fe lu lv lw lx b">for..of 𝑂(n)</code>会显示<code class="fe lu lv lw lx b">reduce mutate 𝑂(n)</code>是四分之三的速度，但是不管我们的数据集有多大，它几乎总是四分之三的速度。然而，如果我们点击<code class="fe lu lv lw lx b">reduce...spread 𝑂(n^2)</code>并将其与<code class="fe lu lv lw lx b">reduce mutate 𝑂(n)</code>进行比较，首先它慢了20倍，然后是40倍，然后是80倍。增长速度越来越慢了！这是个坏消息。</p><p id="b68d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"/></p><p id="bbc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我之所以认为<code class="fe lu lv lw lx b">reduce...spread</code>是一种反模式，是因为它越来越受欢迎，同时还有不明显的性能问题。不明显，因为大多数人认为将一个对象数组直接映射到相似数量的对象属性需要线性工作量:10个项目需要大约10分钟，20个项目需要大约20分钟，等等。然而，事实并非如此。如果你遵循这样一个合理的假设，这个东西会很快杀死你的应用程序的性能。</p><p id="35f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ly">我们应该忘记小的效率，比如说97%的时候:过早的优化是万恶之源。然而，我们不应该错过这关键的3%的机会。</em></p><p id="942b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ly"> —唐纳德·克努特</em></p><p id="bafc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们大多数人都听说过这句话的一部分，但通常不是全部。有<em class="ly">有</em>这种过早优化的东西，然而这不是。如果有的话，我认为<code class="fe lu lv lw lx b">reduce...spread</code>是一个过早的去优化。</p><p id="14a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过早优化是指选择使用我的基准测试中提供的最快的𝑂(n)解决方案，而不是其他𝑂(n)解决方案<em class="ly">，因为它是最快的</em>。从性能角度来看，您选择哪个𝑂(n)解决方案可能无关紧要；您完全有可能在不同的Javascript引擎中看到不同的结果，v8优化编译器的进步可能会在明天改变这些结果。</p><p id="74ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe lu lv lw lx b">reduce...spread</code>和它的𝑂(n2时间来说也是如此吗？大概不会。这里有一个关于<a class="ae kv" href="https://en.wikipedia.org/wiki/Optimizing_compiler" rel="noopener ugc nofollow" target="_blank">优化编译器</a>的相关点(重点后加):</p><blockquote class="nm nn no"><p id="359c" class="kw kx ly ky b kz la jr lb lc ld ju le np lg lh li nq lk ll lm nr lo lp lq lr ij bi translated">优化编译器关注相对较浅的常数因子性能改善，通常不会改善解决方案的算法复杂度。例如，编译器不会将冒泡排序的实现改为使用合并排序。</p></blockquote><p id="5798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这并不是说它不能被优化。显然可以，因为我们利用突变做到了。但是，看看我们的基准测试，很明显，它目前没有优化，也不太可能会优化。<em class="ly">如果你感兴趣的话，你可以在</em> <a class="ae kv" href="https://twitter.com/bmeurer/status/1137025197557669888" rel="noopener ugc nofollow" target="_blank"> <em class="ly">这条推文</em> </a> <em class="ly">上看到一些关于这个确切模式的讨论，要求对对象文字内部的传播进行潜在的优化。</em></p><h2 id="d6bd" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">功能纯度</h2><p id="d51e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">最后，让我们谈一谈函数式编程。我听到的支持<code class="fe lu lv lw lx b">reduce...spread</code>的最后一个论点是出于<a class="ae kv" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">函数纯度</a>的原因，因为我们的reduce函数改变了它的一个参数(累加器)，这是不好的。但是在这种情况下，我们通过避免突变来防止什么潜在的错误呢？</p><p id="8b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再来看一下代码，这次关注的是一个重要的部分。</p><pre class="kg kh ki kj gt mz lx na nb aw nc bi"><span id="17cb" class="lz ma iq lx b gy nd ne l nf ng">let result = items.reduce((acc, item) =&gt; ({<br/>  ...acc, [item.name]: item.value<br/>}), <strong class="lx ir">{}</strong>) // see this initial value?</span></pre><p id="68e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们避免变异的对象是我们创建的引用<em class="ly">。</em>换句话说，改变这个参数并不危险，担心改变它实际上是一种过早去优化的情况。</p><p id="1d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的棉绒在抱怨吗？如果是这样的话，这就是为什么棉绒赋予我们忽略某些线条的能力。棉绒有助于提醒我们潜在的权衡，但在这种情况下(用我们新发现的智慧)，我们可以<a class="ae kv" href="https://twitter.com/dan_abramov/status/1136897691441553409" rel="noopener ugc nofollow" target="_blank">决定忽略它，避免潜在的陷阱</a>。您也可以使用for循环来代替，并完全避免reduce(和林挺错误)。</p><p id="917f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想将<code class="fe lu lv lw lx b">reduce mutate</code>代码一般化，以便在您可能正在处理不属于您的数据的情况下工作，我建议要么在迭代之前制作该数据<em class="ly">的副本，要么使用不可变的数据结构，因为这是它们被创建的目的。</em></p><p id="88b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://gist.github.com/snapwich/7604b2d827f320e470a07e088e0293f3" rel="noopener ugc nofollow" target="_blank">在基准</a>中，我已经包括了一些使用<code class="fe lu lv lw lx b"><a class="ae kv" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank">immutable.js</a></code>和不使用突变的例子(没错，一个不可变的库为数据突变提供了帮助)，以及<code class="fe lu lv lw lx b"><a class="ae kv" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank">immer.js</a></code>。不可变数据结构提供了允许破坏性操作的好处，而无需修改您正在操作的原始源对象。他们这样做还有一个额外的好处，就是共享底层数据以防止浪费，就像在<code class="fe lu lv lw lx b">reduce...spread</code>一样。如果你想用不变性来编码，那么我建议使用合适的工具。你可能也会对这个常量值类型的提议感兴趣。</p><h2 id="d880" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">最后</h2><p id="2dcb" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">请在您的代码中避免这种模式！如果您正在审查包含该模式的代码，请随意参考本文。</p></div></div>    
</body>
</html>