<html>
<head>
<title>Async Functions Are Coming to Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift即将推出异步功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-functions-are-coming-to-swift-75993d0cb4e3?source=collection_archive---------1-----------------------#2021-01-02">https://betterprogramming.pub/async-functions-are-coming-to-swift-75993d0cb4e3?source=collection_archive---------1-----------------------#2021-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7177" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你会爱上它们的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eca52457bc4ae9af1aa500b746f2dcdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EmcSleUuYlGwKwjj"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@wesleypribadi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">韦斯利·普里巴迪</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="d0da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老iOS开发者还记得Objective C还不支持块的日子。异步操作是一场噩梦。</p><p id="5746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Blocks改进了异步操作，当Swift出现时，闭包对我们来说已经很自然了。但是为了帮助我们通过异步调用，闭包仍然有其缺陷。</p><p id="8ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，Swift即将推出一项名为async function的新功能，它将使我们的生活变得更加美好。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0aa4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">闭包有什么问题？</h1><p id="82e6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">闭包是好的，真的，多年来为我们提供了很好的服务。但是我们都知道async + closures有它的问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cf0b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">末日金字塔</h1><p id="5c20" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们来看看下面的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="431d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都知道这个例子。它被称为末日金字塔。</p><p id="ecbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然一开始使用几个嵌套闭包似乎是一个优雅的想法，但它仍然会导致一些问题。</p><p id="7314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在处理嵌套闭包时都知道的一个问题是错误处理。看看下面的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="185b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看到对<code class="fe my mz na nb b">completionBlock</code>的调用和之后的返回语句了吗？现在，想象一下你需要为每个闭包都这样做。不仅如此，你也不能忘记返回语句。否则，你可能会遇到一些难以理解的严重问题。</p><p id="e14e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用enum和switch语句会导致更难看、更复杂的代码。甚至不要让我开始抛出函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想这一点现在已经很清楚了。</p><p id="81f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，随着两个最好的伙伴async和await的出现，事情很快就要改变了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bff4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">异步会面并等待</h1><p id="bf65" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Async和await一点都不新鲜。微软拥有这些功能已经很多年了。Net和JavaScript开发人员非常了解这个特性。</p><p id="8043" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就Swift而言，开发人员提议增加这一功能已有近五年时间，最终获得了批准。</p><p id="329e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来是这样的:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="df3a" class="ng ma iq nb b gy nh ni l nj nk">func loadFileFromServer(string : String) async -&gt;Data // this is the async declaration<br/> <br/>let fileData = await loadFileFromServer("myFile") // this is the call.</span></pre><p id="9f79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样？就是这样。</p><p id="89bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在声明函数时，我们在返回值之前添加了单词<code class="fe my mz na nb b">async</code>，在调用函数之前添加了<code class="fe my mz na nb b">await</code>。</p><p id="7131" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对它有些熟悉，那是因为它看起来类似于将函数声明为throwing。</p><p id="47dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看上面带有新的<code class="fe my mz na nb b">async/await</code>机制的代码:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="566a" class="ng ma iq nb b gy nh ni l nj nk">func processImageFromServer(string : String) async -&gt;UIImage {<br/>    let fileData    = await loadFileFromServer(string)<br/>    let imageData   = await analyzFile(fileData)<br/>    let image       = await decodeImage(imageData)<br/>    return image<br/>}</span></pre><p id="b125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是很简单吗？</p><p id="d9f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe my mz na nb b">await</code>挂起当前线程并等待回答。这使得代码更加明显和简单。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bece" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">有些事情听起来很奇怪</h1><p id="90d5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">好了，我们知道我们可以编写看起来和行为都像同步代码的异步代码。</p><p id="be5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是一想起来，有些事情很诡异…</p><p id="f174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们说过我们有一个名为<code class="fe my mz na nb b">await</code>的新操作符来挂起当前线程。</p><p id="f213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用异步操作的一个最流行的用例是不阻塞UI线程。如果UI线程调用了一个异步函数并使用了<code class="fe my mz na nb b">await</code>，这意味着UI线程现在被阻塞了！那么，有什么意义呢？</p><p id="42cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，实际上并不是这样的。</p><p id="8e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，现在有两种功能:</p><ul class=""><li id="960f" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">一个是异步函数，标有<code class="fe my mz na nb b">async</code>。</li><li id="7c84" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated">另一个是调用async函数并包含<code class="fe my mz na nb b">await</code>操作符的函数。这个函数有一个<code class="fe my mz na nb b">@asyncHandler</code>操作符。</li></ul><p id="6ee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">@asyncHandler</code>函数的“主体”被挂起，但是调用<code class="fe my mz na nb b">@asyncHandler</code>函数的函数没有被挂起，而是继续运行，不等待响应。</p><p id="13c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将尝试用代码和图表来解释这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/bf9c16e0e9f0d584c682d7d94e8a9931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dlAIqHL4xaXpa2cq"/></div></div></figure><p id="91b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看它的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a83b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe my mz na nb b">tapped()</code>功能被触发时，控制台中打印消息的顺序如下所示:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="ea4a" class="ng ma iq nb b gy nh ni l nj nk">1</span><span id="16d5" class="ng ma iq nb b gy oa ni l nj nk">2</span><span id="4b4a" class="ng ma iq nb b gy oa ni l nj nk">3</span><span id="dfa5" class="ng ma iq nb b gy oa ni l nj nk">6</span><span id="2167" class="ng ma iq nb b gy oa ni l nj nk">7</span><span id="578c" class="ng ma iq nb b gy oa ni l nj nk">4</span><span id="3f91" class="ng ma iq nb b gy oa ni l nj nk">5</span></pre><p id="9808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对于理解包含<code class="fe my mz na nb b">await</code>关键字的函数很像完成块是至关重要的。当您调用这样的函数时，run循环继续，这样，UI线程就不会被阻塞。</p><p id="bd27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个问题:如果<code class="fe my mz na nb b">@asyncHandler</code>函数返回值怎么办？嗯，这是一个不可能的情况。<code class="fe my mz na nb b">@asyncHandler</code>不能返回值。它们只能是空函数。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="03b3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="0a8c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe my mz na nb b">Async</code>和<code class="fe my mz na nb b">await</code>对Swift开发人员来说是好消息。这是使Swift成为现代语言并简化我们所有人生活的又一步。</p><p id="cad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，由于这是我们习惯的一个重大变化，我们需要准确理解它是如何在引擎盖下工作的。仔细阅读上面的代码片段，充分吸收如何使用它。</p></div></div>    
</body>
</html>