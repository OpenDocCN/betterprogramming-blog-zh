<html>
<head>
<title>How to Finally Understand Generics in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何最终理解TypeScript中的泛型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-generics-90be93d8c292?source=collection_archive---------1-----------------------#2019-05-20">https://betterprogramming.pub/typescript-generics-90be93d8c292?source=collection_archive---------1-----------------------#2019-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="704e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们揭开奇怪的<t>语法的神秘面纱，让它成为我们的朋友而不是敌人</t></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cbd7994f92375ff1be531c1596d03dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eq3CXJ-UeO6zfT8VFLd1Ug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">类型脚本泛型文档的注释图像</a></p></figure><p id="cef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非你是强类型语言(如<a class="ae ky" href="https://en.wikipedia.org/wiki/Generics_in_Java" rel="noopener ugc nofollow" target="_blank"> Java </a>)的老手，否则我肯定你也有同样的“WTF？”当你第一次在TypeScript中看到泛型类型时。该语法与我们在JavaScript中见过的其他语法大相径庭，很难立即直观地看出它在做什么。</p><p id="44c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里告诉你，仿制药并没有看起来那么可怕。如果你能用JavaScript编写一个带参数的函数，那么你很快就能像专家一样编写和使用TypeScript泛型。我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bcf0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是TypeScript中的泛型？</h1><p id="b1fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript文档将泛型解释为“能够创建一个可以在多种类型上工作的组件，而不是一种类型。”</p><p id="d4f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！这给了我们一个基本的想法。我们将使用泛型来创建某种可重用的组件，它可以用于各种类型。但是它是怎么做的呢？我喜欢这样想:</p><p id="d7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">泛型对于类型来说就像值对于函数参数来说一样——它们是一种告诉我们的组件(函数、类或接口)当我们调用它时我们想要使用什么</strong> <code class="fe mz na nb nc b"><strong class="lb iu">type</strong></code> <strong class="lb iu">的方式，就像我们如何告诉一个函数当我们调用它时使用什么值作为参数一样。</strong></p><p id="1122" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解这句话的最好方法是编写一个通用的标识函数。identity函数是一个简单地返回传递给它的任何参数的函数。用普通的JavaScript来说，应该是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="afbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们修改它，使之适用于TypeScript中的一个数字:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很高兴我们现在有了一个类型，但是功能不是很灵活。identity函数应该适用于任何传入的值，而不仅仅是数字。这就是泛型的用武之地。泛型允许我们编写一个可以接受任何类型的函数，并基于该类型转换我们的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="25a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有那个不熟悉的<code class="fe mz na nb nc b">&lt;T&gt;</code>语法！但这没什么可怕的。就像我们传入一个参数一样，我们传入的是我们想要用于特定函数调用的类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0f74cf1d322d655cfbb2487a480c7fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*5GZ39qVIwNGWJUsY1ekZaw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">填充泛型类型就像我们在调用函数时填充函数参数一样。</p></figure><p id="9f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考上图，当我们调用<code class="fe mz na nb nc b">identity&lt;Number&gt;(1)</code>时，<code class="fe mz na nb nc b">Number</code>类型是一个参数，就像<code class="fe mz na nb nc b">1</code>一样。它在值<code class="fe mz na nb nc b">T</code>出现的任何地方填充它。它也可以接受多种类型，就像我们可以有多个参数一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f83dcbb23a2fcbb0eaf231193983d069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v68QEnkC4qbsdcLOrBj47g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个函数可以有多个泛型，就像它可以有多个参数一样。</p></figure><p id="bff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何调用这个函数的。语法现在应该开始对你有意义了！<strong class="lb iu"/><code class="fe mz na nb nc b"><strong class="lb iu">T</strong></code><strong class="lb iu">或者</strong> <code class="fe mz na nb nc b"><strong class="lb iu">U</strong></code> <strong class="lb iu">没有什么特别的，它们只是我们选择的变量名而已。当我们调用函数并且它使用这些类型时，我们用类型值填充它们。</strong></p><p id="f579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种看待泛型的方式是，它们根据传递给函数的数据类型来转换函数。下面的动画展示了identity函数如何随不同的数据类型而变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/a3da0faa536eceb43a3807a2c5c46307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Zz4Y9ScEbGbRrtIWby4msg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个泛型将变形为传递给它的任何“类型”。</p></figure><p id="3843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该函数接受传递给它的任何类型，允许我们为不同类型创建可重用的组件，就像文档承诺的那样。</p><p id="3f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一定要注意动画中的第二条控制台日志语句</strong>。我们不提供类型。在这种情况下，TypeScript将尝试根据数据推断类型。<strong class="lb iu">小心——类型推断只对简单数据有效。如果你传入更复杂的东西比如对象或者多类型数组，它会推断出类型是</strong> <code class="fe mz na nb nc b"><strong class="lb iu">any</strong></code> <strong class="lb iu">，这就分解了我们的类型安全检查。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2d1e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类和接口的泛型和函数的工作方式完全一样</h1><p id="84c5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在知道泛型只是将类型传递给组件的一种方式。我们刚刚看到了函数是如何工作的，好消息是:接口和类的工作方式完全一样！在他们的例子中，我们把类型放在接口名或类名的后面。</p><p id="b4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的代码块对你是否有意义。我希望它会！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d89e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它没有立即对您有意义，尝试沿着函数调用链向上追踪<code class="fe mz na nb nc b">type</code>值。它是这样工作的:</p><ol class=""><li id="d0ec" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">我们实例化了一个新的<code class="fe mz na nb nc b">IdentityClass</code>实例，传入了<code class="fe mz na nb nc b">Number</code>和<code class="fe mz na nb nc b">1</code>。</li><li id="0928" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">在identity类中，<code class="fe mz na nb nc b">T</code>变为<code class="fe mz na nb nc b">Number</code>。</li><li id="9600" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mz na nb nc b">IdentityClass</code>实现<code class="fe mz na nb nc b">GenericInterface&lt;T&gt;</code>并且我们知道<code class="fe mz na nb nc b">T</code>是<code class="fe mz na nb nc b">Number</code>，所以就好像我们在实现<code class="fe mz na nb nc b">GenericInterface&lt;Number&gt;</code></li><li id="1371" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">在<code class="fe mz na nb nc b">GenericInterface</code>中，<code class="fe mz na nb nc b">U</code>变成了<code class="fe mz na nb nc b">Number</code>。我特意在这里使用了不同的变量名，以表明类型值沿着链向上传播，变量名无关紧要。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4810" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实际用例:超越原始类型</h1><p id="a4c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上面提供的所有例子都使用了基本类型，比如<code class="fe mz na nb nc b">Number</code>和<code class="fe mz na nb nc b">string</code>。这些都是很好的例子，但是实际上，你不太可能对基本类型使用泛型。当我们拥有形成继承树的自定义类型或类时，泛型的真正威力就显现出来了。</p><p id="0c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑汽车的经典继承例子。我们有一个基类<code class="fe mz na nb nc b">Car</code>，它被用作<code class="fe mz na nb nc b">Truck</code>和<code class="fe mz na nb nc b">Vespa</code>的基础。然后我们编写一个实用函数<code class="fe mz na nb nc b">washCar</code>，它接受<code class="fe mz na nb nc b">Car</code>的一个通用实例，然后返回它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过告诉我们的洗车函数<code class="fe mz na nb nc b">T</code>必须扩展<code class="fe mz na nb nc b">Car</code>，我们知道我们能够在函数中调用哪些函数和属性。使用泛型还使我们能够返回传入的特定类型，而不仅仅是一个非特定的<code class="fe mz na nb nc b">Car</code>。</p><p id="12a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此代码的输出是:</p><pre class="kj kk kl km gt nw nc nx ny aw nz bi"><span id="217d" class="oa md it nc b gy ob oc l od oe">Received a Vespa in the car wash.<br/>Cleaning all 2 tires.<br/>Beeping horn - beep beep!<br/>Returning your car now</span><span id="d5d9" class="oa md it nc b gy of oc l od oe">Received a Truck in the car wash.<br/>Cleaning all 18 tires.<br/>Beeping horn - beep beep!<br/>Returning your car now</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="711f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="99bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望这篇文章能让你更清楚泛型！请记住，您所做的只是向函数传递一个<code class="fe mz na nb nc b">type</code>值，仅此而已。:)</p><p id="f860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于泛型的知识，请查看下面的链接。</p><p id="752a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">延伸阅读:</strong></p><ul class=""><li id="c0ef" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu og no np nq bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">类型脚本泛型文档</a></li><li id="91a7" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu og no np nq bi translated"><a class="ae ky" href="https://medium.com/@rossbulat/typescript-generics-explained-15c6493b510f" rel="noopener"> TypeScript Generics解释了</a>——比我的快速入门书更深入地了解了泛型。</li></ul></div></div>    
</body>
</html>