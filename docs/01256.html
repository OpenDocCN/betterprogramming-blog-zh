<html>
<head>
<title>Substrate Blockchains and Runtime Modules: An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">衬底区块链和运行时模块:简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/substrate-blockchains-and-runtime-modules-an-introduction-866851b550b9?source=collection_archive---------9-----------------------#2019-08-27">https://betterprogramming.pub/substrate-blockchains-and-runtime-modules-an-introduction-866851b550b9?source=collection_archive---------9-----------------------#2019-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="31d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始开发底层和运行时模块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3ae443f2104e154ec347c21b892605fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WBoRksBR3Kdx6UaLeuplg.jpeg"/></div></div></figure><p id="e80f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近几个月，Parity的<a class="ae lq" href="https://www.parity.io/substrate/" rel="noopener ugc nofollow" target="_blank"> Substrate </a>区块链框架一直在紧锣密鼓地开发，与此同时，基于Substrate本身的<a class="ae lq" href="https://polkadot.network/" rel="noopener ugc nofollow" target="_blank">波尔卡多</a>区块链也在开发。</p><p id="f4d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章旨在介绍如何开始构建定制的衬底链，以支持您自己的运行时模块:</p><ul class=""><li id="a49c" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">我们将进行基底链的安装和设置</li><li id="de6f" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">探索衬底链配置以及如何使用Polkadot JS浏览链状态</li><li id="6d8b" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">花时间介绍运行时模块的结构，这是向链中添加功能的一种方式</li></ul><h1 id="ebc9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">在基底上显影</h1><p id="5ddd" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Substrate和一致的运行时模块是用<a class="ae lq" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>开发的，这是一种静态类型语言，通过其内存安全特性提供速度和可靠性。</p><p id="cb17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个在区块链开发中经常被忽略的主题，但是对于采用来说却是至关重要的:如何处理Rust。我们不会在这篇文章中分析Rust代码，但这将是对Substrate感兴趣的开发者的先决条件。</p><h2 id="b8a2" class="nc mg it bd mh nd ne dn ml nf ng dp mp ld nh ni mr lh nj nk mt ll nl nm mv nn bi translated">新人如何解决生锈问题</h2><p id="8afe" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">对于一门编程语言来说，Rust的学习曲线非常陡峭。这可以归因于它采用的一些语法约定，严重依赖于诸如<em class="no">泛型</em>、<em class="no">特征</em>、<em class="no">生命周期、</em>和<em class="no">宏</em>等特性，以及诸如范围和可变性等其他考虑因素。</p><p id="1ae0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他底层学习资源，如<a class="ae lq" href="https://www.shawntabrizi.com/substrate-collectables-workshop/#/README?id=what-is-this" rel="noopener ugc nofollow" target="_blank">Substrate Kitties</a>collectables workshop，声称Rust很容易掌握，但事实并非如此，除非您在使用低级语言(如C++)方面有一定的经验，接触过处理系统级管理的更细粒度的API。</p><p id="ce99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">具体地说，如果你是第一次生锈，要有耐心。花点时间去理解这种语言提供的概念和特性，并享受这一过程。基板开发将成为一个更愉快的努力。《Rust book》是一个写得很好的演练，既适合语言新手，也适合寻找Rust复习者的有经验用户。</p><p id="42cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问:Rust这本书能让你快速了解Substrate采用的语言特性和概念吗？</p><p id="5d36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，会的，但是我们建议你在通读这本书的时候用你自己的演示来练习，以巩固你的理解。这将使在衬底中编码更加舒适。</p><p id="c0ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住这一点，在进入运行时模块之前，让我们探索一些实际的底层设置和使用。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="83b3" class="mf mg it bd mh mi nw mk ml mm nx mo mp jz ny ka mr kc nz kd mt kf oa kg mv mw bi translated">安装基板</h1><p id="652e" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated"><em class="no">请注意，本安装部分不再是最新的。相反，安装基板时应使</em> <a class="ae lq" href="https://github.com/paritytech/substrate-up" rel="noopener ugc nofollow" target="_blank"> <em class="no">基板朝上</em> </a> <em class="no">。</em></p><p id="46a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装Substrate只需要在<code class="fe ob oc od oe b">getsubstrate.io</code>调用一个由Parity托管的bash脚本。基底有两种包装:</p><h2 id="6877" class="nc mg it bd mh nd ne dn ml nf ng dp mp ld nh ni mr lh nj nk mt ll nl nm mv nn bi translated"><strong class="ak"> 1。快速安装</strong></h2><p id="1d3b" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">更快的基板安装，安装预构建基板开发链，以及<a class="ae lq" href="https://substrate.dev/docs/en/getting-started/using-the-substrate-scripts" rel="noopener ugc nofollow" target="_blank">基板脚本</a>，用于配置定制基板链和运行时模块的命令行实用程序。</p><p id="165a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过与基底安装脚本一起使用的<code class="fe ob oc od oe b">--fast</code>标志运行快速安装实际上跳过了一些非强制运行基底的实用程序的安装:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="20be" class="nc mg it oe b gy oj ok l ol om">curl https://getsubstrate.io -sSf | bash -s -- --fast</span></pre><p id="89d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将获取Substrate需要的所有依赖项，包括Rust、OpenSSL、LLVM等等，如果它们还没有安装，就安装它们。</p><h2 id="097b" class="nc mg it bd mh nd ne dn ml nf ng dp mp ld nh ni mr lh nj nk mt ll nl nm mv nn bi translated">2.完全安装</h2><p id="b27c" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">完整的基底安装会安装上述所有工具，以及另外两个工具:</p><ul class=""><li id="cb2c" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe ob oc od oe b"><a class="ae lq" href="https://github.com/paritytech/substrate/tree/master/subkey" rel="noopener ugc nofollow" target="_blank">Subkey</a></code>:生成或恢复底层密钥的实用程序(用于通过命令行管理账户)</li><li id="9ab5" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe ob oc od oe b"><a class="ae lq" href="https://github.com/paritytech/substrate/tree/master/node" rel="noopener ugc nofollow" target="_blank">Substrate node</a></code>:预先配置好的基板节点，可以连接到基板测试网。</li></ul><p id="54c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行以下程序，安装这些工具以及基底脚本和开发节点:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="6fc0" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu">// full Substrate installation<br/></strong>curl https://getsubstrate.io -sSf | bash</span></pre><p id="d4d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装脚本完成后，更新您的货物环境，以便调用新安装的程序:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="ffe6" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu">// update env (alternatively, reboot your system)<br/></strong>source ~/.cargo/env</span></pre><p id="5846" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在可通过<code class="fe ob oc od oe b">substrate</code>命令访问已编译的衬底节点。为了验证基板和子密钥安装正确，分别检查两个程序<code class="fe ob oc od oe b">substrate</code>和<code class="fe ob oc od oe b">subkey</code>的版本:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="3b05" class="nc mg it oe b gy oj ok l ol om">substrate --version<br/>subkey --version</span></pre><p id="a70f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注意:</em></strong><em class="no">Polkadot JS应用程序(我们将在下面进一步介绍)在其帐户管理UI中实现了subkey——通过在浏览器中管理帐户的选项，一些用户将不需要subkey。这可能是为什么它是一个可选的工具。</em></p><p id="6929" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为Rust编译的二进制文件，底层和实用工具现在默认位于<code class="fe ob oc od oe b">~/.cargo/bin</code>目录中。检查自己安装了什么:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="e0f0" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu">// list installed cargo binaries</strong></span><span id="8a7f" class="nc mg it oe b gy on ok l ol om">cd ~/.cargo/bin<br/>ls</span></pre><p id="ffe4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到，除了<code class="fe ob oc od oe b">substrate</code>和<code class="fe ob oc od oe b">subkey</code>，我们还有<code class="fe ob oc od oe b">substrate-node-new</code>和<code class="fe ob oc od oe b">substrate-module-new</code>二进制文件。我们将进一步使用这些来生成一个新的定制节点和模块。</p><p id="22b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注:</em> </strong> <em class="no">另一个新编译的二进制是</em> <code class="fe ob oc od oe b"><em class="no">substrate-ui-new</em></code> <em class="no">，一个克隆前端React app管理基板链的工具。当我试图运行该应用程序时，这标记了一个错误，因此我们将假设</em><a class="ae lq" href="https://github.com/polkadot-js/apps" rel="noopener ugc nofollow" target="_blank"><em class="no">Polkadot JS/Substrate UI</em></a><em class="no">应用程序—另一个基于Typescript &amp; React的应用程序，旨在配置和管理Substrate和Polkadot区块链—是管理链的首选方法。</em></p><p id="93d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完整的基板安装说明，包括一系列操作系统的说明，可在<a class="ae lq" href="https://substrate.dev/docs/en/getting-started/installing-substrate" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="ba54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里找到更多关于使用子键<a class="ae lq" href="https://github.com/paritytech/substrate/tree/master/subkey" rel="noopener ugc nofollow" target="_blank">的信息</a>。</p><h2 id="bace" class="nc mg it bd mh nd ne dn ml nf ng dp mp ld nh ni mr lh nj nk mt ll nl nm mv nn bi translated">更新底物脚本</h2><p id="f2af" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">更新底层脚本(从<a class="ae lq" href="https://substrate.dev/docs/en/getting-started/using-the-substrate-scripts" rel="noopener ugc nofollow" target="_blank">官方文档</a>中提取)需要克隆最新版本，并用以下命令替换货物二进制文件:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="60e5" class="nc mg it oe b gy oj ok l ol om">f=`mktemp -d` <br/>git clone https://github.com/paritytech/substrate-up $f <br/>cp -a $f/substrate-* ~/.cargo/bin <br/>cp -a $f/polkadot-* ~/.cargo/bin</span></pre><p id="1e84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经安装了所需的基板工具，并随时可以使用。我们现在确实可以通过预先构建的开发节点运行Substrate。该节点将开始生成块，但对于开发目的来说用处不大。</p><p id="8e22" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注:</em> </strong> <em class="no">底层开发人员使用这个预构建的节点，可通过</em> <code class="fe ob oc od oe b"><em class="no">substrate</em></code> <em class="no">路径访问，仅用于开发目的，测试他们的最新构建和玩配置。对于拥有自己的运行时模块和链配置的底层项目，我们将编译一个自定义节点。这需要克隆底层源代码并构建我们的定制节点。我们将进一步讨论这个问题。</em></p><p id="093c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在任何情况下，我们都可以使用以下命令来验证衬底开发链是否正常工作:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="a275" class="nc mg it oe b gy oj ok l ol om">substrate --dev</span></pre><p id="30e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的节点将在终端中运行，块将开始产生。为了查看关于您的链的更多信息，例如每个支持模块的状态，我们将转向Polkadot JS应用程序。</p><p id="276c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于<code class="fe ob oc od oe b">substrate</code>命令行选项的分解，请查看<code class="fe ob oc od oe b">--help</code>输出:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="74d4" class="nc mg it oe b gy oj ok l ol om">substrate --help</span></pre><p id="dad0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们自己熟悉帮助输出是一种久经考验的了解命令行程序能力的方法。这个构建包含了一些对测试有用的标志，比如预先配置的<code class="fe ob oc od oe b">--alice</code>、<code class="fe ob oc od oe b">--bob</code>等账号。<code class="fe ob oc od oe b">--light</code>标志将您的节点作为轻量级客户端运行，框架中内置了轻量级客户端支持。</p><p id="3888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些和其他标志使切换链配置变得简单，主要用于开发目的。</p><p id="fd57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注意:</em> </strong> <em class="no">你甚至可以用你的自定义衬底节点定义你自己的命令行选项。记得更新</em> <code class="fe ob oc od oe b"><em class="no">--help</em></code> <em class="no">输出就行了！Rust拥有丰富的命令行工具，是我个人最喜欢的命令行实用程序开发语言。</em></p><p id="b23a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开始定制构建之前，让我们回顾一下如何检查基底链。如今，这样做的主要手段是通过Polkadot JS应用程序，它是用Typescript和React开发的。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="bcb6" class="mf mg it bd mh mi nw mk ml mm nx mo mp jz ny ka mr kc nz kd mt kf oa kg mv mw bi translated">使用Polkadot JS应用程序</h1><p id="d14a" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Polkadot JS应用程序充当一个基本的链浏览器，并提供API和接口来管理底层模块。顾名思义，它也支持Polkadot链。我们有两个使用Polkadot JS的选项:</p><ul class=""><li id="a370" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">使用平价托管应用，在<a class="ae lq" href="https://polkadot.js.org/apps" rel="noopener ugc nofollow" target="_blank">https://polkadot.js.org/apps</a></li><li id="ec03" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">克隆项目的存储库并在您的机器上本地运行</li></ul><p id="5b1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们克隆项目并在本地运行它。安装后，我们可以将节点端点指向我们的基底链，这将是您机器上的另一个运行进程。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="4e61" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu">// clone and start polkadot.js app</strong></span><span id="d006" class="nc mg it oe b gy on ok l ol om">git clone <a class="ae lq" href="https://github.com/polkadot-js/apps.git" rel="noopener ugc nofollow" target="_blank">https://github.com/polkadot-js/apps.git</a><br/>mv apps polkadot.js<br/>cd polkadot.js &amp;&amp; yarn start</span><span id="3e23" class="nc mg it oe b gy on ok l ol om"><strong class="oe iu">// start substrate dev chain in another terminal window</strong></span><span id="2e5e" class="nc mg it oe b gy on ok l ol om">substrate --dev</span></pre><p id="4cbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行后，在浏览器中转至<code class="fe ob oc od oe b">localhost:3000</code>。要将应用程序连接到本地链，请导航到应用程序侧面菜单中的设置，然后切换到本地节点端点，类似于以下设置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/a827bd1667cba16a7f87c8cb7db5a324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viHYBceQOV_IkIXLm-0hYg.png"/></div></div><p class="op oq gj gh gi or os bd b be z dk translated">Polkadot JS:基板本地节点配置</p></figure><p id="ee72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">点击<code class="fe ob oc od oe b">Save &amp; Reload</code>，你会注意到现在出现了许多其他的侧菜单链接。这些链接将根据您的链支持的功能而有所不同。</p><p id="9ac9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看几乎所有连锁店都会支持的东西——账户。前往应用程序的<code class="fe ob oc od oe b">Accounts</code>部分——你会在“我的账户”标签下看到一个账户列表。这些是预先配置的账户，有预先配置的余额。我们还可以在帐户之间发送资金，删除帐户，备份帐户密钥。这突出了Polkadot JS应用程序的用途——在UI级别与您的底物链进行交互。</p><p id="32b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在继续之前，我们将提到Polkadot UI可以做的一些事情，只是为了突出它的一些功能:</p><ul class=""><li id="0648" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">您可以上传wasm编译的基于<a class="ae lq" href="https://github.com/paritytech/ink" rel="noopener ugc nofollow" target="_blank"> Ink的</a>智能合同，以便与<a class="ae lq" href="https://substrate.dev/rustdocs/v1.0/srml_contract/index.html" rel="noopener ugc nofollow" target="_blank">合同</a>运行时模块一起使用。</li></ul><p id="31d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注:</em> </strong> <em class="no">我写过一篇专门的文章系列，介绍用于承印物的墨迹智能合约语言</em> <a class="ae lq" href="https://medium.com/block-journal/introducing-substrate-smart-contracts-with-ink-d486289e2b59" rel="noopener"> <em class="no">这里</em> </a> <em class="no">。</em></p><ul class=""><li id="5eb1" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">作为一个利益相关共识区块链的证据，赌注部分允许您下注资金，以成为交易的验证者，并支持通过“隐藏帐户”存储这些下注的资金，该帐户可以保持离线，或在冷库中存储这些资金。还可以查看提名验证者、下注奖励——当然，您可以从下注的头寸中提取资金</li><li id="f9b2" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">民主部分旨在处理管理层投票和链的治理</li><li id="f8e1" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">整个Substrate JSON RPC(通过一系列端点从外部联系Substrate的方法)可以在工具箱部分进行测试，而对链的管理更改可以在Sudo部分进行</li></ul><p id="ad79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能想知道这些来自衬底开发链的预配置帐户是从哪里来的，这是理所当然的。这些帐户以及更多内容，包括运行时逻辑本身的编译代码的“blob ”,存储在“链规范”文件中，也称为链规范。</p><h1 id="4dab" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">带有链规范JSON文件的链配置</h1><p id="298a" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">链规范是一个大的JSON对象，通过<code class="fe ob oc od oe b">substrate build-spec</code>命令生成。该命令通过引用节点的导入运行时模块并查找需要定义的公开配置来工作。这些值要么是空值，要么提供了默认值。</p><p id="d014" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本质上，运行时模块可以依赖于“起源配置”，换句话说，当区块链第一次初始化和构造它的状态时，我们提供的配置。这种状态是通过genesis块——链中第一个生成的块——启动的。chain spec JSON文件的工作就是定义这个初始状态。</p><p id="0b59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦生成，在运行节点之前，我们可以打开这个链规范并修改我们认为必要的任何值。</p><p id="4295" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注:</em> </strong> <em class="no">如果我们的链写了我们不再想要的状态怎么办？也许我们已经更新了一个模块，或任何链配置，并希望反映从起源块的变化？我们可以清除链—删除块历史—有效地重置节点。</em></p><p id="8ba9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="no">您的节点为此提供了</em> <code class="fe ob oc od oe b"><em class="no">purge-chain</em></code> <em class="no">命令，常用于开发工作流:</em></p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="c6c4" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu"><em class="no"># optional --dev flag to specify development chain</em></strong><em class="no"><br/>substrate purge-chain --dev</em></span></pre><p id="9656" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，框架还提供了三个默认的链“规范”，即预先填充的配置，它们根据我们是出于测试还是生产目的运行节点来定义一些基本值。</p><p id="f925" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其实默认提供三种规格:<code class="fe ob oc od oe b">dev</code>、<code class="fe ob oc od oe b">local</code>和<code class="fe ob oc od oe b">staging</code>:</p><ul class=""><li id="625a" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><code class="fe ob oc od oe b">dev</code>规范是离真实世界用例最远的规范，主要配置来帮助您使用您的链。为您提供了一系列帐户，并为所有预打包的运行时模块提供了配置</li><li id="1a66" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe ob oc od oe b">local</code>规范类似于<code class="fe ob oc od oe b">dev</code>规范，在<a class="ae lq" href="https://substrate.dev/docs/zh-CN/tutorials/start-a-private-network-with-substrate" rel="noopener ugc nofollow" target="_blank">专网底层教程</a>中使用，由Parity托管。假设您想要在本地测试多用户场景，它给予多个帐户“权限”</li><li id="1400" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe ob oc od oe b">staging</code>是一个更保守的规范，定义了有限数量的帐户，并省略了特定于模块的配置。这是您在构建生产链时会选择的规格。</li></ul><p id="f38d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能做的是用substrate <code class="fe ob oc od oe b">build-spec</code>命令基于这些提供的选项之一构建一个新的chainspec，将结果输出到一个单独的文件。如果我想为我自己的链复制开发链规范，我可以运行下面的命令，将规范输出到我的主目录中的一个新的<code class="fe ob oc od oe b">my-chianspec.json</code>文件中:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="83aa" class="nc mg it oe b gy oj ok l ol om">substrate build-spec --chain=dev &gt; ~/my-chainspec.json</span></pre><p id="8aba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在编辑器中打开该文件，查看可用的配置选项。</p><p id="6511" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注意:</em> </strong> <em class="no">您可能希望折叠</em> <code class="fe ob oc od oe b"><em class="no">genesis.system.runtime</em></code> <em class="no">块，其中包含一个巨大的不可读的运行时blob。</em></p><p id="ec4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以将<code class="fe ob oc od oe b">id</code>字段修改成您自己的名字，还有<code class="fe ob oc od oe b">name</code>字段，这是一个更易于阅读的链规范名称。一些值得注意的常见选项包括:</p><ul class=""><li id="0c49" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">遥测端点:通过<code class="fe ob oc od oe b">telemetryEndpoints</code>为遥测服务提供端点。这将允许你用连接的节点填充一个UI，类似于<a class="ae lq" href="https://telemetry.polkadot.io/" rel="noopener ugc nofollow" target="_blank">波尔卡多特遥测</a>。</li><li id="bea1" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">在你的节点处理本地令牌的情况下，给出初始账户的列表<code class="fe ob oc od oe b">balances</code>。</li><li id="516f" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><code class="fe ob oc od oe b">staking</code>如果您的连锁店支持该功能，请进行配置。配置选项，如初始验证程序帐户、验证程序和存储变量。</li></ul><p id="0a32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终，根据运行时包含的模块，还会有各种其他变量。帮助您熟悉链等级库文件的建议方法是参考主基板节点链等级库。</p><p id="aba1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦您对您的链规范满意了，我们就将它处理成原始的编码状态，带有<code class="fe ob oc od oe b">--raw</code>标志:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="2298" class="nc mg it oe b gy oj ok l ol om">substrate build-spec --chain ~/chainspec.json --raw &gt; ~/mychain.json</span></pre><p id="5f4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，为了运行我们的链，我们提供了具有该链规格的衬底。从这里开始，我们将假设您正在运行一个定制编译的底层节点，在这里我们用该节点的运行时来替换<code class="fe ob oc od oe b">&lt;node_path&gt;</code>。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="9e58" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu">&lt;node_path&gt;</strong> --chain ~/mychain.json --validator</span></pre><p id="8eee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注意:</em> </strong> <em class="no">验证器标志是您的链开始生成块所必需的。</em></p><p id="a476" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来让我们看一下初始化和编译自定义基底节点。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="1460" class="mf mg it bd mh mi nw mk ml mm nx mo mp jz ny ka mr kc nz kd mt kf oa kg mv mw bi translated">初始化你自己的基底节点</h1><p id="74e7" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">到目前为止，我们一直使用通过安装脚本获得的已编译的底层节点。这对于测试开发链来说非常好，但是当引入我们自己的运行时模块和定制配置时，它限制了我们。为此，我们需要下载衬底源代码。</p><p id="a71d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有两种方式开始使用我们自己的定制基材链:</p><ul class=""><li id="328f" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">下载一个容易配置的节点模板(例如在第一部分的完整安装中下载的test-net节点模板，或者特定车间提供的<a class="ae lq" href="https://www.shawntabrizi.com/substrate-collectables-workshop/#/0/running-a-custom-node" rel="noopener ugc nofollow" target="_blank"> Substrate Kitties节点</a>)。</li><li id="2fb9" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">使用底层脚本，下载<a class="ae lq" href="https://github.com/paritytech/substrate/tree/v1.0/node-template" rel="noopener ugc nofollow" target="_blank">官方节点模板</a>，这是一个基本的底层节点脚本，带有一个运行时模板，可供黑客攻击。我们可以使用<a class="ae lq" href="https://substrate.dev/docs/en/getting-started/using-the-substrate-scripts" rel="noopener ugc nofollow" target="_blank">基底脚本</a>来完成这项工作，我们之前也安装了这些脚本。</li></ul><p id="bda6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几乎所有的基板项目都将从正式的节点模板开始，除非您正在进行研讨会或扩展现有的项目。</p><p id="a90d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下内容生成一个新的<a class="ae lq" href="https://github.com/paritytech/substrate/tree/v1.0/node-template" rel="noopener ugc nofollow" target="_blank">节点模板</a>:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="040d" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu">// substrate-node-new &lt;node_name&gt; &lt;author&gt;<br/></strong>substrate-node-new my-node "Ross Bulat"</span></pre><p id="c117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能需要一些时间，具体取决于您的系统—将获取并编译最新的底层源代码。</p><p id="2897" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦完成，节点的运行时将可以通过<code class="fe ob oc od oe b">lib.rs</code>文件在<code class="fe ob oc od oe b">runtime/src</code>文件夹中编辑。还包括一个运行时模块的模板，带有<code class="fe ob oc od oe b">template.rs</code>。接下来我们将看看运行时模块。</p><h2 id="0789" class="nc mg it bd mh nd ne dn ml nf ng dp mp ld nh ni mr lh nj nk mt ll nl nm mv nn bi translated">构建您的自定义节点</h2><p id="4ab2" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在您的节点目录中，用包含的<code class="fe ob oc od oe b">build.sh</code>脚本将您的节点编译成wasm，然后用cargo编译二进制文件:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="c865" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu"># build wasm</strong><br/>./scripts/build.sh</span><span id="0960" class="nc mg it oe b gy on ok l ol om"><strong class="oe iu"># build binary</strong><br/>cargo build --release</span></pre><p id="6055" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的节点现在将被编译到您的节点的<code class="fe ob oc od oe b">./target/release/</code>目录中。</p><p id="3429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们一直使用substrate调用特定于节点的命令，现在我们可以引用新构建的二进制文件，在我们定制的链上运行命令。要清除链并重新运行它，我们可以像这样使用二进制文件:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="aaa0" class="nc mg it oe b gy oj ok l ol om"><strong class="oe iu"># clear chain state</strong><br/>./target/release/&lt;node_name&gt; purge-chain --dev</span><span id="881d" class="nc mg it oe b gy on ok l ol om"><strong class="oe iu"># run in dev mode</strong><br/>./target/release/&lt;node_name&gt; --dev</span></pre><p id="3d1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里介绍的最后一个主题是运行时模块。让我们探讨一下它们是什么，以及如何将它们包含在一个基底节点中。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="f225" class="mf mg it bd mh mi nw mk ml mm nx mo mp jz ny ka mr kc nz kd mt kf oa kg mv mw bi translated">介绍底层运行时模块:插件区块链特性</h1><p id="b13c" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">赋予Substrate实用性的是一种通用的模块化结构，它允许开发人员将功能插入到他们的运行时中，从而创建符合他们需求的定制区块链。</p><p id="a383" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注:</em> </strong> <em class="no">衬底运行时的另一个术语是</em> <a class="ae lq" href="https://substrate.dev/docs/en/overview/glossary#stf-state-transition-function" rel="noopener ugc nofollow" target="_blank"> <em class="no">状态转换函数</em> </a> <em class="no">，或STF。这本质上是一个执行块的函数，导致区块链的状态改变。</em></p><p id="d3ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些功能包被称为模块，或者更具体地说，<a class="ae lq" href="https://substrate.dev/docs/en/runtime/substrate-runtime-module-library" rel="noopener ugc nofollow" target="_blank">运行时模块</a>。这些预装在基板中的运行时模块共同形成了一个模块目录，称为<a class="ae lq" href="https://substrate.dev/docs/en/overview/glossary#srml-substrate-runtime-module-library" rel="noopener ugc nofollow" target="_blank">基板运行时模块库</a>，或SRML。</p><p id="be2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些模块非常有用。它们增加了我们期望从其他区块链框架中获得的一系列功能，并且可以在<a class="ae lq" href="https://github.com/paritytech/substrate/tree/master/srml" rel="noopener ugc nofollow" target="_blank"> Github </a>上浏览。让这些模块随时可用使开发人员不必重新发明轮子和重新实现它们——并且在实现全新功能的地方，它们也可以作为运行时模块来开发。</p><p id="5631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着基板的开发，SRML模块得到了维护，这也使它们变得可靠。可靠性是运行时模块的另一个关键优势——随着它们被采用，维护它们变得更加现实。</p><p id="088e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是目前可用的几个模块:</p><ul class=""><li id="5739" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">资产:为可替换资产提供支持的模块——想想ERC20令牌。</li><li id="6d16" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://github.com/paritytech/substrate/tree/master/srml/balances" rel="noopener ugc nofollow" target="_blank">余额</a>:支持管理账户余额的模块。</li><li id="052e" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://github.com/paritytech/substrate/tree/master/srml/staking" rel="noopener ugc nofollow" target="_blank"> Staking </a>:提供网络维护人员管理资金风险的功能模块。</li></ul><p id="c529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您将会注意到，这些模块中的每一个都被格式化为Rust crate，旨在导入到基底运行时环境中。</p><p id="c001" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注:</em> </strong> <em class="no">奇偶性创造了很多板条箱才能把衬底弄到今天的位置。查看他们板条箱库的索引，在</em><a class="ae lq" href="https://crates.parity.io/substrate_service/index.html" rel="noopener ugc nofollow" target="_blank"><em class="no">crates . parity . io</em></a><em class="no">。这个文档实际上是自动生成的，使用一个叫做rustdoc的工具——更多关于那个</em> <a class="ae lq" href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html" rel="noopener ugc nofollow" target="_blank"> <em class="no">的文档在这里</em> </a> <em class="no">。</em></p><p id="95c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个SRML模块都打包成板条箱，并在模块名称前加上前缀<code class="fe ob oc od oe b">srml_</code>，每个模块都可以在奇偶校验<a class="ae lq" href="https://crates.parity.io/substrate_service/index.html#modules" rel="noopener ugc nofollow" target="_blank">板条箱库</a>的左侧菜单中找到。</p><h2 id="acd2" class="nc mg it bd mh nd ne dn ml nf ng dp mp ld nh ni mr lh nj nk mt ll nl nm mv nn bi translated">模块结构概述</h2><p id="74d3" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">每个模块都在自己的<code class="fe ob oc od oe b">src/lib.rs</code>文件中定义，符合特定的结构。我们已经可以看到基板模块的高级特征:</p><ul class=""><li id="cfae" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">一个模块通常是它自己的机箱，但不是必须的</li><li id="80cd" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">一个模块可以定义为一个文件，<code class="fe ob oc od oe b">module-name.rs</code>，或者更常见的是<code class="fe ob oc od oe b">lib.rs</code>，如果模块是一个板条箱。一个模块还可以有其他支持文件，通常都位于一个特定的目录中。</li><li id="6304" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><strong class="kw iu">模块必须符合特定的结构，依赖于特定的底层API</strong></li></ul><p id="430d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这最后一点实际上意味着什么？这取决于你的模块实际上是做什么的。模块为您的区块链提供功能，这一点我们已经知道了，但是这种功能可以以一系列组件的形式出现:</p><p id="ca93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">事件:</strong>模块可以定义当满足特定标准时调用的定制事件——也许是当您创建一个新的不可替换令牌时的<code class="fe ob oc od oe b">TokenCreated</code>事件。事件被包装在一个<code class="fe ob oc od oe b">decl_event!</code>宏中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="864e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">存储:</strong>一个模块可以定义持久化的数据结构，比如映射、列表等等。我们实际上可以存储一系列数据类型，其中大部分都记录在<a class="ae lq" href="https://polkadot.js.org/api/types/#codec-types" rel="noopener ugc nofollow" target="_blank">这里</a>。存储项目在<code class="fe ob oc od oe b">decl_storage!</code>宏中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4399" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">可分派的函数:</strong>可以通过<a class="ae lq" href="https://substrate.dev/docs/en/overview/glossary#json-rpc" rel="noopener ugc nofollow" target="_blank"> JSON RPC </a>调用在运行时执行的公共函数。所有<a class="ae lq" href="https://substrate.dev/docs/en/overview/glossary#dispatch" rel="noopener ugc nofollow" target="_blank">可分派的</a>函数都包含一个<code class="fe ob oc od oe b"><a class="ae lq" href="https://substrate.dev/docs/en/overview/glossary#origin" rel="noopener ugc nofollow" target="_blank">origin</a></code>参数，其中包含关于函数调用来源的信息，比如调用者的公共地址和其他元数据。</p><p id="1e62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们查看<code class="fe ob oc od oe b"><a class="ae lq" href="https://crates.parity.io/srml_assets/index.html#dispatchable-functions" rel="noopener ugc nofollow" target="_blank">Assets</a></code> <a class="ae lq" href="https://crates.parity.io/srml_assets/index.html#dispatchable-functions" rel="noopener ugc nofollow" target="_blank">模块可调度函数</a>，我们可以看到<code class="fe ob oc od oe b">issue</code>、<code class="fe ob oc od oe b">transfer</code>和<code class="fe ob oc od oe b">destroy</code>是为我们定义的。可调度的函数是通过帐户调用的。我们将进一步使用特定的工具来管理账户</p><p id="7ad1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">公共或私有函数:</strong>模块可以提供公共函数，可以从运行时环境中的任何地方调用，也可以提供私有函数，只能从模块的实现内部调用。这两个函数都不是可调度的，例如，它们不能通过JSON RPC协议从外部访问，也不需要<code class="fe ob oc od oe b">origin</code>参数。</p><p id="478f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">结构:</strong>模块可以定义该模块可能需要的结构。例如，可能会为用于跟踪全球发货的链定义一个<code class="fe ob oc od oe b">ShipmentItem</code>结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="8bb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们可以将其他类型引入该结构，正如我们在上面的例子中对<code class="fe ob oc od oe b">Hash</code>和<code class="fe ob oc od oe b">Balance</code>所做的那样。</p><p id="b9c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">标准类型，比如<code class="fe ob oc od oe b">Hash</code>，是在运行时原语库中定义的，但是类型通常也是在其他运行时模块中定义的，这里我们引入了模块依赖的概念。</p><h2 id="fafd" class="nc mg it bd mh nd ne dn ml nf ng dp mp ld nh ni mr lh nj nk mt ll nl nm mv nn bi translated">模块也可以是依赖关系</h2><p id="3acd" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">正如我们已经发现的，模块可以是板条箱，因此可以作为<code class="fe ob oc od oe b">Cargo.toml</code>中的依赖项。这确保了不会缺少其他模块所依赖的模块。</p><p id="819f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到即插即用的类比，模块定义了可以在运行时内部播放(执行)的可插入(导入)特性，为您的链提供了额外的功能。这个可插入的方面仅仅意味着声明和导入你需要的模块到你的底层运行时。我们将进一步深入了解这一点。</p><p id="a4e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了对底层模块实际上是什么的概念理解，让我们使用<code class="fe ob oc od oe b">substrate-module-new</code>实用程序来生成一个基本模块模板。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="c1ac" class="mf mg it bd mh mi nw mk ml mm nx mo mp jz ny ka mr kc nz kd mt kf oa kg mv mw bi translated">初始化新模块</h1><p id="6a50" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">像<code class="fe ob oc od oe b">substrate-node-new</code>实用程序一样，我们也下载了一个<code class="fe ob oc od oe b">substrate-module-new</code>实用程序，它为我们提供了最新的模块模板。</p><p id="d918" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在节点运行时目录中，准备一个包含以下内容的新模块:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="5484" class="nc mg it oe b gy oj ok l ol om">substrate-module-new <strong class="oe iu">&lt;module_name&gt;</strong></span></pre><p id="38de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用一个名字<code class="fe ob oc od oe b">my-module</code>来运行它。输出将提示我们将模块添加到我们的<code class="fe ob oc od oe b">runtime/src/lib.rs</code>文件中:</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="7a81" class="nc mg it oe b gy oj ok l ol om">cd runtime/src<br/>substrate-module-new my-module</span><span id="99d4" class="nc mg it oe b gy on ok l ol om">&gt; SRML module created as ./my-module.rs and added to git.<br/>&gt; Ensure that you include in your ./lib.rs the line:</span><span id="5669" class="nc mg it oe b gy on ok l ol om">&gt; mod my_module;</span></pre><p id="8054" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果文件<code class="fe ob oc od oe b">my-module</code>将与最初包含在目录中的<code class="fe ob oc od oe b">template.rs</code>文件相同。然而，在<code class="fe ob oc od oe b">template.rs</code>被编辑的情况下，运行<code class="fe ob oc od oe b">substrate-module-new</code>是启动新运行时模块的首选方式。</p><p id="852e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这里开始，我们可以继续开发这个模块，把它包装在自己的箱子里，甚至把它发布到Github上，其他开发人员可以在那里维护它或为它的开发做贡献。这是底层模块的内在力量，并且无疑将有助于开发工作，因为模块库是由各个领域的开发者发布的。</p><p id="b25c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在文档页面上阅读更多关于将模块导入运行时的信息。</p><p id="4c95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="no">注:</em> </strong> <em class="no">以后我会发布更多关于模块开发的语法驱动的见解。</em></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="a9a9" class="mf mg it bd mh mi nw mk ml mm nx mo mp jz ny ka mr kc nz kd mt kf oa kg mv mw bi translated">摘要</h1><p id="7406" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">Substrate上的介绍已经涵盖了如何安装框架，以及如何使用包含的工具来帮助部署定制节点和模块。</p><p id="3a76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们访问了Polkadot JS应用程序，以了解它如何作为一个底层管理实用程序工作，同时充当链浏览器和管理器。该应用程序旨在成为通用的，并不假设您的链支持什么——应用程序的UI将根据您的链规范和您在运行时中定义的模块进行更新。</p><p id="fb0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于链规范的主题，我们介绍了如何通过<code class="fe ob oc od oe b">substrate build-spec</code>生成一个规范JSON文件，其内容将根据链的运行时将执行的模块而变化。还有三个预配置的链规范，用于填充开发或生产节点的规范。在编译成原始状态并在运行时使用之前，可以编辑链规范。</p><p id="19ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还探索了运行时模块本身，它们通常是捆绑在货物箱中的一个文件。运行时模块需要遵循底层API，这些API定义了各种组件，如事件、存储和函数，所有这些组件在导入模块时都将对您的运行时可用。</p></div></div>    
</body>
</html>