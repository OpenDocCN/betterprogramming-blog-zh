<html>
<head>
<title>Swift: Favor Composition Over Inheritance. The BaseViewController case.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯威夫特:偏爱组合胜过继承。BaseViewController案例。</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-favor-composition-over-inheritance-the-baseviewcontroller-case-f598064bda6?source=collection_archive---------5-----------------------#2019-10-04">https://betterprogramming.pub/swift-favor-composition-over-inheritance-the-baseviewcontroller-case-f598064bda6?source=collection_archive---------5-----------------------#2019-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/85143d23647616812ca00b1e85e19b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJ6-SZXqS_BAAb8691MJ7Q.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae kf" href="https://unsplash.com/s/photos/swift?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f79a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在过去的一篇文章中，我使用了OOP原则<em class="le">优先于继承</em>作为在Swift中避免使用协议默认实现的原因之一。我不想说得太详细，因为那太长了。</p><p id="0f0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将使用一个熟悉的例子来展示我们如何使用复合而不是继承，以及为什么当目标是重用代码时，它是一个更好的方法。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="5deb" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">BaseViewController</h1><p id="7b32" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我在iOS项目中见过的重用代码的继承的最流行用法之一是拥有一个<code class="fe mp mq mr ms b">BaseViewController</code>。项目中的每一个<code class="fe mp mq mr ms b">UIViewController</code>都是这个<code class="fe mp mq mr ms b">BaseViewController</code>的子类，因此它们获得共享的行为、功能、组件、依赖等。</p><p id="2048" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于这样的东西:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fd12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，那么这里有什么问题呢？</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="41f3" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">从BaseViewController到BaseViewContainer</h1><p id="23b4" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated"><code class="fe mp mq mr ms b">BaseViewController</code>快速成为两个或更多子类正在使用(或将潜在使用)的方法的容器。这很难维护，并且打破了实体的<em class="le">单一责任原则</em>。</p><blockquote class="mz na nb"><p id="572c" class="kg kh le ki b kj kk kl km kn ko kp kq nc ks kt ku nd kw kx ky ne la lb lc ld im bi translated">每个模块或类应该对软件提供的功能的一个部分负责。</p></blockquote></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="cddc" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">连接</h1><p id="6f8c" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated"><code class="fe mp mq mr ms b">BaseViewController</code>属性和方法/功能不一定被每个<code class="fe mp mq mr ms b">UIViewController</code>子类使用。这意味着子类可能依赖于他们不需要或不使用的代码。你可以在功能1和功能2中看到一个例子。</p><p id="3ef7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据OOP原则:<em class="le">你不应该依赖你不使用的方法。</em></p><p id="ecc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用组合，您可以通过定义和符合小协议来使用控制反转和接口分离。然而，继承不允许你这样做。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="d731" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">包装</h1><p id="cf27" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">封装指的是对象应该管理它们自己的行为和状态，这样它们的合作者就不需要关心对象的内部工作。</p><p id="fd75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mp mq mr ms b">BaseViewController</code>打破封装有不同的方式:</p><ul class=""><li id="d601" class="nf ng it ki b kj kk kn ko kr nh kv ni kz nj ld nk nl nm nn bi translated"><code class="fe mp mq mr ms b">BaseViewController</code> ↔︎ <em class="le">子类</em> (I):如果任何<code class="fe mp mq mr ms b">BaseViewController</code>子类被允许访问从其继承的成员，那么<code class="fe mp mq mr ms b">BaseViewController</code>中的变化可能也需要维护子类。</li><li id="3221" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated"><code class="fe mp mq mr ms b">BaseViewController</code> ↔︎ <em class="le">子类</em> (II):如果任何<code class="fe mp mq mr ms b">BaseViewController</code>子类被允许覆盖从它继承的成员(只要它们是非final的)，那么<code class="fe mp mq mr ms b">BaseViewController</code>方法的覆盖可能会改变它的行为。</li><li id="f4f1" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated"><code class="fe mp mq mr ms b">ChildViewControllers</code> ↔︎ <em class="le">客户端</em>:由于Swift不像Java那样为子类提供<a class="ae kf" href="https://www.geeksforgeeks.org/access-modifiers-java/" rel="noopener ugc nofollow" target="_blank"> <em class="le">受保护的</em>访问器</a>，因此<code class="fe mp mq mr ms b">BaseViewController</code>共享方法和属性需要是公共的或内部的。子类继承那些具有相同可见性的公共/内部成员。假设这些成员中的一些是私有的，那么任何客户端都可以公开访问它们的内部工作。</li></ul></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="8cde" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">灵活性</h1><p id="4458" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">首先，<code class="fe mp mq mr ms b">BaseViewController</code>方法/功能不能在运行时改变或注入，因为它可以通过使用组合来完成。这是因为<code class="fe mp mq mr ms b">UIViewControllers</code>依赖于具体的实现，而不是抽象。</p><p id="2353" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，那些方法/功能不能在不是<code class="fe mp mq mr ms b">UIViewController</code>的类中重用，除非你想使用<code class="fe mp mq mr ms b">UIViewController</code>作为对它的依赖🤯。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="d646" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">单元测试</h1><p id="ef4d" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">假设您正在为您的代码编写测试，您可能想要注入和模拟单元测试的所有依赖项。在这一点上应该很清楚，子类化<code class="fe mp mq mr ms b">BaseViewController</code>不允许你对继承的方法/功能这样做。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="9bcf" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">普通页眉、页脚或背景</h1><p id="e26d" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这篇文章的目的是解释当谈到共享代码时，为什么你应该选择组合而不是继承<strong class="ki iu">的一些原因。</strong></p><p id="abc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是你可能认为你仍然可以使用<code class="fe mp mq mr ms b">BaseViewController</code>在几个<code class="fe mp mq mr ms b">UIViewController</code>中设置一些公共的页眉、页脚或背景，而不需要重复代码。</p><p id="d926" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为你最终会陷入一些以前的问题，因为你可以用另一种方法来实现。</p><p id="5d02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你共享不同<code class="fe mp mq mr ms b">UIViewController</code>的页眉、页脚或背景，你可以考虑使用<strong class="ki iu"> ChildViewControllers </strong>，这样你就可以将<strong class="ki iu">容器</strong>从你实际的<code class="fe mp mq mr ms b">UIViewController</code>中分离出来。这样每个组件都有自己的职责，另外，你的<code class="fe mp mq mr ms b">UIViewController</code>可以被注入不同的容器。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9e55572148949d55b44f8f4f92e9aaca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*dwimNGA9dVTr28frR6PE1Q.png"/></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="7f40" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">继承语义学</h1><p id="d610" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我把这个话题留到了最后，因为它更多的是概念性的，而不是实践性的，而且可能有争议。所以拜托，就当是额外的主观原因吧。</p><p id="61fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，类继承，或者如果你想的话，子类型化是一种在两个类之间建立关系的机制。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6f1689d7ff4236171b116cfbadea2a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*qsj50HEXilFYmcZSu2dqrQ.png"/></div></figure><p id="4b73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管这个图的正确性和完整性如何，这里我们可以看到，每一个<code class="fe mp mq mr ms b">Cat</code>都是一个<code class="fe mp mq mr ms b">Mammal</code>，每一个<code class="fe mp mq mr ms b">Mammal</code>都是一个<code class="fe mp mq mr ms b">VertebrateAnimal</code>。在这个分类法中，每个<em class="le">类</em>都定义了属于它所代表的概念的属性和方法。</p><p id="854b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mp mq mr ms b">BaseViewController</code>的情况下，考虑到它可能不会被用作实际的<code class="fe mp mq mr ms b">UIViewController</code>，我们不能说我们有is-a关系。<code class="fe mp mq mr ms b">BaseViewController</code>永远不会被实例化，它可能会为此用<code class="fe mp mq mr ms b">fatalErrors</code>覆盖<code class="fe mp mq mr ms b">init</code> <em class="le"> </em>方法<em class="le"> </em>。</p><p id="1c0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mp mq mr ms b">BaseViewController</code>不是<code class="fe mp mq mr ms b">UIViewController</code>，我们可能会破坏这里的继承语义。<code class="fe mp mq mr ms b">BaseViewController</code>不是一个<code class="fe mp mq mr ms b">UIViewController</code>。我们这样做只是为了重用代码。</p><p id="a58c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Swift不提供多重继承，因此，在这一点上，你可以考虑通过将<em class="le">子类化</em>转移到<em class="le">来解决这个问题，使</em> a <em class="le"> </em> <code class="fe mp mq mr ms b">BaseViewControllerProtocol</code> <em class="le"> </em>与<em class="le">默认实现</em>保持一致，但这可能会更糟，因为你可以在这里阅读<a class="ae kf" href="https://medium.com/better-programming/swift-why-you-should-avoid-using-default-implementations-in-protocols-eeffddbed46d" rel="noopener"/>。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="b1d3" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">还是用构图吧！</h1><p id="761c" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">让我们看看如何使用composition重写第一个示例:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="mx my l"/></div></figure><ul class=""><li id="b308" class="nf ng it ki b kj kk kn ko kr nh kv ni kz nj ld nk nl nm nn bi translated">这里我们只在需要的类中注入<code class="fe mp mq mr ms b">Functionality1</code>和<code class="fe mp mq mr ms b">Functionality2</code>。</li><li id="04c9" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated">我们只依赖于我们需要或使用的方法。</li><li id="7d10" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated">我们可以在运行时注入任何符合<code class="fe mp mq mr ms b">Functionality1Protocol</code> / <code class="fe mp mq mr ms b">Functionality2Protocol</code>的类来改变实现。</li><li id="6f30" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated"><code class="fe mp mq mr ms b">Functionality1Protocol</code>和<code class="fe mp mq mr ms b">Functionality2Protocol</code>可以由两个类来整合，也可以由一个类来整合。</li><li id="a00c" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated">我们封装了依赖性。</li><li id="d6ac" class="nf ng it ki b kj no kn np kr nq kv nr kz ns ld nk nl nm nn bi translated">我们可以为单元测试注入符合<code class="fe mp mq mr ms b">Functionality1Protocol</code>和<code class="fe mp mq mr ms b">Functionality2Protocol</code>的模拟。</li></ul></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="eaa4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！如果你喜欢这篇文章，请鼓掌:)</p></div></div>    
</body>
</html>