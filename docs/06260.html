<html>
<head>
<title>Learn webpack in Under 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟内学会网络包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-webpack-in-under-10-minutes-efe2b2b10b61?source=collection_archive---------1-----------------------#2020-09-15">https://betterprogramming.pub/learn-webpack-in-under-10-minutes-efe2b2b10b61?source=collection_archive---------1-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf9b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">webpack可能有点混乱。让我们解开它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/195c2e31092ae97bf81019c7eaef39d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94ZhvvcXzyzCwuUVjxljhA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://webpack.github.io/" rel="noopener ugc nofollow" target="_blank">https://webpack.github.io/</a></p></figure><h1 id="46bc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是webpack？</h1><p id="bf1a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">根据官方<a class="ae ky" href="https://webpack.js.org/concepts/" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="mn mo mp"><p id="b0d9" class="lr ls mq lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated">" webpack是一个用于现代JavaScript应用的静态模块捆绑器."</p></blockquote><p id="1efe" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">作为JavaScript开发人员，我们知道什么是模块，但是在webpack中，模块有点不同。他们包括<strong class="lt iu"> : </strong></p><ul class=""><li id="7615" class="mz na it lt b lu mr lx ms ma nb me nc mi nd mm ne nf ng nh bi translated"><strong class="lt iu"> ES模块</strong> — <code class="fe ni nj nk nl b">import</code>声明</li><li id="3443" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated"><strong class="lt iu">常见JS模块</strong> — <code class="fe ni nj nk nl b">require()</code>语句</li><li id="7c06" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated"><strong class="lt iu"> AMD模块</strong> — <code class="fe ni nj nk nl b">define</code>和<code class="fe ni nj nk nl b">require</code>声明</li><li id="8efb" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated"><strong class="lt iu"> CSS导入</strong> — <code class="fe ni nj nk nl b">@import</code>任何css/sass/less文件内的语句</li><li id="e7a6" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated"><strong class="lt iu">图片网址</strong> — <code class="fe ni nj nk nl b">url(...)</code>或<code class="fe ni nj nk nl b">&lt;img src="..." /&gt;</code></li></ul><p id="058d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">webpack以这样一种方式统一了所有这些不同的模块，使得将所有内容导入JavaScript代码成为可能。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="9760" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">该不该学webpack？</h1><p id="e515" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">今天，大多数应用程序都是使用React/Vue或任何其他库构建的。他们提供CLI工具(例如create-react-app、@vue/cli)来创建应用程序。这些CLI工具抽象出大部分配置并提供默认值。但是对于作为开发人员的您来说，了解这是如何工作的是有益的，因为迟早您可能想要对默认值进行一些调整。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3895" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">我们开始吧</h1><p id="e8ef" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将创建一个简单的应用程序来演示webpack的工作。让我们首先创建一个新目录并初始化一个npm项目。假设您在新创建的目录中，键入以下命令:</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="a3be" class="oh la it nl b gy oi oj l ok ol">npm init -y</span></pre><p id="82f7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在让我们安装所需的webpack包。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="69c7" class="oh la it nl b gy oi oj l ok ol">npm install --save-dev webpack webpack-cli webpack-dev-server</span></pre><p id="1379" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们打开<code class="fe ni nj nk nl b">package.json</code>文件，删除已经存在的<code class="fe ni nj nk nl b">test</code>脚本，并添加一个新脚本<code class="fe ni nj nk nl b">dev</code>以在开发模式下运行webpack。当我们在本地工作时，这个脚本很方便。您的程序包文件应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9221" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在如果你运行<code class="fe ni nj nk nl b">npm run dev</code>，你会得到一个讨厌的错误:<code class="fe ni nj nk nl b">Entry module not found</code>。这是因为，默认情况下，webpack期望将<code class="fe ni nj nk nl b">src/index.js</code>中的一个文件作为入口点。另外，缺省情况下，webpack将构建文件输出到一个名为<code class="fe ni nj nk nl b">dist</code>的目录中。</p><p id="3ac2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">好了，让我们通过创建一个新目录<code class="fe ni nj nk nl b">src</code>和一个名为<code class="fe ni nj nk nl b">index.js</code>的文件来解决这个问题。现在，让我们在<code class="fe ni nj nk nl b">index.js</code>文件中键入一个<code class="fe ni nj nk nl b">console.log('hello');</code>语句。</p><p id="b46c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在让我们运行<code class="fe ni nj nk nl b">npm run dev</code>。您将不会发现任何错误，还会在名为<code class="fe ni nj nk nl b">dist</code>的目录下找到构建文件<code class="fe ni nj nk nl b">main.js</code>。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="6ab1" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">配置webpack</h1><p id="02c7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要配置webpack，我们需要在根目录下创建一个名为<code class="fe ni nj nk nl b">webpack.config.js</code>的文件。在这个文件中，我们需要导出一个配置对象。webpack运行在Node.js这样的无头JavaScript环境上。</p><p id="618f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">一些最广泛使用的术语是:</p><ul class=""><li id="c202" class="mz na it lt b lu mr lx ms ma nb me nc mi nd mm ne nf ng nh bi translated"><strong class="lt iu">入口点</strong> —指定webpack的入口点，从该入口点收集所有依赖项。这些依赖关系形成了依赖关系图。</li><li id="ad76" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated"><strong class="lt iu">输出</strong> —指定在构建过程中收集结果JS和静态文件的位置</li><li id="cbe3" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated">加载器 —帮助webpack处理各种文件扩展名的第三方扩展。它们将JS以外的文件转换成模块。</li><li id="386a" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated"><strong class="lt iu">插件</strong> —可以改变webpack工作方式的第三方扩展</li><li id="158c" class="mz na it lt b lu nm lx nn ma no me np mi nq mm ne nf ng nh bi translated"><strong class="lt iu">模式</strong> —指定两种模式:开发和生产。默认情况下，它是生产。</li></ul><p id="5741" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在让我们配置基本的入口点和输出目录。</p><h2 id="b58c" class="oh la it bd lb oo op dn lf oq or dp lj ma os ot ll me ou ov ln mi ow ox lp oy bi translated">更改入口点</h2><p id="4c65" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们需要webpack查看<code class="fe ni nj nk nl b">source/index.js</code>而不是默认的<code class="fe ni nj nk nl b">src</code>文件夹，我们需要在导出的对象中添加一个属性<code class="fe ni nj nk nl b">entry</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d926" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">您也可以使用替代的条目语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="d5d6" class="oh la it bd lb oo op dn lf oq or dp lj ma os ot ll me ou ov ln mi ow ox lp oy bi translated">更改输出目录</h2><p id="0a70" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们想要将构建的文件输出到另一个名为<code class="fe ni nj nk nl b">build</code>的目录中，而不是默认的<code class="fe ni nj nk nl b">dist</code>目录中。我们可以像这样设置输出属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="455f" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">将构建的文件包含在HTML文件中</h1><p id="7629" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在每个web应用程序中，至少有一个HTML文件。为了处理HTML，我们必须使用一个叫做<code class="fe ni nj nk nl b">html-webpack-plugin</code>的插件。让我们使用以下命令开始安装该插件:</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="7f4f" class="oh la it nl b gy oi oj l ok ol">npm install --save-dev html-webpack-plugin</span></pre><h2 id="93f8" class="oh la it bd lb oo op dn lf oq or dp lj ma os ot ll me ou ov ln mi ow ox lp oy bi translated">这个插件到底是做什么的？</h2><p id="34ec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">它加载我们的HTML文件，并在同一个文件中注入包。</p><p id="1e3c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们创建一个简单的HTML文件，并在webpack配置中对其进行配置。</p><p id="c219" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">我将在<code class="fe ni nj nk nl b">source</code>目录下创建一个名为<code class="fe ni nj nk nl b">index.html</code>的文件，并在其中插入一些样板代码。现在让我们在webpack文件中对此进行配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="aacc" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">既然我们的文件已经准备好了，我们需要一个服务器来服务这个文件，对吗？所以让我们使用之前安装的<code class="fe ni nj nk nl b">webpack-dev-server</code>来启动服务器。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="2599" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">webpack开发服务器</h1><p id="5624" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了配置<code class="fe ni nj nk nl b">webpack-dev-server</code>，我们需要打开<code class="fe ni nj nk nl b">package.json</code>文件并添加一个新的脚本来帮助我们启动服务器。我们已经有了<code class="fe ni nj nk nl b">dev</code>，我们用它来构建文件。现在让我们创建如下所示的<code class="fe ni nj nk nl b">start</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="1c5c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在尝试从您的终端运行这个命令。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="9bdd" class="oh la it nl b gy oi oj l ok ol">npm start</span></pre><p id="7d62" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">导航到您的浏览器并检查<code class="fe ni nj nk nl b">localhost:8080</code>。您会发现那里提供了<code class="fe ni nj nk nl b">index.html</code>,您可以打开开发工具，看到捆绑的<code class="fe ni nj nk nl b">main.js</code>文件也包含在其中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/ce5b108b1edfb69abd86ab7115bf02d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axKDXnf663Xt9eOEa14fYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动包含main.js文件</p></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="ce4b" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">使用webpack加载器</h1><p id="bd2d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如前所述，webpack中的加载器是处理各种其他文件扩展名的第三方扩展。webpack 有很多可用的加载器。</p><p id="378c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们继续在webpack配置文件中配置加载器。加载器有一个奇怪的语法。我们使用一个名为<code class="fe ni nj nk nl b">module</code>的键，它由另一个名为<code class="fe ni nj nk nl b">rules</code>的属性组成，这是一个加载器数组。对于我们希望作为模块对待的每个文件，我们将其作为对象放在这个<code class="fe ni nj nk nl b">rules</code>数组中。每个对象由两个属性组成:<code class="fe ni nj nk nl b">test</code>定义文件类型，<code class="fe ni nj nk nl b">use</code>是由加载器组成的数组。请注意，这里定义的加载器在<code class="fe ni nj nk nl b">use</code>数组中从右向左加载。定义装货人时，顺序很重要。在使用它们之前，请参考加载程序的文档。</p><p id="810c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">配置文件中加载程序的一般语法如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="c5a2" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">使用CSS</h1><p id="7437" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了在webpack中使用CSS，我们需要两个加载器:<code class="fe ni nj nk nl b">css-loader</code>和<code class="fe ni nj nk nl b">style-loader</code>。让我们使用这个命令来安装它们。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="a17a" class="oh la it nl b gy oi oj l ok ol">npm install --save-dev css-loader style-loader</span></pre><p id="55c4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们在<code class="fe ni nj nk nl b">source</code>目录中创建一个新文件<code class="fe ni nj nk nl b">styles.css</code>。添加任何基本样式，以便它们在服务器启动时反映在<code class="fe ni nj nk nl b">index.html</code>中。接下来，我们需要将文件包含在我们的<code class="fe ni nj nk nl b">index.js</code>文件中，并将<strong class="lt iu">而不是</strong>包含在<code class="fe ni nj nk nl b">index.html</code>中。记住，这个教程是基于捆绑和学习webpack的。所以现在我们的<code class="fe ni nj nk nl b">index.js</code>文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="154c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">还有最后一步要做。也就是在我们的<code class="fe ni nj nk nl b">webpack.config.js</code>文件中配置加载程序。我们的配置文件应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="51a0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><code class="fe ni nj nk nl b">css-loader</code>用于加载CSS文件，<code class="fe ni nj nk nl b">style-loader</code>用于加载DOM中的样式表。</p><p id="a679" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">当您重启服务器并再次运行<code class="fe ni nj nk nl b">npm start</code>时，您应该会发现浏览器中反映出的变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/135a828d2ac606909b72fe801c50f40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30z0segvkLYh_ZwHZ1wudw.png"/></div></div></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="827b" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">使用SASS</h1><p id="79c7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用SASS(。scss)文件，我们将需要三个加载器，<code class="fe ni nj nk nl b">sass-loader</code>、<code class="fe ni nj nk nl b">css-loader</code>和<code class="fe ni nj nk nl b">style-loader</code>，外加节点所需的一个额外的包<code class="fe ni nj nk nl b">sass</code>。这里的<code class="fe ni nj nk nl b">sass-loader</code> <strong class="lt iu"> </strong>用于导入加载SASS文件。因为我们已经安装了另外两个，现在让我们安装剩下的包。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="fb55" class="oh la it nl b gy oi oj l ok ol">npm install --save-dev sass-loader sass</span></pre><p id="7822" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们在<code class="fe ni nj nk nl b">source</code>目录下创建一个新文件<code class="fe ni nj nk nl b">styles.scss</code>，并添加这些线条或任何基本样式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5a8c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们通过在文件开头使用<code class="fe ni nj nk nl b">import './styles.scss'</code>将这个文件也包含在我们的<code class="fe ni nj nk nl b">index.js</code>文件中。</p><p id="56e0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在是时候在我们的<code class="fe ni nj nk nl b">webpack.config.js</code>文件中添加加载器了。我们的加载程序应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="bddf" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们重新启动服务器并检查更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/be4eae5bde5869f5f2755e99af4f15a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKHR3aF0x4rfTeqBr9Wjcw.png"/></div></div></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3c3c" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">使用现代JavaScript</h1><p id="4515" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">webpack本身并不知道如何将现代JavaScript转换成可以在任何浏览器中运行的兼容代码。所以它用<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a> <strong class="lt iu"> </strong>来达到同样的目的。我们来安装以下几个包:<code class="fe ni nj nk nl b">@babel/core</code>，这是实际的引擎；<code class="fe ni nj nk nl b">babel-loader</code>，是webpack需要的加载器；和用于将JavaScript向下转换成ES5的<code class="fe ni nj nk nl b">@babel/preset-env</code>。让我们安装依赖项:</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="37bb" class="oh la it nl b gy oi oj l ok ol">npm install --save-dev @babel/core babel-loader @babel/preset-env</span></pre><p id="55f1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">下一步是通过在我们的根目录下创建一个名为<code class="fe ni nj nk nl b">babel.config.json</code>的新文件来配置Babel。这里，我们配置Babel使用我们安装的<code class="fe ni nj nk nl b">preset-envm</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8a1c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在让我们将安装的加载程序添加到我们的<code class="fe ni nj nk nl b">webpack.config.js</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d731" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在让我们在JS代码中使用ES6和上述语法，在我们使用<code class="fe ni nj nk nl b">npm run dev</code>再次构建它之后，我们可以检查构建的<code class="fe ni nj nk nl b">main.js</code>文件，并看到它自动转换成浏览器兼容的代码。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="4cb7" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">在webpack中指定模式</h1><p id="d0a7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">webpack中有两种模式:开发和生产。</p><p id="0503" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在<strong class="lt iu">显影</strong>模式下，没有缩小。webpack只需将我们编写的所有JS代码加载到浏览器中，这样就可以更快地重新加载应用程序。</p><p id="0d1e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在<strong class="lt iu">生产</strong>模式下，webpack应用了很多优化。它会自动使用<code class="fe ni nj nk nl b">terser-webpack-plugin</code>进行缩小，以减小束尺寸。它还将<code class="fe ni nj nk nl b">process.env.NODE_ENV</code>设置为<code class="fe ni nj nk nl b">production</code>。这个环境变量很有用，因为我们可以有条件地在生产和开发中执行事情。</p><p id="5d89" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">要在生产模式下使用webpack，让我们向<code class="fe ni nj nk nl b">package.json</code>文件添加另一个脚本。我们将把它命名为<code class="fe ni nj nk nl b">build</code>。我们的脚本应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="117a" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">优化—代码拆分</h1><p id="9ac2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="mq">代码分割</em>或<em class="mq">延迟加载</em>是一种避免大捆绑包的优化技术。它还避免了依赖性重复。通过使用这种机制，我们可以按需加载一段代码，例如，每当用户点击一个按钮时，当路线改变时，等等。被分割的代码片段被称为<em class="mq">块</em>。</p><p id="8a7a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">webpack中有一个限制，即应用程序初始包的最大文件大小应小于244 KiB。有三种方法可以在webpack中实现代码拆分:</p><ol class=""><li id="51e3" class="mz na it lt b lu mr lx ms ma nb me nc mi nd mm pa nf ng nh bi translated">具有多个入口点</li><li id="0434" class="mz na it lt b lu nm lx nn ma no me np mi nq mm pa nf ng nh bi translated">使用<code class="fe ni nj nk nl b">optimization.splitChunks</code></li><li id="d937" class="mz na it lt b lu nm lx nn ma no me np mi nq mm pa nf ng nh bi translated">动态导入</li></ol><p id="6b19" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">第一种方法适用于较小的项目，但在复杂的项目中不可伸缩。我们在webpack配置文件中指定了多个入口点。</p><h2 id="b795" class="oh la it bd lb oo op dn lf oq or dp lj ma os ot ll me ou ov ln mi ow ox lp oy bi translated">使用优化. splitChunks</h2><p id="9cdb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时候，我们在应用程序中使用了大量的依赖项。举个例子，我们用一个流行的包日期:<a class="ae ky" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank">时刻</a>。我选择这个包裹是因为它的体积有点重。让我们安装它，然后将它包含在我们的<code class="fe ni nj nk nl b">index.js</code>文件中，并运行我们的<code class="fe ni nj nk nl b">build</code>命令。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="1977" class="oh la it nl b gy oi oj l ok ol">npm install moment</span></pre><p id="9cea" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">Moment将成功安装。现在让我们将它导入到我们的<code class="fe ni nj nk nl b">index.js</code>文件中。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="d0dd" class="oh la it nl b gy oi oj l ok ol">import moment from 'moment'</span></pre><p id="a581" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在让我们运行我们的<code class="fe ni nj nk nl b">build</code>命令。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="fbe1" class="oh la it nl b gy oi oj l ok ol">npm run build</span></pre><p id="43af" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">您将在终端中看到以下警告消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/5a618c0e0f6a49987cadfd6bf5955bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcOcj2SVpEXJuwhOyZdBXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">超大main.js文件</p></figure><p id="9fdf" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">那么我们如何解决这个问题呢？很简单。让我们添加一个名为<code class="fe ni nj nk nl b">optimization</code>的键和另一个名为<code class="fe ni nj nk nl b">splitChunks</code>的属性，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a98d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">您会发现入口点的大小大大减小了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/688882840bd59157a964462c678f3d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rZWMHRKfk-rpUQge4WKHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">减小入口点文件大小</p></figure><h2 id="1e2f" class="oh la it bd lb oo op dn lf oq or dp lj ma os ot ll me ou ov ln mi ow ox lp oy bi translated">动态导入</h2><p id="3913" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">动态导入用于有条件地加载代码。这种方法在React和Vue中被广泛使用。我们可以基于用户交互或者基于路线改变来加载代码。</p><p id="8202" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">为了演示，让我们在页面上添加一个按钮，点击它可以获取文章列表。这个获取逻辑的代码存在于一个单独的文件中。它被动态导入到我们的<code class="fe ni nj nk nl b">index.js</code>文件中。</p><p id="240c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们在<code class="fe ni nj nk nl b">source</code>文件夹中的一个名为<code class="fe ni nj nk nl b">api.js</code>的文件中单独调用一个<code class="fe ni nj nk nl b">fetch</code> API。这里，我们导出一个向公共API发出请求并返回响应的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4b7c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们在<code class="fe ni nj nk nl b">index.html</code>文件中创建一个按钮，并将<code class="fe ni nj nk nl b">id</code>属性设置为<code class="fe ni nj nk nl b">btn</code>。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="b51c" class="oh la it nl b gy oi oj l ok ol">&lt;button id="btn"&gt;Click me to load&lt;/button&gt;</span></pre><p id="29aa" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在我们的<code class="fe ni nj nk nl b">index.js</code>文件中，让我们通过使用一个函数来导入我们的<code class="fe ni nj nk nl b">api.js</code>文件来进行动态导入。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="86b0" class="oh la it nl b gy oi oj l ok ol">const getTodos = () =&gt; import('./api')</span></pre><p id="c3de" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">同样，让我们通过在文件末尾添加这个逻辑来记录获取的数据。</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="d002" class="oh la it nl b gy oi oj l ok ol">const btn = document.getElementById('btn');</span><span id="b7d8" class="oh la it nl b gy pd oj l ok ol">btn.addEventListener('click', () =&gt; {<br/>    getTodos().then(({fetchTodos}) =&gt; {<br/>        fetchTodos().then(resp =&gt; console.log(resp))<br/>    })<br/>})</span></pre><p id="46b2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这个代码片段调用了<code class="fe ni nj nk nl b">getTodos</code>函数，它为我们导入了文件。然后在导入之后，我们从其中析构<code class="fe ni nj nk nl b">fetchTodos</code>属性，调用该函数，然后记录成功的响应。</p><p id="3e87" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们构建我们的文件，运行我们的服务器，并确保打开开发工具并保持网络选项卡打开。你会发现，点击一下，就有一个新的JS文件被动态加载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/e1ca1dcf30f1ae5a82a41c7bc8626edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGxl0GKY5z33FGUz50s-2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动态导入</p></figure><p id="bfcd" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><code class="fe ni nj nk nl b">0.main.js</code>是动态加载的文件。如果您希望这个文件有一个可读的名称，您只需要在动态导入期间添加一个注释，如下所示:</p><pre class="kj kk kl km gt od nl oe of aw og bi"><span id="0391" class="oh la it nl b gy oi oj l ok ol">const getTodos = () =&gt; import(<!-- -->/* webpackChunkName: "postsAPI" */ <!-- -->'./api')</span></pre><p id="ca88" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在，当你重复同样的过程时，它将加载一个名为<code class="fe ni nj nk nl b">postsAPI.js</code>而不是<code class="fe ni nj nk nl b">0.main.js</code>的文件。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="9307" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">还好奇？</h1><p id="f6d0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这只是对webpack的简单介绍。正如我前面说过的，这篇文章的目标读者是希望开始学习webpack的初学者或中级开发人员。当然，webpack中的主题要多得多。我刚刚经历了最基本的。如果你对学习更多关于webpack的知识很感兴趣，请参考<a class="ae ky" href="https://webpack.js.org/concepts/" rel="noopener ugc nofollow" target="_blank">文档</a>，因为那里有很多有趣的主题的详细解释。</p><p id="e212" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> Git回购</strong>——<a class="ae ky" href="https://github.com/harshaktg/webpack-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/harshaktg/webpack-demo</a></p><p id="411f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">感谢阅读！</p></div></div>    
</body>
</html>