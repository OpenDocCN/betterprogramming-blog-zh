# 期货:镖中的承诺

> 原文：<https://betterprogramming.pub/futures-in-dart-582186ee75da>

## Dart 中使用期货的异步编程

![](img/2f7eb205f5ff639050051f5e53061210.png)

背景图像—无飞溅

Dart 是一种语言，当 Google 决定把它扔给 Flutter 时，它被赋予了生命。

Dart 是很快成为初学者更喜欢学习的语言之一，因为它支持三大平台的开发:iOS、Android 和 Web。JavaScript 还有很多工作要做，但 common JS 已经存在了二十多年——将它与一种仍在成熟的语言相比较是不公平的。

也就是说，它已经拥有了现代语言几乎所有的基本特性，在本文中，我们将讨论一种非常基本的编程模式。*异步编程* (或*并行编程*)是一种不能立即执行的特定任务在后台继续执行而不阻塞整个程序的编程技术。一个典型的日常例子是 HTTP API 调用。

现在，如果您来自 JS 背景，您将熟悉 async-await、promises 甚至订阅。在本文中，我们将讨论 Dart 中的异步编程。

# 达特的未来

Futures 是 Dart 为异步提供的最简单和最基本的 API 之一。

未来就像承诺一样，只是在飞镖里。就像任何基本承诺一样，它有三种状态:执行状态(完成状态，可以分为“成功完成”和“有错完成” *)* 。

Dart futures 还在管理事件队列的*事件循环*上运行。由于 Dart 和 JS 一样是单线程程序，所以您编写的所有任务都在事件循环中结束执行。

把事件循环想象成一个摆渡轮——但是任务是人。

当新来的人乘坐时，他们被加到一个船舱里，他们呆在轮子里直到他们的时间结束。类似地，任务进入并停留在事件循环中，直到其执行完成。但是就像轮子不会停下来等待一个用户完成骑行一样，事件循环不会停止某个特定任务的执行——即使每个任务可能需要不同的时间来完成执行。

让我们考虑一个例子来说明问题。下面的代码演示了一个非常简单的场景，其中有一个下载按钮。点击它将导致一个图像被下载并显示在应用程序中。我们来分解一下。

第 1–2 行:当用户点击`RaisedButton`时，一个点击事件被注册到调用点击处理程序的事件循环中。现在执行状态已经开始，这将是未完成的。

第 3 行:tap 处理程序使用 HTTP 库从 URL 发出对图像的`get`请求。这返回一个未来成`myFuture` ***。***

第 4 行:当请求完成时，我们使用`then` 注册一个回调。

现在，事件循环不会等到请求完成，但在此期间，它会继续执行事件队列中的其他任务，而不会等待 HTTP 请求的执行完成。

第 5 行:最终，一旦 HTTP 请求成功地将数据返回给未来，该数据将被传递给`response`对象中的回调，回调将被触发以在应用程序中显示图像。

如果你是这个承诺的新手，你可能没有注意到的一件事是，我们从来没有直接管理事件循环，如果没有未来的API，就不会出现这种情况。

Future 负责事件循环中的所有处理，我们所要做的就是从 HTTP 请求中创建一个 future 对象，并告诉它 future 完成后需要做什么。

但是就像我上面提到的，未来也可以有第三种状态，没有错误地完成，在编写有效的代码时，你必须覆盖错误，以确保你的程序不会崩溃。

第 6 行:如果 future 完成时出现错误，执行将转到这一行，在这一行，我们已经使用`catchError()` 方法 ***为错误定义了回调。*** 这个方法将接受一个错误对象而不是一个值，并在未来完成时执行里面的语句。

# 创建未来的实例

在上面的例子中，我们并没有完全靠自己创造未来。如果您已经注意到了，HTTP 库为我们做了这项工作——我们所要做的就是调用 HTTP `get`方法，并将其分配给创建的未来对象`myFuture` ***。***

```
final myFuture = http.get(‘http://example.com');
```

同样，还有许多其他的图书馆为你创造未来。假设你正在将一些数据存储到应用程序的共享偏好设置中。获取共享首选项的实例也将返回一个 future。

```
final myFuture = SharedPreferences.getInstance();
```

所有这些都很好，但是没有图书馆，我们如何创造未来？这就是未来构造函数的用途。

*未来构造函数*是接受一个函数并返回与该函数的返回类型相匹配的未来值的构造函数。该函数异步运行，一旦函数返回值，未来就用该值来完成。让我们考虑一个例子:

使用构造函数创造未来

就像我们上一个例子一样，我们正在创建一个未来，但是这次使用了 Future() 构造函数。未来构造函数将在第一次执行时返回一个未完成的未来。但是事件循环不会等到未来完成，它会立即在`line 6`上执行 print 语句。因此，上述代码的输出将是:

```
Printing....
Future Complete
```

Future.value() **这在已经获得所需值的情况下非常有用，比如构建使用缓存的服务。但是这里要记住的一点是，未来仍然是异步完成的。这是你如何分配它:**

```
final myFuture = Future.value(10);
```

还有另一个构造函数，它执行与`Future.value()`完全相反的操作，并以一个错误完成。`[Future.error()](https://api.dartlang.org/stable/dart-async/Future/Future.error.html)` 构造函数接受一个错误对象和一个可选的堆栈跟踪。示例:

```
final myFuture = Future.error(Exception());
```

最后我们有`Future.delayed()`，它的工作方式与 future 非常相似，但是顾名思义，它在执行函数和完成 Future 之前会等待一段特定的时间。

当您需要模拟一些异步的东西，而您还没有完成代码的编写时，这可以派上用场。

典型的用例是，当你试图模拟一个可能需要几秒钟才能完成的 API 调用时，你已经编写了一些代码，让用户知道后台正在发生一些事情，比如加载器动画。创建一个最简单的方法是:

Future.delayed()示例。

# 结论

就这样，我们已经在 Dart 中介绍了期货的基础知识。

现在，我们需要更深入地研究它在实时应用程序(如 Flutter 应用程序)中的使用和实现，但我们将在另一篇文章中讨论，因为这应该是一个开始。