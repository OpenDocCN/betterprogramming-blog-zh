<html>
<head>
<title>Exploring Type-Safe Identifiers in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Swift中的类型安全标识符</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/type-safe-identifiers-in-swift-d8eb96da647d?source=collection_archive---------4-----------------------#2022-06-10">https://betterprogramming.pub/type-safe-identifiers-in-swift-d8eb96da647d?source=collection_archive---------4-----------------------#2022-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="68b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用可识别的协议</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/ebb4d9d989c7212bb0659abb49724cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*15zUwZFuN1RzpGZK8Tuq9w.png"/></div></figure></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><blockquote class="ku kv kw"><p id="7a4d" class="kx ky kz la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请注意，这个实现使用了仅在iOS 13+上可用的<code class="fe lu lv lw lx b"><strong class="la ir">Identifiable</strong></code>协议，因此您可能会尝试使用一个“剥离”版本，而没有针对旧系统的特定一致性。</p></blockquote></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><h2 id="98ab" class="ly lz iq bd ma mb mc dn md me mf dp mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">问题是</h2><p id="a0a3" class="pw-post-body-paragraph kx ky iq la b lb mu jr ld le mv ju lg mh mw lj lk ml mx ln lo mp my lr ls lt ij bi translated">简单来说，<em class="kz"> an </em> <em class="kz"> identifier </em>是一个字符序列，对于某一类型的模型是唯一的。</p><p id="6fda" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">例如，如果您的应用程序中有一个用户模型，并且它有一个ID属性，那么可以保证它的值在一组用户模型中不会出现超过一次。</p><p id="197b" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">让我们假设我们正在开发一个社交网络应用程序，用户可以在那里写帖子和发表评论。他们的假设模型是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9098" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">想象一下，出于某种原因，一方面用户拥有<code class="fe lu lv lw lx b">String</code>标识符，另一方面帖子和评论使用整数id。同样，用户没有问题，他们的id是唯一的。</p><p id="d606" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">然而，当涉及到其他模型时，就有一些陷阱。不仅一些帖子的ID可以等于一些评论的ID，我们实际上还可以偶然比较它们。最大的问题是编译器无法帮助我们。</p><p id="0033" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">理想的结果是只能比较兼容的id:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/6f5443ed385359cba2992f3ea905814d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9BscRyohQ0l5stqfu0k9w.png"/></div></div></figure><p id="94bc" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">让我们尝试实现这种行为！</p><h2 id="b2a5" class="ly lz iq bd ma mb mc dn md me mf dp mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">幻影类型</h2><p id="0190" class="pw-post-body-paragraph kx ky iq la b lb mu jr ld le mv ju lg mh mw lj lk ml mx ln lo mp my lr ls lt ij bi translated"><em class="kz"> Generics </em>在Swift中确实非常强大。它们的众多应用之一是能够将它们用作幻影类型。简单地说，当一个类型被声明但没有被任何成员使用时，它就被称为<em class="kz">幻影</em>。</p><p id="c540" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">编译器只需要区分某些容器类型。这种ID容器的最简单实现是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6981" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">有点麻烦，你不觉得吗？这些id的声明和初始化过于冗长。</p><p id="6dde" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">我们甚至不得不为每个模型引入一个伪枚举来使用一个标识符。让我们试着封装实现！</p><h2 id="42b1" class="ly lz iq bd ma mb mc dn md me mf dp mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">改进的解决方案</h2><p id="58fa" class="pw-post-body-paragraph kx ky iq la b lb mu jr ld le mv ju lg mh mw lj lk ml mx ln lo mp my lr ls lt ij bi translated">首先，应该使用ID类型的嵌套类型别名，这样我们就不必知道模型范围之外的ID类型。</p><p id="04b5" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">我只想写一些类似<code class="fe lu lv lw lx b">let post: Post.ID</code>的东西，而不用担心在幕后使用了什么。</p><p id="0527" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">第二，也许有办法摆脱伪枚举？也许:)</p><p id="b6f7" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">第三，让我们简化标识符的初始化。由于有了<code class="fe lu lv lw lx b">ExpressibleBy...</code>协议组，这是可行的。</p><p id="78d7" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">额外收获:我们可以让我们的模型兼容SwiftUI迭代机制，比如<code class="fe lu lv lw lx b">ForEach</code>、<code class="fe lu lv lw lx b">List</code>等。，开箱即用，只需加入<code class="fe lu lv lw lx b">Identifiable</code>协议。</p><p id="b956" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">鉴于上述几点，下面是更新后的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="152c" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">现在，让我们用Swift基本类型的文字表达能力来增强这个解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9552" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">因此，我们可以像下面这样声明我们的模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a45c" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">最终，我们的模型可以这样使用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ng"><img src="../Images/ea9759ab70e7d75b91f2151336a59167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2WkSAZCtGeJfywGLDQDkQ.png"/></div></div></figure><h1 id="acc1" class="nh lz iq bd ma ni nj nk md nl nm nn mg jw no jx mk jz np ka mo kc nq kd ms nr bi translated"><strong class="ak">结论</strong></h1><p id="9f96" class="pw-post-body-paragraph kx ky iq la b lb mu jr ld le mv ju lg mh mw lj lk ml mx ln lo mp my lr ls lt ij bi translated">整洁！这个实现可以用<code class="fe lu lv lw lx b">Decodable</code>和您可能发现自己需要的任何东西来改进，但是这超出了本文的范围。</p><p id="82c7" class="pw-post-body-paragraph kx ky iq la b lb lc jr ld le lf ju lg mh li lj lk ml lm ln lo mp lq lr ls lt ij bi translated">感谢阅读！</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt ns lx nt nu aw nv bi"><span id="9d00" class="ly lz iq lx b gy nw nx l ny nz"><strong class="lx ir">Want to Connect?</strong></span><span id="62dc" class="ly lz iq lx b gy oa nx l ny nz">Follow me on <a class="ae ob" href="https://twitter.com/YBuslovsky" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae ob" href="https://www.linkedin.com/in/yury-buslovsky-70540519b/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae ob" href="https://github.com/yurybuslovsky" rel="noopener ugc nofollow" target="_blank">GitHub</a> and/or <a class="ae ob" href="https://www.reddit.com/user/yury_buslovsky" rel="noopener ugc nofollow" target="_blank">Reddit</a>!</span></pre><div class="oc od gp gr oe of"><a href="https://www.linkedin.com/in/yury-buslovsky-70540519b/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">尤里·布斯洛夫斯基——iOS开发者——阿尔法银行| LinkedIn</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">我开始是一名React原生开发人员，经过6个月的经验，我对iOS原生产生了兴趣…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.linkedin.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kl of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://github.com/yurybuslovsky" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">尤里布斯洛夫斯基-概述</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kl of"/></div></div></a></div></div></div>    
</body>
</html>