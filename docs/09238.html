<html>
<head>
<title>Should I Use Functional Components or Class Components In React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中应该使用功能组件还是类组件？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-i-use-functional-components-or-class-components-in-react-e4b93280aa65?source=collection_archive---------0-----------------------#2021-08-02">https://betterprogramming.pub/should-i-use-functional-components-or-class-components-in-react-e4b93280aa65?source=collection_archive---------0-----------------------#2021-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两个组件之间的最终对峙</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca5ccf374fad2ba4985cb6d4f7178eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQccMeZXkhA0_Ma1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈桑·帕夏在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的一年半时间里，我一直是React JS的开发人员。作为React JS和React Native社区的一员，在脸书和其他平台上，这个问题不断出现，所以我在这里提供一些信息。</p><p id="4b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们先了解React！</p><p id="79b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React JS </a>是一个开源的JavaScript库，它从虚拟DOM中分割出DOM，并在构建web应用程序时带来了一种创新的状态管理方法。逻辑与<a class="ae ky" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> React Native </a>相同，但它更具体地构建移动应用程序。</p><h1 id="f58f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">学习曲线</h1><p id="f012" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要学习React Native，您必须学习React JS。要学习React JS，您需要先了解HTML、CSS和JavaScript。</p><p id="d35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了互联网上的许多社区和指导，这肯定可以很容易地实现。</p><p id="8735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React JS和React Native是唯一的移动和web应用吗？</p><p id="c88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要！还有其他几个库和框架可以用来构建移动和web应用，分别是<a class="ae ky" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank"> Flutter </a>和<a class="ae ky" href="https://angular.io/docs" rel="noopener ugc nofollow" target="_blank"> Angular </a>。</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/react-native-vs-flutter-a-decision-pending-in-2020-65bf5835c8ed"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">反应本土与颤振:2020年待定的决定</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">你应该学哪一个？</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">better编程. pub</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><h1 id="bc90" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">React为什么叫“React”</h1><p id="85bd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在React中，我们用基于组件的方法构建应用程序。这仅仅意味着我们将UI分割成更小的独立组件，然后将它们组合起来构建复杂的UI。</p><p id="c2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件是用JavaScript类、状态和呈现方法实现的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态是我们在呈现组件时想要显示的数据。render方法呈现用户界面，它通常有HTML或JSX代码。</p><p id="845b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">render方法返回一个映射到DOM元素的JavaScript对象。React在内存中保留了DOM的轻量级表示，我们称之为虚拟DOM <strong class="lb iu"> <em class="nm">。</em>T15】</strong></p><p id="3fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们改变一个组件的状态时，我们会得到一个新的React元素。React然后将虚拟DOM中的这个元素与实际DOM进行比较，并更新实际DOM以保持同步。因此，我们不需要像使用普通JavaScript或JQuery那样在浏览器中使用DOM API。</p><p id="9c32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这就是React被称为“React”的原因——它通过将虚拟DOM与实际DOM进行比较来检测虚拟DOM中的变化，并通过分别更新实际DOM来对其做出反应。</p><h1 id="6a88" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最终的僵局</h1><p id="acbc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">随着类组件和函数组件成为最近几天的热门话题，以及react开发社区之间的激烈辩论，许多开发人员在开发react应用程序时都不确定使用哪一个。</p><p id="5953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在下面提到的标准下，这里有一个独特的比较来突出两个组成部分的优势和均衡。</p><h2 id="0ea8" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">句法</h2><p id="4132" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">编写函数组件和类组件时的语法非常不同。由于名字本身定义了单词，功能组件就像编写一个简单的JavaScript函数，而类组件就像编写一个JavaScript类。下面是一个函数的例子:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="b415" class="nn lw it oa b gy oe of l og oh">export default function Welcome(props) {<br/>  <!-- -->return(<br/>      // code to display ui<br/>  )<br/>}</span></pre><p id="86a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">功能组件</strong>是字面上简单的JavaScript函数，如上图所示。return函数显示通常是JSX表达式或原始HTML代码的UI代码。它是一个有效的React组件，因为您可以向它传递属性。下面是一个类的例子:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="e11b" class="nn lw it oa b gy oe of l og oh">export default class Welcome extends Component {    <br/>    constructor(props){<br/>        super(props);<br/>        this.state = {}<br/>    }<br/>        render(){<br/>        return(<br/>            // code to display ui<br/>        )<br/>     }<br/>}</span></pre><p id="dcf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类组件</strong>有简单<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> ES6 </a> JavaScript类的语法，如上图。render方法呈现return()函数中的用户界面。它由一个构造函数和一个呈现方法组成。</p><h2 id="fa3b" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">传递道具</h2><p id="5891" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">处理道具在职业组件和功能组件上差别很大。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类组件</strong>就是简单的ES6 JavaScript类。因此，正如您在上面看到的，props被传递到基本构造函数中。可以通过下面的表达式在类组件中访问和使用props:<code class="fe oi oj ok oa b">{this.props.&lt;propertyName&gt;}</code>。</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="23bf" class="nn lw it oa b gy oe of l og oh">function Welcome(props) {<br/>  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br/>}</span></pre><p id="4f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">功能组件</strong>接受“props”作为唯一参数，所以可以将属性作为props传递。但是如果你想传递复杂的属性，你可以通过析构它们来实现。</p><p id="a98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您想要传递一个具有属性<code class="fe oi oj ok oa b">title</code>和<code class="fe oi oj ok oa b">name</code>的用户对象，它将如下所示:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="4bd4" class="nn lw it oa b gy oe of l og oh">function Welcome({user}) {<br/>  return &lt;h1&gt;Hello, <!-- --> &lt;h1&gt;Hello , {user.title, " ", user.name}&lt;/h1&gt;;<br/>}</span></pre><p id="764b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们已经解构了道具，所以我们可以通过使用<code class="fe oi oj ok oa b">propName.attribute</code>在函数中的任何地方访问它们。</p><p id="9b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将属性传递到组件中，不管它们是类组件还是功能组件，都是这样完成的:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="8afa" class="nn lw it oa b gy oe of l og oh">&lt;Welcome name = "John" /&gt;</span></pre><h2 id="9f73" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">管理状态</h2><p id="d99b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如上所述，状态管理是React的主要内容之一。类组件<strong class="lb iu"> </strong>密集支持状态管理。它可以管理复杂的状态对象。类中的构造函数不仅有props，还分配了初始的<code class="fe oi oj ok oa b">this.state</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将状态分配到一个类组件中，您需要定义一个构造函数，然后由它分配初始状态。这些属性被传递到基构造函数中。</p><p id="3ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当组件具有从零到最小状态管理时，使用功能组件。</p><p id="c809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当编写一个功能组件，并且您意识到您需要添加一个状态时，您不必将整个组件转换成一个类组件。您可以简单地使用React <code class="fe oi oj ok oa b">useState()</code>钩子来实现这一点，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe oi oj ok oa b">Counter</code>组件显示了按钮被点击的次数。</p><p id="754b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok oa b">useState</code>钩子可以从‘React’导入。使用<code class="fe oi oj ok oa b">useState</code>钩子，它由三个主要部分组成:</p><ul class=""><li id="df0f" class="ol om it lb b lc ld lf lg li on lm oo lq op lu oq or os ot bi translated">状态变量</li><li id="8ee9" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">更新状态的函数</li><li id="280d" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">初始状态变量</li></ul><p id="e30a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok oa b">useState()</code>只能带一个自变量，我们称之为<em class="nm">初始状态</em>。这个初始状态可以是任何东西:数字、字符串、对象、数组等等。有关管理功能组件状态的更多信息，请参考下面的故事:</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-use-reacts-usestate-hook-ee0dc6da54f8"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">如何使用React的useState()钩子</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">从类到功能组件的状态管理</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">better编程. pub</p></div></div><div class="ne l"><div class="oz l ng nh ni ne nj ks mv"/></div></div></a></div><h2 id="50a5" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">生命周期方法</h2><p id="ffc6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">类组件</strong>有以下<a class="ae ky" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">生命周期</a>方法。</p><ul class=""><li id="79a9" class="ol om it lb b lc ld lf lg li on lm oo lq op lu oq or os ot bi translated"><code class="fe oi oj ok oa b">componentDidMount()</code> —该方法在组件安装后立即触发。一个完美的例子是将数据从API fetch调用加载到归档页面。这种方法非常适合设置任何订阅，即初始状态。但是，当要卸载组件时，需要取消订阅。</li><li id="2475" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><code class="fe oi oj ok oa b">componentDidUpdate()</code> —初始渲染时不调用此方法。但是，每当组件更新，并且状态或道具发生变化时，就会触发此方法。该函数中的逻辑必须包装在if条件中。这就是更新的道具和之前的道具对比的地方。</li><li id="8098" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><code class="fe oi oj ok oa b">componentWillUnmount()</code> — <strong class="lb iu"> </strong>该方法在组件被卸载和销毁之前触发。它清除任何“垃圾”，如无效计时器、取消网络请求或任何订阅。因此，避免了内存泄漏。</li></ul><p id="22b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">功能组件</strong>使用<code class="fe oi oj ok oa b">useEffect()</code>挂钩来实现。钩子是<a class="ae ky" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> React 16.8 </a>的新增。React <code class="fe oi oj ok oa b">useEffect()</code>钩子类似于<code class="fe oi oj ok oa b">componentDidMount()</code>、<code class="fe oi oj ok oa b">componentDidUpdate()</code>和<code class="fe oi oj ok oa b">componentWillUnmount() </code>的总和。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是使用<code class="fe oi oj ok oa b">useEffect</code>挂钩的简单<a class="ae ky" href="https://reactjs.org/docs/hooks-effect.html#detailed-explanation" rel="noopener ugc nofollow" target="_blank">示例</a>。</p><h2 id="89a6" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">表演</h2><p id="a7b5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然功能组件只是JavaScript函数，类组件是JavaScript类，但没有证据表明功能组件比类组件性能更好。</p><p id="a350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，功能组件被认为是轻量级的，因为要编译的代码比类组件少得多。说到更少的代码，阅读和测试相对更容易。</p><p id="4ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着React团队最近致力于<a class="ae ky" href="https://reactjs.org/blog/2015/10/07/react-v0.14.html#stateless-functional-components" rel="noopener ugc nofollow" target="_blank">优化</a>功能组件，我们相信功能组件会比类组件有更好的贡献。</p><p id="ea88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包装纸还没有揭开！</p><h2 id="1f3e" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">测试</h2><p id="fee6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">功能组件比类组件更容易测试，因为它们只是JavaScript函数。使用功能组件编写测试用例并执行测试要方便得多。</p><p id="a2f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jest 是执行测试的推荐框架。同样，我们可以使用<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> React测试库</a>来执行测试。他们表现不同。更多信息，请参考<a class="ae ky" href="https://reactjs.org/docs/testing.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="938b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把这部分留给另一个故事，因为这超出了范围。</p><h1 id="2a76" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用哪一个</h1><p id="86a8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">然而，只使用功能组件就像遵循过程化编程一样；使用类组件是遵循OOP。因此，功能组件可能更容易实现。有些可能偏向于使用类组件或其他。然而，事实并非如此。</p><p id="801b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类组件和功能组件都有它们的好处。有些人可能对这个问题有偏见。那么，你选哪个？</p><p id="3416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问你自己这个问题:这个组件有某种状态吗？</p><p id="9da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<em class="nm">是</em>，用类组件实现。否则，用功能组件实现它。将两者结合使用，实现更有效的应用。</p><h1 id="79e0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="004c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">观点必然会随着时间而改变，但事实不会！所以，让我们不要让偏见影响我们的决策。</p><blockquote class="pa"><p id="2d53" class="pb pc it bd pd pe pf pg ph pi pj lu dk translated">有时候，解决方案不是选项1或选项2。有时候你只是创造了一个最好的选择3(混合)。~放开我</p></blockquote><p id="0d01" class="pw-post-body-paragraph kz la it lb b lc pk ju le lf pl jx lh li pm lk ll lm pn lo lp lq po ls lt lu im bi translated">以上提供的事实是我基于个人研究的不带偏见的比较。因此，我的结论是，同时使用功能组件和类组件是最佳和最有效的方法。</p><p id="a84f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分享知识是获得知识的唯一途径。欢迎在评论区贡献你自己的一些想法。</p><p id="4d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">玩得开心！享受编码！</p></div></div>    
</body>
</html>