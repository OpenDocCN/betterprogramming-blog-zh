<html>
<head>
<title>Hack and Automate! Gathering Pull Request Statistics From GitHub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑客和自动化！从GitHub收集拉请求统计信息</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hack-and-automate-scripting-pull-request-statistics-from-github-3e949ebd5faa?source=collection_archive---------8-----------------------#2019-11-24">https://betterprogramming.pub/hack-and-automate-scripting-pull-request-statistics-from-github-3e949ebd5faa?source=collection_archive---------8-----------------------#2019-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3cbe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有时候，快速修改的脚本比完美的代码更有趣</h2></div><p id="be46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人惊讶的是，我最喜欢的职业是<em class="lb">而不是</em>设计需要处理数千个并发请求的超级复杂系统。</p><p id="7f70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是编写小的、大多是粗糙的脚本来解决和自动化我遇到的简单的日常问题。</p><p id="fbfc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的一个月里，我开始对我们团队中处理的代码审查的数量以及一个简单的事实感兴趣，即在我们的计划中，它不一定被计划和划分为一个工作负载。</p><p id="4cc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">知道你要做多少工作，并估计所需的努力是敏捷方法的基石之一。要真正理解它，需要实际的数据和统计，并且您可能会猜到手工计算拉取请求是不可能的。</p><p id="d2a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我欢迎你和我一起，利用<a class="ae lc" href="https://developer.github.com/v3/pulls/" rel="noopener ugc nofollow" target="_blank"> GitHub API </a>，简单回顾一下我使用Ruby的四小时黑客之旅。我们将从“只是一个想法”到我们团队的拉请求负载的具体统计。</p><p id="e082" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我并不认为建议的解决方案是最优的，但是它确实有效，并为我提供了我需要的数据。我希望这篇短文能启发你使用可用的API来做一些很酷的事情。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="5bf8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">开始:认证</h1><p id="ea7f" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我们从创建一个<a class="ae lc" href="https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line" rel="noopener ugc nofollow" target="_blank">个人访问令牌</a>开始，即使在早期我也有一些问题。</p><p id="294d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该注意到，出于良好的安全相关原因，当我创建的令牌没有足够的权限时，GitHub API不会返回401未授权响应。相反，<a class="ae lc" href="https://developer.github.com/v3/troubleshooting/" rel="noopener ugc nofollow" target="_blank">它返回含糊的“404未找到”响应</a>。</p><p id="d54e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我花了一段时间才明白我调用了正确的端点，只是使用了一个权限不足的令牌。因此，创建一个具有更多权限的新令牌帮助我通过了第一个障碍。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="5bcc" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">脚本101和Github API 101</h1><p id="dc33" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">大多数时候，我需要写一些我不熟悉的东西，我只是开始玩结果。所以我做的第一件事是执行对拉请求API的调用并得到结果。这个简短的脚本涵盖了它:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">从GitHub API获取一个拉请求</p></figure><p id="d5ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地理解结果，您可以使用<a class="ae lc" href="https://developer.github.com/v3/pulls/" rel="noopener ugc nofollow" target="_blank"> API文档</a>，或者通过打印结果散列的键并使用它来熟悉结果。这就是我所做的，因为这比阅读文档有趣得多。</p><p id="ad33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我知道了单个拉请求的结果是什么样的，那么是时候弄清楚如何获得所有的结果了。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="f488" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">页码</h1><p id="c5d5" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">熟悉web APIs并知道GitHub可能正确地实现了它，我知道我将使用<a class="ae lc" href="https://developer.github.com/v3/guides/traversing-with-pagination/" rel="noopener ugc nofollow" target="_blank">分页</a>——通常，它在标题中。<br/>幸运的是，GitHub真的让我们开发人员很容易做到这一点，我们可以浏览我们持有的当前响应页面。</p><p id="2f78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很容易地提取下一页的端点:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">从当前结果解析下一页URL</p></figure><p id="16af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对由此方法提取的端点执行HTTP GET请求将返回下一页结果。</p><p id="4dd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在准备尝试并实现从GitHub获取pull请求数据的完整过程。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="048c" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">尝试1:如此接近，却又如此遥远</h1><p id="f154" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我最初的设计非常简单:</p><ol class=""><li id="21a6" class="ms mt iq kh b ki kj kl km ko mu ks mv kw mw la mx my mz na bi translated">从<a class="ae lc" href="https://developer.github.com/v3/pulls/#list-pull-requests" rel="noopener ugc nofollow" target="_blank">的拉取请求API </a>获取过去一个月的所有拉取请求。</li><li id="6e6a" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">放弃所有与我的团队无关的请求。</li><li id="a6fa" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">对于每个拉取请求，获取请求的审阅者列表。</li></ol><p id="8eb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个设计的问题是，当我在我们团队的主回购上执行我的脚本后，结果说我们几乎没有审查任何东西，我知道这不是真的，因为这次冒险的催化剂是量化和测量我们已经很大的审查工作量。</p><p id="0717" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原因是当一个评审者接受评审请求时，<a class="ae lc" href="https://stackoverflow.com/questions/44965073/how-do-i-get-the-list-of-reviewers-for-a-pull-request-using-github-api" rel="noopener ugc nofollow" target="_blank">它们被pull请求的被请求评审者</a>丢弃。那真是令人失望，给我留下了白白浪费周末下午的坏印象。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="acf7" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">尝试2:利用时间轴API</h1><p id="c501" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">这需要一些挖掘，但GitHub不久前发布了一个新的预览API—<a class="ae lc" href="https://developer.github.com/v3/issues/timeline/" rel="noopener ugc nofollow" target="_blank">时间轴API </a>。本质上，它是您在拉请求的主页上看到的内容，对我来说，这意味着我可以找到作者请求用户审阅的事件:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/c7413188715004ee63c868f20b6bf451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGushCvkCOlJuiXWi4BSYg.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">问题时间表示例</p></figure><p id="7a1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它是一个预览API，所以我需要在我的HTTP GET请求中添加一个accept头来实现这个功能:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">预览标题</p></figure><p id="9bb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的工作设计变成了:</p><ol class=""><li id="dbef" class="ms mt iq kh b ki kj kl km ko mu ks mv kw mw la mx my mz na bi translated">从<a class="ae lc" href="https://developer.github.com/v3/pulls/#list-pull-requests" rel="noopener ugc nofollow" target="_blank">拉请求API </a>获取上个月的所有拉请求。</li><li id="00b0" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">放弃所有与我的团队无关的请求。</li><li id="be65" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">对于每个拉取请求，从<a class="ae lc" href="https://developer.github.com/v3/issues/timeline/" rel="noopener ugc nofollow" target="_blank">时间线API </a>获取发布时间线。</li><li id="14bd" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">从时间轴中，获取类型为<code class="fe nn no np nq b">review_requested</code>的事件。</li><li id="31bd" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">算上审稿人。</li><li id="a4fc" class="ms mt iq kh b ki nb kl nc ko nd ks ne kw nf la mx my mz na bi translated">利润！</li></ol><p id="99d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在给脚本运行几分钟后，我得到了我的团队的评审负载统计数据。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="061b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">结果呢</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nr"><img src="../Images/e95b9c583c46a96a8b60f40b85ca26f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSnjFbboHX94F3j4F109LA.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">每个团队成员的代码审查——我设法收集的度量之一</p></figure><p id="50a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的截图中，您可以看到每个团队成员的评审指标。正如所怀疑的，我们正在做大量的代码审查，现在我们可以估计工作量并将其添加到我们的春季计划中。另一个意想不到的发现是审查工作量分布不均匀——有了数据，我们可以解决这个问题。</p><p id="826a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在度过了一个有趣的周六下午编写这个解决方案后，我们的一个团队领导展示了一个更健康的解决方案:<a class="ae lc" href="https://pullreminders.com/" rel="noopener ugc nofollow" target="_blank">拉提醒</a>。挺牛逼的。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="d6b0" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">最后的想法</h1><p id="2e17" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">现在来看一个不可避免的问题:我们能用这些指标做什么？为什么我把一半的周末都花在了黑客上(除了超级有趣之外)？</p><p id="52be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我重复我自己，现在我们可以量化(从真实数据和真实数字)我们正在做多少审查，因为代码质量、标准和知识共享并不便宜，我们可以将其添加到我们的sprint估计中——并且在我们的交付估计中更加准确。</p><p id="78bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，我们可以在sprint <strong class="kh ir"> </strong>期间测量这些指标，并确保工作负载均匀分布——并且不会产生评审/知识瓶颈。</p><p id="a445" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以为我们团队对代码质量的协作和奉献感到非常高兴——我们都在其他人的代码上投入了大量的时间。</p><h1 id="ae34" class="lk ll iq bd lm ln ns lp lq lr nt lt lu jw nu jx lw jz nv ka ly kc nw kd ma mb bi translated">完整代码</h1><p id="388e" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">至于我用的<a class="ae lc" href="https://gist.github.com/borischerkasky/7acc8b19e7b5c6b044bf92ab6f467126" rel="noopener ugc nofollow" target="_blank">全剧本</a>，就这样吧:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">完整的统计计算脚本</p></figure></div></div>    
</body>
</html>