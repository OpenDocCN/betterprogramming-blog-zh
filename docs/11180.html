<html>
<head>
<title>SQL Query Optimization: Level Up Your SQL Performance Tuning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL查询优化:提升您的SQL性能调优</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sql-query-optimization-level-up-your-sql-performance-tuning-d93af175b24b?source=collection_archive---------2-----------------------#2022-02-24">https://betterprogramming.pub/sql-query-optimization-level-up-your-sql-performance-tuning-d93af175b24b?source=collection_archive---------2-----------------------#2022-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="53aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">增强您对生产数据系统的SQL查询</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/206d5c4c42ac24fec46ea73f7e03e50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kn2d699zQmsKr_Q9fdMOPw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://pixabay.com/vectors/database-schema-data-tables-schema-1895779/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/vectors/database-schema-data-tables-schema-1895779/</a></p></figure><p id="8e18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据是任何应用程序不可或缺的一部分。应该以最快的方式访问数据，以增强用户在使用应用程序时的体验。</p><h1 id="746c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么还需要查询优化？</h1><p id="6442" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">SQL是目前最强大的数据处理工具之一。然而，SQL是一种声明性语言，即每个查询都声明了<em class="mp">我们希望SQL引擎做什么</em>，但没有说<em class="mp">如何做</em>。然而，事实证明,<em class="mp">如何</em>——“计划”——才是影响查询效率的因素，所以这非常重要。</p><p id="dcbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">效率低下的查询会耗尽生产数据库的资源，并且如果查询包含错误，会导致其他用户的性能下降或服务丢失。优化查询以将对数据库性能的影响降至最低是至关重要的。</p><p id="086c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有一步一步的指南。反过来，我们必须使用编写查询的一般准则，使用哪些操作符。然后检查“执行计划”，找出查询中花费时间最多的部分，并以其他方式重写该部分。</p><h1 id="eacf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">查询优化的好处</h1><ul class=""><li id="5483" class="mq mr iq ky b kz mk lc ml lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">最大限度地减少生产问题:</strong>低效的查询需要大量的CPU、内存和I/O操作，这些操作通常会导致死锁、事务失败、系统挂起和其他生产问题。</li><li id="3664" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">性能问题:</strong>慢速查询意味着使用查询的应用程序的响应时间较慢，这会导致较差的用户体验。</li><li id="e00a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">节省基础设施成本:</strong>由于非优化查询需要更多的CPU和内存，因此会导致更高的基础设施成本。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/ab61896cd3f9c8e1e0d19eb52e37ea67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*INggZmho0kWx6Rhb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克劳迪奥·施瓦茨在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5992" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">查询优化最佳实践</h1><ul class=""><li id="8769" class="mq mr iq ky b kz mk lc ml lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">明智地选择数据类型:</strong>与使用<code class="fe nf ng nh ni b">char(10)</code>存储固定长度数据相比，使用<code class="fe nf ng nh ni b">Varchar(10)</code>存储固定长度数据(如手机号码)会导致20%的查询执行损失。</li><li id="7446" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">避免使用隐式转换:</strong>当查询比较不同的数据类型时，它使用隐式数据类型转换。因此，在查询中，应该避免比较不同数据类型的列和值，例如:</li></ul><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="d8d6" class="nn lt iq ni b gy no np l nq nr">WHERE date &gt;= "2022-01-01"</span></pre><ul class=""><li id="accb" class="mq mr iq ky b kz la lc ld lf ns lj nt ln nu lr mv mw mx my bi translated"><strong class="ky ir">避免使用基于函数的条件子句:</strong>当查询在列的<code class="fe nf ng nh ni b">WHERE</code>或<code class="fe nf ng nh ni b">JOIN</code>子句中使用函数时，它不会利用索引，因此会降低执行速度。</li></ul><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="6be8" class="nn lt iq ni b gy no np l nq nr">-- WHERE date(ship_date) = '2022–01–01'</span><span id="8323" class="nn lt iq ni b gy nv np l nq nr">-- JOIN T2 ON CONCAT(first_name,' ',last_name) = 'garvit arya'</span></pre><ul class=""><li id="d0c0" class="mq mr iq ky b kz la lc ld lf ns lj nt ln nu lr mv mw mx my bi translated"><strong class="ky ir">避免同时使用</strong> <code class="fe nf ng nh ni b"><strong class="ky ir">DISTINCT</strong></code> <strong class="ky ir">和</strong><code class="fe nf ng nh ni b"><strong class="ky ir">GROUP BY</strong></code><strong class="ky ir">:</strong>如果您的查询中已经有了<code class="fe nf ng nh ni b">GROUP</code> BY，就没有必要再单独拥有<code class="fe nf ng nh ni b">DISTINCT</code>。</li><li id="aa5b" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">避免同时使用</strong> <code class="fe nf ng nh ni b"><strong class="ky ir">UNION DISTINCT</strong></code> <strong class="ky ir">和</strong><code class="fe nf ng nh ni b"><strong class="ky ir">SELECT DISTINCT</strong></code><strong class="ky ir">:</strong>对于具有UNION DISTINCT的查询，它会自动删除重复记录，因此不需要使用SELECT DISTINCT。</li><li id="1f9c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">永远不要使用</strong><code class="fe nf ng nh ni b"><strong class="ky ir">SELECT *</strong></code><strong class="ky ir">:</strong>选择不必要的列会浪费内存和CPU周期。选择列名总是比选择*或额外的列更好。</li><li id="8d02" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">尽可能避免子查询:</strong>子查询创建临时表来存储数据，有时它会在磁盘上创建临时表，从而降低查询的执行速度。优先使用WITH子句而不是嵌套子查询。</li><li id="847c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">避免在子查询中使用Order by:</strong>子查询中的排序大多是多余的，会导致严重的性能问题。</li><li id="b2e4" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">不要</strong> <code class="fe nf ng nh ni b"><strong class="ky ir">GROUP</strong></code> <strong class="ky ir">数字:</strong>避免按DOUBLE或FLOAT类型的列分组，因为这可能会由于舍入&amp;精度问题而导致意外行为。</li><li id="b940" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">尽量少用</strong> <code class="fe nf ng nh ni b"><strong class="ky ir">SELF</strong></code> <strong class="ky ir">连接:</strong>自连接计算量更大，在许多情况下可以用窗口函数代替。</li><li id="5703" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">不要用OR条件连接表:</strong>可以通过使用<code class="fe nf ng nh ni b">UNION ALL</code>代替基于<code class="fe nf ng nh ni b">OR</code>的连接进行优化。</li><li id="7a34" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">避免使用不等条件连接:</strong>当查询使用<code class="fe nf ng nh ni b">NOT EQUAL</code>操作符连接时，它会搜索所有行，并使用效率非常低的全表扫描。</li><li id="f9cf" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">避免全文搜索:</strong>当查询搜索开头带有通配符的关键字时，它不使用索引，数据库的任务是在所选字段内的任何位置搜索所有匹配的记录。因此，如果需要，最好只在短语末尾使用通配符。</li></ul><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="f228" class="nn lt iq ni b gy no np l nq nr">SELECT user_name</span><span id="a55c" class="nn lt iq ni b gy nv np l nq nr">FROM test</span><span id="8ba5" class="nn lt iq ni b gy nv np l nq nr">WHERE user_name LIKE '%abc%'</span></pre><ul class=""><li id="9476" class="mq mr iq ky b kz la lc ld lf ns lj nt ln nu lr mv mw mx my bi translated">用<code class="fe nf ng nh ni b">WHERE</code>代替<code class="fe nf ng nh ni b">HAVING</code>:最好用<code class="fe nf ng nh ni b">where</code>代替<code class="fe nf ng nh ni b">having</code>，因为<code class="fe nf ng nh ni b">HAVING</code>语句是在<code class="fe nf ng nh ni b">WHERE</code>语句之后计算的。</li><li id="d981" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe nf ng nh ni b">IN</code>与<code class="fe nf ng nh ni b">EXISTS</code>相比:<code class="fe nf ng nh ni b">IN</code>操作符在扫描方面比<code class="fe nf ng nh ni b">EXISTS</code>开销更大，尤其是当子查询的结果是一个大型数据集时。</li></ul><h1 id="7ae1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的想法</h1><p id="fc0d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">理解执行计划和优化SQL查询可能会很乏味，需要一段时间来学习。我已经使用SQL好几年了，并且还在不断学习新的技术！</p><p id="a46c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您努力遵循上面详细介绍的查询优化技术，您可以受益于查询性能的提高、更少的生产问题以及通过最小化资源来节省成本。</p><p id="6683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试试这些技巧，并在下面的评论区让我知道它们对你有多有效！</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="9271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望，这篇短文对你有用。感谢您的阅读！</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="e2dd" class="nn lt iq ni b gy no np l nq nr"><strong class="ni ir">Want to Connect?</strong></span><span id="f325" class="nn lt iq ni b gy nv np l nq nr">You can reach out to me at — <a class="ae kv" href="https://www.linkedin.com/in/garvitarya/" rel="noopener ugc nofollow" target="_blank">Linkedin</a> | <a class="ae kv" href="https://twitter.com/garvitishere" rel="noopener ugc nofollow" target="_blank">Twitter</a> | <a class="ae kv" href="https://github.com/GarvitArya/" rel="noopener ugc nofollow" target="_blank">Github</a>.</span></pre></div></div>    
</body>
</html>