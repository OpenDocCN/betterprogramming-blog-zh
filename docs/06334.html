<html>
<head>
<title>Functional Programming in Java, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的函数式编程，解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-in-java-explained-ae396e9e516f?source=collection_archive---------7-----------------------#2020-09-22">https://betterprogramming.pub/functional-programming-in-java-explained-ae396e9e516f?source=collection_archive---------7-----------------------#2020-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d06e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Java中的函数式编程，带示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87e8179369a3ec7f292bde7c55925716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PWEEYWS36PGaTJwkFcWqQ.png"/></div></div></figure><p id="f59d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您是一名Java开发人员，我敢肯定您至少见过一次类似于上面代码片段的代码。上面片段中的代码是Java中函数式编程范例实现的一个例子，它将过滤请求中的<code class="fe lq lr ls lt b">List&lt;String&gt;</code>并将其转换为另一个<code class="fe lq lr ls lt b">List&lt;String&gt;</code>。</p><p id="ce13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将讲述如何使用Java的API编写函数式编程代码。最后，我们将编写自己的流API，这样我们就可以理解如何用Java实现函数式编程风格。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="810d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Java中的函数式编程</h1><p id="30a7" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">Java中的函数式编程已经存在很长时间了。当甲骨文在2014年发布Java 8时，他们引入了<a class="ae my" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank"> lambda表达式</a>，这是Java中函数式编程的核心特性。</p><p id="08e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子，说明在Java中使用命令式语句序列和使用函数式风格之间的区别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">命令式声明代码示例</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">函数式代码示例</p></figure><p id="0770" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所看到的，尽管两段代码实现了相同的结果，但差异是显著的。与函数式代码相比，命令式声明代码有很多花括号，而且更长，这使得它更难阅读。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5479" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">功能接口注释</h1><p id="95a9" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">为了理解函数式编程在Java中是如何工作的，首先我们需要看看Java 8 SDK中的注释，<code class="fe lq lr ls lt b">@FunctionalInterface</code>。我们可以在<a class="ae my" href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" rel="noopener ugc nofollow" target="_blank"> Java API文档网站</a>上看看。</p><p id="2e30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从API文档中，我们可以看到Java中函数接口注释的行为有:</p><ul class=""><li id="0861" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp nk nl nm nn bi translated">它只有一个抽象方法。</li><li id="8e07" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated">它可以有多个方法，只要只有一个抽象方法。</li><li id="643e" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated">我们只能加到<code class="fe lq lr ls lt b">Interface</code>型。</li><li id="2400" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated">我们可以用lambda表达式、方法引用或构造函数引用来创建函数接口。</li><li id="3478" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated">我们不需要定义<code class="fe lq lr ls lt b">@FunctionalInterface</code>，因为编译器会把任何符合函数接口定义的接口都当作函数接口。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="836b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">创建功能接口类</h1><p id="fe17" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在我们知道了什么是功能界面，我们可以自己创建它了。</p><p id="9b0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们先来创建一个名为<code class="fe lq lr ls lt b">Person</code>的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="24a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于函数接口，我们将创建<code class="fe lq lr ls lt b">PersonFunctionalInterface </code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="048f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，接口中有两个方法，但是由于只有一个抽象方法，<code class="fe lq lr ls lt b">PersonFunctionalInterface</code> class作为函数接口是有效的。</p><p id="02db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是假设我们定义了不止一个抽象方法，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="10c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将产生一个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="649a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">使用功能界面</h1><h2 id="fc86" class="nt mc it bd md nu nv dn mh nw nx dp ml ld ny nz mn lh oa ob mp ll oc od mr oe bi translated">匿名类</h2><p id="44ba" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们先来了解一下匿名类。Java <a class="ae my" href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#:~:text=Anonymous%20classes%20enable%20you%20to,do%20not%20have%20a%20name" rel="noopener ugc nofollow" target="_blank">文档</a>说:</p><blockquote class="of og oh"><p id="2ebb" class="ku kv oi kw b kx ky ju kz la lb jx lc oj le lf lg ok li lj lk ol lm ln lo lp im bi translated">匿名类使您的代码更加简洁。它们使您能够同时声明和实例化一个类。除了没有名字之外，它们类似于本地类。如果只需要使用一次局部类，请使用它们。</p></blockquote><p id="8756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，有了匿名类，我们就不必定义一个实现我们制作的接口的类。我们可以创建一个没有名字的类，并将它存储在一个变量中。</p><p id="8e34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以声明一个匿名类为例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b823" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里所做的是创建了一个匿名类，类型为<code class="fe lq lr ls lt b">PersonFunctionalInterface</code>，名字为<code class="fe lq lr ls lt b">anonClassExample</code>。</p><p id="a313" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们覆盖了<code class="fe lq lr ls lt b">createPerson</code>抽象方法，因此当我们调用该方法时，它将返回一个带有名称的新的Person对象。</p><p id="adb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们调用<code class="fe lq lr ls lt b">anonClassExample.createPerson(“Hello, World”)</code>时，我们基本上只是创建了一个名为“你好，世界”的新人物对象。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="13ca" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">创建带有函数接口的匿名类</h1><p id="694c" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们可以开始为我们制作的函数接口创建匿名类<code class="fe lq lr ls lt b">PersonFunctionalinterface</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f57f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们刚刚实现了功能接口！</p><p id="f2e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，我们以不同的方式创建了三个匿名类。请记住，匿名类的行为是，我们可以用lambda表达式、方法引用或构造函数引用来创建函数接口。</p><p id="b3cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了确保我们创建了行为相同的匿名类，我们断言接口中的每个方法。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8e08" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Java 8中的内置函数接口</h1><p id="4ff3" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">Java 8在<code class="fe lq lr ls lt b">java.util.function</code>包中有很多内置的函数接口类，我们可以在<a class="ae my" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">它的文档</a>中看到。</p><p id="dd07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将只解释四个最常用的函数接口，但是如果您对更多感兴趣，可以在上面提到的Java API文档中阅读。</p><ul class=""><li id="4888" class="nf ng it kw b kx ky la lb ld nh lh ni ll nj lp nk nl nm nn bi translated"><code class="fe lq lr ls lt b">Consumer&lt;T&gt;</code>:接受对象不返回任何东西的函数接口。</li><li id="b8bb" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><code class="fe lq lr ls lt b">Producer&lt;T&gt;</code>:不接受任何东西，返回一个对象的函数接口。</li><li id="2c05" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><code class="fe lq lr ls lt b">Predicate&lt;T&gt;</code>:接受对象并返回布尔值的函数接口。</li><li id="6ced" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp nk nl nm nn bi translated"><code class="fe lq lr ls lt b">Function&lt;T, R&gt;</code>:接受一个对象，返回另一个对象的函数接口。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="957c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">常见用法</h1><p id="08c1" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">如果你已经用Java开发了很多，那么你可能已经了解了函数接口的概念。</p><h2 id="98c9" class="nt mc it bd md nu nv dn mh nw nx dp ml ld ny nz mn lh oa ob mp ll oc od mr oe bi translated">流和可选API</h2><p id="6fe9" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">Java的流API大量使用函数接口，我们可以在下面的代码中看到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1bf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">filter</code>方法有一个参数<code class="fe lq lr ls lt b">Predicate&lt;T&gt;</code>功能接口。正如我们所见，该方法接受了一个<code class="fe lq lr ls lt b">String</code>，并产生了一个<code class="fe lq lr ls lt b">boolean</code>。</p><p id="e34c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">map </code>方法使用<code class="fe lq lr ls lt b">Function&lt;T, R&gt;</code>作为其参数。它接受一个<code class="fe lq lr ls lt b">String</code>并返回<code class="fe lq lr ls lt b">String</code>。</p><p id="489f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Stream中的<code class="fe lq lr ls lt b">forEach</code>方法和可选的<code class="fe lq lr ls lt b">ifPresent</code>方法接受<code class="fe lq lr ls lt b">Consumer&lt;T&gt;</code>，接受一个<code class="fe lq lr ls lt b">String</code>，不返回任何东西。</p><h2 id="63be" class="nt mc it bd md nu nv dn mh nw nx dp ml ld ny nz mn lh oa ob mp ll oc od mr oe bi translated">反应库</h2><p id="a474" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">两个最流行的Java反应库，<a class="ae my" href="https://github.com/ReactiveX/RxJava/wiki#:~:text=RxJava%20is%20a%20Java%20VM,programs%20by%20using%20observable%20sequences." rel="noopener ugc nofollow" target="_blank"> RxJava </a>和<a class="ae my" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> Reactor </a>，都基于Java 8 Streams API，这意味着它们也在代码中使用函数接口。</p><p id="035d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们看一下<a class="ae my" href="https://projectreactor.io/docs/core/release/api/" rel="noopener ugc nofollow" target="_blank"> Reactor的Flux API文档</a>和<a class="ae my" href="http://reactivex.io/RxJava/javadoc/" rel="noopener ugc nofollow" target="_blank"> RxJava的Observable API文档</a>，我们可以看到他们的许多方法都接受了函数接口。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7dde" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">创建我们自己的流API</h1><p id="e4f2" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在我们知道了如何创建和使用功能接口，让我们尝试创建我们自己的流API，这样我们就可以了解如何实现功能接口。</p><p id="4ca1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，我们的流式API比Java的简单得多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5bf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和一个测试类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d22f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，我们一个一个来讨论方法。</p><h2 id="f34c" class="nt mc it bd md nu nv dn mh nw nx dp ml ld ny nz mn lh oa ob mp ll oc od mr oe bi translated">构造器</h2><p id="6f19" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们做了两个构造函数，一个构造函数模仿了<code class="fe lq lr ls lt b">Stream.of()</code> API，另一个构造函数将<code class="fe lq lr ls lt b">List&lt;T&gt;</code>转换为<code class="fe lq lr ls lt b">SimpleStream&lt;T&gt;</code>。</p><h2 id="8199" class="nt mc it bd md nu nv dn mh nw nx dp ml ld ny nz mn lh oa ob mp ll oc od mr oe bi translated">过滤器</h2><p id="45bb" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在这个方法中，我们接受<code class="fe lq lr ls lt b">Predicate&lt;T&gt;</code>作为参数，因为<code class="fe lq lr ls lt b">Predicate&lt;T&gt; </code>有一个名为<code class="fe lq lr ls lt b">test</code>的抽象参数，它接受一个对象并产生一个布尔值。</p><p id="23c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看测试类，我们写道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4190" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们编写了一个实现<code class="fe lq lr ls lt b">Predicate&lt;T&gt;</code>的匿名类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="324e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以在<code class="fe lq lr ls lt b">SimpleStream&lt;T&gt;</code>类中，我们可以看到过滤方法为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="3f0e" class="nt mc it bd md nu nv dn mh nw nx dp ml ld ny nz mn lh oa ob mp ll oc od mr oe bi translated">地图</h2><p id="44f6" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在map方法中，我们接受<code class="fe lq lr ls lt b">Function&lt;T, R&gt;</code>作为它的参数，这意味着map方法将接受一个函数接口，该接口接受一个对象，也产生一个对象。</p><p id="436b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在测试类中编写了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6ed5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与创建实现<code class="fe lq lr ls lt b">Function&lt;T, R&gt;</code>的匿名类是一样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1f14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而在<code class="fe lq lr ls lt b">SimpleStream&lt;T&gt;</code>类中，我们可以这样来看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="8700" class="nt mc it bd md nu nv dn mh nw nx dp ml ld ny nz mn lh oa ob mp ll oc od mr oe bi translated">为每一个</h2><p id="39ed" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><code class="fe lq lr ls lt b">forEach</code>方法接受<code class="fe lq lr ls lt b">Consumer&lt;T&gt;</code>作为它的参数，这意味着它将接受一个对象并且不返回任何东西。</p><p id="944a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在测试类中编写了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bb2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这转化为创建一个实现<code class="fe lq lr ls lt b">Consumer&lt;T&gt;</code>的匿名类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4215" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">SimpleStream&lt;T&gt;</code>中，我们可以看到<code class="fe lq lr ls lt b">forEach</code>的方法，如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c8f7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="1983" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">随着2014年Java 8的发布，我们可以在Java中使用函数式编程风格。在Java中使用函数式编程风格有很多好处，其中之一就是使您的代码更短，可读性更好。考虑到它所提供的好处，如果您是一名Java开发人员，了解Java中函数式编程的实现是必不可少的！</p><p id="3530" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读这篇文章！</p><p id="0423" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在这里找到本文使用的GitHub存储库:</p><div class="om on gp gr oo op"><a href="https://github.com/brilianfird/java-functional-programming" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">brilianfird/Java-函数式编程</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">Java函数式编程演示。为brilianfird/java函数式编程开发作出贡献</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><h1 id="4e8f" class="mb mc it bd md me pe mg mh mi pf mk ml jz pg ka mn kc ph kd mp kf pi kg mr ms bi translated">资源</h1><ol class=""><li id="40ca" class="nf ng it kw b kx mt la mu ld pj lh pk ll pl lp pm nl nm nn bi translated"><a class="ae my" href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/lang/functional interface . html</a></li><li id="21b2" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp pm nl nm nn bi translated"><a class="ae my" href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/Java/javaOO/anonymous classes . html</a></li><li id="8048" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp pm nl nm nn bi translated"><a class="ae my" href="https://www.amitph.com/java-method-and-constructor-reference/#:~:text=Constructor%20Reference%20is%20used%20to,assign%20to%20a%20target%20type" rel="noopener ugc nofollow" target="_blank">https://www . Amit ph . com/Java-method-and-Constructor-reference/#:~:text = Constructor % 20 reference % 20 is % 20 used % 20 to，assign % 20 to % 20a % 20 target % 20 type</a>。</li><li id="6bca" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp pm nl nm nn bi translated"><a class="ae my" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/function/package-summary . html</a></li><li id="3e41" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp pm nl nm nn bi translated"><a class="ae my" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/Java se/tutorial/Java/javaOO/lambda expressions . html</a></li><li id="e781" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp pm nl nm nn bi translated">【http://reactivex.io/RxJava/javadoc/ T4】</li><li id="5f7d" class="nf ng it kw b kx no la np ld nq lh nr ll ns lp pm nl nm nn bi translated"><a class="ae my" href="https://projectreactor.io/docs/core/release/api/" rel="noopener ugc nofollow" target="_blank">https://projectreactor.io/docs/core/release/api/</a></li></ol></div></div>    
</body>
</html>