<html>
<head>
<title>Build and Deploy Your Flask API With a Postgres Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Postgres数据库构建和部署您的Flask API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cookiecutter-template-to-build-and-deploy-your-flask-api-with-postgres-database-20ad99b8dae4?source=collection_archive---------0-----------------------#2020-05-31">https://betterprogramming.pub/cookiecutter-template-to-build-and-deploy-your-flask-api-with-postgres-database-20ad99b8dae4?source=collection_archive---------0-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="528e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个有用的模板，帮助您启动下一个项目并开始构建</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7fe4692e1660055f95aa20c24c59a2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeZEg-xS7KMOqoGdQgMMMQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nevenkrcmarek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Neven Krcmarek </a>在<a class="ae ky" href="https://unsplash.com/s/photos/cookie-cutters?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ac69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写Flask web服务时，我们经常发现自己在重写相同的样板代码——比如配置、结构以及构建和部署设置。这篇文章的目标是帮助你在下一个Flask API项目中尽量减少重复吃同样的东西。您还将学习如何在<a class="ae ky" href="https://render.com/" rel="noopener ugc nofollow" target="_blank">Render.com</a>上部署带有数据库的Flask web服务。如果你不使用Render，没问题——这个<a class="ae ky" href="https://cookiecutter.readthedocs.io/en/1.7.2/" rel="noopener ugc nofollow" target="_blank"> cookiecutter </a>也使用Docker来帮助在其他平台上构建和部署。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e7ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">模板中包含哪些内容</strong></h1><ul class=""><li id="9e69" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">使用GitHub和Render的基础设施作为代码，通过持续部署管道投入使用。在此见示例<a class="ae ky" href="https://github.com/ardydedase/flask-postgres-api/blob/master/render.yaml" rel="noopener ugc nofollow" target="_blank"> IaC文件。</a></li><li id="7b90" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">现成的SQLAlchemy/Postgres数据库。</li><li id="a438" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使用<code class="fe nk nl nm nn b">mypy</code>进行静态类型检查。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a379" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">高层结构</h1><p id="3450" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下面是我们的Flask API的结构。我们将在下一节中讨论每个文件或组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/33f86e5f33becef7fe4bcbd800cbc34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*O_PEPxbh_9OqdkMtOU4jkA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">cookiecutter模板的高级结构。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2189" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结构的分解</h1><p id="ebb1" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们剖析并了解一下我们的<em class="ns"> cookiecutter </em>模板的结构。</p><h2 id="643b" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">T21——一切开始的地方</h2><p id="64c2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是API请求的入口点。</p><ul class=""><li id="8f09" class="mu mv it lb b lc ld lf lg li og lm oh lq oi lu nb nc nd ne bi translated">它包含API端点和CLI声明。它使用<code class="fe nk nl nm nn b">Flask-Restful</code>作为它的API。</li><li id="a45b" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">创建Flask应用程序实例。</li><li id="e477" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">使用<code class="fe nk nl nm nn b">Flask-Migrate</code>运行SQLAlchemy迁移。</li><li id="5d67" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">导入API资源。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/main.py。</p></figure><p id="2cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当文件变大时，我们可能需要移动CLI函数。</p><h2 id="f4c2" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated"><em class="of">app . py</em>—create _ app所在的位置</h2><p id="7edd" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这包含了返回Flask应用实例的<code class="fe nk nl nm nn b">create_app()</code> <em class="ns"> </em>。<code class="fe nk nl nm nn b">create_app()</code> <em class="ns"> </em>也接受一个<code class="fe nk nl nm nn b">env</code>参数，该参数决定应用程序运行的环境。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/app.py。</p></figure><h2 id="e2c7" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">config.py —典型的Python配置文件</h2><p id="bc81" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是我们支持多种环境的配置文件。</p><p id="4f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库凭证是从环境变量中传递的。通过避免将凭证写在配置文件中，这使得我们可以方便地安全传递凭证。Render提供了一种将数据库凭证传递给环境变量的便捷方式，而无需显式设置这些凭证。我们将在后面关于代码形式的<code class="fe nk nl nm nn b">render.yaml</code> <em class="ns"> </em>基础设施的章节中讨论这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/config.py</p></figure><h2 id="a9d0" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">utils.py —静态和无状态函数</h2><p id="a0c4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是我们可以添加实用函数的地方。它目前包含了<code class="fe nk nl nm nn b">get_env_variable()</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/utils.py</p></figure><h2 id="9f21" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">资源——为API保存Restful资源</h2><p id="c6c8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这包含API资源实现。</p><p id="fef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的文件中，您将看到它导入了一个repository类来创建或获取存储在数据库中的用户记录。</p><p id="499c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用<code class="fe nk nl nm nn b">Flask-Restful</code>对API资源进行抽象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/resources/user.py</p></figure><h2 id="6e76" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">存储库—数据的抽象</h2><p id="3e59" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是调用<code class="fe nk nl nm nn b">Flask-SQLAlchemy</code>方法的地方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/repositories/user.py</p></figure><h2 id="6d23" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">模型—代表我们的表格</h2><p id="eb46" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在这个目录中，我们声明我们的数据是如何存储和结构化的。该模板包括一个简单的用户模型，带有字段<code class="fe nk nl nm nn b">username</code>、<code class="fe nk nl nm nn b">avatar_url</code>和<code class="fe nk nl nm nn b">date_created</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/models/user.py</p></figure><h2 id="b1b9" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">render.yaml的render . YAML-IaC</h2><p id="1953" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">这是基础设施代码(IaC)文件，用于提供资源并设置我们在Render.com的服务的部署管道。</p><p id="85e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个可以在<a class="ae ky" href="https://github.com/ardydedase/flask-postgres-api" rel="noopener ugc nofollow" target="_blank"> Flask Postgres参考API </a>中找到的实现示例。它指示Render创建一个web服务资源、一个Postgres数据库和一个环境变量组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="1419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在前面的<code class="fe nk nl nm nn b">config.py</code>部分提到了如何在配置中使用环境变量。注意<code class="fe nk nl nm nn b">envVars</code>，它可以方便地将来自Postgres数据库的凭证传递给环境变量。您还会注意到<code class="fe nk nl nm nn b">envVargroups</code>——这是我们可以设置自己的环境变量值的地方。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="314d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">本地运行</h1><p id="0c8e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在我们已经熟悉了cookiecutter模板的结构，让我们在本地运行一个。</p><h2 id="2eff" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">先决条件</h2><p id="98d3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在我们开始之前，请确保您已经安装了cookiecutter。关于<a class="ae ky" href="https://cookiecutter.readthedocs.io/en/1.7.2/installation.html" rel="noopener ugc nofollow" target="_blank">安装的细节可以在这里找到</a>。</p><pre class="kj kk kl km gt ol nn om on aw oo bi"><span id="e748" class="nt md it nn b gy op oq l or os">pip install cookiecutter</span></pre><h2 id="4845" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">Cookie-cut模板</h2><p id="d05f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">一旦安装了cookiecutter，您需要“cookie-cut”模板:</p><pre class="kj kk kl km gt ol nn om on aw oo bi"><span id="d2cf" class="nt md it nn b gy op oq l or os">cookiecutter <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:ardydedase/cookiecutter-flask-postgres-api.git</span></pre><p id="fd48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的命令后，会要求您输入项目的详细信息，如下图所示。相应地输入值，注意项目slug值将被用作您的GitHub存储库名称和项目文件夹名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d7498fbcc7cbaae3bca9abc3dd5699ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*CRPkUNGPzwbrLiUVFccwjQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Cookicutter模板项目详细信息。</p></figure><p id="4a5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将为您生成项目。将目录<em class="ns"> </em>更改为由cookiecutter创建的项目文件夹。</p><pre class="kj kk kl km gt ol nn om on aw oo bi"><span id="acb7" class="nt md it nn b gy op oq l or os">cd &lt;project_slug&gt;</span></pre><p id="7942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在项目的根文件夹中运行<code class="fe nk nl nm nn b">docker-compose</code>:</p><pre class="kj kk kl km gt ol nn om on aw oo bi"><span id="78de" class="nt md it nn b gy op oq l or os">docker-compose up</span></pre><p id="6996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe nk nl nm nn b">docker-compose</code>成功运行后，可以在<a class="ae ky" href="http://localhost:5000/healthcheck" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/health check</a>查看你的Flask app本地运行情况。</p><p id="2f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以查看GitHub上的<a class="ae ky" href="https://github.com/ardydedase/cookiecutter-flask-postgres-api/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>，了解本地运行应用程序的其他方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2198" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">与Render.com一起部署</h1><p id="5adb" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">请注意，这将在您的渲染账单中产生一些费用——更多关于它们的<a class="ae ky" href="https://render.com/pricing" rel="noopener ugc nofollow" target="_blank">定价，请点击</a>。</p><p id="c3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Render非常简单。登录渲染后，点击菜单中的“YAML”链接，在这个页面:<a class="ae ky" href="https://dashboard.render.com/iacs" rel="noopener ugc nofollow" target="_blank">https://dashboard.render.com/iacs</a>。</p><p id="aa48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击“YAML新建”并从cookiecutter生成的项目的根文件夹中选择render.yaml文件。上传YAML文件后，渲染会要求您批准IaC将创建的资源。更多关于使用<a class="ae ky" href="https://render.com/docs/infrastructure-as-code" rel="noopener ugc nofollow" target="_blank">渲染的IaC在这里</a>。</p><p id="350a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于在他们的文档中管理Render的资源<a class="ae ky" href="https://render.com/docs" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><p id="6665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Render中成功部署后，将在Render dashboard中提供服务的URL。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="59e1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">后续步骤</h1><p id="3b92" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">希望您现在能够使用Postgres数据库快速创建和部署自己的Flask API！</p><p id="2790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在GitHub上查看带有Postgres Cookiecutter模板的<a class="ae ky" href="https://github.com/ardydedase/cookiecutter-flask-postgres-api" rel="noopener ugc nofollow" target="_blank"> Flask API。它还附带了一个</a><a class="ae ky" href="https://github.com/ardydedase/flask-postgres-api" rel="noopener ugc nofollow" target="_blank">参考库</a>——一个从我们的cookiecutter构建的样例项目。</p><div class="ou ov gp gr ow ox"><a href="https://github.com/ardydedase/cookiecutter-flask-postgres-api" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">ardydedase/cookiecutter-flask-postgres-API</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">Flask API的项目模板。使用GitHub和Render的基础设施实现持续部署管道…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">github.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><p id="ba4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这里查看我的另一篇关于构建NPM包的Cookiecutter模板的文章。</p></div></div>    
</body>
</html>