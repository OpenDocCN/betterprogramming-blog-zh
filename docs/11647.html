<html>
<head>
<title>Build, Test, and Automate a Kubernetes Interfacing Application in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建、测试和自动化Kubernetes接口应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-test-and-automate-a-kubernetes-interfacing-application-in-go-da71e4d5aaef?source=collection_archive---------12-----------------------#2022-04-05">https://betterprogramming.pub/build-test-and-automate-a-kubernetes-interfacing-application-in-go-da71e4d5aaef?source=collection_archive---------12-----------------------#2022-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e43c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何创建、构建、测试和自动化与Kubernetes接口的Go应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/76b261b93e37c29fa8345de0c5d81b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jaxyB7Khvd44K8eN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@clo_shooting?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克洛维斯伍德摄影</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="972c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes的<a class="ae kv" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> Client-Go </a>提供了各种与集群交互的包。这些软件包包括以下内容:</p><ul class=""><li id="54b4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mb mc md me b">kubernetes</code>包包含访问Kubernetes API的客户端集。</li><li id="7458" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">discovery</code>包用于发现Kubernetes API服务器支持的API。</li><li id="4579" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">dynamic</code>包包含一个动态客户端，可以对任意Kubernetes API对象执行一般操作。</li><li id="c9d4" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">plugin/pkg/client/auth</code>包包含可选的身份验证插件，用于从外部来源获取凭证。</li><li id="691f" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">transport</code>包用于设置身份验证和启动连接。</li><li id="02bb" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">tools/cache</code>包对于编写控制器很有用。</li></ul><p id="2c99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了上面所有的包，Client-Go还包含一个假客户端，它允许您模拟特定Kubernetes资源的创建、读取、编辑和删除，以便轻松增加单元测试覆盖率。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="d4d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到KubeCon Europe 2019，我介绍了使用Go-Client假客户端执行单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1d7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我将介绍如何创建一个简单的<a class="ae kv" href="https://github.com/kubernetes/client-go/tree/master/examples/out-of-cluster-client-configuration" rel="noopener ugc nofollow" target="_blank">集群外</a>应用程序，用于在您的Kubernetes集群上执行操作。然后我将向您展示如何在您的单元测试中模拟Kubernetes API调用，并使用GitLab自动运行这些测试以及更多！</p><h1 id="d730" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">先决条件</h1><p id="792f" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">为了开始使用，您必须安装一些程序:</p><ul class=""><li id="6a81" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> Go </a> —一种开源编程语言。</li><li id="3724" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><a class="ae kv" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> MiniKube </a> —一个在macOS、Linux和Windows上快速建立本地Kubernetes集群的工具。您还需要一个虚拟化驱动程序来运行MiniKube，例如Docker、HyperV、Podman等。更多信息可在<a class="ae kv" href="https://minikube.sigs.k8s.io/docs/drivers/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li></ul><p id="26be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:你可以使用除了<code class="fe mb mc md me b">minikube</code>之外的另一个集群，它会根据设置的<code class="fe mb mc md me b">kubectl</code>上下文正常工作。这个指南是用<code class="fe mb mc md me b">minikube</code>写的，因为每个人都可以接触到。</p><p id="0c46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还必须了解以下内容:</p><ul class=""><li id="0f9d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://go.dev/doc/" rel="noopener ugc nofollow" target="_blank"> Go基础知识</a>——我写的代码在Go中。确保你有基本的了解。</li><li id="5179" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank"> Kubernetes基础知识</a> —了解如何使用Kubernetes集群，以及如何使用kubectl。</li><li id="9255" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank"> Kubernetes的秘密</a> —了解Kubernetes中有哪些秘密。</li></ul><p id="65f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解以下内容很有好处:</p><ul class=""><li id="0c6c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.freecodecamp.org/news/learn-the-basics-of-git-in-under-10-minutes-da548267cc91/" rel="noopener ugc nofollow" target="_blank"> Git基础知识</a> —很高兴知道Git可以自己创建分支并修改代码。</li><li id="f42d" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> GitLab CI </a> —我的代码存放在GitLab中，我使用GitLab CI来运行我的单元测试和安全扫描。</li></ul><p id="7e46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用我的<a class="ae kv" href="https://gitlab.com/k2511/secreto-server" rel="noopener ugc nofollow" target="_blank"> secreto-server </a>项目，它执行以下功能:</p><ul class=""><li id="7d69" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">生成通用的Kubernetes秘密</li><li id="4e37" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">列出每个给定名称空间的秘密</li><li id="3c36" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">获得包含有效载荷的秘密数据</li><li id="0210" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">删除机密</li></ul><h1 id="ee4f" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">运行应用程序(本地)</h1><p id="e966" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">首先，我们将使用MiniKube创建一个集群，并确保我们可以与Kubernetes secrets进行交互。然后，我们将在本地启动应用程序，并验证应用程序的所有功能。</p><h2 id="80ae" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">创建Kubernetes集群</h2><ol class=""><li id="815e" class="ls lt iq ky b kz nl lc nm lf oc lj od ln oe lr of ly lz ma bi translated">安装MiniKube。您可以在<a class="ae kv" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">入门页面</a>下载基于您的操作系统和架构的Minikube版本。</li></ol><p id="b076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.运行Minikube。下载所需的包可能需要几分钟，但是只要您有所需的虚拟化驱动程序，运行Minikube就很简单。Docker桌面适用于大多数情况，但我正在使用podman尝试一些不同的东西。有关驱动程序的更多信息，请参见<a class="ae kv" href="https://minikube.sigs.k8s.io/docs/drivers/" rel="noopener ugc nofollow" target="_blank"> Minikube文档</a>。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="f636" class="nq mu iq me b gy ok ol l om on">$ minikube start</span><span id="9327" class="nq mu iq me b gy oo ol l om on">minikube v1.25.2 on Darwin 12.3 (arm64)<br/>Using the podman (experimental) driver based on existing profile<br/>Starting control plane node minikube in cluster minikube<br/>Pulling base image ...<br/>E0321 11:05:07.616563   66007 cache.go:203] Error downloading kic artifacts:  not yet implemented, see issue #8426<br/>Restarting existing podman container for "minikube" ...<br/>Preparing Kubernetes v1.23.3 on Docker 20.10.12 ...E0321 11:05:13.251398   66007 start.go:126] Unable to get host IP: RoutableHostIPFromInside is currently only implemented for linux<br/>▪ kubelet.housekeeping-interval=5m<br/>Verifying Kubernetes components...<br/>    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5<br/>Enabled addons: storage-provisioner, default-storageclass<br/>kubectl not found. If you need it, try: 'minikube kubectl -- get pods -A'<br/>Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</span></pre><p id="d112" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.验证Minikube是否正常运行。我们可以通过检查Minikube节点是否处于就绪状态来做到这一点。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="fdf4" class="nq mu iq me b gy ok ol l om on">$ minikube kubectl get nodes</span><span id="8e6c" class="nq mu iq me b gy oo ol l om on">NAME       STATUS   ROLES                  AGE     VERSION<br/>minikube   Ready    control-plane,master   3m50s   v1.23.3</span></pre><p id="6a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.创造一个秘密。我们将通过<code class="fe mb mc md me b">kubectl</code>来验证我们是否可以访问secrets API。我正在用<code class="fe mb mc md me b">literal[<em class="op">shhh</em>]=<em class="op">supersecret</em></code> <em class="op">创建一个通用的秘密。</em></p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="b7b4" class="nq mu iq me b gy ok ol l om on">$ minikube kubectl create secret generic my-secret -- --from-literal=shhh=supersecret</span><span id="db85" class="nq mu iq me b gy oo ol l om on">secret/my-secret created</span></pre><p id="cf36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.现在，让我们验证这个秘密是否已经成功创建</p><p id="b095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在YAML模式下抓取它，并查看base64编码的<code class="fe mb mc md me b">supersecret</code> ( <code class="fe mb mc md me b"><em class="op">c3VwZXJzZWNyZXQ=</em></code>)。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="e495" class="nq mu iq me b gy ok ol l om on">$ minikube kubectl get secrets my-secret -- -o yaml</span><span id="d4e9" class="nq mu iq me b gy oo ol l om on">minikube kubectl get secrets my-secret -- -o yaml<br/>apiVersion: v1<br/>data:<br/>  shhh: c3VwZXJzZWNyZXQ=<br/>kind: Secret<br/>metadata:<br/>  creationTimestamp: "2022-03-20T21:16:48Z"<br/>  name: my-secret<br/>  namespace: default<br/>  resourceVersion: "728"<br/>  uid: 9fcb7814-77f1-44dc-b476-066db11598bd<br/>type: Opaque</span></pre><h1 id="37a5" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">构建应用程序</h1><ol class=""><li id="787f" class="ls lt iq ky b kz nl lc nm lf oc lj od ln oe lr of ly lz ma bi translated">将应用程序克隆到您的<a class="ae kv" href="https://go.dev/doc/gopath_code" rel="noopener ugc nofollow" target="_blank"> GOPATH </a></li></ol><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="8e62" class="nq mu iq me b gy ok ol l om on">$ git clone <a class="ae kv" href="mailto:git@gitlab.com" rel="noopener ugc nofollow" target="_blank">git@gitlab.com</a>:k2511/secreto-server.git</span><span id="b055" class="nq mu iq me b gy oo ol l om on">git clone <a class="ae kv" href="mailto:git@gitlab.com" rel="noopener ugc nofollow" target="_blank">git@gitlab.com</a>:k2511/secreto-server.git<br/>Cloning into 'secreto-server'...<br/>remote: Enumerating objects: 235, done.<br/>remote: Counting objects: 100% (232/232), done.<br/>remote: Compressing objects: 100% (121/121), done.<br/>remote: Total 235 (delta 97), reused 177 (delta 69), pack-reused 3<br/>Receiving objects: 100% (235/235), 282.99 KiB | 3.11 MiB/s, done.<br/>Resolving deltas: 100% (97/97), done.</span><span id="70d0" class="nq mu iq me b gy oo ol l om on">$ cd secreto-server</span></pre><p id="9248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.构建应用程序可执行文件。我创建了一个Makefile，这使它变得容易。一旦运行这个命令，应该会创建一个名为<code class="fe mb mc md me b">secreto-server</code>的新的可执行文件。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="de95" class="nq mu iq me b gy ok ol l om on">$ make build</span><span id="b4b2" class="nq mu iq me b gy oo ol l om on">go mod download<br/>GOOS=darwin GOARCH=arm64 go build -o secreto-server .<br/>chmod +x secreto-server</span></pre><p id="6e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>如果你不是在M1 Mac上运行，你可能需要改变<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/Makefile" rel="noopener ugc nofollow" target="_blank"> Makefile </a>中的<code class="fe mb mc md me b">$GOOS</code>和<code class="fe mb mc md me b">$GOARCH</code>变量。更多详情<a class="ae kv" href="https://www.digitalocean.com/community/tutorials/building-go-applications-for-different-operating-systems-and-architectures" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="6c70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.在本地运行应用程序。这是通过在运行可执行文件时传递<code class="fe mb mc md me b">-local</code>标志来实现的。在没有<code class="fe mb mc md me b">-local</code>标志的情况下运行它，将要求应用程序在Kubernetes集群中运行，因为它使用不同的<a class="ae kv" href="https://github.com/kubernetes/client-go/tree/master/examples/in-cluster-client-configuration" rel="noopener ugc nofollow" target="_blank"> auth方法</a>。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="548a" class="nq mu iq me b gy ok ol l om on">$ ./secreto-server -local</span><span id="0cf7" class="nq mu iq me b gy oo ol l om on">2022/03/20 16:18:30 KubeClient running with local configuration<br/>2022/03/20 16:18:30 Starting server on the port 8080</span></pre><p id="0981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以在执行程序前通过设置<code class="fe mb mc md me b">SECRETO_PORT</code>环境变量来更改端口。</p><p id="f977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在应用程序正在运行。让我们继续下去，并确认它的工作。我们可以通过打开另一个终端并向服务器发送请求来获得它的版本。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="b428" class="nq mu iq me b gy ok ol l om on">$ curl http://localhost:8080/api/secreto/version</span><span id="aa8e" class="nq mu iq me b gy oo ol l om on">{"version":1}</span></pre><p id="02b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在有了一个工作应用程序！让我们验证应用程序的几个功能。</p><h2 id="bd87" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">添加秘密</h2><p id="6ae3" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们可以通过向secreto API路径传递一个<code class="fe mb mc md me b">name</code>和<code class="fe mb mc md me b">payload</code>来添加一个秘密。确保你也添加了<code class="fe mb mc md me b">namespace</code>到路径的末端，如下图所示。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="354d" class="nq mu iq me b gy ok ol l om on">$ curl -X POST http://localhost:8080/api/secreto/default -d '{"name": "my-secret2", "payload": "my-secret-yoo"}'</span><span id="1773" class="nq mu iq me b gy oo ol l om on">{"Secret Created Successfully":{"name":"my-secret2","namespace":"default","date":"2022-03-20 17:39:41 -0500 CDT","payload":"my-secret-yoo"}}</span></pre><h2 id="af1f" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">查看秘密</h2><p id="bf8a" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们可以列出我们所有的秘密，按名称空间排序，甚至查找有效载荷。这是通过在不同的路径上执行GET来完成的:</p><ul class=""><li id="f634" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mb mc md me b">/api/secreto</code>:列出所有秘密</li><li id="e572" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">/api/secreto/{namespace}</code>:列出{命名空间}中的所有秘密</li><li id="8fb8" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">/api/secreto/{namespace}/{name}</code>:列出{命名空间}中机密{name}的数据</li></ul><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="ac74" class="nq mu iq me b gy ok ol l om on">$ curl -X GET <a class="ae kv" href="http://localhost/api/secrets" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/secret</a>o</span><span id="e064" class="nq mu iq me b gy oo ol l om on">[{"name":"default-token-m9wsq","namespace":"default","date":"2022-03-20 16:10:27 -0500 CDT","payload":""},{"name":"my-secret","namespace":"default","date":"2022-03-20 16:16:48 -0500 CDT","payload":"supersecret"},{"name":"yeet","namespace":"default","date":"2022-03-20 16:56:24 -0500 CDT","payload":"my-secret-yoo"},{"name":"default-token-dq5wr","namespace":"kube-node-lease","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"default-token-nwbxx","namespace":"kube-public","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"attachdetach-controller-token-cdfl4","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""},{"name":"bootstrap-signer-token-ljx9n","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""},{"name":"bootstrap-token-81dbvo","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"certificate-controller-token-9nqdf","namespace":"kube-system","date":"2022-03-20 16:10:15 -0500 CDT","payload":""},{"name":"clusterrole-aggregation-controller-token-wb95r","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"coredns-token-7sldt","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""},{"name":"cronjob-controller-token-l5msx","namespace":"kube-system","date":"2022-03-20 16:10:16 -0500 CDT","payload":""},{"name":"daemon-set-controller-token-ppr8p","namespace":"kube-system","date":"2022-03-20 16:10:16 -0500 CDT","payload":""},{"name":"default-token-mxzhs","namespace":"kube-system","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"deployment-controller-token-ctsrt","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"disruption-controller-token-kf9qs","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""},{"name":"endpoint-controller-token-kkp5b","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"endpointslice-controller-token-b4bwk","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"endpointslicemirroring-controller-token-g7bqq","namespace":"kube-system","date":"2022-03-20 16:10:15 -0500 CDT","payload":""},{"name":"ephemeral-volume-controller-token-t7s6h","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""},{"name":"expand-controller-token-wvhn8","namespace":"kube-system","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"generic-garbage-collector-token-q62cw","namespace":"kube-system","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"horizontal-pod-autoscaler-token-wmkcc","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"job-controller-token-9492p","namespace":"kube-system","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"kube-proxy-token-6z9ht","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""},{"name":"namespace-controller-token-lrwx8","namespace":"kube-system","date":"2022-03-20 16:10:15 -0500 CDT","payload":""},{"name":"node-controller-token-x9vwn","namespace":"kube-system","date":"2022-03-20 16:10:16 -0500 CDT","payload":""},{"name":"persistent-volume-binder-token-vdw68","namespace":"kube-system","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"pod-garbage-collector-token-jl9z2","namespace":"kube-system","date":"2022-03-20 16:10:16 -0500 CDT","payload":""},{"name":"pv-protection-controller-token-jv9d8","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"pvc-protection-controller-token-d4ccm","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"replicaset-controller-token-hbdj6","namespace":"kube-system","date":"2022-03-20 16:10:15 -0500 CDT","payload":""},{"name":"replication-controller-token-74kl8","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"resourcequota-controller-token-767r2","namespace":"kube-system","date":"2022-03-20 16:10:13 -0500 CDT","payload":""},{"name":"root-ca-cert-publisher-token-7zbhn","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""},{"name":"service-account-controller-token-vdxgt","namespace":"kube-system","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"service-controller-token-nvt8n","namespace":"kube-system","date":"2022-03-20 16:10:15 -0500 CDT","payload":""},{"name":"statefulset-controller-token-97d8r","namespace":"kube-system","date":"2022-03-20 16:10:26 -0500 CDT","payload":""},{"name":"storage-provisioner-token-nsblb","namespace":"kube-system","date":"2022-03-20 16:10:16 -0500 CDT","payload":""},{"name":"token-cleaner-token-wdbdn","namespace":"kube-system","date":"2022-03-20 16:10:15 -0500 CDT","payload":""},{"name":"ttl-after-finished-controller-token-rgjt4","namespace":"kube-system","date":"2022-03-20 16:10:16 -0500 CDT","payload":""},{"name":"ttl-controller-token-tzjfc","namespace":"kube-system","date":"2022-03-20 16:10:14 -0500 CDT","payload":""}]</span><span id="54cd" class="nq mu iq me b gy oo ol l om on">$ curl -X GET <a class="ae kv" href="http://localhost/api/secrets/default" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/secreto/default</a></span><span id="442b" class="nq mu iq me b gy oo ol l om on">[{"name":"default-token-m9wsq","namespace":"default","date":"2022-03-20 16:10:27 -0500 CDT","payload":""},{"name":"my-secret","namespace":"default","date":"2022-03-20 16:16:48 -0500 CDT","payload":"supersecret"},{"name":"my-secret2","namespace":"default","date":"2022-03-20 16:56:24 -0500 CDT","payload":"my-secret-yoo"}]</span><span id="6a9f" class="nq mu iq me b gy oo ol l om on">$ curl -X GET <a class="ae kv" href="http://localhost/api/secrets/default/yeet" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/secreto/default/</a>my-secret</span><span id="b069" class="nq mu iq me b gy oo ol l om on">{"name":"my-secret","namespace":"default","date":"2022-03-20 16:16:48 -0500 CDT","payload":"supersecret"}</span></pre><h2 id="91f9" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">删除秘密</h2><p id="2833" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在，让我们继续删除我们之前创建的一个秘密。这是通过在机密的完整路径上执行删除来完成的。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="1fc6" class="nq mu iq me b gy ok ol l om on">$ curl -X DELETE <a class="ae kv" href="http://localhost:8080/api/secreto/default/my-secret2" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/secreto/default/my-secret</a></span><span id="f04c" class="nq mu iq me b gy oo ol l om on">{"Secret Deleted Successfully":"my-secret"}</span></pre><h1 id="618e" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">分析代码</h1><p id="d4bd" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在让我们深入研究一下<a class="ae kv" href="https://gitlab.com/k2511/secreto-server" rel="noopener ugc nofollow" target="_blank">应用程序代码</a>。我将主要介绍与Kubernetes API交互的部分。应用程序按以下方式拆分:</p><ul class=""><li id="a17d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mb mc md me b">middleware</code>:包含处理请求和生成响应的所有应用程序逻辑。这包括与Kubernetes API通信，以便对秘密执行不同的功能。</li><li id="b3b3" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">router</code>:将来自特定URIs的调用路由到中间件中的应用逻辑。</li><li id="7848" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">model</code>:包含应用程序中用于显示和创建秘密的结构。</li><li id="9bf2" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated"><code class="fe mb mc md me b">main.go</code> <strong class="ky ir"> : </strong>启动应用程序，加载<code class="fe mb mc md me b">web-server</code>。</li></ul><p id="f1cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们深入了解一下源代码是如何工作的。</p><h2 id="b43e" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">认证和设置</h2><p id="7233" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">使用Kubernetes客户端进行身份验证可以在<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/internal/server/middleware/middleware.go" rel="noopener ugc nofollow" target="_blank"> middleware.go </a>中看到。在本文中，我们将讨论集群外身份认证。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq ms l"/></div></figure><p id="dd6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码摘自Client-Go的<a class="ae kv" href="https://github.com/kubernetes/client-go/tree/master/examples/out-of-cluster-client-configuration" rel="noopener ugc nofollow" target="_blank">集群外配置示例</a>。需要注意的主要部分是:</p><ul class=""><li id="c089" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Kubernetes配置是通过查看<code class="fe mb mc md me b">~/.kube/config</code>文件夹中的活动内容来设置的</li><li id="2745" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">如果不存在主目录，那么我们必须传递<code class="fe mb mc md me b">-kubeconfig</code> <strong class="ky ir"> </strong>以及我们的Kubernetes配置的路径，以便正确地加载它</li><li id="22de" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">这里有一个全局变量<code class="fe mb mc md me b">ClientSet=client</code> <strong class="ky ir"> <em class="op"> </em> </strong>设置，这样我们就不需要一直加载<code class="fe mb mc md me b">kubeconfig</code>就可以用<code class="fe mb mc md me b">ClientSet</code>运行命令了</li></ul><h2 id="b98b" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">添加秘密</h2><p id="7b5f" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">为了添加一个秘密，下面的代码接受一个请求，调用私有的<code class="fe mb mc md me b">createSecret</code>函数，然后将响应返回给用户。需要注意的主要部分是:</p><ul class=""><li id="c530" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">为<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>设置标题，例如，访问控制允许方法，这将允许浏览器使用不同类型的方法</li><li id="d8d2" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">从<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/internal/server/router/router.go" rel="noopener ugc nofollow" target="_blank"> router.go </a>中定义的URI路由{namespace}中获取命名空间的参数</li><li id="f625" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">基于请求体中的项目生成Kubernetes API调用</li><li id="bd84" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">对实际机密进行编码并返回，或者返回一个错误</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq ms l"/></div></figure><p id="d6a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码是一个私有函数，它使用Client-Go来创建一个秘密。需要注意的主要部分是:</p><ul class=""><li id="ca6d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mb mc md me b">metav1.ObjectMeta</code>与封装在图<code class="fe mb mc md me b">secretData</code>和<code class="fe mb mc md me b">secretDataBytes</code>中的秘密有效载荷一起被设置</li><li id="0488" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">一辆库伯内特v1。基于函数中发送的数据的秘密被传递给Kubernetes API以创建秘密</li><li id="4584" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">如果秘密生成成功，那么我们生成一个<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/internal/server/models/models.go" rel="noopener ugc nofollow" target="_blank"> Secreto对象</a>，并在返回它之前用来自秘密的数据填充它</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq ms l"/></div></figure><h2 id="a724" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">查看秘密</h2><p id="c8d2" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们有几个函数用来查看秘密。他们使用Client-Go获取Kubernetes的秘密和信息。因为大多数函数都是相似的，所以我只是想回顾一下获取秘密细节的过程。需要注意的主要部分是:</p><ul class=""><li id="ef1e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">为<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>设置标题，例如，访问控制允许方法，这将允许浏览器使用不同类型的方法</li><li id="5d33" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">从在<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/internal/server/router/router.go" rel="noopener ugc nofollow" target="_blank"> router.go </a>中定义的URI路由<code class="fe mb mc md me b">{namespace}/{name}</code>中获取名称空间和名称的参数，并生成对Kubernetes API的调用</li><li id="d60a" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">对实际机密进行编码并返回，或者返回一个错误</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq ms l"/></div></figure><p id="10c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码是一个使用Client-Go的私有函数，用来描述一个通过Client-Go获取其细节的秘密。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="6440" class="nq mu iq me b gy ok ol l om on">func getSecretDetails(namespace string, name string) (*v1.Secret, error) {<br/>	secret, err := ClientSet.CoreV1().Secrets(namespace).Get(context.TODO(), name, metav1.GetOptions{})<br/><br/>	if err != nil {<br/>		return nil, err<br/>	}<br/><br/>	return secret, nil<br/>}</span></pre><h2 id="8493" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">删除秘密</h2><p id="d991" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">删除一个秘密非常简单。需要注意的主要部分是:</p><ul class=""><li id="ec2a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">为<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>设置标题，例如，Access-Control-Allow-Methods，允许浏览器使用不同类型的方法</li><li id="62a3" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">从在<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/internal/server/router/router.go" rel="noopener ugc nofollow" target="_blank"> router.go </a>中定义的URI路由<code class="fe mb mc md me b">{namespace}/{name}</code>中获取名称空间和名称的参数，并生成对Kubernetes API的调用</li><li id="3264" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">返回一条消息，说明机密已成功删除，或者返回一个错误</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq ms l"/></div></figure><p id="f44e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码是一个私有函数，它使用Client-Go来删除一个秘密:</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="948e" class="nq mu iq me b gy ok ol l om on">func deleteSecret(name string, namespace string) error {<br/>	err := ClientSet.CoreV1().Secrets(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{})<br/>	if err != nil {<br/>		return err<br/>	}<br/><br/>	return nil<br/>}</span></pre><h1 id="7e1a" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">编写单元测试</h1><p id="c5a1" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">现在我们已经看到了应用程序中所有不同的功能，我们将继续编写一些单元测试。单元测试是对我们的应用程序的不同部分的单独测试，这对于验证我们的逻辑和确保我们的应用程序做它应该做的事情是很重要的。</p><p id="88eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写的所有单元测试都位于<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/internal/server/middleware/middleware_test.go" rel="noopener ugc nofollow" target="_blank">中间件_test.go </a>。</p><h2 id="9990" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">一般设置</h2><p id="5919" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我创建了一个函数，只为不同的单元测试设置测试值。您可以看到<code class="fe mb mc md me b">setupSecrets()</code>函数，它将生成不同的秘密以及要寻找的期望值。</p><h2 id="3d9f" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">嘲笑客户-去</h2><p id="afb8" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated"><code class="fe mb mc md me b">ClientSet</code>是<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/internal/server/middleware/middleware.go" rel="noopener ugc nofollow" target="_blank"> <em class="op">中间件. go </em> </a>中定义的全局变量。在测试中，我们覆盖了它，允许所有请求返回假值，而不与我们的Kubernetes集群通信。假客户机发出返回模拟对象和值的请求。</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="813f" class="nq mu iq me b gy ok ol l om on">ClientSet = fake.NewSimpleClientset()</span></pre><h2 id="96cd" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">嘲弄请求</h2><p id="9ba3" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">可以使用<a class="ae kv" href="https://pkg.go.dev/net/http/httptest" rel="noopener ugc nofollow" target="_blank"> httptest </a>来模拟请求，它提供了HTTP测试的实用程序，并允许我们“记录”请求。需要注意的几件事是:</p><ul class=""><li id="eec6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建一个请求，并在requestBody中传递测试变量</li><li id="6bcf" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">用我们生成的假函数<code class="fe mb mc md me b">w http.ResponseWriter, r *http.Request </code>调用<code class="fe mb mc md me b">CreateSecret</code>函数</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq ms l"/></div></figure><h2 id="1d71" class="nq mu iq bd mv nr ns dn mz nt nu dp nd lf nv nw nf lj nx ny nh ln nz oa nj ob bi translated">运行测试</h2><p id="0da2" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">既然我们已经检查了测试，我们可以继续运行它们。这可以通过运行以下命令来完成:</p><pre class="kg kh ki kj gt og me oh oi aw oj bi"><span id="d8de" class="nq mu iq me b gy ok ol l om on">$ make test</span><span id="29b1" class="nq mu iq me b gy oo ol l om on">go test -v ./...<br/>?    gitlab.com/k2511/kube-secreto [no test files]<br/>=== RUN   TestProcessSecrets<br/>--- PASS: TestProcessSecrets (0.00s)<br/>=== RUN   TestGetSecretsClient<br/>--- PASS: TestGetSecretsClient (0.00s)<br/>=== RUN   TestGetSecretDetailsClient<br/>--- PASS: TestGetSecretDetailsClient (0.00s)<br/>=== RUN   TestCreateSecretClient<br/>--- PASS: TestCreateSecretClient (0.00s)<br/>=== RUN   TestDeleteSecretClient<br/>--- PASS: TestDeleteSecretClient (0.00s)<br/>=== RUN   TestGetSecretsByNamespace<br/>--- PASS: TestGetSecretsByNamespace (0.00s)<br/>=== RUN   TestGetSecretDetails<br/>--- PASS: TestGetSecretDetails (0.00s)<br/>=== RUN   TestCreateSecret<br/>--- PASS: TestCreateSecret (0.00s)<br/>=== RUN   TestDeleteSecret<br/>--- PASS: TestDeleteSecret (0.00s)<br/>=== RUN   TestGetVersion<br/>--- PASS: TestGetVersion (0.00s)<br/>PASS<br/>ok   gitlab.com/k2511/kube-secreto/internal/server/middleware 1.406s<br/>?    gitlab.com/k2511/kube-secreto/internal/server/models [no test files]<br/>?    gitlab.com/k2511/kube-secreto/internal/server/router [no test files]</span></pre><h1 id="0208" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">用覆盖率和Sast自动化测试</h1><p id="58c5" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我使用GitLab for CI来自动化构建、测试和将应用程序容器推送到我的注册中心。这使得我不必在每次推送代码时手动执行这些功能。</p><p id="099e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以配置GitLab，以便自动测试我的应用程序，从而验证我的应用程序逻辑。我的应用程序也被构建、容器化并推送到我的容器注册中心。我还可以使用<a class="ae kv" href="https://docs.gitlab.com/ee/user/application_security/sast/index.html" rel="noopener ugc nofollow" target="_blank"> GitLab SAST </a>来检查我的源代码是否安全。</p><p id="9911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的<a class="ae kv" href="https://gitlab.com/k2511/secreto-server/-/blob/main/.gitlab-ci.yml" rel="noopener ugc nofollow" target="_blank"> GitLab Yaml </a>如下图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq ms l"/></div></figure><p id="590e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们看看最新运行的GitLab管道，我们可以看到以下内容:</p><ul class=""><li id="507d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">构建阶段:运行构建应用程序的<code class="fe mb mc md me b">build</code>和构建应用程序容器并将其推送到我的容器注册中心的<code class="fe mb mc md me b">docker-build</code></li><li id="077d" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">测试阶段:<code class="fe mb mc md me b">unit</code> <em class="op"> </em>运行单元测试并生成覆盖报告，<code class="fe mb mc md me b">gosec-sast</code>和<code class="fe mb mc md me b">semgrep-sast</code> <em class="op"> </em>分别使用<code class="fe mb mc md me b">gosec</code>和<code class="fe mb mc md me b">semgrep</code><em class="op">到</em>扫描应用源代码的漏洞</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/b54e6cf3e04ba85b6b3022d7969244cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQAfjyuka4VjFu2U2L_mKg.png"/></div></div></figure><p id="7b3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单击“Security”选项卡时，我们可以看到一些我们应该解决的漏洞，按严重性排序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/f12f6770ee25c22e3c23612617b8c85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFx9GRuj4zFKqSDJRCdcEQ.png"/></div></div></figure><p id="2d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击其中一个会提供描述、位置、CVE和解决方案。您还可以消除漏洞或创建一个机密问题，与其他人一起进行补救，而无需提醒未经许可的人。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/15a07f6278602d6064e8bb4426d3e504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSLs1lwc2GbKTl1zMsNNPg.png"/></div></div></figure><p id="e3c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GitLab还有更多<a class="ae kv" href="https://docs.gitlab.com/ee/user/application_security/" rel="noopener ugc nofollow" target="_blank">安全扫描仪</a>以及其他很酷的CICD工具可供你查看。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="4cff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，我希望这篇文章能够帮助您开始创建和测试一个与Kubernetes交互的应用程序！</p></div></div>    
</body>
</html>