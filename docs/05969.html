<html>
<head>
<title>Testing in Node.js Using Mocha and Chai (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mocha和Chai在Node.js中进行测试(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-in-node-js-using-mocha-and-chai-part-1-d5a9e91f4b06?source=collection_archive---------7-----------------------#2020-08-21">https://betterprogramming.pub/testing-in-node-js-using-mocha-and-chai-part-1-d5a9e91f4b06?source=collection_archive---------7-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="001b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设置您的测试并开始运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/79a14bb5cbf77a67bbba2440b19f3de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*41keBwhX5hsJLOST"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马特·阿特兹在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="63ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js在npm上有许多包，使得编写测试的过程更加容易。在本教程中，我们使用两个最流行的节点模块进行测试:<a class="ae ky" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>和<a class="ae ky" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> Chai </a>。</p><p id="fa68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Mocha是这个测试套件中的主要测试框架。它提供了执行测试和将测试结果记录到终端的功能。Chai是Mocha常用的断言库。我们使用断言来验证被测试的组件是否返回了特定测试用例的预期返回值。</p><p id="c1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你将在本教程编写的单元测试中看到的，像<code class="fe lv lw lx ly b">it</code>和<code class="fe lv lw lx ly b">describe</code>这样的函数是Mocha的一部分。我们在这些函数内部做的断言，像<code class="fe lv lw lx ly b">expect(isSuccess).to.be.true</code>，来自柴库。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="284f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">设置测试环境</h1><p id="8db1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在继续之前，如果还没有Node.js项目，请创建一个新的node . js项目。然后安装Mocha和Chai库，并使用以下命令将它们作为开发依赖项保存到<code class="fe lv lw lx ly b">package.json</code>文件中:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8c5b" class="nh mh it ly b gy ni nj l nk nl">npm install mocha chai --save-dev</span></pre><p id="1df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将<code class="fe lv lw lx ly b">package.json</code>文件的测试脚本改为:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1cd0" class="nh mh it ly b gy ni nj l nk nl">"scripts": {<br/>    "test": "mocha"<br/> },</span></pre><p id="825c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们在命令行上使用<code class="fe lv lw lx ly b">npm test</code>命令运行测试。</p><p id="db01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还应该创建一个名为<code class="fe lv lw lx ly b">test</code>的新目录。这是我们所有测试文件将要保存的地方。请注意，您必须为目录使用确切的名称“test ”,因为Mocha会查找具有该名称的目录来运行测试。</p><p id="8969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们的项目目录具有这样的文件夹结构:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="81b8" class="nh mh it ly b gy ni nj l nk nl">|test<br/>|src<br/>|node_modules<br/>package.json</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8e82" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摩卡的基本测试格式</h1><p id="57bf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Mocha中典型的测试文件采用以下形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9a56" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用摩卡挂钩测试格式</h1><p id="96d1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Mocha提供了钩子，我们可以在每个测试用例或所有测试用例之前和之后运行。它们是:</p><ul class=""><li id="777d" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">before()</code>:这个钩子中的逻辑在测试集合中的所有测试用例之前运行。</li><li id="f415" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">after()</code>:这里面的逻辑在所有测试用例之后运行。</li><li id="3649" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">beforeEach()</code>:这个里面的逻辑在集合中的每个测试用例之前运行。</li><li id="647b" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">afterEach()</code>:在每个测试用例之后运行其中的逻辑。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d8e7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">编写您的第一个单元测试</h1><p id="238f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">要使用Mocha和Chai编写第一个单元测试，首先让我们创建一个名为<code class="fe lv lw lx ly b">isNumValid</code>的简单函数，它对10到70之间的值返回true，对大于或等于70且小于或等于10的值返回false。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以编写测试来验证这个函数的行为。我们在测试目录中创建一个新文件，名为<code class="fe lv lw lx ly b">validator.js</code>，来编写这个测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须将<code class="fe lv lw lx ly b">validator.js</code>文件导入到我们的测试文件中，以便访问正在测试的函数。在我们的例子中，函数写在<code class="fe lv lw lx ly b">src</code>目录下的<code class="fe lv lw lx ly b">validator.js</code>文件中。</p><p id="bf1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了我们在这里使用的断言样式<code class="fe lv lw lx ly b">expect</code>，Chai还提供了另外两种断言样式<code class="fe lv lw lx ly b">should</code>和<code class="fe lv lw lx ly b">assert</code>。您可以在<a class="ae ky" href="https://www.chaijs.com/guide/styles/" rel="noopener ugc nofollow" target="_blank"> Chai断言风格指南</a>中了解更多关于这些风格的差异和用例。</p><h2 id="5000" class="nh mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">运行测试</h2><p id="3825" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用npm test命令运行这些测试。Mocha输出测试结果，并在命令行上显示出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d1ab6eaf1fbd07f050e9774786243db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9axBmK25WxRHdVOde_ITA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试通过成功输出</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="49e8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">失败的测试案例</h1><p id="f8ff" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设我们在编写<code class="fe lv lw lx ly b">isNumValid</code>函数时犯了一个错误。我们忘记了添加带有大于号(&gt;)和小于号(&lt;)运算符的等号条件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="de9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们再次运行测试时，由于这个错误，一个测试用例失败了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/b810be5141bf0d91a86fa130700acaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vxg3yJ1OGj6U2CoPhwyChQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试失败输出</p></figure><p id="c34d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为有了单元测试，我们能够很容易地捕捉并纠正这样的错误，而不必花费数小时去寻找错误在哪里。</p><p id="dfc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在上面的场景中，只有一个测试用例失败了，尽管我们在两个布尔操作符上都犯了同样的错误。这是一个问题。但是这是单元测试的缺点吗？</p><p id="36c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，这是我们测试用例中的一个缺点。我们没有考虑所有的输入场景，也没有为每个场景编写单独的测试用例。我们将边界条件(当数量在10到70之间时)与其他失败的测试条件结合起来，而不是为每个条件编写单独的测试用例。</p><p id="b930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当遵循适当的单元测试实践时，我们的测试套件应该总共包含五个测试用例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="45db" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="6c84" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在本文中，我们简单快速地介绍了测试、单元测试和Node.js中的测试。在下一篇文章中，我们将进一步探讨Node.js中的测试主题。我们将讨论编写复杂的测试用例、集成测试以及其他测试实践，比如使用mocks和stubs。</p><p id="a546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>