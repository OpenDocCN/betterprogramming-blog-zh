# JavaScript 中的递归

> 原文：<https://betterprogramming.pub/recursion-inside-javascript-cde90a37e934>

## JavaScript 中一个强大的概念

![](img/9614dec330677ce06364b9a835e680d5.png)

*Clark ti BBS 在 Unsplash 上拍摄的照片*

如果你是递归的新手，这篇文章有望帮助你更清楚地理解这个概念。

JavaScript 开发人员使用许多技术来构建强大的应用程序，今天我们将讨论*递归*——一个简单地调用自身直到满足条件的函数。

例如，假设我们有一个青蛙列表，我们想计算它们舌头宽度的总和。

虽然有几种方法可以实现我们的目标，但是为了这篇文章，我们将使用递归来解释它是如何工作的。

这个示例代码有效地调用它自己，直到它达到它的目标——青蛙舌头所有宽度的总和。

## 下面是函数内部发生的情况

首先，它检查是否因为某种原因，我们传入了一个无效的青蛙参数。这是用来防止应用程序崩溃，而是返回初始数字。

我们还使用了一个`console.error`来通知开发人员他搞砸了，并去做得更好。

正如[库里函数](https://medium.com/better-programming/currying-inside-javascript-a19f29600880)一样，让一个函数成为递归函数需要遵循一些规则。否则，函数不会变成递归函数。在构造递归函数时，有三个最重要的关键特性需要考虑。

# 递归的三个重要规则

## 1.函数应该有一个自毁的条件

所有递归函数都应该遵循的三个重要规则中的第一个是函数可以用来终止(或自毁)自身的条件。

如果没有终止自身的条件，您的代码很有可能会被引入意想不到的错误。通常，这些错误是你想要避免的，因为它是灾难性的，比如*无限循环*或*不正确的数据类型*，它们会导致你的应用崩溃。

然而，在一天结束时总会有一个终止条件，但你想成为发号施令的人。这是递归的主要工作之一。

否则，你的函数很有可能会无限运行下去，因为它唯一知道的没有终止条件的事情就是调用自己，直到有东西停止它——而这个东西就是我们最可怕的噩梦:无限循环。

在我们前面的示例代码中，我们的第一个条件是*终止条件*:

如果`frogs`参数是无效的数据类型，我们的应用程序可能会在没有这种情况下崩溃，因为之后的代码使用了只有数组才能使用的方法:

```
if (frogs.length === 0) {
  return totalWidth
}
```

因此，如果我们使用错误的数据类型调用函数，例如`null`:

```
const result = findTotalFrogWidths(0, null)
```

然后，我们得到一个导致程序崩溃的错误:

## 2.该函数必须有一个基本条件

三个关键特征中的第二个是有一个基本条件。基本条件对递归函数的作用与终止条件非常相似，除了它代表你的目标——一个快乐的结局！

基本用例通常用一个`if`语句来声明。代码片段中的第二个条件是*基础案例*:

```
*// We have reached the end. Return the total sum*
if (frogs.length === 0) {
  return totalWidth
}
```

之所以说它是基本条件，是因为当`frogs`数组为*空*时，不再有更多的项需要迭代，所以我们不能再做什么了，我们只返回总和。

## 3.自称为

最后，三个中的最后一个定义了一个条件，如果该条件仍然有效，函数必须调用自己(这意味着不满足*终止* ***和*** *基本条件*)。

递归的这一部分构成了递归中的“re”。为了满足基本条件或终止条件，函数必须 *re* do(调用)自身继续，直到满足其中一个条件。

让我们来看一个取自[堆栈溢出链接](https://stackoverflow.com/questions/40982840/javascript-recursion-with-loop)的不同例子。

在这个代码片段中，`test`是一个函数，它接受一个参数`x`(应该是一个数字类型)并反复调用自己，同时递增`x`的值，直到它不再小于`3`。

# 结论

而这就是本文的结尾！我希望你发现这是有价值的，并期待在未来更多。