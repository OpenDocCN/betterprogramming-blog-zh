<html>
<head>
<title>Develop a Rust Macro To Automatically Write SQL Boilerplate Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发一个Rust宏来自动编写SQL样板代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/develop-a-rust-macro-to-automatically-write-sql-boilerplate-code-60c25d86adcb?source=collection_archive---------4-----------------------#2022-09-28">https://betterprogramming.pub/develop-a-rust-macro-to-automatically-write-sql-boilerplate-code-60c25d86adcb?source=collection_archive---------4-----------------------#2022-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0083" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于Rust的元编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/88f7bf865513c921c10bd86fd3d8a25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTbxMZEoaLdpj7WoEJgivA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/do_exploit-19423556/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=5933101" rel="noopener ugc nofollow" target="_blank">做利用<a class="ae kv" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=5933101" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>中的</a></p></figure><p id="9ffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事描述了一个Rust宏的编写，它自动实现SQL语句的包装方法，以减少使用SQL数据库时的样板代码需求。该宏在<a class="ae kv" href="https://crates.io/crates/derive-sql" rel="noopener ugc nofollow" target="_blank"> crates.io </a>上可用，但在现阶段仍处于发展中，有许多限制，包括仅支持<code class="fe ls lt lu lv b">rusqlite</code>包装器。程序宏的源代码可以在麻省理工学院开源许可下在https://github.com/juliendecharentenay/derive-sql获得。</p><p id="4bf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写了这个代码和故事，因为我想完善我对过程宏的理解。我选择围绕SQL开发一些东西，因为我预计我的电子邮件屏蔽附带项目—<a class="ae kv" href="https://1-ml.com" rel="noopener ugc nofollow" target="_blank">https://1-ml.com</a>—将需要它来存储和检索使用统计数据。</p><p id="7aba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事中表达的观点/意见是我自己的。这个故事与我的个人经历和选择有关，并提供了希望有用的信息，但没有任何担保。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="e964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的学习是从Rust编程语言的“如何编写自定义派生宏”一节开始的——<a class="ae kv" href="https://doc.rust-lang.org/book/ch19-06-macros.html#how-to-write-a-custom-derive-macro" rel="noopener ugc nofollow" target="_blank">https://doc . Rust-lang . org/book/ch19-06-macros . html # How-to-write-a-custom-derive-macro</a>而编码之旅是从创建一个名为<code class="fe ls lt lu lv b">derive-sql</code>的库箱开始的，下面的<code class="fe ls lt lu lv b">Cargo.toml</code>中的<code class="fe ls lt lu lv b">proc-macro=true</code>将它声明为一个过程化宏……</p><h1 id="787a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">目标</h1><p id="4f89" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">程序宏的目标是促进SQL数据库中<code class="fe ls lt lu lv b">struct</code>的存储和检索。例如，这个故事使用以下数据结构来存储联系人:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="99a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">DeriveSql</code>宏为<code class="fe ls lt lu lv b">Contact</code>实现以下方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7dc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想指出几个方面:</p><p id="8619" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我选择让<code class="fe ls lt lu lv b">insert</code>、<code class="fe ls lt lu lv b">update</code>和<code class="fe ls lt lu lv b">delete</code>方法在被调用时消费对象。除了允许方法链接之外，这种选择没有特别的原因——这可能相关，也可能不相关。</p><p id="8e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该实现基于包装SQLite的<code class="fe ls lt lu lv b">rusqlite</code>机箱。从长远来看，我希望尝试使它与SQL引擎无关，以便它与<code class="fe ls lt lu lv b">rust-postgres</code>机箱兼容(并且可能作为一个扩展目标，为web客户端应用程序添加与<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB API </a>的兼容性)。</p><h1 id="857d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">测试驱动开发</h1><p id="839b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">对于这个项目，我选择了使用文档测试的测试驱动开发。使用这种方法，我必须同时编写文档和测试。这是我喜欢Rust的一个方面——它使应用(甚至驱使我)良好实践变得容易。</p><p id="eda0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文档测试采用以下形式——为了可读性，已经删除了必需的<code class="fe ls lt lu lv b">//!</code>前导注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我首先从实现<code class="fe ls lt lu lv b">create_table</code>方法开始，然后逐渐添加其他方法及其相关测试。在这个阶段，没有一个测试成功，因为还没有实现任何东西。</p><h1 id="d10f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">履行</h1><h2 id="c88d" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated">解决纷争</h2><p id="4c0c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在谈论实现本身之前，这一段讨论了当事情不按计划进行时可以做些什么。</p><p id="ecea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用程序宏解决问题并不简单。编写过程宏是一种“像编译器一样思考”的练习。一个人编写代码，然后生成要编译的代码。这会导致代码中出现不可见的编译错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ebea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这样的问题要么需要一个优秀的开发人员——我不是——大量的试验和错误，要么让“不可见”的代码可见。后者很容易实现，既可以使用<code class="fe ls lt lu lv b">cargo-expand</code>机箱——参见这里的<a class="ae kv" href="https://crates.io/crates/cargo-expand" rel="noopener ugc nofollow" target="_blank"/>——也可以使用编译器命令(由<code class="fe ls lt lu lv b">cargo-expand</code>包装)。如下所示的编译器命令仅在<code class="fe ls lt lu lv b">nightly</code>中可用，即需要使用<code class="fe ls lt lu lv b">rustup default nightly</code>将Rust工具链从<code class="fe ls lt lu lv b">stable</code>更改为<code class="fe ls lt lu lv b">nightly</code>:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="467e" class="nc me iq lv b gy ns nt l nu nv">cargo rustc --profile=check -- -Zunpretty=expanded</span></pre><p id="2a98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢直接使用编译器命令，因为它省去了添加另一个依赖项。在上面的情况下使用它，我得到了下面的代码摘录，我的错误很明显——我试图使用<code class="fe ls lt lu lv b">r.get(0)?</code>(第8行和第9行),但是它被扩展成一个字符串来代替代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3d19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将扩展代码输出到文件中有时会很有帮助。生成的代码，经过一点点调整以避免编译错误，如下所示，可以被编辑以研究要做的修改，并看看成功是什么样子的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="1c3d" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated">实现结构</h2><p id="048a" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我将<code class="fe ls lt lu lv b">DeriveSql</code>宏的实现结构化为(a)一个包含文档和入口函数<code class="fe ls lt lu lv b">derive_sql</code>的<code class="fe ls lt lu lv b">lib.rs</code>和(b)一个<code class="fe ls lt lu lv b">struct</code><code class="fe ls lt lu lv b">ImplDerive</code>——在文件<code class="fe ls lt lu lv b">implderive.rs</code>中——负责代码生成。代码生成在下面显示的方法<code class="fe ls lt lu lv b">generate</code>中完成。独立方法上的方法支架，每个方法对应于一个要实现的方法——也就是说，一个名为<code class="fe ls lt lu lv b">impl_create_table</code>的方法为方法<code class="fe ls lt lu lv b">create_table</code>生成代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7fb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">《铁锈之书》可能比我更好地解释了程序宏的工作原理。但是让我尝试用我自己的话和理解来表述它。</p><p id="0626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">程序宏编写基于应用程序宏的代码编译的代码。在衍生宏的情况下，程序宏应用于<code class="fe ls lt lu lv b">struct</code>、<code class="fe ls lt lu lv b">enum</code>或<code class="fe ls lt lu lv b">union</code>。程序宏读取的代码以<code class="fe ls lt lu lv b">TokenStream</code>的形式提供——名义上是一个令牌流。使用<code class="fe ls lt lu lv b">syn</code>库(参见<a class="ae kv" href="https://docs.rs/syn/latest/syn/" rel="noopener ugc nofollow" target="_blank">文档</a>)对该<code class="fe ls lt lu lv b">TokenStream</code>进行解析，以在衍生宏场景中生成可用的数据结构<code class="fe ls lt lu lv b">DeriveInput</code>——参见<a class="ae kv" href="https://docs.rs/syn/latest/syn/struct.DeriveInput.html" rel="noopener ugc nofollow" target="_blank">文档</a>——表示应用程序宏的<code class="fe ls lt lu lv b">struct</code>(或<code class="fe ls lt lu lv b">enum</code>或<code class="fe ls lt lu lv b">union</code>)，即<code class="fe ls lt lu lv b">struct</code>前面有<code class="fe ls lt lu lv b">#[derive(...)]</code>。</p><p id="8ce1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">DeriveInput</code>数据结构中可用的信息，程序宏将生成一个表示所生成代码的标记流。为此，使用了<code class="fe ls lt lu lv b">quote</code>板条箱——参见<a class="ae kv" href="https://docs.rs/quote/latest/quote/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="7094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的挑战一直是(现在仍然是)理解并恰当地使用<code class="fe ls lt lu lv b">DeriveInput</code>数据结构和<code class="fe ls lt lu lv b">quote::quote!</code>宏。</p><p id="2539" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的实现中，<code class="fe ls lt lu lv b">ImplDerive</code> <code class="fe ls lt lu lv b">struct</code>存储了对从输入<code class="fe ls lt lu lv b">TokenStream</code>创建的<code class="fe ls lt lu lv b">DeriveInput</code>对象的引用，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="51ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个故事中，我讨论了两种方法的实现:<code class="fe ls lt lu lv b">create_table</code>，因为它相对简单，和<code class="fe ls lt lu lv b">insert</code>，因为它稍微复杂一些。其他方法的实现可以在<a class="ae kv" href="https://github.com/juliendecharentenay/derive-sql/blob/main/src/implderive.rs" rel="noopener ugc nofollow" target="_blank">https://github . com/juliendecharentenay/derive-SQL/blob/main/src/impl derive . RS</a>查看。</p><h2 id="f9bc" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated">“create_table”的实现</h2><p id="18a2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">对于我们使用<code class="fe ls lt lu lv b">Contact</code>的示例，方法<code class="fe ls lt lu lv b">create_table</code>的实现如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="43ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码显示了生成方法<code class="fe ls lt lu lv b">create_table</code>实现的程序宏。为了便于解释，展开了两个方法调用<code class="fe ls lt lu lv b">self.name()</code>和<code class="fe ls lt lu lv b">self.get_fields_named()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b93c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实施分为两部分:(a)准备信息和语句——第6行和第37行——以及(b)使用<code class="fe ls lt lu lv b">quote!</code>宏生成令牌流——第39行到第45行。</p><p id="e2b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我看来，理解令牌流是如何生成的是关键。<code class="fe ls lt lu lv b">quote!</code>使用令牌流和令牌标识符解释Rust代码。在上面第49行代码中，<code class="fe ls lt lu lv b">#name</code>是指第7行定义的变量<code class="fe ls lt lu lv b">name</code>的内容，这是应用了derive宏的<code class="fe ls lt lu lv b">struct</code>的名称，即本例中的<code class="fe ls lt lu lv b">Contact</code>。</p><p id="d415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看了上面这个，我可能会(错误地)假设<code class="fe ls lt lu lv b">Contact</code>可以写成<code class="fe ls lt lu lv b">impl My#name</code>改成<code class="fe ls lt lu lv b">MyContact</code>。不幸的是，事情并非如此。为了做出这样的改变，需要使用类似于<code class="fe ls lt lu lv b">syn::Ident::new(format!("My{}", name), name.span())</code>的东西来定义一个新的<code class="fe ls lt lu lv b">Ident</code>。</p><p id="053e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成<code class="fe ls lt lu lv b">create_table</code>方法的挑战在于检索应用了派生宏的<code class="fe ls lt lu lv b">struct</code>的成员。这些成员用于生成创建表的SQL语句。这是通过(a)检查宏是否应用于数据<code class="fe ls lt lu lv b">struct</code>(第10–14行)以及<code class="fe ls lt lu lv b">struct</code>字段是否为命名字段(第15–19行)，以及(b)使用命名字段的名称并将其类型转换为SQL类型(第24–25行)，基于命名字段的列表构建SQL查询语句来实现的。</p><h2 id="0556" class="nc me iq bd mf nd ne dn mj nf ng dp mn lf nh ni mp lj nj nk mr ln nl nm mt nn bi translated">执行<code class="fe ls lt lu lv b">`</code>选择<code class="fe ls lt lu lv b">`</code></h2><p id="36de" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">对于我们的例子，使用<code class="fe ls lt lu lv b">Contact</code>，方法<code class="fe ls lt lu lv b">select</code>的实现将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码显示了生成<code class="fe ls lt lu lv b">select</code>方法实现的程序宏:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">select</code>和<code class="fe ls lt lu lv b">create_table</code>功能的主要区别在于第39行。第39行从SQL语句返回的字段中生成一个<code class="fe ls lt lu lv b">Contact</code>对象。<code class="fe ls lt lu lv b">#( #fields: #fields_assignment ), *</code>导致两个向量的扩展:<code class="fe ls lt lu lv b">fields</code>和<code class="fe ls lt lu lv b">fields_assignement</code>，带有一个<code class="fe ls lt lu lv b">,</code>字符分隔符——导致语句<code class="fe ls lt lu lv b">name: r.get(0)?, phone_number: r.get(1)?</code>。这在<code class="fe ls lt lu lv b">quote</code>板条箱文档的<a class="ae kv" href="https://docs.rs/quote/latest/quote/macro.quote.html#interpolation" rel="noopener ugc nofollow" target="_blank">插补</a>部分有解释，值得详细阅读。</p><p id="96a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向量<code class="fe ls lt lu lv b">fields</code>是包含命名字段标识符的向量，即<code class="fe ls lt lu lv b">name</code>、<code class="fe ls lt lu lv b">phone_number</code>等。，为<code class="fe ls lt lu lv b">Ident</code>。</p><p id="1010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向量<code class="fe ls lt lu lv b">fields_assignment</code>包含赋值方。回到故障排除部分，我最初的方法是使用一个字符串向量。但是如前一节所述，<code class="fe ls lt lu lv b">quote!</code>宏对一串标记进行操作，因此字符串向量中的每个字符串都被视为一个字符串标记。</p><p id="0a1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第32行，上面的代码显示了所选择的方法，其中向量<code class="fe ls lt lu lv b">fields_assignment</code>是令牌流的向量——每个令牌流都是使用<code class="fe ls lt lu lv b">quote!</code>宏生成的。我花了一些时间才明白，但我最终还是明白了。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="24bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事非常简要地概述了我开发过程宏的历程。我希望它对那些对类似工作感兴趣的人有所帮助。虽然生成相对简单的代码听起来工作量很大，但在我看来，它的好处在于只需编写一次代码，就可以在任何地方应用它。</p><p id="773c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<code class="fe ls lt lu lv b">DeriveSql</code>宏，它是一个正在进行中的工作，有许多缺点——包括我缺乏SQL知识。我将进一步开发它，以满足我的需求——如果需要的话，也满足其他人的需求(通过<a class="ae kv" href="https://github.com/juliendecharentenay/derive-sql" rel="noopener ugc nofollow" target="_blank"> GitHub </a>联系)——希望它能成为Rust生态系统的有用补充。</p><p id="7abd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。敬请关注更多内容。</p></div></div>    
</body>
</html>