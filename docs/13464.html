<html>
<head>
<title>Build Your Own Git With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建您自己的Git</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-own-git-with-typescript-64571ae7c6d0?source=collection_archive---------16-----------------------#2022-08-29">https://betterprogramming.pub/build-your-own-git-with-typescript-64571ae7c6d0?source=collection_archive---------16-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9333" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们构建一些很酷的git特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f50ba9244cf76f057fee532a2b664f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oRsDVbBXg70QqiHJ.png"/></div></div></figure><p id="c48b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在今天的实验中，我想和大家分享如何用TypeScript构建Git的几个特性。当然会有更好的方法来做这件事，但这里是我如何看待和解决这个问题。这是一个复杂事物的简单化观点，希望你喜欢。</p><p id="7bc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们开始之前，如果你想跟随我并和我一起编码，你将有一些以前使用工具和技术的经验，下面是列表:</p><ul class=""><li id="0afc" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">VS代码</li><li id="6134" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">结节</li><li id="24a3" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">以打字打的文件</li><li id="37ef" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">Git基础</li></ul><p id="d9e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个链接，您可以在其中查看最终代码:</p><div class="mb mc gp gr md me"><a href="https://github.com/maaxg/my-own-git" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">GitHub - maaxg/my-own-git:教育资源</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kp me"/></div></div></a></div><h1 id="7002" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">我们将要建造的</h1><p id="e53b" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">在这篇文章中，我们将构建6个基本功能，为了比我在这里给你的解释更好，请查看官方文档，你可以在这里开始<a class="ae nq" href="https://mirrors.edge.kernel.org/pub/software/scm/git/docs/user-manual.html#repositories-and-branches" rel="noopener ugc nofollow" target="_blank"/>。</p><ul class=""><li id="1d27" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">贮藏室ˌ仓库</li><li id="37e3" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">犯罪</li><li id="768f" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">提交链接</li><li id="0e8c" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">分支</li><li id="55c2" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">暂存文件</li><li id="c239" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">用户输入和命令</li></ul><h1 id="6942" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">配置项目</h1><p id="7649" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">让我们开始用一些依赖项来配置我们的项目</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9df7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建<strong class="kt ir"> <em class="nt"> babel.config.js </em> </strong>文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="666c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加完这些依赖项后，确保使用冒烟测试来测试<code class="fe nu nv nw nx b">jest</code>，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="463d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一切都解决了，让我们开始建造我们的东西=)</p><h1 id="3485" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">贮藏室ˌ仓库</h1><p id="d63a" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">当你想在你的项目中使用Git时，首先要创建一个存储库，然后我们将从它开始，考虑到存储库是将要包装我们将要实现的特性的一切，我们将在我们的项目中调用GIT，让我们从创建一个名为<code class="fe nu nv nw nx b">GitI</code>的接口开始。</p><p id="a979" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个接口中，我们将声明Git类的外观</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a5c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们在我们的<code class="fe nu nv nw nx b">Repository</code> (Git)类中实现这个接口</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="03ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这第一个时刻，我们的存储库将只负责存储库的名称。</p><p id="7aa7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在创建了这个类之后，我们现在可以很容易地用jest来测试它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f831" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该命令与以下内容相关:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="9c6c" class="oc mu iq nx b gy od oe l of og">git init</span></pre><p id="7617" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">git init</code>初始化一个存储库，这意味着这个命令创建所有的文件，这些文件将封装所有的东西，并允许我们使用其他命令，如:<code class="fe nu nv nw nx b">git log</code>。</p><h1 id="9e37" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">犯罪</h1><p id="10a5" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">简而言之，提交是您暂存的文件内容的快照。让我们从创建我们的<em class="nt">提交接口开始。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ec4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了生成我们的id，我们将使用<a class="ae nq" href="https://www.npmjs.com/package/sha1" rel="noopener ugc nofollow" target="_blank"> sha-1库</a>来生成类似于GIT hash的东西，首先让我们使用我们的消息作为内容来生成我们的id。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="77c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这第一个时刻，我们不会为这个提交设置作者，如果你愿意，你可以这样做，但是我不会关注我们如何跟踪用户的提交。</p><p id="389d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们测试我们的提交类，验证我们的id是否是用正确的散列生成的，请记住，对于特定的字符串，输出将总是相同的，这样，字符串<code class="fe nu nv nw nx b">message</code>将总是:<code class="fe nu nv nw nx b">6f9b9af3cd6e8b8a73c2cdced37fe9f59226e27d</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8084" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看Git如何知道文件如何更改以及他如何能够进行转移的简单方法是通过比较哈希，让我们在一个示例中看到它</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="1037" class="oc mu iq nx b gy od oe l of og">// index.ts<br/>export * from "./git"<br/>export * from "./commit"</span></pre><p id="1d9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以认为这个特定的文件只不过是一个格式化的字符串，因此这个格式化的字符串将生成一个特定的哈希，如果我们进行这个测试，并将这个文件的内容放到sha1函数上，它将返回这个特定的哈希:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="9022" class="oc mu iq nx b gy od oe l of og">const sha = sha1(fs.readFileSync('./index.ts', {encoding: 'utf-8'}))<br/>console.log(sha)<br/>// sha = 0280670383ddc7cd6640f60f6e4a10eb1799f807</span></pre><p id="0e77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们修改我们的文件并添加一个新的行，我们期望这个函数会产生这个散列</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="b3d1" class="oc mu iq nx b gy od oe l of og">// index.ts<br/>export * from "./git"<br/>export * from "./commit"<br/>export * from './branch'</span><span id="c70b" class="oc mu iq nx b gy oh oe l of og">const sha = sha1(fs.readFileSync('./index.ts', {encoding: 'utf-8'}))<br/>console.log(sha)<br/>// sha = 84d89b5dbc2a304b1564d1761a68e8938ee7ea07</span></pre><p id="f149" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将会注意到散列已经改变，这是GIT知道文件改变的方式。</p><h1 id="23a9" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">提交历史记录</h1><p id="9763" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">在创建了我们的<em class="nt">提交类</em>之后，我们现在可以用提交历史将提交相互关联起来。</p><p id="6c34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">历史是旧的提交和新的提交之间的关系，其中新的提交被添加到列表的头部，而旧的提交更靠近尾部。</p><p id="e830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从向<em class="nt">提交接口添加一些新功能开始:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="61d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以注意到我们在提交接口中添加了两个新东西，父属性和<code class="fe nu nv nw nx b">getCommitLog</code>函数。</p><p id="ec9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">父属性是如何将提交相互关联，Git使用<a class="ae nq" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank">链表</a>来保存分支的提交历史。</p><p id="afc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">链表是一种数据结构，本质上是内存中彼此相关(双重)或与下一个元素相关(简单)的元素序列:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/824c53f6ee709fd16fec74c7f13dff90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hw28GEk3Qab08DoPwb_eg.png"/></div></div></figure><p id="72f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">Head</code>是链表开始的地方，链表的最后一项将指向空。</p><p id="182a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的实现中，基本上是相同的，但是当向我们的提交列表追加新的提交时，我们将把新的提交设置为列表的头部。</p><p id="88fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们创建<code class="fe nu nv nw nx b">getCommitLog</code>函数之前，让我们稍微修改一下构造函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ad3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始创建<code class="fe nu nv nw nx b">parent</code>提交并在我们的构造函数中初始化它，将创建<code class="fe nu nv nw nx b">Commit</code>类的实例的类或文件将负责给出与该实例相关的提交信息。</p><p id="ae0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以创建提交历史并在<code class="fe nu nv nw nx b">Commit</code>类中创建<code class="fe nu nv nw nx b">getCommitLog</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3eb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数所做的是返回一个id(我们的散列)数组，你可以自定义它，用一个我已经满意的散列数组，如果你想添加整个类或者只是一个自定义对象，请这样做，和我分享一下你是如何自定义这个函数的。</p><p id="ceee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们逐行了解正在发生的事情，让我们从<code class="fe nu nv nw nx b">commitAux</code>开始，这是<code class="fe nu nv nw nx b">CommitI</code>类型或<code class="fe nu nv nw nx b">null</code>的辅助变量，所以它可以是我们列表的头、尾或任何元素。在第一时间，它会接受我们自己的阶级的价值。另一个变量是<code class="fe nu nv nw nx b">history</code>,在这个变量中，我们将保存列表的id。</p><p id="d1c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以直接查看我们的while循环，它接收<code class="fe nu nv nw nx b">commitAux</code>作为条件，这意味着当<code class="fe nu nv nw nx b">commitAux</code>不为空时将继续循环，在while循环中，我们将<code class="fe nu nv nw nx b"><a class="ae nq" href="http://commitAux.id" rel="noopener ugc nofollow" target="_blank">commitAux.id</a></code>添加到<code class="fe nu nv nw nx b">history</code>中，并为<code class="fe nu nv nw nx b">commitAux</code>设置一个新值，作为上一次提交的父项，在某个时候<code class="fe nu nv nw nx b">commitAux</code>将成为<code class="fe nu nv nw nx b">null</code>，while循环将结束，并将返回我们的数组:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/78913e5c0ca18c26df3fd62303b064c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vv9xNK_TdVhQgk2P3DxJmQ.png"/></div></div></figure><p id="336f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们实现Branch类时，我将让测试代码的这个特定部分，所以让我们继续我们的实验</p><h1 id="3c28" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">树枝</h1><p id="358d" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">分支是我们在Git中分离代码的方式。</p><p id="a96f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我给你举个例子，你和另外两个开发人员在一个团队中，他们在云上运行相同的代码库。您已经有了一个准备投入生产的特性，您需要生成一个具有该特性的构建，并需要将它发送到您的基于could的代码中。另一方面，你的同事正在开发一个测试功能，不应该投入生产，但是他们需要把它发送到云中。分支可以很容易地解决这个问题，分支是代码库的克隆，在那里你可以做任何你想做的改变，而不会弄乱原来的代码，避免冲突，并且将责任与特定的分支分开。在这个例子中，我们可以创建两个分支，一个分支只接受准备生产的代码，另一个分支是测试分支或开发分支。</p><p id="ac21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以在一天结束的时候，分支指向一个修改，我们以提交的形式保存修改，这意味着一个分支指向一个提交，那个分支指向另一个提交，等等。</p><p id="7354" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下图中，您可以认为可以交付给生产的代码在<strong class="kt ir">主</strong>中，我们可以认为分支<strong class="kt ir">测试</strong>可以在没有描述的情况下进行测试，两个分支指向相同的提交</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/9307167eeffe26ffe7fa0e0846e5f4bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXxT-U0jMuwrgPhCysl1Gw.png"/></div></div></figure><p id="df46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，考虑您的同事将他们的变更推送到测试分支，这将看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/eb979d3d78a06800082f7901a0a1c555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRHfkgJF-CXGXKlV9GQcjQ.png"/></div></div></figure><p id="a8d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在你的同事所做的改变不会影响到主节点，他们在这个树的不同分支中。</p><p id="09ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果您将您的更改推送到master，看起来会是这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/e8fa461fcf1e4edea5b23ac383574f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsLdOMci7bWD08vDhlb7vA.png"/></div></div></figure><p id="29df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">变化互不影响，但都指向同一个起点。</p><p id="b64c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在只是用TypeScript复制这个。</p><p id="c56f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从创建我们的<em class="nt">分支接口开始，</em>我们将从添加一个<code class="fe nu nv nw nx b">name</code>和一个<code class="fe nu nv nw nx b">commit</code>作为分支的属性开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cd16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现该接口将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="091b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单，现在让我们测试我们的分支类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="984a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很酷，但这并没有做太多，我们只有一个类，可以返回给我们一个名字和一个提交，这基本上是什么都不做。</p><p id="505c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们对Git接口进行一些修改并添加一些真正的功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3fed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将这些特性添加到我们的Git类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="130e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇，现在Git类中发生了很多事情，所以让我们从新属性开始，最后让checkout函数。</p><p id="4ab0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">branch</code>属性将是存储库的当前分支，因此它将是存储库此刻将看到的代码。</p><p id="fb7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分支是私有属性，这意味着只有类可以访问，这个属性不对外公开，它是一个分支数组，这意味着我们要在这个数组中存储我们创建的分支。</p><p id="7d95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在构造函数中，我们将分支初始化为一个空数组，下面我们创建第一个名为“<code class="fe nu nv nw nx b">main</code>”的分支，添加到<code class="fe nu nv nw nx b">branches</code>数组中，并将其设置为当前分支。</p><p id="e3aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">私有方法<code class="fe nu nv nw nx b">add</code>正在向我们的数组推送新的分支。</p><p id="1e25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，最后，我们在<code class="fe nu nv nw nx b">checkout</code>方法上，这个方法接收您想要检查的分支的名称作为属性。</p><p id="95fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着如果分支存在于我们的存储库中，我们将切换到它</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="6c67" class="oc mu iq nx b gy od oe l of og">// checkout<br/> const branchIdx = this.branches?.findIndex((branch) =&gt; branch.name === name);<br/> /* If branch already exists changes to existing branch */ <br/> if(branchIdx !== undefined &amp;&amp; branchIdx !== -1 &amp;&amp; this.branches?.length) {<br/>    this.branch = this.branches[branchIdx];<br/>    console.info(`Switched to branch: ${this.branch.name}`)<br/>    return this.branch;<br/>	}</span></pre><p id="3b91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果它不存在，我们将创建并切换:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="e4c1" class="oc mu iq nx b gy od oe l of og">// checkout<br/>      /* Create if does not exists */<br/>      this.branch = new Branch(name, this.branch?.commit);<br/>      this.add(this.branch)<br/>      console.info(`Created and Switched to: ${name}`)<br/>      return this.branch;</span></pre><p id="5856" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果没有传递名称，它将返回当前分支:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="d964" class="oc mu iq nx b gy od oe l of og">// checkout<br/>     if(!name){<br/>        console.info(`Current branch: ${this.branch.name}`)<br/>        return this.branch;<br/>      }</span></pre><p id="99c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，在实现之后，我们终于可以测试我们的新代码和提交历史。</p><p id="e802" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建这些新的测试用例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="a98c" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">暂存文件</h1><p id="84b3" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">暂存文件只不过是让Git知道一个文件或一组文件已经准备好提交。</p><p id="2472" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该操作由命令表示</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="78c1" class="oc mu iq nx b gy od oe l of og">git add file.txt</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/2dd16eaed219b7d2518a63e54b8a6974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kt_GS5az_VkH4RETgr3__g.png"/></div></div></figure><p id="5546" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">存储库中的每个文件都有两种状态:已跟踪或未跟踪。</p><p id="c3cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">跟踪的文件是上次快照(提交)中的文件，以及任何新转移的文件，简而言之，跟踪的文件是GIT知道的文件。</p><p id="d2bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">未跟踪的文件是其他所有文件，这种状态表示位于工作目录中但不在最后一个快照中且不在临时区域中的任何文件。</p><p id="acee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请检查<a class="ae nq" href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository" rel="noopener ugc nofollow" target="_blank">文件</a>以获取更多信息</p><p id="e265" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们将创建暂存被修改的跟踪文件的操作，我们希望暂存它<code class="fe nu nv nw nx b">**.**</code></p><p id="165e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建这个动作，并尝试用TypeScript来表示它</p><p id="137e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先创建添加接口</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1bf7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该接口将只有一个名为<strong class="kt ir"> stageFile的方法，</strong>该方法将接收一个文件路径作为属性。</p><p id="0a56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这之后，我们可以在<strong class="kt ir"> <em class="nt">中创建并实现我们的接口添加类</em> </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d781" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们只考虑一次存放一个文件。</p><p id="5060" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们了解一下Add类中发生了什么。</p><p id="0705" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们有一个私有属性叫做<code class="fe nu nv nw nx b">dbPath</code>这是DB(一个简单的路径。txt文件)，我们将在这里存储已暂存并准备提交的文件，我们将在构造函数中使用自定义路径或默认路径<code class="fe nu nv nw nx b">store.txt</code>初始化该属性。</p><p id="32fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe nu nv nw nx b">stageFile</code>方法中，我们验证它是否是一个有效的路径，如果是，我们将在文件中写入路径，如果不是则返回false。</p><p id="b951" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以测试<code class="fe nu nv nw nx b">stageFile</code>功能了</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dd01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们必须在Git类和接口中公开这个方法。</p><p id="0c4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们首先在<em class="nt"> Git接口:</em>中创建一个<code class="fe nu nv nw nx b">stageFile</code>函数的声明</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0981" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">添加这个声明后，我们可以在我们的<em class="nt"> Git类:</em>中实现这个函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4702" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该函数只是对<em class="nt"> Add类的一个调用。</em></p><h1 id="f129" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">提交中的文件内容</h1><p id="ce2d" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">在我们将文件存放在<code class="fe nu nv nw nx b">store.txt</code>文件中之后，我们需要将特定路径的内容转换成一个散列。</p><p id="d970" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们修改一下<code class="fe nu nv nw nx b">Commit class</code>中的一些东西:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a753" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会注意到，我们已经修改了要用存储在<code class="fe nu nv nw nx b">store.txt</code>文件中的文件路径内容生成的散列，这些内容由<code class="fe nu nv nw nx b">private function getStore</code>读取。在读取并生成散列后，我们用<code class="fe nu nv nw nx b">clearStore</code>函数清除该文件。</p><h1 id="d2d1" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">用户输入和命令</h1><p id="6137" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">到目前为止，我们已经构建了一些git特性，它们是:Repository、Branch、Commit和Add。</p><p id="6898" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们只测试jest的特性，它很好，但没有功能，让我们通过读取用户输入在我们的应用程序中创建一些真实的体验</p><p id="1272" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先创建一个文件，程序将从这个文件开始，我将把这个文件命名为:index.ts</p><p id="cba2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个文件将是程序的入口点，所以向用户提供一些信息是很酷的</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0dda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将使用<code class="fe nu nv nw nx b">ts-node</code>在桌面上构建我们的应用程序，所以请确保在您的<code class="fe nu nv nw nx b">package.json</code>中添加脚本<code class="fe nu nv nw nx b">start</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2950" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到<code class="fe nu nv nw nx b">index.ts</code>，从节点创建一个<code class="fe nu nv nw nx b">readLine</code>模块的实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0c1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建了这个实例之后，让我们创建一个Git类的实例来访问这些特性，并使用<code class="fe nu nv nw nx b">question</code>函数读取用户输入。</p><p id="df11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们创建了一个名为<code class="fe nu nv nw nx b">readCommand</code>的函数，并创建了一个递归函数，在用户的每个回答之后，该函数再次被激活，要求一个新的命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2e96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，添加<code class="fe nu nv nw nx b">on</code>监听器来观看节目，并向用户说“再见”</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b600" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，你可能注意到我还没有解释<code class="fe nu nv nw nx b">syntaxValidator</code>函数是做什么的，让我们深入一下。我从创建一个有效命令的数组开始，实际上类似于GIT命令，除了<code class="fe nu nv nw nx b">qti</code>，它是<code class="fe nu nv nw nx b"><a class="ae nq" href="https://www.google.com/search?q=quati&amp;client=ubuntu&amp;hs=Kq5&amp;channel=fs&amp;sxsrf=ALiCzsZBLZjb-vm0PRIfNesZ-9bU04OmmA:1661788759027&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=2ahUKEwi9rrHFtez5AhV8GLkGHZAzBP4Q_AUoAXoECAIQAw&amp;biw=1920&amp;bih=939&amp;dpr=1#imgrc=XSSSpP3fxv31oM" rel="noopener ugc nofollow" target="_blank">quati</a></code>的缩写，是一种非常可爱的动物</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e138" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在定义了这些有效值之后，我创建了<code class="fe nu nv nw nx b">syntaxValidator</code>函数，函数内部有很多东西，很多if和elses，真的不是你将看到的更清晰的代码，所以如果你有任何想法让事情变得更好或更可读，请在下面发表评论或在repo中打开PR，我将非常高兴听到你的意见。</p><p id="93a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不会深入研究这些函数，因为它们真的很简单，它们只是验证用户输入是否有效，所以你可以根据需要定制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8267" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">isCommandStartingProperly</code>功能验证用户输入是否以“qti”命令开始，以及“qti”之后是否有有效命令</p><p id="3cce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">isCheckoutCommandValid</code>函数验证用户输入是否有分支名称，如果有，是否传递给<code class="fe nu nv nw nx b">git.checkout</code>函数。</p><p id="f170" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">isBranchCommandValid</code>功能与<code class="fe nu nv nw nx b">isCheckoutCommandValid</code>几乎相同，但该功能使<code class="fe nu nv nw nx b">branch -m</code>命令有效。</p><p id="3d29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">isLogCommandValid</code>函数验证日志命令是否有效，如果历史中有提交，它返回历史，如果没有，告诉用户先提交。</p><p id="c6dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">isCommitCommandValid</code>函数验证<code class="fe nu nv nw nx b">commit -m</code>命令是否有效，并将消息提交给我们的提交。</p><p id="fdeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">isAddCommandValid</code>函数验证<code class="fe nu nv nw nx b">add</code>是否有效，并将文件的路径发送给<code class="fe nu nv nw nx b">stageFile</code>函数。</p><p id="996f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nu nv nw nx b">syntaxValidator</code>是入口点。</p><p id="d57a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实现这些函数后，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/09060d7edc8fdbe985bc2c0a5d3d597f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*3Klek8tWFAQ4O2JGDvCvXQ.png"/></div></figure><p id="ff13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在它只是测试你的命令和你实现的功能。</p><h1 id="fbb8" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">结论</h1><p id="106d" class="pw-post-body-paragraph kr ks iq kt b ku nl jr kw kx nm ju kz la nn lc ld le no lg lh li np lk ll lm ij bi translated">今天的文章到此结束，我们用TypeScript构建了Git的一些很酷的特性，我真的希望你喜欢它，任何建议或更正请在评论中告诉我。</p><h2 id="e5f3" class="oc mu iq bd mv om on dn mz oo op dp nd la oq or nf le os ot nh li ou ov nj ow bi translated"><strong class="ak">参考与启发</strong></h2><ul class=""><li id="76c3" class="ln lo iq kt b ku nl kx nm la ox le oy li oz lm ls lt lu lv bi translated"><a class="ae nq" href="https://github.com/codecrafters-io/build-your-own-x" rel="noopener ugc nofollow" target="_blank">https://github.com/codecrafters-io/build-your-own-x</a></li><li id="3c5d" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><a class="ae nq" href="https://kushagra.dev/blog/build-git-learn-git/" rel="noopener ugc nofollow" target="_blank">https://kushagra.dev/blog/build-git-learn-git/</a></li><li id="f012" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><a class="ae nq" href="https://www.youtube.com/watch?v=_7nISfpofec" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=_7nISfpofec</a></li><li id="b670" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><a class="ae nq" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/</a></li></ul><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="7739" class="oc mu iq nx b gy od oe l of og"><strong class="nx ir">Want to Connect?</strong></span><span id="433b" class="oc mu iq nx b gy oh oe l of og"><a class="ae nq" href="https://www.linkedin.com/in/maxsuel-gomes-79a2a1181/" rel="noopener ugc nofollow" target="_blank">Linkedin</a></span><span id="a1ac" class="oc mu iq nx b gy oh oe l of og"><a class="ae nq" href="https://github.com/maaxg" rel="noopener ugc nofollow" target="_blank">Github</a></span></pre></div></div>    
</body>
</html>