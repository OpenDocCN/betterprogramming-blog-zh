<html>
<head>
<title>The Secret of the React Render Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React渲染函数的秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/secret-about-react-render-function-abefcd32f625?source=collection_archive---------10-----------------------#2019-07-22">https://betterprogramming.pub/secret-about-react-render-function-abefcd32f625?source=collection_archive---------10-----------------------#2019-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4cbb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">区分调用渲染函数和实际的重新渲染</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f2ccbb474b23640e51e249e3723e380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SV7m7LlmyAdRwdestUdd8w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@casparrubin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae ky" href="https://unsplash.com/search/photos/react?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c58d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近写了一篇关于React-Redux和React Thunk 的文章，收到了很多反馈和问题。</p><p id="a3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数问题都是关于我的方法的性能。大家都说使用<a class="ae ky" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a> context会对其消费者造成不必要的重渲染。</p><p id="ae95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通过将<code class="fe lv lw lx ly b">console.log</code>放在一个渲染函数上并观察它来创建一个简单的测试。我发现了一些有趣的东西——它实际上并不是重新渲染，它只是被称为渲染函数。</p><p id="671f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迷茫？让我们找出原因。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ae4f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">标准React组件将在每次其父组件重新渲染时调用渲染函数</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/5c28749cf20275c56c22c26898d63d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBY8urRF115I2j7Eebm1Cw.png"/></div></div></figure><p id="53ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这个简单的例子。这是一个简单的计数器应用程序。每当用户点击“向上”按钮，计数器将增加1，应用程序组件得到重新呈现。</p><p id="78ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以问题是:“子组件也会被重新渲染吗？”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/8d34f56237fec1c0b736709598e214a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ce4OltclQ98E954b_EVobQ.png"/></div></div></figure><p id="bcb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看，当我们点击五次向上按钮时，它已经记录了五次<code class="fe lv lw lx ly b">child component re-render</code>,计数器增加到五。</p><p id="d7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这是否意味着子组件被重新渲染了？</p><p id="0372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">否</strong>，不重新渲染。它只是被调用了渲染函数，并没有真正的重新渲染。所以，我们需要区分“重新渲染”和“被调用函数渲染”。(在这种情况下，子组件是一个功能组件，所以呈现功能是它本身。)</p><p id="3164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当父组件被重新渲染时，普通组件将调用渲染函数。在这种情况下，app组件被重新呈现，因为当我们单击Up按钮时，它的状态发生了变化，所以它导致子组件调用render函数。</p><p id="d84a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当render函数被调用时，React会重新计算该组件的虚拟DOM，并将其与之前的虚拟DOM进行比较。</p><p id="4227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不同，React实际上会在我们的浏览器中重新渲染真实的DOM。如果没有，我们的浏览器没有任何变化。这是React快的主要原因。</p><p id="13a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示如何测试真正的DOM是否被更新。</p><h2 id="12ed" class="na mh it bd mi nb nc dn mm nd ne dp mq li nf ng ms lm nh ni mu lq nj nk mw nl bi translated">1.启用Chrome控制台中的渲染选项卡</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/2fcddfb99663a1938e2e9da1675ab362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76ZCKUtdQLXdb_fyVqG8NQ.png"/></div></div></figure><h2 id="9fb6" class="na mh it bd mi nb nc dn mm nd ne dp mq li nf ng ms lm nh ni mu lq nj nk mw nl bi translated">2.运行您的应用程序并观察</h2><p id="1849" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">每个被重新渲染的DOM节点将以绿色背景闪烁，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="51f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，在第一次加载时，整个DOM被重新渲染，因此背景绿色区域显示在整个页面上。</p><p id="c5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，当我们单击Up按钮时，即使控制台日志显示了五次，但是子组件(Hello text)没有重新呈现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f16b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如果调用setState，React组件还会调用Render函数</h1><p id="1d85" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果调用了【The React组件也会调用render函数，而不管state的值是否改变。</p><p id="6fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/30d6c92e7452c3c898550ab24fc348bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jU6Ef1koqJ66-1I7flGZg.png"/></div></div></figure><p id="3300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只将count对象的值设置为1并显示它。当计数值从0变为1时，您可能会认为<code class="fe lv lw lx ly b">console.log</code>(‘app’)只调用一次。</p><p id="2636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它实际上在我们每次点击向上按钮时都会调用。(参见控制台。)</p><p id="1c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件多次调用render函数，但真正的DOM只更新了一次。</p><p id="96ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，您可以使用调试工具中的渲染选项自行测试。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c628" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><ol class=""><li id="cd61" class="nv nw it lb b lc nn lf no li nx lm ny lq nz lu oa ob oc od bi translated">渲染函数调用只会触发虚拟DOM的重新渲染，这并不意味着真实DOM会重新渲染。</li><li id="bc5c" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">状态更改将触发渲染函数回调，无论其值是否更改。</li><li id="7011" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">明智地选择优化您的组件。你不应该到处使用<code class="fe lv lw lx ly b">PureComponent</code>,相反，更喜欢为列表组件优化，这些组件有繁重的JS计算。</li></ol><p id="4436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这首曲子。感谢阅读！</p></div></div>    
</body>
</html>