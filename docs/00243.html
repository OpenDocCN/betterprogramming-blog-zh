<html>
<head>
<title>Chrome Extension: Reading the BODY of an HTTP response object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chrome扩展:读取HTTP响应对象的主体</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/chrome-extension-intercepting-and-reading-the-body-of-http-requests-dd9ebdf2348b?source=collection_archive---------0-----------------------#2018-12-08">https://betterprogramming.pub/chrome-extension-intercepting-and-reading-the-body-of-http-requests-dd9ebdf2348b?source=collection_archive---------0-----------------------#2018-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5bf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文面向对</em><a class="ae kp" href="https://developer.chrome.com/extensions/getstarted" rel="noopener ugc nofollow" target="_blank"><em class="ko">Chrome扩展如何工作</em> </a> <em class="ko">有基本了解的人。</em></p><p id="d60e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Chrome扩展生态系统提供了API，允许我们开箱即用地部分读取和修改请求/响应头。我们有许多利用这些API的扩展，如<a class="ae kp" href="https://chrome.google.com/webstore/detail/requestly-redirect-url-mo/mdnleldcmiljblolnjhpnblkcekpdkpa" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a>，<a class="ae kp" href="https://chrome.google.com/webstore/detail/tamper-chrome-extension/hifhgpdkfodlpnlmlnmhchnkepplebkb?hl=en" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">篡改Chrome </strong> </a>。</p><p id="f1c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，当读取HTTP请求的主体时，事情变得有点棘手。在这篇文章中，我们将探讨一些方法来实现这一点，同时，我们也将看看与这些方法相关的缺点。</p><h1 id="dcc0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">使用内容脚本拦截数据</h1><p id="dc37" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated"><a class="ae kp" href="https://developer.chrome.com/extensions/content_scripts" rel="noopener ugc nofollow" target="_blank">内容脚本</a>是在当前网页的上下文中运行的有条件注入的脚本。内容脚本不能访问网页中运行的JavaScript。相反，它独立运行，并拥有使用标准JavaScript APIs读写DOM的权限。</p><p id="dd8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用我们的内容脚本在DOM中注入一个自定义脚本，并使用它来读取HTTP请求的响应体。现在，让我们配置我们的内容脚本。</p><p id="7fb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我们的<strong class="js iu"> manifest.json </strong>的样子:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="dab2" class="mc kr it ly b gy md me l mf mg">{<br/>    "content_scripts": [{<br/>        "js": ["contentScript.js"],<br/>        "run_at": "document_start"<br/>    }]<br/>}</span></pre><p id="1b47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">甚至在构建DOM之前,<strong class="js iu"> run_at </strong>字段就告诉扩展在web页面中注入内容脚本。现在让我们看看内容脚本的内容:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3391" class="mc kr it ly b gy md me l mf mg">function interceptData() {<br/>  var xhrOverrideScript = document.createElement('script');<br/>  xhrOverrideScript.type = 'text/javascript';<br/>  xhrOverrideScript.innerHTML = `<br/>  (function() {<br/>    var XHR = XMLHttpRequest.prototype;<br/>    var send = XHR.send;<br/>    var open = XHR.open;</span><span id="c65b" class="mc kr it ly b gy mh me l mf mg">    XHR.open = function(method, url) {<br/>        this.url = url; // the request url<br/>        return open.apply(this, arguments);<br/>    }</span><span id="b352" class="mc kr it ly b gy mh me l mf mg">    XHR.send = function() {<br/>        this.addEventListener('load', function() {<br/>            if (this.url.includes('&lt;url-you-want-to-intercept&gt;')) {<br/>                var dataDOMElement = document.createElement('div');<br/>                dataDOMElement.id = '__interceptedData';<br/>                dataDOMElement.innerText = this.response;<br/>                dataDOMElement.style.height = 0;<br/>                dataDOMElement.style.overflow = 'hidden';<br/>                document.body.appendChild(dataDOMElement);<br/>            }               <br/>        });<br/>        return send.apply(this, arguments);<br/>    };<br/>  })();<br/>  `<br/>  document.head.prepend(xhrOverrideScript);<br/>}</span><span id="1e9c" class="mc kr it ly b gy mh me l mf mg">function checkForDOM() {<br/>  if (document.body &amp;&amp; document.head) {<br/>    interceptData();<br/>  } else {<br/>    requestIdleCallback(checkForDOM);<br/>  }<br/>}</span><span id="5763" class="mc kr it ly b gy mh me l mf mg">requestIdleCallback(checkForDOM);</span></pre><p id="67d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们在这里做的是用我们自己的代码通过覆盖它的原型来扩展<a class="ae kp" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">XMLHttpRequest</strong></a><strong class="js iu">的send </strong>和<strong class="js iu"> open </strong>方法。</p><p id="b304" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们得到请求的响应时，<strong class="js iu"> send </strong>中的<strong class="js iu">‘load’</strong>事件监听器被触发。在这个代码示例中，<strong class="js iu">‘this’</strong>指的是XHR的一个特定实例，而<strong class="js iu"> this.response </strong>包含该实例的HTTP响应。</p><p id="4446" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们使用“div”元素将响应存储在DOM中。此外，请注意，为了避免扰乱网页的样式/内容，我们使用“高度”和“溢出”CSS属性来隐藏该元素，但同时使用本机DOM APIs也是可读的。</p><p id="6e6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们需要将存储的数据传递给扩展。为此，我们使用内容脚本来读取它。这对于不同类型的扩展来说是不可能的，因为只有内容脚本可以访问网页的DOM。</p><p id="3de8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在内容脚本的底部添加一个函数，该函数持续检查数据是否已经附加到隐藏的DOM元素中:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d703" class="mc kr it ly b gy md me l mf mg">function scrapeData() {<br/>    var responseContainingEle = document.getElementById('__interceptedData');<br/>    if (responseContainingEle) {<br/>        var response = JSON.parse(responseContainingEle.innerHTML);<br/>    } else {<br/>        requestIdleCallback(scrapeData);<br/>    }<br/>}</span><span id="2cb7" class="mc kr it ly b gy mh me l mf mg">requestIdleCallback(scrapeData); </span></pre><p id="b684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mi mj mk ly b">requestIdleCallback</code>是为了确保内容脚本的主线程不会陷入无限循环。</p><p id="e4a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">差不多就是这样！由于响应数据现在在我们的内容脚本中可用，我们现在可以将它发送到我们的后台脚本，后台脚本又可以将它发送到我们的扩展的任何部分。我们可能希望将数据发送到后台页面的原因是，与后台页面相比，内容脚本对扩展API的访问有限。</p><h2 id="c90c" class="mc kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated">缺点</h2><p id="4c2b" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">对于在加载页面或服务器端呈现页面时触发的请求，没有办法做到这一点，因为我们的内容脚本只有在浏览器中开始DOM构造时才会启动。</p><h1 id="cefa" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">使用DevTools扩展拦截数据:</h1><p id="b18b" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">一个<a class="ae kp" href="https://developer.chrome.com/extensions/devtools" rel="noopener ugc nofollow" target="_blank"> DevTools扩展</a>为我们提供了读取响应数据的现成解决方案。让我们在清单中配置它:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ac1f" class="mc kr it ly b gy md me l mf mg">{<br/>    "devtools_page": "devtools.html"<br/>}</span></pre><p id="aadc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们只需要将清单指向我们的devtools html页面。现在让我们来看看<strong class="js iu">devtools.html</strong>的内容:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="fcf2" class="mc kr it ly b gy md me l mf mg">&lt;script src="devtools.js"&gt;&lt;/script&gt;</span></pre><p id="44bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">devtools.html</strong>只需要指向js文件。让我们看看<strong class="js iu"> devtools.js </strong>的样子:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c9dd" class="mc kr it ly b gy md me l mf mg">chrome.devtools.panels.create("MyPanel", null, 'panel.html');</span></pre><p id="857d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> devtools.js </strong>在Chrome DevTools中创建一个定制面板，如下所示:</p><figure class="lt lu lv lw gt mx gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1bb8be93f1d330b72cd8b97feec82459.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*dWRIfRPyKgc_tfZ5lhhVoQ.png"/></div></figure><p id="bb23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">panel.html</strong>包含将在DevTools扩展中显示的HTML。因为我们的用例不需要任何HTML，我们只需要一个非常简单的文件:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7333" class="mc kr it ly b gy md me l mf mg">&lt;html&gt;<br/>    &lt;body&gt;<br/>        &lt;script src="panel.js"&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="11c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看拼图的最后一块，它是<strong class="js iu"> panel.js: </strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b08f" class="mc kr it ly b gy md me l mf mg">chrome.devtools.network.onRequestFinished.addListener(request =&gt; {<br/>  request.getContent((body) =&gt; {<br/>    if (request.request &amp;&amp; request.request.url) {<br/>      if (request.request.url.includes('&lt;url-to-intercept&gt;')) {<br/>        chrome.runtime.sendMessage({<br/>            response: body<br/>        });<br/>      }<br/>    }<br/>  });<br/>});</span></pre><p id="1091" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<strong class="js iu">chrome . dev tools . network . onrequestfinished . add listener</strong>为网页中的所有请求添加一个监听器。在回调中，我们使用<strong class="js iu"> request.getContent </strong> API读取每个请求的响应，并使用<strong class="js iu">chrome . runtime . sendmessage</strong>将响应发送给扩展的其他部分。</p><h2 id="e811" class="mc kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated">缺点</h2><p id="28ba" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">这种方法的缺点是我们必须一直保持Chrome DevTools打开，因为DevTools扩展只有在DevTools打开时才被激活。</p><h1 id="1c3f" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="4c9c" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们讨论的两种方法都有各自的缺点。第一种方法更复杂，但是当您想要拦截在页面加载后触发的请求时效果更好。另一方面，第二种方法更简单，适用于所有情况，但是需要DevTools一直打开。</p><p id="12b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我读到过还有另一种方法可以实现我们的目标，那就是使用<a class="ae kp" href="https://developer.chrome.com/extensions/debugger" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">chrome . debugger</strong></a><strong class="js iu"/>API，但是我还没有验证过。</p><p id="1f8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">欢迎反馈和批评！此外，如果你在执行或理解上述解决方案时遇到任何困难，请在下面的评论中告诉我。</p><p id="6e4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读！😃</p></div></div>    
</body>
</html>