<html>
<head>
<title>The Joy of Regular Expressions, Part 1: What is regex?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式的乐趣，第1部分:什么是正则表达式？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-joy-of-regular-expressions-part-1-what-is-regex-539dc581e282?source=collection_archive---------8-----------------------#2019-07-08">https://betterprogramming.pub/the-joy-of-regular-expressions-part-1-what-is-regex-539dc581e282?source=collection_archive---------8-----------------------#2019-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编程世界中的强大工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b6b1fc81c7e354bcace5579a6c258cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEnEE7B_IYvKobT0vmaG7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@euwars?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法尔扎德·纳兹菲</a>在<a class="ae ky" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7b53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请注意:</strong>这篇文章的例子是用JavaScript进行测试的。在每个例子中，每段代码都被一行一行地测试过。我以这种方式设置示例，这样我们就可以知道每一行的返回值，而不是在示例中只返回最后一行。示例在gists中设置，返回值在右侧注释掉。</p><p id="15f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，这是一篇面向JavaScript的文章。所有的例子都使用JS中的<code class="fe lv lw lx ly b">.test() </code>方法。也就是说，该逻辑可以跨几种语言应用，尽管语法可能略有不同(例如，在Ruby中使用<code class="fe lv lw lx ly b">.match?</code>会有类似的效果。)</p><p id="f2a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长度是我的文章中反复出现的主题，所以在这篇文章中，我实现了一些简单的、用户友好的机制。本文中有几个关键术语和例子与这些术语相关——要跳转到您感兴趣的内容，请尝试使用<code class="fe lv lw lx ly b">Ctrl+F</code>(Mac的<code class="fe lv lw lx ly b">⌘+F</code>)，在搜索词前加一个井号。例如，如果你想知道更多关于<code class="fe lv lw lx ly b">^</code>这个角色的信息，输入<code class="fe lv lw lx ly b">#^</code>。在返回多个匹配项的情况下，术语后面的括号将描述使用该术语的上下文。</p><p id="4f79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我绝对<em class="lz">必须</em>推荐<a class="ae ky" href="https://www.regular-expressions.info/tutorial.html" rel="noopener ugc nofollow" target="_blank">regular-expressions . info</a>上的精彩教程，这是Jan Goyvaerts的一个网站，它深入研究正则表达式，拥有丰富的信息。这是我第一次了解这些奇妙模式的地方，对于新手和专家来说都是一个很好的资源。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="2bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式是编程领域中一个强大的工具。通过一系列复杂的语法，它们可以在字符串中搜索非常具体的标准。可能性是巨大的。例如，你可以搜索一个单词的第一个字母是大写，后面紧跟着一个破折号。它们是在搜索或模式匹配等操作中使用的强大工具。</p><p id="8c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式——通常缩写为RexExp、<em class="lz"> regex </em>或<em class="lz">Regex</em>——是通常与一个字符串或该字符串的至少一部分进行比较的字符模式。它们几乎可以匹配任何字符，因此经常使用方法来比较正则表达式和字符串。</p><p id="b52f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当读取一个正则表达式时，它是以这样的逻辑读取的:如果我们有一个正则表达式<code class="fe lv lw lx ly b">/the/</code>，我们搜索/比较一个字符串中的t，接着是h，接着是e。</p><p id="7f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正则表达式如何有用的一个很好的例子是它们如何被用来搜索东西。使用正则表达式“garden”就是一个例子。您可以查找任何包含“花园”的单词，包括“园艺”、“花园”和“园丁”。</p><h1 id="c08b" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">创建正则表达式</h1><p id="31a3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">可以用两种方法之一创建正则表达式。一种方法是通过正则表达式文字创建它们(将变量设置为正则表达式)，另一种方法是使用RegExp构造函数。通常，如果希望正则表达式保持不变，请使用正则表达式文本。如果正则表达式应该是动态的，请使用正则表达式构造函数。</p><p id="9f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，正则表达式文字处理反斜杠的方式有些不同。文字夹在两个<em class="lz">正斜杠</em>之间，所以我们需要在字符串中要使用的任何正斜杠前面加一个反斜杠，因为如果我们不加，文字会提前终止。此外，一些转义符(例如。\ "，\ ')将被忽略—这是因为有些字符在regex中被逐字解释，而它们不在字符串中，还因为Regex有自己的<em class="lz">转义符(稍后讨论)。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编写正则表达式的不同方法，以及如何忽略一些传统转义符的例子。</p></figure><h1 id="e658" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">使用。使用正则表达式测试()</strong></h1><p id="5e8b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">#.test()，#test()，#characterclass(用法介绍)</p><p id="0584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">.test()</code>方法是使用正则表达式的众多方法之一，也是本系列中使用最多的方法。此方法接受字符串/字符模式作为参数，并检查字符串是否包含表达式中的匹配模式。运行时，<code class="fe lv lw lx ly b">.test()</code>将返回true或false，这取决于字符模式是否位于字符串中。字符模式必须与字符串中的<em class="lz">完全匹配</em>才能返回true。这意味着字符的大小写和顺序必须完全匹配。例如，如果您对字符串“The”使用<code class="fe lv lw lx ly b">/the/</code>或<code class="fe lv lw lx ly b">/ehT/</code>，这两种情况下都将返回false，第一种情况是由于大小写问题，第二种情况是由于顺序问题。</p><p id="1529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在斜杠中包含的数据周围使用括号使得表达式匹配括号之间的任何内容，而不管顺序如何。</p><p id="8c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果试图检查某个数据类型的多个值，可以使用连字符来代替键入每个字符。这就是所谓的<strong class="lb iu">人物类</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们看到顺序对正则表达式很重要，以及字符类如何引入灵活性。</p></figure><h1 id="b6e9" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">正则表达式和元字符:简介</h1><p id="a8b7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">正则表达式通常使用称为<strong class="lb iu">元字符</strong>的特殊字符来指定该正则表达式的特定内容，从诸如“以该字符/序列开始”到“使该字符在正则表达式中可选”的查询不等。</p><p id="7a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些元字符被进一步细分为子组，比如锚点、边界、量词、简写字符、字符类……不胜枚举。</p><p id="be9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我没有办法深入研究这些子群的每一个方面，主要是因为我无法按照自己的喜好弯曲时空。然而，在这篇文章以及随后的文章中，我们将深入探讨其中的一些子组，这样读者就可以对它们的用法以及它们与正则表达式的整体关系有一个基本的了解。</p><p id="aa67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，我们应该定义几个与正则表达式相关的术语，以及我们将看到和使用它们的上下文。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="38eb" class="mh mi it bd mj mk ng mm mn mo nh mq mr jz ni ka mt kc nj kd mv kf nk kg mx my bi translated">正则表达式术语:简要概述</h1><h2 id="9429" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak"> <em class="nx">元字符</em></strong>#元字符</h2><p id="b766" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一个<strong class="lb iu">元字符</strong>是以下字符之一:<code class="fe lv lw lx ly b">\^$.|?*+()[{</code>。这些字符依赖于上下文，这意味着如果在不同的情况下使用，它们将不会有相同的含义。例如，^(caret)可以用作锚点，但在与字符类一起使用时，也可以调用排除性属性。</p><h2 id="af78" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak"> <em class="nx">锚点</em></strong>#锚点</h2><p id="d270" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一个<strong class="lb iu">定位符</strong>是一种正则表达式字符，它关注字符的位置。它们用于查看正则表达式/正则表达式的一部分是否匹配字符串中的某个位置。在本帖中，我们将回顾一下<code class="fe lv lw lx ly b">^</code>主播、<code class="fe lv lw lx ly b">$</code>主播以及他们的综合行为。</p><h2 id="3958" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak"> <em class="nx">字界</em></strong>#界、#字界、#字界</h2><p id="aef1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">单词边界是将单词彼此分开的东西。在这个系列中，我们将越过<code class="fe lv lw lx ly b"><strong class="lb iu">/b</strong></code>边界。</p><h2 id="fb66" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak"> <em class="nx">量词#量词</em> </strong></h2><p id="25d3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一个<strong class="lb iu">量词</strong>是一个字符，它可以应用于一个正则表达式，使其可选或者重复一定的次数。<code class="fe lv lw lx ly b">?</code>、<code class="fe lv lw lx ly b">+</code>、<code class="fe lv lw lx ly b">*</code>和<code class="fe lv lw lx ly b">{}</code>量词将在本系列的后续文章中介绍。</p><h2 id="4e40" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak"> <em class="nx">字符类</em> # </strong>字符类(定义)</h2><p id="7cab" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一个<strong class="lb iu">字符类</strong>是一组字符，它有助于我们一次在一个字符串或该字符串中的一个位置搜索多个字符；例如，字符类<code class="fe lv lw lx ly b">[a-z]</code>将匹配任何小写字母。字符类也可以具有排除功能，这将在本系列的后续部分中探讨。我们已经在这篇文章中简要地提到了角色类，并将在下一篇文章中探讨它们。</p><h2 id="c224" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak"> <em class="nx">速记人物</em></strong>#速记</h2><p id="b0ed" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">速记字符是特定字符类别的缩写。它们提供了一种更短的方法来写出常用的字符类。例如，一个常用的字符类是<code class="fe lv lw lx ly b">[a-zA-z_0–9]</code>，它编码任何字母数字字符(和下划线)。我们可以简单地编写<code class="fe lv lw lx ly b">\w</code>，而不是每次都写那么多字符。在本系列的后续文章中，我们将讨论速记字符<code class="fe lv lw lx ly b">\w, \W, \d, \D</code>，以及点号<code class="fe lv lw lx ly b">.</code>，从技术上来说，点号<em class="lz">不是速记字符</em>，但其用法通常与其他速记字符同义。速记字符将在本系列的下一篇文章中探讨。</p><h2 id="b524" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated">天资</h2><p id="839e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">天赋是一种特性，可以应用于正则表达式，使其更加灵活。一个例子是<code class="fe lv lw lx ly b">i</code>风格，它不区分大小写。我们将在以后的帖子中讨论flairs。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="5608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他类型的字符不属于上述类别之一。例如，反斜杠字符<code class="fe lv lw lx ly b">\</code>用于转义正则表达式中的某些字符，圆括号<code class="fe lv lw lx ly b">()</code>用于将正则表达式中的某些字符组合在一起。</p><p id="905c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在正则表达式的世界里还有很多其他的概念，比如反向引用和条件的使用。这些主题稍微高级一点——本指南旨在建立基本的正则表达式知识和用法。因此，上面列出的概念不会在本系列的任何帖子中涉及，但是像知识之源这样的资源广泛地涉及了这些主题，比如<a class="ae ky" href="https://www.regular-expressions.info/" rel="noopener ugc nofollow" target="_blank">正则表达式。</a></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c372" class="mh mi it bd mj mk ng mm mn mo nh mq mr jz ni ka mt kc nj kd mv kf nk kg mx my bi translated">锚</h1><h2 id="5b62" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak">使用^锚检查一个字符串是否以某个正则表达式开始</strong></h2><p id="5340" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu"> #^(anchor) </strong></p><p id="a999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">^字符将检查字符模式的开头是否以正则表达式开始。这对于检查字符串是否以某个正则表达式开头很有用。它可以用于整个单词(如下例所示)，也可以更复杂地使用，例如查找以某个字母开头的所有单词。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用^character检查字符串是否以正则表达式开头</p></figure><p id="4d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行代码查看“H”是否在字符串“Hello”的开头。是的，所以返回true。</p><p id="730c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行代码查看“h”是否在字符串“Hello”的开头。虽然这个字符串以H开头，但它是一个大写的H，并且regex默认是区分大小写的。(如前所述，有一些“flairs”可以用来忽略大小写的敏感性，我们将在后面谈到。)</p><p id="47ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三行代码测试“Hello”是否是我们的参数“Hello man”的开始字符串。是的，所以我们得到了真实。</p><p id="fc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四行代码测试“Hello”是否是“Man”中的开始字符串。你好”。它不是。尽管“Hello”在字符串本身中，但它不在<em class="lz">开始的</em>处，所以我们得到false。</p><h2 id="8d0c" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak">使用$ anchor检查字符串是否以某个正则表达式结尾</strong></h2><p id="882f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu"> #$(锚)</strong></p><p id="f821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">$</code>字符将检查字符模式的结尾是否以正则表达式结束。这对于检查字符串是否以某个正则表达式结尾很有用。</p><p id="ebf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要返回具有特定姓氏的所有用户的列表。如果用户的全名是一个字符串，并且我们正在寻找所有姓“Smith”的用户，我们可以使用<code class="fe lv lw lx ly b">/Smith$/</code>作为正则表达式来过滤掉这些用户。</p><p id="0e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子坚持使用我们之前测试过的“Hello”/“Hello，man”字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">$检查正则表达式是否是字符串的最后一部分</p></figure><p id="65d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行代码测试“o”是否是字符串“Hello”中的最后一个字符。是的，所以我们得到了真实。</p><p id="ecda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行代码测试“Hello”是否是我们的参数“Man”中的结束字符串。你好”。请注意，这里不仅测试了“o”——我们还确认了整个字符串都以“Hello”结尾。是的，所以我们得到了真实。</p><p id="894b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三行代码测试“Hello”是否是“Hello man”中的结束字符串。它不是。尽管“Hello”在字符串本身，但它不在<em class="lz">结尾</em>，所以我们得到false。</p><h2 id="419c" class="nl mi it bd mj nm nn dn mn no np dp mr li nq nr mt lm ns nt mv lq nu nv mx nw bi translated"><strong class="ak">同时使用^和$检查字符串是否以单独的正则表达式开始和结束</strong></h2><p id="1ee1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们已经看到，<code class="fe lv lw lx ly b">^</code>锚查看一个字符串是否以某个正则表达式开始，而<code class="fe lv lw lx ly b">$</code>锚查看一个字符串是否以某个正则表达式结束。我们现在可以结合使用这些锚来查看一个字符串是否以一个正则表达式开始，以另一个正则表达式结束。然而，如果我们尝试做一些事情，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里少了点什么…</p></figure><p id="1234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到它不起作用。这是为什么呢？答案是因为正则表达式是如何设置的。按照现在的情况，上面使用的正则表达式将检查以g开头、以s结尾的双字符字符串。它永远不会自动假定我们正在查找该字符串中间的字符—我们必须将它们写入。但是，我们如何表示我们希望在字符串的中间有非特定的字符，并且这些字符的长度可以是我们想要的1到任意多个呢？</p><p id="9127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以在字符串之间添加字母，写类似于<code class="fe lv lw lx ly b">/^gardens$/</code>的东西，但这基本上与键入/gardens/是一样的，并且不是很通用。我们可以使用字符类——它允许匹配不同的字符，稍后会涉及到——来匹配各种各样的字母，但是正则表达式仍然只能匹配特定长度的字符。那么，我们可以用什么作为我们的解决方案呢？</p><p id="d840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个答案是两个特殊字符的组合——点<code class="fe lv lw lx ly b">.</code>和星<code class="fe lv lw lx ly b">*</code>。我们还没有谈到这些(它们在“特殊字符”一节中讨论得更多)，但是现在，我们知道点字符匹配几乎任何字符，而*匹配它所标记的正则表达式的零个或多个出现。通过在我们的锚之间使用它们，我们基本上是在说“匹配以g开头以s结尾的任何长度的字符串——我不关心中间的内容是什么。”这让很多东西通过，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用。*作为正则表达式中间的替代通过了我们的测试，但是有更好的解决方案</p></figure><p id="bb42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这两个特殊字符似乎可以解决我们的问题！我们可以正确匹配以“Look”开头、以“is”结尾的字符串。</p><p id="8ab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，需要注意的是，由于<code class="fe lv lw lx ly b">.</code>匹配几乎任何字符，如果我们加上一句“Look 3478984a843 is”仍然会通过。怎么才能解决这个问题？</p><p id="7b7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们提到使用字符类作为我们可能的解决方案之一，但是我们没有办法指定我们希望字符类扩展到什么程度。这个问题可以通过使用<code class="fe lv lw lx ly b">+</code>量词结合一些字符类来制作一个更具体的正则表达式来解决。在下面的例子中，我们将创建一个正则表达式，它可以匹配以G或G开头，以s结尾，中间有任意数量的字母字符的单词。这个正则表达式利用字符类来满足这些参数。在本系列的下一篇文章中，我们将更深入地研究字符类，以及它们的使用如何帮助我们为这项工作设计正确的正则表达式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="9ac0" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="36bf" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">恭喜你！你已经写完了另一篇冗长的博文。当你读到这句话的时候，你应该对什么是正则表达式有一个基本的概念，它可以用来做什么，一些与正则表达式相关的术语，以及锚的用法。</p><p id="c50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我们将探索字符类(以及它们的速记字符)以及它们的使用如何在我们的正则表达式中提供更多的灵活性，就像上面的例子一样。在那之前，编码快乐！</p><p id="c294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">消息来源</strong></p><ol class=""><li id="2d34" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">Goyvaerts，J. (2019)。欢迎来到Regular-Expressions.info <br/>关于正则表达式的首要网站。https://www.regular-expressions.info/<a class="ae ky" href="https://www.regular-expressions.info/" rel="noopener ugc nofollow" target="_blank">T4</a></li><li id="d1bb" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">Goyvaerts，J. (2019)。正则表达式教程目录。<em class="lz">正则表达式. info .</em>T10】https://www.regular-expressions.info/tutorialcnt.html</li><li id="f4a8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">Goyvaerts，J. (2019)。绳的起点和绳锚的终点。<em class="lz">正则表达式.信息</em>T14】https://www.regular-expressions.info/anchors.html</li></ol></div></div>    
</body>
</html>