<html>
<head>
<title>How to Use Portals in React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React.js中使用门户</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/portals-in-react-js-with-a-practical-example-c6abd976caf?source=collection_archive---------11-----------------------#2022-02-21">https://betterprogramming.pub/portals-in-react-js-with-a-practical-example-c6abd976caf?source=collection_archive---------11-----------------------#2022-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aea9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用一个实例来说明</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d3c63a58270dcc3b73313a4d427a4441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_dOR86KgfEpES6_B"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@moreno303?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米赛尔·莫雷诺</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f68a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如React.js官方文档中所述，门户提供了一个一流的选项来将子组件呈现到位于父组件的DOM层次结构之外的DOM节点中。</p><p id="9962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们想要呈现组件，但是我们的父级有一个隐藏的溢出或定义的宽度和高度时，门户是有用的，模态是一个理想的例子，所以我们要从头开始构建一个模态，并应用良好的用户可访问性实践。</p><p id="3674" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这个<a class="ae kv" href="https://github.com/jordanrjdev/Portals-example-react" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中看到这个例子的完整代码。</p><p id="6f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将创建一个名为<code class="fe ls lt lu lv b">src/Components/Modal/index.js</code>的组件:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1392" class="ma mb iq lv b gy mc md l me mf">export const Modal = (props) =&gt; {<br/>  let { children, close, ...rest } = props;<br/>  if (!children) {<br/>    children = &lt;p&gt;This is a example modal&lt;/p&gt;;<br/>  }</span><span id="2a9f" class="ma mb iq lv b gy mg md l me mf">  return (<br/>      &lt;div id="modal-dialog" {...rest}&gt;<br/>        &lt;div className="flex flex-col justify-center items-center"&gt;<br/>          {children}<br/>          &lt;button onClick={close}&gt;<br/>            Close this modal<br/>          &lt;/button&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="0fc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">src/styles.css</code>文件中，我们将有以下代码:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4b21" class="ma mb iq lv b gy mc md l me mf">@import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;500&amp;display=swap");<br/>* {<br/>  font-size: 62.5%;<br/>  font-family: "Roboto";<br/>  margin: 0;<br/>  padding: 0;<br/>}<br/><br/>#App {<br/>  overflow: hidden;<br/>  height: 20vh;<br/>  background-color: #ccc;<br/>}<br/><br/>#App &gt; h1 {<br/>  font-size: 2rem;<br/>}<br/><br/>div#modal-dialog {<br/>  background-color: rgba(0, 0, 0, 0.8);<br/>  position: fixed;<br/>  z-index: 999;<br/>  height: 100vh;<br/>  width: 100vw;<br/>  top: 0;<br/>  left: 0;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>}<br/><br/>div#modal-dialog &gt; div {<br/>  background-color: #f5f5f5;<br/>  padding: 2rem;<br/>  border-radius: 1.2rem;<br/>}<br/><br/>p {<br/>  margin: 1.4rem 0;<br/>  font-size: 1.5rem;<br/>}<br/><br/>button {<br/>  padding: 1rem;<br/>  border-radius: 1rem;<br/>  border: none;<br/>  background-color: #9b59b6;<br/>  color: #fff;<br/>  cursor: pointer;<br/>  transition: all 0.3s ease-in-out;<br/>}<br/><br/>button:hover {<br/>  background-color: #8e44ad;<br/>}<br/><br/>.flex {<br/>  display: flex;<br/>}<br/><br/>.flex-col {<br/>  flex-direction: column;<br/>}<br/><br/>.flex-row {<br/>  flex-direction: row;<br/>}<br/><br/>.justify-center {<br/>  justify-content: center;<br/>}<br/><br/>.items-center {<br/>  align-items: center;<br/>}</span></pre><p id="ab3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们将有几个样式的模型，我们还为我们的应用程序定义了一些标准类。</p><p id="26c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在模态中，我们将收到几个<em class="mh">属性</em>，如子属性、关闭属性(关闭模态的函数)和我们可能有的其他属性，我们还有一个固定元素，即关闭模态的按钮，我们将在那里传递单击事件时关闭的函数。</p><p id="4faf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将继续在我们的index.html文件中创建一个div，它将是我们的应用程序的父div的兄弟元素，该文件如下所示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5e42" class="ma mb iq lv b gy mc md l me mf">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;meta<br/>      name="viewport"<br/>      content="width=device-width, initial-scale=1, shrink-to-fit=no"<br/>    /&gt;<br/>    &lt;meta name="theme-color" content="#000000" /&gt;<br/>    &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt;<br/>    &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" /&gt;<br/>    &lt;title&gt;React App&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;noscript&gt;<br/>      You need to enable JavaScript to run this app.<br/>    &lt;/noscript&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>    &lt;div id="modals"&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="01e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把“modals”的id放到这个div中，由于门户的原因，modal组件将被注入到这个div中。</p><p id="05b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对我们有好处，这样我们的组件就不会受到父组件样式的影响，因为父组件隐藏了溢出，并且定义了高度和宽度，因为它不会正确显示。</p><p id="40e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将继续创建<code class="fe ls lt lu lv b">src/App.js</code>:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="977c" class="ma mb iq lv b gy mc md l me mf">import { useState } from "react";<br/>import ReactDOM from "react-dom";<br/>import { Modal } from "./Components/Modal";<br/>import "./styles.css";</span><span id="2da0" class="ma mb iq lv b gy mg md l me mf">const domElement = document.getElementById("modals");</span><span id="fc38" class="ma mb iq lv b gy mg md l me mf">export default function App() {<br/>  const [stateModal, setStateModal] = useState(false);<br/>  const openModal = () =&gt; setStateModal(true);<br/>  const closeModal = () =&gt; setStateModal(false);</span><span id="dfa4" class="ma mb iq lv b gy mg md l me mf">  return (<br/>    &lt;div id="App" className="flex flex-col justify-center items-center"&gt;<br/>      &lt;h1&gt;Portals Example&lt;/h1&gt;<br/>      &lt;div className="flex flex-col items-center justify-center"&gt;<br/>        &lt;p&gt;This is a div with a defined height and overflow hidden&lt;/p&gt;<br/>        &lt;button onClick={openModal}&gt;<br/>          Open modal<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>      {stateModal &amp;&amp;<br/>        ReactDOM.createPortal(<br/>          &lt;Modal close={closeModal}&gt;<br/>            &lt;p&gt;Modal from App.js&lt;/p&gt;<br/>          &lt;/Modal&gt;,<br/>          domElement<br/>        )}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="7eaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我们有导入，在第6行我们有一个div#modal的引用</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b808" class="ma mb iq lv b gy mc md l me mf">const domElement = document.getElementById("modals"); //Reference to div#modals for create portal</span></pre><p id="cb63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要将它存储在一个变量中，因为我们将需要它来创建门户。</p><p id="9d6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们有了openModal的状态，能够知道模态是打开的还是关闭的，我们也有了各自的函数来打开和关闭模态。</p><p id="ac6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有打开模态的按钮，下面我们有最重要的东西，这是一个条件，当模态的状态是<code class="fe ls lt lu lv b">true</code>时，我们将使用ReactDOM createPortal函数，作为第一个参数，我们将传递我们想要呈现的元素，第二个参数，我们将传递我们要注入所述组件的div的引用，所以我们有这样的东西:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="bbd8" class="ma mb iq lv b gy mc md l me mf">{stateModal &amp;&amp;<br/>  ReactDOM.createPortal(<br/>  &lt;Modal close={closeModal}&gt;<br/>      &lt;p&gt;Modal from App.js&lt;/p&gt;<br/>  &lt;/Mode&gt;,<br/>  domElement<br/>)}</span></pre><p id="1f49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个，我们将能够看到在我们的应用程序的父容器之外的div#modals中如何呈现模态，这一切都要感谢门户，因此我们的样式没有问题，甚至没有将模态元素从dom中分离出来。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/9681cee64fba1f1f83ceecc15cb7e1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_RSJw0EfEvoMiO50.png"/></div></div></figure><h1 id="15ce" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">通过良好实践提高我们的可及性</h1><blockquote class="na nb nc"><p id="3ecc" class="kw kx mh ky b kz la jr lb lc ld ju le nd lg lh li ne lk ll lm nf lo lp lq lr ij bi translated"><em class="iq">注意:<br/>在使用门户时，记住管理键盘焦点非常重要。对于对话框，确保每个人都可以通过遵循</em> <a class="ae kv" href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> WAI-ARIA模态创建实践</em> </a> <em class="iq">与它们进行交互。</em></p></blockquote><h1 id="f289" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">以编程方式管理焦点。</h1><p id="0330" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们的React应用程序在运行时不断修改HTML DOM，有时会导致键盘焦点丢失或设置为意外元素。要解决这个问题，我们需要以编程方式将键盘焦点推向正确的方向。例如，在模式窗口关闭后，将键盘焦点重置到打开该窗口的按钮。</p><p id="7994" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将改进我们的组件，这样就不会出现错误。</p><p id="18cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果由于某种原因，你有一个模态来删除一些东西，当模态被打开时，焦点被发送到确认按钮，会发生什么呢？这是糟糕的可访问性管理，因为它可能会被键盘输入无意中激活，所以最好是将焦点放在关闭模态的动作上，并将其返回到激活模态的按钮，这样它就不会迷失在一些不存在的元素中。</p><p id="51d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们必须阻止滚动，并防止焦点离开我们的组件，我们将使用2个依赖项，我们将通过安装:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="32e8" class="ma mb iq lv b gy mc md l me mf">npm i no-scroll focus-trap-react</span></pre><p id="8cbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过将焦点重定向到取消按钮来改进我们的模态组件，这要感谢React的useRef钩子。</p><p id="54e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">src/Components/Modal/index.js</code>:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="28f4" class="ma mb iq lv b gy mc md l me mf">import noScroll from "no-scroll";<br/>import { useEffect, useRef } from "react";<br/>import FocusTrap from "focus-trap-react";<br/>export const Modal = (props) =&gt; {<br/>  let { children, openButtonRef, close, ...rest } = props;<br/>  if (!children) {<br/>    children = &lt;p&gt;This is a example modal&lt;/p&gt;;<br/>  }<br/><br/>  let buttonRef = useRef();<br/><br/>  useEffect(() =&gt; {<br/>    buttonRef ? buttonRef.current.focus() : null;<br/>    noScroll.on();<br/>    return () =&gt; {<br/>      openButtonRef ? openButtonRef.current.focus() : null;<br/>      noScroll.off();<br/>    };<br/>  }, []);<br/><br/>  return (<br/>    &lt;FocusTrap&gt;<br/>      &lt;div id="modal-dialog" {...rest}&gt;<br/>        &lt;div className="flex flex-col justify-center items-center"&gt;<br/>          {children}<br/>          &lt;button ref={buttonRef} onClick={close}&gt;<br/>            Close this modal<br/>          &lt;/button&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/FocusTrap&gt;<br/>  );<br/>};</span></pre><p id="7a01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们导入新的依赖项:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="3f1a" class="ma mb iq lv b gy mc md l me mf">import FocusTrap from "focus-trap-react";<br/>import noScroll from "no-scroll";</span></pre><p id="7b2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们创建一个引用，我们将在我们的按钮<code class="fe ls lt lu lv b">let buttonRef = useRef();</code> <br/>中使用，我们使用关闭按钮模式<code class="fe ls lt lu lv b">&lt;button ref={buttonRef} onClick={close}&gt;Close this modal&lt;/button&gt;</code>进行如下引用</p><p id="2a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将添加一个新的属性，它是打开我们的模态的按钮的引用，以便在这个模态关闭时返回焦点:<code class="fe ls lt lu lv b">let { children, openButtonRef, close, ...rest } = props;</code></p><p id="0eaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用useRef，我们将知道何时呈现该模态，这将表明它是打开的，我们将验证是否有对关闭按钮的引用，如果有引用，我们将使用<code class="fe ls lt lu lv b">openButtonRef ? openButtonRef.current.focus() : null;</code>聚焦它，我们还将使用<code class="fe ls lt lu lv b">noScroll.off()</code> <br/>阻止滚动到我们的应用程序，最重要的是，当该组件被卸载时，我们将焦点返回到打开该模态的按钮，我们将使用以下代码再次解锁滚动</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a259" class="ma mb iq lv b gy mc md l me mf">openButtonRef ? openButtonRef.current.focus() : null; <br/>noScroll.off();</span></pre><p id="8731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其使用效果如下:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="618d" class="ma mb iq lv b gy mc md l me mf">useEffect(() =&gt; {<br/>     buttonRef ? buttonRef.current.focus() : null;<br/>     noScroll.on();<br/>     return() =&gt; {<br/>       openButtonRef ? openButtonRef.current.focus() : null;<br/>       noScroll.off();<br/>     };<br/>   }, []);</span></pre><p id="5acc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将用组件包装我们的模型:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8318" class="ma mb iq lv b gy mc md l me mf">&lt;FocusTrap&gt;<br/>{......}<br/>&lt;/FocusTrap&gt;</span></pre><p id="4eab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe ls lt lu lv b">src/App.js</code>组件中，我们将创建一个对我们的打开按钮的引用，并将其传递给我们的模块，这样我们的文件将如下所示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c0c6" class="ma mb iq lv b gy mc md l me mf">import { useRef, useState } from "react";<br/>import ReactDOM from "react-dom";<br/>import { Modal } from "./Components/Modal";<br/>import "./styles.css";<br/><br/>const domElement = document.getElementById("modals");<br/><br/>export default function App() {<br/>  const [stateModal, setStateModal] = useState(false);<br/><br/>  let openButtonRef = useRef();<br/><br/>  const openModal = () =&gt; setStateModal(true);<br/>  const closeModal = () =&gt; setStateModal(false);<br/><br/>  return (<br/>    &lt;div id="App" className="flex flex-col justify-center items-center"&gt;<br/>      &lt;h1&gt;Portals Example&lt;/h1&gt;<br/>      &lt;div className="flex flex-col items-center justify-center"&gt;<br/>        &lt;p&gt;This is a div with a defined height and overflow hidden&lt;/p&gt;<br/>        &lt;button ref={openButtonRef} onClick={openModal}&gt;<br/>          open modal<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>      {stateModal &amp;&amp;<br/>        ReactDOM.createPortal(<br/>          &lt;Modal close={closeModal} openButtonRef={openButtonRef}&gt;<br/>            &lt;p&gt;Modal from App.js&lt;/p&gt;<br/>          &lt;/Mode&gt;,<br/>          domElement<br/>        )}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="22f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，我们应用了良好的可访问性实践，滚动将被阻止，焦点也将只限于我们的模式。我们可以使用“Tab”按钮进行测试，在此示例中，我们学习了react portals并创建了一个具有良好实践的模式。</p><p id="48a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在剩下的就是实践和继续研究我们可以在这个模态组件上改进什么。</p><p id="0c1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">告诉我，您还会在哪个示例中使用react门户？</p></div></div>    
</body>
</html>