<html>
<head>
<title>What’s the Journey of a Single Line of Compiled Code Like?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单行编译代码的旅程是什么样的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/journey-of-a-line-of-complied-code-b37c4a8deb0?source=collection_archive---------11-----------------------#2021-02-01">https://betterprogramming.pub/journey-of-a-line-of-complied-code-b37c4a8deb0?source=collection_archive---------11-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="70cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看将源代码转换成可执行格式的完整过程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/edf669c3975232014859259b18c93c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fzTrAiwRR7_acDUW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@maxboettinger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max b ttinger</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="70a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在高层次上，我将看到使用Clang编译一个简单C++程序的每个阶段的输出。我还将更仔细地研究反汇编输出中的简单代码，并讨论ELF文件的各个部分。</p><p id="92a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你完全编译你的程序时，它会产生一个可执行的二进制文件。例如，这个简单的程序…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="6e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…产生二进制代码。类似这样的内容(在十六进制编辑器中查看):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/a8cbc0ecff170a1695d7dbec3a05c4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qPzgRyNjvsFZWX45"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可执行二进制</p></figure><p id="3235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行这个程序，输出如下:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="a89e" class="ma mb iq lw b gy mc md l me mf">What’s Up?<br/>20</span></pre><p id="58b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，所有的代码和数据都被转换成计算机可以执行的适当格式的二进制文件。这对我们来说不是那么容易理解，但是为了得到更好的理解，你可以改变这个程序的静态字符串部分，在执行时输出不同的东西。</p><p id="f0db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在这个二进制文件中，我将代表字符串<code class="fe mg mh mi lw b">What’s Up?</code>的代码<code class="fe mg mh mi lw b">5768 6174 2773 2055 703f 000a</code>更改为<code class="fe mg mh mi lw b">576f 6e64 6572 6675 6c21 000a</code>，运行修改后的二进制文件将产生输出:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="0a76" class="ma mb iq lw b gy mc md l me mf">Wonderful!<br/>20</span></pre><p id="04a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是啊！太棒了，不是吗？</p><p id="5a7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不知道——我应该担心吗？这只是交换一些ASCII码而已。改变行为会困难得多，所以没什么好担心的。</p><p id="898a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管怎样，我们讨论了获取源文件并将其编译成二进制文件的过程。不过，我会保持高度警惕。</p><p id="ea9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将源代码转换成可执行格式需要几个阶段。您可以从Clang文档中看到，所涉及的步骤是:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="9433" class="ma mb iq lw b gy mc md l me mf">1. <a class="ae kv" href="#4f9b" rel="noopener ugc nofollow">Pre-Processing</a><br/>2. <a class="ae kv" href="#ad85" rel="noopener ugc nofollow">Parsing and Semantic Analysis</a><br/>3. <a class="ae kv" href="#0b95" rel="noopener ugc nofollow">Code Generation and Optimization</a><br/>4. <a class="ae kv" href="#3f63" rel="noopener ugc nofollow">Assembly</a><br/>5. <a class="ae kv" href="#b8ff" rel="noopener ugc nofollow">Linking</a></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/8f9b24f5abb5c95973dd3f574b0f6707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6nMqE8npeg9LhCzQ0Efow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">编译阶段</p></figure><p id="5521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看上面每个阶段的输出。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="4f9b" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">预处理</h1><p id="dd5d" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">Clang文档对此的描述是:</p><blockquote class="nn no np"><p id="e287" class="kw kx nq ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">此阶段处理输入源文件的标记化、宏扩展、#include扩展以及其他预处理程序指令的处理</p></blockquote><p id="99d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个阶段结束时我们程序的输出显示宏被扩展了。注意我们有<code class="fe mg mh mi lw b">std::cout &lt;&lt; “What’s Up?” &lt;&lt; “\n”;</code>，而原始代码是<code class="fe mg mh mi lw b">std::cout &lt;&lt; MSG &lt;&lt; “\n”;</code>。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="499d" class="ma mb iq lw b gy mc md l me mf">…..</span><span id="165a" class="ma mb iq lw b gy nu md l me mf">namespace std __attribute__ ((__visibility__ (“default”)))</span><span id="ed5b" class="ma mb iq lw b gy nu md l me mf">{</span><span id="f22c" class="ma mb iq lw b gy nu md l me mf"># 60 “/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/iostream” 3</span><span id="cd65" class="ma mb iq lw b gy nu md l me mf">extern istream cin;<br/>extern ostream cout;<br/>extern ostream cerr;<br/>extern ostream clog;<br/>extern wistream wcin;<br/>extern wostream wcout;<br/>extern wostream wcerr;<br/>extern wostream wclog;<br/>static ios_base::Init __ioinit;<br/>}</span><span id="1f7d" class="ma mb iq lw b gy nu md l me mf"># 2 “pass_by_reference_example.cpp” 2</span><span id="dc24" class="ma mb iq lw b gy nu md l me mf">void addTen(int&amp; num) {</span><span id="4b18" class="ma mb iq lw b gy nu md l me mf">num += num + 10;</span><span id="1e4c" class="ma mb iq lw b gy nu md l me mf">}</span><span id="9b59" class="ma mb iq lw b gy nu md l me mf">int main(int argc, const char* argv[]) {</span><span id="91f2" class="ma mb iq lw b gy nu md l me mf">int a_something = 5;</span><span id="25b6" class="ma mb iq lw b gy nu md l me mf">std::cout &lt;&lt; “What’s Up?” &lt;&lt; “\n”;</span><span id="41e0" class="ma mb iq lw b gy nu md l me mf">addTen(a_something);</span><span id="f82d" class="ma mb iq lw b gy nu md l me mf">std::cout &lt;&lt; a_something &lt;&lt; “\n”;</span><span id="ca52" class="ma mb iq lw b gy nu md l me mf">return 0;</span><span id="5a98" class="ma mb iq lw b gy nu md l me mf">}<br/>…</span></pre><p id="5900" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong>我不得不剪辑了很多上衣的线条。这是C++模板的东西。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="ad85" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">解析和语义分析</h1><p id="fc9c" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">Clang文档对此的描述是:</p><blockquote class="nn no np"><p id="3e38" class="kw kx nq ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">该阶段解析输入文件，将预处理标记翻译成解析树。一旦采用解析树的形式，它就应用语义分析来计算表达式的类型，并确定代码是否格式良好。这个阶段负责生成大多数编译器警告和解析错误。这个阶段的输出是一个‘抽象语法树’(AST)。”</p></blockquote><p id="5e48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个阶段产生了AST。您可以看到像<code class="fe mg mh mi lw b">a_something</code>这样的变量是如何在层次结构中表示的。我们代码的其余部分也是如此。同样，我删除了许多行，这样输出就保持在熟悉和简单的范围内。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/34d6ee812ecf9960d48b4ddf84555e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hF-_4OX9rBQCBW6E"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">大西洋时间</p></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="0b95" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">代码生成和优化</h1><p id="cbb5" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">Clang文档对此的描述是:</p><blockquote class="nn no np"><p id="cb2e" class="kw kx nq ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">“这个阶段将AST翻译成低级中间代码(称为‘LLVM IR’)，并最终翻译成机器代码。这个阶段负责优化生成的代码，并处理特定于目标的代码生成。这一级的输出通常称为“a”。s”文件或“程序集”文件。</p></blockquote><p id="53d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个阶段最终产生特定于目标的汇编代码。我将插入输出的截屏，但是，在本文的后面，我们可以从<code class="fe mg mh mi lw b">objdump</code>遍历汇编代码，因为它将代码与汇编交错。这就是我们要遵循的一些代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/13faf6977a01c342e3ec9244bb74b547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W_c7l89zLRggsCCH"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">装配输出</p></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3f63" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">装配</h1><p id="dbe9" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">Clang文档对此的描述是:</p><blockquote class="nn no np"><p id="b316" class="kw kx nq ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">这个阶段运行目标汇编程序，将编译器的输出翻译成目标目标文件。这一级的输出通常称为“a”。“o”文件或“对象”文件。</p></blockquote><p id="0f59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">汇编程序产生一个目标文件。我们的平台是Ubuntu——因此，为这个平台生成的目标文件的类型是ELF。具体来说，就是:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="5df7" class="ma mb iq lw b gy mc md l me mf">ELF 64-bit LSB relocatable, x86–64, version 1 (SYSV), with debug_info, not stripped</span></pre><p id="dbd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个可重定位的文件，因此并不是所有的内存地址都能被解析。下面的截图是ELF文件的头信息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/fe171423e96b018f09d592e81d16e178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*CKKmnM3CYBzasPPK"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">目标文件的ELF头</p></figure><p id="317f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在上面看到的，<code class="fe mg mh mi lw b">Entry point address</code>是<code class="fe mg mh mi lw b">0x0</code>，因为它还不是一个可执行文件，不知道它的虚拟地址空间的入口点。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="b8ff" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">连接物</h1><p id="47d3" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">Clang文档对此的描述是:</p><blockquote class="nn no np"><p id="0907" class="kw kx nq ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">此阶段运行目标链接器，将多个目标文件合并到可执行文件或动态库中。这一阶段的输出通常称为“a.out”。dylib或。所以“文件”</p></blockquote><p id="5b77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，链接器获取目标文件并创建一个可执行文件，解析可解析的地址。</p><p id="0d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ELF二进制文件由一个可执行文件头、零个或多个程序头以及零个或多个节头组成。让我们简单看一下组件。</p><h2 id="f242" class="ma mb iq bd ms ny nz dn mw oa ob dp na lf oc od nc lj oe of ne ln og oh ng oi bi translated">可执行文件头</h2><p id="129b" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">下面的截图显示了我们的可执行文件的ELF头输出。它为我们提供了关于文件类型的信息，在哪里可以找到文件中的其他内容，等等。</p><p id="fe53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b">Magic</code>字段是一个16字节的数组，有一个4字节的幻值，表示这是一个ELF文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/dbbfb8b51965a867f33615045bf9a298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/0*SJyLBZgVXi-gc__I"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可执行文件的ELF头文件</p></figure><p id="f6ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您现在从上面的头输出中看到的，它现在有了一个入口点:<code class="fe mg mh mi lw b">0x4010d0</code> <strong class="ky ir">，</strong>虚拟内存地址，执行应该从这里开始。其类型是可执行的。</p><h2 id="68d2" class="ma mb iq bd ms ny nz dn mw oa ob dp na lf oc od nc lj oe of ne ln og oh ng oi bi translated">部分</h2><p id="6953" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">区段以逻辑方式组织数据和代码。它们为链接器提供了一个有组织的视图。让我们使用readelf来研究二进制文件中的各个部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/52ca82aa44a49c83c3df4a5a4596e814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fvm-6SdvrYMOmp5j"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">部分</p></figure><p id="bce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想我们可以看看一些比较有名的部分:</p><p id="8717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b"><strong class="ky ir">.text</strong></code></p><p id="78d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b">.text</code>包含主要的可执行代码。有很多输出，所以我只展示我们可以识别的几个截图。让我们从ELF头中找到的入口点地址开始。以下是对此的反汇编:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/179301fd181e5fee5e3f038aa381c512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pBzg7krBwP1qyXL8"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">开始方法</p></figure><p id="6fa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这并不是我们的主要功能——这是一些<code class="fe mg mh mi lw b">_start</code>，可能是设置和/或初始化程序。</p><p id="08ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">寄存器<code class="fe mg mh mi lw b">rdi</code>用于传递第一个参数，这是我们主函数的地址，如下图所示。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="2959" class="ma mb iq lw b gy mc md l me mf">4010f1: 48 c7 c7 e0 11 40 00 mov rdi,0x4011e0</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/85ff3fa0038e959b15ca0d812d1293a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WDMqcMQ74vsAQxOc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主方法的分解</p></figure><p id="904b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到<code class="fe mg mh mi lw b">a_something</code>是在<code class="fe mg mh mi lw b">[rbp-0x14]</code>创建的，它的值被设置为<code class="fe mg mh mi lw b">0x5</code>。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="c366" class="ma mb iq lw b gy mc md l me mf">int a_something = 5;</span><span id="088e" class="ma mb iq lw b gy nu md l me mf">4011f6: c7 45 ec 05 00 00 00 mov DWORD PTR [rbp-0x14],0x5</span></pre><p id="0301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的代码中，我们调用<code class="fe mg mh mi lw b">addTen</code>并将<code class="fe mg mh mi lw b"><strong class="ky ir">a_something</strong></code>的引用传递给它。它的拆卸是:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="0401" class="ma mb iq lw b gy mc md l me mf">addTen(a_something);</span><span id="ade9" class="ma mb iq lw b gy nu md l me mf">401228: 48 8d 7d ec    lea rdi,[rbp-0x14]<br/>40122c: 48 89 45 e0    mov QWORD PTR [rbp-0x20],rax<br/>401230: e8 8b ff ff ff call 4011c0 &lt;_Z6addTenRi&gt;</span></pre><p id="882b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不确定<code class="fe mg mh mi lw b">40122c</code>行通过将temp <code class="fe mg mh mi lw b">rax</code>移动到<code class="fe mg mh mi lw b">[rbp-0x20]</code>完成了什么，但是我们知道<code class="fe mg mh mi lw b">lea</code>正在加载<code class="fe mg mh mi lw b">[rbp-0x14]</code>的有效地址——即<code class="fe mg mh mi lw b">a_something</code>的地址到<code class="fe mg mh mi lw b">rdi</code>，它用于传递第一个参数并调用<code class="fe mg mh mi lw b">addTen</code>方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/d45b311bac59f8e38079a25635f976d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kGg7o1JduajQ5i5H"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">addTen方法的反汇编</p></figure><p id="353d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里正在进行指针记账:<code class="fe mg mh mi lw b">rbp</code>是基指针，<code class="fe mg mh mi lw b">rsp</code>是始终指向栈顶的栈指针。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="74ec" class="ma mb iq lw b gy mc md l me mf">4011c0: 55       push rbp<br/>4011c1: 48 89 e5 mov rbp,rsp</span></pre><p id="53be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b">rdi</code>保存着<code class="fe mg mh mi lw b">a_something</code>的地址。该地址现在被复制到<code class="fe mg mh mi lw b">[rbp-0x8]</code>，然后进一步复制到<code class="fe mg mh mi lw b">rax</code>寄存器。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="4435" class="ma mb iq lw b gy mc md l me mf">4011c4: 48 89 7d f8 mov QWORD PTR [rbp-0x8],rdi<br/>4011c8: 48 8b 45 f8 mov rax,QWORD PTR [rbp-0x8]</span></pre><p id="c32a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe mg mh mi lw b">a_something</code>地址的内容被复制到<code class="fe mg mh mi lw b">ecx</code>寄存器。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="71ef" class="ma mb iq lw b gy mc md l me mf">4011cc: 8b 08 mov ecx,DWORD PTR [rax]</span></pre><p id="b8b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b">0xa</code>是十进制的10，它被加到<code class="fe mg mh mi lw b">ecx</code>的内容中，其中保存了<code class="fe mg mh mi lw b">a_something</code>的值。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="aebc" class="ma mb iq lw b gy mc md l me mf">4011ce: 83 c1 0a add ecx,0xa</span></pre><p id="aa33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在结果被放置在<code class="fe mg mh mi lw b">rax</code>寄存器中的地址:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="581a" class="ma mb iq lw b gy mc md l me mf">4011d7: 89 08 mov DWORD PTR [rax],ecx</span></pre><p id="972c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，Clang输出的汇编扩展了msg宏，但是<code class="fe mg mh mi lw b">objdump</code>汇编输出保持了它的完整性。</p><p id="e3c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b"><strong class="ky ir">.rodata</strong></code></p><p id="8549" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此部分包含只读数据。所以，对我们来说，它有我们的味精字符串。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/c77d352f4996ac7b742eb1ad2c9c4439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w4cmzuTvzBLyfoVD"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">。罗达塔</p></figure><p id="07fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b"><strong class="ky ir">.bss</strong></code></p><p id="78b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它保存未初始化的数据。</p><h2 id="c42b" class="ma mb iq bd ms ny nz dn mw oa ob dp na lf oc od nc lj oe of ne ln og oh ng oi bi translated">片段</h2><p id="d281" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">段提供了操作系统和动态链接器用来设置和加载进程以供执行的信息。我们的流程看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/0a4822996718c929ad893664eddf8577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IjFlXlVw8iwB6kRM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">片段</p></figure><p id="6587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lw b">LOAD</code>类型是要加载到存储器中的段。我们可以看到包含我们的主代码的段在段<code class="fe mg mh mi lw b">03</code>中，由段<code class="fe mg mh mi lw b">.init</code>、<code class="fe mg mh mi lw b">.plt</code>、<code class="fe mg mh mi lw b">.text</code>和. fini组成。</p><p id="c826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mg mh mi lw b">.rodata</code>在段<code class="fe mg mh mi lw b">04</code> — <code class="fe mg mh mi lw b">.rodata</code>、<code class="fe mg mh mi lw b">.eh_frame_hdr</code>、<code class="fe mg mh mi lw b">.eh_frame</code> —设置为read (R)。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="734d" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">结论</h1><p id="f73e" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">暂时就这样了。显然，有很多东西需要理解和深入，但获得一个整体的看法本身也很有趣。如果有机会，我会写下这个小过程在记忆中的样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="19a4" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">参考</h1><div class="oq or gp gr os ot"><a href="https://clang.llvm.org/docs/CommandGuide/clang.html" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">Clang 12文档</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">clang是一个C，C++和Objective-C编译器，它包含预处理，解析，优化，代码生成…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">clang.llvm.or</p></div></div></div></a></div></div></div>    
</body>
</html>