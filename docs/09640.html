<html>
<head>
<title>How to Delete Child Records in OneToMany Relationship From Database in JPA?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JPA中从数据库中删除OneToMany关系中的子记录？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-delete-child-records-in-onetomany-relationship-from-database-in-jpa-38d78e02d7a1?source=collection_archive---------2-----------------------#2021-09-21">https://betterprogramming.pub/how-to-delete-child-records-in-onetomany-relationship-from-database-in-jpa-38d78e02d7a1?source=collection_archive---------2-----------------------#2021-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4637" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果我删除了子实体与父实体的关联，Hibernate会自动删除子实体吗？让我们找出答案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bbc2528b063509eb463aa6fd501d37e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mMKxr0bkxrUN_kSC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@blocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">挡块</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">防溅板</a>上的照片</p></figure><p id="561c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们对数据库建模时，我们最有可能定义几个多对一或一对多的关联。当然，当我们<a class="ae ky" href="https://thorben-janssen.com/ultimate-guide-association-mappings-jpa-hibernate/" rel="noopener ugc nofollow" target="_blank">对实体</a>建模时也是如此。</p><p id="7138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用JPA和Hibernate很容易做到这一点。您只需要一个表示关联的属性，并用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javaee/7/api/javax/persistence/ManyToOne.html" rel="noopener ugc nofollow" target="_blank">@ManyToOne</a></code>或<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javaee/7/api/javax/persistence/OneToMany.html" rel="noopener ugc nofollow" target="_blank">@OneToMany</a></code>关联对其进行注释。</p><p id="ebee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但不幸的是，尽管看起来很容易，却有几个陷阱。</p><p id="b674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对<code class="fe lv lw lx ly b">Vendor</code>和<code class="fe lv lw lx ly b">Client</code>实体进行建模，并在它们之间创建双向的一对多关系。</p><p id="fa53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Vendor.class</code>的代码如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f710" class="md me it ly b gy mf mg l mh mi">@Entity <br/>public class Vendor{ <br/>     <br/>     @Id     <br/>     @GeneratedValue<br/>     private Long id;<br/>     private String name;<br/>     <br/>     @OneToMany(mappedBy = "vendor", cascade = CascadeType.ALL)<br/>     private List&lt;Client&gt; clients;</span><span id="2520" class="md me it ly b gy mj mg l mh mi">      // standard constructors<br/>      // standard getters and setters<br/>}</span></pre><p id="05c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<code class="fe lv lw lx ly b">Client.class</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d2e6" class="md me it ly b gy mf mg l mh mi">@Entity<br/>public class Client {<br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.IDENTITY)<br/>    private Long id;<br/><br/>    @ManyToOne(fetch = FetchType.LAZY)<br/>    private Vendor vendor;<br/>}</span></pre><p id="1744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有两个存储库，<code class="fe lv lw lx ly b">ClientRepository</code>和<code class="fe lv lw lx ly b">VendorRepository</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0012" class="md me it ly b gy mf mg l mh mi">@Repository<br/>public interface ClientRepository extends JpaRepository&lt;Child, Long&gt;{}</span><span id="a1a4" class="md me it ly b gy mj mg l mh mi">@Repository<br/>public interface VendorRepository extends JpaRepository&lt;Child, Long&gt;{}</span></pre><p id="8b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们编写一个测试，如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="23f2" class="md me it ly b gy mf mg l mh mi">public class VendorTest extends IntegrationTestSpec {<br/><br/>    @Autowired<br/>    private VendorRepository vendorRepository;<br/><br/>    @Autowired<br/>    private ClientRepository clientRepository;<br/><br/>    @Test<br/>    public void test() {<br/>        Vendor vendor = new Vendor();<br/>        Client client = new Client();<br/><br/>        vendor.setClient(Set.of(client));<br/>        vendorRepository.save(vendor);<br/><br/>        Client fetchClients = clientRepository.findAll().get(0);<br/>        clientRepository.delete(fetchClients);<br/><br/>        assertEquals(1, vendorRepository.count());<br/>        assertEquals(0, clientRepository.count()); // FAILS!!! <br/>         //clientRepository.count() returns 1  <br/>    }<br/>}</span></pre><p id="5081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们来了，在这里我们创建了<code class="fe lv lw lx ly b">vendor</code>和<code class="fe lv lw lx ly b">client</code>，将其保存到DB，然后从DB获取<code class="fe lv lw lx ly b">client</code>，移除它，最后，确保一切按预期工作。</p><p id="ff9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但事实并非如此。</p><p id="3f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为JPA实际上不知道是否应该删除从集合中移除的内容。但是等等。那么我们如何从数据库中删除子实体呢？</p><p id="3252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将<code class="fe lv lw lx ly b">@OneToMany</code>注释的<code class="fe lv lw lx ly b">orphanRemoval</code>属性设置为true，并将级联属性设置为<code class="fe lv lw lx ly b">CascadeType.ALL</code> <em class="mk">，</em> it <em class="mk"> </em>删除父实体时，Hibernate会自动删除子实体。</p><p id="c483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将它添加到我们的<code class="fe lv lw lx ly b">Vendor</code>模型中:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1e95" class="md me it ly b gy mf mg l mh mi">@Entity <br/>public class Vendor{ <br/>     <br/>     @Id     <br/>     @GeneratedValue<br/>     private Long id;<br/>     private String name;<br/>     <br/>     @OneToMany(mappedBy = "vendor", cascade = CascadeType.ALL,          <br/>     orphanRemoval = true) <br/>     private List&lt;Client&gt; clients;</span><span id="3349" class="md me it ly b gy mj mg l mh mi">     //Getters and setters omitted for brevity<!-- --> <br/>    <br/>     public Vendor addClient(Client client)<br/>     {<br/>          clients.add(client);<br/>          clients.setVendor(this);<br/>     }<br/>     public Vendor removeClient(Client client)<br/>     {<br/>          clients.remove(client);<br/>          clients.setVendor(null);<br/>          return this;<br/>     }<br/>}</span></pre><p id="b9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">CascadeType.ALL</code>，表示所有JPA和Hibernate <a class="ae ky" href="https://vladmihalcea.com/a-beginners-guide-to-jpa-hibernate-entity-state-transitions/" rel="noopener ugc nofollow" target="_blank">实体状态转换</a>(例如<code class="fe lv lw lx ly b">persist</code>、<code class="fe lv lw lx ly b">merge</code>、<code class="fe lv lw lx ly b">remove</code>)都从父<code class="fe lv lw lx ly b">Vendor</code>实体传递到<code class="fe lv lw lx ly b">Client</code>子实体。</p><p id="e22d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个<code class="fe lv lw lx ly b">Client</code>实体不再被其父<code class="fe lv lw lx ly b">Vendor</code>实体引用时，<code class="fe lv lw lx ly b">orphanRemoval</code>属性将指示JPA提供者触发一个<code class="fe lv lw lx ly b">remove</code>实体状态转换。</p><p id="fde9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们有一个双向的一对多关联，我们需要确保关联的两端是同步的，因此，我们创建了<code class="fe lv lw lx ly b">addClient</code>和<code class="fe lv lw lx ly b">removeClient</code>方法，以便在添加或删除新的客户端实体时同步两端。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c367" class="ms me it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="bf59" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">那都是我这边的。我希望你能从这篇文章中学到一些东西。我尽力让事情尽可能简单。感谢阅读。</p></div></div>    
</body>
</html>