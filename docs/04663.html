<html>
<head>
<title>How to Create Observables in RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在RxJS中创建可观测量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-observables-in-rxjs-aa3bf79b05e0?source=collection_archive---------9-----------------------#2020-04-28">https://betterprogramming.pub/how-to-create-observables-in-rxjs-aa3bf79b05e0?source=collection_archive---------9-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b205" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从各种数据类型、对象和事件中创建可观察值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/6552df4e5fa6a7ffb9363f533653d1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*VgRK11an88FGLsoBSUM6RQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae ku" href="https://unsplash.com/s/photos/observe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="6952" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="4538" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">RxJS是JavaScript中最流行的函数式反应式编程(FRP)框架。Angular完全围绕RxJS和FRP概念构建。这是一项神奇的技术，非常有用，但是它有一个主要缺点:它有一个有点陡峭的学习曲线，这让一些开发人员感到沮丧。</p><p id="eb22" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">有鉴于此，我决定创建“RxJS课程”系列，它将通过简单的例子涵盖RxJS提供的每一个操作符。以下是到目前为止该系列包含的部分:</p><ul class=""><li id="ec0b" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">RxJS课程:如何创建可观测量</li></ul></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="b4d6" class="kv kw it bd kx ky ne la lb lc nf le lf jz ng ka lh kc nh kd lj kf ni kg ll lm bi translated">如何创造可观的</h1><p id="1710" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">RxJS为我们提供了许多创建可观测量的功能。事实上，数量如此之多，以至于一些开发者发现自己不知从何下手。在“RxJS课程”系列的这一部分中，我们将涵盖所有可观察的创建函数，如下所示:</p><ul class=""><li id="ff0f" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">of()</code></li><li id="656c" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">from()</code></li><li id="fae1" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">fromEvent()</code></li><li id="f275" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">interval()</code></li><li id="31cd" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">timer()</code></li><li id="311a" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">range()</code></li><li id="5c0d" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">defer()</code></li><li id="6edc" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">ajax()</code></li><li id="f964" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">fromFetch()</code></li><li id="9996" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">generate()</code></li></ul><p id="b231" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">事不宜迟，让我们开始吧:</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="77cc" class="kv kw it bd kx ky ne la lb lc nf le lf jz ng ka lh kc nh kd lj kf ni kg ll lm bi translated">创建功能</h1><h2 id="0c65" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">的()'</h2><p id="a2c7" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><code class="fe nj nk nl nm b">of()</code>允许我们从数组、对象、字符串等中创建可观察对象。它会将收到的每个参数作为一个整体发出，然后完成。让我们来看看如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/34937b07f5014e2e9890acddde44825d" rel="noopener ugc nofollow" target="_blank">用‘of()’创造可观测量</a></p></figure><p id="584a" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这里我们用<code class="fe nj nk nl nm b">of()</code>创建了四个不同的观察点:</p><ul class=""><li id="6f2a" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">从一系列数字中产生的<code class="fe nj nk nl nm b">number$</code>可观察值</li><li id="be87" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">pokemon$</code>可观察，由三个字符串创建</li><li id="e779" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">从两个字符串数组创建的<code class="fe nj nk nl nm b">fruit$</code>可观察值</li><li id="f4f9" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">iceCream$</code>可观察，由两个物体创建</li></ul><p id="813a" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">那么，我们如何获取我们的可观察物将发出的价值呢？订阅它们，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/0f9ad96869f4a574aae87bd60c56ce4f" rel="noopener ugc nofollow" target="_blank">订阅我们的Observables </a></p></figure><p id="d024" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如您所见，我们可以订阅Observable来访问它发出的值。</p><p id="fdde" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><strong class="lp iu">提示:</strong>如果我们愿意，我们可以避免使用匿名函数(<code class="fe nj nk nl nm b">=&gt;</code>函数),而是这样做:</p><pre class="kj kk kl km gt og nm oh oi aw oj bi"><span id="b061" class="ns kw it nm b gy ok ol l om on">pokemon$.subscribe(console.log);</span><span id="cab6" class="ns kw it nm b gy oo ol l om on">// Output: Squirtle Charmander Bulbasur</span></pre><p id="f0b1" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我相信，如果您实际使用它们并实时查看它们的输出，会更容易理解可观测量及其工作原理，这就是为什么我为我们将在本教程中介绍的每个代码片段准备了一个StackBlitz。因此，我建议您在<a class="ae ku" href="https://stackblitz.com/edit/creation-from?file=index.html" rel="noopener ugc nofollow" target="_blank">这一栈中使用<code class="fe nj nk nl nm b">of()</code></a>。</p><h2 id="1f85" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">来自()'</h2><p id="2d9f" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><code class="fe nj nk nl nm b">from()</code>从数组、承诺、对象、字符串等创建可观察对象。<code class="fe nj nk nl nm b">of()</code>听起来很耳熟吧？那么它们之间有什么区别呢？</p><p id="1c2c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">不同之处在于，<code class="fe nj nk nl nm b">from()</code>发出的是它所接收的参数中的项目，而<code class="fe nj nk nl nm b">of()</code>发出的是整个参数。这是什么意思？一旦我们订阅了一些用<code class="fe nj nk nl nm b">from()</code>创建的可观测量，我们就会明白了。首先，让我们创造一些可观察的事物:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/425b9cc1e5f0a6ecb4da9b1823396bc3" rel="noopener ugc nofollow" target="_blank">使用“from()”创建可观察值</a></p></figure><p id="3a11" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">正如您所看到的，我们在上面的代码片段中创建了五个不同的观察点:</p><ul class=""><li id="f32e" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">从字符串创建的<code class="fe nj nk nl nm b">letters$</code>可观察值</li><li id="f7b5" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">从字符串数组创建的<code class="fe nj nk nl nm b">fruit$</code>可观察值</li><li id="267b" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">从<code class="fe nj nk nl nm b">Map</code>对象创建的<code class="fe nj nk nl nm b">pokemon$</code>可观察对象</li><li id="d1d5" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">promise$</code>可观察，由<code class="fe nj nk nl nm b">Promise</code>创建</li><li id="2cba" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">node$</code>可观察，由<code class="fe nj nk nl nm b">NodeList</code>创建</li></ul><p id="ef93" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">让我们订阅并看看这些可观测量的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/08b2a1f37a4e20c3fa1a3029b542cd60" rel="noopener ugc nofollow" target="_blank">订阅用“from()”创建的观察值</a></p></figure><p id="57ae" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">是时候玩点区别了。让我们比较一下这两个<code class="fe nj nk nl nm b">fruit$</code>观察值，它们是我们使用<code class="fe nj nk nl nm b">from()</code>和<code class="fe nj nk nl nm b">of()</code>函数从一个字符串数组中创建的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/cb2b4ccb196da66c4021376373bc1c9e" rel="noopener ugc nofollow" target="_blank">比较‘from()’和‘of()’的可观测量</a></p></figure><p id="4b91" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你能看出区别吗？我们现在可以看到,<code class="fe nj nk nl nm b">from()</code>发出数组中的项目，而<code class="fe nj nk nl nm b">of()</code>发出整个数组。我们可以说<code class="fe nj nk nl nm b">from()</code>有一种扁平化的效果:它接受一个数组、一个字符串或一个对象，并发出它们所包含的项目。</p><p id="5fec" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-from?file=index.ts" rel="noopener ugc nofollow" target="_blank">这个堆栈</a>里玩<code class="fe nj nk nl nm b">from()</code>。</p><h2 id="d866" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">FromEvent()'</h2><p id="8df7" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">JavaScript有许多类型的事件，让我们知道有趣的事情何时发生。使用<code class="fe nj nk nl nm b">fromEvent()</code>，我们可以创建当这些事件被触发时发出的可观测信号。<code class="fe nj nk nl nm b">fromEvent()</code>接收两个不同的参数:</p><ul class=""><li id="d9d9" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">事件处理函数将附加到的事件目标</li><li id="ca6f" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">我们想听的事件类型</li></ul><p id="900c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们将从四个不同的事件中创建四个不同的可观测量:<code class="fe nj nk nl nm b">click</code>、<code class="fe nj nk nl nm b">keydown</code>、<code class="fe nj nk nl nm b">scroll</code>和<code class="fe nj nk nl nm b">copy</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">“fromEvent()”可观察值</p></figure><p id="e762" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如果我们使用的四个事件中的任何一个是由用户与文档的交互触发的，那么相应的Observable将发出。发出的值会是什么？让我们来看看输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/2d42baeb2f286dcd0a5d75b477dfad5b" rel="noopener ugc nofollow" target="_blank">订阅“fromEvent()”观察值</a></p></figure><p id="f635" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">正如您所看到的，我们正在接收一个事件对象，它包含许多我们可以使用的有用的事件属性。</p><p id="c775" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">但是我们的观察对象如何能够监听事件目标呢？我们不需要添加事件处理程序吗？</p><p id="cff0" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">嗯，这就是<code class="fe nj nk nl nm b">fromEvent()</code>的妙处。当我们订阅用<code class="fe nj nk nl nm b">fromEvent()</code>创建的可观察对象时，一个事件处理函数会自动附加到所提供的事件目标上。这就是我们的可观察对象如何监听，以查看事件是否被触发。一旦我们取消订阅任何用<code class="fe nj nk nl nm b">fromEvent()</code>创建的可观察对象，可观察对象就会为我们移除事件处理程序。很酷，对吧？</p><p id="b54c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-fromevent" rel="noopener ugc nofollow" target="_blank">这个堆栈</a>里玩<code class="fe nj nk nl nm b">fromEvent()</code>。</p><h2 id="ac7a" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">间隔()'</h2><p id="9406" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><code class="fe nj nk nl nm b">interval()</code>创建一个可观察对象，它根据提供的时间间隔发出一系列升序数字。时间间隔大小参数是可选的，默认值为0。对此我们必须非常小心。说到这里，让我们来看几个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">使用“interval()”创建可观察值</p></figure><p id="6eb8" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如您所知，<code class="fe nj nk nl nm b">interval()</code>是一个非常简单的函数。我们唯一需要注意的是默认的间隔值是0。</p><p id="759d" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-interval" rel="noopener ugc nofollow" target="_blank">这个堆栈</a>里玩<code class="fe nj nk nl nm b">interval()</code>。</p><h2 id="c3ae" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">计时器()'</h2><p id="f47c" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><code class="fe nj nk nl nm b">timer()</code>产生一个可观测值，在初始延迟后，开始根据规定的时间间隔发出一系列递增的数字。它与<code class="fe nj nk nl nm b">interval()</code>非常相似，不同之处在于我们可以指定何时开始排放。<code class="fe nj nk nl nm b">timer()</code>接收两个参数:</p><ul class=""><li id="e552" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">发出第一个值之前等待的初始延迟</li><li id="7804" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">排放之间的间隔值</li></ul><p id="6cbc" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这两个参数都是可选的，默认值为0。</p><p id="c862" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">让我们来看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/e8bbb8d2b3fe1ad1315586fef4d514a9" rel="noopener ugc nofollow" target="_blank">使用“timer()”创建可观察值</a></p></figure><p id="072d" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-timer" rel="noopener ugc nofollow" target="_blank">这个堆栈</a>里玩<code class="fe nj nk nl nm b">timer()</code>。</p><h2 id="2b8a" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">范围()'</h2><p id="ae4b" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><code class="fe nj nk nl nm b">range()</code>创建一个发出一系列递增序列号的可观察对象。它接收两个参数:</p><ul class=""><li id="6e22" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">范围的起点</li><li id="3191" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">范围的长度——也就是将要发出的数字的数量。该参数是可选的，默认值为0。</li></ul><p id="9065" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">使用“range()”创建可观察值</p></figure><p id="1c55" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-range?file=index.ts" rel="noopener ugc nofollow" target="_blank">这个StackBlitz </a>里摆弄<code class="fe nj nk nl nm b">range()</code>。</p><h2 id="36ec" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">defer()'</h2><p id="0f1d" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><code class="fe nj nk nl nm b">defer()</code>让我们可以懒散地创造可观的事物。它一直等到我们订阅，然后执行可观察的创建逻辑。</p><p id="3912" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这意味着每个订阅都会创建一个新的可观察对象。这听起来可能有点混乱，但是如果我们看一个例子，比较用<code class="fe nj nk nl nm b">defer()</code>创建的可观察值和用其他创建函数创建的可观察值，这就很容易理解了。</p><p id="f044" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">让我们用<code class="fe nj nk nl nm b">of()</code>创建一个可观察值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/48bab36cb65c8ff0380cba55c09762ec" rel="noopener ugc nofollow" target="_blank">从一个函数创建一个可观察值，该函数返回一个带有‘of()’的随机值</a></p></figure><p id="092a" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">正如你在例子中看到的，我们有一个<code class="fe nj nk nl nm b">getRandomPokemon()</code>函数，正如它的名字所示，返回一个随机的神奇宝贝。我们已经使用<code class="fe nj nk nl nm b">of()</code>从<code class="fe nj nk nl nm b">getRandomPokemon()</code>函数中创建了一个<code class="fe nj nk nl nm b">randomPokemon$</code>可观察值。然而，当我们订阅这个可观测的，我们总是得到相同的值:<code class="fe nj nk nl nm b">Charmander</code>。难道我们每次订阅的时候不应该得到一个随机的神奇宝贝吗？答案是否定的，为什么？</p><p id="f196" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">因为<code class="fe nj nk nl nm b">getRandomPokemon()</code>函数是在可观察对象创建时执行的，而不是在我们订阅时执行的。这意味着它只执行一次——当我们创建可观察对象时。不管我们订阅多少次，可观察的东西已经被创造出来了，所以我们总是得到同样的神奇宝贝。</p><p id="758e" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">基本上，我们订阅了三次相同的可观测值，它发出<code class="fe nj nk nl nm b">Charmander</code>。那么如何才能让<code class="fe nj nk nl nm b">getRandomPokemon()</code>函数在每次订阅时执行，而不是在创建可观察对象时执行呢？通过使用<code class="fe nj nk nl nm b">defer()</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/2fb6f2232115babe23a475e6fbff72a2" rel="noopener ugc nofollow" target="_blank">使用“defer()”从返回随机值的函数中创建可观察值</a></p></figure><p id="fd59" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们已经使用来自<code class="fe nj nk nl nm b">getRandomPokemon()</code>函数的<code class="fe nj nk nl nm b">defer()</code>创建了<code class="fe nj nk nl nm b">randomPokemonForReal$</code>可观察值。正如你在上面的例子中看到的，每次我们订阅它，我们都会获得一个不同的神奇宝贝。就像我们之前说过的，这是因为可观察的创建逻辑(在本例中，是<code class="fe nj nk nl nm b">getRandomPokemon()</code>函数)是在每次订阅时执行的。</p><p id="319d" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">综上所述，需要懒人可观测量的时候可以用<code class="fe nj nk nl nm b">defer()</code>。你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-defer?file=index.ts" rel="noopener ugc nofollow" target="_blank">这个堆栈</a>里玩<code class="fe nj nk nl nm b">defer()</code>。</p><h2 id="4f9d" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">ajax()'</h2><p id="1b7a" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">顾名思义，<code class="fe nj nk nl nm b">ajax()</code>函数从AJAX请求中创建一个可观察对象。让我们来看看如何使用它:</p><p id="465a" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><strong class="lp iu">注意:</strong>我们将使用<a class="ae ku" href="https://ghibliapi.herokuapp.com" rel="noopener ugc nofollow" target="_blank"> Ghibli API </a>来测试我们的AJAX调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/1a3d806aea24f78b52a12708f611ecc8" rel="noopener ugc nofollow" target="_blank"> 'ajax()'示例</a></p></figure><p id="9dcf" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">当我们用<code class="fe nj nk nl nm b">ajax()</code>创建一个可观察对象时，它将发出从API调用返回的整个<code class="fe nj nk nl nm b">AjaxResponse</code>对象。但是如果我们只对获取返回的数据感兴趣呢？嗯，原来<code class="fe nj nk nl nm b">ajax()</code>有一个叫做<code class="fe nj nk nl nm b">getJSON()</code>的简洁的小功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/22d31ea2007dd8228b39e9aea17623e1" rel="noopener ugc nofollow" target="_blank">‘get JSON’示例</a></p></figure><p id="c1ca" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">不错！我们已经得到了我们需要的数据。然而，另一个问题出现了:如果我们需要设置自定义头怎么办？没问题，我们可以通过向<code class="fe nj nk nl nm b">ajax()</code>传递一个对象来设置它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/fa3d9ff16d12bbd8065c5b55ae74cf6e" rel="noopener ugc nofollow" target="_blank">为“ajax()”设置自定义标题</a></p></figure><p id="26b4" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">瞧啊！我们现在有了一个用<code class="fe nj nk nl nm b">ajax()</code>创建的可观察对象，带有自定义标题。你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-ajax?file=index.ts" rel="noopener ugc nofollow" target="_blank">这个堆栈</a>里玩<code class="fe nj nk nl nm b">ajax()</code>。</p><h2 id="fd58" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">fromFetch()'</h2><p id="cfa4" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">AJAX请求很好，但是如果我们想使用<code class="fe nj nk nl nm b">fetch</code>呢？没问题，<code class="fe nj nk nl nm b">fromFetch()</code>允许我们这么做。让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/d878328b867ea85269a32987226332a4" rel="noopener ugc nofollow" target="_blank">使用“fromFetch()”创建可观察对象</a></p></figure><p id="f01c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如您所见，就像使用<code class="fe nj nk nl nm b">ajax()</code>一样，Observable返回整个<code class="fe nj nk nl nm b">Response</code>对象。如果我们只是想要数据呢？与<code class="fe nj nk nl nm b">ajax()</code>不同，<code class="fe nj nk nl nm b">fromFetch()</code>没有<code class="fe nj nk nl nm b">getJSON()</code>功能。那么我们如何获取数据呢？通过做这样的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/dea1b69a708c4ed08f9110d61928f0af" rel="noopener ugc nofollow" target="_blank">使用“切换图”获取数据</a></p></figure><p id="7fec" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">错误处理呢——因为对于HTTP请求，很多事情都可能出错。以下是如何处理错误的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/866292edb3283c49b1e31f9fdd55471d" rel="noopener ugc nofollow" target="_blank">使用‘from fetch()’进行错误处理</a></p></figure><p id="9ba5" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我知道这是相当多的代码，所以让我们把它分解一下:</p><ul class=""><li id="42e5" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">首先，我们使用<code class="fe nj nk nl nm b">switchMap()</code>操作符并检查响应是否正常。通过使用guard子句，如果响应不正常，我们将抛出一个错误。如果没有出错，我们使用<code class="fe nj nk nl nm b">json()</code>函数从响应中返回JSON主体内容。</li><li id="bb54" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">然后，我们使用<code class="fe nj nk nl nm b">catchError()</code>操作符来捕捉错误(万一发生错误)并打印出来。然后，我们返回一个对象的可观察值，包含错误消息和一个错误属性，设置为<code class="fe nj nk nl nm b">true</code>。</li><li id="a5e1" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated">最后，我们订阅。如果<code class="fe nj nk nl nm b">fetch</code>调用顺利，我们将收到响应的数据。如果没有，我们将收到一个错误对象，以及出错的消息。</li></ul><p id="b52c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-fromfetch" rel="noopener ugc nofollow" target="_blank">这个堆栈</a>里玩<code class="fe nj nk nl nm b">fromFetch()</code>。</p><h2 id="8708" class="ns kw it bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">'生成()'</h2><p id="4e6d" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我想把<code class="fe nj nk nl nm b">generate()</code>献给所有的for loop爱好者。<code class="fe nj nk nl nm b">generate()</code>将通过运行一个状态驱动的循环来创建一个可观察的序列，该循环将产生序列中的元素。它接收三个不同的参数:</p><ul class=""><li id="4135" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">initialState</code>:确定循环的起点，初始值</li><li id="5190" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">condition</code>:决定循环结束条件的函数。它接收当前值并检查是否满足指定的条件。如果是，则循环继续。否则，循环结束。</li><li id="3d4e" class="mo mp it lp b lq nn lt no lw np ma nq me nr mi mt mu mv mw bi translated"><code class="fe nj nk nl nm b">iterate</code>:决定每次迭代时如何修改定义值的函数。</li></ul><p id="ace3" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这听起来可能有点复杂，但一旦你看到它，就很容易理解了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">使用“generate()”创建可观察对象</p></figure><p id="35eb" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">第一个参数是<code class="fe nj nk nl nm b">initialState</code>值。如你所见，我们循环的第一个值是<code class="fe nj nk nl nm b">1</code>。</p><p id="c29f" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">第二个参数是条件函数—只要当前值低于<code class="fe nj nk nl nm b">10</code>，我们的循环就会继续。</p><p id="e1d1" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">最后，第三个参数对应于每次交互时当前值将如何被修改。在这种情况下，它将增加<code class="fe nj nk nl nm b">1</code>，这意味着我们的<code class="fe nj nk nl nm b">number$</code>可观测对象将发出从1到9的数字。</p><p id="0723" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">然而，将匿名函数传递给<code class="fe nj nk nl nm b">generate()</code>看起来有点奇怪，不是吗？如果我们喜欢这种语法，我们可以传递一个对象。这里有一个<a class="ae ku" href="https://gist.github.com/NyaGarcia/73d7de00cf78c100de53888ce2e8bb1b" rel="noopener ugc nofollow" target="_blank">的例子</a>。</p><p id="ce92" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如你所见，我们的<code class="fe nj nk nl nm b">evenNumber$</code>可观测体将发射2到10之间的所有偶数。</p><p id="a367" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><strong class="lp iu">警告:</strong>向<code class="fe nj nk nl nm b">generate()</code>传递一个对象允许我们省略条件变量。如果我们这样做，我们将创建一个无休止的循环，所以要非常小心。</p><p id="c92f" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这是一个无限循环的例子。不要这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/NyaGarcia/97d58a1d36c3d2ef7eb920fde0b4edb6" rel="noopener ugc nofollow" target="_blank">‘generate()’死循环</a></p></figure><p id="c610" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">你可以在<a class="ae ku" href="https://stackblitz.com/edit/creation-generate" rel="noopener ugc nofollow" target="_blank">这堆</a>里玩<code class="fe nj nk nl nm b">generate()</code>。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="f2c9" class="kv kw it bd kx ky ne la lb lc nf le lf jz ng ka lh kc nh kd lj kf ni kg ll lm bi translated">结论</h1><p id="db16" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">那都是乡亲们！我们已经介绍了RxJS为可观察创建提供的每一个功能。正如你所看到的，有很多方法可以创造可观测量，尽管并不是所有的方法都被广泛使用。</p><p id="2c61" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">知道如何创建一个可观察对象对于开始我们的RxJS之旅至关重要，但是RxJS的真正力量来自于可管道操作符的流操作。我们将在“RxJS课程”系列的后续教程中介绍所有现有的RxJS运算符。</p><p id="da41" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我希望你喜欢这个教程，并发现它很有用。干杯。</p></div></div>    
</body>
</html>