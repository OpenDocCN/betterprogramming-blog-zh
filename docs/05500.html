<html>
<head>
<title>3 Ways to Rotate an Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">旋转阵列的三种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-ways-to-rotate-an-array-2a45b39f7bec?source=collection_archive---------2-----------------------#2020-07-14">https://betterprogramming.pub/3-ways-to-rotate-an-array-2a45b39f7bec?source=collection_archive---------2-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="37e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个算法一点也不简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7112ee3844c26327947a16b7017c2a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lj4kmi0QAWGfIROpG3olWg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@publicpowerorg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">美国公共电力协会</a>在<a class="ae kv" href="https://unsplash.com/s/photos/arrays?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最常见的算法之一是<a class="ae kv" href="https://leetcode.com/problems/rotate-array/" rel="noopener ugc nofollow" target="_blank">旋转数组问题</a>:</p><blockquote class="ls lt lu"><p id="8497" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">给定一个数组，将数组向右旋转k步，其中k为非负。尽可能想出更多的解决方案——至少有三种不同的方法来解决这个问题。你能在有0(1)额外空间的地方做吗？</p></blockquote><p id="20fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果给你一个数组<code class="fe lz ma mb mc b">[1, 2, 3, 4, 5]</code>，并告诉你将它向右旋转<code class="fe lz ma mb mc b">2</code>步，输出应该是<code class="fe lz ma mb mc b">[4, 5, 1, 2, 3]</code>。向右旋转一次后，数组将是<code class="fe lz ma mb mc b">[5, 1, 2, 3, 4]</code>，因此向右旋转两次后，数组将变成<code class="fe lz ma mb mc b">[4, 5, 1, 2, 3]</code>。</p><p id="b4fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Leetcode上，这个问题被贴上了“容易”的标签——他们是如何确定难度等级的，我不太清楚。但是，我觉得这个问题绝不简单。有很多方法可以解决这个问题，这也是我喜欢它的部分原因，我认为每个解决方案都有自己的复杂之处。</p><p id="9b88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将介绍三种不同的方法来处理和解决这个问题:</p><ol class=""><li id="c324" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated">弹出和取消移动数组中的元素。</li><li id="72cc" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">创建一个新数组，其中的元素开始移位。</li><li id="9fb9" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">反转阵列的不同部分。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/b93358b68ce516113b080252043b5cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ieB9Zj-EKlGxn49W"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@paan_azam13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法尔汉·阿扎姆</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="cd4f" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">方法1:弹出和取消移动</h1><p id="9f2c" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">使用数组时，总会出现一些方法。其中一个是<code class="fe lz ma mb mc b">.pop()</code>，它“从一个数组中移除最后一个元素并返回该元素”(在这里阅读更多关于<code class="fe lz ma mb mc b">.pop()</code><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank"/>)。例如:</p><pre class="kg kh ki kj gt nw mc nx ny aw nz bi"><span id="fd96" class="oa na iq mc b gy ob oc l od oe">const arr = [1, 2, 3]<br/>arr.pop() // would return 3<br/>console.log(arr) // would print [1, 2]</span></pre><p id="9eb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数组上使用的另一个常用方法是<code class="fe lz ma mb mc b">.unshift()</code>。此方法“将一个或多个元素添加到数组的开头，并返回数组的新长度”(`阅读更多关于。unshift() <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" rel="noopener ugc nofollow" target="_blank">此处</a>)。例如:</p><pre class="kg kh ki kj gt nw mc nx ny aw nz bi"><span id="d580" class="oa na iq mc b gy ob oc l od oe">const arr = [2, 3]<br/>arr.unshift(1) // would return 3, the new length of the array<br/>console.log(arr) // would print [1, 2, 3]</span></pre><p id="d2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向右旋转数组也可以认为是将元素从数组的后面移动到数组的前面。在这个问题中，我们希望将元素从数组的后面移到前面，这样做<code class="fe lz ma mb mc b">k</code>次。在一个将运行<code class="fe lz ma mb mc b">k</code>次的for循环中，我们可以从数组的后面弹出最后一个数字，并将该数字移至数组的前面。</p><p id="063b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们得到了数组<code class="fe lz ma mb mc b">nums = [1, 2, 3, 4, 5]</code>和<code class="fe lz ma mb mc b">k = 2</code>，那么我们应该旋转数组两次。使用pop和unshift，我们将从弹出最后一个元素<code class="fe lz ma mb mc b">5</code>开始，这将产生<code class="fe lz ma mb mc b">nums = [1, 2, 3, 4]</code>。然后，我们去移位<code class="fe lz ma mb mc b">5</code>，把它放在数组的前面，这样<code class="fe lz ma mb mc b">nums = [5, 1, 2, 3, 4]</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/3f817a390ff7f8a2a27e96a08c6d5953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u23vSKxlx46U6OKIxYqErQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nums = [1，2，3，4，5]；nums . pop()= 5；nums = [1，2，3，4]；nums.unshift(5) = [5，1，2，3，4]</p></figure><p id="e354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们再重复一次这个循环，弹出<code class="fe lz ma mb mc b">4</code>，制作<code class="fe lz ma mb mc b">nums = [5, 1, 2, 3]</code>，然后解除<code class="fe lz ma mb mc b">4</code>，给我们最后的答案<code class="fe lz ma mb mc b">nums = [4, 5, 1, 2, 3]</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/e0815c1a2913785c6572dac2adb64e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0mEFWGjQTytWzW2NtI28A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nums . pop()= 4；nums = [5，1，2，3]；nums.unshift(4) = [4，5，1，2，3]</p></figure><h2 id="c219" class="oa na iq bd nb og oh dn nf oi oj dp nj lf ok ol nl lj om on nn ln oo op np oq bi translated"><strong class="ak">编码第一种方法</strong></h2><p id="1b87" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">在我们开始编写这个解决方案之前，关于这个问题还有一点需要注意。假设给定的数组是<code class="fe lz ma mb mc b">[1, 2]</code>，我们被告知将其向右旋转七次。这个数组的长度不到7个元素，所以旋转它7次会是很多不必要的工作。因此，在我们做任何事情之前，无论是在这个解决方案中还是在其他方法中，我们都应该使用modulo ( <code class="fe lz ma mb mc b">%</code>)来修改<code class="fe lz ma mb mc b">k</code>。</p><p id="099d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模运算符返回一个数除以另一个数后的余数。例如，<code class="fe lz ma mb mc b">10%3</code>将返回<code class="fe lz ma mb mc b">1</code>，因为10/3的余数为1。同样，在这个问题中，我们想设置<code class="fe lz ma mb mc b">k</code>等于<code class="fe lz ma mb mc b">k % nums.length</code>。用同样的例子，如果<code class="fe lz ma mb mc b">k = 7</code>和<code class="fe lz ma mb mc b">nums = [1, 2]</code>，那么<code class="fe lz ma mb mc b">k = k % nums.length</code>与<code class="fe lz ma mb mc b">k = 7%2</code>或<code class="fe lz ma mb mc b">k = 1</code>相同。这个解决方案的第一行是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="97af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望按照<code class="fe lz ma mb mc b">k</code>等于的次数执行<code class="fe lz ma mb mc b">.pop()</code>和<code class="fe lz ma mb mc b">.unshift()</code>，因此我们创建了一个重复<code class="fe lz ma mb mc b">k</code>次的for循环。在for循环中，我们将<code class="fe lz ma mb mc b">nums.pop()</code>的结果存储到一个名为<code class="fe lz ma mb mc b">back</code>的变量中。然后，我们取消<code class="fe lz ma mb mc b">back</code>的移位，把它放在<code class="fe lz ma mb mc b">nums</code>数组的开始。</p><p id="c4e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦for循环停止执行，我们就返回<code class="fe lz ma mb mc b">nums</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="a86e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这第一种方法是在线性时间(O(n))和常数空间(O(1))中完成的。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="96ff" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">方法2:创建新的数组</h1><p id="dfdf" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">在第二种方法中，我们创建了一个新的数组，其中的元素在<code class="fe lz ma mb mc b">k</code>空格上移动了。这里的想法是，我们可以直接遍历<code class="fe lz ma mb mc b">nums</code>数组，并将每个元素<code class="fe lz ma mb mc b">k</code>移动到原来位置的右边。</p><p id="58ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果元素应该移动到一个比<code class="fe lz ma mb mc b">nums</code>数组长度更长的索引，会发生什么呢？在这种情况下，使用模操作符，计算移动到新距离<code class="fe lz ma mb mc b">%</code>的结果，即<code class="fe lz ma mb mc b">nums</code>数组的长度。我认为这是这种方法中特别棘手的部分，所以我将使用一个例子。</p><p id="f296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您从数组<code class="fe lz ma mb mc b">nums = [1, 2, 3]</code>和空白数组<code class="fe lz ma mb mc b">arr</code>开始。我们被告知<code class="fe lz ma mb mc b">k = 2</code>，所以数组将向右移动2个点。我们从移动<code class="fe lz ma mb mc b">nums</code>数组的第一个元素<code class="fe lz ma mb mc b">1</code>开始。<code class="fe lz ma mb mc b">1</code>位于索引0 ( <code class="fe lz ma mb mc b">i = 0</code>)，我们想将它移动两个位置。换句话说，我们希望它在<code class="fe lz ma mb mc b">arr</code>数组中的位置由索引为<code class="fe lz ma mb mc b">2</code>的<code class="fe lz ma mb mc b">i + k</code>决定。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/c4a69105d7fb0e8f773637ca435bccdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rH6Piijkj0ioUvxJUK5euA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">nums = [1，2，3]；arr =[]；I = 0；I+k = 2；arr = [ <empty>，<empty>，1]</empty></empty></p></figure><p id="72a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们在<code class="fe lz ma mb mc b">nums</code>数组的索引一上，<code class="fe lz ma mb mc b">2</code>。我们想将它向右移动<code class="fe lz ma mb mc b">k</code>步，但是<code class="fe lz ma mb mc b">i + k</code>是3，这将比<code class="fe lz ma mb mc b">nums</code>数组的长度更长。所以，要为<code class="fe lz ma mb mc b">2</code>找到新的点，我们应该做<code class="fe lz ma mb mc b">(i + k) % nums.length</code>，或者<code class="fe lz ma mb mc b">3%3</code>，也就是0。因此，我们应该将元素<code class="fe lz ma mb mc b">2</code>移动到<code class="fe lz ma mb mc b">arr</code>中的索引<code class="fe lz ma mb mc b">0</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/11dbad26ab4083c396fe14b925531d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCt9iEmfRzlbSuMTqS2qfw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">I = 1；I+k = 3；nums . length = 3；3 % 3 = 0;arr = [2，<empty>，1]</empty></p></figure><p id="3b23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们在<code class="fe lz ma mb mc b">nums</code>数组的第二个索引上，即<code class="fe lz ma mb mc b">3</code>。我们想把它向右移动<code class="fe lz ma mb mc b">k</code>步，<code class="fe lz ma mb mc b">i + k</code>是4，比<code class="fe lz ma mb mc b">nums</code>数组的长度还长。所以，为了给<code class="fe lz ma mb mc b">3</code>找到新的位置，我们应该做<code class="fe lz ma mb mc b">(i + k) % nums.length</code>，或者<code class="fe lz ma mb mc b">4%3</code>，也就是<code class="fe lz ma mb mc b">1</code>。所以，我们应该将元素<code class="fe lz ma mb mc b">3</code>移动到<code class="fe lz ma mb mc b">arr</code>中的索引<code class="fe lz ma mb mc b">1</code>，给出这个问题的最终结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/31223f8818a9f922d4c062d134e1b688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ideSuBTVuDJwxs4fNr8OKA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">I = 2；I+k = 4；nums . length = 3；4% 3 = 1;arr = [2，3，1]</p></figure><h2 id="8961" class="oa na iq bd nb og oh dn nf oi oj dp nj lf ok ol nl lj om on nn ln oo op np oq bi translated"><strong class="ak">编码第二种方法</strong></h2><p id="7524" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">为了开始这个解决方案，我们对<code class="fe lz ma mb mc b">k</code>做了与第一种方法相同的修改。然后我们初始化一个名为<code class="fe lz ma mb mc b">arr</code>的新的空数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="a43b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们使用for循环遍历<code class="fe lz ma mb mc b">nums</code>中的每个元素。在每个索引处，我们将该元素放在<code class="fe lz ma mb mc b">arr</code>中的新位置。我们可以通过做<code class="fe lz ma mb mc b">(i + k) % nums.length</code>来找到那个新的地点。所以，我们设置<code class="fe lz ma mb mc b">arr[(i + k) % nums.length]</code>等于<code class="fe lz ma mb mc b">nums[i]</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="0439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe lz ma mb mc b">arr</code>将是我们想要的旋转后的数组。然而，在这个问题中，我们应该修改<code class="fe lz ma mb mc b">nums</code>数组，所以我们必须将<code class="fe lz ma mb mc b">nums</code>中的每个索引设置为等于<code class="fe lz ma mb mc b">arr</code>中该索引处的值。为此，我们设置了另一个for循环。在每个索引处，我们将设置<code class="fe lz ma mb mc b">nums[i]</code>等于<code class="fe lz ma mb mc b">arr[i]</code>。当for循环结束时，我们可以返回<code class="fe lz ma mb mc b">nums</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="1ba4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这第二种方法是在线性时间(O(n))和线性空间(O(n))中完成的。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="d6a7" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated"><strong class="ak">方法3:颠倒截面</strong></h1><p id="48af" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">在第三种方法中，我们将反转<code class="fe lz ma mb mc b">nums</code>的零件。第一次，我们反转整个数组。第二次，我们反转数组的第一个<code class="fe lz ma mb mc b">k</code>元素。第三次，我们反转数组的最后一个元素，从<code class="fe lz ma mb mc b">k</code>到末尾。</p><p id="4614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法背后的思想最好用一个例子来看。我们从数组<code class="fe lz ma mb mc b">[1, 2, 3, 4, 5]</code>开始，我们希望将它旋转两步。我们从旋转整个数组开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/00542d66618119cb823b73e5c30577e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-vSfYUCPbMhiYyELJXazg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk">[1, 2, 3, 4, 5] -&gt; [5, 4, 3, 2, 1]</p></figure><p id="34fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们要旋转第一个<code class="fe lz ma mb mc b">k</code>元素。由于<code class="fe lz ma mb mc b">k</code>是2，我们将在0和1旋转元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/b4a0d7d5789dff0cc14c85eabd37c4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKyx6Z30xFbdfzQH6gas7g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk">[5, 4, 3, 2, 1] -&gt; [4, 5, 3, 2, 1]</p></figure><p id="9896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将旋转最后的元素，从索引<code class="fe lz ma mb mc b">k</code>到结尾。这给了我们想要的最终数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/cbd50c468c986dc6ae3a8dd4d9280b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvRPpHHoJyXOnYYUwHE16Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk">[4, 5, 3, 2, 1] -&gt; [4, 5, 1, 2, 3]</p></figure><p id="6bd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">编码第三种方法<br/> </strong>为了编码这个解决方案，我们将在<code class="fe lz ma mb mc b">rotate</code>函数内编写一个名为<code class="fe lz ma mb mc b">reverse</code>的函数，我们将调用它三次。然而，首先，我们将对<code class="fe lz ma mb mc b">k</code>做与前两种方法相同的修改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="34e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们会调用函数<code class="fe lz ma mb mc b">reverse</code>(一分钟后会写)，我们会调用三次。<code class="fe lz ma mb mc b">reverse()</code>将数组取入，索引开始反转，索引结束反转。因此，对<code class="fe lz ma mb mc b">reverse()</code>的第一个调用将传入<code class="fe lz ma mb mc b">nums</code>、<code class="fe lz ma mb mc b">0</code>(作为开始索引)和<code class="fe lz ma mb mc b">nums.length — 1</code>(作为结束索引)。对<code class="fe lz ma mb mc b">reverse()</code>的第二次调用将传入<code class="fe lz ma mb mc b">nums</code>、<code class="fe lz ma mb mc b">0</code>(作为开始索引)和<code class="fe lz ma mb mc b">k — 1</code>(作为结束索引)。对<code class="fe lz ma mb mc b">reverse()</code>的第三次调用将传入<code class="fe lz ma mb mc b">nums</code>、<code class="fe lz ma mb mc b">k</code>(作为开始索引)和<code class="fe lz ma mb mc b">nums.length — 1</code>(作为结束索引)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="7644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以编写函数<code class="fe lz ma mb mc b">reverse</code>，它的参数将是<code class="fe lz ma mb mc b">nums</code>、<code class="fe lz ma mb mc b">start</code>和<code class="fe lz ma mb mc b">end</code>。在该函数中，我们切换起始和结束索引处的值，并将起始和结束向中心移动。只要开始小于结束，我们就一直这样做。</p><p id="9e21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们写了一个while循环，只要start小于end，它就会一直循环下去。在循环内部，我们保存了一个临时变量，该变量在起始索引处存储了<code class="fe lz ma mb mc b">nums</code>数组的值。然后，我们将起始索引处的值设置为等于结束索引处的值，并将结束索引处的值设置为等于临时变量。我们通过增加开始向中间移动，通过减少结束向中间移动。最后，当while循环执行后，我们将<code class="fe lz ma mb mc b">nums</code>返回到<code class="fe lz ma mb mc b">rotate</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="28e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦每个<code class="fe lz ma mb mc b">reverse()</code>函数执行完毕，最后一件事就是返回<code class="fe lz ma mb mc b">nums</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="a265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解是在线性时间(O(n))和常数空间(O(1))中完成的。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="7aac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有任何问题或其他解决方法的想法，请在评论中告诉我！</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="5cca" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="1b56" class="md me iq ky b kz nr lc ns lf ot lj ou ln ov lr ow mj mk ml bi translated"><a class="ae kv" href="https://leetcode.com/problems/rotate-array/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/rotate-array/</a></li><li id="df21" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr ow mj mk ml bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array/pop</a></li><li id="93b7" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr ow mj mk ml bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array/un shift</a></li></ul></div></div>    
</body>
</html>