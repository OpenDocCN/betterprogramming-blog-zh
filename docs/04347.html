<html>
<head>
<title>The Power and Convenience of useAsync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用的强大和便利同步</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-and-convenience-of-useasync-e4a3e4934143?source=collection_archive---------7-----------------------#2020-04-07">https://betterprogramming.pub/the-power-and-convenience-of-useasync-e4a3e4934143?source=collection_archive---------7-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f177" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">react-async简介，这是一个用于声明性承诺解析和数据获取的实用工具带</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9ec62b075228312bccef6ce3ca481b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqExJaQju_SKuK4KNjkw3w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迪伦·吉利斯在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何在React中进行异步调用？你用<code class="fe lv lw lx ly b">axios</code>、<code class="fe lv lw lx ly b">fetch</code>，甚至<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>吗？</p><p id="cd7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您应该熟悉如何获取成功调用的数据，以及如何接收失败调用的错误。很可能，您还需要跟踪加载状态以显示挂起状态。</p><p id="a5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有考虑过用定制的挂钩把它们包起来？</p><p id="317c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都是由react-async ( <code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/async-library/react-async" rel="noopener ugc nofollow" target="_blank">react-async</a>)</code>)完成的，这是一个用于声明性承诺解析和数据获取的实用工具带。我们将向您展示使用这个强大的react-async是多么容易。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="47bf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用Create React应用程序进行演示</h1><p id="aa5d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一如既往，魔法始于<a class="ae ky" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener">创建React应用</a>。用命令<code class="fe lv lw lx ly b">npm i react-async</code>安装react-async。然后修改<code class="fe lv lw lx ly b">src/App.js</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="eff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6到10行是一个获取函数。它由第13到16行的<code class="fe lv lw lx ly b">useAsync</code>调用。</p><p id="a8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe lv lw lx ly b">useAsync</code>用三个项目来构造:<code class="fe lv lw lx ly b">data</code>、<code class="fe lv lw lx ly b">error</code>和<code class="fe lv lw lx ly b">isPending</code>。第21到25行使用这些项目来显示正确的UI。</p><p id="36bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据此调用是否处于挂起状态，此调用会导致错误或返回数据。很简单，不需要用<code class="fe lv lw lx ly b">useEffect</code>包裹副作用。</p><p id="3ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe lv lw lx ly b">npm start</code>，你会看到如下界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/9d1ac4285dc4e7703574ef207120e619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHatPgyNLRnk9SOlbmOQ8Q.png"/></div></div></figure><p id="0bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是第23行的结果，因为提取<code class="fe lv lw lx ly b">http://localhost:4000/asset-manifest.json</code>失败。</p><p id="96e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以尝试任何带有数据的URL，或者按照以下步骤在<code class="fe lv lw lx ly b">localhost:4000</code>上启动应用程序:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="bc98" class="nk mh it ly b gy nl nm l nn no">git clone --single-branch --branch chunkOptimization <a class="ae ky" href="https://github.com/JenniferFuBook/micro-frontend.git" rel="noopener ugc nofollow" target="_blank">https://github.com/JenniferFuBook/micro-frontend.git</a><br/>npm i<br/>npm start</span></pre><p id="896f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您将看到第24行的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/7a9effcd742c1ce4a1729e4221707afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1IZzK_F9dqMcKPmbLpIag.png"/></div></div></figure><p id="eb4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">22号线待定状态怎么样？</p><p id="3b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点棘手。既然是过境国，你可能看到也可能看不到。</p><p id="1eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将您的网络设置为<code class="fe lv lw lx ly b">Slow 3G</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/27fa9ee12f2a1baaf69d916e206162bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJyCCjGSVeWP9mdBFfLlJg.png"/></div></div></figure><p id="346f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你一定会看到的。当然，旋转的标志也加载得很慢。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/df7fe679cfddb608d7517b6ca6840913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOK4aVuYUGSagAZbkK2Twg.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cec7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用同步挂钩</h1><p id="51b4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">先来了解一下<code class="fe lv lw lx ly b">useAsync</code>:它是一个钩子，可以被<code class="fe lv lw lx ly b">fetch</code>、<code class="fe lv lw lx ly b">axios</code>或者其他数据取数库使用。它接受<code class="fe lv lw lx ly b">options</code>并返回一个<code class="fe lv lw lx ly b">state</code>。</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="3bf9" class="nk mh it ly b gy nl nm l nn no">const state = useAsync(options)</span></pre><p id="c29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">options</code>在文件中定义<a class="ae ky" href="https://docs.react-async.com/api/options" rel="noopener ugc nofollow" target="_blank">。我们用了其中的两个:</a></p><ul class=""><li id="48f1" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">promiseFn</code>:返回承诺的函数，自动调用。</li><li id="de27" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">onResolve</code>:承诺解决时调用回调。</li></ul><p id="728a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">state</code>属性在文档中定义<a class="ae ky" href="https://docs.react-async.com/api/state" rel="noopener ugc nofollow" target="_blank">。第14行解构了其中的三个:</a></p><ul class=""><li id="f1dc" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">data</code>:上一次解决的承诺值，当新的错误到来时维护。</li><li id="dec8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">error</code>:拒绝承诺原因，新数据到达时清除。</li><li id="3997" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">isPending</code> / <code class="fe lv lw lx ly b">isLoading</code>:当承诺当前正在等待结算时为真。</li></ul><p id="7447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第15行放了一个<code class="fe lv lw lx ly b">console.log</code>语句。承诺兑现时显示<code class="fe lv lw lx ly b">‘Resolved’</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="751e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">中止useAsync调用</h1><p id="22cc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">useAsync</code>可接受。除了<code class="fe lv lw lx ly b">onResolve</code>之外，还有一个<code class="fe lv lw lx ly b">onCancel</code>选项:</p><ul class=""><li id="be8e" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">onCancel</code>:取消承诺时调用回调。</li></ul><p id="0d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个<code class="fe lv lw lx ly b">cancel</code>功能作为状态道具之一:</p><ul class=""><li id="e0f9" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">cancel</code>:通过忽略其结果来取消当前待定的承诺，并在<code class="fe lv lw lx ly b">AbortController</code>上调用<code class="fe lv lw lx ly b">abort()</code>。</li></ul><p id="1be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank">AbortController</a></code>是一个JavaScript对象，允许您在需要时中止一个或多个web请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，第18到20行取消了fetch调用。因此，第16行打印出<code class="fe lv lw lx ly b">‘Canceled’</code>。</p><p id="2846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe lv lw lx ly b">useAsync</code>内建的中止承诺的方式。中止也可以通过下面的promise函数实现:<code class="fe lv lw lx ly b">fetchManifest</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6行的第二个参数是<code class="fe lv lw lx ly b">AbortController</code>的一个实例。<code class="fe lv lw lx ly b">abortController.signal</code>是作为信号传入<code class="fe lv lw lx ly b">fetch</code>呼叫的。</p><p id="bdb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个<code class="fe lv lw lx ly b">console.log</code>呼叫。第7行，承诺没有流产。在第11行，承诺被第10行的调用中止。有趣的是，这种中止方式不会触发第20行的<code class="fe lv lw lx ly b">onCancel</code>打印出<code class="fe lv lw lx ly b">‘Canceled’</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6c21bc807449335569d7db9234471442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBZMvsm3upFVrXD2Qzy7wQ.png"/></div></div></figure><p id="20eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第9行添加了一个<code class="fe lv lw lx ly b">debugger</code>语句。如果没有暂停，两个<code class="fe lv lw lx ly b">AbortController</code>都显示abort为<code class="fe lv lw lx ly b">true</code>，因为从<code class="fe lv lw lx ly b">false</code>到<code class="fe lv lw lx ly b">true</code>的转换太快，以至于<code class="fe lv lw lx ly b">console.log</code>无法捕捉。</p><p id="f369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的屏幕截图显示了第29行的中止错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/aab9900eccbdb7a0c40d7c4bd73bc0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T180B70I_oZIu0ky6mOUdg.png"/></div></div></figure><p id="0ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多的时候，我们会看到promise函数是这样写的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不需要显式调用<code class="fe lv lw lx ly b">abort</code>。当再次调用promise函数时，或者当我们离开一个页面时，已有的promise会自动中止。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a4d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用提取挂钩</h1><p id="c533" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果使用<code class="fe lv lw lx ly b">fetch</code>获取数据，<code class="fe lv lw lx ly b">useFetch</code>钩子可以节省几行代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第7行到第10行调用<code class="fe lv lw lx ly b">useFecth</code>，用三个条目来解构状态:<code class="fe lv lw lx ly b">data</code>、<code class="fe lv lw lx ly b">error</code>和<code class="fe lv lw lx ly b">isPending</code>。</p><p id="1f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第15到19行使用这些项目来显示正确的UI。根据此调用是否处于挂起状态，此调用会导致错误，或者此调用会返回数据。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7860" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">IfPending、IfRejected和IfFulfilled</h1><p id="b13b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">React-async提供了几个助手组件，使JSX更具声明性，更简洁。</p><ul class=""><li id="41d5" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">IfPending</code>:仅在承诺待定时呈现。</li><li id="a257" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">IfRejected</code>:仅在承诺被拒绝时呈现。</li><li id="d65c" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">IfFulfilled</code>:仅在承诺兑现时才呈现。</li></ul><p id="7eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是这些组件助手的一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看第20行到第28行，对你来说看起来更清楚吗？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="13fc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">异步组件</h1><p id="d0db" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">组件和它的状态助手可以完成同样的事情。</p><ul class=""><li id="5fa9" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">Async.Pending</code>:仅在承诺待定时渲染。</li><li id="3d9b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">Async.Rejected</code>:仅在承诺被拒绝时呈现。</li><li id="9826" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">Async.Fulfilled</code>:仅在承诺兑现时渲染。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看第17到25行。你更喜欢<code class="fe lv lw lx ly b">&lt;Async&gt;</code>组件吗？这完全取决于你。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="19e0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="607f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">React-async即使在具有多个或嵌套数据依赖的大型应用程序中也能很好地工作。它鼓励在组件级按需并行加载数据，而不是在路由或页面级批量加载。</p><p id="f1a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它与路由完全分离，所以它在具有动态路由模型或根本不使用路由的复杂应用程序中工作得很好。</p><p id="3c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>