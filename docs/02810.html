<html>
<head>
<title>Fun With Twitter Parsing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Twitter解析的乐趣</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fun-with-twitter-parsing-2ab3b729d375?source=collection_archive---------17-----------------------#2020-01-02">https://betterprogramming.pub/fun-with-twitter-parsing-2ab3b729d375?source=collection_archive---------17-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bb6c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仅使用几行代码从Twitter账户中提取媒体信息</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/59d882f6171d21ab375e29faa7d5d31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y8rliN1J-ZhsHTx5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">莎拉·库菲在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="9e1d" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">介绍</h1><p id="7b8a" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">流行的社交媒体平台Twitter包含了丰富的信息。不仅来自个人推文的文本有助于挖掘社交信息，推文和转发中包含的图像和视频也可以让人们了解帐户处理通常在互联网上浏览或分享的内容。</p><p id="0298" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我有一个朋友让我给他一个脚本，可以下载任何账户的所有推文、图片和视频。他特别感兴趣的是获取账户负责人在他们的时间线上发布的图片和视频。由于Python是我最喜欢的语言，我决定编写一个小的实用程序脚本，从Twitter时间轴下载媒体文件。</p><p id="c014" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">就像Python一样，有一个生命、宇宙和一切事物的库。关于宇宙和一切，我都是在开玩笑。无论如何，在今天的文章中，我将向你展示，你可以用大约100行代码轻松地完成一些事情。我们将使用名为<a class="ae kv" href="https://www.tweepy.org/" rel="noopener ugc nofollow" target="_blank"> Tweepy </a>的精彩Python库。</p><p id="a636" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">首先，启动一个终端并安装以下软件(如果您还没有安装的话):</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="32b6" class="nb le iq mx b gy nc nd l ne nf">pip install tweepy</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="aaf3" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">从用户时间线获取推文</h1><p id="4e13" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">Twitter的API参考和文档可以在https://developer.twitter.com/en/docs/api-reference-index的<a class="ae kv" href="https://developer.twitter.com/en/docs/api-reference-index" rel="noopener ugc nofollow" target="_blank">找到。我们对用户时间线端点特别感兴趣。</a></p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e735" class="nb le iq mx b gy nc nd l ne nf">GET statuses/user_timeline</span></pre><p id="5b95" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">正如文档中提到的，这将返回由用户<em class="ng"> </em>发布的最新tweets的集合，由<code class="fe nh ni nj mx b">screen_name</code>或<code class="fe nh ni nj mx b">user_id</code>参数指示。</p><p id="148d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">仅当经认证的用户“拥有”时间线或者是拥有者的经批准的追随者时，才可以请求属于受保护用户的用户时间线。</p><p id="0c9d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">返回的时间线相当于用户在Twitter上的个人资料。</p><p id="6854" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这种方法最多只能返回3200条用户最近的推文。无论请求此资源时<code class="fe nh ni nj mx b">include_rts</code>是否设置为false，用户对其他状态的本地转发都包括在此总数中。</p><p id="e235" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">为了对这个API端点发出经过验证的请求，用户需要到<a class="ae kv" href="https://dev.twitter.com/apps/new" rel="noopener ugc nofollow" target="_blank">https://dev.twitter.com/apps/new</a>创建一个新的Twitter应用。</p><p id="557f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">创建完成后，您可以转到API Keys选项卡，在那里您将找到消费者密钥和消费者秘密条目。确保复制它们。创建一个名为. twitter.json <strong class="lx ir"> </strong>的文件，并将其放在您的主目录中。</p><p id="8569" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们首先需要确保我们的脚本可以使用这些密钥并创建一个经过身份验证的客户端。这可以通过以下方式完成:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="e0bd" class="nb le iq mx b gy nc nd l ne nf">from tweepy import OAuthHandler</span><span id="1239" class="nb le iq mx b gy nk nd l ne nf">auth = OAuthHandler(consumer_key, consumer_secret)<br/>api = tweepy.API(auth)</span></pre><p id="71fc" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">API对象将用于访问用户时间线。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e7f6" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">页码</h1><p id="2f73" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">Twitter的好人们在他们的API中加入了分页。如果你不知道什么是分页，它基本上是API如何用数据块来响应，而不是一次性发送整个响应。这可以防止大量数据通过网络发送。</p><p id="2a73" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">为了执行分页，我们必须为每个请求提供一个page/cursor参数。这里的问题是这需要大量的样板代码来管理分页循环。为了使分页更容易，需要的代码更少，Tweepy有了<code class="fe nh ni nj mx b">Cursor</code>对象。你像这样使用它:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="8cdc" class="nb le iq mx b gy nc nd l ne nf">for status tweepy.Cursor(api.user_timeline).items(num_items):<br/>    # process status here<br/>    process_status(status)</span></pre><p id="f9b2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果<code class="fe nh ni nj mx b">num_items</code>没有通过，默认情况下Twitter将返回超过3200条推文的光标。</p><p id="e9a5" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">太棒了。现在让我们在代码中使用<code class="fe nh ni nj mx b">Cursor</code>对象。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e240" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">获取图像和视频</h1><p id="dd94" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">我们有兴趣解析每条推文，检查它是否有任何图像和视频，然后下载这些工件。与tweet相关联的媒体对象存在于名为<code class="fe nh ni nj mx b">extended_entities</code>的嵌套属性中。</p><p id="2540" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">为了访问图片或视频的URL，我们首先检查推文中是否存在<code class="fe nh ni nj mx b">extended_entities</code>属性。如果是，那么我们迭代对应于<code class="fe nh ni nj mx b">extended_entities</code>对象中属性<code class="fe nh ni nj mx b">media</code> <strong class="lx ir"> </strong>的条目。我们检查每个媒体对象的类型是<code class="fe nh ni nj mx b">media_url</code>还是<code class="fe nh ni nj mx b">video</code>或<code class="fe nh ni nj mx b">animated_gif</code>，分别表示它是图像还是视频。我们将每个URL存储在单独的列表中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b698" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">方法<code class="fe nh ni nj mx b">process_tweet</code> <strong class="lx ir"> </strong>是我们定义提取图像和视频URL的逻辑的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9dc5" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在您有了两个列表，一个用于视频，一个用于图像，您可以很容易地使用Python <a class="ae kv" href="https://pypi.org/project/wget/" rel="noopener ugc nofollow" target="_blank"> wget库</a>将它们下载到磁盘。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e79a" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">使用多线程来并行化下载媒体URL的任务是很诱人的，因为这主要是磁盘I/O，CPU开销很小。</p><p id="c382" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">完整的代码可以在GitHub 上找到<a class="ae kv" href="https://github.com/sauravbiswasiupr/twitter-media-downloader" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>