<html>
<head>
<title>Why You Should Be Storing Remote Data in a Cache (and Not in State)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该将远程数据存储在缓存中(而不是在状态中)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-be-separating-your-server-cache-from-your-ui-state-1585a9ae8336?source=collection_archive---------2-----------------------#2019-11-28">https://betterprogramming.pub/why-you-should-be-separating-your-server-cache-from-your-ui-state-1585a9ae8336?source=collection_archive---------2-----------------------#2019-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="87d1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从大规模反应中得到的教训</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0c12e552a2ed377e3098a7c111856fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMUS-emArGLSIdupoF8seg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片:<a class="ae kv" href="https://unsplash.com/photos/rEGEeXPQ1FU" rel="noopener ugc nofollow" target="_blank">亚采克·斯莫特</a></p></figure><p id="c1ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React中处理远程数据的一个常见模式是在<code class="fe ls lt lu lv b">useEffect</code>中取数据，并将结果复制到组件状态中。大概是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="63cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe ls lt lu lv b">userData</code>需要从不同嵌套层次的其他组件中读取怎么办？</p><p id="1ea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们可能需要从应用程序中完全独立的区域读取用户权限。通过道具传递数据可能很快变得不可行。</p><p id="856a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个解决方案可能是使用像<a class="ae kv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> context </a>这样的全局状态库，或者像<a class="ae kv" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> MobX </a>或<a class="ae kv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>这样的状态管理库。这些都可以工作，但是它们引入了不必要的复杂性。</p><p id="8ffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使我们不需要跨其他组件重用数据，它仍然是冗长和混乱的。我们需要在获取数据的每个组件中重复这个样板文件。</p><p id="6374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要编写<code class="fe ls lt lu lv b">useEffect</code>,我们需要每次都保持异步进程的完全相同的状态。在一个更现实的场景中，我们的组件可能还混合了一些本地UI状态。</p><p id="fd89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">远程数据是只读的。它不属于与我们的UI状态相同的位置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lx l"/></div></figure><p id="8a5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过以下方式解决这些问题:</p><ol class=""><li id="6249" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">抽象出异步过程的样板文件(加载、错误等)。).</li><li id="40c6" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">将我们的远程数据存储在内存缓存中。</li></ol><p id="458d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前者可以用一个定制的钩子来解决，但是处理你自己的内存缓存是困难和费时的。</p><p id="362d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢天谢地，两个新的库解决了这两个问题:<a class="ae kv" href="https://github.com/zeit/swr" rel="noopener ugc nofollow" target="_blank"> swr </a>和<a class="ae kv" href="https://github.com/tannerlinsley/react-query" rel="noopener ugc nofollow" target="_blank"> react-query </a>。两个库都提供了定制的<a class="ae kv" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>来管理远程数据获取。</p><p id="60a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何使用swr来清理前面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5fb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">useSWR()</code>采用唯一标识符(键)和提取器函数来解析数据。</p><p id="d1c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe ls lt lu lv b">fetchUser</code>可以是任何异步函数。这意味着你可以将这些库与你已经在使用的任何数据获取API或库一起使用(<a class="ae kv" href="https://fetchsoftworks.com/" rel="noopener ugc nofollow" target="_blank"> Fetch </a>，<a class="ae kv" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>，<a class="ae kv" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>等)。).</p><p id="c467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一标识符用于缓存和重复数据消除请求。如果我们想从另一个组件访问相同的数据，我们可以用相同的键调用<code class="fe ls lt lu lv b">useSWR</code>, SWR将从缓存中检索它。</p><p id="c6bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个组件都引用相同的底层请求实例，我们不需要担心重复！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1c5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，在<code class="fe ls lt lu lv b">dedupingInterval</code>(react-query中的<code class="fe ls lt lu lv b">staleTime</code>)之后，请求的结果变得陈旧。这意味着，如果组件A发出请求，那么组件B在该时间间隔内使用相同的键发出请求，则从缓存中检索数据。</p><p id="8651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果请求是在该时间间隔之后发出的，将重新提取数据并重新验证缓存。swr使用两秒的默认时间间隔，react-query使用默认值零。</p><p id="f4b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个库都采用了过时但重新验证的缓存策略。这意味着，如果一个请求被标记为陈旧，那么先前缓存的数据将被返回，并进行重新验证。</p><p id="8f83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当新数据到达时，数据被更新以反映新的状态，并且引用该请求键的所有组件将被重新呈现。你可以在本文的<a class="ae kv" href="https://web.dev/stale-while-revalidate/" rel="noopener ugc nofollow" target="_blank">中阅读更多关于stale-while-revalidate的内容。</a></p><p id="692b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个库都很小(在撰写本文时小于4kb ),并且拥有优秀的文档。它们支持暂停、轮询、滚动恢复、失败重试、窗口焦点重新验证等等。</p><p id="5b5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">窗口焦点重新验证是一项提供最新UI的伟大技术。引用自swr文档的这段话说得很好:</p><blockquote class="mn"><p id="e478" class="mo mp iq bd mq mr ms mt mu mv mw lr dk translated">“组件将不断自动获得一系列数据更新。因此，用户界面将始终保持快速反应。”</p></blockquote><p id="2ad6" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">除了这些特性，我发现使用缓存解决方案的最大好处是它给我的代码库带来的简单性。</p><p id="fd72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">远程数据的获取和读取仍然位于我的组件中，我可以相信我总是在我的组件树中提供最新和同步的数据。</p><p id="cc39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个库之间只有很小的区别。决定在您的应用程序中使用哪一个可能取决于个人偏好。评估每种API，并决定哪种最适合您的应用。</p><p id="c21d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用它们之前，值得注意的是远程数据处理仍然是React社区中非常活跃的领域。</p><p id="ea83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于目前还不清楚React将来是否会提供一个缓存解决方案，我认为使用这两个库来填补空白没有什么坏处。随着稳定并发模式的到来，数据获取解决方案很可能会继续发展。</p><p id="8869" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:swr和react-query目前在其构建的输出中包含ES6特性，这意味着它们不能在IE11中工作。</p><p id="1275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不幸有支持IE11的责任，你将需要为ES5而奋斗。在我的例子中，我必须更新我的<a class="ae kv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>配置来包含swr:</p><pre class="kg kh ki kj gt nc lv nd ne aw nf bi"><span id="32f1" class="ng nh iq lv b gy ni nj l nk nl">// ...<br/><br/>  {<br/>    test: /\.(js|jsx|ts|tsx)$/,<br/>    include: [<br/>      resolve('src'),<br/>      resolve('node_modules/swr'),<br/>    ],<br/>    use: ['babel-loader'],<br/>  },</span></pre></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="409b" class="nt nh iq bd nu nv nw nx ny nz oa ob oc jw od jx oe jz of ka og kc oh kd oi oj bi translated"><strong class="ak">结论</strong></h1><p id="99a3" class="pw-post-body-paragraph kw kx iq ky b kz ok jr lb lc ol ju le lf om lh li lj on ll lm ln oo lp lq lr ij bi translated">将远程数据存储在组件状态中会导致冗长和样板文件过多的组件。触及全局状态存储增加了更多的复杂性，这是不值得的。</p><p id="4783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用像swr或react-query这样的数据获取解决方案将极大地简化您的代码并提高您的生产率。</p><p id="f4fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我对这些库感到非常兴奋，希望通过分享这种兴奋，你会发现这种技术在你自己的代码中很有用，感谢阅读！</p></div></div>    
</body>
</html>