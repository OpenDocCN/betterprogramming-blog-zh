<html>
<head>
<title>React Performance Optimisations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对性能优化做出反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-performance-optimisations-15b244cf3abb?source=collection_archive---------11-----------------------#2019-11-14">https://betterprogramming.pub/react-performance-optimisations-15b244cf3abb?source=collection_archive---------11-----------------------#2019-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c452" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用真实世界的例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5073d0e8d3af20b7c52f1b3799d928cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgH07xbQAo7ZCpK6xEpkaw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">布拉登·科拉姆在Unsplash<a class="ae kv" href="https://unsplash.com/s/photos/athlete?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="373d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用来自我们的web应用程序<a class="ae kv" href="https://www.focaldata.com/" rel="noopener ugc nofollow" target="_blank"> focaldata </a>的示例来浏览React中的一些性能优化。</p><p id="8bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在我们开始之前，重要的是要考虑什么时候是关注优化的合适时机。React非常快，与其防止重新渲染，不如将时间花在构建产品上。性能改进也增加了应用程序的复杂性，这可能会减慢其他开发人员处理代码的速度。用肯特·多兹的话说:</p><blockquote class="ls lt lu"><p id="152a" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">大多数时候，你不应该费心去优化不必要的重新呈现器。反应非常快，我可以想到很多事情让你用你的时间去做，这比优化这些事情要好。事实上，用useMemo和useCallback等功能]来优化东西的需求是如此之少，以至于在我从事PayPal产品工作的3年时间里，甚至在我从事React工作的更长时间里，我都不需要这样做。</p></blockquote><p id="5f3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的应用程序感觉很慢，您应该只考虑关注性能优化。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="fd3b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">什么是重渲染？</h1><p id="dfa2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当需要提高性能时，开发人员通常会致力于减少重新渲染。但这意味着什么呢？</p><p id="8c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新DOM分三步完成:</p><ul class=""><li id="9d70" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">渲染阶段是React创建元素的时候。<code class="fe nm nn no np b">React.createElement</code>。</li><li id="c3e3" class="nd ne iq ky b kz nq lc nr lf ns lj nt ln nu lr ni nj nk nl bi translated">协调阶段是React比较以前的元素和新的元素的阶段。</li><li id="096c" class="nd ne iq ky b kz nq lc nr lf ns lj nt ln nu lr ni nj nk nl bi translated">DOM更新的提交阶段(如果需要的话)。</li></ul><p id="4438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">呈现和协调阶段非常快，但是提交阶段通常是DOM更新中最慢的部分。</p><p id="baae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与其专注于防止闪电般的渲染(如果在协调阶段没有差异，甚至可能不会更新DOM)，通常最好的方法是隔离缓慢的提交并解决它们。</p><p id="ada4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们正在进行性能优化，我们应该知道应用程序中目前慢的是什么。例如，这可能意味着点击一个按钮或输入一个输入。我们可以使用React Profiler工具调查哪些提交速度慢——只需下载React dev工具，检查页面并单击Profiler。</p><p id="25bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有两个我们在<a class="ae kv" href="https://www.focaldata.com/" rel="noopener ugc nofollow" target="_blank"> focaldata </a>发现的性能改进的例子。值得记住的是，React在生产中更新DOM的速度要比在开发中快得多。以下示例正在开发中。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="0248" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用React探查器识别慢速提交</h1><p id="333b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在我们的内部应用程序中，我们有一个调查列表。当用户点击调查时，加载下一页会有一点延迟。使用React Profiler，我们可以单击record，选择一个调查，停止记录，然后检查提交。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/65ee1e271b803807fc04d1ff3a31a7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnrAJjk7CWXf-eULyUhK_w.png"/></div></div></figure><p id="e3d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在图中看到的，一个组件<code class="fe nm nn no np b">Select</code>需要123 ms来提交，比所有其他组件都要长得多。我们可以在截图右上角的小图中看到，条形图中有四个高的黄色条。在其中的每一个中，<code class="fe nm nn no np b">Select</code>是最昂贵的组件(即花费了最长的时间来加载),总共花费了超过400 ms来加载。</p><p id="482e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">WindowedSelect</code>是另一种昂贵的成分。在代码库中搜索后，我发现这是一个0.0.3-alpha版本的npm包，使用了<code class="fe nm nn no np b">Select</code>。</p><p id="820b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将软件包升级到版本2.0.1，并再次运行profiler。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/afe3c91c1b4a9fe1ca05b11a4d2801e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5lpn4-PxSsT3OnrFn-Rcw.png"/></div></div></figure><p id="0eea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">Select</code>组件现在只需要2.5毫秒加载。现在最昂贵的组件是<code class="fe nm nn no np b">withStyles(Chip)</code>，它需要8.2毫秒——大大少于<code class="fe nm nn no np b">Select</code>的123毫秒加载时间。这是一个显著的性能提升，而无需编写任何代码！</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="3129" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用useMemo解决不必要的重新渲染</h1><p id="e494" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们在应用程序的几个部分向用户显示一个可重用的表格组件。虽然渲染速度相对较快，但加载时会有一点延迟，尤其是在显示属于某个用户的所有文件的部分。</p><p id="c428" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用React <code class="fe nm nn no np b">Profiler</code>，我记录了登陆页面，点击上传文件按钮的过程。<code class="fe nm nn no np b">Profiler</code>显示表组件花了38毫秒提交。</p><p id="4160" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">表格组件映射数据以创建表格行，然后映射每一行以创建单独的单元格。这意味着它的性能是<code class="fe nm nn no np b">O(n^2)</code>。如果它在许多文件中循环，提交必然会很慢。</p><p id="1d60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然该表需要遍历大量数据，但我们可以检查它是否被不必要地重新呈现。为了更好地理解渲染过程，我们可以使用<code class="fe nm nn no np b"><a class="ae kv" href="https://www.npmjs.com/package/@welldone-software/why-did-you-render" rel="noopener ugc nofollow" target="_blank">WhyDidYouRender</a></code> npm包并用<code class="fe nm nn no np b">useRef</code>跟踪渲染。在<code class="fe nm nn no np b">Table</code>组件中，我们添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制台日志显示表格组件呈现了四次——三次是不必要的。更新状态、父组件渲染或属性更改会触发重新渲染。<code class="fe nm nn no np b">WhyDidYouRender</code>包声明<code class="fe nm nn no np b">Table</code>正在被重新渲染，因为道具在变化——但是输入是一样的，那么为什么它要被重新渲染呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="472e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是，在JavaScript中，整数、字符串和布尔值具有引用相等性:</p><pre class="kg kh ki kj gt nz np oa ob aw oc bi"><span id="2a39" class="od mh iq np b gy oe of l og oh">true === true // true<br/>false === false // true<br/>1 === 1 // true<br/>'a' === 'a' // true</span></pre><p id="6da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，对象、数组(JavaScript中的对象)和函数指向内存中的一个空间，而<em class="lv">没有</em>的引用相等性:</p><pre class="kg kh ki kj gt nz np oa ob aw oc bi"><span id="dbef" class="od mh iq np b gy oe of l og oh">{} === {} // false<br/>[] === [] // false<br/>() =&gt; {} === () =&gt; {} // false</span></pre><p id="e7e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">Table</code>组件正在重新呈现，因为我们将列和数据作为数组/对象的道具传入。这就是为什么即使列和数据的值保持不变，props在技术上也会发生变化。</p><p id="505f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决不必要的重新渲染，我们可以记忆表组件，即在缓存中存储数据。内存化用于解决引用相等的问题，并缓存计算量大的函数。</p><p id="3428" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React中，我们有几个可用的记忆选项。<code class="fe nm nn no np b">useCallback</code>会缓存一个回调函数。当我们将函数作为没有引用相等性的道具传递时，这是很有帮助的。使用<code class="fe nm nn no np b">useMemo</code>，我们可以记忆值，这样它们就不需要重新计算，或者我们可以将组件包装在<code class="fe nm nn no np b">React.memo()</code>中，这类似于纯组件。</p><p id="40c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们想要记忆一个值:带有映射数据的<code class="fe nm nn no np b">Table</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="75f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将逻辑提取到一个单独的组件中并用<code class="fe nm nn no np b">useMemo</code>调用它，表格组件仅在<code class="fe nm nn no np b">data</code>更新时创建。</p><p id="60f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在<code class="fe nm nn no np b">Files</code>组件中包含<code class="fe nm nn no np b">CreateTableData</code>函数，但是该函数仍然会在每次渲染时创建。在JavaScript中创建函数是很昂贵的，所以最好把它提取出来，只在需要的时候创建。</p><p id="44c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经节省了三次不必要的大约38毫秒的重新渲染，节省了超过100毫秒的加载速度。然而，<code class="fe nm nn no np b">useMemo</code>确实增加了代码的复杂性。在实现性能改进之前，考虑速度与代码复杂性之间的权衡总是很重要的。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="599b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">进一步阅读</h1><ul class=""><li id="7dc0" class="nd ne iq ky b kz my lc mz lf oi lj oj ln ok lr ni nj nk nl bi translated"><a class="ae kv" href="https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render" rel="noopener ugc nofollow" target="_blank">在修复重新渲染之前修复缓慢的渲染</a>，肯特·C·多兹https://kentcdodds . com/blog/Fix-the-Slow-Render-Before-You-Fix-the-Re-Render</li><li id="0ee7" class="nd ne iq ky b kz nq lc nr lf ns lj nt ln nu lr ni nj nk nl bi translated"><a class="ae kv" href="https://kentcdodds.com/blog/usememo-and-usecallback" rel="noopener ugc nofollow" target="_blank">使用备忘录和使用回调</a>，肯特·C·多兹</li><li id="02fe" class="nd ne iq ky b kz nq lc nr lf ns lj nt ln nu lr ni nj nk nl bi translated"><a class="ae kv" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">优化性能</a>，reactjs.org</li><li id="9a95" class="nd ne iq ky b kz nq lc nr lf ns lj nt ln nu lr ni nj nk nl bi translated"><a class="ae kv" href="https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction" rel="noopener ugc nofollow" target="_blank">错误的抽象</a>，桑迪·梅斯</li><li id="2dce" class="nd ne iq ky b kz nq lc nr lf ns lj nt ln nu lr ni nj nk nl bi translated"><a class="ae kv" href="https://dev.to/devcord/react-hooks-useeffect-usecallback-usememo-3o42" rel="noopener ugc nofollow" target="_blank"> React钩子:UseEffect，UseCallback，UseMemo </a>，Devcord</li><li id="9936" class="nd ne iq ky b kz nq lc nr lf ns lj nt ln nu lr ni nj nk nl bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=00RoZflFE34" rel="noopener ugc nofollow" target="_blank">如何使用React Profiler发现并修复性能问题</a> (YouTube)，Ben Awad</li></ul></div></div>    
</body>
</html>