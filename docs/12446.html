<html>
<head>
<title>How to Ensure React is Not Destroying Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何确保React不会损坏组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-ensure-that-react-is-not-destroying-components-db52a653eadf?source=collection_archive---------18-----------------------#2022-06-06">https://betterprogramming.pub/how-to-ensure-that-react-is-not-destroying-components-db52a653eadf?source=collection_archive---------18-----------------------#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="729b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一旦我们知道哪些组件有问题，修复问题就容易多了。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d42f062286bfd8c829a27eff53162c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i3Hsvim72Ull1OXW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@error420?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">错误420📷</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="0486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们来说，确保React不会在组件没有改变时重新呈现它们是很常见的。我们是否知道如何识别React何时完全销毁实例，并在每次渲染时从头重新安装实例？</p><p id="619a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我调试我正在使用的最新的基于React的文本编辑器时，我需要识别每个渲染上卸载和安装的React组件。我所经历的具体行为是，当在要编辑的段落之间切换时，我的编辑器需要第二次点击。第一次点击启动了onBlur，但是它没有关注下一个要编辑的段落。</p><h1 id="49e5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">修复错误的问题</h1><p id="5d76" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">起初，我认为这是一个性能问题，并开始使用浏览器的性能选项卡来分析这些操作。<code class="fe ms mt mu mv b">onBlur</code>事件保存了内容并重新解析了文本，对于一个大文件来说需要&gt;1000毫秒。</p><p id="fc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们花了几天时间来优化它的性能和我们管理的一些依赖项，并将其缩减到不到500毫秒。这应该没问题，但是这种行为仍然持续在只需要50毫秒的小文件上。为此做了很多工作。至少现在这款应用的响应速度更快了，没有浪费时间。</p><p id="b090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复bug的第二次尝试是尝试React 18的新功能<code class="fe ms mt mu mv b">startTransition</code>。这允许我们包装一个代码块，并将其指定为当前渲染不必要的。</p><p id="3727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来很适合我的场景，因为在上游保存之前，组件应该已经应用了适当的编辑。成功了！嗯，算是吧。它允许点击聚焦在新的段落上，但是一旦延迟的渲染发生就退出。它在重新渲染之前将大约500毫秒分割为大约200毫秒，在焦点丢失之后和之前分割为大约300毫秒。回到制图板！</p><p id="2eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从前面的步骤中学到的是，无论组件渲染得多快，我仍然会失去焦点。这不是性能问题。我怀疑这些部件被销毁了，没有被重新使用。我开始研究，发现了很多减少重渲染的技巧，以及其他关于何时以及如何在组件上使用key属性的技巧。没有一个管用。</p><h1 id="e5f9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">识别真正的问题</h1><p id="ed9b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我需要想出一种方法来查看哪些组件被卸载，然后在不应该卸载的时候被装载。</p><p id="b617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">useEffect()</code>来救援了！当我们有一个带有空依赖数组的<code class="fe ms mt mu mv b">useEffect</code>时，我们确保它只在第一次渲染时运行。</p><p id="557c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加一个带有消息的<code class="fe ms mt mu mv b">console.log()</code>，告诉你这是第一次渲染。如果我们在意想不到的时候看到了那条信息，那么维奥拉！我们知道在当前渲染过程中它会破坏我们现有的组件。</p><p id="4bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确定卸载事件何时被触发，我们在返回块的<code class="fe ms mt mu mv b">useEffect</code>中添加了第二个<code class="fe ms mt mu mv b">console.log()</code>。<code class="fe ms mt mu mv b">useEffect</code>中的返回块是卸载时要清理的代码。这些日志一起向我们显示了卸载和装载发生的时间。</p><p id="7c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将此添加到我怀疑的每个组件，我能够确认哪些组件被破坏和重新创建。我现在可以确切地知道我的更改何时正确地导致了组件被重用。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e48c" class="na lw it mv b gy nb nc l nd ne">useEffect(() =&gt; {<br/> if (verbose) console.log(‘ComponentName: Mount/First Render’);<br/> return (() =&gt; {<br/>   if (verbose) console.log(‘ComponentName Unmount/Destroyed’);<br/> });<br/> // eslint-disable-next-line react-hooks/exhaustive-deps<br/>}, []);</span></pre><p id="ebdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许有其他方法可以做到这一点，但这对我解决一个令人沮丧的错误真的很有帮助！</p><p id="dc9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化将它添加到更多组件的过程，以确保只在需要时才进行渲染，我创建了一个自定义钩子，其中只包含上面的代码。为组件名和详细标志传递了两个属性。这样，我可以只在调试时打开日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/efef57cf8c7997f4774e89eb460c11ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3MTFcENFIaFI54g2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·托马索在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="0aff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">修复我的bug</h1><p id="4e4a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，对我的编辑器的焦点错误的修复是一个单行的修改。在我的一些组件中，我在渲染道具中传递的组件。更具体地说，我用props提供的组件覆盖了一些默认组件。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e05c" class="na lw it mv b gy nb nc l nd ne">const components = {<br/>  ...DEFAULT_PROPS.components,<br/>  ...props.components,<br/>};</span></pre><p id="cee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的第一次尝试是用来自<code class="fe ms mt mu mv b">use-deep-compare</code>库的<code class="fe ms mt mu mv b">useDeepCompareMemo()</code>来包装它，该库提供了React的<code class="fe ms mt mu mv b">useEffect</code>、<code class="fe ms mt mu mv b">useCallback</code>、<code class="fe ms mt mu mv b">useMemo</code>版本，允许对依赖关系中的对象和数组进行深度比较。</p><p id="e375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，无论我如何记忆作为道具传入的组件，都不能解决问题。它还在不该打印的时候打印信息。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3b3e" class="na lw it mv b gy nb nc l nd ne">const components = useDeepCompareMemo(() =&gt; (<br/>  { ...DEFAULT_PROPS.components, ...props.components }<br/>), [props.components]); <br/><em class="ng">// props.components appeared to still be new each time</em></span></pre><p id="bb96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并组件和使用props提供的组件的逻辑导致父组件认为自定义组件功能在每次渲染中都是新的。我希望他们永远不会改变。为了解决这个问题，我简单地用一个空的依赖数组<code class="fe ms mt mu mv b">useMemo()</code>包装了这个定义，以确保它们只在第一次渲染时被定义。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a11c" class="na lw it mv b gy nb nc l nd ne">const components = useMemo(() =&gt; (<br/>  { ...DEFAULT_PROPS.components, ...props.components }<br/>), []); <br/><em class="ng">// if non-empty dependencies, components render from scratch each time</em></span></pre><p id="c3a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我在包装合并的<code class="fe ms mt mu mv b">useMemo()</code>中使用了一个空的依赖数组，我的控制台没有日志。不再需要从零开始破坏和重建组件。多么美丽的景色啊！</p><p id="a659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最棒的是，最大限度地减少每次渲染时的卸载和装载，使得我们已经针对大文件优化的&lt; 500毫秒的渲染减少到了～250毫秒！</p><p id="36df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调查过程中，我还发现了一些我试图用来记忆JSX街区的方法，而这些并不是必须的。我删除了这些，只在组件的返回块中呈现了JSX。</p><p id="a8fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我意识到React可以在没有我的帮助下很好地管理何时重新渲染这些块。现在这是可能的，因为我确定这个改变不会导致额外的渲染。</p><h1 id="2ca4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="df6e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">花几天时间修复一个bug可能会令人沮丧，而解决方案只是一个小小的改变。我们可以花很多时间优化代码，这些代码产生了名义上的影响，但没有解决根本问题。</p><p id="1604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每次渲染时，能够识别React何时从零开始破坏和重新创建组件实例是至关重要的。</p><p id="bec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现有帮助的简单方法是利用React的<code class="fe ms mt mu mv b">useEffect()</code>和一个空的dependencies数组，当mount和unmount事件发生时打印几行<code class="fe ms mt mu mv b">console.log()</code>。一旦我们知道哪些组件有问题，修复问题就容易多了。</p></div></div>    
</body>
</html>