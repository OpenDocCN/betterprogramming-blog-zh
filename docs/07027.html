<html>
<head>
<title>5 Auto Layout Approaches in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的5种自动布局方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-auto-layout-approaches-at-swift-b229cf396ee2?source=collection_archive---------6-----------------------#2020-11-30">https://betterprogramming.pub/5-auto-layout-approaches-at-swift-b229cf396ee2?source=collection_archive---------6-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f813" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NSLayoutConstraint、可视化格式语言等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01acf65392d948af67a1ea4f52cf8160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iiSx9J5pNUl_VY78"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cravethebenefits?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Brenda Godinez </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="6437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个自适应的UI来适当地响应屏幕大小和设备方向的变化，我们使用了自动布局，这是一个基于约束的布局系统。本文概述了以编程方式添加约束的五种不同方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a2a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么是自动布局？</h1><p id="d396" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果不使用自动布局，添加到视图中的子视图的位置是固定的。如果我们将具有红色背景的子视图添加到iPhone 11的中心，则中心X在点207处被硬编码，而中心Y在点448处被硬编码，因为iPhone 11的屏幕由水平414个点(或828个像素)和垂直896个点(或1792个像素)组成。</p><p id="6678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用iPhone SE、8、12和iPad pro模拟器运行它时，您将得到子视图不居中的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/ae20909fda6d237b06866bfc6d53566e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQUfWGoxG4GANVcaKruujw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有自动布局的不同设备—作者提供的照片</p></figure><p id="1f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iPhone 11上旋转时，子视图会超出屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/52de29c1b470f24ddb83a9b7f27916a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibTzYosEBHnLLdroYXMWjQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6fd5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.使用<code class="fe nb nc nd ne b">NSLayoutConstraint</code>自动布局</h1><p id="4100" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nb nc nd ne b">NSLayoutConstraint</code>使用以下格式的线性方程定义两个用户界面对象之间的关系:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="fdb3" class="nj md it ne b gy nk nl l nm nn">item1.attribute1 = multiplier × item2.attribute2 + constant</span></pre><ul class=""><li id="e96f" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nb nc nd ne b">attribute1</code>和<code class="fe nb nc nd ne b">attribute2</code>是自动布局在解决这些约束时可以调整的变量。例如:<code class="fe nb nc nd ne b">left</code>、<code class="fe nb nc nd ne b">right</code>、<code class="fe nb nc nd ne b">top</code>、<code class="fe nb nc nd ne b">bottom</code>、<code class="fe nb nc nd ne b">leading</code>、<code class="fe nb nc nd ne b">trailing</code>、<code class="fe nb nc nd ne b">width</code>、<code class="fe nb nc nd ne b">height</code>、<code class="fe nb nc nd ne b">centerX</code>、<code class="fe nb nc nd ne b">centerY</code>、<code class="fe nb nc nd ne b">lastBaseLine</code>等。</li><li id="f7f3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe nb nc nd ne b">multiplier</code>和<code class="fe nb nc nd ne b">constant</code>定义了两个属性的相对位置。</li></ul><p id="2250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于示例子视图，我们使用以下代码添加自动布局:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><ul class=""><li id="b0a8" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nb nc nd ne b">translatesAutoresizingMaskIntoConstraints</code>被设置为<code class="fe nb nc nd ne b">false</code>以忽略由视图的自动调整大小遮罩指定的行为。它还忽略了使用<code class="fe nb nc nd ne b">frame</code>、<code class="fe nb nc nd ne b">bounds</code>和<code class="fe nb nc nd ne b">center</code>属性对视图大小和位置的修改。</li><li id="fa2d" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">该代码通过指定属性的相对位置来创建宽度、高度、中心x和中心y约束。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/30d6b3017ed8aa2159fcc733191fc4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6vnURXWyx8y8mKynJp5UA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nb nc nd ne b">NSLayoutConstraint Auto Layout</code></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b317" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.利用可视化格式语言实现自动布局</h1><p id="11a7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大多数在真实用户界面中有用的约束都可以用自动布局可视化格式语言来表达。可视格式字符串语法可在<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" rel="noopener ugc nofollow" target="_blank">自动布局指南</a>中找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><ul class=""><li id="f2b4" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nb nc nd ne b">views</code>定义层次结构中每个视图的键值对。</li><li id="0d54" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">我们使用<code class="fe nb nc nd ne b">metrics</code>来动态计算子视图的<code class="fe nb nc nd ne b">width</code>。</li><li id="73a0" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe nb nc nd ne b">H</code>指定水平约束，<code class="fe nb nc nd ne b">V</code>指定垂直约束。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/9c4a8c20085acc187a90a79cf32743a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byU8Vk_IPCuKYOjMkmAtNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">视觉格式语言</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f36" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用<code class="fe nb nc nd ne b">AutoresizingMask</code>自动布局</h1><blockquote class="of og oh"><p id="2955" class="kz la oi lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">AutoresizingMask</code>确定当其超级视图的边界改变时，接收控件如何调整自身的大小。当视图的边界改变时，该视图根据每个子视图的自动调整大小掩码自动调整其子视图的大小。通过使用C位OR运算符组合<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiview/autoresizingmask" rel="noopener ugc nofollow" target="_blank">UIView.AutoresizingMask</a></code>中描述的常量来指定该掩码的值。结合这些常量，您可以指定视图的哪些维度应该相对于超级视图增长或收缩。根据<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiview/1622559-autoresizingmask?changes=_4" rel="noopener ugc nofollow" target="_blank">苹果的开发者文档</a>。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nb nc nd ne b">AutoresizingMask</code></p></figure><ul class=""><li id="0e2d" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">要使用<code class="fe nb nc nd ne b">AutoresizingMask</code>，将<code class="fe nb nc nd ne b">translatesAutoresizingMaskIntoConstraints</code>设置为<code class="fe nb nc nd ne b">true</code>很重要。</li><li id="3b7a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">我们指定<code class="fe nb nc nd ne b">subView</code>边界，并将其置于<code class="fe nb nc nd ne b">superView</code>的中心。</li><li id="bb8a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">我们在顶部、左侧、右侧和底部给它灵活的边距，以保持<code class="fe nb nc nd ne b">subView</code>的大小和居中。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/1c67a58d2d03247ad42629fa90eda2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*tn9UHTTal54zbuHAWu2QWQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nb nc nd ne b">AutoresizingMask</code></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98cc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.使用<code class="fe nb nc nd ne b">NSLayoutAnchor</code>自动布局</h1><blockquote class="of og oh"><p id="c308" class="kz la oi lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">NSLayoutAnchor</code>从一个视图对象开始构建约束，并选择该对象的一个锚点属性。这些属性对应于自动布局中使用的主<code class="fe nb nc nd ne b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute" rel="noopener ugc nofollow" target="_blank">NSLayoutConstraint.Attribute</a></code>值，并提供了一个合适的<code class="fe nb nc nd ne b">NSLayoutAnchor</code>子类，用于为该属性创建约束。根据<a class="ae ky" href="https://developer.apple.com/documentation/uikit/nslayoutanchor" rel="noopener ugc nofollow" target="_blank">苹果的开发者文档</a>。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AddNSLayoutAnchor</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/3936b1b708ecffaadbb004d5fd3007be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSVaOiQ7ydhsTiIsDFiSkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AddNSLayoutAnchor</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ada" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.使用<code class="fe nb nc nd ne b">intrinsicContentSize</code>自动布局</h1><p id="4db8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nb nc nd ne b">intrinsicContentSize</code>是<code class="fe nb nc nd ne b">UIView</code>的独享属性。</p><blockquote class="of og oh"><p id="011c" class="kz la oi lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">它允许自定义视图根据其内容向布局系统传达想要的大小。这种固有的大小必须独立于内容框架，因为没有办法根据变化的高度将变化的宽度动态地传递给布局系统。使用<code class="fe nb nc nd ne b">intrinsicContentSize</code>的唯一方法是子类化<code class="fe nb nc nd ne b">UIView</code>。根据<a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize" rel="noopener ugc nofollow" target="_blank">苹果的开发者文档</a>。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nb nc nd ne b">intrinsicContentSize</code></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/3936b1b708ecffaadbb004d5fd3007be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSVaOiQ7ydhsTiIsDFiSkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nb nc nd ne b">Using intrinsicContentSize</code></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d8e1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="2161" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文描述了在Swift中实现自动布局的五种不同方法。上面提到的代码可以在这个<a class="ae ky" href="https://gist.github.com/ericleiyang/c4fbfdb6c7ba827cc9b7b3abe3d47929" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p><p id="878e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我很想听听你们的想法，回答你们可能有的任何问题！</p></div></div>    
</body>
</html>