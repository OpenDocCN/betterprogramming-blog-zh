<html>
<head>
<title>Provider Pattern in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写中的提供者模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/provider-pattern-in-jetpack-compose-bb4f4e27185e?source=collection_archive---------10-----------------------#2022-09-12">https://betterprogramming.pub/provider-pattern-in-jetpack-compose-bb4f4e27185e?source=collection_archive---------10-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="935c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用<code class="fe kf kg kh ki b">CompositionLocalProvider</code>，将提供者模式引入Jetpack Compose领域</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/fc5eb8c16ae436b4075873533f174b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LFWF0hNTSu1qhH_h"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@3dparadise?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Braňo </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="723c" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">介绍</h1><p id="c533" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">自从模式转向将Jetpack Compose作为一个可靠的UI框架以来，现代Android应用程序的开发已经飞速发展。新的声明式和直观的UI框架正在帮助Android应用程序快速构建，并提高了性能。</p><p id="c861" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">Jetpack Compose实际上有一个树状结构(例如，与Flutter中看到的一样)，其中我们指定所有要呈现的节点，并基于所提供的属性，在屏幕上绘制元素。</p><p id="857f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们知道，属性或状态在树上向下传递到最后一个节点，生成的事件向上传播以便处理。这种模式有时会变得很乏味，必须传递某个实体，该实体只在较高的节点产生，沿着树向下传递到目标节点。</p><p id="c9ea" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在本文中，我们将讨论这个问题，以及Jetpack Compose如何提供一个优雅的解决方案。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="e80e" class="la lb iq bd lc ld na lf lg lh nb lj lk jw nc jx lm jz nd ka lo kc ne kd lq lr bi translated">先决条件</h1><p id="9a28" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们在这里提到了Jetpack Compose的一个高级概念，以及一些“使用Hilt的依赖注入”概念。在阅读这篇文章的时候，最好有关于这些的基本知识。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="9cf7" class="la lb iq bd lc ld na lf lg lh nb lj lk jw nc jx lm jz nd ka lo kc ne kd lq lr bi translated">理论</h1><p id="3486" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">将下面的用例视为一个组合UI树:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nf"><img src="../Images/0f19388b218316d05de7252e799d0830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61cSNu7DEGthRjskXI3MLw.png"/></div></div></figure><p id="fc45" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">根节点产生一个实体A，它在第4级子节点(子节点4)上被消费。a不是单例的，因为它的实例不能从根节点之外的任何地方创建，所以创建的实例必须沿着树向下传递到子节点4。在这种情况下，子节点1到3不必要地持有A的实例，这对这些节点没有用。我们想以某种方式直接从子4访问A:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/b582ffae7528d11cc979e9fb3bb5e9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpXJofBAmR25aUCwzt3Bcw.png"/></div></div></figure><p id="8696" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在Flutter中，这个问题可以通过使用Provider模式来解决，在这种模式下，可以在树中全局提供项目，然后可以从任何地方访问它。我们将看到如何在Jetpack Compose中实现这一点。</p><h1 id="a715" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">输入“CompositionLocalProvider”</h1><p id="e91e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated"><code class="fe kf kg kh ki b">CompositionLocalProvider</code>可以提供对树中较高层的某个对象的引用，任何子代都可以直接访问提供的值。</p><p id="f568" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这在内部使用了一个<code class="fe kf kg kh ki b">CompositionLocal</code>，它的作用域是一个子树。如果我们将它放在UI树的根级别，它将覆盖下面的整个树，从而表现为一个全局提供者。</p><h1 id="e88a" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">说暗号，伙计！</h1><h2 id="f182" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">用例</h2><p id="9db8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们在这里讨论的典型用例是，通过点击按钮，记录来自可组合函数的Firebase分析事件..</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9e27" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们已经创建了一个由Hilt辅助的<code class="fe kf kg kh ki b">AnalyticsManager</code>类，作为在应用程序中记录各种分析事件的抽象。在<code class="fe kf kg kh ki b">ViewModel </code>类中，这可以直接注入，但是当涉及到可组合函数时，我们不能在函数参数中直接注入这个类的实例。</p><h2 id="9f0c" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">声明组合本地</h2><p id="bca0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在按钮点击直接调用任何分析事件的记录的情况下(也就是说，不传递这个事件给<code class="fe kf kg kh ki b">ViewModel</code>来处理)，我们需要提供一个<code class="fe kf kg kh ki b">AnalyticsManager</code>的实例。现在，不要将这个实例在树中向下传递给有这样一个按钮的可组合组件，让我们看看如何使用一个<code class="fe kf kg kh ki b">CompositionLocalProvider</code>来提供所需的实例:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cbc0" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在全局(静态)级别，我们为我们的<code class="fe kf kg kh ki b">AnalyticsManager</code>类声明了一个<code class="fe kf kg kh ki b">CompositionLocal</code>创建者，命名为<code class="fe kf kg kh ki b">LocalAnalytics</code>。这是通过使用<code class="fe kf kg kh ki b">staticCompositionLocalOf&lt;T&gt;</code>函数声明一个<code class="fe kf kg kh ki b">StaticProvidableCompositionLocal</code>并提供一个默认初始值来实现的。这将创建一个<code class="fe kf kg kh ki b">CompositionLocal</code>的静态实例，然后可以提供给UI树的相关部分。</p><blockquote class="nv nw nx"><p id="7425" class="ls lt ny lu b lv mo jr lx ly mp ju ma nz mq md me oa mr mh mi ob ms ml mm mn ij bi translated"><em class="iq"> ℹ️ </em>请注意，因为我们不能为我们的柄辅助<code class="fe kf kg kh ki b">AnalyticsManager</code>类提供默认值，所以我们将它设置为空。在这种情况下，可以解决这个问题，因为我们稍后将设置一个适当的非空值。但是最好提供一个非空的缺省初始值。</p><p id="9037" class="ls lt ny lu b lv mo jr lx ly mp ju ma nz mq md me oa mr mh mi ob ms ml mm mn ij bi translated"><em class="iq"> ℹ️ </em>我们可以用另一个函数<code class="fe kf kg kh ki b">compositionLocalOf&lt;T&gt;</code>代替<code class="fe kf kg kh ki b">staticCompositionLocalOf&lt;T&gt;</code>。它们的不同之处在于树是如何根据所提供的值的变化而重新呈现的。在<a class="ae kz" href="https://developer.android.com/jetpack/compose/compositionlocal#creating-apis" rel="noopener ugc nofollow" target="_blank">官方Android文档中阅读更多相关信息</a>。</p></blockquote><h2 id="4157" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">为组合本地提供价值</h2><p id="f576" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们的代码中有一个主要的<code class="fe kf kg kh ki b">ComponentActivity</code>,它管理可组合的函数，处理导航等等，在这里我们可以注入<code class="fe kf kg kh ki b">AnalyticsManager</code>类的初始实例，然后可以提供它..</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="aa33" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们已经使用了<code class="fe kf kg kh ki b">CompositionLocalProvider</code>来提供我们注入的<code class="fe kf kg kh ki b">AnalyticsManager</code>类的实例。该实例将替换初始的“null”值，并将提供一个有效值。请注意，我们在声明UI树之前已经声明了它，因此所提供的实例对于整个应用程序都是可用的。在这种情况下，我们使用了<code class="fe kf kg kh ki b">provides</code>功能；我们可以添加更多这样的条款，以在全球范围内提供多个实体！</p><h2 id="1cbf" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">提供商的消费者</h2><p id="6cdd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在消费者端，我们可以将提供的价值用作:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="68b2" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe kf kg kh ki b">LocalAnalytics</code>是一个静态声明的属性，我们可以通过使用<code class="fe kf kg kh ki b">LocalAnalytics.current</code>来访问它的最新实例。由于我们已经将<code class="fe kf kg kh ki b">AnalyticsManager</code>声明为可空，所以我们有一个空安全的访问，但是这并不是对所有情况都是正确的。请注意，我们没有向下传递任何参数，它都是全局提供的！</p><h2 id="f695" class="nh lb iq bd lc ni nj dn lg nk nl dp lk mb nm nn lm mf no np lo mj nq nr lq ns bi translated">如果我们需要改变提供的值呢？</h2><p id="c9bb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">因为我们在UI树的根级别声明了我们的<code class="fe kf kg kh ki b">CompositionLocalProvider</code>,所以整个树获得了提供的实例。但是我们可以通过在新的<code class="fe kf kg kh ki b">CompositionLocalProvider</code>下包装一个子树来改变这个值。这样，下面的子树将使用最新的值，而先前的值将被覆盖。这只适用于被包装的子树；其余的其他节点将继续获取在根级别提供的值:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oc"><img src="../Images/a5e05d4dea3377e8a4a75e90aaa07748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZ4yO4SRAbZ_yS_0m391OA.png"/></div></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="dc08" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">使用<code class="fe kf kg kh ki b">CompositionLocalProvider</code>，我们将提供者模式引入了Jetpack Compose领域。关于任何特殊功能或模块的深入细节，您可以随时查看<a class="ae kz" href="https://developer.android.com/jetpack/compose/compositionlocal" rel="noopener ugc nofollow" target="_blank">官方组合本地文档</a>。</p></div></div>    
</body>
</html>