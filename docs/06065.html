<html>
<head>
<title>Webpack Essentials — Updated for 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">web pack Essentials—2020年更新</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/webpack-essentials-updated-for-2020-4a0aa019ca3?source=collection_archive---------4-----------------------#2020-08-31">https://betterprogramming.pub/webpack-essentials-updated-for-2020-4a0aa019ca3?source=collection_archive---------4-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">webpack的最新版本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87a60b82be814f340a020058c38a1d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3EFupkgnb6BVBUAE4_9PGQ.jpeg"/></div></div></figure><h1 id="a363" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">什么是webpack？</strong></h1><p id="1b0b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你在到达这个页面之前没有<a class="ae mi" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank"> webpack </a>的知识，让我在几个方面帮助你。这是一个模块捆扎机。它的主要目的是捆绑JavaScript文件以便在浏览器中使用，但是它也能够转换、捆绑或打包。您可以使用webpack使您的包更有效率。我说的富有成效是什么意思？取决于您项目的需求。以缓存静态数据为例。如果我们不更新文件路径，那么浏览器仍然会为用户提供缓存的资源。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a5ef" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated"><strong class="ak">散列法</strong></h1><p id="a416" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，我们使用webpack来构建我们的资源，因为它非常容易使用。所以在webpack中出现了散列的概念，它允许我们在新的构建中为每个块生成新的散列。您可以设置一个基本的webpack配置来完成以上工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="081a" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">哈希:9dsn348s34378y99</p><p id="278d" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">版本:webpack 1.10.1</p><p id="6dcb" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">时间:76毫秒</p><p id="7499" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">资产大小块块名称</p><p id="ca0d" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">主要的。9 DSN 348s 34378y 99 . js 1.43 kB 0[已发出] main</p><p id="c958" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">供应商。9 DSN 348s 34378y 99 . js 1.43 kB 1[已发出]供应商</p><p id="02d9" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">[0] ./src/index.js 46字节{ 0 }[已建立]</p><p id="a3b3" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">[0] ./src/vendor.js 40字节{ 1 }[已建立]</p><p id="0e72" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">这个配置实现有什么问题？每次构建时，将使用另一个随机散列重新创建散列9dsn348s34378y99。为了提高我们的应用程序的性能，我们只能更新以前在开发端更改过的块，这样下次用户在新部署后打开我们的应用程序时，用户就不必再次从服务器下载所有资产。它们应该只获取我们已经对其进行了更改的资源。</p><p id="9910" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">Webpack提供三种类型的散列:</p><ul class=""><li id="82c3" class="nc nd it lo b lp mx ls my lv ne lz nf md ng mh nh ni nj nk bi translated">混杂</li><li id="7d7b" class="nc nd it lo b lp nl ls nm lv nn lz no md np mh nh ni nj nk bi translated"><code class="fe nq nr ns nt b">chunkHash</code></li><li id="a6d8" class="nc nd it lo b lp nl ls nm lv nn lz no md np mh nh ni nj nk bi translated"><code class="fe nq nr ns nt b">contentHash</code></li></ul><p id="92a0" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">我将简单解释一下这些散列之间的区别。</p><h2 id="e52c" class="nu kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">混杂</h2><p id="c57b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">哈希对应于构建。在整个构建过程中，每个块都将获得相同的哈希。如果您的构建中有任何变化，相应的散列也会发生变化。</p><h2 id="1dfb" class="nu kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">chunkHash</h2><p id="0d3f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe nq nr ns nt b">chunkhash</code>是基于webpack的入口点。定义的每个条目都有自己的散列。如果这个特定的入口点发生了任何变化，那么只有相应的散列会发生变化。</p><h2 id="dc2c" class="nu kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">内容哈希</h2><p id="37e2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe nq nr ns nt b">contenthash</code>是在<code class="fe nq nr ns nt b">ExtractTextPlugin</code>中创建的一种特定类型的哈希，通过提取的内容而不是完整的块内容来计算。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0021" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated">代码分割</h1><p id="447e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您在CLI中看到过这条消息吗？</p><blockquote class="og oh oi"><p id="d1e9" class="lm ln oj lo b lp mx ju lr ls my jx lu ok mz lx ly ol na mb mc om nb mf mg mh im bi translated"><em class="it">“入口点大小限制警告:以下入口点组合资产大小超过建议限制(244 KiB)。这可能会影响网络性能。”</em></p></blockquote><p id="1452" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">如果是，可能您的包大小存在性能问题——web pack试图告诉您您的包太大了。我们如何继续利用您的应用程序的性能并避免这种警告？分析包的大小是正确的方法。</p><p id="c203" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">你需要做的第一件事是测量你的包的大小。我们如何做到这一点？</p><p id="f99f" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">在陷入一些过早的优化之前，你应该总是<strong class="lo iu"> </strong>衡量一个问题的影响。我们可以在<code class="fe nq nr ns nt b">webpack.config.js</code>中使用<code class="fe nq nr ns nt b">devtool</code>来让<code class="fe nq nr ns nt b"><a class="ae mi" href="https://webpack.js.org/configuration/devtool/" rel="noopener ugc nofollow" target="_blank">source-map</a></code>检查我们的JavaScript包，然后采取相应的行动，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1bcc" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">给你的<code class="fe nq nr ns nt b">package.json</code>添加一个名为<code class="fe nq nr ns nt b">analyze</code>的脚本，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="beb2" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">然后我们可以运行:</p><pre class="kj kk kl km gt on nt oo op aw oq bi"><span id="7d22" class="nu kv it nt b gy or os l ot ou">npm run build<br/>npm run analyze</span></pre><p id="6240" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">您可能会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/f57d406f9a95dd8918e1d5d262707437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SdQdvOzFs-wHcXmp.jpg"/></div></div></figure><p id="6f57" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">正如您在bundle文件中看到的，<a class="ae mi" href="https://www.npmjs.com/package/bluebird" rel="noopener ugc nofollow" target="_blank"> Bluebird </a>、<a class="ae mi" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>和<a class="ae mi" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> MobX </a>是您的应用程序中的重量级组件。这是一个很好的起点，可以检查哪些脚本需要从您的包文件中进行代码拆分，并生成不同的包文件。对你的应用进行代码分割可以帮助你延迟加载用户当前需要的东西，这可以极大地提高你的应用的性能。虽然你没有减少应用程序中的总代码量，但你避免了加载用户可能永远不需要的代码，并减少了初始加载期间所需的代码量。</p><p id="39bd" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">因为这篇文章是关于webpack essentials的，所以我不会深究代码分割。这篇文章仅仅是对webpack中有用的东西的一个简单解释，但是我保证我会专门写一篇关于代码分割的文章。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="baf0" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated"><strong class="ak">开发与生产模式</strong></h1><p id="748d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">webpack使得部署多个环境(开发、测试和生产)变得更加容易，只需要每个环境特别需要的代码和数据。从webpack v4开始，我们可以使用<code class="fe nq nr ns nt b">mode</code>的功能，它相应地使用了一组内置的配置优化。您可以在CLI中将它作为参数传递。</p><p id="866b" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">webpack —模式=开发</p><p id="05c7" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">根据webpack官方网站的说法，当您相应地设置选项时，会出现以下情况:</p><p id="f9d2" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated"><strong class="lo iu">开发</strong> —将<code class="fe nq nr ns nt b"> DefinePlugin</code>上的<code class="fe nq nr ns nt b">process.env.NODE_ENV</code>设置为值<code class="fe nq nr ns nt b">development</code>。启用<code class="fe nq nr ns nt b">NamedChunksPlugin</code>和<code class="fe nq nr ns nt b">NamedModulesPlugin</code>。</p><p id="559d" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated"><strong class="lo iu">生产</strong> —将<code class="fe nq nr ns nt b">DefinePlugin</code>上的<code class="fe nq nr ns nt b">process.env.NODE_ENV</code>设置为值<code class="fe nq nr ns nt b">production</code>。启用<code class="fe nq nr ns nt b">FlagDependencyUsagePlugin</code>、<code class="fe nq nr ns nt b">FlagIncludedChunksPlugin</code>、<code class="fe nq nr ns nt b">ModuleConcatenationPlugin</code>、<code class="fe nq nr ns nt b">NoEmitOnErrorsPlugin</code>、<code class="fe nq nr ns nt b">OccurrenceOrderPlugi</code>、<code class="fe nq nr ns nt b">SideEffectsFlagPlugin</code>和<code class="fe nq nr ns nt b">TerserPlugin</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e065" class="ku kv it bd kw kx mq kz la lb mr ld le jz ms ka lg kc mt kd li kf mu kg lk ll bi translated"><strong class="ak">网络包树晃动</strong></h1><p id="3839" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">树抖动，至少是webpack对该特性的实现，在尽可能多地消除不使用的代码方面做得很好。比如淘汰进口但不用的进口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="465e" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">在上面的例子中，只有<code class="fe nq nr ns nt b">divide</code>函数被调用。从未使用过<code class="fe nq nr ns nt b">subtract</code>功能，将在最终包中移除。</p><p id="e575" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">即使导入对象中从未被访问过的特定属性也会被删除。</p><p id="9d9f" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">然而，树抖动并不能消除所有未使用的代码。什么被删除，什么不被删除的细节超出了本文的范围，但是应该注意的是，使用树抖动并不能完全解决未使用代码的问题。</p><h2 id="19a3" class="nu kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">副作用</h2><p id="70e0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">副作用是代码在导入时执行一些不一定与任何导出相关的操作。副作用的一个很好的例子是聚合填充物。聚合填充通常不提供在主脚本中使用的导出，而是作为一个整体添加到项目中。</p><p id="b572" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">树摇不能自动分辨哪些脚本是副作用，所以手动指定很重要，下面我们会看到。</p><h2 id="9695" class="nu kv it bd kw nv nw dn la nx ny dp le lv nz oa lg lz ob oc li md od oe lk of bi translated">我们如何使用它？</h2><p id="9589" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您可以简单地在您的<code class="fe nq nr ns nt b">webpack.config.js</code>配置文件中设置生产模式，或者使用CLI中的参数，正如我上面提到的。在其他优化中，这将启用树抖动。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="5a95" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">webpack是一个强大的工具，可以帮助我们开发更健壮的应用程序。有大量的功能。在这篇文章中，我试图提到最重要的方面，而不深入到任何其他方面。</p><p id="67e9" class="pw-post-body-paragraph lm ln it lo b lp mx ju lr ls my jx lu lv mz lx ly lz na mb mc md nb mf mg mh im bi translated">可靠消息来源:<a class="ae mi" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/</a></p></div></div>    
</body>
</html>