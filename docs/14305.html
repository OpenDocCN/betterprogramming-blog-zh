<html>
<head>
<title>A Stable AI Optimization Algorithm Implemented Using Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rust实现的稳定的人工智能优化算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-stable-ai-optimization-algorithm-c2a1467f2b1b?source=collection_archive---------2-----------------------#2022-11-27">https://betterprogramming.pub/a-stable-ai-optimization-algorithm-c2a1467f2b1b?source=collection_archive---------2-----------------------#2022-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eabf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">使用人工蜂群算法</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87f514ae55ec55594fa27ad7a861abf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPeQCA8IoOL-mw0DBXWY_Q.png"/></div></div></figure><div class="ku kv gp gr kw kx"><a href="https://medium.com/@applied-math-coding/membership" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd iu gy z fp lc fr fs ld fu fw is bi translated">通过我的推荐链接加入Medium-applied . math . coding</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">获得我所有的故事，以及其他作家在媒体上发表的成千上万的故事。我坚信，媒介是…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ks kx"/></div></div></a></div><p id="ad34" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">人工智能中的大多数技术。机器学习需要解决一个连续的优化问题。通常，这种优化问题是非线性的，不能手工解决。存在大量关于这类优化问题和有效解决它们的可能方法的文献。</p><p id="4172" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这些方法之间的主要区别可以通过使用导数来区分。例如，顾名思义，基于梯度的方法需要计算导数。这同样适用于牛顿法，它试图寻找一阶导数的根。</p><p id="88d8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">众所周知，如果有效的话，这些方法会很快见效。但是它们有时也完全不起作用，或者很难陷入局部极小值。</p><p id="6f02" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这个故事中，我想介绍一种本身基于人工智能的优化技术。就像大多数基于人工智能的算法一样，它是不确定的。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1e41" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">该算法</h1><p id="771d" class="pw-post-body-paragraph lm ln it lo b lp nh ju lr ls ni jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">它的名字是“<strong class="lo iu">人工蜂群算法</strong>”，它遵循自然界中观察到的关于蜜蜂的模式:</p><p id="c983" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">固定数量的N个“蜜蜂”被随机地(均匀地)放置在域中。每只蜜蜂记忆一个基于当前的位置，算法记忆一个全局最佳位置。</p><p id="e6f7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">局部搜索:</strong>在每一步中，每只蜜蜂首先通过随机选择另一只蜜蜂并朝着或远离它的对手移动随机距离来试图找到一个更好的位置。它只在新位置比当前位置更好的情况下执行实际移动。</p><p id="b8d5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">旁观者阶段:</strong>当所有的蜜蜂都完成了局部搜索后，它们会根据一个适合度值通过分类分布进行重新定位。具体来说，通过计算每只蜜蜂的值与当前“最差”蜜蜂的值之间的距离，为每只蜜蜂分配一个适应度。所以，这个距离越高，健身效果越好。我们认为作为一个类别的每个适应值通过将适应值除以所有适应值的总和来加权。这提供了所有适合度值的分布(分类),我们可以从中抽取随机样本。请注意，适合度越高，样本从相应类别中被选中的可能性就越大。这样做N次，实际上有助于N次选择一些蜜蜂，我们为每只蜜蜂找到一个新的位置。这样，一个位置的适应值越好，分配到那里的蜜蜂就越多。</p><p id="c85e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo iu">侦察阶段:</strong>在此之后，所有没有通过重复上述移动X次来提高其当前值的蜜蜂，被随机地重新定位到整个域中，与初始化时的方式相同。</p><p id="beee" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了提高全局最优解，上述过程重复几次。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="d63a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，这种方法非常稳定，它适用于高维，只要求函数是连续的，并且非常容易实现。</p><p id="fc23" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，它允许许多自定义改进。很难估计它的收敛速度，但在许多应用中已经证实，它在搜索全局最小值时工作得特别好，而不会陷入局部最小值。</p><p id="5481" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">因此，如果需要该全局最小值的非常精确的解，最好使用这种方法，让它接近该点，然后用最陡梯度或牛顿迭代来产生所需的精度。</p><p id="2309" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">包括发明人在内的更多详细信息可在以下网址找到:</p><blockquote class="nm nn no"><p id="1f38" class="lm ln np lo b lp lq ju lr ls lt jx lu nq lw lx ly nr ma mb mc ns me mf mg mh im bi translated">人工蜂群算法。(2022年7月8日)。在<em class="it">维基百科</em>里。<a class="ae nt" href="https://en.wikipedia.org/wiki/Artificial_bee_colony_algorithm" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Artificial_bee_colony_algori</a></p></blockquote></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="dd37" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">履行</h1><p id="df2b" class="pw-post-body-paragraph lm ln it lo b lp nh ju lr ls ni jx lu lv nj lx ly lz nk mb mc md nl mf mg mh im bi translated">我们将看看Rust中可能的实现。对于那些需要对Rust做一些总结的人，我推荐阅读<a class="ae nt" href="https://medium.com/@applied-math-coding/list/an-introduction-into-rust-22c99777c5e5" rel="noopener">我的</a>简介。</p><p id="3004" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了产生随机值，我们把箱子<code class="fe nu nv nw nx b"><a class="ae nt" href="https://crates.io/crates/rand" rel="noopener ugc nofollow" target="_blank">rand</a></code>放到我们的依赖项(<code class="fe nu nv nw nx b">Cargo.toml</code>)中:</p><pre class="kj kk kl km gt ny nx nz bn oa ob bi"><span id="1b4f" class="oc mq it nx b be od oe l of og">[dependencies]<br/>rand = { version = "0.8.5" }</span></pre><p id="16d0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在整个计划中，我们使用以下类型:</p><pre class="kj kk kl km gt ny nx nz bn oa ob bi"><span id="5c20" class="oc mq it nx b be od oe l of og">use rand::{distributions::WeightedIndex,<br/> prelude::Distribution, rngs::ThreadRng, thread_rng, Rng};<br/><br/>pub struct Params {<br/>    n_bees: usize,<br/>    abandon_limit: usize,<br/>    max_iter: usize,<br/>}<br/><br/>type X = Vec&lt;f64&gt;;<br/>type Target = dyn Fn(&amp;X) -&gt; f64;<br/><br/>struct Bee {<br/>    position: X,<br/>    value: f64,<br/>    not_improved_since: usize,<br/>    fitness: f64, // distance to worst<br/>}</span></pre><p id="ee8c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">所以，一辆<code class="fe nu nv nw nx b">Bee</code>由它的<code class="fe nu nv nw nx b">position</code>、<code class="fe nu nv nw nx b">value, fitness</code>以及它多久没能改进它的<code class="fe nu nv nw nx b">value</code>来描述。<code class="fe nu nv nw nx b">X</code>只是一个方便的占位符，而<code class="fe nu nv nw nx b">Target</code>是我们想要最小化的函数类型。</p><p id="401a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">接下来，我们列出一些需要的简单实用函数:</p><pre class="kj kk kl km gt ny nx nz bn oa ob bi"><span id="a1e0" class="oc mq it nx b be od oe l of og">fn compute_fitness_on_bees(bees: &amp;mut Vec&lt;Bee&gt;) {<br/>    let worst_value = bees[find_worst_bee_idx(bees)].value;<br/>    for bee in bees.iter_mut() {<br/>        bee.fitness = worst_value - bee.value;<br/>    }<br/>}<br/><br/>// returns the best position and value among all the bees<br/>fn find_best_position_and_value(bees: &amp;Vec&lt;Bee&gt;) -&gt; (X, f64) {<br/>    let best_bee = bees<br/>        .iter()<br/>        .min_by(|b1, b2| b1.value.partial_cmp(&amp;b2.value).unwrap())<br/>        .unwrap();<br/>    (best_bee.position.clone(), best_bee.value)<br/>}<br/><br/>// returns the index of the bee with highest (worst) value<br/>fn find_worst_bee_idx(bees: &amp;Vec&lt;Bee&gt;) -&gt; usize {<br/>    bees.iter()<br/>        .enumerate()<br/>        .max_by(|(_, b1), (_, b2)| b1.value.partial_cmp(&amp;b2.value).unwrap())<br/>        .unwrap()<br/>        .0<br/>}<br/><br/>// creates a random point within the n-dim. interval [a, b],<br/>// that is a &lt;/= x &lt;/= b<br/>fn create_random_position(a: &amp;X, b: &amp;X, rng: &amp;mut ThreadRng) -&gt; X {<br/>    let mut res = vec![];<br/>    for (u, v) in a.iter().zip(b.iter()) {<br/>        res.push(rng.gen_range(*u..*v));<br/>    }<br/>    res<br/>}</span></pre><p id="1130" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">最后，我们按照算法中的描述逐一实现每个阶段。你会看到，所有的步骤都很容易实现:</p><pre class="kj kk kl km gt ny nx nz bn oa ob bi"><span id="864d" class="oc mq it nx b be od oe l of og">// create n bees and position them randomly in [a,b]<br/>fn init_bees(f: &amp;Target, a: &amp;X, b: &amp;X, n_bees: usize) -&gt; Vec&lt;Bee&gt; {<br/>    let mut res = vec![];<br/>    let mut rng = thread_rng();<br/>    for _ in 0..n_bees {<br/>        let position = create_random_position(a, b, &amp;mut rng);<br/>        res.push(Bee {<br/>            fitness: 0.0,<br/>            not_improved_since: 0,<br/>            value: f(&amp;position),<br/>            position,<br/>        });<br/>    }<br/>    res<br/>}<br/><br/>// let each bee locally search by moving a random distance to or away from<br/>// another random bee.<br/>// At the same time, keep the globally best know value/position up to date.<br/>fn do_local_search_phase(<br/>    f: &amp;Target,<br/>    bees: &amp;mut Vec&lt;Bee&gt;,<br/>    best_position: &amp;mut X,<br/>    best_value: &amp;mut f64,<br/>    a: &amp;X,<br/>    b: &amp;X,<br/>) {<br/>    let mut rng = thread_rng();<br/>    for idx in 0..bees.len() {<br/>        let mut new_position = bees.get(idx).unwrap().position.clone();<br/>        let other_bee_idx = rng.gen_range(0..bees.len());<br/>        let position_idx = rng.gen_range(0..new_position.len());<br/>        let phi = rng.gen_range(-1.0..1.0);<br/>        let x_i_other = bees.get(other_bee_idx).unwrap()<br/>                   .position[position_idx];<br/>        let x_i = new_position[position_idx];<br/>        new_position[position_idx] = (x_i + phi * (x_i_other - x_i))<br/>            .max(a[position_idx])<br/>            .min(b[position_idx]);<br/>        let new_value = f(&amp;new_position);<br/>        let old_value = bees.get(idx).unwrap().value;<br/>        let bee = bees.get_mut(idx).unwrap();<br/>        if new_value &lt; old_value {<br/>            bee.position = new_position;<br/>            bee.value = new_value;<br/>            bee.not_improved_since = 0;<br/>        } else {<br/>            bee.not_improved_since += 1;<br/>        }<br/>        if new_value &lt; *best_value {<br/>            *best_value = bee.value;<br/>            *best_position = bee.position.clone();<br/>        }<br/>    }<br/>}<br/><br/>// Re-distribute bees onto other locations and prioritize locations with<br/>// higher fitness. This is done by laying a categorical distrubition over all<br/>// the bees.<br/>fn do_onlooker_phase(bees: &amp;mut Vec&lt;Bee&gt;) {<br/>    compute_fitness_on_bees(bees);<br/>    let sum_fitness = bees.iter().map(|bee| bee.value).sum::&lt;f64&gt;();<br/>    let weights = bees<br/>        .iter()<br/>        .map(|bee| bee.value / sum_fitness)<br/>        .collect::&lt;X&gt;();<br/>    let categorical_dist = WeightedIndex::new(&amp;weights).unwrap();<br/>    let mut rng = thread_rng();<br/>    for idx in 0..bees.len() {<br/>        let other_bee = bees.get(categorical_dist.sample(&amp;mut rng)).unwrap();<br/>        let new_position = other_bee.position.clone();<br/>        let new_value = other_bee.value;<br/>        bees[idx].position = new_position;<br/>        bees[idx].value = new_value;<br/>    }<br/>}<br/><br/>// Abandon bees from positions if have not been improved for long.<br/>// This avoids being trapped at local minima.<br/>fn do_scout_phase(bees: &amp;mut Vec&lt;Bee&gt;, <br/>abandon_limit: usize, a: &amp;X, b: &amp;X, f: &amp;Target) {<br/>    let mut rng = thread_rng();<br/>    bees.iter_mut()<br/>        .filter(|bee| bee.not_improved_since &gt; abandon_limit)<br/>        .for_each(|bee| {<br/>            let new_position = create_random_position(a, b, &amp;mut rng);<br/>            let new_value = f(&amp;new_position);<br/>            bee.position = new_position;<br/>            bee.value = new_value;<br/>            bee.not_improved_since = 0;<br/>        });<br/>}</span></pre><p id="409e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，我们一起将这些阶段放入一个迭代中:</p><pre class="kj kk kl km gt ny nx nz bn oa ob bi"><span id="17ff" class="oc mq it nx b be od oe l of og">pub fn optimize(f: &amp;Target, a: &amp;X, b: &amp;X, params: Params) -&gt; (X, f64) {<br/>    let mut bees = init_bees(f, a, b, params.n_bees);<br/>    let (mut best_position, mut best_value) = find_best_position_and_value(&amp;bees);<br/>    for _ in 0..params.max_iter {<br/>        do_local_search_phase(f, &amp;mut bees, &amp;mut best_position, &amp;mut best_value, a, b);<br/>        do_onlooker_phase(&amp;mut bees);<br/>        do_scout_phase(&amp;mut bees, params.abandon_limit, a, b, f);<br/>    }<br/>    (best_position, best_value)<br/>}</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="472c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">作为一个测试函数，我使用了Ackley函数(见这里的<a class="ae nt" href="https://en.wikipedia.org/wiki/Ackley_function" rel="noopener ugc nofollow" target="_blank">和</a>)，这是一个有很多局部最小值的函数:</p><pre class="kj kk kl km gt ny nx nz bn oa ob bi"><span id="93a5" class="oc mq it nx b be od oe l of og">fn main(){<br/>   let ackley_fn = |x: &amp;X| {<br/>            -20.0 * f64::exp(<br/>               -0.2 * f64::sqrt(0.5 * (x[0] * x[0] + x[1] * x[1]))<br/>             ) - f64::exp(<br/>               0.5 * (f64::cos(2.0 * PI * x[0]) + f64::cos(2.0 * PI * x[1]))<br/>             ) + E + 20.0<br/>        };<br/><br/>        println!("{}", ackley_fn(&amp;vec![0.0, 0.0])); // this is the minimum<br/><br/>        let params = Params {<br/>            n_bees: 200,<br/>            abandon_limit: 20,<br/>            max_iter: 500,<br/>        };<br/>        println!(<br/>            "{:?}",<br/>            optimize(&amp;ackley_fn, &amp;vec![-5.0, -5.0], &amp;vec![5.0, 5.0], params)<br/>        );<br/>}</span></pre><p id="65db" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">输出是:</p><pre class="kj kk kl km gt ny nx nz bn oa ob bi"><span id="9e3a" class="oc mq it nx b be od oe l of og">([0.007315634561002593, 9.547793830446227e-5], 0.02211822639045735)</span></pre><p id="114c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可以在这里找到关于<a class="ae nt" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=36db9de9533ff56b869d543696fff288" rel="noopener ugc nofollow" target="_blank">的全部代码。</a></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="7260" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">感谢阅读！</p></div></div>    
</body>
</html>