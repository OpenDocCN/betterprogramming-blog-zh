<html>
<head>
<title>Securely Building Container Images on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上安全地构建容器图像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/securely-building-container-images-on-kubernetes-cef0c4c3cc24?source=collection_archive---------4-----------------------#2019-07-28">https://betterprogramming.pub/securely-building-container-images-on-kubernetes-cef0c4c3cc24?source=collection_archive---------4-----------------------#2019-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4628" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">运行容器和提取容器图像—不再需要Docker</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4fac765ee3f3f9a755782c9546a21e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E78mjbRQXGft6SfI.jpg"/></div></div></figure><p id="3b2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">梅萨维德国家公园，古普韦布洛住宅，CO <br/>由Kurt Madel 2019 </em>拍摄</p><p id="544c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到2013年，<a class="ae lr" href="https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/" rel="noopener ugc nofollow" target="_blank">在Kubernetes出现之前</a>，Docker正在让Linux容器(LXC)变得更容易使用。基于Docker的容器开始流行起来(Docker很快放弃了LXC作为他们自己的容器运行时的默认执行引擎)。</p><p id="a72f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与此同时，持续集成(CI)作为一种最佳实践和高效软件交付的必要条件正在迅速成熟。将Docker容器与CI结合使用很快成为管理CI工具(编译器、测试工具、安全扫描等)的最佳方式。但它是新的，没有多少最佳实践被定义——人们的态度是“去搞清楚”。</p><p id="c88b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在早期，将容器用于CI/CD的一个重要方面是使用它们来构建容器映像，并将这些映像推送到容器注册中心。但是，这一切都是非常新的——许多人并不真正知道他们在做什么。没有一个<em class="lq">为假人构建容器图像</em>。</p><p id="8010" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几年后的2015年9月，杰罗姆·佩塔佐尼发表了一篇名为<a class="ae lr" href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" rel="noopener ugc nofollow" target="_blank">“为您的CI或测试环境使用Docker-in-Docker？三思而后行。”</a>本文描述了使用<a class="ae lr" href="https://github.com/jpetazzo/dind" rel="noopener ugc nofollow" target="_blank"> Docker-in-Docker (DinD) </a>对于CI/CD工作负载来说是多么糟糕的选择，原因有很多。绝对还是值得一读的。Petazzoni提出了在运行Docker守护进程的主机上安装Docker套接字，并使用主机Docker守护进程在CI/CD作业中执行Docker命令的概念。将<code class="fe ls lt lu lv b">/var/run/docker.sock</code>文件作为一个卷安装在Docker容器中允许您完成与DinD相似的功能，但是没有DinD的一些缺点——包括层缓存和需要在启用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" rel="noopener ugc nofollow" target="_blank">--privileged</a></code> <a class="ae lr" href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" rel="noopener ugc nofollow" target="_blank">模式</a>的情况下运行DinD容器。</p><p id="7068" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在关于本地Kubernetes连续交付的本系列文章的第5部分中，我们将探讨为什么使用这两种方法中的任何一种作为本地Kubernetes连续交付管道的一部分来构建和推送容器映像不再是最佳实践。我们将从两个不同的角度来看这个问题:安全性和性能。最后，我们将着眼于安全性和性能，看看另一种方法。</p><p id="8e1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始在Kubernetes上安全地构建和推送容器图像之前，我想分享一些关于容器术语的想法。我通常把在Kubernetes Pod中作为容器运行的图像称为<strong class="kw iu">容器图像</strong>，而不是<strong class="kw iu"> Docker图像</strong>。</p><p id="b148" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">早在2015年，Docker就好心地<a class="ae lr" href="https://blog.docker.com/2017/07/oci-release-of-v1-0-runtime-and-image-format-specifications/" rel="noopener ugc nofollow" target="_blank">将Docker图像格式</a>捐赠给了当时新成立的<a class="ae lr" href="https://www.opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放容器倡议(OCI) </a>。除了容器<a class="ae lr" href="https://github.com/opencontainers/image-spec/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank">映像规范</a>，OCI还为容器执行维护了一个开放的<a class="ae lr" href="https://github.com/opencontainers/runtime-spec/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank">运行时规范</a>。这意味着<em class="lq"> Docker是</em> <em class="lq">不再需要</em>来运行容器和提取容器图像——正如你将在本文后面看到的，甚至是构建和推送容器图像。</p><p id="e9e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解使用DinD构建和推送容器映像的缺点，我再次推荐您阅读<a class="ae lr" href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" rel="noopener ugc nofollow" target="_blank">jérme Petazzoni的文章</a>。下面是一个快速总结:</p><ul class=""><li id="fd11" class="lw lx it kw b kx ky la lb ld ly lh lz ll ma lp mb mc md me bi translated">安全性DinD容器必须在启用了<code class="fe ls lt lu lv b">--privileged</code>标志的情况下运行，从而导致针对底层Docker主机的不良攻击。</li><li id="988c" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp mb mc md me bi translated">性能—当使用临时DinD容器时，层缓存不会在构建之间共享。每次使用新的DinD容器时，都必须提取所有映像的所有层，这导致容器映像构建非常慢。</li></ul><p id="52f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们已经确定，将DinD用于CI/CD，尤其是用于构建和推送容器映像，是一个坏主意。但是对于Kubernetes CD，如果您要为CI/CD安装Docker插座，包括构建和推送容器映像，您也应该三思。</p><h1 id="84dc" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">表演</h1><p id="a89b" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">让我们暂时把安全放在一边。事实证明，在基于Kubernetes的CD环境中安装Docker插座有很大的问题。</p><p id="9c9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubernetes集群由一个或多个工作节点组成，Kubernetes正是在这些工作节点上调度和运行<a class="ae lr" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank"> Pods </a>。当您将Docker插座安装到Pod时，您正在将<code class="fe ls lt lu lv b">/var/run/docker.sock</code>文件安装到组成Pod的每个容器中。当这些容器针对该套接字运行Docker命令时，它们实际上是由Docker守护进程直接执行的，该守护进程作为<strong class="kw iu"> root </strong>在调度Pod的worker节点上运行。Kubernetes调度程序无法跟踪这些其他容器的运行情况——它们不是由Kubernetes管理的，而是由运行在调度Pod的节点上的Docker守护进程管理的。这可能会导致严重的Kubernetes调度问题，尤其是在繁忙的CD集群上。首先，使用Kubernetes的一个主要原因是因为其强大的容器编排和调度功能——那么，为什么要在CI/CD中规避这一点呢？</p><p id="7a1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个性能问题是容器影像图层缓存。如果您依赖于Docker守护进程提供的内置缓存，那么您可能会在不同的K8s节点上完成同一容器映像的不同构建，或者共享层的其他容器映像，从而否定Docker守护进程在特定K8s worker节点上提供的缓存。</p><p id="0224" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，存储在主机上的任何层，以及通过Docker套接字运行的容器生成的任何日志，都不会自动为您清除。</p><h1 id="4635" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">安全性</h1><p id="177d" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">简而言之，提高安全性与减少攻击面或攻击媒介密切相关。和Kubernetes上的CD没什么区别。如果Docker套接字暴露给一个CD作业，那么好奇/恶意的开发人员可以修改该作业，以运行Docker命令作为构建步骤，有可能成为该作业所在节点上的<code class="fe ls lt lu lv b">root</code>。如果他们以<code class="fe ls lt lu lv b">root</code>的身份获得对底层主机的访问权限，有相当简单的方法来提升权限并获得对整个Kubernetes集群的访问权限。许多集群操作员没有适当的监控来正确地检测这种活动，并将其与合法的CD作业运行分开，因此这种利用可能暂时不会被注意到。</p><p id="89f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> DinD </strong>一直<a class="ae lr" href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" rel="noopener ugc nofollow" target="_blank">要求运行DinD </a>的容器启用 <code class="fe ls lt lu lv b"><a class="ae lr" href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" rel="noopener ugc nofollow" target="_blank">--privileged</a></code> <a class="ae lr" href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" rel="noopener ugc nofollow" target="_blank">标志——而这一直被认为是不安全的。但是安装Docker套接字从来没有这么安全过，它依赖于使用专用的Docker守护进程实例来将CI/CD工作负载与其他容器工作负载(例如生产应用程序)隔离开来。</a></p><p id="007c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这对于仅执行CI/CD的单用途集群来说是很高的，但是对于具有多个应该具有隔离的工作负载的K8s集群来说，这是非常高的——这种隔离应该来自K8s上运行的容器。例如，您的<strong class="kw iu">生产</strong>容器可能只是运行CD作业的名称空间的一个名称空间。</p><p id="c799" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果沿着这条路走下去，最终结果是<em class="lq">任何可以修改CD作业的人都有办法成为整个集群的root</em>。</p><p id="d3e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于一些人来说，在Kubernetes上安装CD Docker插座的缺点非常明显，以至于他们<a class="ae lr" href="https://applatix.com/case-docker-docker-kubernetes-part-2/" rel="noopener ugc nofollow" target="_blank">建议回到DinD </a>。但是我们已经放弃了在Kubernetes上安装CD的方法。在我们寻找替代方案之前，我们将探索K8s的一些特性，这些特性允许您阻止在K8s集群(或集群的一部分)上运行的所有容器使用DinD和安装Docker套接字。</p><p id="266c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将Kubernetes用于动态短暂CD执行器，您可以在专门构建的容器中直接运行您的每个CD步骤，并单独用于执行该步骤，所有这些都在由Kubernetes管理的<a class="ae lr" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank"> Pod </a>中。除了协调这些CD Pods的调度和运行，K8s还允许管理其生命周期的其他方面，以包括pod规范的安全敏感方面，从而实现pod创建和更新的细粒度授权。</p><p id="88a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用于管理pod安全性的本地K8s解决方案是<a class="ae lr" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy" rel="noopener ugc nofollow" target="_blank"> Pod安全策略准入控制器</a>。Pod安全策略(PSP)可以以这样的方式配置，即如果使用正确配置的策略在Pod中运行的容器被配置为安装Docker套接字，则不会被调度，并且不允许作为<code class="fe ls lt lu lv b">--privileged</code>容器运行，从而禁用DinD。</p><h1 id="34fc" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">使用Pod安全策略阻止DinD并安装Docker插座</h1><p id="3b2c" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">Pod安全策略准入控制器是增强K8s集群安全性的<a class="ae lr" href="https://kubernetes.io/blog/2018/07/18/11-ways-not-to-get-hacked/#6-use-linux-security-features-and-podsecuritypolicies" rel="noopener ugc nofollow" target="_blank">关键特性。Pod安全策略准入控制器允许您指定Pod安全策略，以限制允许容器执行的操作。如果Pod中的容器被配置为执行Pod安全策略不允许的操作，那么K8s将不会调度该Pod。</a></p><p id="942c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lr" href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#what-is-a-pod-security-policy" rel="noopener ugc nofollow" target="_blank"> <em class="lq">来自Kubernetes官方文档</em> </a> <em class="lq"> : </em></p><blockquote class="nh ni nj"><p id="a74b" class="ku kv lq kw b kx ky ju kz la lb jx lc nk le lf lg nl li lj lk nm lm ln lo lp im bi translated">pod安全策略是控制Pod规范的安全敏感方面的群集级资源。PodSecurityPolicy对象定义了一组条件，pod必须在这些条件下运行才能被系统接受，还定义了相关字段的默认值</p></blockquote><p id="87ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看一些具体的设置，它们将大大减少<em class="lq">攻击</em>面，从而降低风险:</p><ul class=""><li id="a20d" class="lw lx it kw b kx ky la lb ld ly lh lz ll ma lp mb mc md me bi translated"><code class="fe ls lt lu lv b">privileged</code>:设置为<code class="fe ls lt lu lv b">false</code>将禁止使用DinD。</li><li id="39ac" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe ls lt lu lv b">runAsUser</code>:将此项设置为<code class="fe ls lt lu lv b">MustRunAsNonRoot</code>，这样容器就不能以<code class="fe ls lt lu lv b">ROOT</code>用户的身份运行。</li></ul><p id="d43a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">注意:您将需要允许</em> <code class="fe ls lt lu lv b"><em class="lq">USER root</em></code> <em class="lq">使用Kaniko做任何有意义的事情来构建和推送容器映像，因此您很可能需要将</em> <code class="fe ls lt lu lv b"><em class="lq">runAsUser</em></code> <em class="lq">设置为</em> <code class="fe ls lt lu lv b"><em class="lq">RunAsAny</em></code> <em class="lq">。Kaniko PSP的目标是减少其他可用的攻击媒介。</em></p><ul class=""><li id="27e0" class="lw lx it kw b kx ky la lb ld ly lh lz ll ma lp mb mc md me bi translated"><code class="fe ls lt lu lv b">allowPrivilegeEscalation</code>:禁用特权提升，这样容器的子进程就不会获得比其父进程更多的特权。</li><li id="e14e" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp mb mc md me bi translated"><code class="fe ls lt lu lv b">volumes</code>:通过指定<a class="ae lr" href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener ugc nofollow" target="_blank">特定卷类型</a>和不允许任何CD容器的<code class="fe ls lt lu lv b">hostPath</code>卷，不允许将主机目录/文件挂载为卷。这将禁用安装Docker插座的功能。</li><li id="ceeb" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp mb mc md me bi translated">PSP <code class="fe ls lt lu lv b">annotations</code>:通过<code class="fe ls lt lu lv b">seccomp.security.alpha.kubernetes.io/defaultProfileName</code>注释将所有Pod容器限制在<code class="fe ls lt lu lv b">runtime/default</code> <strong class="kw iu"> seccomp </strong>配置文件中，并且不要设置<code class="fe ls lt lu lv b">seccomp.security.alpha.kubernetes.io/allowedProfileNames</code>，这样默认设置就无法更改。</li></ul><p id="7ea4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个限制性<strong class="kw iu"> PSP </strong>的例子，它不允许<strong class="kw iu">安装Docker插座</strong>，也不允许<strong class="kw iu"> DinD </strong>:</p><pre class="kj kk kl km gt nn lv no np aw nq bi"><span id="c7a8" class="nr ml it lv b gy ns nt l nu nv">apiVersion: policy/v1beta1</span><span id="7b78" class="nr ml it lv b gy nw nt l nu nv">kind: PodSecurityPolicy</span><span id="8b20" class="nr ml it lv b gy nw nt l nu nv">metadata:</span><span id="798c" class="nr ml it lv b gy nw nt l nu nv">name: cd-restricted</span><span id="856e" class="nr ml it lv b gy nw nt l nu nv">annotations:</span><span id="8df8" class="nr ml it lv b gy nw nt l nu nv">seccomp.security.alpha.kubernetes.io/defaultProfileName:  'runtime/default'</span><span id="a023" class="nr ml it lv b gy nw nt l nu nv">apparmor.security.beta.kubernetes.io/defaultProfileName:  'runtime/default'</span><span id="3da1" class="nr ml it lv b gy nw nt l nu nv">spec:</span><span id="e53b" class="nr ml it lv b gy nw nt l nu nv">privileged: false</span><span id="a772" class="nr ml it lv b gy nw nt l nu nv"># Required to prevent escalations to root.</span><span id="e584" class="nr ml it lv b gy nw nt l nu nv">allowPrivilegeEscalation: false</span><span id="e20d" class="nr ml it lv b gy nw nt l nu nv"># This is redundant with non-root + disallow privilege escalation,</span><span id="a1c9" class="nr ml it lv b gy nw nt l nu nv"># but we can provide it for defense in depth.</span><span id="338e" class="nr ml it lv b gy nw nt l nu nv">requiredDropCapabilities:</span><span id="10a1" class="nr ml it lv b gy nw nt l nu nv">- ALL</span><span id="4136" class="nr ml it lv b gy nw nt l nu nv"># Allow core volume types. But more specifically, don't allow mounting host volumes to include the Docker socket - '/var/run/docker.sock'</span><span id="00e0" class="nr ml it lv b gy nw nt l nu nv">volumes:</span><span id="8004" class="nr ml it lv b gy nw nt l nu nv">- 'configMap'</span><span id="a853" class="nr ml it lv b gy nw nt l nu nv">- 'emptyDir'</span><span id="1485" class="nr ml it lv b gy nw nt l nu nv">- 'projected'</span><span id="cbac" class="nr ml it lv b gy nw nt l nu nv">- 'secret'</span><span id="c678" class="nr ml it lv b gy nw nt l nu nv">- 'downwardAPI'</span><span id="a121" class="nr ml it lv b gy nw nt l nu nv"># Assume that persistentVolumes set up by the cluster admin are safe to use.</span><span id="be15" class="nr ml it lv b gy nw nt l nu nv">- 'persistentVolumeClaim'</span><span id="7082" class="nr ml it lv b gy nw nt l nu nv">hostNetwork: false</span><span id="b9a4" class="nr ml it lv b gy nw nt l nu nv">hostIPC: false</span><span id="18fc" class="nr ml it lv b gy nw nt l nu nv">hostPID: false</span><span id="deed" class="nr ml it lv b gy nw nt l nu nv">runAsUser:</span><span id="be89" class="nr ml it lv b gy nw nt l nu nv"># Don't allow containers to run as ROOT</span><span id="3562" class="nr ml it lv b gy nw nt l nu nv">rule: 'MustRunAsNonRoot'</span><span id="6e6f" class="nr ml it lv b gy nw nt l nu nv">seLinux:</span><span id="8606" class="nr ml it lv b gy nw nt l nu nv"># This policy assumes the nodes are using AppArmor rather than SELinux.</span><span id="cb74" class="nr ml it lv b gy nw nt l nu nv">rule: 'RunAsAny'</span><span id="6764" class="nr ml it lv b gy nw nt l nu nv">supplementalGroups:</span><span id="773a" class="nr ml it lv b gy nw nt l nu nv">rule: 'MustRunAs'</span><span id="51cc" class="nr ml it lv b gy nw nt l nu nv">ranges:</span><span id="3263" class="nr ml it lv b gy nw nt l nu nv"># Forbid adding the root group.</span><span id="6d29" class="nr ml it lv b gy nw nt l nu nv">- min: 1</span><span id="b3e9" class="nr ml it lv b gy nw nt l nu nv">max: 65535</span><span id="9d93" class="nr ml it lv b gy nw nt l nu nv">fsGroup:</span><span id="6540" class="nr ml it lv b gy nw nt l nu nv">rule: 'MustRunAs'</span><span id="68de" class="nr ml it lv b gy nw nt l nu nv">ranges:</span><span id="a171" class="nr ml it lv b gy nw nt l nu nv"># Forbid adding the root group.</span><span id="6b4d" class="nr ml it lv b gy nw nt l nu nv">- min: 1</span><span id="546b" class="nr ml it lv b gy nw nt l nu nv">max: 65535</span><span id="9947" class="nr ml it lv b gy nw nt l nu nv">readOnlyRootFilesystem: false</span></pre><p id="0491" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"/></p><h1 id="01a9" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">不要运行Docker</h1><p id="880f" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">不允许DinD或安装Docker套接字的另一个令人信服的方法是不要将Docker用作K8s集群的容器运行时。</p><p id="524f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lr" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> containerd </strong> </a>是上面提到的OCI映像运行时的一个实现(也是由Docker捐赠给CNCF 的<a class="ae lr" href="https://blog.docker.com/2017/03/docker-donates-containerd-to-cncf/" rel="noopener ugc nofollow" target="_blank">),并且(在撰写本文时)</a><a class="ae lr" href="https://cloud.google.com/kubernetes-engine/docs/concepts/using-containerd" rel="noopener ugc nofollow" target="_blank">由Google Kubernetes引擎(GKE) </a> — <em class="lq">支持，但没有其他主要的云提供商</em>。通过使用由<strong class="kw iu"> containerd </strong>提供的OCI运行规范，您实际上并不需要Docker——并且您实际上会看到带有<strong class="kw iu"> containerd </strong>的K8s容器有更好的性能，因为Docker实际上在幕后使用了<strong class="kw iu">container d</strong>—导致了额外的守护进程和不必要的通信开销。</p><p id="326b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> containerd </strong>的一个有趣的方面是它只是容器的运行时——它不支持构建容器映像。但是除了更好的性能之外，<strong class="kw iu"> containerd </strong>的一大优点是，它使使用<strong class="kw iu"> DinD </strong>或安装Docker套接字变得不可能——因此提供了更安全的容器运行时。</p><p id="839c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果没有Docker，如何构建容器映像呢？</p><p id="f189" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者更具体地说，在没有Docker <strong class="kw iu">守护进程</strong>的情况下构建容器映像——没有<strong class="kw iu"> DinD </strong>，没有Docker套接字。我们仍然希望利用K8s托管的CD容器，包括构建和推送容器映像。我们如何做到这一点？</p><h1 id="072d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">进入Kaniko</h1><p id="9617" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">Kaniko是一个能够在没有Docker守护进程的情况下构建和推送容器映像的工具，但从安全角度来看，它有一个主要缺点:要轻松构建任何有用的东西，您必须在Kaniko容器中作为<code class="fe ls lt lu lv b">root</code> <code class="fe ls lt lu lv b">USER</code>运行。</p><p id="8a90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lr" href="https://github.com/GoogleContainerTools/kaniko#security" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="lq">来自Kaniko的文档</em> </strong> </a> <em class="lq"> : </em></p><blockquote class="nh ni nj"><p id="dd97" class="ku kv lq kw b kx ky ju kz la lb jx lc nk le lf lg nl li lj lk nm lm ln lo lp im bi translated"><em class="it">如果你有一个最小的基础映像(SCRATCH或者类似的)不需要权限就可以解包，并且你的Dockerfile没有以root用户的身份执行任何命令，那么你可以在没有root权限的情况下运行Kaniko。需要注意的是，Docker默认以root身份运行，所以您仍然需要(在某种意义上)特权来使用Kaniko。</em></p><p id="36f5" class="ku kv lq kw b kx ky ju kz la lb jx lc nk le lf lg nl li lj lk nm lm ln lo lp im bi translated"><em class="it">通过在PodSecurityPolicy上设置带注释的seccomp配置文件来创建或更新集群上的安全策略，您可以实现Docker在Pod中使用的相同默认seccomp配置文件。</em></p></blockquote><p id="4d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所述，以<code class="fe ls lt lu lv b">root</code>身份运行是一种攻击媒介，许多人认为这是一个不可接受的安全漏洞——但使用Pod安全策略将减少作为K8s Pod一部分运行的Kaniko容器的攻击面，并提供比我们已经放弃的基于Docker的方法更高的安全性。</p><p id="feae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的配置假设您已经启动并运行了一个K8集群，并且您可以访问<code class="fe ls lt lu lv b">kubectl</code>来添加和修改K8s资源。</p><ol class=""><li id="3126" class="lw lx it kw b kx ky la lb ld ly lh lz ll ma lp nx mc md me bi translated"><strong class="kw iu">容器注册中心</strong>:我建议Kaniko建立一个暂存或沙盒容器注册中心，Kaniko不能将图像推送到这个注册中心。一旦针对容器映像成功运行了所需的测试/扫描/策略，应使用单独管理和安全的CD作业将容器映像从暂存提升到生产。当然，Kaniko容器映像本身(以及CD作业使用的任何其他容器映像)应该总是从生产容器注册表中取出。</li><li id="0d16" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp nx mc md me bi translated"><code class="fe ls lt lu lv b">PodSecurityPolicy</code>:一旦启用了PodSecurityPolicy许可控制器，您将需要至少两个PodSecurityPolicy(实际上，您将希望在启用许可控制器之前定义并应用所有的Pod安全策略，否则将会阻止在集群中创建任何Pod)。</li><li id="7131" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp nx mc md me bi translated">使用Kaniko执行构建和推送的最严格的策略——上面对PSP的唯一更改是将<code class="fe ls lt lu lv b">runAsUser</code>更改为<code class="fe ls lt lu lv b">RunAsAny</code>,以允许在Kaniko构建的Dockerfiles中使用ROOT用户。</li><li id="fbef" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp nx mc md me bi translated">一个<a class="ae lr" href="https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml" rel="noopener ugc nofollow" target="_blank">特权策略</a>,对于使用Pod安全准入控制器的Pod，它相当于不使用Pod安全准入控制器。</li><li id="c84c" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp nx mc md me bi translated"><code class="fe ls lt lu lv b">Namespace</code>、<code class="fe ls lt lu lv b">Service Account</code>、<code class="fe ls lt lu lv b">Role</code>、<code class="fe ls lt lu lv b">RoleBinding</code>:PodSecurityPolicy应用于K8s <code class="fe ls lt lu lv b">Role</code>，K8s<code class="fe ls lt lu lv b">Role</code>通过<code class="fe ls lt lu lv b">RoleBinding</code>绑定到<code class="fe ls lt lu lv b">ServiceAccount</code>。我建议专门为Kaniko/CD作业创建一个绑定到具有限制性PodSecurityPolicy的<code class="fe ls lt lu lv b">ServiceAccount</code>。</li></ol><p id="806d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kaniko是Google赞助的一个项目，因此在GKE集群中使用Kaniko自然会得到很好的支持。我<a class="ae lr" href="https://github.com/GoogleContainerTools/kaniko#running-kaniko-in-a-kubernetes-cluster" rel="noopener ugc nofollow" target="_blank">遵从GKE + GCR </a>的Kaniko指令。</p><p id="4f80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lr" href="https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies" rel="noopener ugc nofollow" target="_blank">对GKE使用Pod安全策略。</a></p><p id="bb91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kaniko指令告诉您用您的<code class="fe ls lt lu lv b">~/.aws/credentials</code>创建一个Kubernetes秘密，将容器图像推送到ECR，但是大多数组织不允许您以这种方式使用AWS凭证。</p><p id="207c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是<a class="ae lr" href="https://github.com/GoogleContainerTools/kaniko#pushing-to-amazon-ecr" rel="noopener ugc nofollow" target="_blank"> Kaniko推送到AWS ECR </a>的指令。</p><p id="4a3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将Kaniko与EKS和ECR一起安全使用的另一种方法是将worker node IAM角色与专用于Kaniko/CD的实例组一起使用。</p><p id="c067" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lr" href="https://aws.amazon.com/blogs/opensource/using-pod-security-policies-amazon-eks-clusters/" rel="noopener ugc nofollow" target="_blank">对EKS使用Pod安全策略。</a></p><p id="7b58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章发表的时候，Kaniko还没有对Azure容器注册中心(ACR)的官方支持——但这并不意味着这是不可能的。Kaniko GitHub资源库中有一个<a class="ae lr" href="https://github.com/GoogleContainerTools/kaniko/issues/425" rel="noopener ugc nofollow" target="_blank">未解决的问题</a>，其中包括一些关于从Kaniko向ACR推送容器图像的技巧。</p><p id="1fae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lr" href="https://docs.microsoft.com/en-us/azure/aks/use-pod-security-policies" rel="noopener ugc nofollow" target="_blank">通过AK使用Pod安全策略。</a></p><p id="76b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Jenkins X允许您<a class="ae lr" href="https://jenkins-x.io/getting-started/create-cluster/#the-jx-create-cluster-gke-process" rel="noopener ugc nofollow" target="_blank">启用Kaniko作为默认方式，为您的所有Jenkins X CD作业构建和推送容器映像</a>，并将自动配置为推送至您安装Jenkins X和Kaniko缓存的云的默认容器注册表。这导致快速、安全的容器映像构建被推送到默认的Jenkins X容器注册表。</p><p id="d681" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">重要提示:</strong>根据<a class="ae lr" href="https://github.com/jenkins-x/jx/issues/1074" rel="noopener ugc nofollow" target="_blank">此GitHub问题</a>的追踪，Jenkins X没有OOTB对Pod安全策略的支持。在我的下一篇文章中，我们将看看在Jenkins X上使用Pod安全策略——但不仅仅是针对Kaniko，因为一旦您启用了Pod安全策略，每个K8s <code class="fe ls lt lu lv b">Role</code> / <code class="fe ls lt lu lv b">ClusterRole</code> <em class="lq">都必须有一个与之相关联的Pod安全策略。</em></p><ul class=""><li id="046c" class="lw lx it kw b kx ky la lb ld ly lh lz ll ma lp mb mc md me bi translated">需要以<code class="fe ls lt lu lv b">ROOT</code>的身份运行Kaniko容器来执行大多数容器构建</li><li id="ffcd" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp mb mc md me bi translated">无法与所有<code class="fe ls lt lu lv b">Dockerfiles</code>一起工作，但会不断改进</li><li id="2287" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp mb mc md me bi translated">比以前的<code class="fe ls lt lu lv b">docker build</code>稍微复杂一点</li></ul><p id="b3f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">强制使用特定的容器注册中心——例如，不允许从DockerHub这样的公共容器注册中心获取或向其推送。您应该维护自己的容器映像和容器注册表，包括至少有两个不同的容器注册表，一个用于CD容器映像(以及中间应用程序容器映像)，另一个用于生产批准的应用程序容器映像。实际上，我会更进一步，使用第三个容器注册表(类似于沙箱),它允许CD特定的容器映像和中间应用程序容器映像，这些映像尚未被批准用于更安全的环境，如生产环境，但可以在不太安全的测试环境中运行。</p><p id="1589" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在使用容器图像之前，请对其进行扫描。</p><p id="1640" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一篇关于使用带有Jenkins管道的Anchore的博客文章。它的设置非常简单，因此没有理由不扫描您的容器图像，并将扫描作为提升到更安全的容器注册的大门。</p><p id="a2f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他解决方案允许您使用基于Kubernetes Pod的容器构建和推送容器映像，并且不依赖于Docker守护进程:</p><ul class=""><li id="2231" class="lw lx it kw b kx ky la lb ld ly lh lz ll ma lp mb mc md me bi translated"><a class="ae lr" href="https://github.com/genuinetools/img" rel="noopener ugc nofollow" target="_blank"> img </a> : <strong class="kw iu"> img </strong>才0.5.7版本(2019 . 5 . 3发布)，但是这个项目很有前景。<strong class="kw iu"> img </strong>需要<a class="ae lr" href="https://github.com/genuinetools/img#upstream-patches" rel="noopener ugc nofollow" target="_blank">上游补丁</a>到不同的项目，最终应该使它成为从K8s Pod容器构建和推送容器映像的最安全(和快速)的方式。</li><li id="9b51" class="lw lx it kw b kx mf la mg ld mh lh mi ll mj lp mb mc md me bi translated"><a class="ae lr" href="https://github.com/GoogleContainerTools/jib" rel="noopener ugc nofollow" target="_blank"> jib </a> —另一个Google项目，<strong class="kw iu"> jib </strong>支持在没有Docker守护进程的情况下构建和推送容器图像。</li></ul><p id="e546" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你还没有，开始用Kubernetes上的Kaniko构建你的容器映像——使用Pod安全策略。</p><p id="de62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，如果你想让Kaniko快速、轻松地运行，那么你应该签出Jenkins X. Jenkins X将自动设置Kaniko，并进行必要的配置，以将容器映像推送到你选择的Docker注册表(GCR、ECR、Docker Hub等)。使用Jenkins X，您可以在几分钟内从GitHub中的docker文件转换为注册表中的容器图像。</p></div></div>    
</body>
</html>