<html>
<head>
<title>How To Poll Sockets Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python轮询套接字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-poll-sockets-using-python-3e1af3b047?source=collection_archive---------3-----------------------#2022-08-25">https://betterprogramming.pub/how-to-poll-sockets-using-python-3e1af3b047?source=collection_archive---------3-----------------------#2022-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a6b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种更快、更有效的与套接字交互的方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89fd494987d9c67f028f48fcf37d319f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOWqvsNKEGNXf-AMh68WSQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mvdheuvel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马腾·范·登·霍维尔</a>在<a class="ae ky" href="https://unsplash.com/s/photos/files?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在编写从网络套接字读取或写入的代码，您会希望这些操作尽可能地快速高效。也许你想在不影响速度和阻塞每个呼叫的情况下关注多个插座。在大多数情况下，从底层操作系统获取关于套接字上是否存在数据的信号实际上是一个非常简单的过程。</p><p id="194a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在使用Python，您可以访问一个强大的库来跟踪套接字状态。图书馆。</p><p id="267a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">select</code>你可以<code class="fe lv lw lx ly b">poll</code>一个特定的套接字或一组套接字用于任何输入或输出数据。这允许您观察多个套接字，而无需不断尝试与它们直接交互。与其试图获取不存在的数据，为什么不让操作系统告诉你它何时存在呢？</p><p id="efc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">poll</code>的一个主要优势是它允许你同时处理多个插座，而不会因为等待其中一个而卡住。</p><p id="69b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看。</p><h1 id="4d3a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">向套接字发送数据</h1><p id="17a8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了了解<code class="fe lv lw lx ly b">poll</code>是如何工作的，让一些测试数据流经几个套接字是有帮助的。这将有助于我们直观地看到数据何时出现在缓冲区中，以及当<code class="fe lv lw lx ly b">poll</code>告诉我们从套接字读取数据然后继续循环时，它会如何表现。</p><p id="02d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简单的<code class="fe lv lw lx ly b">sender</code>服务器的代码片段:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="0a54" class="na ma it ly b gy nb nc l nd ne"># sender.py</span><span id="b901" class="na ma it ly b gy nf nc l nd ne">import socket<br/>from time import sleep</span><span id="fc77" class="na ma it ly b gy nf nc l nd ne">socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><span id="c3e5" class="na ma it ly b gy nf nc l nd ne">while 1:<br/>    socket.sendto(b'hello', ('127.0.0.1', 9998))<br/>    print('sent data to socket_1')<br/>    sleep(1)<br/>    socket.sendto(b'hello', ('127.0.0.1', 9999))<br/>    print('sent data to socket_2')<br/>    sleep(1)</span></pre><p id="1dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下这是怎么回事:</p><ul class=""><li id="0d74" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">首先，我们初始化一个新的UDP套接字。</li><li id="56e3" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">接下来，我们开始一个无限循环。</li><li id="6c9c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在循环内部，我们使用回送地址将<code class="fe lv lw lx ly b">hello</code>发送到端口<code class="fe lv lw lx ly b">9998</code>和<code class="fe lv lw lx ly b">9999</code>的两个套接字。这是我们将在<code class="fe lv lw lx ly b">receiver</code>端监听的地方。</li><li id="dafb" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在每次发送操作之间，我们打印一条消息，说明数据已经发送，然后休眠一秒钟。</li></ul><p id="9f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是保持发送到两个套接字的数据流一致的简单方法，我们将等待使用<code class="fe lv lw lx ly b">poll</code>。现在，让我们看看如何构建这个场景的另一面。<code class="fe lv lw lx ly b">receiver</code>服务器。</p><h1 id="f663" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">设置接收器</h1><p id="1c17" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了<code class="fe lv lw lx ly b">poll</code>我们的套接字，我们需要创建一些。在本例中，我们将设置两个UDP套接字，并让它们使用主机上的环回地址监听两个不同的端口。这与我们刚刚在<code class="fe lv lw lx ly b">sender</code>代码中使用的地址和端口集相同:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="472d" class="na ma it ly b gy nb nc l nd ne"># receiver.py</span><span id="481d" class="na ma it ly b gy nf nc l nd ne">import socket<br/>import select</span><span id="c632" class="na ma it ly b gy nf nc l nd ne">socket_1 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br/>socket_2 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><span id="4f09" class="na ma it ly b gy nf nc l nd ne">socket_1.bind(('127.0.0.1', 9998))<br/>socket_2.bind(('127.0.0.1', 9999))</span><span id="f0fa" class="na ma it ly b gy nf nc l nd ne">poller = select.poll()<br/>poller.register(socket_1, select.POLLIN)<br/>poller.register(socket_2, select.POLLIN)</span><span id="aa30" class="na ma it ly b gy nf nc l nd ne">while 1:<br/>    evts = poller.poll(5000)<br/>    for sock, evt in evts:<br/>        if evt and select.POLLIN:<br/>            if sock == socket_1.fileno():<br/>                socket_1.recvfrom(4096)<br/>                print('received poll event from socket_1')<br/>            if sock == socket_2.fileno():<br/>                socket_2.recvfrom(4096)<br/>                print('received poll event from socket_2')</span></pre><p id="65f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，让我们分解这段代码，看看它到底在做什么:</p><ul class=""><li id="ae61" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们设置两个UDP套接字，然后将它们绑定到我们从<code class="fe lv lw lx ly b">sender</code>使用的环回地址和端口。</li><li id="276b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">接下来，我们创建一个<code class="fe lv lw lx ly b">poll</code>实例，并为其创建<code class="fe lv lw lx ly b">register</code>两个套接字。该方法接受套接字作为第一个参数，接受“<a class="ae ky" href="https://docs.python.org/3/library/select.html#select.poll.register" rel="noopener ugc nofollow" target="_blank">事件</a>”作为下一个参数。每个事件对应于套接字上的一个动作。这可能意味着数据正在输入或准备输出。在我们的例子中，我们将使用<code class="fe lv lw lx ly b">POLLIN</code>来表示套接字上的数据已准备好接收。</li><li id="c593" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">开始一个无限循环，我们开始轮询。<code class="fe lv lw lx ly b">poll</code>的参数是以毫秒为单位的超时。如果在超时时间内没有收到任何事件，此操作将会失败。因为我们是在一个无限循环中，这没什么大不了的，我们只是重新开始循环，等待事件再次发生。我们还将超时设置为高于我们发送<code class="fe lv lw lx ly b">sender</code>代码的速率，因此理想情况下永远不会超时。</li><li id="f64e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">收集事件后，我们通过套接字和事件类型遍历它们。</li><li id="aa38" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">对于每一对，我们将带有数据的轮询套接字文件描述符与我们的原始套接字对象进行比较，如果它们匹配，我们就从套接字中读取。<code class="fe lv lw lx ly b">recvfrom</code>的参数是以字节为单位的缓冲区大小。</li><li id="6fae" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">最后，我们打印一条消息，说明我们收到了一些数据，循环重新开始寻找新的事件。</li></ul><h1 id="0189" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">把所有的放在一起</h1><p id="5c8c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在我们已经有了我们的<code class="fe lv lw lx ly b">sender</code>和<code class="fe lv lw lx ly b">receiver</code>让我们试一试。首先启动<code class="fe lv lw lx ly b">receiver</code>。这应该什么也不输出，只是坐在那里等待流量:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="ac0e" class="na ma it ly b gy nb nc l nd ne">python3 receiver.py</span></pre><p id="4d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，启动<code class="fe lv lw lx ly b">sender</code>:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="5e65" class="na ma it ly b gy nb nc l nd ne">python3 sender.py</span></pre><p id="5396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您应该看到消息在两端输出。<code class="fe lv lw lx ly b">sender</code>应该告知何时向每个套接字发送消息。<code class="fe lv lw lx ly b">receiver</code>应说明何时接收到消息以及在哪个套接字上:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="409a" class="na ma it ly b gy nb nc l nd ne">&gt;&gt;&gt; sender<br/>sent data to socket_1<br/>sent data to socket_2<br/>sent data to socket_1<br/>sent data to socket_2</span><span id="46a8" class="na ma it ly b gy nf nc l nd ne">&gt;&gt;&gt; receiver<br/>received poll event from socket_1<br/>received poll event from socket_2<br/>received poll event from socket_1<br/>received poll event from socket_2</span></pre><p id="eb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功运行这个示例代码后，您可以开始将<code class="fe lv lw lx ly b">poll</code>方法应用到您自己的代码中。您可以添加不同类型的轮询事件，以创建更高效的写入或错误处理操作。</p><p id="60d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看官方的<code class="fe lv lw lx ly b">select</code>库<a class="ae ky" href="https://docs.python.org/3/library/select.html#select.poll.register" rel="noopener ugc nofollow" target="_blank">文档</a>了解关于实现<code class="fe lv lw lx ly b">poll</code>的细节。</p><h1 id="063e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">为什么要投票？</h1><p id="4446" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果不小心的话，读写多个套接字可能会成为一项非常昂贵的操作。根据数据量和套接字数量，正常的阻塞操作最终会导致性能下降。使用<code class="fe lv lw lx ly b">poll</code>,你可以通过让操作系统告诉你何时执行读写操作来避免大量的开销。这比一次尝试一个插座更有效。</p><p id="f91e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果一个套接字使用<code class="fe lv lw lx ly b">poll</code>在另一个没有数据的套接字之前接收到大量的数据，您会马上得到通知。你不必等待没有数据的套接字。随着套接字和操作数量的增加，您应该会看到使用<code class="fe lv lw lx ly b">poll</code>后效率有了相当大的提高。</p></div></div>    
</body>
</html>