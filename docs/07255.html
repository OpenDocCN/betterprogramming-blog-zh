<html>
<head>
<title>How Can We Measure Our Software’s Modularity and Dependencies?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何度量软件的模块性和依赖性？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/inside-software-modularity-and-related-metrics-2e5af2b447dc?source=collection_archive---------4-----------------------#2020-12-23">https://betterprogramming.pub/inside-software-modularity-and-related-metrics-2e5af2b447dc?source=collection_archive---------4-----------------------#2020-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edbb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是模块化，有哪些度量标准可以用来衡量模块化？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f8be1899a9e7f8b3d18dd208bc29196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-iAOpwdTn3keXkKvwf-QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">依赖外部或外部耦合。图片由作者提供。</p></figure><h1 id="86fc" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="8498" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在本文中，我将讨论模块化:什么是模块化？为什么重要？我们如何衡量模块化？</p><p id="c22f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">模块化包括将一个系统分成单独和独立的部分，称为<em class="mr">组</em>或<em class="mr">模块。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/5246c07ae47622cce8fffd4d9cb76156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USFHGo8CoUCEFrjVXTixxw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模块化应用。图片由<a class="ae mt" href="https://unsplash.com/@kieran_wood" rel="noopener ugc nofollow" target="_blank"> Kieran Wood </a>在<a class="ae mt" href="https://unsplash.com/photos/UOk1ghQ7juY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><ul class=""><li id="0489" class="mu mv it ls b lt mm lw mn lz mw md mx mh my ml mz na nb nc bi translated">我们可以将一个应用程序分成独立的技术层:业务层、持久层、UI层和数据库层</li><li id="7757" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">我们可以将一个应用程序分成独立的功能层:用户、支付、订单等。</li><li id="6bbf" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">我们可以将相关的方法分组到一个类中(<code class="fe ni nj nk nl b">Car:</code> <code class="fe ni nj nk nl b">move</code>、<code class="fe ni nj nk nl b">accelerate</code>、<code class="fe ni nj nk nl b">park</code>、<code class="fe ni nj nk nl b">setPreferences</code>等等)。)</li></ul><h2 id="ade7" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">模块化对重用和可维护性有直接影响</strong></h2><p id="e678" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">良好的模块组织和划分增加了清晰性和可维护性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/0a9c9b467334d69b5db3a66cfcd89514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STABUrloDXDRs1WLAawqjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非模块化与模块化。图片由作者提供。</p></figure><p id="506a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">同一组内的元素之间的关系是根据共同的功能属性(认证、支付、交付等)定义的。)或技术(业务、服务、持久性、UI等。).</p><p id="3b93" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个定义让我们想起了一个数学理论，它已经处理了组、它们的元素、它们的关系以及它们的运算:<a class="ae mt" href="https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation" rel="noopener ugc nofollow" target="_blank">集合论</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cf19d75ccde19f754cb0bb57603b6cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQmcTDw8ohsaNbnqp3CVFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">集合内部耦合强，外部依赖弱。图片由作者提供。</p></figure><p id="f6b0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了解释模块化，我将参考一些set原则。我不是从微观的角度(例如，作为数据结构的集合)而是从宏观的角度来做这件事。</p><p id="913e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后，因为模块化是一个数学概念，我们可以测量它:一个架构的模块化程度如何？这些模块有多独立？模块内部的元素有多紧密？</p><p id="ecfb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们开始吧！</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="dbb2" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">模块化:数学方面(集合)</h1><p id="9370" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一个<em class="mr">集合</em>是共享一个公共属性的元素的集合，并根据这个公共属性聚集在一起。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/518ffd81c736d6761ba1ae79f768dc13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMgSlitYrdwDbh_14CTV7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同的元素集合。图片由作者提供。</p></figure><p id="8a68" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在每个集合中，元素之间有很强的联系，而与其他集合中的元素的联系相对较弱。</p><p id="eafe" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其他已知类型的器械包:</p><ul class=""><li id="1ea7" class="mu mv it ls b lt mm lw mn lz mw md mx mh my ml mz na nb nc bi translated"><code class="fe ni nj nk nl b">∅</code>表示空集</li><li id="9032" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated"><code class="fe ni nj nk nl b">Z</code>表示整数集合</li><li id="dff4" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated"><code class="fe ni nj nk nl b">R</code>表示实数集合</li><li id="c833" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated"><code class="fe ni nj nk nl b">N</code>表示自然数的集合</li></ul><blockquote class="om on oo"><p id="bcbf" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">在数学中，集合是明确定义的不同元素或成员的集合。构成集合的元素可以是任何东西:人、字母表中的字母或数学对象，如数字、空间中的点、线或其他几何形状、代数常数和变量或其他集合</p><p id="8dda" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">——贾恩·艾哈迈德通过维基百科</p></blockquote><ul class=""><li id="cf26" class="mu mv it ls b lt mm lw mn lz mw md mx mh my ml mz na nb nc bi translated"><em class="mr">定义明确的</em>意味着对于任何元素，问题“这个元素属于集合吗？”有一个明确的是或不是的答案</li><li id="b427" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">不同的元素意味着集合中的元素不会被计算两次</li></ul><blockquote class="om on oo"><p id="d513" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">在计算机科学中，关注点分离(SoC)是一种将计算机程序分成不同部分的设计原则，每个部分处理一个单独的关注点— <a class="ae mt" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><p id="c0e9" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">“DRY原则被表述为‘每个知识都必须在一个系统中有一个单一的、明确的、权威的表示。’”——<a class="ae mt" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><p id="c698" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">“单一责任原则(SRP)规定每个软件模块应该有且只有一个变更的理由。”罗伯特·马丁</p></blockquote><p id="72ef" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一个<em class="mr">软件模块</em>仅仅是一组具有某种共同属性的部分或层的集合(一个<em class="mr">关注点</em>)。公共属性可以是功能性的(认证、支付、交付等)。)或技术(业务、服务、持久性、UI等。).</p><p id="c156" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在面向对象编程中，<em class="mr">类</em>是一组转换成员变量的成员方法。</p><p id="7362" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">集合在结构上彼此独立，但它们可以组合在一起形成其他集合。</p><p id="a026" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">例如，我们可以将我们的<code class="fe ni nj nk nl b">Clothes</code>集合、<code class="fe ni nj nk nl b">Transport</code>集合和<code class="fe ni nj nk nl b">Foods</code>集合组合成一个独特的上下文/集合，称为<code class="fe ni nj nk nl b">Human needs</code>。</p><ul class=""><li id="c414" class="mu mv it ls b lt mm lw mn lz mw md mx mh my ml mz na nb nc bi translated">人类需要穿衣服</li><li id="7a07" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">人们需要一种交通工具去工作、拜访家人、旅行等。</li><li id="b888" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">人类需要食物才能生存</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/b3a5e478022679c658bdfaa9523a0278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMPq6A8vRMWL0CwKquAv5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全球环境—应用程序。图片由作者提供。</p></figure><p id="1920" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以将不同的独立模块组合成一个单一的全局环境:应用程序。</p><p id="263b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">顺便说一下，<code class="fe ni nj nk nl b">Human needs</code>是一个集合，<code class="fe ni nj nk nl b">Clothes</code>、<code class="fe ni nj nk nl b">Transport</code>和<code class="fe ni nj nk nl b">Foods</code>现在是子集。</p><p id="8c2c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">子集保持相同的集合属性。</p><p id="29c2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们还可以在子集内定义独立的子集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/f337cc0da6f466dca47825d2851a700c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POx51J-ce3y92EEa5VzeMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">子集运输现在有了自己的子集:空运、陆运和海运。图片由作者提供。</p></figure><p id="8596" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当我们有一个复杂的全球背景时，我们可以把它分成小的独立的子背景。</p><blockquote class="om on oo"><p id="a97e" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">“一个复杂的系统可以通过把它分成更小的部分，并分别看待每一个来管理。”</p><p id="a653" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated"><strong class="ls iu"> — </strong> Carliss Y. Baldwin和Kim B. Clark在《设计规则:模块化的力量》</p></blockquote><h2 id="98f4" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">集合或子集也可以有共享元素</strong></h2><p id="4c33" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当我们乘坐飞机、轮船、火车或汽车旅行时，我们可以使用/带上地图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/4c9f33f1d3f357e97e6e90a85224d35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyWocDFyP0B78VLA_rnF7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该映射在不同的传输子集之间共享。图片由作者提供。</p></figure><p id="0446" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">不同子集的交集就是映射子集。</p><p id="28f3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">{1, 2} ∩ {2, 3} = {2}.<br/> {1，2} ∩ {3，4} = ∅.</p><p id="28e1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">每个元素在一个集合中只能存在一次:</p><blockquote class="om on oo"><p id="ea58" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">“集合是我们的感知和思维的一个集合，集合成一个确定的、不同的对象的整体，这些对象被称为集合的元素。”</p><p id="260d" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">—集合论的创始人乔治·康托尔</p></blockquote><p id="c25c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当集合或子集之间有重复或公共元素时:</p><blockquote class="om on oo"><p id="fac5" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated"><strong class="ls iu">"也可以通过确定两个集合中哪些成员有共同的'【T13'来构造一个新的集合</strong>——<a class="ae mt" href="https://en.wikipedia.org/wiki/Set_(mathematics)#Intersections" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="54a9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果模块或类共享公共元素，我们创建一个公共的共享模块或类(干:不要重复自己)。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="c26b" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">我们能从集合论中保留什么？</h1><h2 id="9ec4" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated">集合和元素</h2><ul class=""><li id="9b12" class="mu mv it ls b lt lu lw lx lz ou md ov mh ow ml mz na nb nc bi translated">内部集合内聚性(元素根据一个公共标准被强有力地组合在一起)</li><li id="87e5" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">默认情况下，集合中的元素是内聚的</li><li id="b701" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">集合中的每个元素只存在一次(DRY和SRP)</li><li id="ff02" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">一个集合独立于其他集合(松散外部耦合，SoC)</li><li id="1ab4" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">分解(子集)</li><li id="836d" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">集合或子集之间公共元素的新集合(干)</li></ul><h2 id="8117" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated">软件模块化是一个<strong class="ak">数学方面</strong></h2><ul class=""><li id="d1b7" class="mu mv it ls b lt lu lw lx lz ou md ov mh ow ml mz na nb nc bi translated">模块是一组部分或层</li><li id="572a" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">类是一组成员方法</li></ul></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="fd18" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">集合论在软件中的应用实例:分层体系结构</h1><p id="7a97" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在分层架构中，共同的属性是技术角色。我们根据它们的技术角色对文件、类或代码进行分组:表示、业务、持久性和数据库。</p><h2 id="2593" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated">我们有四套</h2><ul class=""><li id="d405" class="mu mv it ls b lt lu lw lx lz ou md ov mh ow ml mz na nb nc bi translated">演示文稿集:{HTML，CSS}</li><li id="375e" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">业务集:{UI逻辑适配器，接口}</li><li id="9931" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">持久性集= {ORM}</li><li id="6448" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated">数据库集= {表，SQL查询}</li></ul><p id="fc56" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">每个集合还可以分成子集。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="33f5" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">集合论在软件中应用的例子<strong class="ak"> <em class="ox"> : SOA架构</em> </strong></h1><p id="7082" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在SOA架构中，我们根据它们的功能角色对文件、类或代码进行分组:书籍、订单、帐户、用户等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/9d5956ccc9532cbce406903b7f776f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdLc7gDuJeT_4u4Jf6sb9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mt" href="https://subscription.packtpub.com/book/application_development/9781789133608/1/ch01lvl1sec12/service-oriented-architecture-soa" rel="noopener ugc nofollow" target="_blank">通过Dinesh Rajput的“动手微服务—监控和测试”</a></p></figure></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="65ad" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">如何衡量模块化</h1><p id="b3ee" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">因为模块化是一个数学概念，我们可以测量:</p><ul class=""><li id="e26d" class="mu mv it ls b lt mm lw mn lz mw md mx mh my ml mz na nb nc bi translated">内部群体凝聚力</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/c383ba519775c44619b1cd2a2c21a682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THAmp9X54L3hvbJHSCvuPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内部凝聚力。图片由作者提供。</p></figure><ul class=""><li id="5ab4" class="mu mv it ls b lt mm lw mn lz mw md mx mh my ml mz na nb nc bi translated">软件模块之间的相互依赖程度或耦合程度</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f8be1899a9e7f8b3d18dd208bc29196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-iAOpwdTn3keXkKvwf-QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对外部或外部耦合的依赖性。图片由作者提供。</p></figure></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="c978" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">内聚力</h1><h2 id="c07a" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">定义</strong></h2><blockquote class="om on oo"><p id="7af0" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">"在计算机编程中，内聚性指的是一个模块中的元素属于一起的程度."</p><p id="a5d4" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">——爱德华·尤顿和拉里·l·康斯坦在《结构化设计:计算机程序和系统设计学科的基础》中</p></blockquote><h2 id="f374" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">类型</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/d7eca9b851206bb7a533567eded24ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUV5qTj8k8y4R8xaK3WSxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mt" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)#Types_of_cohesion" rel="noopener ugc nofollow" target="_blank">衔接类型</a>。图片由作者提供。</p></figure><p id="10e9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="mr">功能内聚</em>是模块的各个部分被分组，因为它们都有助于模块的一个明确定义的任务。</p><p id="71e7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="mr">顺序内聚</em> <strong class="ls iu"> </strong>是指模块的各个部分被分组，因为一个部分的输出是另一个部分的输入(例如，从文件中读取数据并处理数据的函数)。</p><h2 id="5639" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">测量凝聚力</strong></h2><p id="7b03" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">以下集合中的元素没有内聚性:元素被任意分组；各部分之间的唯一关系是它们被组合在一起(巧合的内聚)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/fcfb79e4f25806d1a5bb6e498ac4f17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxNIekO16b7x00eV-OgN8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非粘性基团。图片由作者提供。</p></figure><p id="7c2c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当一个集合中的元素不共享任何公共属性时，该集合就失去了其<em class="mr">明确定义的</em>特征，并且我们无法确保<em class="mr">明确的</em>标准，因为在该集合中没有定义归属的属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/4c2aafa7be5c8423fde427afb4ced05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNKnaYRS2rtOd2WQORQYSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内聚子集。图片由作者提供。</p></figure><p id="93aa" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">集合中的元素必须是内聚的；否则，我们将不得不继续分解，直到我们有内聚的子集。</p><h2 id="9432" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">阶级凝聚力(</strong><a class="ae mt" href="https://maisqual.squoring.com/wiki/index.php/Lack_of_Cohesion_in_Methods#cite_note-1" rel="noopener ugc nofollow" target="_blank"><strong class="ak"/></a><strong class="ak">)</strong></h2><p id="c9a5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">例如:</strong></p><p id="4fd5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">考虑一个有三种方法的类<code class="fe ni nj nk nl b">C</code>:<code class="fe ni nj nk nl b">M1</code>、<code class="fe ni nj nk nl b">M2</code>和<code class="fe ni nj nk nl b">M3</code>。</p><p id="d1f5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">设<code class="fe ni nj nk nl b">{Ij}</code> =方法<code class="fe ni nj nk nl b">Mi</code>使用的实例变量集</p><p id="8856" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让<code class="fe ni nj nk nl b">{I1}</code> = <code class="fe ni nj nk nl b">{a,b,c,d,e}</code>和<code class="fe ni nj nk nl b">{I2}</code> = <code class="fe ni nj nk nl b">{a,b,e}</code>和<code class="fe ni nj nk nl b">{I3}</code> = <code class="fe ni nj nk nl b">{x,y,z}</code></p><ul class=""><li id="daf1" class="mu mv it ls b lt mm lw mn lz mw md mx mh my ml mz na nb nc bi translated"><code class="fe ni nj nk nl b">{I1} ∩ {I2}</code>非空</li><li id="904c" class="mu mv it ls b lt nd lw ne lz nf md ng mh nh ml mz na nb nc bi translated"><code class="fe ni nj nk nl b">{I1} ∩ {I3}</code>和<code class="fe ni nj nk nl b">{I2} ∩ {I3}</code>是空集</li></ul><p id="b744" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">LCOM =空交叉点的数量-非空交叉点的数量。</p><p id="612b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在我们的例子中，LCOM = <code class="fe ni nj nk nl b">2-1</code> = <code class="fe ni nj nk nl b">1</code>。</p><p id="1166" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">通用公式:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/5ab7f43eba700548c7cb9877d61f608e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Og61tPeKadvPHXvqB6O1tA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凝聚力通用公式</p></figure><blockquote class="om on oo"><p id="9b38" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated"><strong class="ls iu"> <em class="it"> "P = {(Ii，Ij) | Ii ∩ Ij = φ} </em> </strong> <em class="it">和</em> <strong class="ls iu"> <em class="it"> Q = {(Ii，Ij) | Ii ∩ Ij ≠ φ} </em> </strong></p><p id="9ef9" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">取类中的每一对方法。如果它们访问不相交的实例变量集，则将P增加1。如果它们共享至少一个变量访问，则Q增加1。</p><p id="badb" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">LCOM是相似度为零的方法对的计数。</p><p id="973c" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">LCOM = 0表示一个内聚类。</p><p id="1c17" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">LCOM &gt; 0表示该类需要或可以分成两个或更多个类，因为它的变量属于不相交的集合。"</p><p id="1ef9" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">— <a class="ae mt" href="https://www.aivosto.com/project/help/pm-oo-cohesion.html" rel="noopener ugc nofollow" target="_blank">奇丹博和凯梅勒</a></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/75ba24c79d708fba76a2f5d2d95997d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KpeCxPXpG69eYtqkIgjWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺乏内聚力——分裂成子类。图片由作者提供。</p></figure></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="c28c" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">连接</h1><h2 id="8c33" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">定义</strong></h2><blockquote class="om on oo"><p id="0714" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">“在软件工程中，耦合是软件模块之间相互依赖的程度；衡量两个例程或模块的紧密程度— <a class="ae mt" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><h2 id="36b2" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">类型</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/5ab8586d948fe51c137356dc5cb62d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gedD8AyxR5ZceUDdBXOig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mt" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Types_of_coupling" rel="noopener ugc nofollow" target="_blank">联轴器</a>类型。图片由作者提供。</p></figure><p id="51fe" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">低耦合通常是结构良好的计算机系统和良好设计的标志，当与高内聚结合时，它是高可读性和可维护性的标志。</p><h2 id="f180" class="nm kz it bd la nn no dn le np nq dp li lz nr ns lk md nt nu lm mh nv nw lo nx bi translated"><strong class="ak">测量联轴器</strong></h2><p id="53f8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">传出耦合(</strong> <code class="fe ni nj nk nl b"><strong class="ls iu">CE</strong></code> <strong class="ls iu"> ) </strong></p><p id="c1c7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe ni nj nk nl b">CE</code>测量包内依赖于包外类的类的总数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/9cb0df2cc5946f3d4c9129f0bee0fab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xqmgk148XJ3CjsnMzxIC4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">传出耦合示例。图片由作者提供。</p></figure><p id="b48b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在上面的例子中，<code class="fe ni nj nk nl b">Module A</code>对其他三个类有输出依赖。</p><p id="ec75" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">指标<code class="fe ni nj nk nl b">CE&gt;20</code>的高值表示包的不稳定性——众多外部类中的任何一个发生变化都会导致需要对包进行更改。指标<code class="fe ni nj nk nl b">CE</code>的优选值在0到20的范围内——较高的值会给代码的维护和开发带来问题。</p><p id="48e0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">传入耦合(</strong> <code class="fe ni nj nk nl b"><strong class="ls iu">CA</strong></code> <strong class="ls iu"> ) </strong></p><p id="7ac9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe ni nj nk nl b">CA</code>测量依赖于包内类的包外类的总数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/d6dbc1488fee225ca387ebfd5aa14286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXV4jMvUOdR6H5-nhrme4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">传入耦合示例。图片由作者提供。</p></figure><p id="401e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在上面的例子中，<code class="fe ni nj nk nl b">Module A</code>有两个传入的依赖项。</p><p id="0583" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe ni nj nk nl b">CA</code>指标与便携性高度相关。具有更高<code class="fe ni nj nk nl b">CA</code>的包是坏包，因为它们更难被替换，因为它们有许多其他依赖它们的包。度量<code class="fe ni nj nk nl b">CA</code>的优选值在0到500的范围内。</p><p id="f02b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">不稳定</strong></p><p id="a1ce" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">此指标衡量包的不稳定性，其中<em class="mr">稳定性</em>通过计算在不影响应用程序中其他包的情况下更改包的工作量来衡量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/ab2dd72e3b519aad093fabf360debb6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CHbx5K4Llh7adznym4CUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模块不稳定。图片由作者提供。</p></figure><p id="0ff5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><code class="fe ni nj nk nl b">Instability I = CE / (CE + CA)</code></p><blockquote class="om on oo"><p id="2b46" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">"此度量产生范围[0，1]内的结果。值I=0表示不依赖于任何东西的最大稳定包，I=1表示不具有输入依赖性但依赖于其他包的完全不稳定包。因此，不稳定性会对可重用性、可维护性和可移植性产生负面影响。”</p><p id="29a8" class="lq lr mr ls b lt mm ju lv lw mn jx ly op mo mb mc oq mp mf mg or mq mj mk ml im bi translated">— <a class="ae mt" href="https://pdfs.semanticscholar.org/18ce/e8682c75f8ed069891f67731d159d3b8c5ff.pdf" rel="noopener ugc nofollow" target="_blank"> Gurpreet Kaur和Deepak Sharma在“使用模糊逻辑研究Robert C.Martin的数据包分类指标”</a></p></blockquote></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="370f" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">结论</h1><p id="2480" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在本文中，我们讨论了什么是模块化，为什么它很重要，以及我们可以测量它。</p><p id="1aee" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">内聚性是衡量软件设计在SRP和SoC原则方面有多好的一个标准:如果一个模块或一个类中的元素没有内聚性，这表示多重责任和过度责任。在这种情况下，它们应该被分开。</p><p id="03b7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一段没有关注和责任分离的代码就像一个没有椅子、墙壁、门和窗户的房子:一切都是开放的。一切都一起改变(回归测试必须测试一切——相关和不相关的代码)。</p><p id="6cf8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当我们缺乏凝聚力、SRP和SoC时，我们就缺乏模块化。(没有凝聚力、SRP和SoC，就没有边界或团体。然后也没有模块——只有一大块。</p><p id="bf13" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一个没有内聚性的类或模块就像一个无序的车库，在那里我们随机快速地扔出所有东西。很难找到东西。</p><p id="f3bc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">凝聚力衡量的是一个群体内部各元素的关联程度——这就是为什么凝聚力必须很高的原因。</p><p id="2fba" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当内聚力较低时，这表明SRP和SoC原则已被破坏。</p><p id="a8f0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">另一方面，群体对其环境的影响或群体与其环境之间的相互作用必须尽可能的弱——仅仅为了必要的需要。</p><p id="ed2d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">与外部的强耦合对可维护性、重构和稳定性有很大的影响。对于一个类或模块的每一个小的变化或发展，我们应该验证每一个链接仍然工作。</p><p id="eeba" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">当传出耦合(CE)、传入耦合(CA)和不稳定性很高时，这给出了关于设计有多弱以及每个改变和重构有多弱的想法。</p><p id="b987" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我建议在软件设计和开发过程中使用这些度量标准，这样你就不会欠下一大笔债。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="366b" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">进一步的信息</h1><div class="pg ph gp gr pi pj"><a href="https://www.amazon.fr/Fundamentals-Software-Architecture-Comprehensive-Characteristics/dp/1492043451" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">软件架构基础:工程方法</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">诺特/5。软件架构基础:工程方法和数百万库存…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">www.amazon.fr</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a href="https://www.amazon.fr/Building-Evolutionary-Architectures-Support-Constant/dp/1491986360" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">构建进化架构:支持不断的变化</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">诺特/5。建造进化的建筑:支持股票市场的持续变化和数百万里弗…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">www.amazon.fr</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ks pj"/></div></div></a></div></div></div>    
</body>
</html>