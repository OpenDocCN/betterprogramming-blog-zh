<html>
<head>
<title>React 16: Testing Function Components With Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 16:用钩子测试功能组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-16-testing-function-components-with-hooks-f63705e2570?source=collection_archive---------3-----------------------#2019-11-19">https://betterprogramming.pub/react-16-testing-function-components-with-hooks-f63705e2570?source=collection_archive---------3-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="78b5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Jest和Enzyme测试有状态组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8ea3e94331ab3b8bf997a712f320188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hGrNltllluHglUC09kyJw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·萨卡奇斯在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="feb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可能的话，应该将有状态逻辑和视图分开。通常情况下，您可以通过Redux风格的缩减器和无状态组件来实现这一点。这两者都很容易测试，并且可以成为应用程序的最大部分。</p><p id="adc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有时您可能仍然想测试有状态的组件，或者只是不想重构来使用reducers。尤其是当状态变化异步发生时，事情会变得棘手。在本文中，我将告诉你如何使用React 16、<a class="ae ky" href="https://jestjs.io/en/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae ky" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>来测试各种情况下的有状态组件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1409" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建示例应用程序</h1><p id="9e55" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从使用create-react-app创建一个示例应用程序开始</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6488" class="ne md it na b gy nf ng l nh ni">npx create-react-app react16-testing</span></pre><p id="0bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以通过运行<code class="fe nj nk nl na b">npm run test</code>轻松地运行测试。之后，我们编辑<code class="fe nj nk nl na b">src/App.js</code>并添加一个最小的例子用于我们的测试。我们创建一个功能组件，它使用了<code class="fe nj nk nl na b">useState</code>钩子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得一些视觉反馈，请在app.css中添加以下代码行。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b6ce" class="ne md it na b gy nf ng l nh ni">.box { color: white; }<br/>.blue { background-color: blue; }<br/>.red { background-color: red; }<br/>.green { background-color: green; }</span></pre><p id="87be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的应用程序将简单地显示3个<code class="fe nj nk nl na b">button</code>元素和1个带<code class="fe nj nk nl na b">background-color</code>的<code class="fe nj nk nl na b">div</code>，这取决于你点击了哪个按钮。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4790" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装测试依赖项</h1><p id="dfa8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们想测试组件在点击按钮后是否显示正确的类。我们将使用来自Enzyme的<code class="fe nj nk nl na b">shallow()</code>渲染API来完成。您可以安装相关的依赖项:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="197b" class="ne md it na b gy nf ng l nh ni">npm install --save enzyme enzyme-adapter-react-16 react-test-renderer</span></pre><p id="4018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，您必须用一些初始命令创建<code class="fe nj nk nl na b">./src/setupTests.js</code>，这些命令应该在测试开始之前运行。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fbe2" class="ne md it na b gy nf ng l nh ni">import { configure } from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';<br/>configure({ adapter: new Adapter() });</span></pre><p id="3895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React 16之前，如果我们想使用状态，我们必须使用类组件。那时，您可以简单地呈现您想要测试的组件，并可以直接在该组件上调用<code class="fe nj nk nl na b">setState()</code>来测试该组件在状态改变时是否行为正确。随着功能组件中钩子的引入，这不再可能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1137" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用酶测试具有钩子的功能部件</h1><p id="affd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">但是，您仍然可以手动触发相关事件，从而改变状态。下面是一个例子:<code class="fe nj nk nl na b">App.test.js</code>，它点击最后一个按钮触发一个状态改变和一次重新渲染。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您通常希望使用默认事件来访问数据属性，如下面的示例所示，而不是将值直接绑定到函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做之后，我们的测试将会失败，因为我们的<code class="fe nj nk nl na b">simulate</code>函数在默认情况下没有通过一个事件。我们不得不嘲笑它(见下面的例子)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff81" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试异步状态的功能组件</h1><p id="510a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，在现实世界应用程序中，您的状态更改可能会被异步触发。如果我们在<code class="fe nj nk nl na b">handleClick</code>中的状态变化是异步发生的，就像下面的例子，我们的测试也会失败。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b6b9" class="ne md it na b gy nf ng l nh ni">function handleClick(e) {<br/>    setTimeout(() =&gt; {<br/>        changeColor(e.target.getAttribute('data-color'));<br/>    }, 1000);<br/>}</span></pre><p id="e9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，状态将在一秒钟后改变，并且在重新渲染之前测试已经完成。我们在这里可以做的是在<code class="fe nj nk nl na b">handleClick</code>中返回一个<code class="fe nj nk nl na b">Promise</code>，它在状态改变后被解析。在我们的<code class="fe nj nk nl na b">App.test.js</code>中，我们可以使用<code class="fe nj nk nl na b">async/await</code>来等待状态变化的发生。有关更多详细信息，请查看jestjs async tutoria  l。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6f17" class="ne md it na b gy nf ng l nh ni">function handleClick(e) {<br/>    const node = e.target;<br/>    return new Promise(resolve =&gt; {<br/>        setTimeout(() =&gt; {<br/>            changeColor(node.getAttribute('data-color'));<br/>            resolve();<br/>        }, 1000);<br/>    });<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="79ec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使有状态功能组件可测试</h1><p id="ea02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，为了使带有钩子的函数组件可测试，触发状态改变的函数:</p><ul class=""><li id="79d7" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">必须作为道具，这样我们才能手动触发它</li><li id="fa90" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">如果使用模拟事件中的值，则需要模拟事件</li><li id="5978" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">如果状态变化异步发生，必须返回一个<code class="fe nj nk nl na b">Promise</code></li></ul></div></div>    
</body>
</html>