<html>
<head>
<title>Highly Customizable Network Layer in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5中高度可定制的网络层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/highly-customizable-network-layer-in-swift-5-1e5c1e163674?source=collection_archive---------0-----------------------#2019-09-29">https://betterprogramming.pub/highly-customizable-network-layer-in-swift-5-1e5c1e163674?source=collection_archive---------0-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b2c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">准备一个API请求，调用一个API，并解析响应</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b7327f28f8ad54ab894721941e065ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73f33DTb5XsNfE1R7CIY0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>在<a class="ae ky" href="https://unsplash.com/s/photos/network-coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="13a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文主要关注网络层的简单性、<strong class="lb iu"> </strong>可定制性、<strong class="lb iu">、</strong>和模块化。我的方法已经在许多项目中得到验证和测试，我一直在更新我的网络层，以包含我在开发过程中面临的问题。</p><p id="bbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以从<a class="ae ky" href="https://github.com/waseemwk22/NetworkLayerSwift" rel="noopener ugc nofollow" target="_blank"> Github </a>下载完整的源代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">金科玉律</h1><p id="c29c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在您开始阅读本文之前:</p><ol class=""><li id="e972" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">视图控制器不应该知道网络API。他们甚至不应该关心数据是来自API还是本地数据库，例如Coredata或SQLite。</li><li id="46ca" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">唯一应该调用网络API的层是服务层。</li><li id="887f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">视图控制器应该请求服务提供数据。</li><li id="1874" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">服务不应该知道API服务器以及发送到API服务器或从API服务器接收的数据的格式。</li><li id="6e8a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">只有网络层应该知道这些细节。</li></ol><p id="f5d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将涵盖的内容:</p><ol class=""><li id="85fb" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">准备一个API请求:<strong class="lb iu"/>&lt;API请求&gt;</li><li id="717b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">调用一个API: <alamofire/></li><li id="162c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">解析响应:<strong class="lb iu"> </strong> <em class="nn"> &lt; </em>可编码<em class="nn"> &gt; </em></li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a2d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.准备请求</h1><p id="ea2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个网络请求都由某些属性标识:</p><ol class=""><li id="3eb5" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu">端点:</strong>网络API的路径</li><li id="ab4b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">HTTP方法类型:GET、POST、PUT、DELETE、PATCH等。</li><li id="81f9" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">请求参数:</strong> JSON或字符串</li><li id="664d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">响应类型:<strong class="lb iu"> </strong> JSON、XML或字符串</li></ol><h2 id="7e69" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><strong class="ak">终点</strong></h2><p id="3f98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们以一个通过用户名<code class="fe oa ob oc od b">get-stories-by-username</code>返回故事的API为例</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="69cb" class="no md it od b gy oi oj l ok ol">// GET All stories by username</span><span id="26d9" class="no md it od b gy om oj l ok ol">https:www.medium.com/api/v1.0/stories/waseem_khan</span><span id="3f2b" class="no md it od b gy om oj l ok ol">// server-url/api-path/api-version/resource-name/end-point</span><span id="52f1" class="no md it od b gy om oj l ok ol">// server-url    -&gt; https:www.medium.com/<br/>// api-path      -&gt; api/<br/>// api-version   -&gt; v1.0/<br/>// resource-name -&gt; stories/<br/>// end-point     -&gt; waseem_khan</span></pre><p id="fd5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，任何API的URL都是我提到的格式。通常情况下，<code class="fe oa ob oc od b">server-url</code>保持不变，但是其余的属性会随着API的变化而变化。我们的网络层应该以支持每个API请求的定制的方式来编写。</p><p id="79c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将网络请求封装在一个Swift类中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ApiRequest</p></figure><p id="c8a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b"><strong class="lb iu">ApiRequest</strong></code>类是我们项目中所有API请求的父类，即我们将为每个API创建一个单独的Swift类，例如<code class="fe oa ob oc od b"><strong class="lb iu">LoginApiRequest</strong></code>、<code class="fe oa ob oc od b"><strong class="lb iu">SignupApiRequest</strong></code>、<code class="fe oa ob oc od b"><strong class="lb iu">GetStoriesApiRequest</strong></code>、<strong class="lb iu">、<em class="nn">。通过覆盖父类中所需的方法，可以完全定制每个请求。</em></strong></p><h2 id="1878" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><strong class="ak"> HTTP方法类型</strong></h2><p id="80b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个API可以是以下类型之一:GET、POST、PUT、DELETE、PATCH <em class="nn">。</em> <code class="fe oa ob oc od b"><strong class="lb iu">HTTPMethod</strong></code> enum代表API请求的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="511c" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated"><strong class="ak">请求参数</strong></h2><p id="c17a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据API的类型，您可能需要在主体中设置请求参数。例如，<code class="fe oa ob oc od b">LoginRequest</code>可以期待下面格式的请求参数。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="9579" class="no md it od b gy oi oj l ok ol">{<br/>  "email": "waseem.khan@medium.com",<br/>  "password": "mission#impossible"<br/>}</span></pre><p id="62cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些参数可以通过从基类<code class="fe oa ob oc od b">APIRequest</code>覆盖<code class="fe oa ob oc od b">LoginRequest</code> <strong class="lb iu"> <em class="nn"> </em> </strong>中的函数<code class="fe oa ob oc od b">bodyParams()</code>来提供。</p><h2 id="1d4c" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">响应类型</h2><p id="029f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在<code class="fe oa ob oc od b">ApiRequest</code><strong class="lb iu"><em class="nn"/></strong><strong class="lb iu"><em class="nn"/></strong><code class="fe oa ob oc od b">&lt;ResponseType: Codable&gt;</code><strong class="lb iu"><em class="nn">，</em> </strong>类属<strong class="lb iu"><em class="nn"/></strong><code class="fe oa ob oc od b">ResponseType</code><strong class="lb iu"><em class="nn"/></strong>类型的<code class="fe oa ob oc od b">Codable</code>是提供<code class="fe oa ob oc od b">Codable</code>模型对象来映射API返回的响应。我们可以在这里传递任何实现<code class="fe oa ob oc od b">Codable</code>接口的对象。<code class="fe oa ob oc od b">Array</code>、<code class="fe oa ob oc od b">String</code>、<code class="fe oa ob oc od b">Double</code>等数据类型，已经符合本协议。我们可以直接将来自API的响应映射到我们的一个模型类。例如，<code class="fe oa ob oc od b">get-stories-by-username</code> <strong class="lb iu"> <em class="nn"> </em> </strong> API以下面的格式返回数据。我们关心钥匙<code class="fe oa ob oc od b">data</code>的反应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="7d59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对上述API的响应可以直接映射到故事数组，即<code class="fe oa ob oc od b">[Story]</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="ff13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们的模型类<code class="fe oa ob oc od b">Story</code>要实现<code class="fe oa ob oc od b">Codable</code>？</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1690" class="no md it od b gy oi oj l ok ol">// A type that can convert itself into and out of an external representation.</span><span id="d42d" class="no md it od b gy om oj l ok ol">typealias Codable = <a class="ae ky" href="https://developer.apple.com/documentation/swift/decodable" rel="noopener ugc nofollow" target="_blank">Decodable</a> &amp; <a class="ae ky" href="https://developer.apple.com/documentation/swift/encodable" rel="noopener ugc nofollow" target="_blank">Encodable</a></span></pre><p id="74f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把API get-all-stories的JSON响应映射到<code class="fe oa ob oc od b">Story</code> <em class="nn">。</em>因此<code class="fe oa ob oc od b">Story</code>应该实现<code class="fe oa ob oc od b">Codable</code>来支持编码和解码。</p><h2 id="357a" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">让我们创建第一个网络API请求</h2><p id="14e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建一个API，从medium.com获取特定用户的故事。这个API期望请求体中有记录限制和页码(假设启用了分页)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="78c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到我们只覆盖了这个API的可配置属性。我们可以覆盖<code class="fe oa ob oc od b">apiPath()</code><strong class="lb iu"><em class="nn"/></strong><code class="fe oa ob oc od b">apiVersion()</code>等。，如果需要。我们还提到这个API将返回一组故事<code class="fe oa ob oc od b">[Story]</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2009" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.调用API</h1><p id="2662" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经创建了一个网络请求。现在让我们看看如何实际调用网络API。我们将使用<code class="fe oa ob oc od b">Alamofire</code>与API服务器通信。让我们创建<code class="fe oa ob oc od b">NetworkApiClient</code>，它将负责与API服务器的连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bfd9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.解析响应</h1><p id="75da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止我们有什么？</p><ol class=""><li id="05c9" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">一个网络请求，即<strong class="lb iu"> <em class="nn"> </em> </strong> <code class="fe oa ob oc od b">get-stories-by-username</code></li><li id="d73b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">一个<strong class="lb iu"><em class="nn"/></strong><code class="fe oa ob oc od b">NetworkAPIClient</code><strong class="lb iu"><em class="nn"/></strong>向API服务器发送请求</li></ol><p id="65d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看如何解析从API返回的响应。</p><p id="64f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回到<code class="fe oa ob oc od b">NetworkApiClient</code>并提供函数<code class="fe oa ob oc od b">successResponse()</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f9b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1步:解析对JSON对象的响应(使用<code class="fe oa ob oc od b">SwiftyJson</code> ) <br/>第2步:实际的数据/结果在<code class="fe oa ob oc od b">data</code>键中，如上面通用API响应中所讨论的。第三步:这是实际的交易。</p><p id="e3aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经提供了API所期望的模型类的类型。在请求<code class="fe oa ob oc od b">get-stories-by-username</code><strong class="lb iu"/>的情况下，提到的类型是<code class="fe oa ob oc od b">[Story]</code>，即一个故事列表。<code class="fe oa ob oc od b">decodedValue</code>为<code class="fe oa ob oc od b">[Story]</code>类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d33" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">检验一切</h1><p id="f49b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">没有实践的知识是无用的；没有知识的实践是危险的。</p><p id="8593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止我们有什么？</p><ol class=""><li id="1ad3" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">一个网络请求，即<em class="nn"> </em> <code class="fe oa ob oc od b"><em class="nn">get-all-stories-by-username</em></code></li><li id="bf3e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">网络API客户端:<br/> &gt;向API服务器发送请求<br/> &gt;解析API服务返回的响应</li></ol><p id="369b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将看到如何使用上述知识来调用API并使用结果。</p><p id="0fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一个调用<code class="fe oa ob oc od b">get-stories-by-username</code> API的<code class="fe oa ob oc od b">StoryService</code>类。<code class="fe oa ob oc od b">StoryService</code>负责所有与<code class="fe oa ob oc od b">Story</code>相关的CRUD操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d0de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">apiResponse.data</code>，在这里是一个故事的数组，也就是<code class="fe oa ob oc od b">[Story]</code>。我们可以使用这个列表来填充视图控制器中的<code class="fe oa ob oc od b">UITableView</code>数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望一切都很清楚。如有任何困惑，请留言。我很乐意帮忙。欢迎建议。</p></div></div>    
</body>
</html>