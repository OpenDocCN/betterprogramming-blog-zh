<html>
<head>
<title>How Kotlin’s “reified” Keyword Simplifies Working With Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的“具体化”关键字如何简化泛型的使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-kotlins-reified-keyword-simplifies-working-with-generics-50a4e0cb254c?source=collection_archive---------1-----------------------#2022-09-05">https://betterprogramming.pub/how-kotlins-reified-keyword-simplifies-working-with-generics-50a4e0cb254c?source=collection_archive---------1-----------------------#2022-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="44ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何访问Kotlin函数体中的泛型类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec22ea5cc230aa1debcd7aaf5b8263f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VqxAbL7b7CLWT3gm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伯明翰博物馆信托基金会<a class="ae ky" href="https://unsplash.com/@birminghammuseumstrust?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kotlin编程语言提供了一组很棒的特性，让程序员的生活变得更加轻松。与Java相比，Kotlin提供了许多语法改进和技巧，使编程成为一大乐趣。<code class="fe lv lw lx ly b">reified</code>关键词就是其中之一。这个关键字在许多其他语言中是未知的，因此许多人不直接理解它的用途。在这篇小文章中，我将通过一个例子来演示关键字的目的和用途。</p><h1 id="0a20" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">我们到底在说什么？</h1><p id="2f1f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了同时解决许多不同的事情，软件需要抽象。许多流行且强大的语言，如Java或C++(甚至Golang，据我所知)都支持泛型。下面是一个用Kotlin编写的函数示例:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="ae6e" class="na ma it ly b gy nb nc l nd ne">fun &lt;T&gt; myGenericFun(c: Class&lt;T&gt;)</span></pre><p id="ab90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在像<code class="fe lv lw lx ly b">myGenericFun</code>这样的普通通用函数中，不可能直接访问函数体中的类型<code class="fe lv lw lx ly b">T</code>。我们让它工作的方式是通过使用泛型类型<code class="fe lv lw lx ly b">T</code>将类型<code class="fe lv lw lx ly b">Class</code>的参数传递到函数中。需要这样做的原因是，像在Java中一样，所有的泛型类型在运行时都是不可用的。泛型类型在编译过程中被删除。因此，在函数体中引用泛型类型并不简单。例如，在某些情况下，您可能希望在函数的实现中访问<code class="fe lv lw lx ly b">T</code>的类型。为此，我们需要显式地将类作为参数传递，如给定示例中所做的那样。这种方法是完全正确的，几乎可以在所有的Java代码库中找到。然而，Kotlin试图简化使用泛型的工作，这就是<code class="fe lv lw lx ly b">reified</code>关键字的用武之地。</p><h1 id="b655" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><code class="fe lv lw lx ly b">reified type </code>来救援了</h1><p id="0fd0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果我们以上面的示例函数为例，并希望利用Kotlin提供的具体化类型，那么要遵循的第一个先决条件是创建函数<code class="fe lv lw lx ly b">inline</code>。内联函数由编译器解析，其代码被复制到所有调用点。如果我们现在将关键字<code class="fe lv lw lx ly b">reified</code>添加到泛型类型<code class="fe lv lw lx ly b">T</code>中，我们的签名如下所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="3a00" class="na ma it ly b gy nb nc l nd ne">inline fun &lt;reified T&gt; myGenericFun()</span></pre><p id="0168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这样一个函数，我们现在可以像处理一个普通的<code class="fe lv lw lx ly b">Class</code>一样处理<code class="fe lv lw lx ly b">T</code>，例如，你可能想检查一个变量是否是<code class="fe lv lw lx ly b">T</code>的一个实例，你可以很容易地这样做:<code class="fe lv lw lx ly b">myVar is T</code>。</p><h1 id="25d1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">在后台</h1><p id="a1d4" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">记住<code class="fe lv lw lx ly b">reified</code>类型只能与<code class="fe lv lw lx ly b">inline</code>功能结合使用。一个<code class="fe lv lw lx ly b">inline</code>函数让编译器将函数的字节码复制到调用该函数的每个地方。当用<code class="fe lv lw lx ly b">reified</code>类型调用<code class="fe lv lw lx ly b">inline</code>函数时，编译器知道用作类型参数的实际类型，并修改生成的字节码以直接使用相应的类。因此，像<code class="fe lv lw lx ly b">myVar is T</code>这样的调用在字节码中变成了<code class="fe lv lw lx ly b">myVar is String</code>，因此可以在运行时工作。</p><h1 id="31bf" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">在行动中具体化</h1><p id="c969" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们看一个例子来演示<code class="fe lv lw lx ly b">reified</code>实际上带来了什么价值。任务是在<code class="fe lv lw lx ly b">String</code>上创建一个扩展函数，该函数应该将JSON字符串转换成Kotlin类型，该类型由函数的泛型类型<code class="fe lv lw lx ly b">T</code>指定。为此，我们将使用<code class="fe lv lw lx ly b">com.fasterxml.jackson.module.kotlin</code>，我们的第一次尝试如下:</p><p id="1a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一种方法没有具体化类型</strong></p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="f1b4" class="na ma it ly b gy nb nc l nd ne">fun &lt;T&gt; String.toKotlinObject(): T {<br/>      val mapper = jacksonObjectMapper()<br/>                                    //does not compile!<br/>      return mapper.readValue(this, T::class.java)<br/>}</span></pre><p id="8ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个语句中使用的<code class="fe lv lw lx ly b">readValue</code>方法将一个类型作为它的最后一个参数(这里:<code class="fe lv lw lx ly b">T::class.java</code>)。该参数用于指定解析应该发出的类型。如果我们现在在函数体内引用类型参数<code class="fe lv lw lx ly b">T </code>，编译器会报错如下:<em class="nf">“不能使用‘T’作为具体化的类型参数。请改用类。</em>”。这个错误基本上告诉我们，泛型类型T不能以我们的函数设置的方式使用。让我们在第一次迭代中修复它。</p><h1 id="95b0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak">使用显式类参数的解决方法</strong></h1><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="c75d" class="na ma it ly b gy nb nc l nd ne">fun &lt;T: Any&gt; String.toKotlinObject(c: KClass&lt;T&gt;): T {<br/>    val mapper = jacksonObjectMapper()<br/>    return mapper.readValue(this, c.java)<br/>}</span></pre><p id="8b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们显式地传递<code class="fe lv lw lx ly b">T</code>的<code class="fe lv lw lx ly b">Class</code>，我们可以简单地将它传递给<code class="fe lv lw lx ly b">readValue</code>。这种方法在Java世界中非常常见，并且工作正常。在调用端，我们的代码如下所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="373c" class="na ma it ly b gy nb nc l nd ne">// type definition</span><span id="409d" class="na ma it ly b gy ng nc l nd ne">data class MyJsonType(val name: String)<br/>// variable definition</span><span id="9e70" class="na ma it ly b gy ng nc l nd ne">val jsonTypeAsString = """{"name":"example"}"""<br/>// call to String::toKotlinObject</span><span id="e657" class="na ma it ly b gy ng nc l nd ne">jsonTypeAsString.toKotlinObject(MyJsonType::class)</span></pre><h1 id="0f5d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用<code class="fe lv lw lx ly b">reified</code>的科特林方式</h1><p id="2c36" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">使用带有<code class="fe lv lw lx ly b">reified</code>类型参数<code class="fe lv lw lx ly b">T</code>的<code class="fe lv lw lx ly b">inline</code>函数可以实现如下功能:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="c71a" class="na ma it ly b gy nb nc l nd ne">inline fun &lt;reified T: Any&gt; String.toKotlinObject(): T {<br/>    val mapper = jacksonObjectMapper()<br/>    return mapper.readValue(this, T::class.java)<br/>}</span></pre><p id="3a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不需要通过<code class="fe lv lw lx ly b">T</code>的<code class="fe lv lw lx ly b">Class</code>另外，<code class="fe lv lw lx ly b">T</code>可以像普通班一样使用。对于客户端，代码简化为以下内容:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="a2c6" class="na ma it ly b gy nb nc l nd ne">json.toKotlinObject&lt;MyJsonType&gt;()</span></pre><h1 id="962b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">与Java的互操作性</h1><p id="6ca9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">内联具体化函数不能从Java代码中调用，而普通的内联函数可以。这可能是为什么不是所有在<code class="fe lv lw lx ly b">inline</code>函数中使用的泛型类型都默认成为<code class="fe lv lw lx ly b">reified</code>的原因之一。</p><h1 id="634d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="3fb9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们已经看到<code class="fe lv lw lx ly b">reified</code>关键字可以解决JVM的泛型类型擦除的常见问题。许多情况下需要我们访问函数体内的泛型类型，这在函数和被调用者端都很难实现。本文通过一个简单的例子展示了具体化类型简化函数实现和调用者代码的能力。</p></div></div>    
</body>
</html>