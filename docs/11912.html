<html>
<head>
<title>How to Push an Initial Commit To a New GitHub Remote With a Single Shell Command</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用一个Shell命令将初始提交推送到新的GitHub Remote</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-push-an-initial-commit-to-a-new-github-remote-with-a-single-shell-command-66d59b638f22?source=collection_archive---------10-----------------------#2022-04-26">https://betterprogramming.pub/how-to-push-an-initial-commit-to-a-new-github-remote-with-a-single-shell-command-66d59b638f22?source=collection_archive---------10-----------------------#2022-04-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="88a8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">别名降低了使用命令行界面的复杂性</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj kj"><img src="../Images/5035199f22c29f3f4ed9281af8d2c080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*xry9Q_1ZVn3YbzgA.png"/></div><p class="kr ks gk gi gj kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=161382" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="05b6" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">我不是CLI或命令行界面的狂热爱好者，但是这一次我决定通过减少建立良好的源代码控制实践的努力来挑战自己。我通常拒绝Xcode将新项目置于源代码控制之下的提议，因为我经常尝试，不一定想要早期原型的记录。</p><p id="5af4" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">但是，让没有源代码控制的项目不仅有本地提交，而且还被推送到远程存储库，这是非常复杂的。</p><p id="3372" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">直到现在…</p><h1 id="71f7" class="ls lt iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">用自制软件安装GitHub CLI</h1><p id="4583" class="pw-post-body-paragraph kw kx iu ky b kz mk jv lb lc ml jy le lf mm lh li lj mn ll lm ln mo lp lq lr in bi translated">如果您还没有安装Homebrew，请打开“终端”并粘贴以下命令:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="d9d6" class="mu lt iu mq b gz mv mw l mx my">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</span></pre><p id="2dce" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">一旦你有了自制软件，运行这个来安装GitHub CLI:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="4556" class="mu lt iu mq b gz mv mw l mx my">brew install gh</span></pre><p id="526a" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">安装GitHub CLI后，运行以下命令登录:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="28e5" class="mu lt iu mq b gz mv mw l mx my">gh auth login</span></pre><p id="f77a" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">我使用HTTPS并通过浏览器进行验证，但您可能会选择不同的方式。</p><h1 id="0c8d" class="ls lt iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">添加GitHub CLI别名</h1><p id="7173" class="pw-post-body-paragraph kw kx iu ky b kz mk jv lb lc ml jy le lf mm lh li lj mn ll lm ln mo lp lq lr in bi translated">该命令将添加GitHub CLI所需的唯一别名:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="c649" class="mu lt iu mq b gz mv mw l mx my">gh alias set new 'repo create --private --push --source=.'</span></pre><p id="d46e" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">这只是创建一个私有的远程存储库，并推送它在当前文件夹中找到的任何内容。</p><p id="ad9c" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">运行<code class="fe mz na nb mq b">gh new</code>命令将创建远程并推送您的提交(如果您已经有一个本地存储库)。如果没有本地存储库，该命令将会失败，理由是该目录还不是git存储库。</p><h1 id="8652" class="ls lt iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">添加Git别名</h1><p id="af03" class="pw-post-body-paragraph kw kx iu ky b kz mk jv lb lc ml jy le lf mm lh li lj mn ll lm ln mo lp lq lr in bi translated">运行以下命令，向全局<code class="fe mz na nb mq b">~/.gitconfig </code>文件添加一个新的Git别名:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="385c" class="mu lt iu mq b gz mv mw l mx my">git config --global alias.new '!new() { cd -- ${GIT_PREFIX:-.}; if getopts "rf:" arg; then mkdir "$OPTARG"; cd "$OPTARG"; fi; touch README.md; git init; git add .; git commit -m "Initial commit"; }; new'</span></pre><p id="bab7" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">感叹号(！)允许使用非git命令，但是它也将shell的默认位置更改为用户的主文件夹。</p><p id="40a9" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">要解决这个问题，我们只需将目录更改为<code class="fe mz na nb mq b">GIT_PREFIX:-.</code>，这是调用git命令的地方。</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="f860" class="mu lt iu mq b gz mv mw l mx my">git new</span></pre><p id="b20d" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">这个新别名允许您在当前文件夹中创建新的本地存储库，而不管它是包含文件还是空的。</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="691e" class="mu lt iu mq b gz mv mw l mx my">git new -f MyNewProject</span></pre><p id="0b49" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">运行这个命令会创建一个名为<code class="fe mz na nb mq b">MyNewProject</code>的新的子文件夹。</p><p id="dcfd" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">子文件夹参数作为<code class="fe mz na nb mq b">$OPTARG</code>传递，因为它是<code class="fe mz na nb mq b">-f</code>选项字母之后的第一个参数。如果没有传递<code class="fe mz na nb mq b">-f</code>选项，那么任何其他参数都将被忽略，该命令的运行方式与当前文件夹中的<code class="fe mz na nb mq b">git new</code>相同，不会创建子文件夹。</p><h1 id="dbaf" class="ls lt iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">组合别名</h1><p id="c719" class="pw-post-body-paragraph kw kx iu ky b kz mk jv lb lc ml jy le lf mm lh li lj mn ll lm ln mo lp lq lr in bi translated">我考虑过各种方法来将别名组合成一个，一个接一个地调用它们，但是我认为在很多情况下一次做所有的事情可能是多余的。</p><p id="9a67" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">假设我想用本地repo创建一个新的子文件夹，然后将它推送到一个新的GitHub remote:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="b3e8" class="mu lt iu mq b gz mv mw l mx my">git new -f MyNewProject &amp;&amp; cd MyNewProject &amp;&amp; gh new</span></pre><p id="e3c1" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">返回到我第一次调用命令的目录，这意味着如果我创建了一个子文件夹，我需要手动进入它。</p><p id="b915" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">如果我不想创建子文件夹，而是想在当前文件夹中创建一个新的存储库，我只需运行以下命令:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="a062" class="mu lt iu mq b gz mv mw l mx my">git new &amp;&amp; gh new</span></pre><p id="adec" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">如果您真的想将此组合添加为Z-Shell别名，请运行以下命令:</p><pre class="kk kl km kn gu mp mq mr ms aw mt bi"><span id="cdf3" class="mu lt iu mq b gz mv mw l mx my">echo -n 'alias newgit="git new &amp;&amp; gh new"' &gt;&gt; ~/.zshrc; source ~/.zshrc</span></pre><p id="3c9f" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">只要记住这个<code class="fe mz na nb mq b">newgit</code>别名只能在你想用它的文件夹中调用。</p><p id="1356" class="pw-post-body-paragraph kw kx iu ky b kz la jv lb lc ld jy le lf lg lh li lj lk ll lm ln lo lp lq lr in bi translated">你不能给它一个子文件夹名，因为它将在原始文件夹而不是子文件夹中运行<code class="fe mz na nb mq b">gh new</code>。</p></div></div>    
</body>
</html>