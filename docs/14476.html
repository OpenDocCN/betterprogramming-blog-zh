<html>
<head>
<title>Blender vs. Reality Composer: Prototyping AR Experiences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Blender vs. Reality Composer:原型AR体验</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/blender-vs-reality-composer-86f29ff2d0bc?source=collection_archive---------5-----------------------#2022-12-21">https://betterprogramming.pub/blender-vs-reality-composer-86f29ff2d0bc?source=collection_archive---------5-----------------------#2022-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="609d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两种工具的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d301793e118b18795bba1d2bbb32660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JdXXa3SMOwk_hVWpv2jZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">钢筋混凝土渲染低聚棋子</p></figure><p id="4d15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我开始这篇文章时，我打算谈谈我花了几个星期记录的国际象棋应用程序的动画。</p><p id="dcf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但当我深入研究这个问题时，我意识到苹果在这个问题上与他们之前的SceneKit和SpriteKit框架有着非常不同的想法。你没有<code class="fe lu lv lw lx b">SCNTransactions</code>或<code class="fe lu lv lw lx b">CAAnimations</code>，有相当多不同的选项，我的同事安迪·爵士在这个<a class="ae ly" href="https://stackoverflow.com/questions/59335075/how-to-animate-a-models-rotation-in-realitykit" rel="noopener ugc nofollow" target="_blank"> SO帖子</a>中简要介绍了这些选项。</p><p id="071c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个远比我在这里有时间触及的更全面的列表；本文的重点是“*。USDZ”基于动画与RC触发器、通知和动作。前者没有代码的动画，后者既“罐头”和增强的动画，如果你愿意。</p><h2 id="29dd" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">简短的</h2><p id="9c17" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">挑战就在这里——在国际象棋中，你有64个方格，32个棋子和6个模型，有些模型被对折了两次，它们是自成一类的棋子。每个模型都有自己的一套在棋盘上移动的规则。规则说有些可以移动一格，有些可以移动多格。不同的棋子可以向不同的方向移动，有些是斜向的，有些是直线的。你不能穿过其他玩家，除了可以跳过他们的骑士或马。你有几个例外，比如阉割和提升——但它们都是例外。</p><h2 id="1a65" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">力学</h2><p id="9faf" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">当然，除了移动之外，我还需要设计一种方法来指示您想要将哪个部分移动到哪里。选择棋子很容易，但是决定接下来的动作就比较复杂了。我需要让白板更具互动性吗？我能有一个平视显示器吗？我应该实现自定义手势吗？我需要考虑一下。</p><h1 id="2367" class="mx ma it bd mb my mz na me nb nc nd mh jz ne ka mk kc nf kd mn kf ng kg mq nh bi translated">搅拌机</h1><p id="c695" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">RealityKit允许您通过在Blender中创建和导出实体来播放动画。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/88d2b6a421ef5872cd2b640acbe5c1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1Cmt6dXx2q1apMRkEEfmpQ.gif"/></div></div></figure><p id="7f7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我最初使用*导出了。usdc]没有动画的blender场景，随后导出另外两个只有动画的副本。然后，我将所有三个导出转换为“*”。“usdz”格式，将它们加载到应用程序中，将第一个添加到场景中，并使用第二个和第三个作为“罐装”移动；通过SwiftUI界面触发，使正在发生的事情一目了然。</p><pre class="kj kk kl km gt nj lx nk bn nl nm bi"><span id="810b" class="nn ma it lx b be no np l nq nr">let model = try! Entity.load(named: "ChessSceneA")<br/>anchor.addChild(model)<br/><br/>let model2 = try! Entity.load(named: "ChessSceneB")<br/><br/>whiting = white<br/>  .throttle(for: 0.01, scheduler: RunLoop.main, latest: true)<br/>  .sink(receiveValue: { [self] _ in<br/>            <br/>  let animation = model2.availableAnimations<br/>  if animation.count &gt; 0 {<br/>     model.playAnimation(animation[0], transitionDuration: 4, startsPaused: false)<br/>  } else {<br/>     print("no....")<br/>  }</span></pre><h2 id="dd49" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">可行性</h2><p id="bcda" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">但是我在骗谁呢——我不可能为一场国际象棋比赛创建并管理一个“罐装”动画池。想象一下，女王可以从任何地方向任何方向移动任何数量的方格——也许通过大量的艰苦工作和一些开箱即用的逻辑，你可以让它工作，但不，它根本不是一个可扩展的解决方案。</p><h1 id="646a" class="mx ma it bd mb my mz na me nb nc nd mh jz ne ka mk kc nf kd mn kf ng kg mq nh bi translated">现实作曲家</h1><p id="0184" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">在对自己做出决定/证明Blender不能解决问题后，我需要别的东西，一个能让我与代码交互并管理游戏的工具，这就是RC的用武之地。</p><p id="5624" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Reality Composer是苹果一直致力于帮助你我开发AR应用的少数专用工具之一，还有它的堂兄Reality Converter。你可以找到许多关于前者的文章，尽管很少触及我在这里想要关注的主题——我称之为增强编码。</p><h2 id="7af4" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">扩充编码</h2><p id="04e6" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">苹果的配套工具Reality Composer是一个应用程序构建器，让没有编码技能的人能够在他们的AR应用程序中创建交互式场景。它有固定的动画(大部分都很糟糕，抱歉，是苹果的)和增强代码的机会，我会这么称呼它们。随着动画的出现，还有一些预设的触发器，这是2019年WWDC的最终名单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/a33ead3d9997d448d54138457ae2bb28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbOKBSF1V6n_XKDwjHtXtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自wwdc 2019 Reality Composer简介的快照</p></figure><p id="68da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前四个是给非程序员的，剩下的一个是给我们其他人的。您有一个类似的行动列表，同样在最后有一个通知。这里的概念和他们在Combine框架中使用的概念是一样的，所以如果你熟悉的话，这将是小菜一碟。</p><p id="4b26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个动画GIF，展示了一个固定的动画和一些正在运行的增强代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/2751fdb37ba34c049287f75cd115a678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fy6zUG0pPp3UY_yAWNJG2Q.gif"/></div></div></figure><p id="8965" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个动作是“固定的”RC动作之一——一个旋转——我将通知消息传递回SwiftUI接口，以切换控制<code class="fe lu lv lw lx b">GameOver</code>消息的布尔值。下面是对话的代码部分，后面是RC配置:</p><pre class="kj kk kl km gt nj lx nk bn nl nm bi"><span id="d46e" class="nn ma it lx b be no np l nq nr">@State var gameOver = false<br/><br/>CustomARView(view: arview)<br/>      .scaleEffect(zoomScale)<br/>      .onReceive(game) { _ in<br/>          gameOver.toggle()<br/>      }<br/>  if gameOver {<br/>      Text("GameOver") { $0.kern = CGFloat(2)}<br/>          .font(Fonts.neutonRegular(size: 64))<br/>          .foregroundColor(Color.white)<br/>  }</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/e0ac973fd7a669f2f32a4cd1a7c980c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzgcrVeTEqcq_P461sk78A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带通知和“预设”操作的RC配置</p></figure><p id="cef4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在游戏版本中，我会点击模型的图像，以一个动作开始，以记住我点击了哪个部分。为了继续玩，我在棋盘上的每个方格中添加一个触发器，以请求我刚才点击的棋子。</p><p id="9f32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等，因为第二个触发器需要从第一个触发器中获取信息；因此，第二个触发器不可能是一个“固定”的动作；如果你愿意，这必须是一个有坐标的“合格”移动。</p><p id="f491" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我需要一个通知触发器；这将是我添加到方块中的触发器:它们将运行一些自定义代码来检查方块是否为空，如果所述方块上已经有一个棋子，则执行销毁操作，然后请求从先前指示的棋子移动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/7371020658973e0841a9f429770b7cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRuYVaQP3rsnkpBXH4ePDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带通知触发器动作的RC配置</p></figure><p id="50f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二种情况在代码中是什么样的——请看这里；我添加了一个带有手势的标签，以[通过Combine]向我的ARKit生成的场景发送消息，要求它向该场景发布消息。</p><pre class="kj kk kl km gt nj lx nk bn nl nm bi"><span id="c187" class="nn ma it lx b be no np l nq nr">Text("knight")<br/>  .font(Fonts.neutonRegular(size: 32))<br/>  .foregroundColor(whiteBack ? .white : .blue)<br/>  .onTapGesture {<br/>      move.send()<br/>  }</span></pre><p id="8939" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该操作的后半部分在这段代码中概述。在这个代码片段中，我设置了一个消息订阅，它向场景中的模型发送第二条消息。</p><pre class="kj kk kl km gt nj lx nk bn nl nm bi"><span id="cbbb" class="nn ma it lx b be no np l nq nr">moving = move<br/>    .throttle(for: 0.01, scheduler: RunLoop.main, latest: true)<br/>    .sink(receiveValue: { [self] _ in<br/>        model.notifications.tapKnight.post()<br/>    })</span></pre><p id="2507" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个演示，我的骑士展示了这一切走到一起。我按下按钮，骑士做了一个360度的旋转。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/ade8ba5566df0d846ff8e458ecee40c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6MoN_qLUY1kbxp6vKE3AKQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RC配置场景，SwiftUI链接到场景</p></figure><h2 id="cec8" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">RC到底值不值得？</h2><p id="9444" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">动画当然有它们的位置，给每一个作品添加一个或者仅仅一个令人敬畏的动画可能是好的。但很明显，我需要更多。<br/><br/>RC是否胜任工作？我不确定。触发器、动作和通知的组织是一个长长的层次列表，所有人都可以自由使用。如果没有结构，管理起来不会比用代码块做几乎相同的事情更容易。在我看来，苹果应该复制Blender Materials菜单，让你建立一个动作的动画网络。这将使事情进入下一个阶段。</p><h1 id="2c48" class="mx ma it bd mb my mz na me nb nc nd mh jz ne ka mk kc nf kd mn kf ng kg mq nh bi translated">最后的想法</h1><p id="336c" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">如果有人正在阅读苹果的这篇文章，那么与场景相关联的API可能是一个令人兴奋的选择。事实上，在我考虑的时候，也许我可以使用新的<a class="ae ly" href="https://developer.apple.com/videos/play/wwdc2021/10253/" rel="noopener ugc nofollow" target="_blank"> DSL </a>功能以及这些触发器、动作和通知来构建一个。精神食粮。这样做，我可以建立自己的工具来管理动画。</p></div></div>    
</body>
</html>