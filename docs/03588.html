<html>
<head>
<title>The Evil in Code Generation in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中代码生成的弊端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-potential-evils-of-code-generation-in-swift-9fcbe495b421?source=collection_archive---------8-----------------------#2020-02-19">https://betterprogramming.pub/the-potential-evils-of-code-generation-in-swift-9fcbe495b421?source=collection_archive---------8-----------------------#2020-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="844c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">可扩展IOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="60c1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">自动化和生成代码的缺点</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f4aab5bd34f19fefb3ef2f8896537f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWdOSHpBTnjPiBuRVOc2Cw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">布莱恩·麦高恩在<a class="ae lh" href="https://unsplash.com/s/photos/evil?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6764" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一个聪明的开发者，你已经知道了新的信条:</p><blockquote class="me"><p id="0ef4" class="mf mg it bd mh mi mj mk ml mm mn md dk translated">自动化一切！</p></blockquote><p id="62e2" class="pw-post-body-paragraph li lj it lk b ll mo kd ln lo mp kg lq lr mq lt lu lv mr lx ly lz ms mb mc md im bi translated">真的吗？一切？🤨</p><p id="060c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不，当然不是。只有在系统生命周期中，自动化的创建和维护比手动方式花费的时间少，自动化才有经济意义。</p><h2 id="a55f" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated">那是什么意思？</h2><p id="c038" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">每一种自动挡都需要一开始的努力才能装上。例如，您首先必须阅读该工具的API文档，然后基于它构建一个脚本。</p><p id="4624" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，每个自动化系统通常都需要维护，因为有些东西总是会随着时间的推移而改变。下一个突破API的重大更新已经开始了。</p><p id="602f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在某种程度上，维护工作可能如此之高，以至于根本不再值得(如果我们让它更干净就好了)。或者随着时间的推移，这些知识可能已经丢失了(如果我们没有解雇管理员就好了)。或者工具已经不再需要了(如果我们能预见未来就好了)。😄</p><p id="08c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一切都是有限的，自动性也是如此。你必须把你在自动化上投入的所有时间加起来，然后问自己:“我真的节省了时间吗？或者至少是值得的？”</p><p id="cf67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">聪明的开发人员会提前估计到这一点。有经验的开发人员甚至只做了一半的估计。😜</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="d6a4" class="nx mu it bd mv ny nz oa my ob oc od nb ki oe kj ne kl of km nh ko og kp nk oh bi translated">自动化工具</h1><p id="d9bd" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">如果你开发iOS应用，迟早你会接触到如下自动化工具:</p><h2 id="1c16" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated"><a class="ae lh" href="https://fastlane.tools" rel="noopener ugc nofollow" target="_blank">浪子</a></h2><p id="25a5" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">当你想到自动化时，首先想到的可能是浪子。不会生成源代码，但某些流程会自动运行。浪子是一个工具套件，可以让你自动构建代码，运行测试，上传测试版，创建截图，等等。不仅适用于iOS，也适用于Android。</p><p id="20fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">听起来很酷，的确如此。至少在管道因为CI服务器上有东西卡住而再次中断之前。现在你不得不再花一天、两天或三天时间四处闲逛。在某种程度上，这变成了一份全职工作。😉</p><p id="1c2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这种努力通常是值得的，因为如果浪子在CI服务器上设置正确，它有助于在大型团队中保持项目的高质量。它可以测试您可能不会手动做的事情，要么是因为您忘记了，要么是因为它太麻烦或太乏味了。</p><p id="42d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是我们来谈谈源代码生成器。🧐</p><h2 id="b5f3" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated"><a class="ae lh" href="https://github.com/SwiftGen/SwiftGen" rel="noopener ugc nofollow" target="_blank"> SwiftGen </a></h2><p id="4866" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">使用SwiftGen，您可以自动生成Swift代码。例如，该工具遍历一个资源文件夹，并为字符串、颜色、字体等创建类型安全的常量。你甚至可以使用你自己的模板来个性化代码。🤓</p><p id="d6cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">局限性在于生成器或解析器。没有被接受为输入或者没有被适当地处理为模板的内容当然不能作为转换后的输出出来。该工具是开源的。因此，在紧急情况下，也可以延长。但是谁真的想维护SwiftGen呢？😖</p><h2 id="f3f9" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated">r .斯威夫特</h2><p id="a4eb" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">R.swift做的事情几乎和SwiftGen一样。该工具遍历资源并创建类型安全的常数。然而，缺点是它不使用你可以定制的模板。这意味着要么你接受这个工具，因为它适合，要么它不适合，你接受另一个工具，比如SwiftGen。😕</p><p id="4c9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就我个人而言，我更喜欢R.swift而不是SwiftGen，因为它更简单，结果也足够好。配置SwiftGen，使它比R.swift提供更多的现成功能，将需要付出更多的努力，尤其是在维护方面。因此，我将暂时和R.swift在一起。☺️</p><h2 id="312b" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated"><a class="ae lh" href="https://github.com/krzysztofzablocki/Sourcery" rel="noopener ugc nofollow" target="_blank">来源</a></h2><p id="f2bf" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">Sourcery也可以用来生成Swift代码，但是更多的是用来生成重复的样板代码。所以，你编写一个模板，然后根据某个方案从它自动创建Swift代码。</p><p id="53a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，工作包括创建和维护模板。但是如果你找到合适的用例，你肯定可以用Sourcery节省时间。当然，只有在完成教程和文档之后。😅</p><h2 id="4ddb" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated"><a class="ae lh" href="https://github.com/scribd/Weaver" rel="noopener ugc nofollow" target="_blank">织工</a></h2><p id="3523" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">如果您希望使用依赖注入，但是希望在编译时而不是运行时解析注入的依赖，那么您需要一个相应的代码生成器，比如Weaver。</p><p id="1c9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这个工具是否真的能节省您的时间，以及它是否足够适合您的项目，这是值得怀疑的。我个人更喜欢手动方式，正如我在上一篇文章“<a class="ae lh" href="https://medium.com/better-programming/dependency-management-done-manually-in-swift-ee0f8f2dfbe3" rel="noopener">Swift</a>中手动完成的依赖性管理”中所描述的。😇</p><h2 id="8150" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated"><a class="ae lh" href="https://github.com/swagger-api/swagger-codegen" rel="noopener ugc nofollow" target="_blank">霸气Codegen </a></h2><p id="fed8" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">当使用REST API时，后端开发人员很可能也会提供OpenAPI/Swagger格式的文档。使用Swagger Codegen，您可以自动将这种标准化的规范格式转换为Swift代码。</p><p id="a43e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当模型和请求最终被自动转换成代码时，这是一件非常令人高兴的事情——至少直到意识到结果可能不像您希望的那样适合您，并且没有办法调整任何模板。😞</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="6794" class="nx mu it bd mv ny nz oa my ob oc od nb ki oe kj ne kl of km nh ko og kp nk oh bi translated">自动生成代码的问题</h1><p id="0b3f" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">代码是自动生成的。它节省时间。这有什么不好的？🤨</p><h2 id="9fd4" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated">训练时间</h2><p id="02e0" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">每一个新工具都意味着一定的训练期。熟悉很少只是五分钟的自述。你实验了几天，直到你理解它，并且它适合你的项目。</p><p id="1e42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最坏的情况是，一年后你不得不再次运行这个工具或者重新配置它，但是却忘记了一切。当然，那你就没时间再去熟悉了。😅</p><h2 id="4af1" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated">根据工具的不同</h2><p id="be01" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">如果一年后工具不存在了怎么办？或者也许它仍然存在，但不再维持。只要您仍然可以使用来自您自己的Git repo的旧版本，一切都很好，但这是一个临时的游戏。在某种程度上，您将需要该工具不支持的新特性。</p><p id="0531" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，您必须寻找替代方案，并注意到每个工具创建的代码都有些不同。一个工具创建一个类，接下来是两个类，然后第三个工具处理协议和工厂，第四个工具以完全不同的方式命名一切。您猜得不错:您现在必须调整接口。😕</p><h2 id="f1bf" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated">发电机资源的维护</h2><p id="5394" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">发电机作为输入所需的一切可能都需要维护。这些可以是配置文件和模板，也可以是源代码本身。例如，工具更新过程中的新参数或变量可能需要扩展您自己的模板。否则，该项目将无法继续建设。一个简单的<code class="fe oi oj ok ol b">pod update</code>可能会变成一整天的任务。😩</p><h2 id="3ca5" class="mt mu it bd mv mw mx dn my mz na dp nb lr nc nd ne lv nf ng nh lz ni nj nk iz bi translated">结果并不总是最佳的</h2><p id="5c6a" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">您很少对生成的代码100%满意。如果你能调整模板，这很好，但是这也是有限制的。然而，通常情况下，生成的代码并不像是您手动干净地编写的。至少界面看起来会有所不同。这导致了妥协。然而，这意味着时间的节省是以代码质量为代价的。😟</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="b6ce" class="nx mu it bd mv ny nz oa my ob oc od nb ki oe kj ne kl of km nh ko og kp nk oh bi translated">结论</h1><p id="ca79" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">你现在可能会有不同的印象，但是自动化本质上是一件好事。自动化意味着必须做更少的无聊工作，从而有更多的时间做有趣的工作。😄</p><p id="0522" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，自动化也有其成本。有时候，根本就没有省时。有时候，你用代码质量购买了节省的时间。有时，你可以提高质量，但也必须投入更多的时间。</p><p id="9a6a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">往往是一种取舍。你只要意识到这一点，就能权衡成本和收益。😜</p><p id="1c50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顺便提一下，这是一篇来自“可扩展的iOS应用架构”系列的文章。</p></div></div>    
</body>
</html>