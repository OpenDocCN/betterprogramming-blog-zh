<html>
<head>
<title>Working on High-Performance Golang Client Library — Remove the Bad Busy Loops With the Sync.Cond</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用高性能Golang客户端库——使用Sync消除糟糕的繁忙循环。Cond</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/working-on-high-performance-golang-client-library-remove-the-bad-busy-loops-with-the-sync-cond-e262b3fcb458?source=collection_archive---------9-----------------------#2022-02-21">https://betterprogramming.pub/working-on-high-performance-golang-client-library-remove-the-bad-busy-loops-with-the-sync-cond-e262b3fcb458?source=collection_archive---------9-----------------------#2022-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="223c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用同步。同步和不同步条件。互斥（体）…</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1989d3ff34774026ea37c68530520b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nhxl0vWgmYD6-CuXwkx-SQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保罗·马尔桑在<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="faa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我从构建高性能Golang Redis客户端库<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>中学到的常见技巧系列的第三个主题。</p><p id="2ed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为这些技巧值得分享，因为它们对日常Golang编程也很有用:</p><ul class=""><li id="6455" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><a class="ae kv" href="https://ruian.medium.com/writing-high-performance-golang-client-library-part-1-batching-on-pipeline-97988fe3211?source=friends_link&amp;sk=ff4d0b2200f9416025f6cac6f2c0d117" rel="noopener">第1部分——管道上的配料</a></li><li id="b643" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/working-on-high-performance-golang-client-library-reading-again-from-channels-5e98ff3538cf?source=friends_link&amp;sk=a336644446cf70749e1a0f1aa0d4c706">第2部分—再次从频道中读取？</a></li><li id="c4aa" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">第3部分—通过同步消除不良繁忙循环。Cond</li><li id="b42b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">第4部分—优雅地关闭并发作者的通道</li></ul><p id="9736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的第2部分中，与双通道方法相比，我们用自定义的环形队列实现了更高的请求/响应通信吞吐量。</p><p id="7614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，有两个地方的定制振铃队列使用忙等待:</p><ol class=""><li id="d025" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mk mc md me bi translated"><code class="fe ls lt lu lv b">EnqueueRequest</code>使用一个忙循环来等待时隙可用。</li><li id="5cdd" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mk mc md me bi translated">正在编写的goroutine在一个繁忙的循环中调用<code class="fe ls lt lu lv b">NextRequestToSend</code>,因为它没有阻塞行为，而Golang通道有。</li></ol><p id="cca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在以下几节中，我将介绍:</p><ol class=""><li id="3bf1" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mk mc md me bi translated">这些忙循环有什么问题？</li><li id="1149" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mk mc md me bi translated">用<code class="fe ls lt lu lv b">sync.Mutex</code>通过<code class="fe ls lt lu lv b">sync.Cond</code>去除不良忙回路</li><li id="164a" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mk mc md me bi translated">在没有<code class="fe ls lt lu lv b">sync.Mutex</code>的情况下，通过<code class="fe ls lt lu lv b">sync.Cond</code>最小化坏忙循环</li></ol><h1 id="333a" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">这些忙循环有什么问题？</h1><p id="8d08" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">Golang以使并发编程变得容易而闻名，它的运行时调度器在操作系统的进程上调度goroutines方面做得很好。但是Go程序的真正并发性仍然受到你所拥有的CPU内核的限制。</p><p id="689c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做一个忙循环基本占用一个CPU核。此外，如果循环需要不确定的时间来完成，这意味着内核很难在不确定的时间内做其他有用的工作，并导致糟糕的整体性能。</p><p id="b897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的自定义环形队列就是这种情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5e25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">EnqueueRequest</code>将一直循环，直到环槽可用，但是只有当我们已经处理了它之前的响应时，环槽才可用。也就是我们已经发出了之前的请求，收到了服务器的响应，最重要的是，需要多长时间是未知的。</p><p id="ecdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，我们编写的goroutine只是不断循环并调用<code class="fe ls lt lu lv b">NextRequestsToSend</code>，但是用户何时发出请求也是未知的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="37b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写程序会一直占用你的一个CPU核心。而<code class="fe ls lt lu lv b">EnqueueRequest</code>，在最坏的情况下，会占领所有的。</p><p id="1709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过用更高的并行度设置对定制环队列进行基准测试来确认性能下降。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基准源代码:<a class="ae kv" href="https://gist.github.com/rueian/ffa36c008be14717732377a35a3956d0" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/rue Ian/FFA 36 c 008 be 14717732377 a 35 a 3956d 0</a></p></figure><p id="7ec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从结果中可以看出，当并行度上升时，自定义环形队列的性能比通道方法差得多。这是因为goroutines之间获取操作系统进程的竞争也变得更加困难。</p><h1 id="cddb" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">用<code class="fe ls lt lu lv b">sync.Mutex</code>通过<code class="fe ls lt lu lv b">sync.Cond</code>去除不良忙回路</h1><p id="390c" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">对于我们的<code class="fe ls lt lu lv b">EnqueueRequest</code>，我们需要能够在插槽不可用时让goroutine进入睡眠状态，并在插槽可用时唤醒它。</p><p id="836e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种能力就像其他编程语言中的<strong class="ky ir"> <em class="nk">信号量</em> </strong>所提供的一样。</p><p id="ef48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Golang中，有两种使用类似“信号量”的同步技术的推荐方法:</p><ol class=""><li id="3e7f" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mk mc md me bi translated">golang.org/x/sync/semaphore</li><li id="e27d" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mk mc md me bi translated"><code class="fe ls lt lu lv b">sync.Cond</code></li></ol><p id="0567" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前者提供了一个复杂的加权信号量机制，用一个<code class="fe ls lt lu lv b">sync.Mutex</code>和一个通道链表实现，允许用户一次<code class="fe ls lt lu lv b">Acquire</code>和<code class="fe ls lt lu lv b">Release</code>多个信号。关于这一点，我在附录中做了更多的介绍。</p><p id="d2e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后者用<code class="fe ls lt lu lv b">Wait</code>和<code class="fe ls lt lu lv b">Signal</code>方法提供了一个简单得多的接口，但是要求用户准备一个<code class="fe ls lt lu lv b">sync.Locker</code>来避免在这种情况下竞争。</p><p id="745a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的等待条件是基于信号量外部的插槽状态，所以使用<code class="fe ls lt lu lv b">EnqueueRequest</code>中的<code class="fe ls lt lu lv b">sync.Cond</code>更合适。</p><p id="e613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将<code class="fe ls lt lu lv b">sync.Cond</code>添加到我们的插槽中，并用<code class="fe ls lt lu lv b">sync.Mutex</code>初始化它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并用它重写我们的自定义环形队列:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="edb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果时隙不可用，我们会让<code class="fe ls lt lu lv b">EnqueueRequest</code>进入睡眠状态，并在前一个时隙响应发出时，用<code class="fe ls lt lu lv b">cond.Signal()</code>唤醒一个goroutine。</p><p id="5301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，基准测试结果优于渠道方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基准源代码:<a class="ae kv" href="https://gist.github.com/rueian/8c18e905aa6b543d2b2dac8f975f2bef" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/rue Ian/8c 18 e 905 aa 6b 543 D2 b 2 DAC 8 f 975 F2 bef</a></p></figure><p id="99b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将处理我们的写作程序中的繁忙循环。</p><h1 id="da39" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">在没有<code class="fe ls lt lu lv b">sync.Mutex</code>的情况下，通过<code class="fe ls lt lu lv b">sync.Cond</code>最小化坏忙循环</h1><p id="5e97" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在我们的新<code class="fe ls lt lu lv b">EnqueueRequest</code>中，只有当环总是被回收时，才会有锁争用。</p><p id="dcc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们以同样的方式在我们的writing goroutine上使用<code class="fe ls lt lu lv b">sync.Cond</code>，这意味着每个<code class="fe ls lt lu lv b">EnqueueRequest</code>调用都需要访问我们的writing goroutine的<code class="fe ls lt lu lv b">sync.Cond</code>，以检查是否有必要唤醒它。这无疑会有很多锁争用。</p><p id="6146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，这种情况下我们不需要真正的<code class="fe ls lt lu lv b">sync.Locker</code>。我们可以稍微放松一下我们写程序的睡眠状态，并且仍然使它不占用一个CPU内核。</p><p id="e164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当不再有飞来飞去的<code class="fe ls lt lu lv b">EnqueueRequest</code>呼叫时，我们才让我们的写作程序进入睡眠状态，并且只在下一个<code class="fe ls lt lu lv b">EnqueueRequest</code>唤醒它。</p><p id="ea7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们使用两个原子计数器:<code class="fe ls lt lu lv b">waits</code>和<code class="fe ls lt lu lv b">sleep</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="dd8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe ls lt lu lv b">sleep</code>计数器来标记写入程序何时进入休眠状态以及何时被唤醒。</p><p id="7958" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在进入<code class="fe ls lt lu lv b">EnqueueRequest</code>前增加<code class="fe ls lt lu lv b">waits</code>计数器，离开后减少计数器。如果在我们增加后<code class="fe ls lt lu lv b">waits</code>计数器为1，我们将尝试用<code class="fe ls lt lu lv b">cond.Broadcast()</code>唤醒写入程序。</p><p id="8276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是，我们先访问<code class="fe ls lt lu lv b">waits</code>计数器，然后在<code class="fe ls lt lu lv b">makeRequest</code>函数中访问<code class="fe ls lt lu lv b">sleep</code>计数器，而另一方面，我们先访问<code class="fe ls lt lu lv b">sleep</code>计数器，然后在<code class="fe ls lt lu lv b">writing</code>函数中访问<code class="fe ls lt lu lv b">waits</code>计数器。</p><p id="2fd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些颠倒的访问顺序可以保证我们不会错过唤醒goroutine的机会。</p><p id="efe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们仍然使用一个繁忙的循环来唤醒我们的<code class="fe ls lt lu lv b">makeRequest</code>函数中正在写的goroutine，但是这个繁忙的循环比前一个要好，因为我们知道它很快就会完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="02c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让写程序进入睡眠状态确实会增加一些开销。但是，现在它不会在没有请求发送的时候占用和浪费你的一个CPU。</p><p id="dee4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更新</strong>:完全消除繁忙环路实际上是可能的。看看https://github.com/rueian/rueidis/pull/9/files的<a class="ae kv" href="https://github.com/rueian/rueidis/pull/9/files" rel="noopener ugc nofollow" target="_blank">看看怎么做。</a></p><h1 id="2fe1" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">下一步是什么:关闭拥有并发作者的渠道</h1><p id="3804" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">线程安全客户端库的最后一部分可能是如何关闭它的问题。最后一个帖子，我会分享<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>是如何优雅处理的。</p><h1 id="b52a" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">附录</h1><div class="nl nm gp gr nn no"><a href="https://pkg.go.dev/golang.org/x/sync/semaphore" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">旗语</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Example_workerPool演示了如何使用信号量来限制处理并行任务的线程数量…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pkg.go.dev</p></div></div></div></a></div></div></div>    
</body>
</html>