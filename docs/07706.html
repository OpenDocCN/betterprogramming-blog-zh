<html>
<head>
<title>A Deeper Look at Async and Concurrent Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Python中的异步和并发编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deeper-look-at-async-and-concurrent-programming-in-python-9f2a84adbdd2?source=collection_archive---------5-----------------------#2021-02-11">https://betterprogramming.pub/a-deeper-look-at-async-and-concurrent-programming-in-python-9f2a84adbdd2?source=collection_archive---------5-----------------------#2021-02-11</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="8d43" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">“WebSockets和AsyncIO:超越5行示例”的续集</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/6a7193d60ed55a40e99e24ce9a24dbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zN28k1CySahwVRQkeTBkRQ.jpeg"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@jizhidexiaohailang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pocky Lee </a>在<a class="ae kw" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8257" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在上一篇文章的后续文章中，我讨论了WebSockets、异步编程和Python并发性范围内的设计、库和质量保证。</p><p id="5579" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在第一篇文章中，我们看了一下WebSockets技术以及它如何适应Python。我还提出了一个虚构的用例来为讨论添加更多的上下文。</p><p id="8a26" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在是时候将注意力转移到<a class="ae kw" href="https://docs.python.org/3.8/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> AsyncIO </a>了，这是一个使用async/await语法编写并发代码的内置库。(如果你不熟悉的话，我推荐你看一下这个教程。)和<code class="fe lt lu lv lw b">websockets</code>，<code class="fe lt lu lv lw b">asyncio</code>将允许我们满足所提议用例的需求。</p><p id="9fb2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在<a class="ae kw" href="https://github.com/ricardolsmendes/websockets-asyncio" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上有完整的例子；<code class="fe lt lu lv lw b"><a class="ae kw" href="https://github.com/ricardolsmendes/websockets-asyncio/blob/main/document_inspector.py" rel="noopener ugc nofollow" target="_blank">document_inspector.py</a></code>是主文件。解释200多行代码中的每一行会很无聊，所以让我们把重点放在关键特性上。</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="d3bc" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">并发处理</h1><p id="d357" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">我在上一篇文章的结尾说，并发任务可以用来处理WebSocket通信通道中的消息和回复。将其转化为编程语言，我们最初需要将消息发送者和接收者任务表示为函数。函数是Python中的一级对象，这意味着它们可以作为参数传递给其他函数。</p><p id="5253" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">AsyncIO配备了可唤醒的<code class="fe lt lu lv lw b">asyncio.gather()</code>功能。它用于以给定的顺序运行并发函数，如下面的代码片段所示。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段1。asyncio.gather()用法示例</p></figure><p id="1265" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">results</code>名单预计有两个要素。第一个存储消息发送者的结果，可以忽略。第二个存储接收者的结果，这意味着成功执行时要返回的对象。</p><p id="a2f1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在这个虚构的用例中，我们还可以利用<code class="fe lt lu lv lw b">asyncio.gather()</code>:在收到<code class="fe lt lu lv lw b">GetDocument</code>回复(步骤1)后，我们需要发送<em class="nd"> n </em>条消息来获取详细的小部件容器信息，这取决于给定文档中图形小部件的数量(步骤2)。为了减少文档检查时间，可以同时发送这些消息，如下所示:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段2。另一个asyncio.gather()使用示例</p></figure><p id="01ad" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">正如我们所见，<code class="fe lt lu lv lw b">asyncio</code>使得运行并发函数并无缝获取它们的结果值变得容易。还支持异常处理。(详情请参考<a class="ae kw" href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.gather" rel="noopener ugc nofollow" target="_blank">官方文档</a>。)</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="c799" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">任务同步问题</h1><p id="1ed0" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">现在我们知道了如何并发运行发送方和接收方任务，是时候解决另一个问题了:同步。在建议的用例中，开始步骤2依赖于步骤1的成功，开始步骤3依赖于来自步骤2的至少一个回复。发生这种情况是因为构建要在接下来的步骤中发送的消息依赖于从以前的回复中收集的数据。看看这个基于<code class="fe lt lu lv lw b">syncio.Event</code>的方法来解决这个问题。</p><blockquote class="ne"><p id="cd2f" class="nf ng ir bd nh ni nj nk nl nm nn ls dk translated">"异步事件可以用来通知多个任务某个事件已经发生. "</p><p id="c62d" class="nf ng ir bd nh ni nj nk nl nm nn ls dk translated">— <a class="ae kw" href="https://docs.python.org/3.8/library/asyncio-sync.html#asyncio.Event" rel="noopener ugc nofollow" target="_blank"> AsyncIO事件文档</a></p></blockquote><p id="af2a" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">由于示例工作负载的特征，发送方启动工作负载，并且可以休眠，直到有一些回复需要处理。然后它醒来，处理回复，包括发送后续消息(如果需要)，并再次休眠，直到有新的回复可用。但是谁知道新的回复刚刚到。接收器！</p><p id="15a6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这意味着两个任务都应该可以访问一个共享的<code class="fe lt lu lv lw b">asyncio.Event</code>对象。创建<code class="fe lt lu lv lw b"><a class="ae kw" href="https://github.com/ricardolsmendes/websockets-asyncio/blob/main/send_receive_sync_helper.py" rel="noopener ugc nofollow" target="_blank">SendReceiveSyncHelper</a></code>类是为了支持任务同步。关于<code class="fe lt lu lv lw b">asyncio.Event</code>的使用细节，请参考<code class="fe lt lu lv lw b">__new_reply_event</code>属性和相关方法——顺便说一下，这非常简单。</p><p id="8563" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">不幸的是，仅仅发射一个事件是不够的。我们还需要一个缓冲区，允许接收者与发送者共享接收到的对象。这是<code class="fe lt lu lv lw b">__unhandled_replies</code>属性的工作。简而言之，接收方完成缓冲区，而发送方在处理完传入的回复后清除缓冲区。</p><p id="bd64" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">还有第三个属性值得特别关注:<code class="fe lt lu lv lw b">__pending_reply_ids</code>。它由一个数组组成，该数组保存待回复的id，这意味着它们所标识的消息已经发送但尚未回复。</p><p id="760e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下图说明了共享变量的总体使用情况。从步骤1和2开始:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nt"><img src="../Images/fcde13c99a6468916c91258eb8febc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfexpElVO_uwIbYZcN7bGg.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">图一。发送方/接收方同步— GetDocuments和GetWidgetContainer</p></figure><p id="2f1b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后，第2步和第3步:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nt"><img src="../Images/b23e10720549ed24b87758997fa92dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kG0bZBeY7NPYndFqDIQL0g.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">图二。发送方/接收方同步— GetWidgetContainer和GetWidgetProperties</p></figure><p id="caf7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">变量<code class="fe lt lu lv lw b">__pending_reply_ids</code>和<code class="fe lt lu lv lw b">__unhandled_replies</code>有助于决定WebSocket是否应该保持打开。当没有未决或未处理的回复时，对于给定的文档，检查工作量被认为已经完成，并且可以关闭连接。</p><p id="b7ad" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">你可以在<a class="ae kw" href="https://github.com/ricardolsmendes/websockets-asyncio/blob/main/document_inspector.py" rel="noopener ugc nofollow" target="_blank">完整示例</a>的<code class="fe lt lu lv lw b">__send_get_widgets_messages()</code>和<code class="fe lt lu lv lw b">__receive_get_widgets_messages()</code>方法中看到用来实现这些结果的代码。</p><p id="8ff0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在结束这一部分之前，值得一提的是，这个解决方案可以被改编/重用，以解决各种用例中的任务同步问题，而不仅仅是我的团队所面临的WebSockets挑战。</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="7a6c" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">错误处理</h1><p id="f980" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">并发任务将在成功执行时优雅地关闭。但是我们知道失败总是存在的，当失败发生时，最好准备好采取适当的措施来避免破坏应用程序。</p><h2 id="359a" class="nu mf ir bd mg nv nw dn mk nx ny dp mo lg nz oa mq lk ob oc ms lo od oe mu of bi translated">超时</h2><p id="5d2d" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">正如我已经提到的，当没有未决或未处理的回复时，对于给定的文档，检查工作量被认为已经完成。如果没有收到预期的回复，可能需要3秒或20秒，或者更长时间，从而阻塞整个工作负载。</p><p id="004d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用<code class="fe lt lu lv lw b">asyncio.wait_for()</code>，用户可以指定等待任务完成的时间。<a class="ae kw" href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.wait_for" rel="noopener ugc nofollow" target="_blank">如果超时，取消任务并引发</a>T7】错误。在提供的示例中，您可以看到<code class="fe lt lu lv lw b">__hold_websocket_communication()</code>被包裹在<code class="fe lt lu lv lw b">asyncio.wait_for()</code>中:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段3。asyncio.wait_for()用法示例</p></figure><h2 id="c434" class="nu mf ir bd mg nv nw dn mk nx ny dp mo lg nz oa mq lk ob oc ms lo od oe mu of bi translated">任务取消</h2><p id="735a" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">而<code class="fe lt lu lv lw b">__get_widgets()</code>调用又被包装在<code class="fe lt lu lv lw b">asyncio.AbstractEventLoop.run_until_complete()</code>中。我们将在下面的<strong class="kz is">同步与异步</strong>部分看到更多关于事件循环的内容。现在，只需注意<code class="fe lt lu lv lw b">asyncio.AbstractEventLoop.run_until_complete()</code>调用包含在<code class="fe lt lu lv lw b">try/except</code>块中，这允许我们在工作负载执行过程中出现任何异常时取消所有任务。</p><p id="ec8a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过取消任务，我们确保他们的资源将被释放。</p><p id="c953" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">正如我们在上面看到的，<code class="fe lt lu lv lw b">asyncio.wait_for()</code>在超时发生时取消任务，但是可能会引发不同类型的异常。所以用代码明确取消任务还是值得的。下面的代码片段显示了如何做到这一点:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段4。阿辛西奥。Task.cancel()用法示例</p></figure><h2 id="6365" class="nu mf ir bd mg nv nw dn mk nx ny dp mo lg nz oa mq lk ob oc ms lo od oe mu of bi translated">记录并返回</h2><p id="25e4" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">是时候讨论设计决策了。<code class="fe lt lu lv lw b">DocumentInspector</code>类中只有一个公共方法:<code class="fe lt lu lv lw b">get_widgets()</code>。它隐藏了我们迄今为止看到的所有复杂性，为用户提供了一个简化的界面。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段5。关于记录和返回的设计决策</p></figure><p id="b846" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">就异常处理而言，这是记录技术信息的唯一地方，因此程序输出保持简洁明了。基于这样的日志，可以很容易地进行故障跟踪。</p><p id="1ab1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，如果在获取给定文档小部件数据时出现异常，则返回一个空列表。对于这个虚构的用例，假设做出这个决定是为了防止由于每次执行中运行的一些不同工作负载中的错误而中断整个应用程序。有了详细的日志，零星的错误可能是可以接受的。如果它不符合您的需要，请考虑重新引发异常并在上游处理它。</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="6f04" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">同步与异步</h1><p id="91c8" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">您可能注意到了保留字<code class="fe lt lu lv lw b">async</code>和<code class="fe lt lu lv lw b">await</code>在第一段代码中比在最后一段中使用得更多。这是因为我使用了自下而上的方法来解释<code class="fe lt lu lv lw b">asyncio</code>的特性。我的意思是我从更复杂的<code class="fe lt lu lv lw b">DocumentInspector</code>内部/并发东西开始，以更简单的公共<code class="fe lt lu lv lw b">get_widgets()</code>方法结束。顺便说一下，该方法是同步的，而不是协程。</p><p id="9a49" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">同步和异步代码之间的桥梁是<code class="fe lt lu lv lw b">asyncio.AbstractEventLoop.run_until_complete()</code>方法。它返回给定协程的结果或引发其异常。</p><blockquote class="ne"><p id="8b90" class="nf ng ir bd nh ni nj nk nl nm nn ls dk translated">"事件循环是每个AsyncIO应用程序的核心."</p><p id="d75f" class="nf ng ir bd nh ni nj nk nl nm nn ls dk translated">— <a class="ae kw" href="https://docs.python.org/3.8/library/asyncio-eventloop.html#event-loop" rel="noopener ugc nofollow" target="_blank"> AsyncIO事件循环文档</a></p></blockquote><p id="8e09" class="pw-post-body-paragraph kx ky ir kz b la no js lc ld np jv lf lg nq li lj lk nr lm ln lo ns lq lr ls ik bi translated">在完整的例子中，我在<code class="fe lt lu lv lw b">__run_until_complete()</code>中调用了它，这是我们将在本文中讨论的最后一个方法。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段6。<code class="fe lt lu lv lw b">asyncio.new_event_loop().run_until_complete()</code>用法示例</p></figure><p id="36c0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">请注意，事件循环对象存储在一个变量中。这允许我们将其传递给<code class="fe lt lu lv lw b">__cancel_all_tasks()</code>——如前所述，在出现错误时取消并发任务——并在文档检查工作完成后正确关闭事件循环。</p><p id="5f35" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在看一下<code class="fe lt lu lv lw b">future</code> arg:它解析为<code class="fe lt lu lv lw b">asyncio.wait_for()</code>创建的协程。在运行时，它恰好是发送方和接收方任务的包装器。然后，事件循环拥有了运行工作负载所需的所有元素，并为<code class="fe lt lu lv lw b">get_widgets()</code>提供了一个在结束时返回的适当对象。</p><p id="972e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is">旁注</strong> : Python 3.7 <a class="ae kw" href="https://docs.python.org/3.7/library/asyncio-task.html#running-an-asyncio-program" rel="noopener ugc nofollow" target="_blank">临时引入了</a> <code class="fe lt lu lv lw b">asyncio.run()</code>作为对<code class="fe lt lu lv lw b">asyncio.AbstractEventLoop.run_until_complete()</code>的更高层次的方法。它完成了我在本节中描述的所有工作，外加<strong class="kz is">任务取消</strong>。虽然被宣布为<a class="ae kw" href="https://docs.python.org/3.8/glossary.html#term-provisional-api" rel="noopener ugc nofollow" target="_blank">临时API </a>，但其签名和行为从那时起就没有改变过(参考见<a class="ae kw" href="https://github.com/python/cpython/blob/3.7/Lib/asyncio/runners.py" rel="noopener ugc nofollow" target="_blank"> 3.7 </a>、<a class="ae kw" href="https://github.com/python/cpython/blob/3.8/Lib/asyncio/runners.py" rel="noopener ugc nofollow" target="_blank"> 3.8 </a>和<a class="ae kw" href="https://github.com/python/cpython/blob/3.9/Lib/asyncio/runners.py" rel="noopener ugc nofollow" target="_blank"> 3.9 </a>中的源代码)。如果你的项目不需要Python &lt; 3.7，那就值得考虑<code class="fe lt lu lv lw b">asyncio.run()</code>。</p><p id="8bef" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">好了，完成前一篇文章中介绍的虚构用例所需的主要工具已经就绪。在这里，我们结束了“操作”讨论。</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="0633" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">单元测试</h1><p id="3c5d" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">在这最后一节中，我将简要回顾单元测试相关的事项。它更多的是关于经验教训和未来的改进，而不是关于如何编写这样的测试的细节。</p><h2 id="c4fc" class="nu mf ir bd mg nv nw dn mk nx ny dp mo lg nz oa mq lk ob oc ms lo od oe mu of bi translated">Python版本怪癖</h2><p id="72cd" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">从Python 3.4 开始，AsyncIO就包含在标准库<a class="ae kw" href="https://docs.python.org/3.6/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">中。在3.5 </a>中添加了带有<code class="fe lt lu lv lw b">async</code>和<code class="fe lt lu lv lw b">await</code>语法的协程<a class="ae kw" href="https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-pep-492" rel="noopener ugc nofollow" target="_blank">。但是内置的<code class="fe lt lu lv lw b">unittest</code>模块在3.8 </a>中变成了<code class="fe lt lu lv lw b">asyncio</code>-特色<a class="ae kw" href="https://docs.python.org/3/whatsnew/3.8.html#unittest" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7b7c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">运行我的团队实际工作的代码需要Python 3.6+支持，这意味着需要变通方法来测试3.6和3.7中的异步代码。我们在Python 博客文章中使用了启发性的<a class="ae kw" href="https://medium.com/@AgariInc/strategies-for-testing-async-code-in-python-c52163f2deab" rel="noopener">策略来测试异步代码，作为完成工作的参考。</a></p><p id="3baa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们预计这是暂时的，当有协议要求Python ≥ 3.8来运行代码时，我们会更新单元测试——解决方法与3.8不兼容。因此，我不会在本节的剩余部分重复参考博客文章，而是将重点介绍最近的两个内置改进，这两个改进使得异步代码单元测试从3.8开始变得更加简单。</p><h2 id="ffca" class="nu mf ir bd mg nv nw dn mk nx ny dp mo lg nz oa mq lk ob oc ms lo od oe mu of bi translated"><strong class="ak">异步模拟</strong></h2><p id="fc4a" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">Python 3.8增加了<code class="fe lt lu lv lw b">AsyncMock</code>，支持<code class="fe lt lu lv lw b">Mock</code>的一个<a class="ae kw" href="https://docs.python.org/3.8/library/unittest.mock.html#unittest.mock.AsyncMock" rel="noopener ugc nofollow" target="_blank">异步版本</a>。<code class="fe lt lu lv lw b">AsyncMock</code>对象的行为使得该对象被识别为一个异步函数，并且调用的结果是一个可唤醒的。还添加了适当的新测试断言函数，例如<code class="fe lt lu lv lw b">assert_awaited()</code>、<code class="fe lt lu lv lw b">assert_awaited_with()</code>和<code class="fe lt lu lv lw b">await_count</code>。</p><p id="1037" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">也就是说，为异步函数编写单元测试现在非常类似于Python开发人员在测试同步代码时一直做的事情。例如:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段7。unittest.mock.AsyncMock用法示例</p></figure><h2 id="10a0" class="nu mf ir bd mg nv nw dn mk nx ny dp mo lg nz oa mq lk ob oc ms lo od oe mu of bi translated">上下文管理器和迭代方法</h2><p id="9014" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated"><code class="fe lt lu lv lw b">MagicMock</code>(你没看错，我说的已经不是<code class="fe lt lu lv lw b">AsyncMock</code>了)增强了。<a class="ae kw" href="https://docs.python.org/3.8/library/unittest.mock.html#magicmock-and-magic-method-support" rel="noopener ugc nofollow" target="_blank">魔法方法现在支持</a><code class="fe lt lu lv lw b">__aenter__</code><code class="fe lt lu lv lw b">__aexit__</code><code class="fe lt lu lv lw b">__aiter__</code><code class="fe lt lu lv lw b">__anext__</code>；因此，异步上下文管理器和迭代可以被无缝地模仿:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nb nc l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">代码片段8。unittest . mock . magic mock . _ _ aiter _ _用法示例</p></figure><p id="ee21" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后可以使用上面的模拟对象来测试异步for循环，比如<code class="fe lt lu lv lw b">async for message in websocket:</code>，它在样本代码中遍历WebSocket客户端接收到的消息。</p><p id="d3cb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你想看更多的单元测试例子，包括如何修补异步函数的建议，请参考GitHub 上的<a class="ae kw" href="https://github.com/ricardolsmendes/websockets-asyncio/blob/main/tests/document_inspector_test.py" rel="noopener ugc nofollow" target="_blank">配套资源库。我把一些试卷留在那里了。</a></p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="087b" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">最后的想法</h1><p id="c2e0" class="pw-post-body-paragraph kx ky ir kz b la mw js lc ld mx jv lf lg my li lj lk mz lm ln lo na lq lr ls ik bi translated">我已经介绍了WebSockets，对于AsyncIO来说差不多就是这些了。我相信他们还有很多有待发现的地方，但我希望在队友的帮助下，我已经足够清楚地提出了我目前所学到的东西。</p><p id="1218" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">本文中讨论的设计和策略目前正在生产代码中使用。他们帮助我们创建了一个易于维护的模块化解决方案，促进了重用，并对客户隐藏了复杂性。</p><p id="2d75" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">写作就是分享，所以我希望这里展示的知识可以帮助其他团队在他们的WebSockets和AsyncIO相关的挑战中茁壮成长。请不吝赐教，随时欢迎反馈。</p><p id="44e0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">万事如意！</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><h1 id="3980" class="me mf ir bd mg mh mi mj mk ml mm mn mo jx mp jy mq ka mr kb ms kd mt ke mu mv bi translated">参考</h1><ul class=""><li id="9a53" class="og oh ir kz b la mw ld mx lg oi lk oj lo ok ls ol om on oo bi translated">Python中的异步IO，完整演练:<strong class="kz is"/><a class="ae kw" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/async-io-python/</a></li><li id="db47" class="og oh ir kz b la op ld oq lg or lk os lo ot ls ol om on oo bi translated">Python中测试异步代码的策略:<strong class="kz is"/><a class="ae kw" href="https://medium.com/@AgariInc/strategies-for-testing-async-code-in-python-c52163f2deab" rel="noopener">https://medium . com/@ agari Inc/strategies-for-Testing-Async-Code-in-Python-c 52163 F2 deab</a></li><li id="0b10" class="og oh ir kz b la op ld oq lg or lk os lo ot ls ol om on oo bi translated">Python中的AsyncIO、线程和多处理:<strong class="kz is"/><a class="ae kw" href="https://medium.com/analytics-vidhya/asyncio-threading-and-multiprocessing-in-python-4f5ff6ca75e8" rel="noopener">https://medium . com/analytics-vid hya/AsyncIO-Threading-and-multi processing-in-Python-4 F5 ff 6 ca 75 e 8</a></li></ul></div></div>    
</body>
</html>