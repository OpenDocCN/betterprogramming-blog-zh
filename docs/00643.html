<html>
<head>
<title>Breaking Down ORM and Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解ORM和Ruby</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/breaking-down-orm-and-ruby-aa8174c4b632?source=collection_archive---------4-----------------------#2019-06-24">https://betterprogramming.pub/breaking-down-orm-and-ruby-aa8174c4b632?source=collection_archive---------4-----------------------#2019-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="70b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头到尾构建一个ORM设置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83187189c0e9b1cc72df8e2fe5cebcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NlqpTTAM8DbGl4paBmjE_g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托夫·高尔在<a class="ae ky" href="https://unsplash.com/search/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请注意:</strong>这篇文章大量引用了熨斗学校实验和讲座ORM部分的几个学习模块。</p><p id="708b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是这些模块的重复——以我能解释的最简单、最详细的方式从头到尾构建一个ORM设置。由于这种复杂的润色，这篇文章相当冗长。然而，它应该为读者提供丰富的信息。</p><p id="d680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，这篇文章的例子使用了<a class="ae ky" href="https://www.sqlite.org/" rel="noopener ugc nofollow" target="_blank"> SQLite3 </a>作为他们的SQL版本。示例中使用的逻辑应该是相同的，但是不同SQL版本之间的语法可能会有所不同。</p><blockquote class="lv lw lx"><p id="a351" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it">“ORM是一种使用面向对象语言访问关系数据库的技术。它允许语言通过将数据库表“映射”到类来管理数据库数据。行是由这些类的实例组成的。</em>——<em class="it">转述自学习模块“ORM为什么有用”。</em></p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="8306" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">ORM —对象关系映射</h1><p id="0516" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这到底是什么意思？描述ORM的另一种方式是，通过使用这种技术，您可以创建一个“虚拟对象数据库”，它可以在面向对象语言中使用和操作(正如Sitepoint上的一篇文章所描述的)。</p><p id="8608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为数据在对象中的处理方式不同于在数据库中的处理方式，所以我们使用ORM来弥合这一差距，并在两者之间建立联系。</p><p id="b939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以被看作是某种翻译。假设你在一个使用英语键盘的日本网站上。你下载一个扩展来翻译网站上的内容，同时也把你的英文字符翻译成日文。</p><p id="678b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用该扩展，您可以看到网站上的信息，并随后访问这些信息。在这个例子中，日语网站可以理解为数据库，英语键盘可以理解为面向对象的语言(如<a class="ae ky" href="https://www.ruby-lang.org/en/" rel="noopener ugc nofollow" target="_blank"> Ruby </a>)，而翻译扩展可以理解为ORM。</p><p id="c2a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ORM将SQL的编码传递给Ruby，提高了效率。</p><p id="e79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL可能是一种很难编程的语言，此外，它的许多命令可能非常重复。例如，向数据库中添加新数据需要一整行代码，每次你想放入新数据时都必须编写代码。</p><p id="a654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要介意这样一个事实，您可能有一个包含几个参数的健壮表，您每次都必须输入所有这些参数，然后输入它们的后续值。</p><p id="9a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用ORM作为联络工具，而不是编写大量的SQL代码。在一个类中，我们可以创建一个类似这样的<code class="fe ng nh ni nj b">self.save</code>方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/dc4c1140f90da009bdccfadad2d2a9f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tTZSyic9_iZtZVsxBen9w.png"/></div></div></figure><p id="80b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">database_connection</code>变量只是连接到我们的数据库，在本例中名为<code class="fe ng nh ni nj b">ex_database.db</code>。</p><p id="9d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">execute</code>方法将一条SQL语句作为参数，并执行它。</p><p id="4ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL语句中的问号表示要插入的参数，参数本身会在要插入的语句后立即列出。</p><p id="6a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那里，使用类的类变量<code class="fe ng nh ni nj b">@@all</code>，我们可以做类似这样的事情:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/1d194c97fe0c1433cf4d08eb4936cccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*TzsglYT2x-CbcTYH5qoUlA.png"/></div></figure><p id="e715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们在<code class="fe ng nh ni nj b">Class</code>的所有实例上调用<code class="fe ng nh ni nj b">save</code>方法。每个实例都将经历<code class="fe ng nh ni nj b">save</code>方法，这意味着每个实例都将其参数插入到<code class="fe ng nh ni nj b">save</code>方法中的<code class="fe ng nh ni nj b">execute</code>方法中。</p><p id="13b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们为每个实例及其参数创建一个新的SQL语句，并执行它。</p><p id="c35a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们的SQL语句有<code class="fe ng nh ni nj b">INSERT INTO</code>，所以我们将新数据插入到<code class="fe ng nh ni nj b">ex_database.db</code>。这比逐个输入单个SQL命令要快得多。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d07a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用Ruby和ORM创建数据库</h1><p id="0718" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">假设我们有一个音乐库数据库，包含歌曲和艺术家。每首歌曲都有一个艺术家，但是一个艺术家可以有多首歌曲。</p><p id="73da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建数据库，我们将使用以下内容创建一个<code class="fe ng nh ni nj b">environment.rb</code>文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/f95ea9b28b57180675dc7c72c3f241ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KD1QjPydtgvbhOmIqkcF4w.png"/></div></div></figure><p id="e2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先需要建立音乐数据库。</p><p id="26c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个Ruby文件中，我们需要使用一个SQL程序(在这个例子中是SQLite3)，以及我们想要转换成这个数据库中的表的任何文件。在我们的例子中，这些文件是<code class="fe ng nh ni nj b">.rb</code>文件——因此，我们首先需要在这些文件中存储一些类，这些类将在以后进行转换。对我们来说重要的文件被命名为<code class="fe ng nh ni nj b">song.rb</code>和<code class="fe ng nh ni nj b">artist.rb</code>。</p><p id="00c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe ng nh ni nj b">DB</code>常量被设置为一个散列值——我们基本上是说我们的连接(key) <code class="fe ng nh ni nj b">:conn</code>将会转到一个名为<code class="fe ng nh ni nj b">music.db</code> <strong class="lb iu"> </strong> (value)的新数据库。该数据库将由SQLite3访问和修改。</p><p id="0f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后可以使用<code class="fe ng nh ni nj b">DB[:conn]</code>在我们的<code class="fe ng nh ni nj b">song.rb</code>和<code class="fe ng nh ni nj b">artist.rb</code>文件中调用它。</p><p id="4097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，当我们调用hash的键时，返回的是相应的值，所以这实际上是指向<code class="fe ng nh ni nj b">music.db</code>数据库。</p><p id="a77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的下一步是填充<code class="fe ng nh ni nj b">song.rb</code>和<code class="fe ng nh ni nj b">artist.rb</code>文件。出于这个例子的目的，我们将使用<code class="fe ng nh ni nj b">song.rb</code>文件，因为创建<code class="fe ng nh ni nj b">artist.rb</code>文件将遵循非常相似的过程。</p><p id="6578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先创建一个<code class="fe ng nh ni nj b">Song</code>类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/e1505e206e118d639b19df57b4d1a38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXE2pN1HtDTv8QWIR4sq5g.png"/></div></div></figure><p id="b724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类最终会变成一个表。传统的ORM结构以复数形式命名它的表——因此，当这个类被“转换”成一个表时，它将被称为“songs”表。</p><p id="7d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到这个类有许多与非ORM关联类相同的特性——它有带有典型属性的<code class="fe ng nh ni nj b">attr_accessors</code>,还有一个<code class="fe ng nh ni nj b">:id</code>属性。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="4268" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">id属性成为表的主键</h1><p id="4c1f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当<code class="fe ng nh ni nj b">Song</code>的一个实例被移入数据库时，<code class="fe ng nh ni nj b">:id</code>属性将被转换为主键。</p><p id="86be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有一个缺省值<code class="fe ng nh ni nj b">nil</code>，因为当一个实例被创建时，它的主键/id将在该实例被移入数据库时被创建。</p><p id="bfd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序员自己不定义主键/id。我们让ORM来分配它们，因为当创建一个新的实例时，跟踪每首歌曲的id对我们来说是一个巨大的痛苦。通过用ORM自动化这个过程，我们有了一种更快、更少出错的分配主键的方法。</p><p id="a95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实际上通过创建一个<code class="fe ng nh ni nj b">self.create_table</code>方法来创建歌曲表(来自类<code class="fe ng nh ni nj b">Song</code>)。这是一个类方法，因为一个实例创建一个表是没有意义的——否则，每个实例都有一个表，这在很大程度上是没有用的。</p><p id="8dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使<code class="fe ng nh ni nj b">create_table</code>成为一个类方法，我们涉及到了<code class="fe ng nh ni nj b">Song</code>的所有实例，这些实例稍后将被映射到songs表。</p><p id="ce4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用的是<code class="fe ng nh ni nj b">sql = &lt;&lt;- SQL</code>这条线。</p><p id="2bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双箭头语法<code class="fe ng nh ni nj b">&lt;&lt;-</code>允许创建一个<code class="fe ng nh ni nj b">heredoc</code>，它是一个多行字符串文字。这允许用户在一个字符串中键入几行，并允许他们在需要的地方形成新的行。</p><p id="8de5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有用，因为我们必须在这里放入一个SQL命令——如果我们试图使用一个常规的字符串，它会很长，每次当您关注该字符串的内容时，您都必须向右滚动。</p><p id="0a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Heredocs以指示该字符串的开始和结束的序列开始和结束(注意:在这篇文章中，我可能会将这样的序列称为“侧翼序列”，因为它们包围该字符串的性质)。</p><p id="6a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们在字符串开始和结束之前使用了序列<code class="fe ng nh ni nj b">SQL</code>。<code class="fe ng nh ni nj b">SQL</code>在这里是一个很好的序列——它明确地说明了该字符串的内容与什么相关。</p><p id="2233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">heredoc中包含的SQL代码是这样说的，“如果没有名为‘songs’的表，那么创建一个具有以下三个属性的表:id(主键)是一个整数，name是text(字符串)，album也是text(字符串)。”</p><p id="05cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成所有这些之后，我们可以虚拟地认为<code class="fe ng nh ni nj b">songs</code>表正在被创建。<code class="fe ng nh ni nj b">songs</code>表将是音乐库数据库中的几个表之一。</p><p id="5503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，一个数据库包含多个表。出于我们的目的，我们将只关注其中一个。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0089" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">如何将对象数据发送到表中</h1><p id="6cc4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">很容易假设整个Ruby对象被发送到位于整个数据库中的表中。然而，事实并非如此。</p><p id="8da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，数据库不会识别Ruby对象。实际发生的是对象的<em class="ly">属性</em>被发送过来，在表中编译一行。</p><p id="01ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，这意味着对于<code class="fe ng nh ni nj b">Song</code>，将<code class="fe ng nh ni nj b">@name</code>和<code class="fe ng nh ni nj b">@artist</code>发送到<code class="fe ng nh ni nj b">songs</code>表，<em class="ly">而不是</em>整个<code class="fe ng nh ni nj b">Song</code>对象。</p><p id="402e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更清楚地说，如果我们有一个<code class="fe ng nh ni nj b">back_to_black</code>变量，它是<code class="fe ng nh ni nj b">Song</code>的实例，带有<code class="fe ng nh ni nj b">@name</code> = "Back to Black "和<code class="fe ng nh ni nj b">@artist</code> = "Amy Winehouse "，那么将被发送的是" Back to Black "和" Amy Winehouse "，而不是<code class="fe ng nh ni nj b">back_to_black</code>对象本身。</p><p id="f0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从视觉上看，它应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/405351f337a3c50653ce01f0faef04d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*rM4P3yvvC5_DObDSdyz6iQ.png"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="13ef" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">重新审视保存方法</h1><p id="fd9c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们已经讨论了<code class="fe ng nh ni nj b">save</code>方法应该做什么，但是这次我们将从<code class="fe ng nh ni nj b">Song</code>类的角度来看。</p><p id="902e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们设置一个var <code class="fe ng nh ni nj b">sql</code>等于一个heredoc(使用序列“SQL”作为多行字符串的侧翼序列)，我们的字符串是一个SQL代码，表示“对于表songs中的值(name，album)，输入这些值(value1，value2)”。</p><p id="7857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们引用DB常量，并执行命令。</p><p id="b280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，键入<code class="fe ng nh ni nj b">hash[:key]</code>实际上指向那个键的<em class="ly">值</em>，所以我们真正指向的是数据库<code class="fe ng nh ni nj b">:conn</code>所绑定的(<code class="fe ng nh ni nj b">music.db</code>)。</p><p id="b02a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在这个数据库上运行<code class="fe ng nh ni nj b">.execute</code>方法时，我们使用<code class="fe ng nh ni nj b">sql</code>、<code class="fe ng nh ni nj b">self.name</code>和<code class="fe ng nh ni nj b">self.album</code>作为参数。</p><p id="9230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，我们在这个保存方法中使用<code class="fe ng nh ni nj b">sql</code>作为局部变量，而<code class="fe ng nh ni nj b">sql</code>只是一个SQL代码片段。</p><p id="425e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们<em class="ly">实际上</em>说的是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/53c4d5514621f354213c8dcb4036a0a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MgSJL-8qxK3twoBc1nDrA.png"/></div></div></figure><p id="5f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们还没有向<code class="fe ng nh ni nj b">music.db</code>数据库发送任何东西。</p><p id="ca15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，要在数据库中创建歌曲表，我们首先要调用<code class="fe ng nh ni nj b">Song.create_table</code>。</p><p id="4e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以调用<code class="fe ng nh ni nj b">back_to_black.save</code>，它将获取<code class="fe ng nh ni nj b">back_to_black</code> <strong class="lb iu">、</strong>的<code class="fe ng nh ni nj b">@name </code>和<code class="fe ng nh ni nj b">@artist</code>值，并以行的形式发送到song表中。</p><p id="c458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该行在创建后会自动分配一个主键，位于<code class="fe ng nh ni nj b">songs</code>表的<code class="fe ng nh ni nj b">id</code>列下。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d3f7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">@id属性的重新分配:从表中获取主键，并将其值设置为@id</h1><p id="884c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们将数据发送到数据库中的表之前，<code class="fe ng nh ni nj b">back_to_black</code>的<code class="fe ng nh ni nj b">@id</code>值是<code class="fe ng nh ni nj b">nil</code>。</p><p id="ad7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在表中，它会自动被赋予一个主id形式的值。然而，回到Ruby方面，它仍然是<code class="fe ng nh ni nj b">nil</code>。</p><p id="b2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们需要做的是——现在我们的表已经存在，并且已经为<code class="fe ng nh ni nj b">back_to_black</code>的数据分配了一个主键——我们想要获取这个主键并为其设置<code class="fe ng nh ni nj b">@id</code>。</p><p id="5dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实质上，我们是将<code class="fe ng nh ni nj b">@id</code>从它之前的值<code class="fe ng nh ni nj b">nil</code>重新分配给它在<code class="fe ng nh ni nj b">songs</code>表中的主键的新值。</p><p id="d6c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们设置了<code class="fe ng nh ni nj b">@id = DB[:conn].execute(“SELECT last_insert_rowid() FROM songs”)[0][0]</code>。</p><p id="1bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码清楚地表明，“<code class="fe ng nh ni nj b">back_to_black</code>的<code class="fe ng nh ni nj b">@id</code>以前是<code class="fe ng nh ni nj b">nil</code>。通过进入<code class="fe ng nh ni nj b">music.db</code>数据库重新分配它，并从那里进入歌曲表。从那个表中，转到我们刚刚插入了<code class="fe ng nh ni nj b">back_to_black</code>的数据的那一行。从那一行，得到它的<code class="fe ng nh ni nj b">id</code>。那个<code class="fe ng nh ni nj b">id</code>是<code class="fe ng nh ni nj b">back_to_black</code>的<code class="fe ng nh ni nj b">@id</code>属性将要被赋值的值。"</p><p id="bb71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之所以要写<strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">[0][0]</code>，是因为从数据库传输的数据在Ruby中是以数组的形式返回的。如果返回多行数据，那么将返回一个数组的数组，形式类似于<strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">[[row1.name, row1.artist]</code> <strong class="lb iu">、</strong> <code class="fe ng nh ni nj b">[[row2.name, row2.artist]]</code>。</p><p id="c418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们返回的数组中，我们将有一行数据，但只是其中的一部分。所以，我们得到了<strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">[[1]]</code>。要访问1，我们必须从返回的数组中获取第一个(也是唯一一个)元素，这是一个数组。然后我们得到数组的第一个元素，也就是1。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="55b4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">创建类的新实例并将属性推送到表中</h1><p id="dae5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">self.create</code> class方法是创建一个类的新实例的有效方法，并将所述实例的属性推送到一个表中(同时重新分配实例的<code class="fe ng nh ni nj b">@id</code>值)。</p><p id="0086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe ng nh ni nj b">self.create</code>类方法总结了我们到目前为止所做的很多事情。</p><p id="c113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法的目的是消除程序员创建一个类的新实例，然后在那个类上运行<code class="fe ng nh ni nj b">.save</code>，然后<em class="ly">和</em>从数据库中检索<code class="fe ng nh ni nj b">id</code>以分配给那个实例的<code class="fe ng nh ni nj b">@id</code>的过程。</p><p id="09db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了加快整个过程，我们应该使用一种方法！</p><p id="5313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">self.create</code>方法将name和album参数用作<code class="fe ng nh ni nj b">Song.new</code>的参数，然后在该实例上运行<code class="fe ng nh ni nj b">.save</code>。</p><p id="25ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们不想隐式返回<code class="fe ng nh ni nj b">.save</code>的结果，而且我们<em class="ly">肯定</em>不想自己到处跑并试图从<code class="fe ng nh ni nj b">songs</code>表中提取这个新实例，所以我们只是返回新的<code class="fe ng nh ni nj b">Song</code>实例。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9771" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">将数据库表映射到Ruby对象</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/c319fb1675d8d0d2a3171bd2e22c1297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izIZE8yX0uB4l53DlXzIoQ.png"/></div></div></figure><p id="b1d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经看到，我们可以创建Ruby对象，获取其数据的属性，并将这些数据推送到数据库中的一个表中。</p><p id="0ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以做相反的事情——也就是说，我们可以使用ORM从已建立的数据库中预先存在的表中获取数据。</p><p id="72df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，让我们回忆一下我们的<code class="fe ng nh ni nj b">back_to_black</code>变量——带有<code class="fe ng nh ni nj b">@name</code> =“回到黑色”和<code class="fe ng nh ni nj b">@artist</code> =“艾米·怀恩豪斯”的<code class="fe ng nh ni nj b">Song</code>类的一个实例。</p><p id="ea0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们目前仍然有这个变量，但假设我们错误地删除了它。幸运的是，我们已经把它上传到了<code class="fe ng nh ni nj b">music.db</code>数据库的歌曲表中。</p><p id="a48d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们必须把它作为Ruby对象取回。我们如何做到这一点？</p><p id="9d74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表格存储纯数据，而Ruby对象要复杂得多。这意味着我们必须利用ORM，并在Ruby中创建一个方法来从表中提取数据并将其转换成有意义的东西。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0418" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">self.new_from_db方法将从表中获取数据，并将其转换为对象</h1><p id="5687" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">self.new_from_db</code> <strong class="lb iu"> </strong>方法是一个类方法，因为我们要用它创建新的<code class="fe ng nh ni nj b">Song</code> <strong class="lb iu"> </strong>实例。</p><p id="6d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们设置一个变量等于<code class="fe ng nh ni nj b">new_song = Song.new</code>。</p><p id="1c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在接下来的行中，我们设置新实例的<code class="fe ng nh ni nj b">@id</code>、<strong class="lb iu">、</strong>、<code class="fe ng nh ni nj b">@name</code>和<code class="fe ng nh ni nj b">@artist to row[#]</code>。</p><p id="c546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将这些属性设置为行数组的原因是，当数据从SQLite提取回Ruby时，它以数组的形式返回。</p><p id="4c8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数组的顺序反映了这个类的实例是如何被实例化的——在我们的def initialize方法中，我们按照这个顺序构造了<code class="fe ng nh ni nj b">@id</code>、<code class="fe ng nh ni nj b">@name</code>和<code class="fe ng nh ni nj b">@artist</code>，所以这就是<code class="fe ng nh ni nj b">songs</code>表上的列的顺序。</p><p id="b7bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ORM中的<code class="fe ng nh ni nj b">self.all</code>方法采用基于SQL的方法从表中检索数据</p><p id="ce50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SQL中，用<code class="fe ng nh ni nj b">SELECT * FROM</code> table命令返回一个表的所有值相当容易。</p><p id="4d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe ng nh ni nj b">Song.all</code>方法中，我们通过使用一个设置为heredoc的变量<code class="fe ng nh ni nj b">sql</code>来利用这一点，SQL命令的两侧是字符序列<code class="fe ng nh ni nj b">SQL</code>。</p><p id="a4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那里，我们必须调用<code class="fe ng nh ni nj b">DB[:conn]</code>来建立到<code class="fe ng nh ni nj b">music.db</code>数据库的连接，从而连接到songs表。</p><p id="5edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，我们经营<code class="fe ng nh ni nj b">SELECT * FROM songs</code>。</p><p id="5b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，SQLite以数组的形式将数据返回给Ruby，因此我们目前将获得一个只有一个数组的数组，因为“Back to Black”是我们添加到<code class="fe ng nh ni nj b">songs</code>表中的唯一内容。<code class="fe ng nh ni nj b">[ [1, “Back to Black”, “Amy Winehouse”] ]</code></p><p id="1e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个数组的数组。这意味着我们已经成功地获得了一些可以用来构建对象的Ruby数据。</p><p id="ef37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们在这个数组上运行<code class="fe ng nh ni nj b">map</code>，结合<code class="fe ng nh ni nj b">new_from_db</code>方法，创建一个新的<code class="fe ng nh ni nj b">Song</code>实例，并用从<code class="fe ng nh ni nj b">songs</code>表中提取的数据填充它。</p><p id="40f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如我们行数组的第一个元素是<strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">[1, “Back To Black”, “Amy Winehouse”]</code>。我们取1并将其设置为<code class="fe ng nh ni nj b">@id</code>，我们取“回到黑色”并将其设置为<code class="fe ng nh ni nj b">@name</code>，我们取“艾米·怀恩豪斯”并将其设置为<code class="fe ng nh ni nj b">@artist</code>。</p><p id="30da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数组中有更多的元素，我们将对它们进行同样的操作，直到遍历完整个数组。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6dc9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">self.find_by_name使用基于SQL的方法和Ruby来创建一个新的实例</h1><p id="f4b0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">虽然<code class="fe ng nh ni nj b">self.all</code>方法将为歌曲表中的每首歌曲创建新的实例，但我们可能不想每次都这样做。</p><p id="4047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设“Back to Black”是歌曲表中无数歌曲中我们想要创建的唯一歌曲对象。</p><p id="2eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将songs表中的所有行创建为元素，然后挖掘它们以找到我们想要的内容，这将是浪费和乏味的，因此，我们将使用SQL和Ruby，通过ORM的力量来获得我们想要的内容。</p><p id="e9c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个方法中，我们将<code class="fe ng nh ni nj b">sql</code>设置为一个基本上是这样说的命令，</p><p id="3bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“查看整个歌曲表，并返回其名称为“我告诉你”的歌曲的所有数据行。只还我一首歌。”</p><p id="7109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们要告诉SQL，我们关注的歌曲是“Back to Black”，所以我们将获得一个数组<strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">[ [1, “Back to Black”, “Amy Winehouse”] ]</code>。</p><p id="e5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们又有了这个数组的数组，可以从中创建一个对象。</p><p id="c631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将让这个数组的数组服从<code class="fe ng nh ni nj b">.map</code>，并对其运行<code class="fe ng nh ni nj b">new_from_db</code>，以创建一个新的<code class="fe ng nh ni nj b">Song</code>实例，将歌曲表中的数据用作其<code class="fe ng nh ni nj b">@id</code>、<code class="fe ng nh ni nj b">@name</code>和<code class="fe ng nh ni nj b">@artist</code>的值。</p><p id="6598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住<code class="fe ng nh ni nj b">.map</code>仍然返回一个数组，所以你会得到类似<strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">[#&lt;Song:0x083502585324de47de(1, “Amy Winehouse”, “Back to Black”)&gt;]</code>的返回。</p><p id="496b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们不想要一个数组，我们想要它里面的对象。要做到这一点，我们所要做的就是在这个数组上调用<code class="fe ng nh ni nj b">.first</code>，瞧！我们有目标了！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="0895" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">更新ORM中的现有记录</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/f7e01b2b5f1493ba991bc440128c85a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKuvOfjREEK6hRFr2KZwaA.png"/></div></div></figure><p id="b65f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多情况下，数据是动态的。你可能在一个邮寄名单上，并有一个地址的变化，你可以改变职业领域，甚至你喜欢的音乐类型。</p><p id="9f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们不仅需要像以前一样创建和检索数据，还必须在时机成熟时对其进行修改。对我们来说，现在正是时候。</p><p id="7085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经处理“回到黑色”这个变量很久了，你会认为我们已经记住了它的每一个音符。</p><p id="e216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，让我们说，当我们去上传这首歌，我们不小心命名为“回到未来”，我们已经上传到歌曲表。不管<em class="ly">为什么会发生这样的事情，它需要被修复。</em></p><p id="efbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe ng nh ni nj b">find_by_name</code>方法检索这些数据，并将我们得到的信息设置回一个变量，就像这样:</p><p id="919d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">back_to_black = Song.find_by_name(“Back to the Future”)</code></p><p id="96d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以修改我们得到的对象，通过对它执行<code class="fe ng nh ni nj b">.name=</code>方法。</p><p id="d0ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，就像现在这样，我们在歌曲表中还有一行“回到未来”。如果我们将新的<code class="fe ng nh ni nj b">back_to_black</code>变量更新到表中，我们没有覆盖任何内容，我们只是添加了一首艾米·怀恩豪斯的新歌。</p><p id="caae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实际更改现有的行，我们应该利用SQL的<code class="fe ng nh ni nj b">UPDATE</code>方法。</p><p id="5579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法确实如它所说的那样做——一旦你指向你想在表格中改变什么的地方，也许使用一些参数和/或条件，它就会那样做。</p><p id="1fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了执行这个，我们创建了一个更新方法，它说，“查找这个表，我们要更新它。为匹配的id重置名称和艺术家值。</p><p id="c77e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们通过调用<strong class="lb iu"> </strong> <code class="fe ng nh ni nj b">DB[:conn].execute</code>方法来实际执行这个命令。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="7427" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">避免在表中插入重复数据</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/9760253bb330d298f1eda90594eeb52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnnewyrX8FjpiAt1FDStGg.png"/></div></div></figure><p id="1f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经讨论了更新表中已经存在的数据，但是我们仍然没有解决重复数据的问题。</p><p id="d974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们的歌曲表中已经有了“Back to Black ”,没有什么可以阻止我们再次更新相同的内容——两者之间唯一不同的是它们的id。</p><p id="defb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们的<code class="fe ng nh ni nj b">save</code>方法反映了这一点。</p><p id="915d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它总是放入新的数据，而不实际检查这些数据是否真的是“新的”。</p><p id="ee20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有没有任何子句告诉它，“只有当数据实际上是新的才插入”。所以，我们必须修改它，使它更有选择性。</p><p id="d1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以使用一个<code class="fe ng nh ni nj b">if statement</code>。</p><p id="603d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能认为可以在SQL中使用<code class="fe ng nh ni nj b">WHERE</code>子句，但是编写这样的语句可能会更复杂。此外，如果我们试图上传的数据已经存在，我们甚至不想使用SQL。相反，我们首先想看看它是否在表中。</p><p id="516f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不使用SQL我们如何做到这一点？</p><p id="c9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经确定——每次一个新的数据上传到表中——它会被分配一个<code class="fe ng nh ni nj b">id</code>,然后我们会立即获取这个值，并将<code class="fe ng nh ni nj b">@id</code>从<code class="fe ng nh ni nj b">nil</code>重新分配给该id的值。</p><p id="3909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以用一个<code class="fe ng nh ni nj b">if</code>语句查询<code class="fe ng nh ni nj b">@id</code>的值——任何不是<code class="fe ng nh ni nj b">nil</code>或<code class="fe ng nh ni nj b">false</code>的都被认为是真的，因此被认为是真的。</p><p id="912c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对<code class="fe ng nh ni nj b">@id</code>的值的评估是<code class="fe ng nh ni nj b">true</code>，我们可以用我们的update方法更新表中的数据，而不是再次添加它。</p><p id="55ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe ng nh ni nj b">@id</code>仍然为空，那么<code class="fe ng nh ni nj b">else statement</code>将被运行，这意味着我们继续使用我们在<code class="fe ng nh ni nj b">save</code>方法中的原始代码，在songs表中创建一个新行，并从中获取一个id。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="1f42" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="f3d7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">就是这样！</p><p id="a3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该给你一个ORM如何与Ruby协同工作的概述。您已经学习了几种方法，从创建一个表到修改它的数据，以及将数据提取到Ruby对象。</p><p id="5ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，你就可以创建复杂的程序了！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="6c94" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">来源</strong></h1><ol class=""><li id="f514" class="nt nu it lb b lc nb lf nc li nv lm nw lq nx lu ny nz oa ob bi translated">Learn.co<em class="ly"/>ORM为什么有用<em class="ly">，</em>熨斗学校，<a class="ae ky" href="https://github.com/learn-co-students/ruby-orm-nyc-web-060319" rel="noopener ugc nofollow" target="_blank">https://github . com/learn-co-students/ruby-ORM-NYC-we b-060319</a></li><li id="123e" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">m .阿吉特·库玛尔(2014年)。“ORM In Ruby:简介<em class="ly">”Sitepoint，</em>【https://www.sitepoint.com/orm-ruby-introduction/ T2】</li><li id="ba6f" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">Learn.co“将Ruby类映射到数据库表”，<em class="ly">熨斗学校</em>，<a class="ae ky" href="https://github.com/learn-co-students/orm-mapping-to-tables-nyc-web-060319" rel="noopener ugc nofollow" target="_blank">https://github . com/learn-co-students/ORM-Mapping-to-tables-NYC-we b-060319</a></li><li id="cb9b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">Learn.co“将数据库表映射到Ruby对象”，<em class="ly">熨斗学校</em>，<a class="ae ky" href="https://github.com/learn-co-students/orm-mapping-db-to-ruby-object-nyc-web-060319" rel="noopener ugc nofollow" target="_blank">https://github . com/learn-co-students/ORM-Mapping-d B- to-Ruby-object-NYC-we b-060319</a></li><li id="3b0b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">Learn.co“用ORM更新记录”，<em class="ly">熨斗学校</em>，<a class="ae ky" href="https://github.com/learn-co-students/orm-updating-records-nyc-web-060319" rel="noopener ugc nofollow" target="_blank">https://github . com/learn-co-students/ORM-Updating-Records-NYC-we b-060319</a></li><li id="76c0" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">learn.co“防止记录复制”，<em class="ly">熨斗学校</em>，<a class="ae ky" href="https://learn.co/tracks/web-development-immersive-2-0-module-one/orms-and-active-record/orms/preventing-record-duplication" rel="noopener ugc nofollow" target="_blank">https://learn . co/tracks/web-development-immersive-2-0-module-one/orms-and-active-Record/orms/Preventing-Record-Duplication</a></li></ol></div></div>    
</body>
</html>