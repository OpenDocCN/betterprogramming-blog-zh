# Go 中的基准测试:子字符串与正则表达式

> 原文：<https://betterprogramming.pub/benchmarking-in-go-substrings-vs-regular-expressions-a84de7f0eb02>

## 讨论这些文本过滤策略的利弊

![](img/3ae04489d464c2f95f250d24f00a77d1.png)

在这个四部分系列的第三部分中，我们将使用我们的文本过滤工具作为测试主题来讨论 Go 中的基准测试。您可以在下面找到其他部分:

*   [第 1 部分:在 Go 中构建一个文本过滤工具](/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092)
*   [第 2 部分:添加正则表达式支持](https://medium.com/@gourikabang1996/part-2-how-to-prepare-for-your-next-coding-interview-d048b188301e)
*   [第 4 部分:针对 grep 的命令行基准测试](/benchmarking-command-line-tools-7d00ed4813cc)

之前，我们[构建了一个 Go 程序来删除不想要的文本](/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092)，我们[用正则表达式支持](https://medium.com/@gourikabang1996/part-2-how-to-prepare-for-your-next-coding-interview-d048b188301e)扩展了它。现在，我们将通过比较最初的子串搜索方法和增加的正则表达式模式匹配来了解 Go 中的基准测试。请注意，这里使用的方法很简单，旨在促进基准测试讨论，而不是客观地证明一种方法严格地比另一种方法快。

Go 的标准库[测试包](https://pkg.go.dev/testing)提供了广泛的测试支持(你可能已经见过表单`TestXxx(t *testing.T)`的函数)，以及通过[类型 B](https://pkg.go.dev/testing#B) 的基准测试支持。`B`便于管理基准计时、迭代等。，以及清除、记录或测试失败的典型实用函数。

使用这些工具，我们可以了解使用子串或模式匹配工具是否运行得更快(在这些场景下)。

# 设定基准

Go 基准是位于`<filename>_test.go`文件中的函数，其中`<filename>`通常是包含要测试的函数的文件名。这两个文件通常在同一个包中，基准函数采用以下形式:

```
func BenchmarkXxx(b *testing.B) { // benchmark code }
```

在编写基准测试时，我们通常需要一些特定于代码的初始设置，然后进入一个循环，该循环将多次运行被测代码(由测试包确定[)。最后，我们被告知运行了多少个循环，以及运行每个循环花费了(平均)多长时间。从那里，我们可以分析代码性能。](https://pkg.go.dev/testing#hdr-Benchmarks)

我们将从设置一个带有几行文本的`[]string`开始——这对于子串和模式匹配搜索来说很常见。然后我们将构建一个包含一组`keys`或`pattern`的`config`，然后我们将针对输入文本运行`lineMatches()`(在基准循环中)，并查看每次迭代需要多长时间。我们将使用不同数量的关键短语和模式复杂性(每个都是为匹配相同的文本而构建的)来做这件事，并比较结果。

# 建立基准

我们的基准将非常简单:它们都将使用相同的输入文本，并生成一个带有`keys`或`pattern`的`config`。我们将为每种查询类型制定一致的子串搜索和模式匹配基准。然后，我们只需要运行测试并比较结果。

我们将使用以下内容作为输入测试(与`example/input.txt`中相同):

## 基准匹配“hello”—这将匹配我们输入中的所有行

## 基准匹配“大”——这将匹配两个输入行

## 基准匹配“大”、“亮”、“弯”和“亮”——这将匹配三条输入线

# 运行基准测试

最后，我们可以通过运行以下命令来运行我们的所有基准:

`go test -bench=.`

在项目 repo 的根目录中，这会产生以下结果:

第一列是基准的名称。第二列是使用了多少个循环(想想:`b.N`的值)，第三列是运行一个循环所用的平均时间。在我们的例子中，每个循环在所有的`inputText`中搜索子串或模式匹配。

请注意，附加到每个测试名称的`-10`表示用于测试的 CPU 内核数量(在我的例子中是 10)。

我们可以看到，在 Apple Silicon Mac 上的上述测试中，子串搜索比实现的模式匹配快 3.55 倍到 83.74 倍。

# 包扎

这是否意味着我们应该总是选择子串搜索？不一定。

在软件方面，我们必须为正确的工作选择正确的工具。你能用锤子把螺丝拧进去吗？从技术上来说是的，但它远非理想。如果您可以用一个或几个子字符串匹配您关心的文本，这个工具可能会更快。

但是，使用正则表达式有很多好处。它们通常可以在工具之间很好地转换，并且可以回答比子字符串更复杂的查询(没有明显的重复)。人们可能还会考虑这种性能差异转化为多少真实时间。正如我们所看到的，这将取决于查询复杂性和输入大小。

在许多情况下，性能差异可能并不显著(几分之一秒到不到一分钟)。

此外，请注意，上述测试并不全面，但可能代表了各种常见的查询。例如，很高兴看到性能如何随输入大小而扩展——这可以留给读者作为练习。如果初始设置需要很长时间，我们也可以选择在`b.N`循环之前调用`b.ResetTimer()`，但是这里没有必要这样做。和往常一样，测试包中的[基准测试部分还有更多的内容需要深入研究！](https://pkg.go.dev/testing#hdr-Benchmarks)

如果您想查看基准测试的其他用例，请在评论中告诉我！在下一篇文章(四篇系列文章的最后一篇)中，我们将针对 grep 等工具对该工具进行一些命令行基准测试(感谢您的想法，Aaron！).