<html>
<head>
<title>A Tale of Two Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两种语言的故事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-tale-of-two-languages-a-story-about-class-b6b7551c795d?source=collection_archive---------11-----------------------#2019-07-26">https://betterprogramming.pub/a-tale-of-two-languages-a-story-about-class-b6b7551c795d?source=collection_archive---------11-----------------------#2019-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="683a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个关于阶级的故事</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4c5c5eb4b4be99ba935bc3fac2a9287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLhrh07szPME2k-R8DXw-Q.png"/></div></div></figure><p id="5bf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">刚刚学习了JavaScript中的类，我认为深入了解JavaScript中的类以及我最近使用的另一种语言Ruby中的类的内部工作方式可能是个好主意。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="8424" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">编程中的类:基础</h1><p id="2ff9" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">从简单实用的角度来看，每种语言中的类都只是制造对象的蓝图。就像宜家家具手册描述家具并教顾客如何制作一样，课程告诉语言如何制作物品。</p><p id="fdaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">什么是对象？只是一堆属性和动作。现实世界中的一把特定的椅子可以被认为是类<code class="fe mr ms mt mu b">Chair</code>的一个对象，具有类似<code class="fe mr ms mt mu b">num_legs</code>的属性和类似<code class="fe mr ms mt mu b">#be_sat_on</code>的方法。从这个意义上说，面向对象语言试图反映人类所看到的世界:它由不同类型的对象组成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/cd4b204958288458ae8efc1ef8586cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v8kdIbfqE8jCbjzkvSVEA.jpeg"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">椅子类型的物体</p></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="cde4" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">鲁比:真正的交易</h1><p id="1242" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">严格来说，JavaScript不是面向对象的:类只是具有一些特殊键和值的对象。但是类不就是制造对象的蓝图吗？哇，那听起来令人困惑。所以让我们从Ruby开始，这是一种理想的面向对象语言，其中类就像它们看起来的那样:制造对象的蓝图。简单吧？</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="0f1a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">Ruby中的类是一级对象</h1><p id="a6fa" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Ruby docs的“类介绍”以这个有用的、令人欣慰的句子开始:</p><blockquote class="na nb nc"><p id="6164" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">Ruby中的类是一级对象——每个都是类<code class="fe mr ms mt mu b">Class</code>的一个实例。</p></blockquote><p id="76dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这听起来非常类似于JavaScript范式，类只是具有一些特殊属性的对象。幸运的是，对于我们对Ruby类的理解来说，Ruby最初是作为一种面向对象的语言而设计的，在类和普通的Ruby对象之间有更强的区分。具体来说，Ruby有一个名为<code class="fe mr ms mt mu b">Class</code>的内置类，它将类与其他对象截然分开。</p><p id="5b3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，虽然Ruby类是一级对象看起来很神秘，但这仅仅意味着类可以被分配给行为很像指向普通旧(非类)对象的变量的变量。类可以在创建后修改，传递给函数，并从函数返回。然而，Ruby的类是内置在语言中的，类和其他对象之间的界限非常清楚。具体来说，类是普通旧对象的类型和蓝图。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="088a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">遗产</h1><p id="2e49" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Ruby和其他OO语言中的继承试图模仿人类看待世界的方式。现实世界中的类型是分等级的:人类是哺乳动物的类型，哺乳动物是动物的类型，动物是一种生命形式。除了反映现实生活，面向对象语言中的继承范例允许程序员避免重复工作。通过让<code class="fe mr ms mt mu b">Human</code>和<code class="fe mr ms mt mu b">Cat</code>都从<code class="fe mr ms mt mu b">Mammal</code>继承，程序员可以避免编写两个<code class="fe mr ms mt mu b">#give_live_birth</code>方法，这确实是所有哺乳动物共有的方法，而不是<code class="fe mr ms mt mu b">Cat</code>或<code class="fe mr ms mt mu b">Human</code>的责任。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="9410" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">Ruby中的继承</h1><p id="7131" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Ruby中的类不同于其他对象，这极大地简化了继承的实现。从父类继承的类可以访问父类的属性和方法，创建一个总是以<code class="fe mr ms mt mu b">BasicObject</code>结束的继承链。当我们调用一个方法或请求一个对象的属性时，Ruby解释器首先检查该对象的直接类，看是否有任何属性或方法匹配。如果没有，它检查父类，依此类推，直到曾祖父祖先<code class="fe mr ms mt mu b">BasicObject</code>。最后，如果没有匹配的，解释器抛出一个<code class="fe mr ms mt mu b">Undefined Method</code>错误。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="ef9a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">JavaScript“类”</h1><p id="caf8" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">JavaScript中的情况更复杂。除了字符串和数字之类的原语，JavaScript中唯一的实体是对象:指向值的键的集合。我们如何从这种简单的数据结构中获得模仿Ruby类友好行为的东西(蓝图和继承)？通过展示一系列针对这个问题的低效解决方案，我希望能说明为什么JavaScript的原型解决方案能在糟糕的情况下发挥最大作用。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="5457" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">幼稚的对象工厂</h1><p id="2e05" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">由于JavaScript函数可以返回对象，我们可以实现一个简单的函数类，它返回一个具有特定属性(指向原语或其他对象的键)和方法(指向函数的键)的对象。这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6870" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们可以调用这个函数来创建一个具有<code class="fe mr ms mt mu b">name</code>、<code class="fe mr ms mt mu b">weight</code>和<code class="fe mr ms mt mu b">specialty</code>属性以及<code class="fe mr ms mt mu b">rechargeBatteries()</code>方法的机器人对象。</p><h2 id="84f9" class="nj lv iq bd lw nk nl dn ma nm nn dp me la no np mg le nq nr mi li ns nt mk nu bi translated">问题是</h2><p id="6dd7" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们创造的每个机器人都有一个<code class="fe mr ms mt mu b">rechargeBatteries()</code>指向的独特功能。当我们用许多复杂的方法创建许多对象时，这就变成了内存使用的灾难。呀！</p><h2 id="299a" class="nj lv iq bd lw nk nl dn ma nm nn dp me la no np mg le nq nr mi li ns nt mk nu bi translated">好一点了</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d632" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过让机器人工厂指向自身之外的一个函数，每个机器人的<code class="fe mr ms mt mu b">rechargeBatteries()</code>方法将指向一个单独的函数，从而节省内存。但是如果我们有一堆函数呢？我们需要一些方法来组织它们。这就是原型出现的地方。原型是特殊的对象，包含了工厂函数需要赋予它所创建的对象的所有方法。因为这些方法只在内存中存储一次，所以这种实现也比第一个例子高效得多。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="f066" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">一个例子</h1><pre class="kg kh ki kj gt nv mu nw nx aw ny bi"><span id="e5f0" class="nj lv iq mu b gy nz oa l ob oc">Array.prototype === [1,2,3].__proto__ <br/>&gt;&gt; true</span></pre><p id="9526" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这告诉我们什么？<code class="fe mr ms mt mu b">Array</code>对象是数组对象的蓝图。<code class="fe mr ms mt mu b">Array</code>有一个指向<code class="fe mr ms mt mu b">prototype</code>对象的键，它将这个键传递给它创建的所有数组对象。因此，当我们调用像<code class="fe mr ms mt mu b">[1,2,3].forEach()</code>这样的方法时，我们实际上是在幕后调用<code class="fe mr ms mt mu b">[1,2,3].__proto__.forEach()</code>。当我们在<code class="fe mr ms mt mu b">[1,2,3]</code>上调用<code class="fe mr ms mt mu b">.forEach()</code>时，一些JavaScript魔法会在<code class="fe mr ms mt mu b">[1,2,3].__proto__</code>中搜索<code class="fe mr ms mt mu b">.forEach()</code>。</p><p id="afe0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重申一下，<code class="fe mr ms mt mu b">Array</code>，我们可以认为它是一个类，有一个键指向一个原型，它具有数组对象的所有功能。然后，当我们创建数组时，它们通过键<code class="fe mr ms mt mu b">__proto__</code>访问这个原型对象，允许我们调用数组上的方法。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="7527" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">JavaScript中的原型继承</h1><p id="107b" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">那么基于原型的类范式到底是如何允许继承的呢？考虑下面的代码片段:</p><pre class="kg kh ki kj gt nv mu nw nx aw ny bi"><span id="1af8" class="nj lv iq mu b gy nz oa l ob oc">[1,2,3].__proto__.__proto__ === Object.prototype<br/>&gt;&gt; true</span></pre><p id="0e52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我来说，这一行是JavaScript继承的核心。在Ruby中，当我们在一个对象上调用一个方法时，它首先在该对象的类中寻找相应的方法。如果解释器没有找到同名的方法，它会在父类中查找，创建一个查找链。</p><p id="55cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中，有一个从每个对象延伸的原型链，该语言依次查看每个原型，寻找对象上调用的方法。由于<code class="fe mr ms mt mu b">Object</code>是<code class="fe mr ms mt mu b">Array</code>的父类，从一个数组向上两次跳转原型链将使我们到达<code class="fe mr ms mt mu b">Object</code>原型。</p><p id="e721" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再举一个例子，假设我有一个指向类<code class="fe mr ms mt mu b">Human</code>的对象的<code class="fe mr ms mt mu b">human</code>变量和一个指向类<code class="fe mr ms mt mu b">Mammal</code>的对象的<code class="fe mr ms mt mu b">mammal</code>变量。最后，假设<code class="fe mr ms mt mu b">Human</code>是<code class="fe mr ms mt mu b">Mammal</code>的子类。则以下所有内容都将返回true:</p><pre class="kg kh ki kj gt nv mu nw nx aw ny bi"><span id="aac5" class="nj lv iq mu b gy nz oa l ob oc">human.__proto__ === Human.prototype<br/>human.__proto__.__proto__ === Mammal.prototype<br/>human.__proto__.__proto__ === mammal.__proto__</span></pre><p id="2cf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我说明JavaScript中继承如何工作的最佳尝试。类的原型是包含其方法的对象。该原型的原型是一个包含该类祖先的方法的对象。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="16b3" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">在JavaScript中实现继承</h1><p id="a450" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我该如何在<code class="fe mr ms mt mu b">Mammal</code>和<code class="fe mr ms mt mu b">Human</code>之间建立父子关系呢？如果我们已经定义了类，并且需要建立链接，我们可以使用一个叫做<code class="fe mr ms mt mu b">Object.create()</code>的东西，它是完成这项工作的完美工具。MDN对<code class="fe mr ms mt mu b">Object.create()</code>做了如下描述:</p><blockquote class="na nb nc"><p id="5ae0" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated"><code class="fe mr ms mt mu b"><strong class="kt ir">Object.create()</strong></code>方法创建一个新对象，使用一个现有对象作为新创建对象的原型。</p></blockquote><p id="e372" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇，好大一口。但是看看这能有什么帮助？根据MDN的定义，<code class="fe mr ms mt mu b">Object.create(ParentClass.prototype)</code>将返回一个新的对象，带有一个指向<code class="fe mr ms mt mu b">ParentClass.prototype</code>的<code class="fe mr ms mt mu b">prototype</code>键。</p><p id="5f87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过将子类的原型指定为这个新对象来建立父子关系。例如，在<code class="fe mr ms mt mu b">Mammal</code>和<code class="fe mr ms mt mu b">Human</code>的情况下，我们可以写成:</p><pre class="kg kh ki kj gt nv mu nw nx aw ny bi"><span id="72a3" class="nj lv iq mu b gy nz oa l ob oc">Human.prototype = Object.create(Mammal.prototype)<br/>Human.prototype.constructor = Human</span></pre><p id="a871" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不用太担心二线。它只是为了确保当我们创建一个新的<code class="fe mr ms mt mu b">Human</code>实例时，JavaScript不会默认创建一个<code class="fe mr ms mt mu b">Mammal</code>对象。最后，如果我们将<code class="fe mr ms mt mu b">human</code>指定为<code class="fe mr ms mt mu b">Human</code>的实例，我们将看到以下结果:</p><pre class="kg kh ki kj gt nv mu nw nx aw ny bi"><span id="2259" class="nj lv iq mu b gy nz oa l ob oc">human.__proto__.__proto__ === Mammal.prototype<br/>&gt;&gt;&gt; true</span></pre><p id="b596" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这表明我们已经成功地在<code class="fe mr ms mt mu b">Mammal</code>和<code class="fe mr ms mt mu b">Human</code>之间建立了父子链接！如果我们在<code class="fe mr ms mt mu b">human</code>上调用一个方法，而它的原型中没有相应的方法，那么JavaScript将在<code class="fe mr ms mt mu b">human.__proto__.__proto__</code>中寻找这个方法，我们使用<code class="fe mr ms mt mu b">Object.create()</code>将它指定为<code class="fe mr ms mt mu b">Mammal</code>原型。因此，<code class="fe mr ms mt mu b">human</code>确实继承了<code class="fe mr ms mt mu b">Mammal</code>的方法。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="033b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">引文</h1><p id="1af0" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">Ruby Docs的主要支柱:<a class="ae od" href="https://ruby-doc.org/" rel="noopener ugc nofollow" target="_blank">https://ruby-doc.org/</a>和MDN:<a class="ae od" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/</a>，它们分别是Ruby和Web开发的惊人资源。</p></div></div>    
</body>
</html>