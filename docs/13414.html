<html>
<head>
<title>Recursion vs. Loops in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的递归与循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-vs-loops-in-javascript-d588c5b0df31?source=collection_archive---------14-----------------------#2022-08-24">https://betterprogramming.pub/recursion-vs-loops-in-javascript-d588c5b0df31?source=collection_archive---------14-----------------------#2022-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d006" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">递归不一定是可怕的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f44b2ef1921159f08181845ba6d6c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UsnUMDsvzFQj2DdQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@comparefibre?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">对比<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的纤维</a>和</a></p></figure><p id="14d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归是每个开发人员的克星，只有它的朋友正则表达式才能与之匹敌。</p><p id="ef8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归可能很难理解，原因有两个。首先，你必须掌握函数调用自身的概念。其次，您必须理解基本情况和递归情况之间的区别，否则您可能会发现自己陷入了一个无限循环，直到导致堆栈溢出。</p><p id="c402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你能掌握这两个概念，递归就没有你想象的那么可怕或复杂。递归代码通常写起来更短，而且(在某些情况下)更容易阅读。</p><p id="29ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一起浏览五个代码示例。我们将首先使用循环来解决每个问题，然后使用递归来解决它。哪种方法更好？这由你来决定。</p><h1 id="517a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例子#1:阶乘</h1><p id="7b26" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们写一个函数来计算正整数的阶乘。阶乘是这样写的:<code class="fe ms mt mu mv b">5!</code>。阶乘的公式是这样的:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="dbbb" class="na lw it mv b gy nb nc l nd ne">n! = n * (n - 1) * (n - 2) * ... * 1</span></pre><p id="33a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以<code class="fe ms mt mu mv b">5!</code>应该是:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9512" class="na lw it mv b gy nb nc l nd ne">5! = 5 * 4 * 3 * 2 * 1 = 120</span></pre><p id="5a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何为此编写一个函数呢？一种方法是使用<code class="fe ms mt mu mv b">while loop</code>。我们可以为我们的<code class="fe ms mt mu mv b">result</code>创建一个变量，然后在一个循环中将它与<code class="fe ms mt mu mv b">x</code>相乘，每次将<code class="fe ms mt mu mv b">x</code>减1。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们也处理过小于0的错误输入，并且我们已经简化了0和1的情况，因为<code class="fe ms mt mu mv b">0!</code>和<code class="fe ms mt mu mv b">1!</code>都等于1。</p><p id="e02f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个利用循环的解决方案。如果我们想递归地写这个函数呢？递归解决方案可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="32e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇哦。那就短多了。注意，在最后一行，我们返回的是用<code class="fe ms mt mu mv b">x — 1</code>作为参数再次调用同一个<code class="fe ms mt mu mv b">factorial</code>函数的结果乘以<code class="fe ms mt mu mv b">x</code>。这是递归的情况。</p><p id="4de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只是递归调用我们的函数，我们会陷入一个无限循环，所以我们需要一些方法来摆脱它。这就是为什么我们有处理when <code class="fe ms mt mu mv b">x &lt;= 1</code>的条件。当我们到达那个点时，我们停止递归调用我们的<code class="fe ms mt mu mv b">factorial</code>函数。这是基本情况。</p><p id="d7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备好再举一个例子了吗？</p><h1 id="aab3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">示例2:电源</h1><p id="56dd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们试一个类似的例子。这一次让我们实现幂函数，它计算基数的幂的结果。所以，比如说，<code class="fe ms mt mu mv b">2^3</code>是2的3次方，或者说<code class="fe ms mt mu mv b">2 * 2 * 2</code>，是8。</p><p id="668d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，有几种方法可以实现幂函数，比如调用<code class="fe ms mt mu mv b">Math.pow(2, 3)</code>或者使用像<code class="fe ms mt mu mv b">2 ** 3</code>这样的求幂语法。现在，让我们假装这些工具不存在。我们如何自己编写这个功能呢？</p><p id="c92c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个<code class="fe ms mt mu mv b">while loop</code>，我们可以写一个类似这样的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们将忽略这个例子中的负指数，尽管在现实生活中负指数是完全有效的。我们还将处理指数为0的情况，因为任何升到0的数总是1 ( <code class="fe ms mt mu mv b">2^0 = 1</code>)。</p><p id="e41c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像我们对阶乘例子所做的一样，我们从1的初始<code class="fe ms mt mu mv b">result</code>开始。然后，我们在循环中用<code class="fe ms mt mu mv b">result</code>乘以<code class="fe ms mt mu mv b">x</code>，同时递减<code class="fe ms mt mu mv b">y</code>，直到达到0。</p><p id="a199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，递归解决方案会是什么样的呢？这个怎么样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="80d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，又短了很多！在最底部，我们有一个递归的例子，我们将<code class="fe ms mt mu mv b">x</code>乘以用<code class="fe ms mt mu mv b">x</code>和递减的<code class="fe ms mt mu mv b">y — 1</code>调用<code class="fe ms mt mu mv b">power</code>函数的结果。</p><p id="1bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之上，我们有我们的基本情况，如果<code class="fe ms mt mu mv b">y</code>等于0，我们返回1。这样，我们可以摆脱无限调用我们的<code class="fe ms mt mu mv b">power</code>函数。</p><p id="4b30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个有趣的说明是，在我们的两个递归解决方案中，我们不必跟踪一个<code class="fe ms mt mu mv b">result</code>变量。调用栈为我们做了这些！</p><p id="04e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准备好继续生活了吗？</p><h1 id="1878" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例3:对数组中的数字求和</h1><p id="9d06" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们写一个对数组中所有数字求和的函数。在JavaScript中，<code class="fe ms mt mu mv b">reduce</code>方法提供了一个简单的工具来将一个数组简化为一个总和，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8f0d" class="na lw it mv b gy nb nc l nd ne">numbers.reduce((number, sum) =&gt; number + sum, 0);</span></pre><p id="f793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">暂且就当<code class="fe ms mt mu mv b">reduce</code>不存在吧。我们如何编写自己的函数呢？一种选择是使用<code class="fe ms mt mu mv b">for loop</code>遍历数组中的所有项，并将它们加在一起。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简短明了。如果我们想递归地做这件事呢？我们可以写一个这样的递归解:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b63e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次我们将第一个数字加到调用数组其余部分的<code class="fe ms mt mu mv b">sumNumbersArray</code>函数的结果上，不包括第一个数字。</p><p id="bdbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是比使用<code class="fe ms mt mu mv b">for loop</code>更好的方法吗？这是一个主观的问题，但在我看来，在这里使用递归感觉比仅仅使用循环更不自然。你怎么想呢?</p><p id="fb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，让我们考虑另一个例子。</p><h1 id="b0a0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例4:找出数组中的最大数字</h1><p id="b430" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们编写一个函数，它接受一个数字数组并返回最大的一个。在JavaScript中，我们可以像这样使用<code class="fe ms mt mu mv b">Math.max</code>实用函数:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4f0b" class="na lw it mv b gy nb nc l nd ne">Math.max(...numbers);</span></pre><p id="f91b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为了便于讨论，让我们假设我们没有这个功能。我们怎么能自己写呢？使用一个<code class="fe ms mt mu mv b">for loop</code>，我们的代码可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先假设数组中的第一个数字是最大的数字。然后我们在数组中循环，从第二个元素开始，比较当前元素和最大值。如果当前元素大于最大数量，我们用那个值更新最大数量。一旦我们完成了列表的循环，我们就找到了最大的数字。</p><p id="b63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，相当简单。现在，如果我们想递归地写这个呢？我们可以这样写我们的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个是不是感觉有点难以直观把握？让我们走一遍。</p><p id="05bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数组包含零个元素或一个元素，我们将只返回第一个元素(在空数组的情况下为<code class="fe ms mt mu mv b">undefined</code>)。这是我们的基本情况。</p><p id="cbf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将对包含两个或更多元素的数组进行比较。我们将获取数组中的第一个元素，然后将其与递归调用数组剩余部分的<code class="fe ms mt mu mv b">maxNumberArray</code>的结果进行比较。然后我们将返回较大的数字。</p><p id="c28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还不清楚？我也没有。</p><p id="7251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个调用的例子，让我们每次都走一遍这些步骤。假设我们用这个参数调用函数:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="52cf" class="na lw it mv b gy nb nc l nd ne">maxNumberArray([1, 9, 5, 7, 3, 8, 2, 4])</span></pre><p id="ac8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当函数递归调用自身时，未解析的函数被推到调用堆栈上。一旦我们到达只有一个元素的数组的基本情况，函数就开始解析。这就是我们的对比结果:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="99e7" class="na lw it mv b gy nb nc l nd ne">Is 2 greater than 4? 4 is our max number.<br/>Is 8 greater than 4? 8 is our max number.<br/>Is 3 greater than 8? 8 is our max number.<br/>Is 7 greater than 8? 8 is our max number.<br/>Is 5 greater than 8? 8 is our max number.<br/>Is 9 greater than 8? 9 is our max number.<br/>Is 1 greater than 9? 9 is our max number.</span></pre><p id="ad4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，从概念上讲，我们从最后两个数字开始向后遍历数组。我们比较这两个数字，并保留最大的一个。然后我们向左移动一个元素，并将其与当前的最大值进行比较。</p><p id="ce6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们继续向左移动，直到到达数组的开头，在这里我们比较了所有的数字，找到了最大的一个。</p><p id="4528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个递归的例子更好吗？同样，这是一个主观问题，但我觉得答案是否定的。掌握这个递归函数如何工作的认知复杂性高于理解用循环实现的函数所需的努力。</p><p id="715a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归函数感觉像是一个“聪明”的解决方案，但不是一个“清晰”的解决方案。</p><p id="9002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们结束之前，让我们再做一个例子。</p><h1 id="7b51" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例5:在盒子里的盒子里找到一把钥匙</h1><p id="b734" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这将是我们最复杂的例子，但它是递归的完美用例。假设你有一个盒子。此框可以包含多个其他框、其他框等等。盒子也可能是空的。最后，我们要找的盒子里有一把钥匙。</p><p id="9975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以想象一下:</p><ul class=""><li id="320d" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">第一个框(框A)包含其他三个框(框B、框C和框D)。</li><li id="4063" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">盒子B里面什么也没有。</li><li id="1b54" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">盒子C里面有两个盒子(盒子E和盒子F)。</li><li id="d95d" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">盒子E里面有一个盒子(盒子G)。</li><li id="3ad1" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">G框包含密钥(万岁！).</li><li id="3f7a" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">盒子F里面什么也没有。</li><li id="ae16" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">盒子D里面有一个盒子(盒子H)。</li><li id="1535" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">盒子H里面什么也没有。</li></ul><p id="b130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的头还疼吗？</p><p id="343a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何编写一个函数来搜索盒子，直到找到密钥？</p><p id="d589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像这样使用<code class="fe ms mt mu mv b">while loop</code>来编写这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="95f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个空的堆(一个可以用作堆栈数据结构的数组)开始，然后将第一个盒子添加到这个堆中。</p><p id="8027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，趁那堆东西不是空的，我们从那堆东西中抓起一个盒子，往里面看。</p><p id="e00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在盒子里找到的每样东西都可能是钥匙(耶，我们找到了！)或者另一个盒子(棒极了……)。如果我们找到了钥匙，那我们就完事了。如果我们找到一个盒子，我们就把它加入到我们的堆里。</p><p id="8d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们重复这个循环，直到我们用完所有的盒子或者找到钥匙。</p><p id="1291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们想找到这个问题的递归解决方案呢？我们可以这样写我们的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我们的递归解决方案和循环解决方案之间的差异。在递归求解中，我们不跟踪栈。我们简单地浏览第一个盒子，然后，如果我们找到更多的盒子，我们递归地调用这个盒子上的<code class="fe ms mt mu mv b">findKeyInBox</code>函数。调用堆栈再次为我们跟踪我们的状态！</p><h1 id="cae0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="6972" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">那么，循环和递归哪个更好呢？这由你来决定。循环和递归之间通常没有显著的性能差异，大O符号是相同的，因为在每种情况下执行相同数量的操作。</p><p id="ad2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你真正要优化的是可读性。你更容易理解递归解还是循环解？那么下一个会阅读这段代码的开发人员呢？</p><p id="55eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码被读的次数比写的次数多10倍，所以要优化可读性。</p><p id="88cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果你想重温这些例子并查看测试用例，你可以在这个<a class="ae ky" href="https://github.com/thawkin3/recursion-vs-loops-js" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到我们讨论过的所有功能。</p></div></div>    
</body>
</html>