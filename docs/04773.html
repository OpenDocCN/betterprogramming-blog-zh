<html>
<head>
<title>A Guide to Property Wrappers in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的属性包装器指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/property-wrappers-in-swiftui-63bae630bb5a?source=collection_archive---------12-----------------------#2020-05-07">https://betterprogramming.pub/property-wrappers-in-swiftui-63bae630bb5a?source=collection_archive---------12-----------------------#2020-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0d4b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">@State、@Published、@EnvironmentObject等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a27d6720da72ed403728342917746ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pF35bGJMa6gukB01"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@punttim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tim Gouw </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="706a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI有许多用于不同目的的属性包装器，以使开发人员的生活更加轻松。我想分享一些关于这些包装的注意事项。让我们开始吧。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8874" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">@状态</strong></h1><ul class=""><li id="aa89" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">我们可以通过将该结构用作值类型来修改该结构的值。</li><li id="ad9a" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">这意味着存储简单的类型，如<code class="fe nh ni nj nk b">String</code>、<code class="fe nh ni nj nk b">Int</code>、<code class="fe nh ni nj nk b">Bool</code>等。</li><li id="3145" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们需要在视图中使用它，建议将其设为私有。</li><li id="066b" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们应该提供一个默认值。</li><li id="42e8" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">它可以用作装订。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="501a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> @ObservedObject </strong></h1><ul class=""><li id="c8b7" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">当我们想要在视图之间传递一个复杂的对象时，我们可以使用这个，当对象改变时，所有的视图都会得到通知。</li><li id="1bb9" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">类型应符合<code class="fe nh ni nj nk b">ObservableObject</code>协议。</li><li id="711e" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们需要将对象中的属性标记为<code class="fe nh ni nj nk b">@Published</code>,以指示正在使用该对象的视图的变化。</li><li id="676f" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">对象类型应该是类。</li><li id="b9d4" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们应该提供一个默认值。</li><li id="6966" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">假设我们有一个符合<code class="fe nh ni nj nk b">ObservableObject</code> <strong class="ky ir"> </strong>和<strong class="ky ir"> </strong>的<code class="fe nh ni nj nk b">MenuData</code>类，将它的属性菜单之一标记为<code class="fe nh ni nj nk b">@Published</code>。<strong class="ky ir"> </strong>每当这个菜单改变时，它会通知所有正在使用的视图。在我们的例子中，它是<code class="fe nh ni nj nk b">ContentView</code>:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ul class=""><li id="9514" class="mr ms iq ky b kz la lc ld lf nn lj no ln np lr my mz na nb bi translated">如果没有视图正在使用该对象，则发布的数据将被忽略。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5b4a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">@环境对象</strong></h1><ul class=""><li id="472f" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">类似于<code class="fe nh ni nj nk b">@ObservedObject</code>。</li><li id="3e33" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">类型应符合<code class="fe nh ni nj nk b">ObservableObject</code>协议。</li><li id="dc6c" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们需要将对象中的属性标记为<code class="fe nh ni nj nk b">@Published</code>,以指示对正在使用该对象的视图的更改。</li><li id="2e9c" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">对象类型应该是类。</li><li id="c9f8" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">不需要默认值，因为它可以从环境中读取默认值。如果该对象在环境中不可用，应用程序将会崩溃。</li><li id="80e3" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">还有另一个主要区别:假设我们有五个视图(V1…V5)。如果我们想将一个对象直接从V1传递到V5，我们可以使用<code class="fe nh ni nj nk b">@EnvironmentObject</code>而不是<code class="fe nh ni nj nk b">@ObservedObject</code>。设置要在环境中从V1传递的数据，并在V5中检索它(或任何需要的地方)。代码会简单得多。</li><li id="9e75" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">在环境中，一次只能有一个类型的实例。</li><li id="c992" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">纯粹是基于观点。如果父视图设置了环境对象，那么它的所有子视图都可以使用它。如果另一个父视图设置了另一个环境对象，其子视图可以使用它:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1c5f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@环境</h1><ul class=""><li id="6707" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">我们可以用它来获得系统相关的值，比如应用程序是在亮模式还是暗模式下运行，core data的托管对象上下文，大小类等。</li><li id="94bb" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们需要提供正确的键来访问该值，因为它可以针对多个键保存相同的数据类型:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="20f2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">@绑定</strong></h1><ul class=""><li id="c7f0" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">这用于维护视图之间的共享数据。</li><li id="8a4e" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">最好的例子是在视图1中显示一个工作表，在视图2中启动一个解除操作。</li><li id="315e" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们需要使用@Binding声明一个属性。</li><li id="fede" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">不需要默认值，因为它会从另一个视图中设置它。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0b85" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">@手势状态</strong></h1><ul class=""><li id="cbae" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">这个类似于<code class="fe nh ni nj nk b">@State</code>。</li><li id="7be2" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">唯一的区别是手势一结束，默认值就会被设置。而在<code class="fe nh ni nj nk b">@State</code>中，最后的设定值被保存。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1fd7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">@已发布</h1><ul class=""><li id="8e6a" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">这用于通知视图，每当对象中的属性更新时，就重新呈现其body属性。</li><li id="6a96" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们需要在<code class="fe nh ni nj nk b">ObservableObject</code>协议中使用这个。</li><li id="c582" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">如果一个类符合<code class="fe nh ni nj nk b">ObservableObject</code>，我们可以将该类中的一个或所有属性标记为<code class="fe nh ni nj nk b">@Published</code>。</li><li id="2281" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">每当class' <code class="fe nh ni nj nk b">@Published</code>属性中的数据发生变化时，SwiftUI将向所有正在使用该对象的视图发出通知:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9353" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak"> @FetchRequest </strong></h1><ul class=""><li id="c388" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">我们可以用它从核心数据中提取数据，并直接在视图中使用它。没必要写什么多余的逻辑。</li><li id="04ef" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们需要传递实体名称和排序描述符来从核心数据中获取数据。</li><li id="4663" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">我们也可以提供一个选项谓词。</li><li id="fc93" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">这隐含地具有<code class="fe nh ni nj nk b">@ObservedObject</code>的行为，因此每当对象改变时，视图将自动更新:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d1b4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="0857" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">SwiftUI中有几个重要的属性包装器。所有这些都是为了使开发过程变得容易，减少错误。</p><p id="dded" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>