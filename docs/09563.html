<html>
<head>
<title>Building Dynamic Lists in SwiftUI for iOS 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中为iOS 15构建动态列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-dynamic-lists-in-swiftui-for-ios-15-a2e470fb37cb?source=collection_archive---------6-----------------------#2021-09-09">https://betterprogramming.pub/building-dynamic-lists-in-swiftui-for-ios-15-a2e470fb37cb?source=collection_archive---------6-----------------------#2021-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8649" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">增强您的SwiftUI列表视图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97578efb3398a0dcdcb5eaff3baef6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K6O4-VGRzrvwxx3n"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@amadejtauses?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Amadej Tauses </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/customizing-views-inside-swiftui-lists-7b2cacdd9fd0">在之前的</a>中，我们看了如何使用<code class="fe lv lw lx ly b">List</code>视图来创建<em class="lz">静态</em>列表视图。静态列表视图对于在iOS应用中创建菜单或设置屏幕很有用，但是当我们将它们连接到数据源时，<code class="fe lv lw lx ly b">List</code>视图变得更加有用。</p><p id="77ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们来看几个例子，看看如何使用<code class="fe lv lw lx ly b">List</code>视图来显示数据的动态列表，比如图书列表。我们还将了解如何使用苹果在iOS 15最新版本的SwiftUI中添加的一些新功能，如pull-to-refresh，一种搜索UI，以及一种使用async/await从异步API获取数据的简单方法，如远程服务。</p><h1 id="5526" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">显示元素列表</h1><p id="aef8" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">创建列表的方法有很多种，正如我们将在本系列后面看到的，你既可以创建平面列表，也可以创建层次<em class="lz">、</em>嵌套列表。由于所有的列表行都是按需计算的，<code class="fe lv lw lx ly b">List</code>视图甚至对于包含许多条目的集合也表现良好。</p><p id="a72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于元素集合创建一个<code class="fe lv lw lx ly b">List</code>视图的最简单方法是使用它的构造函数，该构造函数接受一个<code class="fe lv lw lx ly b">RandomAccessCollection</code>和一个用于行内容的视图构建器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ebe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在视图构建器中，我们以一种类型安全的方式访问集合中的单个元素。这意味着我们可以访问集合元素的属性，并使用SwiftUI视图如<code class="fe lv lw lx ly b">Text</code>来呈现单个行，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="aaef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这个视图充当我们想要显示的数据的所有者，所以我们使用一个<code class="fe lv lw lx ly b">@StateObject</code>来保存视图模型。视图模型公开了保存图书列表的published属性。为了简单起见，这是一个静态列表，但是在现实世界的应用程序中，您可以从远程API或本地数据库获取这些数据。</p><p id="61e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们如何通过编写<code class="fe lv lw lx ly b">book.title</code>或<code class="fe lv lw lx ly b">book.author</code>来访问<code class="fe lv lw lx ly b">List</code>中<code class="fe lv lw lx ly b">Book</code>元素的属性。这里，我们使用一个<code class="fe lv lw lx ly b">Text</code>视图，通过字符串插值来显示一本书的标题和作者。</p><p id="23b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于SwiftUI的声明性语法，我们可以轻松地构建更复杂的自定义UI来呈现数据——就像我们上次看到的那样。</p><p id="845f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用下面的代码，用一个更精细的行来替换上面代码片段中的<code class="fe lv lw lx ly b">Text</code>视图，该行显示图书封面、标题、作者和页数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Xcode的SwiftUI重构工具，我们可以将这些代码提取到一个自定义视图中，使我们的代码更容易阅读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="102d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看我关于构建SwiftUI视图的视频，了解这种(以及其他)重构的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz my l"/></div></figure><p id="bb7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们不打算修改列表行中的数据(或者细节视图中的数据)，所以我们将列表项作为一个简单的引用传递给该行。如果我们想要修改列表行中的数据(例如，将一本书标记为收藏，或者将它传递到用户可以编辑书的详细信息的子屏幕)，我们必须使用列表绑定。</p><h1 id="7692" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">使用列表绑定允许修改列表项</h1><p id="3123" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">通常，视图中的数据是不可修改的。要修改数据，需要将其作为一个<code class="fe lv lw lx ly b">@State</code>属性或一个<code class="fe lv lw lx ly b">@ObservedObject</code>视图模型来管理。为了允许用户修改子视图中的数据(例如，<code class="fe lv lw lx ly b">TextField</code>或详细信息屏幕)，我们需要使用绑定将子视图中的数据连接到父视图中的状态。</p><p id="b435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI for iOS 15之前，没有直接的方法来绑定列表的元素，所以人们必须想出自己的解决方案。我以前在这篇<a class="ae ky" href="https://peterfriese.dev/swiftui-list-item-bindings-behind-the-scenes/" rel="noopener ugc nofollow" target="_blank">文章</a>中写过这个问题，在文章中我对比了不正确和正确的做法。</p><p id="e387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 15的SwiftUI中，Apple引入了一种直接的方式来访问作为绑定的列表项，使用以下语法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了允许我们的示例应用程序的用户在列表视图中编辑书籍的标题，我们所要做的就是更新书籍列表视图，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="47e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这也适用于自定义视图。下面是如何更新<code class="fe lv lw lx ly b">BookRowView</code>使书名可编辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="23f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的重点是在子视图中使用<code class="fe lv lw lx ly b">@Binding</code>。通过这样做，父视图保留了传递给子视图的数据的所有权，同时允许子视图修改数据。真理的来源<em class="lz">是父视图中<code class="fe lv lw lx ly b">ObservableObject</code>上的<code class="fe lv lw lx ly b">@Published</code>属性。</em></p><p id="bc1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要阅读更多关于列表绑定的内容，以及这个特性是如何工作的，请查看我的文章<a class="ae ky" href="https://peterfriese.dev/swiftui-list-item-bindings-behind-the-scenes/" rel="noopener ugc nofollow" target="_blank"> SwiftUI列表绑定</a>。</p><h1 id="f4d5" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">异步获取数据</h1><p id="8b27" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">本文接下来的部分有一个共同点——它们都基于苹果公司处理异步代码的新API。</p><p id="f3e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WWDC 21上，苹果推出了Swift新的并发模型，作为Swift 5.5的一部分。Swift的下一个版本目前处于测试阶段，但你已经可以通过从<a class="ae ky" href="https://developer.apple.com/download/" rel="noopener ugc nofollow" target="_blank">这里</a>下载Xcode 13的测试版来体验新功能了。</p><p id="e5f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，我们使用了静态数据列表。这种方法的优点是我们不必获取(并等待)这些数据，因为它们已经在内存中了。这对于例子来说很好，因为它允许我们关注相关的东西，但是它不能反映现实。</p><p id="00a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界的应用程序中，我们通常显示来自远程API的数据，这通常意味着执行异步调用:当我们等待来自远程API的结果时，应用程序需要继续更新UI。如果它不这样做，用户可能会得到应用程序挂起甚至崩溃的印象。</p><p id="3c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在接下来的例子中，我将展示如何利用Swift的新并发模型来处理异步代码。</p><p id="9b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取数据的一个好时机是当用户导航到一个新的屏幕并且这个屏幕刚刚出现的时候。在SwiftUI的以前版本中，使用<code class="fe lv lw lx ly b">.onAppear</code> view修饰符是请求数据的好地方。从iOS 15开始，SwiftUI包括了一个新的视图修改器，让这个变得更加简单:<code class="fe lv lw lx ly b">.task</code>。当视图出现时，它将启动一个异步的<code class="fe lv lw lx ly b">Task</code>，一旦视图消失，它将取消这个任务(如果任务还在运行的话)。如果您的任务是一个长时间运行的下载，并且您想在用户离开屏幕时自动中止它，这将非常有用。</p><p id="7b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">.task</code>就像将它应用到你的<code class="fe lv lw lx ly b">List</code>视图一样简单。下面是如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="962f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在视图模型中，您可以使用异步API来获取数据。在本例中，我模仿了后端以使代码更容易阅读，并添加了人工延迟，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尝试像这样运行代码，您将会得到一个运行时警告，说<em class="lz">“不允许从后台线程发布更改；确保在模型更新时从主线程发布值(通过receive(on:)之类的操作符，"</em></p><p id="6ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个运行时错误的原因是<code class="fe lv lw lx ly b">refreshable</code>里面的代码没有在主线程上执行。然而，UI更新<em class="lz">必须</em>在主线程上执行。在过去，我们必须使用<code class="fe lv lw lx ly b">DispatchQueue.main.async { ... }</code>来确保任何UI更新都在主线程上执行。</p><p id="2951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用Swift的新并发模型，有一种更简单的方法:我们所要做的就是使用<code class="fe lv lw lx ly b">@MainActor</code>属性包装器对任何执行UI更新的方法(或类)进行操作。这指示编译器在执行这段代码时切换到主参与者，从而确保任何UI更新都在主线程上运行。下面是更新后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cb94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多有关Swift新并发模式的信息，请查看YouTube上的视频系列<a class="ae ky" href="https://www.youtube.com/playlist?list=PLsnLd2esiGRQ1qkp__tAfXI0qb-TgwtJj" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="f0cc" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">拉至刷新</h1><p id="a5b9" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">除非你使用像<a class="ae ky" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank"> Cloud Firestore </a>这样的SDK，让你可以实时听到后端的更新，否则你会想给你的应用添加一些UI启示，让你的用户可以轻松地请求最新的数据。让用户刷新数据的最常见方式之一是<em class="lz">拉动刷新</em>，Loren Brichter于2008年在Tweetie应用中<a class="ae ky" href="https://www.imore.com/hall-fame-loren-brichter-and-tweetie" rel="noopener ugc nofollow" target="_blank">流行起来(后来被Twitter收购，并作为iOS版Twitter重新推出)。</a></p><p id="53c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于SwiftUI的声明性，只需几行代码就可以轻松地将该功能添加到您的应用程序中。而且，如上所述，该功能还利用了Swift的新并发模型，以确保您的应用的UI即使在需要等待任何更新时也能保持响应。</p><p id="de7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe lv lw lx ly b">refreshable</code>视图修改器添加到您的<code class="fe lv lw lx ly b">List</code>视图就是将<em class="lz">拉至刷新</em>添加到您的应用程序的全部工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="abf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如关键字<code class="fe lv lw lx ly b">await</code>所示，<code class="fe lv lw lx ly b">refreshable</code>打开一个异步执行上下文。这要求你从<code class="fe lv lw lx ly b">refreshable</code>内部调用的代码异步执行(如果你调用的代码可以非异步执行，因为它会立即返回，这也很好。但通常情况下，您会希望与需要异步调用的远程API进行通信。</p><p id="c860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让您了解这可能是什么样子，我创建了一个视图模型，通过添加一些人工等待时间来模拟异步远程API，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="30de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下这段代码，了解一下发生了什么。</p><ol class=""><li id="05c2" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">与前面的示例一样，<code class="fe lv lw lx ly b">books</code>是视图订阅的已发布属性。</li><li id="1721" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe lv lw lx ly b">generateNewBook</code>是一个本地函数，使用优秀的<a class="ae ky" href="https://github.com/lukaskubanek/LoremSwiftum" rel="noopener ugc nofollow" target="_blank"> LoremSwiftum </a>库产生一个随机的新<code class="fe lv lw lx ly b">Book</code>实例。</li><li id="da52" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在<code class="fe lv lw lx ly b">refresh</code>内部，我们调用<code class="fe lv lw lx ly b">generateBook</code>生成一本新书，然后将其插入到已发布的属性<code class="fe lv lw lx ly b">books</code>中，但是在我们这样做之前，我们使用<code class="fe lv lw lx ly b">Task.sleep</code>调用告诉应用程序休眠两秒钟。这是一个异步调用，所以我们需要用<code class="fe lv lw lx ly b">await</code>来调用它。</li></ol><p id="ef71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和前面的例子一样，这段代码将产生一个紫色的运行时警告:</p><blockquote class="no np nq"><p id="38b4" class="kz la lz lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">不允许从后台线程发布更改；确保在模型更新时从主线程发布值(通过像receive(on:)这样的操作符)</p></blockquote><p id="16cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们需要使用<code class="fe lv lw lx ly b">@MainActor</code>来确保所有的更新都发生在主参与者身上。这一次，我们不是只标记<code class="fe lv lw lx ly b">refresh</code>方法，而是将整个视图模型标记为<code class="fe lv lw lx ly b">@MainActor</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="edd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们结束这一部分之前的最后一个调整:您会注意到，当通过拖动刷新向列表添加新项目时，新添加的项目会立即出现，没有平滑的过渡。</p><p id="8968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于SwiftUI的声明式语法，添加动画使其感觉更加自然非常容易。我们需要做的就是给<code class="fe lv lw lx ly b">List</code>视图添加一个<code class="fe lv lw lx ly b">animation</code>视图修改器，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="499c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过提供<code class="fe lv lw lx ly b">value</code>参数，我们可以确保这个动画只在列表视图的内容改变时运行。例如，它可能在插入或删除新项目时运行。</p><p id="afd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完善动画，我们还将在视图模型的<code class="fe lv lw lx ly b">refresh</code>函数的末尾添加一个短暂的暂停。这确保了在进度微调器消失之前，新行以平滑过渡的方式出现。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="e1dd" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">搜索</h1><p id="9575" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">SwiftUI使得在<code class="fe lv lw lx ly b">List</code>视图中实现搜索变得容易。您所需要做的就是将<code class="fe lv lw lx ly b">.searchable</code>视图修饰符应用到列表视图，SwiftUI将自动为您处理所有的UI方面。它将显示一个搜索字段(并确保当您第一次显示列表视图时它不在屏幕上，就像您对本机应用程序的期望一样)。它还具有触发搜索和清除搜索字段的所有UI启示)。</p><p id="6d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下唯一要做的事情就是实际执行搜索并提供适当的结果集。</p><p id="817d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般而言，搜索屏幕既可以本地操作(即，过滤列表视图中显示的项目)，也可以远程操作(即，针对远程API执行查询，并且仅显示该调用的结果)。</p><p id="0394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本节中，我们将研究如何过滤列表视图中显示的元素。为此，我们将使用async/await和Combine的组合。</p><p id="fac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将构建一个简单的<code class="fe lv lw lx ly b">List</code>视图，显示视图模型中的图书列表。这对您来说应该很熟悉，因为我们重用了前面例子中使用的大部分代码。下面是新代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cc84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该视图模型与我们之前使用的模型非常相似，但有一个重要的区别—图书集合最初是空的，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="73dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给<code class="fe lv lw lx ly b">SearchableBooksListView</code>添加一个搜索UI，我们应用了<code class="fe lv lw lx ly b">.searchable</code>视图修改器，并将其<code class="fe lv lw lx ly b">text</code>参数绑定到视图模型上的一个新的<code class="fe lv lw lx ly b">searchTerm</code>属性。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在<code class="fe lv lw lx ly b">List</code>视图中安装搜索UI，但是如果运行这段代码，什么也不会发生。事实上，您甚至不会在列表视图中看到任何书籍。</p><p id="ee49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了改变这一点，我们将向视图模型添加一个新的私有属性，该属性保存原始的未过滤的图书列表。最后，我们将设置一个组合管道，根据用户输入的搜索条件过滤这个列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种组合管道是如何工作的？</p><ol class=""><li id="75bb" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">我们使用<code class="fe lv lw lx ly b">Publishers.CombineLatest</code>来获取两个发布者<code class="fe lv lw lx ly b">$originalBooks</code>和<code class="fe lv lw lx ly b">$searchTerm</code>的最新状态。在现实世界的应用程序中，我们可能会在后台接收到图书收藏的更新，我们希望这些更新也包含在搜索结果中。每当这些发布者之一发送新事件时，<code class="fe lv lw lx ly b">CombineLatest</code>发布者将发布包含<code class="fe lv lw lx ly b">originalBooks</code>和<code class="fe lv lw lx ly b">searchTerm</code>的最新值的新元组。</li><li id="adcb" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">然后我们使用<code class="fe lv lw lx ly b">.map</code>操作符将<code class="fe lv lw lx ly b">(books, searchTerm)</code>元组转换成一个图书数组，我们最终将该数组分配给published <code class="fe lv lw lx ly b">$books</code>属性，该属性连接到<code class="fe lv lw lx ly b">SearchableBooksListView</code>。</li><li id="e833" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在<code class="fe lv lw lx ly b">.map</code>闭包内，我们使用<code class="fe lv lw lx ly b">filter</code>只返回标题或作者姓名中包含搜索词的书籍。流程的这一部分实际上不是特定于组合的- <code class="fe lv lw lx ly b">filter</code>是<code class="fe lv lw lx ly b">Array</code>上的一个方法。</li></ol><p id="f327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你运行这段代码，你会发现你在搜索栏中输入的所有内容都会自动大写。为了防止这种情况，我们可以在视图修改器<code class="fe lv lw lx ly b">searchable</code>之后应用<code class="fe lv lw lx ly b">. autocapitalization</code>视图修改器- <em class="lz">，如下所示:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="6c82" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">关闭</h1><p id="c835" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">SwiftUI中的列表视图非常强大，随着WWDC 21上宣布的功能，苹果正在弥合UIKit和SwiftUI的<code class="fe lv lw lx ly b">List</code> API之间存在的许多差距。</p><p id="d87e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些特性有点隐藏，但谢天谢地官方文档正在赶上。阅读SwiftUI头文件中的源文档总是有好处的。如果我们能获得SwiftUI的源代码，那就更好了，但我不会为这个屏住呼吸。</p><p id="9f8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，我希望这一系列文章有助于阐明苹果平台上最常用的用户界面范例之一。欢迎随时在<a class="ae ky" href="https://twitter.com/peterfriese" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系，如果你有任何问题或评论，请不要犹豫，发送推文或DM。</p><p id="4119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一集，我们将研究样式<code class="fe lv lw lx ly b">List</code>视图。苹果在最新版本中增加了一些令人兴奋的造型功能，使得在你的应用品牌中采用<code class="fe lv lw lx ly b">List</code>变得更加容易。</p><p id="92de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。下次见！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="601b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">最初发布于</em><a class="ae ky" href="https://peterfriese.dev/swiftui-listview-part2/" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://peterfriese . dev</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>