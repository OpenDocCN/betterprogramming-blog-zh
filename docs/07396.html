<html>
<head>
<title>Using CSS Subgrid for Pixel Perfection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CSS子网格实现像素完美</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-css-subgrid-for-pixel-perfection-6d4343b057cd?source=collection_archive---------10-----------------------#2021-01-11">https://betterprogramming.pub/using-css-subgrid-for-pixel-perfection-6d4343b057cd?source=collection_archive---------10-----------------------#2021-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8197" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">展示CSS的子网格特性的简单美丽</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aabdb83f0c2d91d5b22bcb19517dd8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qcPD3r_07oBntW78"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·卡斯滕斯-彼得斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。</p></figure><p id="5bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速回顾一下什么是网格:它是一个基于容器的二维布局系统。它可以在两个轴中的任何一个轴上增长，几乎所有的信息都存储在父容器中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/52c15fc3156f5d2590f19373ed71e755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*6YeEVVXSRcJwnZBHo2EgpQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="d903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么子网格有什么好大惊小怪的呢？它的目的是什么？网格不就解决了所有的问题吗？他们大多是，但我们渴望完美，没有这个新功能很难实现。一旦您开始使用网格功能，您就会意识到缺少了一些东西…</p><p id="1771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，在本文中，我们将忽略媒体查询和响应布局。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="67cc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">深入研究这个问题</h1><p id="e581" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一切都很好，直到我们开始嵌套网格。在这种情况下，我们开始遇到一些网格之间对齐和调整的问题。这是因为一个网格只能影响它的直接子网格，而不能影响它们的子网格。</p><p id="f20e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当必须对齐一些嵌套网格时，我们需要大量的计算来进行补偿。这意味着试图达到像素完美将付出代价:脆弱的布局。你可能仍然需要做出许多让步。</p><p id="36e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对subgrid的支持离生产就绪还差得很远。目前我们只能以增量的方式使用它(也就是说，我们只能用它来增强支持它的浏览器的体验)。</p><p id="95dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一些嵌套网格并一起探索它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/c69bd5ef6f042ebe13c203d49fbd4aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-aqRFfsSvuKwh24jaHlWQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一切都完美地对齐。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/25a194a1ce721a909bb35c35bd32628c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YFCI6sXRQqOrRE-lFKX1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轨道和网格线。这些复制品排列得很好。</p></figure><p id="7a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么问题？我们有一个主网格和两个嵌套网格，看起来一切正常。事实上，嵌套网格继承了带有<code class="fe ne nf ng nh b">grid-template-columns: inherit</code>的<code class="fe ne nf ng nh b">grid-column-template</code>定义。这不正是我们想要的吗？</p><p id="5d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论总是非常美好，但当你开始添加内容时，它就开始分崩离析了。</p><p id="c940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们希望第一行的最后一列的大小基于内容。为此，我们将使用<code class="fe ne nf ng nh b">max-content</code>:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="9c70" class="nm me it nh b gy nn no l np nq">//using max-content on the last column</span><span id="4642" class="nm me it nh b gy nr no l np nq">#container {<br/>  ...<br/>  grid-template-columns: 1fr 1fr 1fr 1fr max-content;<br/>  ...<br/>}</span></pre><p id="9bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/fe33339d62708ee8e9dba741b6467683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bt0hCBysAYm-SaBnhL35NQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对嵌套网格使用最大内容时布局被破坏</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b43bf69ca6aaf0e21915c2856365c7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MO3Mhlx5lKjkzb1im4xhzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">断开的最大内容嵌套网格的网格</p></figure><p id="22a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，一切都乱了套。内容不断破坏我们的布局，但这是内容的错吗？不，问题是我们的布局方式非常脆弱。有很多方法可以解决这个问题:</p><ul class=""><li id="2391" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">对于每个分辨率具有固定的列宽。</li><li id="728e" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">我们不使用<code class="fe ne nf ng nh b">max-content</code>，而是测量内容并使其保持静态。</li><li id="1b3d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">告诉我们的设计师这是太多的工作，并要求退而采用<code class="fe ne nf ng nh b">1fr</code>方法。</li></ul><p id="bf24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些解决方案都只是解决问题的方法，没有一个能带来完美的像素。我们真正的问题是什么？父网格无助于将任何元素定位在第一个子级别之下。</p><p id="a4c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前的解决方案是上面列出的解决方案的混合。这导致大量的CSS代码充满了计算和可能出错的地方。更改/添加内容可能是一项令人生畏的任务，其中许多东西可能会损坏。另一个问题是代码审查。只是不可能在你的头脑中有这些计算，并正确地审查代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="eefa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">CSS子网格拯救世界</h1><p id="36e0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个问题怎么解决？只要让所有嵌套的网格使用相同的轨迹。这就是子网格的具体用途:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们完成了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f0d0d30a528400ef10a24f6edb67e778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjN1i-jZsVui0eARVGxmkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用子网格固定布局</p></figure><p id="a832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那里发生了什么事？是怎么固定的？</p><p id="c4b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子栅格强制子元素位于父元素的轨迹上。此外，父网格和嵌套网格正在相互通信，并一起制定布局。</p><p id="9846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看网格上的最后一列。它比其他的都小。如果您还记得，我们将该列设置为<code class="fe ne nf ng nh b">max-content</code>。父网格和嵌套网格一起决定<code class="fe ne nf ng nh b">max-content</code>的宽度，因为它们将共享相同的轨迹。它的网格与嵌套的子网格进行递归通信，以确保它们获得完美的单元大小。</p><p id="41f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是基本要点:网格及其子网格<em class="oh">一起工作</em>来设计共享网格布局。知道这种布局是跨他们共享的，我们需要在设计它的时候多加注意。我们必须在父级定义网格和子网格的用途。这需要提前做一些额外的思考，但这确实是值得的。</p><p id="5c41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子网格也是二维布局。它可以从父网格继承列和/或行。我们刚刚看到了列维子网格布局。现在让我们来看看行维度1:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/1357807d9b2b173245053fe07920ba85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZShhB1bJVM0-CDzMu8LhXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有相同内容的嵌套网格</p></figure><p id="06bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，看起来一切都很好，不需要任何其他东西。如上面的代码所示，行模板的定义如下:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="4f86" class="nm me it nh b gy nn no l np nq">grid-template-rows: max-content 2fr 50px;</span></pre><p id="dc26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如果我们的标题内容比这个长一点会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7ff6d71d7fb22a031f42d2d43f2f761f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XA1OFSSZbdAF3YCNNPB7qw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用嵌套网格的最大内容时布局被破坏</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/8d2245eab386d3fcffc44e9887fa87dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7be6gMhxtBJ07qnkWiFCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将最大内容与嵌套网格一起使用时，布局的网格被破坏</p></figure><p id="f5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用同样的原则再次修正它，在两个嵌套网格上使用子网格:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/738fb3bd32f8c6a8a46af5772f960777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzfY3k-ep0ZsYSKF_9CNrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在行维度上应用子网格以修复布局</p></figure><p id="3983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇的事情又发生了。这一切看起来像素完美。网格容器和嵌套容器正在一起定义<code class="fe ne nf ng nh b">max-content</code>,这是小菜一碟，因为它们都使用相同的网格线和网格轨迹定位。</p><p id="d943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oh">注:我们已经看到了一个共享</em> <code class="fe ne nf ng nh b"><em class="oh">grid-template-rows</em></code> <em class="oh">的例子和一个共享</em> <code class="fe ne nf ng nh b"><em class="oh">grid-template-columns</em></code> <em class="oh">的例子。如果需要，</em> <code class="fe ne nf ng nh b"><em class="oh">subgrid</em></code> <em class="oh">可以在两个维度上扩展。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0ecb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/071350c67a298520db2daab610e8a681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CJ9-wP_eyt_7Tr_v"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ravipalwe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ravi Palwe </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="f7f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下subgrid的所有优点:</p><ul class=""><li id="d265" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">它继承了命名的网格线。</li><li id="0009" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">它继承了命名的网格区域。</li><li id="2a8d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">它继承了间隙并可以覆盖它们。</li><li id="92aa" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">它可以定义命名的网格线，并将在父对象中可见。</li><li id="18a3" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">它有助于母细胞的大小。</li><li id="03cc" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">可以是一维，也可以是二维。</li><li id="e658" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">行号总是从1开始。</li></ul><p id="d04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了每一个CSS特性，我们修改布局的日子就一去不复返了。这一切都始于Flex，它是主要的游戏规则改变者，并延续到Grid。Subgrid是最终的伴侣，与它一起你将实现完美定位的布局结构，它将100%匹配设计者的布局结构。你再也不用担心内容会破坏你的布局了。它将永远在正确的轨道上。</p><p id="dbf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对Flex在今天仍然出色的用例感兴趣，你可以看看我以前关于Flex与网格的文章:</p><div class="ol om gp gr on oo"><a href="https://dioxmio.medium.com/grid-vs-flexbox-which-one-should-you-be-using-471cb955d3b5" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">Grid和Flexbox——你应该使用哪一个？</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">为合适的工作寻找合适的工具</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">dioxmio.medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><p id="8c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将来会有更多的子网格内容出现。干杯！</p></div></div>    
</body>
</html>