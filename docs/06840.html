<html>
<head>
<title>5 Advanced C Programming Concepts for Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向开发人员的5个高级C编程概念</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-advanced-c-programming-concepts-for-developers-22a9dd35e361?source=collection_archive---------8-----------------------#2020-11-10">https://betterprogramming.pub/5-advanced-c-programming-concepts-for-developers-22a9dd35e361?source=collection_archive---------8-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f20" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">随着C语言的复兴，让我们来看看一些重要的概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e2c517a91e4906668e66536e1e683806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoWz45eP3SARJ7B9zNQUTQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="2ba7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于采用C语言作为自动驾驶汽车开发的首选语言，C语言的人气和需求正在复苏。许多业内资深人士通过C语言学习编程，但已经很多年没用过了。</p><p id="b085" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将通过对开发人员来说最重要的五个高级C语言概念来帮助您更新C语言知识或使您的学习更上一层楼。</p><p id="9d9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">下面是我们今天要讲的内容:</strong></p><ul class=""><li id="a585" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">1.动态存储分配</li><li id="e93b" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">2.用gdb调试</li><li id="839c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">3.函数指针</li><li id="ef06" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">4.C中的递归</li><li id="e19c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">5.C #中的类型转换和typedef</li><li id="0c6e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">接下来学什么</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="3ac8" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">1.动态存储分配</h1><h2 id="0ae9" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">定义</h2><p id="4415" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">在C #中，内存分配有两种类型:静态和动态。静态分配是两者中最基本的，在执行时分配给堆栈。</p><p id="fb19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦分配，静态分配有一个固定的大小。静态分配用于任何全局变量、文件范围变量和带有<code class="fe nv nw nx ny b">static</code>关键字的变量。</p><p id="8f5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">动态内存分配</strong>是两者中更高级的，在分配后可以改变大小。这个内存存储在堆中。与堆栈不同，堆内存没有大小限制。</p><p id="c60b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">动态分配会根据需要分配更多的内存，这意味着分配的内存永远不会超过您的需要。</p><p id="b07d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">动态内存分配也会降低性能。缓存的堆数据不像缓存的堆栈数据那样相邻。因此，检索堆数据的效率通常不如检索堆栈数据。</p><p id="d325" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">动态内存分配也需要很大的开销。缓存到堆中的变量必须有一个大小相等的关联指针，以便以后定位该变量。</p><p id="7997" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，一个4字节的变量也有一个关联的4字节指针。这意味着堆数据的资源成本大约是栈数据的两倍。</p><p id="1d2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然动态内存可以扩展以容纳更多数据，但当数据量减少时，它不会自动释放内存。相反，您必须使用<code class="fe nv nw nx ny b">free()</code>函数手动释放内存。</p><p id="bc2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您忘记释放内存，您将很快发现自己遇到了内存泄漏错误，这可能会降低您的程序速度，甚至导致程序崩溃！</p><h2 id="bcd7" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">使用</h2><p id="fc2d" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">动态内存的开销成本最好用于选择变量，如缩放数据结构。最好仍然对大多数变量使用静态分配，以避免降低程序速度。</p><p id="8aed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在以下情况下，您应该使用动态内存:</p><ul class=""><li id="a043" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">你事先不知道一个结构需要多少内存</li><li id="1c64" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">您想要一个可以无限扩展以匹配输入的数据结构</li><li id="63da" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">您希望确保永远不会提前过度分配内存(自动向上扩展)</li><li id="5c1e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">您正在使用一个链表或结构对象</li></ul><h2 id="736c" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">履行</h2><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="2c4d" class="ne mn iq ny b gy od oe l of og">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt; <br/>int main( )<br/>{<br/>    // Declare pointer variables<br/>    int  *i ;<br/>    float  *a ; <br/>    /* Allocate memory using malloc and store the starting <br/>    address of allocated memory in pointer variable*/<br/>    i = (int*) malloc (sizeof(int));<br/>    a = (float*) malloc (sizeof(float));<br/>    // Declare employee structure<br/>    struct emp<br/>    {<br/>        char name [20];<br/>        int age;<br/>        float sal;<br/>    };<br/>    // Declare structure pointer<br/>    struct emp *e;<br/>    e = (struct emp *) malloc (sizeof (struct emp));<br/>}</span></pre><p id="c824" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">中，第6、7和20行</strong>、<code class="fe nv nw nx ny b">i</code>、<code class="fe nv nw nx ny b">a</code>和<code class="fe nv nw nx ny b">e</code>被创建在堆栈上。三个都是指针。它们所指向的内存块是在堆上创建的。</p><p id="3769" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">第10–11行</strong>中，我们使用<code class="fe nv nw nx ny b">malloc( )</code>库函数来实现动态内存分配。在动态内存分配中，两个决定——分配多少内存和分配到哪里——都是在执行过程中做出的。</p><p id="a650" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">应该分配的字节数作为参数传递给<code class="fe nv nw nx ny b">malloc( )</code>。<code class="fe nv nw nx ny b">malloc( )</code>分配那么多内存，并返回作为空指针分配的内存块的基址。</p><p id="9583" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用(目标类型)语法，将由<code class="fe nv nw nx ny b">malloc( )</code>返回的空指针适当地类型转换(转换)成整数指针、浮点指针或结构emp指针。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="6f60" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">2.用Gdb调试</h1><h2 id="39a9" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">定义</h2><p id="1aab" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">Linux是C编程最常用的操作系统。Linux有一个名为<strong class="kx ir"> gdb </strong>的调试命令行工具，可以帮助你调试你的程序。一旦安装完毕，你可以使用gdb运行你的整个程序，它会指出逻辑和语法错误。</p><p id="cf40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这允许您:</p><ul class=""><li id="5396" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">执行程序，一次一条语句</li><li id="fd8e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在程序的任何给定行/函数处停止执行</li><li id="df64" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">打印中间值</li><li id="976a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">了解执行的详细流程</li></ul><h2 id="72ee" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">使用</h2><p id="006f" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">gdb中最重要的命令是断点、<code class="fe nv nw nx ny b">step</code>、<code class="fe nv nw nx ny b">next</code>和变量值打印。</p><p id="8ca5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">断点</strong>在指定的时间暂停程序的执行，允许你评估程序状态和变量值。该工具用于将较大的代码段分解成较小的代码块。然后，您可以运行这些块来确定bug的大致位置。</p><p id="bafc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤</strong>让你一次运行一行代码。该命令执行下一行代码，然后暂停以等待进一步的指令。一旦您将bug缩小到一个较小的代码块，而不是一个特定的行，您就可以使用它。当您遍历这个程序块时，您最终会发现是哪一行导致了这个错误。</p><p id="5d94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">下一个</strong>与<code class="fe nv nw nx ny b">step</code>相似，但是执行下一个功能而不是下一行。这最好与断点一起使用，以调试功能繁重的程序或分支程序。您可以运行每个模块化函数，并确保每个函数都按预期执行。</p><p id="fb7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">变量值打印</strong>用于在断点、<code class="fe nv nw nx ny b">step</code>或<code class="fe nv nw nx ny b">next</code>命令后打印变量的当前值。如果没有gdb，每次程序与变量交互后，您都必须手动将打印命令写入程序。相反，gdb允许你的程序摆脱杂乱的打印命令，同时仍然允许你通过程序段跟踪变量值。</p><h2 id="d7c6" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">履行</h2><p id="0264" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated"><strong class="kx ir">安装:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="2e44" class="ne mn iq ny b gy od oe l of og">apt-get -y install gdb</span></pre><p id="984c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">使用gdb编译器编译程序:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="e8c9" class="ne mn iq ny b gy od oe l of og">gcc main.c -g</span></pre><p id="6a19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">进入gdb模式:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="1ddd" class="ne mn iq ny b gy od oe l of og">gdb a.out</span></pre><p id="5c8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">参见源代码:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="d4f3" class="ne mn iq ny b gy od oe l of og">list</span></pre><p id="e887" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">创建断点:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="4177" class="ne mn iq ny b gy od oe l of og">gdb) break 6<br/>gdb) run</span></pre><p id="cd85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">一步一行:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="873a" class="ne mn iq ny b gy od oe l of og">gdb) step</span></pre><p id="3191" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第一步功能:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="7fb1" class="ne mn iq ny b gy od oe l of og">gdb) next</span></pre><p id="1ac7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">检查变量的当前值:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="f0b3" class="ne mn iq ny b gy od oe l of og">print {variable name}</span></pre><blockquote class="oh oi oj"><p id="6ade" class="kv kw ok kx b ky kz jr la lb lc ju ld ol lf lg lh om lj lk ll on ln lo lp lq ij bi translated"><em class="iq">按下</em> <code class="fe nv nw nx ny b"><em class="iq">enter</em></code> <em class="iq">同时在广发租房上一个命令。使用它可以快速遍历代码块，而无需每次都重新键入</em> <code class="fe nv nw nx ny b"><em class="iq">step</em></code> <em class="iq">或</em> <code class="fe nv nw nx ny b"><em class="iq">next</em></code> <em class="iq">命令。</em></p></blockquote></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="7066" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">3.函数指针</h1><h2 id="81c5" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">定义</h2><p id="a776" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">函数指针是调用已创建函数的另一种方式。标准的函数调用带有函数名和括号<code class="fe nv nw nx ny b">function1()</code>。函数指针允许你用函数的内存位置<code class="fe nv nw nx ny b">(*f)()</code>调用函数。</p><p id="018e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，您必须首先将所需函数的位置存储在一个指针变量中。一旦你这样做了，你就可以在任何需要使用标准函数调用的地方使用函数指针。</p><h2 id="0dac" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">使用</h2><p id="a874" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">函数指针允许你<strong class="kx ir">将函数作为参数</strong>传递给其他函数或数据结构。因此，您可以避免使用临时变量，而是简单地将函数的结果直接传递给下一个函数。</p><p id="95a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">函数指针还可以防止不同数据类型的重复代码。例如，通常要为不同的数据类型创建一个快速排序程序，你需要编写特定类型的排序函数，比如<code class="fe nv nw nx ny b">quicksort_integer</code>或<code class="fe nv nw nx ny b">quicksort_char</code>。</p><p id="7506" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用函数指针，您可以创建一个函数，它将指针作为参数，并根据您有比较器的任何字段进行排序。</p><p id="d7eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，函数指针允许你创建用函数而不是变量填充的结构。例如，您可以通过将每个函数指针存储为一个元素来创建一个函数数组。</p><p id="467d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您想要将一个函数插入到另一个函数中时，或者当您想要在使用数据结构时减轻类型限制时，请使用函数指针。</p><h2 id="ef8d" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">履行</h2><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="d611" class="ne mn iq ny b gy od oe l of og"># include &lt;stdio.h&gt;<br/>void dbl ( int * ) ;<br/>void tple ( int * ) ;<br/>void qdpl ( int * ) ;<br/>int main( )<br/>{<br/>    int  num = 2, i ;<br/>    void ( *p[ ] )( int * ) = { dbl, tple, qdpl } ;<br/>    for ( i = 0 ; i &lt; 3 ; i++ )<br/>    {<br/>        p[ i ]( &amp;num ) ;<br/>        printf ( "%d\n", num ) ;<br/>    }<br/>    return 0 ;<br/>}</span><span id="2bb6" class="ne mn iq ny b gy oo oe l of og">void dbl ( int *n )  <br/>{<br/>    *n = *n * *n ;<br/>}</span><span id="f5b7" class="ne mn iq ny b gy oo oe l of og">void tple ( int *n )  <br/>{<br/>    *n = *n * *n * *n ;<br/>}</span><span id="35bb" class="ne mn iq ny b gy oo oe l of og">void qdpl ( int *n )  <br/>{<br/>    *n = *n * *n * *n * *n ;<br/>}</span></pre><p id="0073" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个程序中，我们定义了三个函数。<code class="fe nv nw nx ny b">dble</code>、<code class="fe nv nw nx ny b">tple</code>和<code class="fe nv nw nx ny b">qdpl</code>函数接收一个int的地址，分别将int值加倍/三倍/四倍，并且不返回任何值。</p><p id="ae7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在main函数中，我们将这些函数的地址存储在一个数组中，然后通过遍历一个数组来逐个调用它们。</p><p id="2964" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">第8行</strong>中，我们创建了一个函数指针数组，并将<code class="fe nv nw nx ny b">dble</code>、<code class="fe nv nw nx ny b">tple</code>和<code class="fe nv nw nx ny b">qdpl</code>的地址存储在一个数组中。</p><p id="170d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">第11行</strong>中，我们通过遍历一个数组，根据地址调用<code class="fe nv nw nx ny b">dbl</code>、<code class="fe nv nw nx ny b">tple</code>和<code class="fe nv nw nx ny b">qdpl</code>函数。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="5402" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">4.C中的递归</h1><h2 id="2220" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">定义</h2><p id="2583" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">递归是指函数包含对自身的调用。递归程序通常包含在每次递归迭代中重复的递归调用之上的命令和操作。</p><p id="b1a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在C中，可以递归调用用户函数和<code class="fe nv nw nx ny b">main()</code>。在许多情况下，递归可以取代传统的循环。像循环一样，如果没有退出条件，递归程序可以无限循环。</p><p id="15fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">典型的递归调用要么来自<code class="fe nv nw nx ny b">if</code>段，要么来自<code class="fe nv nw nx ny b">else</code>段。</p><p id="b157" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于<code class="fe nv nw nx ny b">if</code>类型的递归程序，递归调用保存在<code class="fe nv nw nx ny b">if</code>段。程序将继续迭代，直到<code class="fe nv nw nx ny b">if</code>变为<code class="fe nv nw nx ny b">false</code>。然后，程序将前进到包含返回语句的<code class="fe nv nw nx ny b">else</code>段。</p><p id="c7ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如:</p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="15b0" class="ne mn iq ny b gy od oe l of og">int example()<br/>{<br/>  if (n != 0){ <br/>    // do something<br/>    // something more<br/>    example(..); //recursive call<br/>  }<br/>  else <br/>  {<br/>    return 1;<br/>  }<br/>}</span></pre><p id="4385" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nv nw nx ny b">else</code>类型程序中，递归调用与影响程序条件的操作一起保存在<code class="fe nv nw nx ny b">else</code>段中。任何<code class="fe nv nw nx ny b">else</code>类型的程序都会迭代，直到<code class="fe nv nw nx ny b">if</code>语句变成<code class="fe nv nw nx ny b">true</code>。</p><p id="2630" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些程序类型之间的区别在于，我们是从起始状态<em class="ok">远离</em>还是从<em class="ok">向</em>目标状态前进。</p><p id="80ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如:</p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="7dbe" class="ne mn iq ny b gy od oe l of og">int example ()<br/>{<br/>  if (n == 0){<br/>      return 1; <br/>  }<br/>  else <br/>  {<br/>    // do something<br/>    // something more<br/>    example(..); //recursive call<br/>  }<br/>}</span></pre><h2 id="e0cd" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">使用</h2><p id="c6f8" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">递归用于重新定位问题，以关注期望的条件，而不是实现它的迭代次数。</p><p id="0a20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于循环，您必须对程序将要进行的迭代次数进行编程。这意味着你必须知道一个给定的输入需要多少次迭代，或者创建一个子组件来决定迭代的次数。</p><p id="02e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，您最终关心的是实现某个目标，迭代是您实现目标的工具，而不是相反。</p><p id="cc2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归允许你设计基于目标思维的程序。递归程序重复多少次来实现它们的目标，无论是偏离一个起始状态还是到达一个目标状态。</p><p id="e8d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你不应该对所有事情都使用递归，因为它比迭代循环解决方案使用更多的资源。一般来说，递归最适合用于以下解决方案:</p><ul class=""><li id="3960" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">可以用许多更小的子问题的答案来解决</li><li id="a51e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">需要多次重复相同的步骤</li><li id="29bc" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">追求某些程序状态。</li></ul><h2 id="7bff" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">履行</h2><p id="15b1" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">这个C程序寻找一个整数参数的阶乘。这是一个<code class="fe nv nw nx ny b">else</code>类型的递归程序。</p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="21d8" class="ne mn iq ny b gy od oe l of og">#include &lt;stdio.h&gt;<br/>int refact ( int ) ;</span><span id="c06a" class="ne mn iq ny b gy oo oe l of og">int main( )<br/>{<br/>    int  num, fact ;<br/>    num = 4;</span><span id="cc6c" class="ne mn iq ny b gy oo oe l of og">    fact = refact ( num ) ;<br/>    printf ( "Factorial value = %d\n", fact ) ;</span><span id="365f" class="ne mn iq ny b gy oo oe l of og">    return 0 ;<br/>}</span><span id="f17a" class="ne mn iq ny b gy oo oe l of og">int  refact ( int  n )<br/>{<br/>    int  p ;</span><span id="70b3" class="ne mn iq ny b gy oo oe l of og">    if ( n == 0 )   <br/>        return ( 1 ) ; <br/>    else<br/>        p = n * refact ( n - 1 ) ; //recursive call</span><span id="f2b7" class="ne mn iq ny b gy oo oe l of og">    return ( p ) ;<br/>}</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="8bc1" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">5.C #中的类型转换和Typedef</h1><h2 id="61fb" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">定义</h2><p id="e257" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">类型转换是C #中一种特殊的操作，它将一种数据类型转换成另一种数据类型。类型转换可以隐式或显式完成。</p><p id="d17c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">隐式类型转换是编译器自动转换数据的地方。隐式类型转换更容易实现，但在转换过程中经常会丢失信息。</p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="f571" class="ne mn iq ny b gy od oe l of og">// implicit typecasting<br/># include &lt;stdio.h&gt;<br/>int main( )<br/>{<br/>    // Initialize variables of type int<br/>    int  a = 5, b = 2, c ;<br/>    // Declare variable of type int<br/>    float  d ;<br/>    // Assign value to c<br/>    c = a / b ;<br/>    printf ( "%d\n", c ) ;<br/>    // Store result of integer division in variable of float type<br/>    d = a / b ;<br/>    printf ( "%f\n", d ) ;<br/>}</span></pre><p id="3834" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，<code class="fe nv nw nx ny b">d</code>应该有<code class="fe nv nw nx ny b">2.500000</code>的值，但实际上是<code class="fe nv nw nx ny b">2.000000</code>。十进制值在自动转换过程中被截断，因为<code class="fe nv nw nx ny b">a</code>和<code class="fe nv nw nx ny b">b</code>都是整数，因此从它们的除法运算中返回一个整数值。</p><p id="c5a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">显式类型转换</strong>解决了这个问题。使用这种类型转换形式，您可以手动转换数据，因此可以选择更早的转换点。</p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="5027" class="ne mn iq ny b gy od oe l of og">// explicit typecasting<br/># include &lt;stdio.h&gt;<br/>int main( )<br/>{<br/>    // Initialize variables of type int<br/>    int  a = 5, b = 2, c ;<br/>    // Declare variable of type int<br/>    float  d ;<br/>    // Assign value to c<br/>    c = a / b ;<br/>    printf ( "%d\n", c ) ;<br/>    // Store result of float division in variable of float type<br/>    d = ( float ) a / b ;<br/>    printf ( "%f\n", d ) ;<br/>}</span></pre><p id="d013" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx ir">第12行</strong>、<code class="fe nv nw nx ny b">d = ( float ) a / b</code>上，在执行除法运算之前，a被强制定型为浮点型<em class="ok">。因此，操作会保留操作的所有十进制值。如您所见，<code class="fe nv nw nx ny b">d</code>的值就是显式转换时的<code class="fe nv nw nx ny b">2.500000</code>。</em></p><blockquote class="oh oi oj"><p id="972e" class="kv kw ok kx b ky kz jr la lb lc ju ld ol lf lg lh om lj lk ll on ln lo lp lq ij bi translated"><em class="iq">只从不太具体的数据类型转换到更具体的数据类型，以避免数据丢失。例如，如果您从</em> <code class="fe nv nw nx ny b"><em class="iq">int</em></code> <em class="iq"> → </em> <code class="fe nv nw nx ny b"><em class="iq">double</em></code> <em class="iq">转换，您将保留所有信息，但是如果您从</em> <code class="fe nv nw nx ny b"><em class="iq">double</em></code> <em class="iq"> → </em> <code class="fe nv nw nx ny b"><em class="iq">int</em></code> <em class="iq">转换，您将丢失信息。</em></p></blockquote><h2 id="6fff" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">使用</h2><p id="c145" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">您可以使用类型转换来创建<strong class="kx ir">可重用代码</strong>。如果将较小的数据转换为较大的数据，则可以将相同的值用作多个函数的参数，即使它们调用不同的数据类型。</p><p id="fe2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还可以从第一个函数序列中获取输出，并将其转换为新的类型，以满足它遇到的下一个函数的需求。在c #中使用严格数据类型时，类型转换允许您有更大的自由度。</p><p id="fdf1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还可以使用<code class="fe nv nw nx ny b">typedef</code>关键字进行类型转换，为现有的数据类型或用户定义的结构赋予新的名称。这并没有取消原始名称的赋值，只是增加了另一种引用相同类型的方式。</p><p id="6469" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如:</p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="4736" class="ne mn iq ny b gy od oe l of og">#include&lt;stdio.h&gt;</span><span id="284c" class="ne mn iq ny b gy oo oe l of og">int main() {<br/>    // Declare variables<br/>    unsigned long int i, j;<br/>    // Give new name to unsigned long int<br/>    typedef unsigned long int ULI;<br/>    // Declare variables of type ULI<br/>    ULI k, l;<br/>}</span></pre><p id="1121" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们将名称<code class="fe nv nw nx ny b">ULI</code>指定给<code class="fe nv nw nx ny b">unsigned long int</code>类型。然后，我们可以声明类型为<code class="fe nv nw nx ny b">ULI</code>或<code class="fe nv nw nx ny b">unsigned long int</code>的变量，并获得相同的效果。</p><p id="40f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这有助于提高可读性，因为您可以为数据类型指定名称，以缩短声明或更准确地表示它们将保存什么值(<code class="fe nv nw nx ny b">string</code> → <code class="fe nv nw nx ny b">color</code>)。</p><h2 id="9239" class="ne mn iq bd mo nf ng dn ms nh ni dp mw le nj nk my li nl nm na lm nn no nc np bi translated">履行</h2><p id="9664" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated"><strong class="kx ir">隐式类型转换:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="b64b" class="ne mn iq ny b gy od oe l of og">// implicit typecasting<br/># include &lt;stdio.h&gt;<br/>int main( )<br/>{<br/>    // Initialize variables of type int<br/>    int  a = 5, b = 2, c ;<br/>    // Declare variable of type int<br/>    float  d ;<br/>    // Assign value to c<br/>    c = a / b ;<br/>    printf ( "%d\n", c ) ;<br/>    // Store result of integer division in variable of float type<br/>    d = a / b ;<br/>    printf ( "%f\n", d ) ;<br/>}</span></pre><p id="c50e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">显式类型转换:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="648c" class="ne mn iq ny b gy od oe l of og"># include &lt;stdio.h&gt;<br/>int main( )<br/>{<br/>    // Initialize variables of type int<br/>    int  a = 5, b = 2, c ;<br/>    // Declare variable of type int<br/>    float  d ;<br/>    // Assign value to c<br/>    c = a / b ;<br/>    printf ( "%d\n", c ) ;<br/>    // Store result of float division in variable of float type<br/>    d = ( float ) a / b ;<br/>    printf ( "%f\n", d ) ;<br/>}</span></pre><p id="e1ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">用户结构的Typedef:</strong></p><pre class="kg kh ki kj gt nz ny oa ob aw oc bi"><span id="78c6" class="ne mn iq ny b gy od oe l of og">#include&lt;stdio.h&gt;</span><span id="71d7" class="ne mn iq ny b gy oo oe l of og">int main() {<br/>    // Declare structure<br/>    struct a<br/>    {<br/>        char *p;<br/>    };<br/>    // Give new name to struct a<br/>    typedef struct a FILE;<br/>    FILE *fs , *ft;<br/>}</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="6de9" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">接下来学什么</h1><p id="15de" class="pw-post-body-paragraph kv kw iq kx b ky nq jr la lb nr ju ld le ns lg lh li nt lk ll lm nu lo lp lq ij bi translated">祝贺您完成了高级C编程的第一步！我们讨论了提高C编程技能的五个最重要的概念。</p><p id="bedb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，这些仅仅是这种长期发展的语言所能提供的表面。一些值得研究的下一个主题是:</p><ul class=""><li id="75eb" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">创建库</li><li id="cdfd" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用Linux/Unix的c语言</li><li id="d3fe" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">位和按位运算符</li><li id="ee06" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">可变参数列表</li><li id="9a5f" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">结构</li></ul><p id="a5da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快乐学习！</p></div></div>    
</body>
</html>