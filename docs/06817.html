<html>
<head>
<title>Build a GraphQL Server With Spring Boot and MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring Boot和MySQL构建一个GraphQL服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-graphql-server-with-spring-boot-and-mysql-df427cbba26d?source=collection_archive---------1-----------------------#2020-11-07">https://betterprogramming.pub/build-a-graphql-server-with-spring-boot-and-mysql-df427cbba26d?source=collection_archive---------1-----------------------#2020-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始构建GraphQL服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e5f6f9f52605ec3e9d7a07b9f324f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zttc2YOayk-LuiTYy18c9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我用<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@johnpeel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约翰·皮尔</a>的资源修改的照片</p></figure><p id="2c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想过一个客户可以影响一个API请求？他能要求他真正需要的东西并得到吗？如果你对这些问题感到惊讶，我可以肯定你从未听说过GraphQL。</p><p id="403b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对上述问题的回答肯定是肯定的，因为graph QL 100%可能做到这一点。如果你没有听说过，不要担心。我将带您进入这个最新的、令人惊奇的GraphQL世界，如果您从这篇文章中获得了最大的收益，您将不会后悔。</p><p id="f7a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您熟悉Java编程语言、Spring Boot框架和REST APIs。继续之前不需要GraphQL经验。我知道你对这个话题很感兴趣。那么我们为什么要等呢？但是在开始编码之前，我将快速概述一下GraphQL以及它如此特别的原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e1ce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">GraphQL的第一步</h1><p id="57c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我知道你现在在努力寻找什么。这个GraphQL到底是什么？深呼吸，听我解释。简单地说，它是一种用于API的数据查询和操作语言。</p><p id="c680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL <strong class="lb iu"> </strong>公开了一个端点，<strong class="lb iu"> </strong>从前端接收查询作为请求的一部分，在一个响应中准确返回请求的数据部分。当然，我必须说:不要低估一个普通客户的力量。</p><p id="ee45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看这张GIF就能有个清晰的思路了。此外，这是我们今天要实现的应用程序的一部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/3677c9ec61713d4efb05c6235e3524de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aXd1Atpt9B8QI2s9r3r_Ew.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL如何工作</p></figure><p id="0446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL被各种规模的数百家组织用于生产，包括脸书(实际上GraphQL是脸书在2012年内部开发的，然后在2015年公开开源)、Credit Karma、GitHub、Intuit、PayPal、New York Times等等。</p><p id="b453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘿，等一下！那休息呢。难道这还不够有价值吗？看看这个。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b33" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="na"/>之战:GraphQL Vs REST</h1><p id="a018" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们大多熟悉web开发中的REST APIs，因为它在世界各地广泛使用。但最近，由于其灵活性和性能，有转向GraphQL的趋势。</p><p id="01fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么REST和GraphQL的核心区别是什么呢？REST是基于网络的软件的架构概念。另一方面，GraphQL是一种查询语言、一种规范和一组在单个端点上操作的工具。让我用一个例子来解释一下。</p><p id="0502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想从图书实体请求信息。同时，您想要请求关于作者的信息(这是一个不同的实体)。通常，这是通过向REST API发送两个请求(两个GET请求)来完成的。书籍和作者的端点可能是:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="554c" class="ng md it nc b gy nh ni l nj nk">localhost:8080/book/:id<br/>localhost:8080/author/:id</span></pre><p id="9e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是使用GraphQL，我们不仅可以从一个API端点获取这两个信息，还可以获取任何信息<br/>。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="315d" class="ng md it nc b gy nh ni l nj nk">localhost:8080/graphql</span></pre><p id="30c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在我之前的GIF中看到的，如果您想从特定的端点收集一些信息，我们可以限制GraphQL API返回的字段。但是在REST中，你将总是得到一个完整的数据集，并且不可能被限制。</p><p id="693f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时响应数据是不充分的(比如嵌套的结果)，你不得不发出另一个请求来得到你真正需要的。另一方面，传入的响应数据太多(没有必要),您只使用一两个数据字段。</p><p id="2fa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种现象被称为欠取和过取。GraphQL解决了这些问题并优化了您的应用程序。通过对比REST和GraphQL，就像一家没有服务员的餐厅。</p><p id="d14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于GraphQL，有一个学习曲线，它不像REST APIs那样确定，但是这个学习曲线是值得的。当创建用户友好的大型应用程序时，如果用户只收到他请求的数据而没有收到其他数据，他会更高兴。</p><p id="bc5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">额外的好处是，您的应用程序的性能将大大提高，因为您不必处理大量数据。(最好的例子是脸书应用程序)在规模上，你可以获得的任何性能改进都是巨大的胜利。</p><p id="3658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多不同的编程语言都支持GraphQL，如Java、JavaScript、Python、Scala等。你可以通过访问<a class="ae ky" href="https://graphql.org/code/" rel="noopener ugc nofollow" target="_blank"> GraphQL官方网站</a>找到更多关于服务器和客户端语言的信息。</p><p id="03d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我对Java和JavaScript越来越熟悉，我考虑使用Spring Boot应用程序，因为支持该技术的文章较少。Node.js上有合理的文章/教程，用它实现并不难。</p><p id="4450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你想要一篇关于用Node.js实现GraphQL服务器的文章，请在评论区留言，我也非常乐意就此写一篇单独的文章。</p><p id="6398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，说够了。让我们来点实际的东西。没有比亲身体验更好的了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基础:设置项目</h1><p id="ab36" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为一个简单的场景，我正在创建一个获取用户及其帖子的应用程序。我将此命名为<strong class="lb iu">评论</strong>，并希望在未来进一步发展它。</p><p id="0d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从头开始实现这一点。如果您熟悉spring boot，请跳过基础知识快速浏览一遍。所以首先，要么通过<a class="ae ky" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>要么用IntelliJ idea创建新的Spring Boot应用程序。</p><div class="kj kk kl km gt ab cb"><figure class="nl kn nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/8e1e2dc54a8635f8f631efd25bc7f50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*DEPldJV7a6gZfG_VGlr1HQ.png"/></div></figure><figure class="nl kn nr nn no np nq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a4e6e243377b0b974efc4b091e81ec35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*ZueIgy3oLM7lND_Eo-4leQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk ns di nt nu translated">作者提供的截图。</p></figure></div><p id="13bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请确保添加这些依赖项。</p><ol class=""><li id="8db3" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">Spring Data JPA:处理基于JDBC的数据库访问的大部分复杂性，ORM(对象关系映射)<br/>减少JPA所需的样板代码。</li><li id="171e" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">MySQL驱动:Java MySQL连接器，用于连接SQL数据库。</li><li id="d53e" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">Lombok:减少模型/数据对象的样板代码。它可以通过使用Lombok注释为这些对象自动生成getters和setters(以及更多)。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f0bb686e0bf3aab42b8c6343eb91e16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gj881gOHnanEEmyWoStkEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的截图。</p></figure><p id="e11e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧。稍微休息一下，让IntelliJ来解决依赖性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0ba0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="na">要点:</em>配置基础</h1><p id="b9f6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">至于初始设置，我们可以创建实体模型并向MySQL数据库添加一些虚拟数据。</p><p id="cf1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我在根文件夹中创建了一个新的包，并将其命名为model，在这个包中，我定义了两个模型user和post。使用Lombok，代码是干净的，不需要生成setters和getters，因为它们可以插入注释。但是请记住，您必须创建一个没有id字段的构造函数，因为在实例化时需要它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f5c4be2d4ae5ef8216b87bf52289b63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSxPRxwWgyq1ZF5AiwF2OQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户和发布实体</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="df23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个存储库层来连接数据库。因此，我创建了一个名为repository的新包，在其中，我为实体创建了两个接口，并用<code class="fe om on oo nc b">JpaRepository</code>进行了扩展。确保在<code class="fe om on oo nc b">JpaRepository</code>上的通用参数中专门添加实体类型和ID。</p><p id="8209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe om on oo nc b">CrudRepository</code>扩展，但我更喜欢<code class="fe om on oo nc b">JpaRepository</code>，因为它在find方法中返回一个列表，而不是由curd方法提供的一个可迭代列表。(如果你想找到更多关于这些库的信息，你可以使用<a class="ae ky" href="https://stackoverflow.com/questions/14014086/what-is-difference-between-crudrepository-and-jparepository-interfaces-in-spring" rel="noopener ugc nofollow" target="_blank">这个</a>线程。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="3537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我实现了一个组件，向我们的数据库添加一些虚拟数据。为此，我创建了一个服务包，并在其中定义了一个数据加载器服务。这将在初始化项目时添加指定的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于向SQL数据库插入虚拟数据的数据加载器服务</p></figure><p id="8b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好极了。现在你必须在<code class="fe om on oo nc b">application.properties</code>中进行配置，确保创建一个名为writeup的新数据库，并提供正确的凭证来连接MySQL数据库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="60ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本结构都做好了。嘿，控制器呢？如果你认为我忘记了，那你就大错特错了。在REST API中，我们使用控制器来处理多个端点。但是正如您已经知道的，在GraphQL中，您只需要一个API端点。所以你不需要任何控制器来处理。</p><p id="f09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！让我们做一个快速的演示运行，以检查所有的工作是否正常。</p><div class="kj kk kl km gt ab cb"><figure class="nl kn op nn no np nq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/d2fdd1806ad766179eb681abc13caf4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*ntnM4Gn6fdr7kIthZbGvWw.png"/></div></figure><figure class="nl kn oq nn no np nq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/fa1f447c208275c585ae2c0afe7bed68.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*MSaXfP1WhsFaMrPT94A8FA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk or di os nu translated">作者提供的截图。</p></figure></div><p id="5c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了。如你所见，我们的基本结构已经如预期的那样工作了。让我们进入大的一步。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd8a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><em class="na">释放野兽:</em>设置GraphQL</h1><p id="d853" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">重要的事情先来！您需要向项目中添加GraphQL依赖项。<br/>因此，在<code class="fe om on oo nc b">pom.xml</code>中，将这两个依赖项添加到<code class="fe om on oo nc b">&lt;dependencies&gt;</code>部分中，并通过单击右上角的<em class="ot"> m </em>图标来更新项目(解析依赖项)。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="697d" class="ng md it nc b gy nh ni l nj nk">&lt;!-- GraphQL dependencies --&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;<br/>    &lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;<br/>    &lt;version&gt;5.0.2&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;<br/>    &lt;artifactId&gt;graphql-java-tools&lt;/artifactId&gt;<br/>    &lt;version&gt;5.2.4&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/9468c6834a72c9a72a8447bbfef0cb46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6ecTzyeFI8UQL4ica3lcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的截图。</p></figure><p id="0008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL有两个主要的构建块:模式和解析器。作为在我们的应用程序中实现GraphQL的第一步，我们需要定义一个模式。</p><p id="5449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL模式最基本的组成部分是对象类型，它代表一个对象(如学生、动物等)。)以及它有哪些字段。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2069" class="ng md it nc b gy nh ni l nj nk">type Director {<br/>  name: String!<br/>  age: Int<br/>  films: [Film]<br/>}</span></pre><p id="c096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所知，在像java这样的语言中有如此多的原始和非原始数据类型。但是这里我们只能看到有限数量的数据类型(称为标量类型)。</p><ul class=""><li id="a6d4" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu ov ob oc od bi translated">Int:一个有符号的32位整数。</li><li id="f899" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu ov ob oc od bi translated">Float:有符号的双精度浮点值。</li><li id="af3c" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu ov ob oc od bi translated">字符串:UTF 8字符序列。</li><li id="4f4f" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu ov ob oc od bi translated">布尔值:真或假。</li><li id="9345" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu ov ob oc od bi translated">ID:唯一的标识符</li></ul><p id="2ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您可以根据自己的喜好定义自定义标量。<br/>(如日期、货币等..)</p><p id="78f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式中的大多数类型都是普通的对象类型，但是在模式中有两种特殊的类型。</p><ol class=""><li id="32de" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">查询:数据提取(读取)的入口点</li><li id="9bd7" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">突变:数据修改(写)的入口点</li></ol><p id="c833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过访问<a class="ae ky" href="https://graphql.org" rel="noopener ugc nofollow" target="_blank">官方GraphQL网站</a>了解更多关于这些概念的信息。</p><p id="f0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧。让我们定义我们的模式。为此，我在资源文件夹中创建了一个名为<code class="fe om on oo nc b">graphql</code>的目录，并在其中创建了一个<code class="fe om on oo nc b">schema.graphqls</code>文件。(确保扩展名应该是<code class="fe om on oo nc b">.graphqls</code>，因为它是一个模式文件。)</p><p id="4059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经在IntelliJ上安装了GraphQL插件，那么在创建文件之后，您可以看到GraphQL图标。它可以通过在插件部分进行搜索来轻松安装。在进行GraphQL模式文件的<br/>开发时，这将非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/fb807be7897c3d01b63ee054b95b1835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9m9djB1PukLtoQCU348zbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的截图。</p></figure><p id="9ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我为自己的写文章应用程序定义的模式。首先我用一个查询，很容易理解其中的东西，然后我会解释突变。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f77d" class="ng md it nc b gy nh ni l nj nk">schema {<br/>    query: Query,   <br/>}</span><span id="c152" class="ng md it nc b gy ox ni l nj nk">type Query{<br/>    # Fetch All Users<br/>    getAllUsers:[User]<br/>}</span><span id="b782" class="ng md it nc b gy ox ni l nj nk">type User {<br/>    userId : ID!,<br/>    firstName :String,<br/>    lastName :String,<br/>    dob:String,<br/>    address:String,<br/>    postId : Int,<br/>}</span></pre><p id="4b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请务必在此处添加评论。因此，我们可以在使用Altair等第三方工具测试服务器时查看这些描述(大多数情况下，我们使用这个客户端来测试GraphQL端点，而不是postman。)</p><p id="7ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们必须定义我们的解析器。(如果你想知道这个<code class="fe om on oo nc b">getAllUsers</code>方法是什么[不是一个方法而是一个字段]以及它在哪里引用，等等，就是这个)</p><p id="6ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析器是每个字段的函数，这些函数都有一个父对象、参数和执行上下文。它们负责返回该字段的相应数据结果。</p><p id="b460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过多种方式实现这一点。大多数大型项目(行业标准)倾向于在根层中创建一个单独的<code class="fe om on oo nc b">graphql</code>包，在这个包中，它将定义解析器接口和实现。此外，请求和响应的映射类型可以在单独的包中定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba2d36cc5a5dc61ea894e407c22eb4ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqGqp_oqVxsE1at4tSwFVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定义解析器的行业标准</p></figure><p id="3521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这是为了理解概念，所以我将在服务层实现它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="569e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个名为<code class="fe om on oo nc b">UserService</code>的新服务，并实现了作为<code class="fe om on oo nc b">graphql-java-tools</code>中的库接口的<code class="fe om on oo nc b">GraphQLQueryResolver</code>接口</p><p id="02b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我自动连接用户存储库，以获得与数据库的连接。(但是，在最新版本中不推荐这种现场注入。你可以做的是，点击左上角的黄色灯泡图标时，通过点击自动连线的注释出现，并重新格式化的想法建议。)</p><p id="216b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在希望您还记得我们在GraphQL模式中定义的<code class="fe om on oo nc b">getAllUsers</code>字段。这应该完全符合这个类的方法。所以我在这里定义了这个方法，并按照预期返回了用户列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/4f29f7abd0d9a3427618efe80cdfc5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFmcMBaBBUTF8YAJkKweYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件夹结构和服务层</p></figure><p id="ccf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们必须在<code class="fe om on oo nc b">application.properties</code>文件中定义我们的GraphQL配置。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="eeef" class="ng md it nc b gy nh ni l nj nk">#graphql properties<br/>graphql.servlet.corsEnabled=true<br/>graphql.servlet.mapping=/graphql<br/>graphql.servlet.enabled=true</span></pre><p id="62bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从配置中可以看到，<code class="fe om on oo nc b">/graphql</code>端点将处理所有的请求。所以不需要定义控制器。</p><p id="a41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切就绪！我们的服务器现在准备好了。进行一次测试运行，瞧:您将会看到这样一条消息，如“<em class="ot">已开始编写应用程序...(JVM运行…)" </em></p><p id="45e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在测试。正如我前面提到的，您可以使用Altair客户端来测试这些端点。它既是一个桌面应用，也是一个浏览器扩展。您可以通过点击<a class="ae ky" href="https://altair.sirmuel.design/docs/" rel="noopener ugc nofollow" target="_blank">此处</a>将其添加到您的机器中。</p><p id="405d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在使用Altair转到服务器端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/23c6d289a3d382c71f0c67fd828510be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbDmknJv8-rYGJo2u9N2gA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://localhost:7000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:7000/graph QL</a></p></figure><p id="7e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您重新加载docs部分，您可以看到带有注释消息的字段。你可以点击它，了解更多详情。在左上角写一个查询。你可以看到牛郎星给出了自动完成。通过单击运行查询或发送请求按钮，您可以获得结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/be5bf79e9456672341786e83848964bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BT7ol2I85_R2NtYeCRoBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的截图。</p></figure><p id="bc5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看，多酷啊！我们可以得到我们所要求的细节。我希望现在你们都清楚这个概念以及它的实用性。我将解释突变以及我的文章的完成。</p><p id="2593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您可以向模式文件添加一个变体。我做过更新用户地址的例子。为此，我将突变添加到模式中，并将突变定义如下。所以最终的模式如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="3219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我向用户存储库添加了一个SQL查询，以便根据传入的参数更新用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="ddc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在用户服务中，我们必须实现另一个名为<code class="fe om on oo nc b">GraphQLMutationResolver</code>的接口，然后我们可以在那里定义我们的<code class="fe om on oo nc b">updateUserAdress</code>方法。确保所有方法都可以公开访问。所以最后的<code class="fe om on oo nc b">UserService</code>会如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="81b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！我们也定义了我们的突变。现在像往常一样做测试。您可以通过检查数据库来确认API是否工作正常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/f87739718cf169b33ae950c50097b951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voqYoBAxQ6UyQdvfiX2SDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的截图。</p></figure><p id="6e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！您已经完成了GraphQL中的大多数概念。但是在这个神奇的世界里，我们还有很多东西需要探索。等等，我再透露一些事情。</p><p id="f9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了查询和变异，GraphQL还支持第三种操作类型，称为<strong class="lb iu">订阅</strong>。</p><p id="26a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像查询一样，订阅使您能够获取数据。与查询不同，订阅保持与GraphQL服务器的活动连接。(最常见的是通过Web套接字)这使您的服务器能够随着时间的推移推送订阅结果的更新。</p><p id="25f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在实时通知您的客户端后端数据的变更时非常有用，例如用户通知、重要更新、文件更改等。</p><p id="2759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，GraphQL还涵盖了更多内容，如错误处理、spring安全、验证等。因此，我也打算就这些主题发表单独的文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8fab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">内心平静:结论</h1><p id="725c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个我们今天构建的小演示，项目的完整源代码可以在下面看到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb ol l"/></div></figure><p id="a24b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">资源:<a class="ae ky" href="https://github.com/Yasas4D/WriteUp" rel="noopener ugc nofollow" target="_blank"> WriteUp </a>应用程序的源代码。</p><div class="pc pd gp gr pe pf"><a href="https://github.com/Yasas4D/WriteUp" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">yasas 4d/报道</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div></div></div>    
</body>
</html>