<html>
<head>
<title>How to Identify Similar Pieces of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何识别相似的代码片段</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-identify-similar-pieces-of-code-43d2a5cef5a6?source=collection_archive---------17-----------------------#2020-07-20">https://betterprogramming.pub/how-to-identify-similar-pieces-of-code-43d2a5cef5a6?source=collection_archive---------17-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe0d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用DRY来识别代码并清理您的代码库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aede97030194304631f0dea8766026b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFiFB4BSGfyZJTxQwQ6VXA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@martinadams?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马丁·亚当斯</a>在<a class="ae kv" href="https://unsplash.com/s/photos/pairs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="3673" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">目标</h1><p id="6340" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">最好是用尽可能少的代码库来获得想要的结果。<br/>代码库中的实体越少，就越容易熟悉、支持和构建代码库。</p><p id="f422" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">然而，随着项目及其团队的成长，意外引入相同或相似代码的风险也会增加，对于自动代码生成的迭代更是如此。</p><p id="21bd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><a class="ae kv" href="https://github.com/ch3rn0v/dry" rel="noopener ugc nofollow" target="_blank"> DRY </a>是我为了识别这种类似的作品而建立的项目。(好吧，好吧——和哈斯克尔一起玩。)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="15b1" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">考虑过的方法</h1><p id="5eb5" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">确定性地显示两段(可能不同的)代码是相同的，这并不是一个简单的任务，这意味着它们总是为相同的输入产生相同的输出。事实上，一个人必须为这样的主张或它的否定做出证明。</p><p id="b006" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">另一种方法是基于启发式。这是为干燥而选择的道路。这种方法有其缺点:可以很容易地创建两个函数，这两个函数可以欺骗任何给定的度量集，并且仍然可以证明函数是相同的。然而，在构建项目时，通常可以安全地忽略提到的漏洞。由于所有的最佳实践、命名约定、样式指南、自动语法测试等等，很可能相同的函数将具有相同的名称、arity、语句、计数和深度。因此，我决定尝试这种方法。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d9b4" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">韵律学</h1><p id="43bb" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">为每个唯一的函数对计算一组度量。每个度量都绑定到[0；1].这是指标本身。</p><p id="7d4c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">1.<strong class="lx ir"> </strong> <a class="ae kv" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> <strong class="lx ir">两个函数名之间的距离</strong> </a>。更准确地说，<code class="fe mw mx my mz b">1 / (1 + LD)</code>其中LD是Levenshtein距离。</p><p id="52d5" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">2.<strong class="lx ir">函数的arity差:</strong>如果两个函数的arity都为零，则为1，否则为较小值除以较大值。</p><p id="4a76" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">3.<strong class="lx ir">函数的语句差异:</strong>相同的语句在每个深度级别上统计，与不同种类的语句分开考虑。还考虑了唯一语句。越深，差别越不重要。两个函数中任何一个的唯一语句越多，函数越不相似(反之亦然)。</p><p id="d28b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">4.<strong class="lx ir">函数的语句总计数差</strong>，计数方式类似于arity:如果两个函数都有零个语句，则为1，否则为较小值除以较大值。</p><p id="d7ab" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">最后，对于每一对函数，将上述得分乘以一个权重向量。然后计算这些值的平均值，这就是给定函数对的相似性得分。</p><p id="91c2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">有人可能会想，既然已经有了第三个指标(说明语句计数的差异，按语句类型分组),为什么我们还需要第四个指标(总语句计数差异)。和深度水平)。如果函数体由相似的语句组成，那么第四个度量标准可能是多余的。但是，如果它们由不同的语句组成，那么在用于定义它们的语句数量上，可能有也可能没有相似性。第四个指标说明了这一点。</p><p id="d496" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">最后一个度量(如上面的四个)被绑定到[0；1]其中1相同，0完全不同。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5ed9" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结果</h1><p id="0bb3" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">我对许多回购执行了DRY，并用Python创建了这个可视化:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/c603a100e7a1539795a0e87f8bd7f8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7g68n_0GtMRlmEU-Rmarpg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/69fe4ec48e669d9a25be8b9f4e3cfb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kattOlOGBha9cRweq38MEA.png"/></div></div></figure><p id="8f93" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">有趣的是，大多数相似的函数都具有相似的语句总数。这仅仅是分数计算方式的结果(<a class="ae kv" href="https://github.com/ch3rn0v/dry/blob/master/src/Analyser.hs#L148" rel="noopener ugc nofollow" target="_blank">见权重向量</a>)。同样值得注意的是，有些函数有数百条语句。例如，这里是有3831条语句的<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/core/vdom/patch.js#L70" rel="noopener ugc nofollow" target="_blank"> Vue的</a> <code class="fe mw mx my mz b"><a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/core/vdom/patch.js#L70" rel="noopener ugc nofollow" target="_blank">createPatchFunction</a></code>。</p><p id="bf01" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">Vue是一个大到足以展示所有可能性的项目。我们先来看看完全相同的函数。他们数量相当多。</p><p id="5472" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">首先，这里是<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/platforms/web/runtime/modules/events.js#L32" rel="noopener ugc nofollow" target="_blank">一个平台</a>和<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/platforms/weex/runtime/modules/events.js#L7" rel="noopener ugc nofollow" target="_blank">另一个</a>的<code class="fe mw mx my mz b">createOnceHandler</code>。</p><p id="9a49" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">然后<code class="fe mw mx my mz b">genData</code>为<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/platforms/web/compiler/modules/class.js#L34" rel="noopener ugc nofollow" target="_blank">类</a>和<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/platforms/web/compiler/modules/style.js#L37" rel="noopener ugc nofollow" target="_blank">风格</a>。这是一个特例。根据度量标准，这些函数完全相同(得分为<code class="fe mw mx my mz b">1.0</code>)。然而，实际上它们并不相同:字符串模板略有不同，对象属性名也是如此。从技术上讲，解释这种差异是可能的。是否有实际意义是另一个问题。</p><p id="acdc" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">还有其他类似的<code class="fe mw mx my mz b">genData</code>的例子，比如<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/platforms/weex/compiler/modules/class.js#L38" rel="noopener ugc nofollow" target="_blank">这个</a>。总共发现了六对独特的<code class="fe mw mx my mz b">genData</code>。这给了我们四个不同的<code class="fe mw mx my mz b">genData</code>函数，它们彼此相似(因为每一对都是唯一的，并且每一对中的顺序无关紧要)。</p><p id="af85" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">一对相似函数的另一个例子是<code class="fe mw mx my mz b">generate</code>。我假设<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/server/optimizing-compiler/codegen.js#L39" rel="noopener ugc nofollow" target="_blank">这个</a>与服务器端渲染有关，而<a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/compiler/codegen/index.js#L43" rel="noopener ugc nofollow" target="_blank">这个</a>是客户端的。</p><p id="c4dc" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">好吧，那么几乎相似的功能呢？下面一对函数的相似性得分为<code class="fe mw mx my mz b">0.952695949955943</code>，语句计数分别为<code class="fe mw mx my mz b">105</code>和<code class="fe mw mx my mz b">100</code>:<code class="fe mw mx my mz b"><a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/platforms/weex/compiler/modules/style.js#L18" rel="noopener ugc nofollow" target="_blank">transformNode</a></code>和<code class="fe mw mx my mz b"><a class="ae kv" href="https://github.com/vuejs/vue/blob/8ead9d2a0d4ca686eaf5e35526eff4af1b8c79a7/src/platforms/weex/compiler/modules/class.js#L15" rel="noopener ugc nofollow" target="_blank">transformNode</a></code>。注意，在后一种情况下，如何测试<code class="fe mw mx my mz b">staticClass</code>是否等于<code class="fe mw mx my mz b">true</code>，而<code class="fe mw mx my mz b">staticStyle</code>没有被测试，即使它们被检索的方式是相同的:使用<code class="fe mw mx my mz b">getAndRemoveAttr</code>。</p><p id="5c35" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">对于回购，总共有167，331个唯一对，其中最不相似的函数对的得分为<code class="fe mw mx my mz b">0.002267573696145</code>。我邀请读者自己来看看这些功能是什么。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="1ace" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="dbea" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">如上所示，<a class="ae kv" href="https://github.com/ch3rn0v/dry" rel="noopener ugc nofollow" target="_blank"> DRY </a>不仅可以用来识别相似的功能，以便将它们抽象出来，从而减少代码库中的任何重复，还可以用来发现不一致性，这可能有助于发现bug。希望您会发现这个工具很有用。请随意尝试，指出任何问题和潜在的改进方法。</p><p id="ac67" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>