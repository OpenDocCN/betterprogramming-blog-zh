<html>
<head>
<title>Organizing Modules in React Project — Low Coupling and High Cohesion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React项目中的模块组织——低耦合和高内聚</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/coupling-cohesion-552b022492b2?source=collection_archive---------2-----------------------#2022-01-16">https://betterprogramming.pub/coupling-cohesion-552b022492b2?source=collection_archive---------2-----------------------#2022-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cce3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">设计强大的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e410f3e15f1ec9a635a2f36f0622e1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1pL_FNwp1AKqoLfoekyDQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@xps" rel="noopener ugc nofollow" target="_blank"> XPS </a>在<a class="ae kv" href="https://unsplash.com/photos/7ZWVnVSaafY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4f3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你如何在你正在做的React项目中组织模块？我希望您将彼此相关的元素放在一起(模块)，然后在这些元素组之间建立连接。对吗？</p><p id="9d27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述原理允许设计可扩展的应用程序。听起来是这样的:</p><blockquote class="ls lt lu"><p id="b2b3" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">以解耦和内聚的方式组织系统元素。即偏爱<strong class="ky ir">低耦合</strong>和<strong class="ky ir">高内聚</strong>。</p></blockquote><p id="5ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经听过这个规则了。但是你有没有想过它到底意味着什么，它能提供什么真正的好处？我建议你更深入地探究这些问题，并找到遵循这条规则的理由。</p><h1 id="e326" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">连接</h1><p id="9001" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">耦合类似于系统元素之间的连接。高耦合是指系统中的元素有混乱的连接。</p><p id="54b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从技术上讲，我们可以度量耦合的价值——这只是系统元素(功能、对象、模块等)之间的一些连接。).该规则规定系统应该具有尽可能少的连接数。在这种情况下，我们可以确定只有预期的连接，并且我们能够有效地管理它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/aa1888b768e5d859c6623bdcdb198cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*SAvDcqHmBUAKn9IgiRAduA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片。1.连接</p></figure><p id="c711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，我不确定是否有一种简单的方法来计算连接数。我甚至不认为这个数字真的有用！</p><p id="aa03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们想象一下，我们已经以某种方式计算了一些连接，结果是“100”。是多还是少？我们如何利用这个数字来改进现有的系统？不确定在这里回答什么。</p><p id="4fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，如何改进现有的系统呢？唯一合适的方法是遵循我们稍后将要讨论的技术。</p><h1 id="c290" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">内聚力</h1><p id="e84c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">内聚是指系统的元素按照某种标准组合在一起。低内聚意味着app元素没有清晰的边界。这可能看起来一团糟。</p><p id="6a20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多东西我们可以称之为“组”:</p><ul class=""><li id="11c1" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">组件</li><li id="e7d5" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">班级</li><li id="c703" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">反应组件(类和函数)</li><li id="ed39" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">命名空间</li><li id="e52b" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">服务</li><li id="2c8c" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">诸如此类…</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/a233e3e1c4590fcf303c35548882101b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjPEud4D9xc1lcz2eRkKnQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片。2.内聚力</p></figure><p id="102d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么有用呢？因为在一个内聚的系统中，元素之间的联系要少得多。这导致对这些连接的更好的管理，并且我们可以更确定它们是预期的。</p><p id="83c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，“耦合”和“内聚”这两个术语总是在一起。在这种情况下，支持高内聚是减少连接数量并使系统更易于管理和扩展的更好的解决方案。</p><h1 id="ebae" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">耦合和内聚</h1><p id="e69a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们来探讨不同的案例。下面你可以找到一个描述“耦合”和“内聚”之间联系的图表。这对于分析您的应用程序和创建改进计划可能很有用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4d50917895eb218ccfcc3ae02c385e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*xvXUm5b-zCy7-5RrxVjPxQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片。3.耦合和内聚</p></figure><h2 id="0a52" class="nn ma iq bd mb no np dn mf nq nr dp mj lf ns nt ml lj nu nv mn ln nw nx mp ny bi translated"><strong class="ak"> 1。理想:低耦合、高内聚</strong></h2><p id="5c4b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这是一个我们需要支持的案子。这样的系统是可管理和可扩展的。在大多数情况下，开发人员喜欢使用类似的系统，因为它可以被分成逻辑部分；这导致了开发过程中较低的精神压力。</p><p id="df16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面你可以看到在这种情况下元素之间的连接是什么样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4b3e1f1d33e8cd945b17332a962685eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*NspNoeA5U2sKnUz2z_B1uQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片。4.理想:低耦合、高内聚</p></figure><p id="971c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何遵循这个规则？并不复杂:将相关元素组织成组(见上文)，并在组之间建立连接。</p><p id="edfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，项目结构可能是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点1。理想:低耦合、高内聚(结构)</p></figure><p id="0f9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看一个虚构的代码示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点2。理想:低耦合、高内聚(代码)</p></figure><h2 id="fbf9" class="nn ma iq bd mb no np dn mf nq nr dp mj lf ns nt ml lj nu nv mn ln nw nx mp ny bi translated"><strong class="ak"> 2。神模块:高耦合、高内聚</strong></h2><p id="3861" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对我来说，这是最坏的情况，每个团队都应该避免。这样的系统很难管理，并且不能以适当的方式扩展。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/aaaf32d3a19281329860d60aea186df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*s__25btT1Mkx5--YitSt0g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片。5.上帝模块:高耦合、高内聚</p></figure><p id="6cea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，系统元素变得一塌糊涂。让我们想象一下这在代码结构中会是什么样子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点三。神模块:高耦合、高内聚(结构)</p></figure><p id="3a11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和人为的代码示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点4。神模块:高耦合、高内聚(代码)</p></figure><p id="e1f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的问题是共享组件中嵌入了数据逻辑。这个组件应该是可重用的，新的数据类型不应该影响它。请避免这样的设计，将所有特定的逻辑放在可重用组件之外。</p><h2 id="61b2" class="nn ma iq bd mb no np dn mf nq nr dp mj lf ns nt ml lj nu nv mn ln nw nx mp ny bi translated"><strong class="ak"> 3。错误的界限:</strong>高耦合，低内聚</h2><p id="d952" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们在没有任何额外单词的情况下研究图表和例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a87bd57535bdf2a2ad613bc2a83493f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*-BJ1xE6dK7pvzq0KuZI_hg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片。6.错误的边界:高耦合，低内聚</p></figure><p id="1970" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人为的项目结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点5。错误的边界:高耦合，低内聚(结构)</p></figure><p id="1408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和人为的代码示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点6。错误的边界:高耦合，低内聚(代码)</p></figure><p id="5207" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你清楚这个例子中的界限是错误的。这样的应用程序应该重新设计，就像在第一个例子。</p><h2 id="965f" class="nn ma iq bd mb no np dn mf nq nr dp mj lf ns nt ml lj nu nv mn ln nw nx mp ny bi translated"><strong class="ak"> 4。破坏性解耦:低耦合、低内聚</strong></h2><p id="21ea" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们在没有详细解释的情况下研究图表和示例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f898076c3013070a9c32b1cce576d207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*sJzaiAqOFx9BDv5Z9601EQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片。7.破坏性解耦:低耦合、低内聚</p></figure><p id="f45d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人为的代码结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点7。破坏性解耦:低耦合、低内聚(结构)</p></figure><p id="3310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和人为的代码示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要点8。破坏性解耦:低耦合、低内聚(代码)</p></figure><p id="e4f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的问题是有很多元素被扔在同一个堆里。并且很难理解每个模块(文件)的使用范围。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="c827" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！希望您喜欢这些内容，这将帮助您设计健壮的应用程序。</p></div></div>    
</body>
</html>