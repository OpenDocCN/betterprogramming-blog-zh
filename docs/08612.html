<html>
<head>
<title>7 Tricks I Use To Rewrite JavaScript Code From My Early Days</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我早期用来重写JavaScript代码的7个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-approaches-to-rewriting-javascript-from-my-early-days-c6ada526d55f?source=collection_archive---------3-----------------------#2021-05-20">https://betterprogramming.pub/7-approaches-to-rewriting-javascript-from-my-early-days-c6ada526d55f?source=collection_archive---------3-----------------------#2021-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f351" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">3.移除过多的中间函数返回</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cfe548a8fb3354523c4f7db3fc2ed4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMQ7jyacFtBIMQbNGvXGTQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mr_vero?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">欧文·史密斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/javascript-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我回到过去编写的JavaScript代码库时，我有时会遇到现在通常以更紧凑和可读的方式编写的代码。事实上，特定的旧代码模式如此突出，以至于当我看到它们时，很难不重构它们。</p><p id="3e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我早年使用的七个旧代码模式的例子，以及我通常喜欢如何重写它们。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="29d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.删除不必要的括号</h1><p id="270f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在使用方括号深入研究PHP中的对象之后，我很早就将这个习惯带入了JavaScript的编写中。下面是一个例子，我检查了一本书的<code class="fe mz na nb nc b">preface</code>属性，以便获得它的<code class="fe mz na nb nc b">intro</code>属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/144f41ff4385e9d157cfbb0f4b9d2ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsPpvJs0ScjM53KS6ZqLlw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不必要的括号语法。</p></figure><p id="f449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某一点上，我在括号语法和点语法之间建立了联系，并开始使用点语法来访问我知道不会改变的属性。</p><p id="edfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在每当我知道我的属性是什么时，我就使用点语法。我发现它使我的代码更简洁，更易读。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/855a38a5ba501b94efb867f8dd141490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwcqiUsdB4ngGTXZpQ_Ulw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用点语法钻取对象。</p></figure><p id="aead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我唯一一次使用括号语法是在属性是一个可能会改变的变量的时候。下面是一个通过<code class="fe mz na nb nc b">myProp</code>变量任意选择一个属性进行访问的简单例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/a9bd7ca54835a963a25a5401a72ab223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XTVo2Z42z8iLV_RgEx2Dg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用不确定变量时，括号语法很有用。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c355" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.构建字符串时换入模板文本</h1><p id="c578" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">过去，我总是使用加号(<code class="fe mz na nb nc b">+</code>)来连接字符串。现在，这通常感觉空间效率低下——尤其是当我合并多个变量时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ef2fde7c318e7c297279ef1a6d0f1ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qc9cgTrmBV6Juvq4jPFnUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过连接字符串和变量来初始化字符串。</p></figure><p id="3c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我发现一个难以阅读的串联字符串，我会用一个模板文字替换它，这样更容易查看。请注意，两个反斜线(<code class="fe mz na nb nc b">``</code>)用于区分字符串，一个美元符号加上一对花括号(<code class="fe mz na nb nc b">${}</code>)用于表示每个变量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/764095b926d9a206681f139d245c02fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2B23XiCvvZSbbg5HPVxpCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用模板文本初始化字符串。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.移除过多的中间函数返回</h1><p id="c778" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我开始编写可以与外界交互的代码时，我最初编写了许多中间函数<code class="fe mz na nb nc b">returns</code>,以确保我不会因为缺少属性而破坏我的应用程序的功能。这导致了许多额外的行来处理我认为可能发生的每个问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/23ed9610e38b85616597a97961b270f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ei84vPNTpC7NiQlVy5SHrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个中间函数返回。</p></figure><p id="211e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我开始意识到过多的中间函数<code class="fe mz na nb nc b">returns</code>会使我的代码混乱，并鼓励我以灾难优先的心态思考，这会分散我的代码读者对函数目的的注意力。虽然我的目标仍然是处理相同的问题，但我现在尝试编写代码，首先给自己一个默认值，首先关注期望的结果，然后处理潜在的无值情况。</p><p id="e125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的例子中看到这个方法，它将一个空对象作为默认对象分配给<code class="fe mz na nb nc b">obj</code>，然后使用一个<code class="fe mz na nb nc b">if</code>语句来运行预期的代码，只要该属性存在。我仍然处理无价值的情况，但是最后:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/e869ff263d96ce02d113e52b6b942dcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*df2r9-uTdRp9ZVkm2SCPwg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用默认参数和正的if条件。</p></figure><p id="8f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">中间函数<code class="fe mz na nb nc b">returns</code>在某些情况下仍然可能有它们的位置——特别是当我喜欢限制你的缩进量时——但是我现在尝试更多地使用默认参数和正的<code class="fe mz na nb nc b">if</code>条件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6476" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.对默认属性使用OR运算符</h1><p id="aa2f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我不确定属性是否存在的情况下，我的老方法是使用一个<code class="fe mz na nb nc b">if</code>语句来检查丢失的属性，并在必要时给它一个默认属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/674e2a284fbf589b19f84c08d20c6109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7ihCu06lrm0nRTlpYcoUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旧方法:使用if语句分配默认属性</p></figure><p id="6bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然处理这种情况仍然很重要，但我现在的目标是以更紧凑的方式编写它，首先处理期望的结果。所以我现在的方法是使用OR运算符(<code class="fe mz na nb nc b">||</code>)来指定一个默认值，如果有必要的话:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a9c4a26d37ffa3d5dc5c8e1682b4cf0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ao30I7c2c9o2WJplRVoiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新方法:使用OR运算符分配默认属性。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="13cf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.用一个对象替换多个参数</h1><p id="8ac5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我的更复杂的应用程序中，我有时发现自己编写的函数接受许多参数。这个函数一开始可能只有一两个参数，但是随着函数变得越来越复杂，参数的数量也会增加。下面是一个相当短的例子，有五个参数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/4c9d7ce3528067fe18afd4e49c4c185d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCwOh62cBcxkGJ-S290KQw.png"/></div></div></figure><p id="2f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我调用这些函数时，参数的顺序变得至关重要。这些年来，我注意到我所犯的许多错误都源于参数的顺序。如果您只使用下面的方法调用该函数一次或两次，可能不会有任何问题:</p><pre class="kj kk kl km gt nm nc nn no aw np bi"><span id="fa95" class="nq md it nc b gy nr ns l nt nu"><br/>printBook(bookId, lastName, firstName, bookTitle, bookDate);<br/></span></pre><p id="3afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果您在许多地方调用该函数，并决定更改参数的顺序，这可能会导致错误。</p><p id="b0f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以对于有很多参数的函数，我已经开始将所有属性捆绑到一个对象中，然后作为一个参数传入:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e85daa63f48939087b9a46e66f3e0233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrBBikvGkN0Xm5tx3v5iTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">捆绑到作为参数传入的对象中的各种属性。</p></figure><p id="c2c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于新的<code class="fe mz na nb nc b">printBook</code>函数，我在参数空间中使用花括号(<code class="fe mz na nb nc b">{}</code>)来析构传入的对象并解包我需要的属性:</p><pre class="kj kk kl km gt nm nc nn no aw np bi"><span id="81e5" class="nq md it nc b gy nr ns l nt nu">function printBook (<strong class="nc iu">{</strong>lastName, firstName, bookTitle, bookDate<strong class="nc iu">}</strong>) {<br/>   <br/>   // logic goes here</span><span id="031e" class="nq md it nc b gy nw ns l nt nu">}</span></pre><p id="c166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于析构，参数的顺序和数量无关紧要。我发现这给了我一种受欢迎的灵活性，并且导致了更少的与参数相关的错误。下面是完整的功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/20212b71648dc1af7886862c367c571a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpCXeH2jUUZ9yIwwCwI5FQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">析构赋值语法。</p></figure><p id="19db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是该示例的工作演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">属性捆绑技术的演示。</p></figure><p id="c08a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然像这样将属性分组到一个对象中是一种强大的技术，但是当属性相互关联时效果最好。例如，如果我想将一个DOM元素的参数传入到<code class="fe mz na nb nc b">printBook</code>中，这将发生在这个对象之外。注意函数和相关函数调用末尾的<code class="fe mz na nb nc b">el</code>参数。</p><pre class="kj kk kl km gt nm nc nn no aw np bi"><span id="033c" class="nq md it nc b gy nr ns l nt nu">function printBook (<strong class="nc iu">{</strong>lastName, firstName, bookTitle, bookDate<strong class="nc iu">}</strong>, <strong class="nc iu">el</strong>) {</span><span id="e963" class="nq md it nc b gy nw ns l nt nu">}</span><span id="0b17" class="nq md it nc b gy nw ns l nt nu">printBook(object, <strong class="nc iu">el</strong>)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1575" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.在某些情况下，将forEach替换为for…of</h1><p id="e213" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">过去，我经常将<code class="fe mz na nb nc b">forEach</code>与异步实用程序方法结合使用，比如一个定制的<code class="fe mz na nb nc b">getJSON</code>请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/9004d6c640e6bb07ba0cafc08f7990d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VzFmX3ZjBW_Q9YIlyPVnKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用forEach语法的异步函数。</p></figure><p id="c3ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe mz na nb nc b">forEach</code>在某些情况下仍然非常重要——尤其是DOM操作——但当我开始使用<code class="fe mz na nb nc b">async/await</code>时，我发现它不够用，因为我想以顺序方式处理每个<code class="fe mz na nb nc b">getJSON</code>调用的结果。</p><p id="3ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地控制何时处理结果，我使用了<code class="fe mz na nb nc b">for...of</code>循环:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b6696ae6881f5b378a9213a12c9a378f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHySNAFX0VxacTo10U61rg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">for…of循环。</p></figure><p id="4812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这是一种以可预测的顺序方式处理多个异步函数结果的更好方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5826" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.使用自定义方法构建复杂的DOM元素</h1><p id="cf33" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我停止定期使用jQuery之后，我开始从头开始创建DOM元素。这感觉更干净，但也更罗嗦:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/6d4dc2ff928832184023ae6e3ef3b1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1txVY4ElBKUaanRbW0H0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用传统语法创建标签元素。</p></figure><p id="586d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几年后，我编写了一个小的实用方法，允许我更紧凑地编写DOM元素。注意，我遍历了一个<code class="fe mz na nb nc b">attrs</code>属性中的键来设置定制属性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ce8b8f2bd6efb1012aca235e614f2f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqrMw-HdRu-A52qAAoEnmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加DOM元素的实用方法。</p></figure><p id="aa00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我可以使用自定义方法以简洁的方式声明一个元素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/1dfc3df4f3ee62d5a4a0fe8d18496cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUXR74ierc22K4w9pLGjpw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用我的助手方法声明一个标签元素。</p></figure><p id="898b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现自己现在经常使用这样的效用函数。下面是上例的工作演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个DOM实用方法的演示。</p></figure><p id="552f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这个实用方法帮助我使创建DOM元素的语法更加紧凑和易读。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ca03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="0006" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">令人惊讶的是，当我遇到它时，我在某一点上不假思索地写下的东西现在会让我如此困扰。如果您遇到这种情况，并发现自己对旧代码望而却步，请振作起来。这意味着你的编码实践在进步。我希望这些方法可以作为有用的例子，让您的JavaScript代码更清晰、更简洁。</p><p id="95fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c3e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在别处</h1><p id="36ba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是我写的另外两篇文章，你可能也会喜欢。</p><p id="74e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">寻找代码中最棘手bug的7种策略</p><p id="e794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/geekculture/capture-and-display-your-json-data-with-vanilla-javascript-4675f81cfb54" rel="noopener">用普通的JavaScript捕获并显示你的JSON数据</a></p></div></div>    
</body>
</html>