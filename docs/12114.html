<html>
<head>
<title>Mastering GDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握GDB</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-gdb-be5e589af90b?source=collection_archive---------5-----------------------#2022-05-12">https://betterprogramming.pub/mastering-gdb-be5e589af90b?source=collection_archive---------5-----------------------#2022-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ff8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高你的调试技能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/27f6ffcbcf2e700cb5492b85e84e48fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zFA-o55IxTwHCwM5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="0bc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GNU项目调试器(GDB)是Linux下非常有用的调试器。<br/>聪明的程序员通常使用gdb来调试bug，当一个程序核心转储，或者一个程序发生意外行为时。在本文中，我将向您展示如何高效地使用gdb。</p><h1 id="c8f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">选择合适的编译标志</h1><p id="bfbf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">编译器通常会进行许多优化，以生成最佳代码，这给调试带来了困难。如果遇到类似找不到符号这样的错误，需要打开适当的编译标志进行调试，以便调试器可以获得足够的信息。</p><ul class=""><li id="5d50" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">-g</code>让编译器将调试信息构建到可执行文件中。</li><li id="d0c3" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">-ggdb3</code>可以让gdb调试宏。</li><li id="74fe" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">-fno-omit-frame-pointer</code>来避免编译器优化掉小函数，这样你就可以看到完整的调用栈。</li><li id="e374" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">-0g</code>让编译器打开不影响调试的优化。</li></ul><h1 id="1a9c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">启动gdb</h1><p id="69aa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用适当的标志编译程序后，我们可以使用GDB来调试生成的可执行文件。有很多不同的场景，每个场景的启动方式都略有不同。</p><ul class=""><li id="09d2" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">在第一个场景中，我们有一个接受一些参数的可执行文件。我们可以用<code class="fe my mz na nb b">gdb executable</code>启动gdb，然后用<code class="fe my mz na nb b">run arg1 arg2</code>运行程序。</li><li id="d00d" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">在第二种情况下，当可执行文件正在运行时，会生成一个核心转储文件，这可能是一个段故障。我们可以用<code class="fe my mz na nb b">gdb executable coredump_file</code>启动gdb，gdb会在错误发生的地方停止。</li><li id="a20e" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">在第三个场景中，我们有一个正在运行的可执行文件。我们可以使用<code class="fe my mz na nb b">gdb attach pid</code>来附加到进程。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/25d14ebb44787189ee02da335bff5aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y2MSHumKaheFC5O9sNUdmg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">启动广发的截图</p></figure><h1 id="a6b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">断点和监视</h1><p id="ed66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">启动gdb后，我们一般会设置一个断点。程序在遇到检查点时会暂停。我们可以观察程序的状态。</p><ul class=""><li id="107f" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">break func</code>会在某个函数处中断。</li><li id="6899" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">break example.cc:10</code>会在example.cc的第10行中断，如果只有一个文件，我们可以省略文件名，直接用<code class="fe my mz na nb b">break 10</code>。我们可以键入<code class="fe my mz na nb b">list</code>来显示当前行周围的代码。</li><li id="0ee9" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">info breaks</code>可以显示你设置的所有断点。</li><li id="0871" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">delete 2</code>将删除第二个断点。</li><li id="d27a" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">你也可以设置条件断点，只需将<code class="fe my mz na nb b">if [condition]</code>追加到break命令。</li><li id="3063" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">可以在一个变量上设置一个观察点，观察点是另一种断点，如果被观察的变量改变了，它将暂停程序。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/cc53f222d5c25456190e936a0bcb6851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_VCdDEgjpxpe7SFdCyJEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">设置断点的图示</p></figure><h1 id="fd86" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">变量和表达式</h1><p id="fa9d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当暂停在一个断点上时，我们可以通过打印变量和表达式来观察程序的状态。</p><ul class=""><li id="c930" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">info args</code>可以向我们展示一个函数的自变量。</li><li id="062a" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">info locals</code>可以显示当前函数的局部变量。</li><li id="045e" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">print</code>可以用来显示一个变量或一个表达式的结果。参见下图。<code class="fe my mz na nb b">print a</code>打印变量。<code class="fe my mz na nb b">print a=2</code>将首先评估<code class="fe my mz na nb b">a=2</code>然后打印结果。注意，如果直接输入<code class="fe my mz na nb b">a=2</code>，会得到一个错误。<code class="fe my mz na nb b">print sum(1, a)</code>调用函数<code class="fe my mz na nb b">sum</code>。</li></ul><blockquote class="nj nk nl"><p id="c7cd" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">(gdb)print a<br/>$ 1 = 1<br/>(gdb)print a = 2<br/>$ 2 = 2<br/>(gdb)print sum(1，a)</p></blockquote><p id="8fd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以格式化<code class="fe my mz na nb b">print</code>的结果，</p><ul class=""><li id="4a51" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">print /x &lt;exp&gt;</code>将以十六进制显示结果。</li><li id="3bc5" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">print /t &lt;exp&gt;</code>将以二进制显示结果。</li><li id="03f4" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">print /d &lt;exp&gt;</code>将以无符号整数格式显示结果。</li><li id="de17" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">print /c &lt;exp&gt;</code>将以有符号整数格式显示结果。</li><li id="6f11" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">注意<code class="fe my mz na nb b">print</code>的结果，如<code class="fe my mz na nb b">$1</code>、<code class="fe my mz na nb b">$2</code>也是可以进一步使用的变量。</li><li id="4c4d" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">dprintf locaion, format-string, expr1, expr2</code>。<code class="fe my mz na nb b">drpintf</code>是一个方便的命令，可以在该位置动态打印，就像你在该位置插入了一个<code class="fe my mz na nb b">printf</code>表达式一样。</li><li id="b3dd" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">set $foo = 4</code>可以设置变量。如果你想保存一些中间结果，这是很方便的。</li><li id="91a9" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">command 2</code>是另一个gdb命令，你可以设置命中特定断点时要执行的命令。当点击第一个断点时，下图将自动执行<code class="fe my mz na nb b">info locals</code>。你也可以用这种方法达到<code class="fe my mz na nb b">dprintf</code>同样的效果。</li></ul><blockquote class="nj nk nl"><p id="fc40" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">(gdb)命令1 <br/>为断点1键入命令，每行一个。<br/>以一句“结束”结束。<br/>T34】info locals<br/>T35】end</p></blockquote><ul class=""><li id="aaff" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">print *&amp;arr[96]@5</code>可以打印一个数组的96–100个元素。</li></ul><p id="a6ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意目前我们不能轻易打印std::vector或其他c++ stdlib容器。这个话题我们以后再讨论。</p><h1 id="8277" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">施工管理</h1><p id="c480" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有几个命令允许我们在gdb会话中控制程序的执行。</p><ul class=""><li id="b6e1" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">run</code>将开始运行程序并在第一个断点处停止，如果没有断点，程序将在退出时停止。</li><li id="1dc3" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">start</code>将启动程序并停止<code class="fe my mz na nb b">main</code>功能。</li><li id="416b" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">continue</code>将继续程序，并在下一个断点处停止或退出。</li><li id="2be3" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">finish</code>将在当前功能完成时停止。</li><li id="abbc" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">next</code>会停在下一行。</li><li id="fbf6" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">step</code>将进入一个功能并停在那里。</li></ul><h1 id="351e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">文本用户界面</h1><p id="2d12" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Gdb包含一个文本用户界面(TUI)，就像大多数ide一样，它可以在调试时显示代码行。<code class="fe my mz na nb b">tui enable</code>进入tui模式，按<code class="fe my mz na nb b">tui disable</code>退出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/b2e84adec46becb79dc537b37fafcb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EudLn1e0bIa-_6o24cF2Kw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">TUI插图</p></figure><h1 id="1a0c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">回溯和线程</h1><p id="1438" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">回溯对于调试非常有用，尤其是在我们调试核心转储时。</p><ul class=""><li id="4dca" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">bt</code>将显示当前回溯。</li><li id="91a3" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">up</code>会将您移动到上层框架。</li><li id="0256" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">down</code>会将您移动到下部框架。</li><li id="2958" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">frame 2</code>会直接带你到第二帧。</li></ul><p id="44ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当调试多线程程序时，</p><ul class=""><li id="8354" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">info threads</code>显示所有线程。</li><li id="e11d" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">thread 5</code>将转到第五个线程。</li><li id="e3ab" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">thread apply all [command]</code>将在所有线程上执行一个命令。使用<code class="fe my mz na nb b">thread apply all bt full</code>打印所有线程的所有回溯非常方便。</li></ul><h1 id="a320" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用<code class="fe my mz na nb b">.gdbinit</code>配置gdb</h1><p id="4b70" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Gdb有一个配置文件，位于<code class="fe my mz na nb b">~/.gitinit</code>或者当前文件夹，就像<code class="fe my mz na nb b">.vimrc</code>对于<code class="fe my mz na nb b">vim</code>一样。当前路径中的配置文件比<code class="fe my mz na nb b">~/.gitinit</code>具有更高的加载优先级。我们来讨论一些配置。</p><ul class=""><li id="c8a1" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe my mz na nb b">set logging on</code>将所有输出输出到<code class="fe my mz na nb b">gdb.txt</code>。当命令输出如此多的信息时，这很有用，就像上面的<code class="fe my mz na nb b">thread apply all bt full</code>。</li><li id="7fd9" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">set history save on</code>保存命令历史。</li><li id="cb15" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">set pagination off</code>禁用长屏幕输出的交互显示。</li><li id="00de" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">set print pretty on</code>可以用更漂亮的格式显示c++类。</li><li id="7760" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">set confirm off</code>禁用确认。</li></ul><p id="b7b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然gdb不能方便的打印出<code class="fe my mz na nb b">std::vector</code>之类的c++容器，我们可以写一些脚本让它变得简单。跟随<a class="ae kv" href="https://gist.github.com/skyscribe/3978082" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/skyscribe/3978082</a>。</p><h1 id="0ea5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">源文件路径</h1><p id="69da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有时我们会遇到像<code class="fe my mz na nb b">xxx.c: No such file or directory</code>这样的错误。这意味着gdb找不到源文件。解决方案是:</p><ul class=""><li id="34d6" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">directory [folder]</code>将特定目录添加到gdb的搜索路径中。</li><li id="12c1" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">set substitute-path [src] [dst]</code>替换路径。</li></ul><h1 id="8561" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">宏观扩张</h1><p id="9ae3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">还可以展开宏来查看预处理后的细节。</p><ul class=""><li id="6580" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">macro expand some_macro(macro_arg)</code>展开宏。</li><li id="7543" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">info macro some_macro</code>查看其定义。</li></ul><p id="2b9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意gdb将分析当前函数的上下文，只有在当前上下文中可见的宏才可以展开。</p><h1 id="cc27" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">记录程序的状态</h1><p id="f695" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">gdb的一个强大的命令是<code class="fe my mz na nb b">record</code>，它记录正在运行的程序的状态，并允许您回退程序。Gdb还提供了一组以<code class="fe my mz na nb b">reverse</code>前缀开头的命令，如<code class="fe my mz na nb b">reverse-continue</code>、<code class="fe my mz na nb b">reverse-finish</code>、<code class="fe my mz na nb b">reverse-next</code>、<code class="fe my mz na nb b">reverse-nexti</code>、<code class="fe my mz na nb b">reverse-step</code>、<code class="fe my mz na nb b">reverse-stepi</code>。</p><p id="faeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">record</code>的一个用途是发现内存损坏。可以在gdb中运行程序，记录程序的执行情况，停在发生内存崩溃的位置。然后，您可以查看损坏的内存地址。然后反向运行程序，看看地址的内容在哪里发生了变化。</p><p id="3ede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">record</code>的缺点是会让你的程序变慢。用好还是要下一番功夫的。</p><h1 id="bb61" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">保存并加载调试会话</h1><p id="55c4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有时候需要反复调整代码，多次运行程序，才能逐渐了解bug的细节。但如果每次都重启gdb，那么反复设置检查点就不方便了。我们可以保存调试会话并在以后重新加载它。</p><p id="c04b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用makefile来构建你的程序，你可以简单地在gdb会话中输入<code class="fe my mz na nb b">make</code>，它将重建你的程序并重置检查点。</p><p id="413b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以使用<code class="fe my mz na nb b">save breakpoints bp.txt</code>将断点保存到bp.txt，稍后使用<code class="fe my mz na nb b">source bp.txt</code>重新加载这些断点，或者使用<code class="fe my mz na nb b">gdb -x bp.txt --args [exe]</code>在gdb启动时加载。</p><h1 id="a045" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于调试的更多信息</h1><p id="ac26" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">除了gdb，还有很多其他的调试方法:比如分析日志。二分搜索法git提交。它们各有利弊。在调试程序时，您可以结合使用这些方法来有效地解决问题。这样做的好处是你可以完全访问正在运行的程序，这在一个bug很难重现的时候非常有用。</p></div></div>    
</body>
</html>