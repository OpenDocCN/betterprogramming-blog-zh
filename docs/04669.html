<html>
<head>
<title>You Built a Container, Now What?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你造了一个容器，现在怎么办？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-built-a-container-now-what-4bda43aa1cd?source=collection_archive---------15-----------------------#2020-04-28">https://betterprogramming.pub/you-built-a-container-now-what-4bda43aa1cd?source=collection_archive---------15-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Docker、Docker Compose和Kubernetes之间的区别</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d6235056a99e69fc0c8a3d352ab0cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIF6RAvYCKY20iP6Go2ucg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.wallpaperflare.com/electronics-kubernetes-ukraine-l-viv-headset-headphones-wallpaper-evoaq" rel="noopener ugc nofollow" target="_blank">壁纸光斑</a></p></figure><p id="6ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厌倦了在不同的机器上反复配置相同的软件？处理你需要安装的16个不同的包，一遍又一遍地遵循一个wiki文档开始变得很麻烦。你有没有在Medium上找到关于如何运行你的第一个Docker容器的教程？太棒了，现在你做什么？</p><p id="59f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始使用Docker和容器时，人们最常问的一个问题是<em class="lv">下一步是什么？</em></p><ul class=""><li id="3f84" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">如何在Docker容器中运行我的Angular应用程序？</li><li id="f5a1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我应该为我的应用程序的每个版本创建一个新的容器吗？</li><li id="d781" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如何将数据库连接到我的应用程序？</li><li id="4527" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">什么是<code class="fe mk ml mm mn b">docker-compose</code>文件？</li><li id="7675" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">既然Kubernetes使用容器，我应该学习它吗？</li></ul><p id="6982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有和上面类似的问题，请继续读下去，让我为你一一解答。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="ca50" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">运行容器与构建容器</h1><p id="0d31" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果您是一名应用程序程序员，您可能正在尝试构建一个容器，并使用Dockerfile文件让它运行。如果您是系统管理员，您可能会尝试运行Docker容器并管理它的生命周期。理解您在运行时和构建时能做什么之间的区别是很重要的。</p><h2 id="7e75" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated"><strong class="ak">运行时间</strong></h2><p id="8166" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">简单地运行一个容器与在桌面上启动一个应用程序没有什么不同。有一个预配置的脚本，在构建时用<code class="fe mk ml mm mn b">ENTRYPOINT</code>配置，它会做启动所需的任何事情。容器将一直运行，直到脚本以<code class="fe mk ml mm mn b">0</code>状态退出。理解这一点非常重要，尤其是在构建容器的时候。</p><h2 id="ef77" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated"><strong class="ak">构建时间</strong></h2><p id="73a5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当使用Dockerfile时，考虑需要将什么放入新容器的最简单的方法是这样的:使用一些基本级别的容器，并在Dockerfile中添加或覆盖内容，最终生成一个独立的容器，这是一个新的映像。</p><p id="80f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果你试图获取一个<code class="fe mk ml mm mn b">centos:7</code>容器，并在其中安装一个应用程序，让它在你执行<code class="fe mk ml mm mn b">run</code>命令时自动启动并运行，你需要记住这些关键的事情:</p><ul class=""><li id="b051" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">对于您需要做的任何命令行事情，使用<code class="fe mk ml mm mn b">RUN</code>语法</li><li id="ce11" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">使用<code class="fe mk ml mm mn b">COPY</code>语法从本地计算机获取文件，并将其放入容器映像中</li><li id="10bc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">学习<code class="fe mk ml mm mn b">BASH</code>脚本并更新默认的<code class="fe mk ml mm mn b">ENTRYPOINT</code>,这样Bash脚本就可以执行新的软件，而不会退出脚本</li></ul><p id="3b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动容器后不会立即停止容器的Bash脚本示例:</p><pre class="kj kk kl km gt oe mn of og aw oh bi"><span id="1bac" class="ns mw it mn b gy oi oj l ok ol">#!/bin/bash<br/>echo “Hello-docker” &gt; /usr/hello.txt<br/>java -jar myprogram.jar<br/>/bin/bash</span></pre><p id="c880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行将启动<code class="fe mk ml mm mn b">/bin/bash</code>命令行，它总是在Linux容器启动时运行。这允许您的<code class="fe mk ml mm mn b">.jar</code>程序退出或崩溃，并且您仍然可以登录到容器来检查日志或进行故障排除。</p><p id="db5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在生产中，如果Java程序崩溃，您可能希望脚本退出，因此相应地更新您的脚本。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="5254" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated"><strong class="ak">“运行”与“命令”和“入口点”</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/0e10e68cfa965d1432f7fe608b20de2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AfemhOX9mxupRrJw.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://i.stack.imgur.com/gVtK9.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><ul class=""><li id="32df" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe mk ml mm mn b">RUN</code>在一个新的层中执行命令并创建一个新的映像——例如，它通常用于安装软件包</li><li id="dab0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe mk ml mm mn b">CMD</code>设置默认命令和/或参数，当Docker容器运行时，可以从命令行覆盖这些命令和/或参数</li><li id="949d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe mk ml mm mn b">ENTRYPOINT</code>配置作为可执行文件运行的容器</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="1c9b" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">用于不同应用的不同容器</h1><p id="ee65" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">使用容器的下一个逻辑步骤是需要保持关注点的分离。你不想把一堆不同的服务和程序都塞进一个容器里。拜托，永远不要这么做！</p><p id="aeca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本应用程序的一个非常常见的模式是需要一个web应用程序和一个数据库。这些应该在两个不同的容器中运行。</p><h2 id="efbe" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">输入Docker撰写</h2><p id="fcb3" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让多个容器一起启动的最简单的方法是使用Docker Compose。请将该文件视为您的运行时配置。是的，您正在更改一个文件来运行容器，但是您并没有在这里构建容器。</p><p id="254b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速回顾一下——我有一个应用程序，它有一个web组件和一个数据库组件。</p><ol class=""><li id="4ee6" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu on mc md me bi translated">我需要一个<code class="fe mk ml mm mn b">Dockerfile</code>来构建应用程序的web部分(安装中间件，复制应用程序代码，运行webserver)。</li><li id="45a4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu on mc md me bi translated">我还需要一个<code class="fe mk ml mm mn b">Dockerfile</code>来构建应用程序的数据库部分(安装数据库软件，运行SQL来构建模式，启动数据库)。</li><li id="c72c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu on mc md me bi translated">我需要一个一起启动两个容器的<code class="fe mk ml mm mn b">docker-compose</code>文件。</li><li id="191b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu on mc md me bi translated">我运行<code class="fe mk ml mm mn b">docker-compose up</code>来支持我的全栈应用程序。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/65ebaed4ebf986186031ee8da8b46610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/0*cZrLAweRqcLWy-l6"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker撰写文件示例</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="8545" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">那么Kubernetes呢？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c0afb26718e1718e4b6b9bccaf272e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Na9OlcU461SJiizI.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://kubernetes.io/images/blog/2018-06-05-11-ways-not-to-get-hacked/kubernetes-control-plane.png" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="a26d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes(或K8s)是生产就绪、高度可用的应用程序和演示环境之间的区别。我从来没有运行过一个<code class="fe mk ml mm mn b">docker-compose</code>命令和应用程序来作为我的生产环境和部署应用程序的手段。</p><p id="9e93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes提供了一个控制平面，本质上是作为您的自动化部署工程师。该控制平面的组件包括:</p><ul class=""><li id="a498" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe mk ml mm mn b">kube-apiserver</code>:API服务器是Kubernetes <a class="ae ky" href="https://kubernetes.io/docs/reference/glossary/?all=true#term-control-plane" rel="noopener ugc nofollow" target="_blank">控制平面</a>的一个组件，它公开了Kubernetes API。API服务器是Kubernetes控制平面的前端。</li><li id="ccd7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe mk ml mm mn b">etcd</code>:一致且高度可用的键值存储，用作Kubernetes所有集群数据的后备存储</li><li id="83b8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe mk ml mm mn b">kube-scheduler</code>:监视没有分配<a class="ae ky" href="https://kubernetes.io/docs/concepts/architecture/nodes/" rel="noopener ugc nofollow" target="_blank">节点</a>的新创建的<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" rel="noopener ugc nofollow" target="_blank">pod</a>——并选择一个节点供它们运行</li><li id="455a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe mk ml mm mn b">kube-controller-manager</code>:运行<a class="ae ky" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank">控制器</a>进程</li></ul><p id="c8f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑Kubernetes与Docker Compose的最简单方式是Docker Compose定义了我要运行的应用程序堆栈——仅此而已。Kubernetes定义了我的应用程序堆栈，并让控制平面监控我的容器，将它们部署到多个服务器，并在它们崩溃时保持运行。</p><p id="4467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes基本上是用类固醇合成的。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="98bc" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated"><strong class="ak">总结</strong></h1><ul class=""><li id="d539" class="lw lx it lb b lc nn lf no li oq lm or lq os lu mb mc md me bi translated">您应该始终学习和理解如何一次构建和运行一个容器</li><li id="b23c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">对于本地开发环境或概念验证，Docker Compose非常适合用来建立一堆容器</li><li id="a0d8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">要部署具有高可用性的生产就绪型应用程序，您需要一个可部署的Kubernetes基础架构——这将您的<code class="fe mk ml mm mn b">docker-compose</code>配置发挥到极致</li></ul><p id="565e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">享受容器带来的乐趣！</p></div></div>    
</body>
</html>