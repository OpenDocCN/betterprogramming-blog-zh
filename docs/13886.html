<html>
<head>
<title>My Top 7 Custom Extension Methods for .NET 7 and C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我最喜欢的7种自定义扩展方法。NET 7和C#</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/my-top-7-custom-extension-methods-for-net-7-and-c-494acb2e6634?source=collection_archive---------0-----------------------#2022-10-10">https://betterprogramming.pub/my-top-7-custom-extension-methods-for-net-7-and-c-494acb2e6634?source=collection_archive---------0-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这些基本的扩展方法提高你的流畅编码！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4ed3af2acacc4df945feeee70986260f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BJpI1gHOACnHKbo1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">瑞兰德·迪恩在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="f105" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="a8eb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">自从我开始了解扩展方法后，我不断发现新的可能性，让我的程序员生活变得更容易。扩展方法是O在固体中的完美应用— <a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原理</a>。一个类应该尽可能的简单，并且只在其他组件真正需要的时候才公开属性和方法。</p><p id="600e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过扩展方法，您可以为您的类实现额外的方法，而无需更改类本身！这非常适合将类作为参数的递归方法。</p><p id="1141" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实现扩展方法相当容易。看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a7ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这实现了每个<code class="fe mu mv mw mx b">IEnumerable&lt;T&gt;</code>(由<code class="fe mu mv mw mx b">this</code>关键字引入)的<code class="fe mu mv mw mx b">ForEach()</code>方法，就像你从<code class="fe mu mv mw mx b">List&lt;T&gt;</code>类型中知道的一样。要访问这个方法，您唯一需要做的就是添加一个对各自名称空间的引用，在本例中是<code class="fe mu mv mw mx b">System</code>。</p><h1 id="a50a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">我最常用的7种扩展方法</h1><p id="6a75" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">自从。NET 6，微软已经为<code class="fe mu mv mw mx b">IEnumerable&lt;T&gt;</code>实现了一些扩展方法，包括<code class="fe mu mv mw mx b">DistinctBy()</code>和<code class="fe mu mv mw mx b">Chunk()</code>。然而，截至。NET 7中，我仍然缺少一些非常重要的方法，尤其是处理任务集合的方法。</p><p id="5319" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">事不宜迟，下面是我在。网络7:</p><h1 id="75f9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.try异步</h1><p id="45e2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一种扩展方法是我最喜欢的。有多少次你在一个刚刚创建的方法周围添加了一个新的<code class="fe mu mv mw mx b">try-catch</code>块，并且因为它破坏了外观而变得有点恼火？当您的方法返回一个<code class="fe mu mv mw mx b">Task</code>或<code class="fe mu mv mw mx b">Task&lt;T&gt;</code>时，这里有一个非常简洁的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0100" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在你可以简单地写:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="9c4e" class="nc la it mx b gy nd ne l nf ng">var result = await GetSomethingAsync().TryAsync();</span></pre><p id="53a6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您的方法将自动包装在一个<code class="fe mu mv mw mx b">try-catch</code>块中。此外，您可以提供一个<code class="fe mu mv mw mx b">errorHandler</code>用于额外的辅助逻辑，如日志记录。然后可以检查这些方法返回的<code class="fe mu mv mw mx b">Result</code>是否成功，您可以继续您的逻辑。</p><p id="c001" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">顺便说一下，你可以在这些方法中找到的<code class="fe mu mv mw mx b">Result</code>或<code class="fe mu mv mw mx b">Result&lt;T&gt;</code>来自我以前的文章:</p><div class="nh ni gp gr nj nk"><a rel="noopener  ugc nofollow" target="_blank" href="/bring-error-handling-and-eliminate-nullreferenceexceptions-using-a-result-type-in-net-f4447dceb6c4"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">如何在中使用结果类型？网</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">使用此结果类型消除NullReferenceExceptions并提升您的错误处理能力</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">better编程. pub</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><h1 id="3fe9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.何时同步</h1><p id="9608" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在一个集合中有一个以上的<code class="fe mu mv mw mx b">Task</code>或<code class="fe mu mv mw mx b">Task&lt;T&gt;</code>在正常情况下有点不方便。你需要给<code class="fe mu mv mw mx b">Task.WhenAll(tasks)</code>打电话，这让我有点不知所云，因为这不是一种流畅的风格。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ba6f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我可以简单地收集任何任务，并简单地编写:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="cb50" class="nc la it mx b gy nd ne l nf ng">var results = await tasks.WhenAllAsync();</span></pre><h1 id="7068" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.WhenAllSequentialAsync</h1><p id="9feb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一个扩展方法甚至为您节省了几行代码，并使您能够一个接一个地执行每个任务。这在您可能不会并行执行许多任务的情况下可能很有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="472a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.WhenAllParallelAsync</h1><p id="d705" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后但同样重要的是，可能有一个用例，您可以并行执行任务，但可能有一个最大值的限制。平行工人。对于这种情况，我有以下扩展方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6c4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe mu mv mw mx b">degree</code>参数，您可以指定应该并行执行多少个任务。</p><h1 id="3711" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">5.MapAsync</h1><p id="4363" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个也是一个流畅的扩展，但是这次是针对单个的<code class="fe mu mv mw mx b">Task</code>或者<code class="fe mu mv mw mx b">Task&lt;T&gt;</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9dee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用这种扩展方法，您能够流畅地将一个<code class="fe mu mv mw mx b">Task&lt;T1&gt;</code>映射到一个类似于<code class="fe mu mv mw mx b">Enumerable.Select()</code>方法的<code class="fe mu mv mw mx b">Task&lt;T2&gt;</code>。</p><h1 id="4ad8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">6.DoAsync</h1><p id="6cfa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个类似的方法是<code class="fe mu mv mw mx b">DoAsync()</code>，但是不是转换一个任务，你可以用<code class="fe mu mv mw mx b">tasks</code>结果执行边逻辑而不改变它的返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="aa99" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">7.字符串。加入</h1><p id="bb38" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后一个是扩展方法，我有时用它来连接日志记录的字符串。通常情况下，您可以使用<code class="fe mu mv mw mx b">string.Join()</code>来实现这一点，但是同样，这并不流畅，会使我脱离流程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="5360" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">缩写</h1><p id="4304" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从技术上来说不是扩展方法，但对保存一些代码也很有用，下面是我的缩写方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b184" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了方便地使用它们，您必须在您的根级别上创建一个特殊的文件(我通常称之为<code class="fe mu mv mw mx b">GlobalUsings.cs</code>)，并在其中放入下面一行:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="78c8" class="nc la it mx b gy nd ne l nf ng">global using static System.Abbreviations;</span></pre><h1 id="5f42" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.arrive）</h1><p id="fdbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mu mv mw mx b">Arr</code>方法是从已经存在的值创建新的<code class="fe mu mv mw mx b">IEnumerable&lt;T&gt;</code>的缩写。通常，这需要一个非常难看的代码，如下所示:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="eae1" class="nc la it mx b gy nd ne l nf ng">var arr = new [] { param1, param2,... };</span></pre><p id="be83" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在你可以简单地这样写:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e772" class="nc la it mx b gy nd ne l nf ng">var arr = Arr(param1, param2,... );</span></pre><p id="dcc7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这样看起来更漂亮，而且你不用用手指在键盘上玩杂技。</p><h1 id="5ead" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.尝试</h1><p id="e7ee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你是否经常想在一个新方法周围添加一个简单的<code class="fe mu mv mw mx b">try-catch</code>块，但感觉很难看，因为它在你的代码中占据了太多的空间？下面用缩写法<code class="fe mu mv mw mx b">Try()</code>来解一下。</p><p id="3791" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">用最简短的形式，你可以写:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5aa7" class="nc la it mx b gy nd ne l nf ng">Try(TestMethod);</span></pre><p id="8955" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其中<code class="fe mu mv mw mx b">TestMethod</code>是一个不带任何参数的方法。这使您能够编写非常短的代码，并消除那些讨厌的<code class="fe mu mv mw mx b">try-catch</code>块。</p><p id="55d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于异步方法，我推荐你使用上面的扩展方法<code class="fe mu mv mw mx b">TryAsync</code>，因为它是流畅风格的。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="aacd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，还有更多的可能性，您可以使用这种模式并创建自己的缩写和扩展方法。让我知道你对评论的看法。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">祝你有美好的一天！</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="oh">加入中现</em> </a></p><p id="86e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>