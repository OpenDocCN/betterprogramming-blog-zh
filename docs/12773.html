<html>
<head>
<title>Understanding MySQL’s “Binlog”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解MySQL的“Binlog”</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-mysqls-binlog-4ac8de4d20ee?source=collection_archive---------1-----------------------#2022-06-30">https://betterprogramming.pub/understanding-mysqls-binlog-4ac8de4d20ee?source=collection_archive---------1-----------------------#2022-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d2da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Binlog的机制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bdd7b669a16abf695578186c60e6aa38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WVWJI5y0RpuOOmoT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">萨曼塔·加迪斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="af2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文深入讲解了MySQL中重要日志<code class="fe lv lw lx ly b">binlog</code>的写入机制和影响IO性能的关键配置，并介绍了如何使用<code class="fe lv lw lx ly b">binlog</code>恢复数据。</p><h1 id="6627" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">如何写Binlog？</h1><p id="4443" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">binlog</code>的写作逻辑并不复杂。在事务执行期间，日志首先被写入<code class="fe lv lw lx ly b">binlog</code>缓存，当事务被提交时，<code class="fe lv lw lx ly b">binlog</code>缓存被写入<code class="fe lv lw lx ly b">binlog</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/23b8f038b41a97033e064799595ebedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*sCd3LCX9DKtjwOKZlxk26g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><h2 id="90bf" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated"><strong class="ak"> <em class="nj"> Binlog缓存</em> </strong></h2><p id="e262" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">binlog cache</code>在事务执行期间临时存储<code class="fe lv lw lx ly b">binlog</code>数据，而<code class="fe lv lw lx ly b">binlog cache</code>在每个线程内是空间独立的。</p><p id="75c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果启用了<code class="fe lv lw lx ly b">binlog</code>日志记录，MySQL会为每个客户端分配一个二进制日志缓存。</p><p id="1fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您经常使用大型事务，可以增加缓存大小以获得更好的性能。其大小可以通过<code class="fe lv lw lx ly b">binlog_cache_size</code>配置，默认为<code class="fe lv lw lx ly b">32768 bytes</code>。</p><p id="d63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该参数的主要作用是控制单线程中<code class="fe lv lw lx ly b">binlog</code>缓存占用的内存大小。</p><p id="c336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">binlog cache</code>空间足够，当提交事务时，缓存中的内容将被清空，数据将被写入<code class="fe lv lw lx ly b">binlog</code>文件。</p><p id="2542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe lv lw lx ly b">binlog</code>内容需要在事务提交的时候一次性写入，所以不管有多大，当bin日志缓存放不下的时候，需要临时存储在磁盘上，然后提交写入<code class="fe lv lw lx ly b">binlog</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a61aeefacd81a7d0deddecc54304ae3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbFV4IP3a6XZOQu3LuMPqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="ab4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述文字<code class="fe lv lw lx ly b">binlog</code>实际上分为两部分:</p><ul class=""><li id="cce9" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">写入:首先，它将被写入页面缓存中的<code class="fe lv lw lx ly b">binlog</code>文件，页面缓存是一块不占用磁盘IOPS的内存。</li><li id="9456" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">Fsync:那么bin日志实际上是在操作系统执行<code class="fe lv lw lx ly b">fsync</code>的时候从页面缓存持久化到磁盘；它占据了IOPS磁盘。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cefc3af41542c463b150bdf101f32ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POccCXoOUIHysSx1WHenng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><h2 id="d108" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated"><strong class="ak"> <em class="nj">什么时候到</em></strong><code class="fe lv lw lx ly b"><strong class="ak"><em class="nj">write</em></strong></code><strong class="ak"><em class="nj"/></strong><code class="fe lv lw lx ly b"><strong class="ak"><em class="nj">fsync</em></strong></code><strong class="ak"><em class="nj">？</em> </strong></h2><p id="82e8" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">write</code>和<code class="fe lv lw lx ly b">fsync</code>的定时由参数<code class="fe lv lw lx ly b">sync_binlog</code>控制:</p><p id="dd2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sync_binlog=0</code>:表示每个提交事务只写不执行<code class="fe lv lw lx ly b">fsync</code>，即<code class="fe lv lw lx ly b">binlog</code>不持久(不推荐)。</p><p id="e51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sync_binlog=1</code>:表示每次提交事务时都会发生<code class="fe lv lw lx ly b">fsync</code>。</p><p id="d0be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sync_binlog=N</code>:表示每个事务都将写入，但<code class="fe lv lw lx ly b">N</code>事务提交将执行<code class="fe lv lw lx ly b">fsync</code>以获得持久性。</p><p id="b45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，为了增加IOPS，该参数设置为100–1000。缺点是如果机器在执行<code class="fe lv lw lx ly b">fsync</code>之前崩溃，最多会丢失最近<code class="fe lv lw lx ly b">N</code>事务的<code class="fe lv lw lx ly b">binlog</code>日志。为了数据安全，设置为<code class="fe lv lw lx ly b">1</code>。</p><p id="9795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">官方文档对其描述如下:</p><blockquote class="oa ob oc"><p id="9b1c" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated"><em class="it">"默认情况下，二进制日志在每次写入时同步到磁盘(</em> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_sync_binlog" rel="noopener ugc nofollow" target="_blank"><em class="it">sync_binlog=1</em></a></code> <em class="it">)。如果</em> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_sync_binlog" rel="noopener ugc nofollow" target="_blank"><em class="it">sync_binlog</em></a></code> <em class="it">未启用，并且操作系统或机器(不仅仅是MySQL服务器)崩溃，二进制日志的最后语句有可能丢失。</em></p><p id="1a4f" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated"><em class="it">为了防止这种情况，在每次</em> <code class="fe lv lw lx ly b"><em class="it">N</em></code> <em class="it">提交组后，启用</em> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_sync_binlog" rel="noopener ugc nofollow" target="_blank"><em class="it">sync_binlog</em></a></code> <em class="it">系统变量将二进制日志同步到磁盘。参见</em> <a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html" rel="noopener ugc nofollow" target="_blank"> <em class="it">章节5.1.8，“服务器系统变量”</em> </a> <em class="it">。</em> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_sync_binlog" rel="noopener ugc nofollow" target="_blank"><em class="it">sync_binlog</em></a></code> <em class="it">最安全的值是1(默认值)，但这也是最慢的。”</em></p></blockquote><h2 id="9fa6" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated"><strong class="ak"><em class="nj"/></strong><code class="fe lv lw lx ly b"><strong class="ak"><em class="nj">binlog</em></strong></code><strong class="ak"><em class="nj">内容缺失怎么办？</em> </strong></h2><p id="6176" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们已经知道可以通过<code class="fe lv lw lx ly b">redo log</code>恢复数据，但是如果<code class="fe lv lw lx ly b">binlog</code>内容丢失了怎么办？</p><p id="26e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<code class="fe lv lw lx ly b">sync_binlog</code>参数的描述，如果设置为大于1，则意味着<code class="fe lv lw lx ly b">N</code>事务将持久保存在磁盘的日志中。</p><p id="2938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，<code class="fe lv lw lx ly b">redo log</code>的<code class="fe lv lw lx ly b">innodb_flush_log_at_trx_commit</code>参数被设置为<code class="fe lv lw lx ly b">1</code>，这意味着对于每一个提交的事务都将执行<code class="fe lv lw lx ly b">fsync</code>。</p><p id="d7f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就造成了一种可能，如果MySQL服务器崩溃了，此时<code class="fe lv lw lx ly b">redo log</code>已经持久化，但是<code class="fe lv lw lx ly b">binlog</code>和事务仍然存储在页面缓存中，没有时间执行<code class="fe lv lw lx ly b">fsync</code>。</p><p id="fd2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">停机后重启服务，依靠<code class="fe lv lw lx ly b">redo log</code>恢复数据，<code class="fe lv lw lx ly b">binlog</code>长度会比实际需要的数据要短。</p><p id="51ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面对数据完整却缺失的<code class="fe lv lw lx ly b">binlog</code>，这种情况下会发生什么？起初，我很困惑。终于在MySQL 5.7的官方文档中找到了答案。</p><p id="8040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">官方文档对其描述如下:</p><blockquote class="oa ob oc"><p id="79ce" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated"><em class="it">“如果MySQL服务器在崩溃恢复时发现二进制日志比预期的要短，那么它至少缺少一个成功提交的</em> <code class="fe lv lw lx ly b"><em class="it">InnoDB</em></code> <em class="it">事务。如果</em> <code class="fe lv lw lx ly b"><em class="it">sync_binlog=1</em></code> <em class="it">和磁盘/文件系统在被请求时进行了实际的同步(有些没有)，这种情况就不会发生，所以服务器会打印一条错误消息</em> <code class="fe lv lw lx ly b"><em class="it">The binary log *</em></code> <em class="it">文件名</em> <code class="fe lv lw lx ly b"><em class="it">* is shorter than its expected size</em></code> <em class="it">。</em></p><p id="e7c6" class="kz la od lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated"><em class="it">在这种情况下，此二进制日志不正确，应该从源数据的新快照重新开始复制。”</em></p></blockquote><p id="bcd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据官方描述，如果<code class="fe lv lw lx ly b">sync_binlog</code>设置为<code class="fe lv lw lx ly b">1</code>，就不会出现这种情况。如果<code class="fe lv lw lx ly b">binlog</code>比预期的少，服务器上会打印出<code class="fe lv lw lx ly b">binlog</code>日志的异常日志:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="ead4" class="mx ma it ly b gy ol om l on oo">The binary log xxx is shorter than its expected size.</span></pre><p id="6384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这种情况需要人工干预，并从最新的快照数据源进行重新复制。</p><h2 id="5f69" class="mx ma it bd mb my mz dn mf na nb dp mj li nc nd ml lm ne nf mn lq ng nh mp ni bi translated"><strong class="ak"> <em class="nj">如何使用Bin Log恢复历史数据？</em> </strong></h2><p id="850b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">binlog</code>会记录所有的逻辑操作，以“追加写入”的形式，不会像<code class="fe lv lw lx ly b">redo log</code>一样覆盖日志文件。</p><p id="e4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">binlog</code>中的数据是可靠的，必须是事务提交后的数据，这是由重做日志两阶段提交保证的。</p><p id="6409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，我们可以通过<code class="fe lv lw lx ly b">bin log</code>恢复任意时间点的数据，如何做到呢？</p><p id="a94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其实这是前提条件。我们必须有一个定期备份全部数据的机制，比如半个月，每周，或者每天。</p><p id="45ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设场景:比如今天中午误删了表数据，需要检索数据。我该怎么办？</p><ul class=""><li id="d3ea" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">首先，找到最近的完整备份，比如昨天凌晨1:00，然后将该备份恢复到临时数据库。</li><li id="6ff2" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">然后，从昨天上午<code class="fe lv lw lx ly b">1:00</code>的备份时间开始，依次取出备份<code class="fe lv lw lx ly b">binlog</code>并重放，直到今天中午<code class="fe lv lw lx ly b">12:00</code>的数据。</li></ul><p id="4b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，临时数据库就达到了数据被意外删除之前的状态，然后就可以根据需要将表数据从临时数据库中取出，恢复到联机正式数据库中。</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><p id="ea37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="od">感谢您阅读这篇文章。</em></p></div></div>    
</body>
</html>