<html>
<head>
<title>Solidity 0.6.x Features: Fallback and Receive Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity 0.6.x特性:回退和接收功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-0-6-x-features-fallback-and-receive-functions-69895e3ffe?source=collection_archive---------7-----------------------#2020-04-15">https://betterprogramming.pub/solidity-0-6-x-features-fallback-and-receive-functions-69895e3ffe?source=collection_archive---------7-----------------------#2020-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d0b7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索Solidity 0.6.x的两个关键特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4d6f56bf72015f7b6825c37e5183fc4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kvW32ZBLNhwokey4Nbk8w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@bdchu614?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae kv" href="https://unsplash.com/s/photos/cross-road?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="e35c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在0.6.x之前的Solidity版本中，开发人员通常使用<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.5.15/contracts.html#fallback-function" rel="noopener ugc nofollow" target="_blank">回退函数</a>来处理两种情况下的逻辑:</p><ul class=""><li id="e3a3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">合同收到以太网，没有数据。</li><li id="00ac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">约定收到了数据，但没有与调用的函数匹配的函数。</li></ul><p id="c535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">0.6.x之前的回退函数的主要用例是接收以太网并对其做出反应，这是令牌式契约用于拒绝传输、发出事件或转发以太网的典型模式。当在没有任何数据的情况下调用合同时，该函数执行(例如，通过<code class="fe mg mh mi mj b">.send()</code>或<code class="fe mg mh mi mj b">.transfer()</code>函数)。0.5.x的语法是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="83e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个用例因实现可升级契约的“委托代理”模式而变得流行。它有一个简单的代理契约，只声明一个后备函数。当协定中没有函数与调用数据中的函数标识符匹配时，调用回退函数。这允许“委托代理”模式，在该模式中，功能在被调用的契约之外实现。以下是实施的一个示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用合同使用汇编代码，我们不会在这里深入讨论，但是你可以在<a class="ae kv" href="https://docs.openzeppelin.com/upgrades/2.6/proxies" rel="noopener ugc nofollow" target="_blank"> Zeppelin的文档</a>中读到更多。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="55c5" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">分割回退功能</h1><p id="b230" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我们意识到这个函数的双重目的让开发人员感到困惑，这可能会导致潜在的安全问题。例如，开发人员通常实现一个回退函数，只希望以太网传输调用它，但当契约中缺少某个函数时，也会调用它。令人困惑的是，由于这是预期行为，因此没有报告任何错误。下面是这种令人困惑的行为的一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="95b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用慈善合同地址调用<code class="fe mg mh mi mj b">CharitySplitter.donate()</code>时，它的<code class="fe mg mh mi mj b">processDonation</code>函数被正确调用，按预期处理捐赠。然而，如果错误地传递了<code class="fe mg mh mi mj b">Receiver</code>契约地址，那么它的回退函数将被调用，并接收发送的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b130" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为EVM是无类型的，所以Solidity不能从它的地址检查合同的实际类型，只能依赖用户提供的内容。函数签名也不能提供防止类型混淆的完美解决方案，但在许多情况下可以工作。</p><p id="a893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是0.6x版中回退功能被分成两个独立功能的原因:</p><ul class=""><li id="ee23" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b"><a class="ae kv" href="https://solidity.readthedocs.io/en/latest/contracts.html#receive-ether-function" rel="noopener ugc nofollow" target="_blank">receive()</a> external payable</code> —用于空呼叫数据(和任何值)</li><li id="83c2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b"><a class="ae kv" href="https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function" rel="noopener ugc nofollow" target="_blank">fallback()</a> external payable</code> —没有其他函数匹配时(甚至没有<code class="fe mg mh mi mj b">receive</code>函数)。可选<code class="fe mg mh mi mj b">payable</code>。</li></ul><p id="83ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种分离为希望接收普通以太网的合同提供了备用功能。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="861f" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">接收()</h1><p id="d501" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">一个契约现在只能有一个用语法<code class="fe mg mh mi mj b">receive() external payable {…}</code>(没有<code class="fe mg mh mi mj b">function</code>关键字)声明的<code class="fe mg mh mi mj b">receive</code>函数。</p><p id="3f6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它执行对没有数据的契约的调用(<code class="fe mg mh mi mj b">calldata</code>)，比如通过<code class="fe mg mh mi mj b">send()</code>或<code class="fe mg mh mi mj b">transfer()</code>进行的调用。</p><p id="7f4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数不能有参数，不能返回任何东西，并且必须有<code class="fe mg mh mi mj b">external</code>可见性和<code class="fe mg mh mi mj b">payable</code>状态可变性。要在0.6.0下复制上述示例，请使用以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="319e" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">回退()</h1><p id="33e5" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">fallback函数现在有一个不同的语法，使用<code class="fe mg mh mi mj b">fallback() external [payable] {…}</code>声明(没有<code class="fe mg mh mi mj b">function</code>关键字)。该函数不能有参数，不能返回任何内容，并且必须具有<code class="fe mg mh mi mj b">external</code>可见性。fallback函数总是接收数据，但是为了也接收Ether，您应该将其标记为<code class="fe mg mh mi mj b">payable</code>。要在0.6.0下复制上述示例，请使用以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="2fbf" class="mt mu iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">迁移和固定样本合同</h1><p id="cbbb" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">因此，我们将有问题的契约转换为v0.6.x，让它声明一个<code class="fe mg mh mi mj b">receive()</code>函数，该函数只接受没有数据的传入以太网，并避免导致上述价值损失的类型混淆。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="042d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用<code class="fe mg mh mi mj b">Receiver</code>合同地址的调用失败时，对固定合同的调用将恢复:</p><pre class="kg kh ki kj gt nq mj nr ns aw nt bi"><span id="15df" class="nu mu iq mj b gy nv nw l nx ny">// The following call now reverts<br/>await charitySplitter.donate(badCharity, { value: 10 });</span></pre><p id="c027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望您发现回退功能的逻辑划分对您的设计来说更加清晰，并欢迎您对新语法的任何反馈。</p></div></div>    
</body>
</html>