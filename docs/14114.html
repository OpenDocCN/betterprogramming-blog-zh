<html>
<head>
<title>Five Data-Loading Patterns To Improve Web Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Web性能的五种数据加载模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/five-data-loading-patterns-to-improve-web-performance-57d4f288ef13?source=collection_archive---------4-----------------------#2022-11-08">https://betterprogramming.pub/five-data-loading-patterns-to-improve-web-performance-57d4f288ef13?source=collection_archive---------4-----------------------#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3215" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">前端数据加载模式介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/917d16425658ffdcf5c684cdfc725b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKDiWdjNWzsxwhDa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</p></figure><p id="a5cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不需要为每件事都使用一个框架，但是如果你使用一个框架，这篇文章将帮助你以最有效的方式使用它。</p><p id="8166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说到性能，你不应该吝啬。有数以百万计的网站，你在和每一个谷歌搜索结果进行激烈的竞争。研究表明，用户<a class="ae kv" href="https://www.marketingdive.com/news/google-53-of-mobile-users-abandon-sites-that-take-over-3-seconds-to-load/426070/" rel="noopener ugc nofollow" target="_blank">会放弃加载时间超过三秒的网站</a>。三秒钟是很短的时间。虽然现在许多网站的加载时间不到一秒钟，但是没有一个放之四海而皆准的解决方案，第一个请求可能是你的应用程序成败的关键。</p><p id="be01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现代前端应用程序越来越大。难怪业界越来越关注优化。框架为应用程序创建了不合理的构建规模，这可能决定应用程序的成败。您打包和提供的每一点不必要的JavaScript代码都会增加客户端需要加载和处理的代码。经验法则是越少越好。</p><p id="74d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据加载模式是应用程序的重要组成部分，因为它们将决定访问者可以直接使用哪些部分。不要因为他们在应用程序的主页上下载了一个5MB的图像，就让他们的整个网站变慢，并且更好地理解这个问题。您需要了解资源加载瀑布。</p><h1 id="cab5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">加载Spinner Hell和数据瀑布</h1><p id="d6d0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">资源加载瀑布是从网络服务器下载到客户端的文件的级联，从头到尾加载你的网站。它本质上描述了从网络上下载并加载页面的每个文件的生命周期。</p><p id="0409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过打开浏览器查看网络选项卡来了解这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/ed0d99a1b36a6d921cb1e15636b20d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fjbnYG39YC5_gJdHX8kfg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中等主页。作者图片</p></figure><p id="5cc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在那里看到了什么？您应该看到两个基本组件:</p><ol class=""><li id="6e15" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">该图表显示了请求和加载的每个文件的时间表。您可以查看哪些文件先加载，并跟踪每个连续的请求，直到某个文件需要很长时间才能加载。您可以检查它，看看是否可以优化它。</li><li id="b0ca" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">在页面底部，您可以检查您的客户端消耗了多少kB的资源。注意客户端需要下载多少数据是很重要的。第一次尝试时，您可以将其用作以后优化的基准。</li></ol><p id="db61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有人喜欢空白的白屏，尤其是你的用户。滞后的资源加载瀑布需要一个基本的占位符，然后才能开始在客户端构建布局。通常，您会使用旋转器或骨骼加载器。随着数据一个接一个地加载，页面将显示一个加载器，直到所有组件都准备好。</p><p id="2ff2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然添加加载器作为占位符是一种改进，但是让它持续太久会导致“旋转地狱”本质上，你的应用程序在加载时停滞不前，虽然它比一个空白的HTML页面好，但它可能会变得令人讨厌，访问者会选择退出你的网站。</p><p id="3d0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等待数据不是重点吗？</p><p id="127e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，但是你可以装得更快。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/f1b904bba1b2b09d1a4c3cef2ef99660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrQc_oizCSEUpmfgcgyC3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="8b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您想要加载一个社交媒体布局，您可以添加一个加载微调器或一个骨架加载器来确保您不会加载一个不完整的站点。骨架加载程序通常会等待以下情况:</p><ul class=""><li id="4b9f" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr nf mw mx my bi translated">来自后端API的数据</li><li id="00db" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated">根据数据构建布局</li></ul><p id="91cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您对API进行异步调用，然后获取CDN上资产的URL。只有这样，您才能开始在客户端构建布局。第一次尝试展示你的脸、名字、状态和Instagram帖子需要做很多工作。</p><h1 id="1bc9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">您需要知道的五种数据加载模式</h1><p id="67a3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">随着React、Vue或Angular等框架成为创建最简单应用程序的首选解决方案，开发软件变得越来越容易。但是使用这些庞大的框架，其中充满了大量你甚至不使用的神奇功能，这不是你应该去做的。</p><p id="45c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是来优化的。记住，越少越好。</p><p id="7d63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果不能少做呢？那么，你将如何提供速度惊人的代码呢？很好，你将要学习五种数据加载模式，你可以用它们来让你的站点快速加载，或者像你说的那样，快得惊人。</p><h1 id="a562" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">服务器端渲染和Jamstack</h1><p id="5db8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现代JavaScript框架经常使用客户端渲染(CSR)来渲染网页。浏览器<a class="ae kv" href="https://web.dev/rendering-on-the-web/" rel="noopener ugc nofollow" target="_blank">在一个有效负载中接收一个JavaScript包</a>和静态HTML，然后它将呈现DOM并添加监听器和事件触发器以实现反应性。当一个CSR应用程序在DOM中呈现时，<a class="ae kv" href="https://web.dev/rendering-on-the-web/" rel="noopener ugc nofollow" target="_blank">页面将被阻塞</a>，直到所有组件都被成功呈现。渲染使应用程序具有反应性。要运行它，您必须对服务器进行另一个API调用，并检索您想要加载的任何数据。</p><p id="8b9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器端呈现(SSR)是指应用程序向客户端提供普通的HTML。SSR分为两种:有水合作用的SSR和没有水合作用的SSR。SSR是老框架使用的老技术，比如WordPress、Ruby on Rails和ASP.NET。SSR的主要目标是给用户一个静态HTML，其中包含先决条件数据。与CSR不同，SSR不需要对后端进行另一个API调用，因为服务器会生成一个HTML模板并加载任何数据。</p><p id="76ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像Next.js这样的新解决方案使用了hydration，其中静态HTML将在客户端使用JavaScript进行水合。把它想象成速溶咖啡:咖啡粉是HTML，水是JavaScript。将速溶咖啡粉和水混合会发生什么？你得到了——等着瞧——咖啡。</p><p id="0e57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是什么是Jamstack呢？Jamstack类似于SSR，因为客户端检索的是普通的HTML。但是在SSR期间，客户机从服务器检索HTML。然而，Jamstack应用程序直接从CDN提供预先生成的HTML。正因为如此，Jamstack应用程序通常加载更快，但开发者更难制作动态内容。Jamstack应用程序适合为客户端预先生成HTML。但是，当您在客户端使用大量JavaScript时，与客户端呈现(CSR)相比，使用Jamstack变得越来越不合理。</p><p id="c3b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SSR和Jamstack各有不同。它们的共同之处在于，它们不会让客户机负担使用JavaScript从头开始呈现整个页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/12896c75090c0a8a27a2799b35db00e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*59mZRlCN4znYKblk.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jamstack vs. SSR vs. CSR。作者图片</p></figure><p id="078d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你优化你的站点的SEO时，推荐使用SSR和Jamstack，因为与CSR相比，两者都返回搜索机器人可以轻易遍历的HTML文件。但是搜索机器人仍然可以遍历和编译CSR的JavaScript文件。然而，在CSR应用程序中渲染每个JavaScript文件可能很耗时，并且会降低站点的SEO效率。</p><p id="efcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SSR和Jamstack非常受欢迎，与它们的普通CSR同行React和Vue相比，更多的项目正在转向像Next.js和Nuxt.js这样的SSR框架，主要是因为SSR框架在SEO方面提供了更好的灵活性。Next.js有<a class="ae kv" href="https://nextjs.org/learn/seo/introduction-to-seo" rel="noopener ugc nofollow" target="_blank">一整节谈论他们框架上的SEO </a>优化。</p><p id="bc4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SSR应用程序通常会有模板引擎，当提供给客户端时，这些引擎会将变量注入到HTML中。例如，在Next.js中，您可以加载一个学生列表:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="7150" class="nn lt iq nj b gy no np l nq nr">export default function Home({ studentList }) {<br/>  return (<br/>    &lt;Layout home&gt;<br/>        &lt;ul&gt;<br/>          {studentList.map(({ id, name, age }) =&gt; (<br/>            &lt;li key={id}&gt;<br/>              {name}<br/>              &lt;br /&gt;<br/>              {age}<br/>            &lt;/li&gt;<br/>          ))}<br/>        &lt;/ul&gt;<br/>    &lt;/Layout&gt;<br/>  );<br/>}</span></pre><p id="fb9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Jamstack在文档网站中很受欢迎，这些网站通常将代码编译成HTML文件并将其托管在CDN上。Jamstack文件通常在编译成HTML之前使用Markdown，例如:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="d814" class="nn lt iq nj b gy no np l nq nr">---<br/>author: Agustinus Theodorus<br/>title: 'Title'<br/>description: Description<br/>---<br/>Hello World</span></pre><h1 id="707d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">主动内存缓存</h1><p id="fe3d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当您想要快速获取已经拥有的数据时，您需要进行缓存—缓存存储用户最近检索到的数据。可以通过两种方式实现缓存:使用Redis这样的超快速键-值存储来保存数据键和值，以及使用简单的浏览器缓存来本地存储数据。</p><p id="1f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缓存部分存储您的数据，而不是用作永久存储。将缓存用作永久存储是一种反模式。强烈建议生产应用程序使用缓存；随着新应用的逐渐成熟，它们将开始使用缓存。</p><p id="55ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是什么时候应该在Redis缓存(服务器缓存)和浏览器缓存(本地缓存)之间做出选择呢？两者都可以同时使用，但最终将服务于不同的目的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/f4d1ad6c2cec7f81c794d5eed8392f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*07jtyVngyoTGghqmsSwIRg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">缓存方案。作者图片</p></figure><p id="ee22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器缓存有助于降低前端和后端之间的延迟。由于键值数据库比传统的关系SQL数据库更快，这将显著增加API的响应时间。然而，本地缓存有助于改善应用程序状态管理，使应用程序能够在页面刷新后保持状态，并有助于未来的访问。</p><p id="62d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，如果你想提高你的应用程序的性能，你可以使用服务器缓存来加速你的API，但是如果你想保持你的应用程序状态，你应该使用本地存储缓存。虽然本地缓存可能看起来一点帮助都没有，但是它确实有助于通过持久化不经常改变的状态来减少对后端的API调用的数量。然而，当与实时数据结合时，本地缓存会更好。</p><h1 id="7058" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据事件来源</h1><p id="377d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可以通过WebSockets在前端和后端之间建立实时连接。WebSockets是一种依赖于事件的双向通信机制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/cfa9a0b5b2636f7cc020839be619acde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*QURopQ70BPkc0Q-AGRGryw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通用Websocket架构。作者图片</p></figure><p id="2565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在常见的WebSocket架构中，前端应用程序将连接到WebSocket API、事件总线或数据库。大多数WebSocket架构利用它作为REST的替代品，尤其是在像聊天应用程序这样的用例中；每隔几秒钟轮询一次后端服务会变得低效。WebSockets允许您从另一端接收更新，而无需通过双向连接创建新的请求。</p><p id="7600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与普通的HTTP请求相比，WebSockets建立了一个微小的、保持活动的连接。将WebSockets与本地浏览器缓存结合起来创建了一个实时应用程序。您可以根据从WebSocket接收的事件更新应用程序的状态。然而，<a class="ae kv" href="https://blog.bitsrc.io/event-sourcing-pattern-for-real-time-frontends-42359e6dd957" rel="noopener ugc nofollow" target="_blank">存在一些关于性能、可伸缩性和潜在数据冲突的警告</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/d3d47ea996eb782fd5733fadc43b3642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s43RNhpgXQoSkqvoiC2Ftg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">事件源架构。作者图片</p></figure><p id="543f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个纯WebSocket实现还是有很多缺点的。使用WebSockets而不是常规的HTTP调用会改变整个应用程序的行为方式。仅仅一个轻微的连接问题就能影响你的整体UX。例如，当WebSocket需要在每次有get请求时查询数据库时，它就不能具有实时性能。后端存在瓶颈，需要优化以获得更好的实时结果，从而使WebSockets变得可行，成为更合理的答案。</p><p id="6e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要有一个底层的架构模式来支持它。<a class="ae kv" href="https://blog.bitsrc.io/event-sourcing-pattern-for-real-time-frontends-42359e6dd957" rel="noopener ugc nofollow" target="_blank">事件源是一种流行的数据模式</a>您可以用它来创建可靠的实时应用程序。虽然它不能保证应用程序的整体性能，但通过拥有实时用户界面，它将为您的客户提供更好的UX。</p><p id="ec66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现代JavaScript有WebSocket提供者，您可以使用。<code class="fe nv nw nx nj b">WebSocket</code>类打开到远程服务器的连接，并使您能够在WebSocket打开连接、关闭连接、返回错误或返回事件时进行监听。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="36bb" class="nn lt iq nj b gy no np l nq nr">const ws = new WebSocket('ws://localhost');</span><span id="b633" class="nn lt iq nj b gy ny np l nq nr">ws.addEventListener('message',<!-- --> (event) =&gt; {<br/>    console.log('Message from server ', event.data);<br/>});</span></pre><p id="80a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您想对服务器事件做出反应吗？添加一个<code class="fe nv nw nx nj b">addEventListener</code>函数并插入一个它将使用的回调函数。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="b631" class="nn lt iq nj b gy no np l nq nr">ws.send('Hello World');</span></pre><p id="b123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想传递信息吗？WebSockets抓住了你。使用<code class="fe nv nw nx nj b">send</code>函数向服务器发送消息。这就像打印“你好，世界”一样简单这些示例来自<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket?retiredLocale=id" rel="noopener ugc nofollow" target="_blank">MDN文档</a>。</p><h1 id="69fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">预取和延迟加载</h1><p id="5c63" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">预取和延迟加载已经成为前端开发人员的常识。有效利用客户机的资源和带宽可以大大提高应用程序的性能。</p><h2 id="2461" class="nn lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">预取</h2><p id="d06a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">预取使开发人员能够更精确地控制客户端的空闲带宽、加载资源以及客户端接下来可能需要的页面。当一个网站有一个预取链接时，浏览器会<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ" rel="noopener ugc nofollow" target="_blank">悄悄地下载</a>内容并将其存储在其缓存中。当用户点击预取链接时，它们的加载速度会明显加快。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="6e50" class="nn lt iq nj b gy no np l nq nr">&lt;link rel="prefetch" href="https://example.com/example.html"&gt;</span></pre><p id="5a46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您在<code class="fe nv nw nx nj b">link</code> HTML元素中指定预取URL，更具体地说，是在<code class="fe nv nw nx nj b">rel</code>属性中。预取有一些优点和缺点:</p><ol class=""><li id="5060" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">优点:预取会等到浏览器的网络空闲并且不再被使用，并且当您通过单击链接或触发延迟加载功能来触发使用时会停止。</li><li id="045e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">优点:预取在浏览器中缓存数据，当重定向到一个链接时，使页面转换更快。</li><li id="3892" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">缺点:它可以用来下载追踪器，危及用户隐私。</li></ol><h2 id="6e39" class="nn lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">惰性装载</h2><p id="c8dd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">惰性加载是一种常见的数据加载模式，它让客户端按菜单加载结果，直到客户端需要时才加载所有内容。延迟加载将使客户端在滚动到视图中后获取网站的后面部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/ae8cdc6a696c4cc83b49b59717b168e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IhhRARLvIK7GFVx7OEFMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">懒加载。作者图片</p></figure><p id="15fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">延迟加载通过让浏览器专注于更重要的屏幕资源，使你的网站加载更快。当你看不到的时候，你不需要在一个给定的网站上加载所有的图片/文本。但是延迟加载只能帮助你延迟下载资源，并不能让你的资源变得更小更划算。</p><p id="5b85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果你正在寻找一个类似于延迟加载的更具成本效益的解决方案，尝试寻找可恢复性。</p><h1 id="d60c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可再生性</h1><p id="f48e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">许多开发者以前从未听说过可再生性的概念。可恢复性<a class="ae kv" href="https://github.com/BuilderIO/qwik/blob/main/packages/docs/src/routes/docs/concepts/resumable/index.mdx#introducing-resumability" rel="noopener ugc nofollow" target="_blank">在服务器</a>中部分呈现JavaScript，呈现的最终状态将被序列化，并与相应的HTML有效负载一起发送到客户端。然后客户端将完成渲染，节省客户端的时间和资源。本质上，可恢复性使用服务器来完成繁重的工作，然后通过序列化给客户端最少的JavaScript来执行。</p><p id="e363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可重用性的主要思想是将应用程序状态从服务器序列化到客户端。Resumability不是在前端加载所有内容(HTML、JS)并进行水化，而是分阶段序列化JavaScript解析，并以HTML格式发送给客户端。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/dcb7570008834f815d9a5046269e7784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CEbvAUK7xDx37Gg_P6fhA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可恢复性与水合作用。图片来自<a class="ae kv" href="https://github.com/BuilderIO/qwik/blob/main/packages/docs/src/routes/docs/concepts/resumable/index.mdx" rel="noopener ugc nofollow" target="_blank"> Qwik </a></p></figure><p id="257b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">页面启动将是即时的，因为客户端不能重新加载任何东西，并且可以反序列化注入HTML的状态。可持续性是一个非常陌生的概念，在许多项目中并不常见。它是由Qwik的创始人Misko Hevery创造的。</p><p id="8467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/BuilderIO/qwik" rel="noopener ugc nofollow" target="_blank"> Qwik是一个JavaScript框架</a>，它依赖于底层的可重用性。与其他框架不同，Qwik是在考虑可重用性的基础上从头开始构建的。像<a class="ae kv" href="https://github.com/BuilderIO/qwik/blob/main/packages/docs/src/routes/docs/think-qwik/index.mdx#why-not-fix-existing-frameworkstools" rel="noopener ugc nofollow" target="_blank"> React和Vue这样的框架不可能在不牺牲向后兼容性的情况下利用可重用性</a>。这是因为与大多数JavaScript框架的同步性质相比，Qwik的惰性加载组件使用异步惰性加载。</p><p id="704b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Qwik 的<a class="ae kv" href="https://github.com/BuilderIO/qwik" rel="noopener ugc nofollow" target="_blank">目标是加载尽可能少的JavaScript。延迟加载JavaScript很难，而且在某些情况下是不可能的。越不需要越好。可重用性允许开发人员进行细粒度的延迟加载，并减少移动应用程序的内存使用，从而为移动web优化您的站点。</a></p><p id="0de7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Qwik在某些方面是相似的——特别是它的语法。这里有一个关于Qwik如何在代码中工作的<a class="ae kv" href="https://qwik.builder.io/examples/introduction/hello-world/" rel="noopener ugc nofollow" target="_blank">代码片段示例</a>。应用程序的根将以HTML的形式出现:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="b2b7" class="nn lt iq nj b gy no np l nq nr">import { App } from './app';</span><span id="eff9" class="nn lt iq nj b gy ny np l nq nr">export const Root = () =&gt; {<br/>  return (<br/>    &lt;html&gt;<br/>      &lt;head&gt;<br/>        &lt;title&gt;Hello Qwik&lt;/title&gt;<br/>      &lt;/head&gt;<br/>      &lt;body&gt;<br/>        &lt;App /&gt;<br/>      &lt;/body&gt;<br/>    &lt;/html&gt;<br/>  );<br/>};</span></pre><p id="24ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根对<code class="fe nv nw nx nj b">App</code>有依赖性。它将是延迟加载的Qwik组件:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="afaa" class="nn lt iq nj b gy no np l nq nr">import { component$ } from '@builder.io/qwik';</span><span id="f65b" class="nn lt iq nj b gy ny np l nq nr">export const App = component$(() =&gt; {<br/>  return &lt;p&gt;Hello Qwik&lt;/p&gt;;<br/>});</span></pre><p id="e4b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Qwik和React在组件级别有相似之处。但是当你进入服务器端的时候就不一样了。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="7146" class="nn lt iq nj b gy no np l nq nr">import { renderToString, RenderOptions } from '@builder.io/qwik/server';<br/>import { Root } from './root';</span><span id="030e" class="nn lt iq nj b gy ny np l nq nr">export default function (opts: RenderOptions) {<br/>  return renderToString(&lt;Root /&gt;, opts);<br/>}</span></pre><p id="781e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码片段向您展示了Qwik的服务器端如何使用<code class="fe nv nw nx nj b">renderToString</code>方法序列化根组件。然后，客户端只需要解析纯HTML并反序列化JavaScript状态，而不需要重新加载它们。</p><h1 id="d5d5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="d731" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">应用程序性能对客户端至关重要。启动时你需要加载的资源越多，你的应用程序需要启动的时间就越长。装载时间期望值越来越低。你需要加载一个站点的时间越少越好。</p><p id="f416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您正在开发大型企业应用程序，如何优化您的应用程序并不明显。数据加载模式是优化应用程序速度的一种方式。在本文中，您回顾了可能有用的五种数据加载模式:</p><ol class=""><li id="8320" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">服务器端渲染(SSR)和Jamstack</li><li id="8e95" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">主动内存缓存</li><li id="7cf7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">数据事件来源</li><li id="c49a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">预取和延迟加载</li><li id="8778" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">可再生性</li></ol><p id="622f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这五个在他们自己的环境中都是有用的。</p><p id="86eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于不太需要客户端状态管理的应用程序，SSR和Jamstack通常是不错的选择。随着React等现代JavaScript框架的出现，越来越多的人开始尝试客户端渲染(CSR)，社区似乎又回到了SSR。SSR是旧的MVC web框架使用的技术，它使用模板引擎根据后端的数据生成HTML。Jamstack是对原始网络的一种更古老的描述，在那里一切都只使用HTML。</p><p id="a5fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主动内存缓存帮助用户更快地从API加载数据。主动内存缓存通过在远程缓存服务器(Redis)或本地浏览器缓存上缓存结果，解决了数据加载的重要问题。另一种数据加载模式甚至使用它，预取。</p><p id="89c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，事件源是一种架构模式，它补充了实时的基于事件的WebSocket APIs。普通的旧WebSocket不足以变得完全高效，因为即使web socket本身是实时的，对数据库的重复API调用也会导致瓶颈。事件源通过创建一个单独的数据库来检索数据，从而解决了这个问题。</p><p id="8a32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">预取和延迟加载是最容易实现的解决方案。预取的目标是在网络空闲时静默加载数据。客户端会将预取的链接保存在浏览器缓存中，使其在接触时立即生效。</p><p id="71c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">延迟加载减少了第一次点击时需要加载的资源数量。您只需要在页面加载后直接看到的资源。然而，可恢复性将延迟加载发挥到了极致。可恢复性是一种延迟加载JavaScript组件的方法，方法是在服务器中呈现组件，然后序列化状态以通过HTML在客户端继续呈现。</p><h1 id="b143" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">从这里去哪里？</h1><p id="d51d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">学习优化你的前端应用程序是一个持续的过程；你需要积极主动地对待你每天要做的事情。数据加载模式只是提高应用程序性能的几种方法之一。</p><p id="ddff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在对应用程序的结构、使用和加载数据的方式做出任何重大改变之前，最好考虑一下常见的缺陷。</p><p id="9371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有兴趣了解这些参考资料，可以查看以下内容:</p><ul class=""><li id="5c3b" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr nf mw mx my bi translated">Qwik <a class="ae kv" href="https://qwik.builder.io/docs/overview/" rel="noopener ugc nofollow" target="_blank">概述</a></li><li id="4a82" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated"><a class="ae kv" href="https://medium.com/@inverita/frontend-optimization-8-tips-to-improve-web-performance-29af4b00efe7" rel="noopener">提高前端性能的八个技巧</a></li><li id="8ff8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated">实时<a class="ae kv" href="https://blog.bitsrc.io/event-sourcing-pattern-for-real-time-frontends-42359e6dd957" rel="noopener ugc nofollow" target="_blank">事件源模式</a></li><li id="3a64" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated">12前端性能<a class="ae kv" href="https://medium.com/geekculture/12-front-end-performance-patterns-you-need-to-know-def550620464" rel="noopener">优化技术</a></li><li id="819e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr nf mw mx my bi translated">23 web性能<a class="ae kv" href="https://blog.speedvitals.com/web-performance-mistakes/#Over_Utilizing_Preloading" rel="noopener ugc nofollow" target="_blank">要避免的错误</a></li></ul><p id="8c32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章对你有所帮助。如果您有任何问题或意见，请加入下面的论坛讨论。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="e5b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ng">原载于2022年9月27日</em><a class="ae kv" href="https://www.smashingmagazine.com/2022/09/data-loading-patterns-improve-frontend-performance/" rel="noopener ugc nofollow" target="_blank"><em class="ng">【https://www.smashingmagazine.com】</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>