<html>
<head>
<title>Functional Programming in JavaScript: Introduction and Practical Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数式编程:简介和实例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-in-javascript-introduction-and-practical-examples-d268e44395b2?source=collection_archive---------3-----------------------#2019-10-15">https://betterprogramming.pub/functional-programming-in-javascript-introduction-and-practical-examples-d268e44395b2?source=collection_archive---------3-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="785b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从纯函数和组合子到组合和容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/acb458b01d7b861ccac358b4058710df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Scj1YOBc2cxDfANrU5yQXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数式编程借鉴了数学中的一些思想。在<a class="ae ky" href="https://unsplash.com/s/photos/equation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@roman_lazygeek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗马法师</a>拍摄的照片。</p></figure><p id="c2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">函数式编程(FP)是一种越来越流行的编码风格。有很多内容解释了什么是<em class="me"> </em>函数式编程，但是关于如何应用它的内容却很少。对我来说，知道如何应用它更有价值:只有当你把它付诸实践时，你才能真正理解和感受一种编程风格。这就是这篇文章的目的JavaScript中函数式编程风格的实用介绍。</p><p id="f6e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我遇到的一些作品不同，这个作品不会鼓励你使用高阶函数，如<code class="fe mf mg mh mi b">map</code>、<code class="fe mf mg mh mi b">filter</code>和<code class="fe mf mg mh mi b">reduce</code>，并就此打住。是的，这些函数是函数式程序员工具箱中有用的一部分，但它们只是整体情况的一部分——许多代码库在使用它们时没有遵循其他函数式编程原则。相反，我们将使用普通的JavaScript来构建函数，帮助我们尽可能地坚持函数范式。但是首先，我们需要理解两个关键的功能概念。</p><p id="0304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:ES6的JavaScript特性，比如箭头函数和spread操作符，使得编写FP代码变得更加容易，所以建议您在一个ES6友好的环境中学习！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01718234c2e658c6caf4086d0c631f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4LqoH6F8tRRbK2rDUobKKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@erdaest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Erda Estremera </a>在<a class="ae ky" href="https://unsplash.com/s/photos/pure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f1fd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">概念1。纯函数</h1><p id="b533" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这些是函数式编程的核心。纯函数有三个属性:</p><p id="a79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.同样的论点必然总是导致同样的结果。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="4a41" class="nr mr it mi b gy ns nt l nu nv"><em class="me">/** This function is </em><strong class="mi iu"><em class="me">pure</em></strong><em class="me">:<br/>*   if the input is the same, the result will always be the same.<br/>*/<br/></em>const cubeRoot = num =&gt; Math.pow(num, 1/3);</span><span id="f32a" class="nr mr it mi b gy nw nt l nu nv"><em class="me">/** This function is </em><strong class="mi iu"><em class="me">impure</em></strong><em class="me">:<br/>*   here, the same argument can produce different results.<br/>*/<br/></em>const randInt = (min, max) =&gt; {<br/>  return parseInt(Math.random() * (max - min) + min);<br/>};</span></pre><p id="1d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.一个纯函数不能依赖于在其作用域之外声明的任何变量。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="9f1f" class="nr mr it mi b gy ns nt l nu nv">const stock = ['pen', 'pencil', 'notepad', 'highlighter'];</span><span id="e7dd" class="nr mr it mi b gy nw nt l nu nv"><em class="me">/** This function is </em><strong class="mi iu"><em class="me">impure</em></strong><em class="me">:<br/>*   it refers to the stock variable in the global namespace.<br/>*/</em><br/>const isInStock = item =&gt; {<br/>  return stock.indexOf(item) !== -1;<br/>};</span><span id="31fa" class="nr mr it mi b gy nw nt l nu nv"><em class="me">/** This function is </em><strong class="mi iu"><em class="me">pure</em></strong><em class="me">:<br/>*   it does not depend on any variables outside its scope.<br/>*/</em><br/>const isInStock = item =&gt; {<br/>  const stock = ['pen', 'pencil', 'notepad', 'highlighter'];<br/>  return stock.indexOf(item) !== -1;<br/>};</span><span id="c243" class="nr mr it mi b gy nw nt l nu nv"><em class="me">/** This function is also </em><strong class="mi iu"><em class="me">pure</em></strong><em class="me">: <br/>*   all variables are passed in as arguments.<br/>*/</em><br/>const isInStock = (item, array) =&gt; {<br/>  return array.indexOf(item) !== -1;<br/>};</span></pre><p id="584c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.不能有副作用:这意味着不能改变外部变量，不能调用<code class="fe mf mg mh mi b">console.log</code>，不能触发额外的进程。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="55d7" class="nr mr it mi b gy ns nt l nu nv">let fruits = ['apple', 'orange', 'apple', 'apple', 'pear'];</span><span id="8f95" class="nr mr it mi b gy nw nt l nu nv"><em class="me">/** This function is </em><strong class="mi iu"><em class="me">pure</em></strong><em class="me">:<br/>*   it does not change the fruits variable.<br/>*/</em><br/>const countApples = fruits =&gt; fruits.filter(word =&gt; word === 'apple').length;</span><span id="4a94" class="nr mr it mi b gy nw nt l nu nv"><em class="me">/** This function is </em><strong class="mi iu"><em class="me">impure</em></strong><em class="me">:<br/>*   it 'destructively' changes the fruits variable (a </em><strong class="mi iu"><em class="me">side-effect</em></strong><em class="me">).<br/>*/</em><br/>const countApples = () =&gt; {<br/>  fruits = fruits.filter(word =&gt; word === 'apple');<br/>  return fruits.length;<br/>};</span></pre><p id="a61d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些特征使得纯函数类似于数学中的函数。通过尽可能频繁地使用纯函数，我们使代码更加透明、可预测和独立。这使得我们的代码更容易维护和调试。它还鼓励我们将大任务分成更简单、更易管理的步骤。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a27e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">概念2。组合子</h1><p id="7cda" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">组合子类似于纯函数，但它们更受限制。组合子具有与纯函数相同的要求，外加一个要求:</p><ul class=""><li id="bfc2" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">组合子不包含自由变量。</li></ul><p id="e13f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自由变量是其值不能被独立访问的任何变量。组合子中的每个变量都必须通过参数传递。</p><p id="f1ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以下面这个函数是纯函数，但不是组合子。它依赖于一个<code class="fe mf mg mh mi b">conversionRates</code>变量，我们不能独立地访问它:它不是函数的参数。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="2dfa" class="nr mr it mi b gy ns nt l nu nv">const convertUSD = (val, code) =&gt; {<br/>  const conversionRates = {<br/>    CNY: 7.07347,<br/>    EUR: 0.906250,<br/>    GBP: 0.796313,<br/>    INR: 71.1427,<br/>    USD: 1,<br/>  };</span><span id="ae16" class="nr mr it mi b gy nw nt l nu nv">  if (!conversionRates[code]) {<br/>    throw new Error('This currency code is not available');<br/>  };</span><span id="11fa" class="nr mr it mi b gy nw nt l nu nv">  return val * conversionRates[code];<br/>};</span></pre><p id="aca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使<code class="fe mf mg mh mi b">convertUSD</code>成为一个组合子，我们需要将转换率数据作为一个参数传入。</p><p id="5861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，下面的函数是组合子:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="57c7" class="nr mr it mi b gy ns nt l nu nv">const add = (x, y) =&gt; x + y;<br/>const multiple = (x, y) =&gt; x + y;</span><span id="f65b" class="nr mr it mi b gy nw nt l nu nv">const sum = (...nums) =&gt; nums.reduce((x, y) =&gt; x + y);<br/>const product = (...nums) =&gt; nums.reduce((x, y) =&gt; x * y);</span></pre><p id="f7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该清楚的是<code class="fe mf mg mh mi b">add</code>和<code class="fe mf mg mh mi b">multiply</code>不包含自由变量，但是<code class="fe mf mg mh mi b">sum</code>和<code class="fe mf mg mh mi b">product</code>呢？当然，他们引入了两个新变量<code class="fe mf mg mh mi b">x</code>和<code class="fe mf mg mh mi b">y</code>，它们不是参数？但是在这种情况下，<code class="fe mf mg mh mi b">x</code>和<code class="fe mf mg mh mi b">y</code>的值直接由传递给每个函数的参数决定。<code class="fe mf mg mh mi b">x</code>和<code class="fe mf mg mh mi b">y</code>不是表示新变量，而是现有变量的别名，所以我们也可以将<code class="fe mf mg mh mi b">sum</code>和<code class="fe mf mg mh mi b">product</code>定义为组合子。</p><p id="cecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:通常在函数式编程中，组合子接受并返回函数。所以在实践中，你不会经常看到像上面描述的组合子那样的函数，尽管它们遵循所有的规则！对于经典的FP组合器，请参见下面“介绍合成函数”一节中的<code class="fe mf mg mh mi b">compose</code>函数。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9ea7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">为什么函数式程序员会回避循环？</h1><p id="88ca" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">网上有很多内容告诉我们函数式程序员避免使用<code class="fe mf mg mh mi b">for</code>或<code class="fe mf mg mh mi b">while</code>循环，但是很少解释为什么。这里有一个例子。下面是一个用于创建从<code class="fe mf mg mh mi b">1</code>到<code class="fe mf mg mh mi b">100</code>的值数组的函数:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="7399" class="nr mr it mi b gy ns nt l nu nv">const list1to100 = () =&gt; {<br/>  const arr = [];<br/>  for (let i = 0; i &lt; 100; i++) {<br/>    arr.push(i + 1);<br/>  };<br/>  return arr;<br/>};</span></pre><p id="7263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这样的<code class="fe mf mg mh mi b">for</code>循环，我们可能需要两个自由变量(<code class="fe mf mg mh mi b">arr</code>和<code class="fe mf mg mh mi b">i</code>)。这防止了<code class="fe mf mg mh mi b">for</code>循环成为一个组合子。从技术上讲，它是一个纯函数，因为它不会在局部范围之外改变任何变量。但是，如果可能的话，我们宁愿完全避免突变。</p><p id="5d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个更适合函数式编程范例的替代方案:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="2235" class="nr mr it mi b gy ns nt l nu nv">const list1to100 = () =&gt; {<br/>  return new Array(100).fill(undefined).map((x, i) =&gt; i + 1);<br/>};</span></pre><p id="5ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们不再定义任何新的变量(在这种情况下，<code class="fe mf mg mh mi b">i</code>指的是数组中项的索引，这个值是在数组创建时存储在内存中的)。我们也没有改变任何变量。这个函数更有FP的味道！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0596" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">纯函数和组合子为什么有用？</h1><p id="702e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果你是函数式编程的新手，你可能会认为我们给自己强加了很多不必要的限制。您甚至可能想知道是否有可能以这种方式编写整个应用程序，并且仍然遵循规则！</p><p id="fdef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">核心思想是函数式编程更容易写，更容易理解。我们可以在任何上下文中使用纯函数:它们将总是返回相同的结果，并且它们不会改变代码的任何其他部分。组合子更加透明:组合子中的每个变量都是你选择传递的。</p><p id="0ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于编写真实世界的应用程序，函数式编程确实只能带我们走这么远。我们需要通过将事情记录到控制台来调试应用程序。我们还需要变异变量(例如，控制状态)，触发外部流程(例如，对数据库的CRUD操作)，以及处理未知数据(例如，用户输入)。满足这些需求的FP方法是将非FP代码隔离到容器中，并在这些代码和我们整洁的、可重用的FP代码之间提供桥梁。通过将可变代码保存在容器中，我们限制了它变得混乱和影响我们不希望它影响的事情的能力！</p><p id="4080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的剩余部分，我们将研究一些实用的方法:</p><ul class=""><li id="28d5" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">写FP代码</li><li id="9e56" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">解决上面确定的一些问题</li></ul><p id="4449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从构建一个实用程序来使函数式编程更加自然开始:<code class="fe mf mg mh mi b">compose</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a7c891c1de24297892b699829ec692e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pa3z13OFvjiemiYeoOfrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比尔·牛津在<a class="ae ky" href="https://unsplash.com/s/photos/cogs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2c16" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">介绍撰写功能</h1><p id="d037" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">函数式编程中一个非常常见的任务是将多个函数组合成一个函数。按照惯例，我们将执行此操作的函数称为<code class="fe mf mg mh mi b">compose</code>。这个函数恰好也是一个组合子！</p><p id="5e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要一个将美分转换成美元的函数。FP鼓励我们将这个任务拆分成更小的子任务，所以让我们从制作四个函数开始:<code class="fe mf mg mh mi b">divideBy100</code>、<code class="fe mf mg mh mi b">roundTo2dp</code>、<code class="fe mf mg mh mi b">addDollarSign</code>和<code class="fe mf mg mh mi b">addSeparators</code>。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="5d11" class="nr mr it mi b gy ns nt l nu nv">const divideBy100 = num =&gt; num / 100;</span><span id="d4c8" class="nr mr it mi b gy nw nt l nu nv">const roundTo2dp = num =&gt; num.toFixed(2);</span><span id="e742" class="nr mr it mi b gy nw nt l nu nv">const addDollarSign = str =&gt; '$' + String(str);</span><span id="4735" class="nr mr it mi b gy nw nt l nu nv">const addSeparators = str =&gt; {<br/>  // add commas before the decimal point<br/>  str = str.replace(/(?&lt;!\.\d+)\B(?=(\d{3})+\b)/g, `,`);<br/>  // add commas after the decimal point<br/>  str = str.replace(/(?&lt;=\.(\d{3})+)\B/g, `,`);<br/>  return str;<br/>};</span></pre><p id="baa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码大多非常简单，除了<code class="fe mf mg mh mi b">addSeparators</code>函数，它使用一些漂亮的正则表达式在每第三个数字前添加逗号。</p><p id="7b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了各自的功能，我们需要一种方法来组合它们。传统的方法是使用括号，就像这样:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="c8a4" class="nr mr it mi b gy ns nt l nu nv">const centsToDollars = <br/>  addSeparators(<br/>    addDollarSign(<br/>      roundTo2dp(<br/>        divideBy100<br/>      )<br/>    )<br/>  );</span></pre><p id="66a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这没关系，但是随着我们需要的函数数量的增加，跟踪括号可能会变得令人困惑。这就是<code class="fe mf mg mh mi b">compose</code>的用武之地。<code class="fe mf mg mh mi b">compose</code>功能将允许我们像这样组合功能:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="7483" class="nr mr it mi b gy ns nt l nu nv">const centsToDollars = compose(<br/>  addSeparators,<br/>  addDollarSign,<br/>  roundTo2dp,<br/>  divideBy100,<br/>);</span></pre><p id="062a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有复杂的括号，这就清楚多了。那么，我们如何构建<code class="fe mf mg mh mi b">compose</code>？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="74c8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">构建合成函数</h1><p id="6b38" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用高阶<code class="fe mf mg mh mi b">reduceRight</code>功能，这可以在一行中实现:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="326d" class="nr mr it mi b gy ns nt l nu nv">const compose = (...fns) =&gt; x =&gt; fns.reduceRight((res, fn) =&gt; fn(res), x);</span></pre><p id="e6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，上面的代码是怎么回事呢？</p><ul class=""><li id="3f84" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">首先，我们使用扩展操作符<code class="fe mf mg mh mi b">...</code>传递任意数量的函数作为参数。</li><li id="f1a1" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">接下来，我们想把我们的函数数组(<code class="fe mf mg mh mi b">fns</code>)变成一个输出。我们可以使用JavaScript的<code class="fe mf mg mh mi b">reduce</code>函数，但是按照惯例<code class="fe mf mg mh mi b">compose</code>是从右向左运行的，所以我们将使用<code class="fe mf mg mh mi b">reduceRight</code>。</li><li id="4ae7" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe mf mg mh mi b">reduceRight</code>将回调函数作为第一个参数。在这个回调中，我们将传递两个参数:我们的结果(<code class="fe mf mg mh mi b">res</code>)，其中我们跟踪最新返回的结果，以及一个函数(<code class="fe mf mg mh mi b">fn</code>)，我们将使用它来触发<code class="fe mf mg mh mi b">fns</code>数组中的每个函数。</li><li id="7561" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">最后，<code class="fe mf mg mh mi b">reduceRight</code>有一个可选的第二个参数，它定义了它的初始值。这种情况下应该是<code class="fe mf mg mh mi b">x</code>。</li></ul><p id="0c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果你喜欢从左到右排列你的功能，你可以用<code class="fe mf mg mh mi b">reduce</code>代替<code class="fe mf mg mh mi b">reduceRight</code>。按照惯例，<code class="fe mf mg mh mi b">compose</code>的这种从左到右的变化将被称为<code class="fe mf mg mh mi b">pipe</code>或<code class="fe mf mg mh mi b">sequence</code>。</p><p id="2121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，下面的代码应该返回一个函数:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="6e7a" class="nr mr it mi b gy ns nt l nu nv">const centsToDollars = compose(<br/>  addSeparators,<br/>  addDollarSign,<br/>  roundTo2dp,<br/>  divideBy100,<br/>);</span></pre><p id="febb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行<code class="fe mf mg mh mi b">console.log(typeof centsToDollars)</code>，应该会看到<code class="fe mf mg mh mi b">"function"</code>。</p><p id="916a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们试一试。如果我们执行<code class="fe mf mg mh mi b">console.log(centsToDollars(100000000))</code>，我们应该得到一个<code class="fe mf mg mh mi b">$1,000,000.00</code>的结果。完美！</p><p id="5320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚编写了第一个真实世界的函数代码示例！不再想添加美元符号？只需从<code class="fe mf mg mh mi b">compose</code>中删除<code class="fe mf mg mh mi b">addDollarSign</code>作为参数。你的初始值是美元，而不是美分？然后取下<code class="fe mf mg mh mi b">divideBy100</code>。因为我们遵循FP原则，我们可以确信移除这些函数不会影响我们代码的任何其他部分。</p><p id="0d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以很容易地在我们代码库的任何部分重用这些小函数。例如，我们可能想在应用程序中使用<code class="fe mf mg mh mi b">addSeparators</code>来格式化其他数字。函数式编程意味着我们可以放心地重用那个函数！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d0dd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">调试撰写</h1><p id="79e6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">但是我们有一个新问题。假设我们在应用程序中使用方便的<code class="fe mf mg mh mi b">addSeparators</code>函数来格式化20个不同的数字，但是有些东西不工作。通常，我们可能会在函数中添加一个<code class="fe mf mg mh mi b">console.log</code>语句来查看发生了什么:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="8154" class="nr mr it mi b gy ns nt l nu nv">const addSeparators = str =&gt; {<br/>  str = str.replace(/(?&lt;!\.\d+)\B(?=(\d{3})+\b)/g, `,`);<br/>  str = str.replace(/(?&lt;=\.(\d{3})+)\B/g, `,`);<br/>  console.log(str);<br/>  return str;<br/>};</span></pre><p id="02c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这并没有太大的帮助，因为每次我们的应用程序加载时该函数触发20次，所以我们会看到20个<code class="fe mf mg mh mi b">console.log</code>的实例！</p><p id="7c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一种方法来查看只有当<code class="fe mf mg mh mi b">addSeparators</code>作为<code class="fe mf mg mh mi b">centsToDollars</code>的一部分被调用时会发生什么。为此，我们可以使用一个名为<code class="fe mf mg mh mi b">tap</code>的组合子。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="aa87" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">抽头函数</h1><p id="7d9c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe mf mg mh mi b">tap</code>函数使用提供的对象运行函数，然后返回该对象:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="3de6" class="nr mr it mi b gy ns nt l nu nv">const tap = f =&gt; x =&gt; {<br/>  f(x);<br/>  return x;<br/>};</span></pre><p id="8361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们在传递给<code class="fe mf mg mh mi b">compose</code>的各种函数之间运行额外的函数，而不会影响结果:这使得<code class="fe mf mg mh mi b">tap</code>成为登录控制台的理想位置。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cf3e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">跟踪功能</h1><p id="5f46" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们将调用我们的日志记录函数<code class="fe mf mg mh mi b">trace</code>，我们将调用<code class="fe mf mg mh mi b">console.log</code>作为回调函数:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="5a78" class="nr mr it mi b gy ns nt l nu nv">const trace = label =&gt; tap(console.log.bind(console, label + ':'));</span></pre><p id="bb1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们必须使用<code class="fe mf mg mh mi b">bind</code>来确保在执行<code class="fe mf mg mh mi b">tap</code>时全局<code class="fe mf mg mh mi b">console</code>对象是可用的。下一个参数<code class="fe mf mg mh mi b">label</code>，允许我们在记录到控制台的任何内容之前添加一个字符串，这可以使调试更加清晰。</p><p id="3e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe mf mg mh mi b">compose</code>，我们可以添加<code class="fe mf mg mh mi b">trace</code>函数，在对象从一个对象传递到另一个对象时跟踪对象:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="06b4" class="nr mr it mi b gy ns nt l nu nv">const centsToDollars = compose(<br/>  trace('addSeparators'),<br/>  addSeparators,<br/>  trace('addDollarSign'),<br/>  addDollarSign,<br/>  trace('roundTo2dp'),<br/>  roundTo2dp,<br/>  trace('divideBy100'),<br/>  divideBy100,<br/>  trace('argument'),<br/>);</span></pre><p id="63e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们运行<code class="fe mf mg mh mi b">centsToDollars(100000000)</code>，我们将在控制台中看到:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="2f64" class="nr mr it mi b gy ns nt l nu nv">argument: 100000000<br/>divideBy100: 1000000<br/>roundTo2dp: 1000000.00<br/>addDollarSign: $1000000.00<br/>addSeparators: $1,000,000.00</span></pre><p id="c170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在任何阶段出现问题，现在都更容易发现！</p><p id="5ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看我们到目前为止创建的所有函数，包括<code class="fe mf mg mh mi b">centsToDollars</code>示例，<a class="ae ky" href="https://gist.github.com/BretCameron/0630bbdc332ed128de6c702efea47ccc" rel="noopener ugc nofollow" target="_blank">请查看这个要点</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3cb844a7153cc4c94e81e07e536d3af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*da0t7DdeQVASJ9rG3sNgIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@serjosoza?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> sergio souza </a>在<a class="ae ky" href="https://unsplash.com/s/photos/shipping-containers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="697a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">容器</h1><p id="7436" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文的最后一部分，我们将快速了解一下容器。我们无法完全避免混乱的、有状态的代码，所以函数式编程的解决方案是将这些代码与我们代码库的其他部分隔离开来。这就把所有易变的、副作用大的、不纯的代码放在了一个地方，保持了整洁。我们的纯逻辑可以使用<em class="me">桥</em>与这些代码进行交互——我们创建这些方法来触发副作用，并以可控、可预测的方式改变变量。</p><p id="bd92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建几个实用函数，帮助我们检查函数是否作为参数传递:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="2770" class="nr mr it mi b gy ns nt l nu nv">const isFunction = fn =&gt; fn &amp;&amp; Object.prototype.toString.call(fn) === '[object Function]';</span><span id="54c1" class="nr mr it mi b gy nw nt l nu nv">const isAsync = fn =&gt; fn &amp;&amp; Object.prototype.toString.call(fn) === '[object AsyncFunction]';</span><span id="c97b" class="nr mr it mi b gy nw nt l nu nv">const isPromise = p =&gt; p &amp;&amp; Object.prototype.toString.call(p) === '[object Promise]';</span></pre><p id="80c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用ES6类语法来创建我们的容器，但是您也可以使用常规函数来实现相同的目的:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="5c61" class="nr mr it mi b gy ns nt l nu nv">class Container {<br/>  constructor(fn) {<br/>    <em class="me">this</em>.value = fn;<br/>    if (!isFunction(<em class="me">this</em>.value) &amp;&amp; !isAsync(<em class="me">this</em>.value)) {<br/>      throw new TypeError(`Container expects a function, not a ${typeof <em class="me">this</em>.value}.`);<br/>    };<br/>  }</span><span id="6465" class="nr mr it mi b gy nw nt l nu nv">  run() {<br/>    return <em class="me">this</em>.value();<br/>  }<br/>};</span></pre><p id="e4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe mf mg mh mi b">constructor</code>接受一个函数或者异步函数。如果两者都没有提供，它将抛出一个<code class="fe mf mg mh mi b">TypeError</code>。然后<code class="fe mf mg mh mi b">run</code>方法执行这个函数。</p><p id="01ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在容器中存储不纯的函数，这些函数不会运行，除非它们被特别调用，如下所示:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="49d4" class="nr mr it mi b gy ns nt l nu nv">const sayHello = () =&gt; 'Hello';</span><span id="0397" class="nr mr it mi b gy nw nt l nu nv">const container = new Container(sayHello);<br/>console.log(container.run());  // 'Hello'</span></pre><p id="3d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们的<code class="fe mf mg mh mi b">sayHello</code>函数实际上不是不纯的。但也有可能！</p><p id="88b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让容器更有用，最好对容器的<code class="fe mf mg mh mi b">run</code>方法的结果执行额外的函数。为此，让我们将<code class="fe mf mg mh mi b">map</code>作为方法添加到我们的<code class="fe mf mg mh mi b">Container</code>类中:</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="1a6d" class="nr mr it mi b gy ns nt l nu nv">map(fn) {<br/>  if (!isFunction(fn) &amp;&amp; !isAsync(fn)) {<br/>    throw new TypeError(`The map method expects a function, not a ${typeof fn}.`);<br/>  };</span><span id="f5aa" class="nr mr it mi b gy nw nt l nu nv">  return new Container(<br/>    () =&gt; isPromise(<em class="me">this</em>.value()) ?<br/>      <em class="me">this</em>.value().then(fn) : fn(<em class="me">this</em>.value())<br/>  )<br/>}</span></pre><p id="d834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要一个新函数作为它的参数。如果原始函数(<code class="fe mf mg mh mi b">this.value()</code>)的结果是一个承诺，它使用<code class="fe mf mg mh mi b">then</code>方法链接新函数。否则，它只执行<code class="fe mf mg mh mi b">this.value()</code>上的功能。</p><p id="ea66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以将函数链接到用于创建容器的函数上。在下面的例子中，我们向序列中添加了一个新函数<code class="fe mf mg mh mi b">addName</code>，并使用前面的<code class="fe mf mg mh mi b">tap</code>函数将结果记录到控制台。</p><pre class="kj kk kl km gt nn mi no np aw nq bi"><span id="b4d6" class="nr mr it mi b gy ns nt l nu nv">const sayHello = () =&gt; 'Hello';<br/>const addName = (name, str) =&gt; str + ' ' + name;</span><span id="33f5" class="nr mr it mi b gy nw nt l nu nv">const container = new Container(sayHello);</span><span id="5b7f" class="nr mr it mi b gy nw nt l nu nv">const greet = container<br/>  .map(addName.bind(<em class="me">this</em>, 'Joe Bloggs'))<br/>  .map(tap(console.log));</span></pre><p id="a41c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们执行<code class="fe mf mg mh mi b">greet.run()</code>时，我们应该在控制台中看到<code class="fe mf mg mh mi b">Hello Joe Bloggs</code>。</p><p id="db5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看本节的完整代码，请查看要点。</p><p id="ac0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器的内容远不止本文所能涵盖的。例如，流行的工具Redux，其核心是一个状态管理容器。但是希望这个例子足以向您展示什么是容器，以及它为什么有用。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e18a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="7f40" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我希望这篇文章为您提供了一些将函数式编程引入JavaScript代码的实用方法。大多数函数式编程都很简单:尽可能多地编写纯函数。对于感兴趣的人，您可以更深入地了解:</p><ul class=""><li id="3255" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">如果你愿意投资付费课程，我强烈推荐迈克尔·罗萨塔的课程《使用函数式JavaScript构建声明式应用程序》(可在<a class="ae ky" href="https://www.linkedin.com/learning/building-declarative-apps-using-functional-javascript" rel="noopener ugc nofollow" target="_blank"> LinkedInLearning </a>或<a class="ae ky" href="https://www.udemy.com/course/building-declarative-apps-using-functional-javascript/" rel="noopener ugc nofollow" target="_blank"> Udemy </a>上获得)。当我刚开始学习函数式编程时，我使用了Michael的课程，并且在我关于容器的最后一节中借鉴了他的一些想法。</li><li id="48c9" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">另一个改进函数式编程的好方法是查看库<a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> RamdaJS </a>。它是专门为函数式编程风格设计的，实现了我们之前构建的几个函数，即<code class="fe mf mg mh mi b">compose</code>、<code class="fe mf mg mh mi b">pipe</code>和<code class="fe mf mg mh mi b">tap</code>。【Ramda官方网站有一些好文章的链接让你入门。Christopher Okhravi的视频也是一个很好的介绍，它通过给出更多关于如何使用<code class="fe mf mg mh mi b">compose</code> / <code class="fe mf mg mh mi b">pipe</code>的例子来补充这篇文章。</li></ul><p id="cb76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，或者你想读一篇更深入挖掘特定FP概念的文章，请告诉我！</p></div></div>    
</body>
</html>