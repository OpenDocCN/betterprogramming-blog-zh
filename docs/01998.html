<html>
<head>
<title>Core Data and App Extensions: Sharing a Single Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心数据和应用程序扩展:共享单个数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/core-data-and-app-extensions-sharing-a-single-database-24f8cac35faa?source=collection_archive---------12-----------------------#2019-10-29">https://betterprogramming.pub/core-data-and-app-extensions-sharing-a-single-database-24f8cac35faa?source=collection_archive---------12-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="45af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改善核心数据实现的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7f49e11e400e1020415b0c99bc1eebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vVDzkg5_5FpGNBiD.png"/></div></div></figure><p id="13c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着API的改进，核心数据变得越来越好，更容易使用。Apple framework允许您保存应用程序的永久数据以供离线使用，提供撤销功能，或者只是缓存数据以获得更好的性能。</p><p id="1e32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在将基础实现到你的应用程序中之后，<a class="ae lq" href="https://www.avanderlee.com/swift/nsbatchdeleterequest-core-data/" rel="noopener ugc nofollow" target="_blank">也许通过使用</a> <code class="fe lr ls lt lu b"><a class="ae lq" href="https://www.avanderlee.com/swift/nsbatchdeleterequest-core-data/" rel="noopener ugc nofollow" target="_blank">NSBatchDeleteRequest</a></code> <a class="ae lq" href="https://www.avanderlee.com/swift/nsbatchdeleterequest-core-data/" rel="noopener ugc nofollow" target="_blank">来删除批处理</a>，你可能需要更高级的解决方案来引入复杂的bug。同样的事情也发生在我在日常工作中开发的<a class="ae lq" href="https://collect.bywetransfer.com" rel="noopener ugc nofollow" target="_blank"> Collect by WeTransfer </a>应用程序上，所以让我们分享一些经验。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4ba4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">与应用程序扩展共享相同的核心数据持久容器</h1><p id="5621" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如果您使用核心数据作为数据库解决方案，那么与Today扩展、Action扩展或Share扩展共享核心数据数据库是很常见的事情。在Collect应用程序中，我们有一个Share扩展和一个Action扩展，这两个扩展都需要使用相同的底层持久容器。</p><p id="d685" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应用程序扩展和包含应用程序不能直接访问彼此的容器，即使应用程序扩展捆绑包嵌套在其包含应用程序的捆绑包中。幸运的是，苹果使得与你的扩展共享一个持久容器变得很容易。</p><h2 id="a10a" class="mz md it bd me na nb dn mi nc nd dp mm ld ne nf mo lh ng nh mq ll ni nj ms nk bi translated">为数据共享设置持久容器</h2><p id="44ee" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">为了共享数据，我们需要在主应用程序及其扩展之间创建一个共享容器。我们可以通过在项目的“签名和功能”部分添加应用程序组功能来实现这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/00000705a6e5ca44be70c50b0276425a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W3unStDOgQk4r3ci.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">将应用程序组添加到您的项目以共享核心数据</p></figure><p id="79d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将最终导致您的项目的应用程序组的以下概述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/bb3be88c05578bda26dfccaace5c12ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZUIRz8BQ1bpTscwv.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">项目的应用程序组概述</p></figure><p id="7c83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，当您尚未将其添加到您的应用程序标识符时，应用程序组会变成红色。您可以通过在此登录您的账户<a class="ae lq" href="https://developer.apple.com/account/resources/identifiers" rel="noopener ugc nofollow" target="_blank">来完成此操作。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/2e0b7f0fc8adaff343985689d341b0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0pEefRt6HDYWDscq.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">将应用组添加到你的应用标识符</p></figure><p id="896f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，您可以更新您的持久性存储描述。基本上，您将数据库保存到共享应用程序容器中。</p><pre class="kj kk kl km gt nq lu nr ns aw nt bi"><span id="8aa3" class="mz md it lu b gy nu nv l nw nx">let persistentContainer = NSPersistentContainer(name: "Collect")<br/>let storeURL = URL.storeURL(for: "group.swiftlee.core.data", databaseName: "Coyote")<br/>let storeDescription = NSPersistentStoreDescription(url: storeURL)<br/>persistentContainer.persistentStoreDescriptions = [storeDescription]</span></pre><p id="1beb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们利用一个方便的URL扩展来获取使用安全应用程序组标识符的共享容器的路径。</p><pre class="kj kk kl km gt nq lu nr ns aw nt bi"><span id="ffc7" class="mz md it lu b gy nu nv l nw nx">public extension URL {<br/><br/>    /// Returns a URL for the given app group and database pointing to the sqlite database.<br/>    static func storeURL(for appGroup: String, databaseName: String) -&gt; URL {<br/>        guard let fileContainer = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: appGroup) else {<br/>            fatalError("Shared file container could not be created.")<br/>        }<br/><br/>        return fileContainer.appendingPathComponent("\(databaseName).sqlite")<br/>    }<br/>}</span></pre><p id="022c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将足以与您的应用程序扩展共享您的持久容器。请务必将您的核心数据模型添加到您的应用程序扩展目标中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a31" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通知主应用程序扩展中的核心数据更改</h1><p id="30b5" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">下一个重要的步骤是，当数据从你的一个扩展中改变时，通知你的主应用程序。这听起来很容易，但这是一个相当大的挑战，因为你不能简单地发布通知。一个应用程序扩展正在不同的进程中运行，因此您的主应用程序不会收到来自它的任何通知。</p><p id="a6c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你的应用程序激活时，你可以简单地刷新你的数据库，但是如果什么都没有改变，这将导致很多不必要的刷新。一个更好的解决方案是从你的应用程序扩展发送一个达尔文通知来触发你的主应用程序的刷新。</p><h2 id="b199" class="mz md it bd me na nb dn mi nc nd dp mm ld ne nf mo lh ng nh mq ll ni nj ms nk bi translated">使用达尔文通知进行扩展和主应用程序之间的通信</h2><p id="64b4" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">达尔文通知能够在应用程序扩展和主应用程序之间发送和接收。他们不太出名，但是一旦建立起来就很容易合作。</p><p id="6d95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让您开始的最好方法是将下面的<a class="ae lq" href="https://gist.github.com/AvdLee/07de0b0fe7dbc351541ab817b9eb6c1c" rel="noopener ugc nofollow" target="_blank">darwinnotificationcenter . swift</a>文件添加到您的项目中。这为您提供了处理Darwin通知所需的所有代码。</p><p id="8536" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，您需要定义两个通知名称来区分您的主应用程序和应用程序扩展。请注意，我们根据我们是否在应用程序扩展上下文中返回这个。这是为了确保我们发布和收听正确的通知。</p><pre class="kj kk kl km gt nq lu nr ns aw nt bi"><span id="0dfd" class="mz md it lu b gy nu nv l nw nx">extension DarwinNotification.Name {<br/>    private static let appIsExtension = Bundle.main.bundlePath.hasSuffix(".appex")<br/><br/>    /// The relevant DarwinNotification name to observe when the managed object context has been saved in an external process.<br/>    static var didSaveManagedObjectContextExternally: DarwinNotification.Name {<br/>        if appIsExtension {<br/>            return appDidSaveManagedObjectContext<br/>        } else {<br/>            return extensionDidSaveManagedObjectContext<br/>        }<br/>    }<br/><br/>    /// The notification to post when a managed object context has been saved and stored to the persistent store.<br/>    static var didSaveManagedObjectContextLocally: DarwinNotification.Name {<br/>        if appIsExtension {<br/>            return extensionDidSaveManagedObjectContext<br/>        } else {<br/>            return appDidSaveManagedObjectContext<br/>        }<br/>    }<br/><br/>    /// Notification to be posted when the shared Core Data database has been saved to disk from an extension. Posting this notification between processes can help us fetching new changes when needed.<br/>    private static var extensionDidSaveManagedObjectContext: DarwinNotification.Name {<br/>        return DarwinNotification.Name("com.wetransfer.app.extension-did-save")<br/>    }<br/><br/>    /// Notification to be posted when the shared Core Data database has been saved to disk from the app. Posting this notification between processes can help us fetching new changes when needed.<br/>    private static var appDidSaveManagedObjectContext: DarwinNotification.Name {<br/>        return DarwinNotification.Name("com.wetransfer.app.app-did-save")<br/>    }<br/>}</span></pre><p id="e2a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们可以开始观察应用扩展的变化:</p><pre class="kj kk kl km gt nq lu nr ns aw nt bi"><span id="935e" class="mz md it lu b gy nu nv l nw nx">extension NSPersistentContainer {<br/>    // Configure change event handling from external processes.<br/>    func observeAppExtensionDataChanges() {<br/>        DarwinNotificationCenter.shared.addObserver(self, for: .didSaveManagedObjectContextExternally, using: { [weak self] (_) in<br/>            // Since the viewContext is our root context that's directly connected to the persistent store, we need to update our viewContext.<br/>            self?.viewContext.perform {<br/>                self?.viewContextDidSaveExternally()<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="c635" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是要知道，只有当你的应用程序实际上在后台活动时，才会收到这些通知。当你的应用程序刚刚打开时，它显然会获取数据，而这整个通知甚至是不需要的。</p><p id="0464" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一个必需的步骤是实际刷新数据。这带来了一些你需要考虑的副作用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a24" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">保持数据同步</h1><p id="3a6a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在WeTransfer，我们首先简单地调用视图上下文中的<a class="ae lq" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/1506217-refreshallobjects" rel="noopener ugc nofollow" target="_blank">refreshalobjects()</a>来刷新所有注册的对象。这通常足以更新您的数据，但有一个轻微的副作用需要考虑。</p><p id="8c35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/1506875-stalenessinterval" rel="noopener ugc nofollow" target="_blank">失效间隔</a>用于确定一个对象是否真的需要刷新，或者是否可以重用任何可用的缓存数据。该到期值基于每个对象应用，默认情况下设置为-1。这意味着默认情况下，注册的对象根本不会被刷新。</p><p id="1e47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们采用了以下刷新方法:</p><pre class="kj kk kl km gt nq lu nr ns aw nt bi"><span id="8c98" class="mz md it lu b gy nu nv l nw nx">extension NSPersistentContainer {<br/><br/>    /// Called when a certain managed object context has been saved from an external process. It should also be called on the context's queue.<br/>    func viewContextDidSaveExternally() {<br/>        // `refreshAllObjects` only refreshes objects from which the cache is invalid. With a staleness intervall of -1 the cache never invalidates.<br/>        // We set the `stalenessInterval` to 0 to make sure that changes in the app extension get processed correctly.<br/>        viewContext.stalenessInterval = 0<br/>        viewContext.refreshAllObjects()<br/>        viewContext.stalenessInterval = -1<br/>    }<br/>}</span></pre><p id="a8bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们会在之后立即重置陈旧时间间隔，以确保我们能够从之后的缓存中受益。这就是我们保持我们的应用和它的扩展之间的数据最新所需要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="960f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="d532" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如今使用核心数据比以前容易多了。希望有了这些提示，您也能设法让您的数据与您的扩展同步。</p><p id="1c78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您需要调试任何核心数据问题，您可能想要查看我的博客文章<a class="ae lq" href="https://www.avanderlee.com/debugging/core-data-debugging-xcode/" rel="noopener ugc nofollow" target="_blank">“使用启动参数在Xcode中调试核心数据”</a>。</p></div></div>    
</body>
</html>