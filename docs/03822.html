<html>
<head>
<title>Angular Isn’t Reactive Enough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度不够敏感</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-isnt-reactive-enough-70b6b8d6cf8?source=collection_archive---------11-----------------------#2020-03-06">https://betterprogramming.pub/angular-isnt-reactive-enough-70b6b8d6cf8?source=collection_archive---------11-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有一个非常令人沮丧的bug一直出现在Angular应用程序中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4ce6ca84e232b24a239b021cae06aa13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8bR2cyjPrQc-h2Tk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@lanceanderson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">兰斯·安德森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="134b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意以下错误之间的共性:</p><ul class=""><li id="67cc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当用户收到新邮件时，未读邮件计数不会更新。</li><li id="5554" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当用户加载以前的配置时，背景颜色不会更新。</li><li id="1387" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当介质状态改变时，图标不会更新。</li><li id="92b7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">EndDate</code>当用户将查询参数更改为<code class="fe mj mk ml mm b">type=duration</code>时，不会禁用输入。</li><li id="b0bf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当用户订阅新队列时，他们仍然只能获得以前队列的通知。</li></ul><p id="3fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么共性？都可以放入公式“__不更新时___”换句话说，“___没有对__”做出反应。</p><p id="a081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你看够了这些令人沮丧的bug，你就会开始意识到它们只是出现在不同地方的同一个bug。越是事件驱动和数据丰富的应用程序，这个错误就越明显。</p><p id="63c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何摆脱这个bug？通过反应式思考:如果一个特性最初是反应式连接的，那么任何新的事件或行为都应该无缝连接，而不必重新管理现有的行为。</p><p id="045b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是Angular并不总是让我们容易做到这一点。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5404" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">角度:必要的部分</h1><p id="fdf3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">不幸的是，Angular中仍然有许多命令式API，使得开发人员不再被动地思考。因此，这种强制性的错误往往会出现在围绕这些API的代码中。这里有一些我认为可以改进的地方。</p><h2 id="2edf" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">角反应形式</h2><p id="6dc2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">大约一年前，我被分配去修复一个大型表单上的几个错误，这个表单是用角反应式表单构建的。过了一会儿，我开始感觉到一些我从jQuery时代就没有感觉到的东西。我突然意识到代码和jQuery是多么的相似。事实上，只要做一些表面上的改变，它就会是一样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5beab7d9223e4b56d7da827ed325d42e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*LQpwvtrFjy7519Ll6gbBwA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">jQuery的角度反应形式。</p></figure><p id="3c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我很难过。你看，我已经爱上了更新UI的"<a class="ae ky" href="https://css-tricks.com/animations-the-angular-way/" rel="noopener ugc nofollow" target="_blank">棱角分明的方式</a>。我喜欢这种自动的感觉。我不必担心UI的所有部分会因为发生的每一个小事件而更新。我可以在控制器中设置一个变量，让DOM中的各种元素自己做出反应。</p><p id="ab08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我必须修复的错误几乎都是命令性错误。如果形体真的是反应性的，它们就不会存在。更重要的是，代码本身是杂乱的，有很多冗余，因为如果没有明确的状态管理，如果UI中的某些东西不同步，您可能会遇到麻烦。但是打个电话确认一下也无妨。</p><p id="09bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我不是唯一一个注意到反应形式需要帮助才能反应的人。其他开发人员<a class="ae ky" href="https://netbasal.com/disabling-form-controls-when-working-with-reactive-forms-in-angular-549dd7b42110" rel="noopener ugc nofollow" target="_blank">写了</a> <a class="ae ky" href="https://medium.com/@amcdnl/reactive-angular-forms-with-ngrx-533a2f28c127" rel="noopener">文章</a>解释如何创建指令，将反应式表单的命令式界面隐藏在声明式界面之后。受这些文章的启发，我为一些方法制定了指令，比如<code class="fe mj mk ml mm b">.disable()</code>和<code class="fe mj mk ml mm b">patchValue()</code>，我认为它们应该是反应式的。您可以使用以下指令绑定该属性，而不是在表单控件上调用<code class="fe mj mk ml mm b">.disable()</code>:</p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="e688" class="nr mv it mm b gy oi oj l ok ol">&lt;input <br/>  [formControl]="formControl" <br/>  <strong class="mm iu">[controlDisabled]="disabled$ | async"<br/></strong>/&gt;</span></pre><p id="3a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是该指令的实现，以及表单组的实现:</p><ul class=""><li id="6694" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://gist.github.com/mfp22/3d9a6a7695c31d031db95871ffc978cf" rel="noopener ugc nofollow" target="_blank">禁用-控制.指令. ts </a></li><li id="22b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://gist.github.com/mfp22/a4a3d43ebe3665697a7361e9f32a20f4" rel="noopener ugc nofollow" target="_blank">禁用表单组指令ts </a>。</li></ul><p id="bd7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些设置和修补值的指令:</p><ul class=""><li id="c592" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://gist.github.com/mfp22/12c0d3c56db06d526b0aae289823e347" rel="noopener ugc nofollow" target="_blank"> set-value.directive.ts </a></li><li id="fe57" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://gist.github.com/mfp22/2f2c47f630e3c7b6379503236745af4c" rel="noopener ugc nofollow" target="_blank">patch-form-group-values . directive . ts</a></li></ul><p id="9ac9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用这些来更相对地管理你的角度反应形式。希望将来我们会看到更多的工具。</p><h2 id="2385" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">生命周期挂钩</h2><p id="452e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">生命周期挂钩让您能够在Angular中对生命周期事件做出反应。但是默认的反应方式不是被动的。相反，您提供这些钩子强制调用的函数。</p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="bf90" class="nr mv it mm b gy oi oj l ok ol">ngOnDestroy() {<br/>  // Do imperative stuff<br/>}</span></pre><p id="80bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们又有好运气了，因为<a class="ae ky" href="https://twitter.com/esosanderelias" rel="noopener ugc nofollow" target="_blank"> Sander Elias </a>注意到了这个机会，并且已经创建了<a class="ae ky" href="https://www.npmjs.com/package/@se-ng/observable-hooks" rel="noopener ugc nofollow" target="_blank">一个库</a>，给你生命周期钩子作为观察对象。而不是这个:</p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="de41" class="nr mv it mm b gy oi oj l ok ol">ngOnChanges(changes: SimpleChanges) {<br/>  // Do imperative stuff<br/>}</span></pre><p id="b815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以这样做:</p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="9235" class="nr mv it mm b gy oi oj l ok ol">this.seOnChanges$.pipe(...)</span></pre><h2 id="1bba" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">组件输入</h2><p id="b300" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">分量输入是随时间变化的值，因此它们是可观测量的完美候选。不幸的是，应对这些变化的唯一方法也是必要的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="46ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想被动地做这件事，您可以再次使用Sander的<code class="fe mj mk ml mm b">seOnChanges$</code>来获得每个输入的可观察值:</p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="b69e" class="nr mv it mm b gy oi oj l ok ol">@Input() myInput: string;</span><span id="aef8" class="nr mv it mm b gy oo oj l ok ol">myInput$ = this.seOnChanges$.pipe(<br/>  filter(changes =&gt; changes.myInput),<br/>  map(changes =&gt; changes.myInput.currentValue),<br/>);</span></pre><p id="f315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我想要更直接的东西，所以我创建了<a class="ae ky" href="https://gist.github.com/mfp22/5f9717ff297deb69125afab8480eb65e" rel="noopener ugc nofollow" target="_blank">这个装饰器:</a></p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="c291" class="nr mv it mm b gy oi oj l ok ol">import { AsyncInput } from '@ng-reactive/async-input';<br/>...<br/>@Input() myInput: string;<br/>@AsyncInput() myInput$ = new BehaviorSubject('initial value');</span></pre><p id="0f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不能100%确定它已经准备好生产了，所以要小心使用。</p><p id="d237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前有很多关于这个主题的活动。看看Michael Hladky的ngrx/platform提案。<a class="ae ky" href="https://dev.to/stupidawesome/reactive-adventures-in-angular-introducing-angular-effects-1epf" rel="noopener ugc nofollow" target="_blank">这个</a>看起来也真有意思。</p><h2 id="4a63" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">材料成分</h2><p id="a5f5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Angular Material是一个非常令人印象深刻的组件库，每个组件作者都可以从中学习。但是，有一些组件带有命令式API:</p><ul class=""><li id="aa3f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://material.angular.io/components/bottom-sheet/overview" rel="noopener ugc nofollow" target="_blank"> MatBottomSheet </a></li><li id="3c2d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://material.angular.io/components/dialog/overview" rel="noopener ugc nofollow" target="_blank"> MatDialog </a></li><li id="d061" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://material.angular.io/components/snack-bar/overview" rel="noopener ugc nofollow" target="_blank"> MatSnackBar </a></li></ul><p id="9454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这些强制性接口，我们不得不在手动订阅中强制性地管理这些组件，而不是被动地用异步管道绑定数据。这种必要性使得某些更新在复杂的对话框中很容易被忽略。</p><p id="200f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为MatDialog创建了一个带有声明性接口的包装组件。现在，不是做:</p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="8eee" class="nr mv it mm b gy oi oj l ok ol">this.dialog.open(AnyComponent)</span></pre><p id="ed03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你只需要:</p><pre class="kj kk kl km gt oe mm of og aw oh bi"><span id="522c" class="nr mv it mm b gy oi oj l ok ol">&lt;app-dialog <br/>  [component]="AnyComponent" <br/>  <strong class="mm iu">[open]="open$ | async"<br/></strong>&gt;&lt;/app-dialog&gt;</span></pre><p id="82fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个地方，当<code class="fe mj mk ml mm b">open$</code>发出<code class="fe mj mk ml mm b">true</code>或<code class="fe mj mk ml mm b">false</code>时，它会自动打开和关闭。<a class="ae ky" href="https://gist.github.com/mfp22/479a6860510286e69d9cb7ea3a448d5e" rel="noopener ugc nofollow" target="_blank">这里是该对话框的代码</a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a01a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="b15e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Web开发变得越来越事件驱动和数据丰富，正因为如此，我们的代码需要变得越来越被动。随着我们越来越习惯于反应式思维，我们将会看到更多的机会来改进命令式API，避免命令式bug，并加速开发。</p><p id="2e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且，希望有一天，我们将不再看到这么多的错误报告说，“当___时___没有更新。”</p></div></div>    
</body>
</html>