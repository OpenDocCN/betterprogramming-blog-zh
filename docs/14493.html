<html>
<head>
<title>Why You Should Use Islands Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该使用岛屿架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-use-islands-architecture-b4f291708a02?source=collection_archive---------0-----------------------#2022-12-26">https://betterprogramming.pub/why-you-should-use-islands-architecture-b4f291708a02?source=collection_archive---------0-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e6d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对前端开发未来的一瞥</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd806dbf0ee09940e01551881f81c6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7JIFrazcz1fFNGo2uAP9w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">静态HTML海洋中的动态JS岛。<a class="ae ky" href="https://www.fodors.com/news/photos/11-philippines-islands-that-should-be-on-your-bucket-list" rel="noopener ugc nofollow" target="_blank">原始来源</a></p></figure><p id="a0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2013年，脸书支持的React进入了web开发领域，改变了我们呈现web应用程序的方式。开发人员可以使用React创建单页面应用程序(spa)并在客户端呈现它们，而不是在服务器上呈现页面并将它们发送到客户端。随着像React这样的工具越来越受欢迎，客户机呈现的SPAs很快取代了它们的老亲戚，服务器呈现的多页面应用程序。</p><p id="5109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法革新了现代前端设计。然而，它并不是没有性能缺陷。当像React、Vue和Angular这样的SPA框架开始统治web时，狡猾的小bug-as-features和糟糕的做法溜进了大多数新应用程序，并变得更糟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/a58a9927212c5d9dd3af8173faf8897a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YVRWnEERbp9l1JLy.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">spa推翻了传统的服务器渲染的MPAs。<a class="ae ky" href="https://www.excellentwebworld.com/what-is-a-single-page-application/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="24ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在2019年的一次会议上，Etsy前端建筑师凯蒂·西勒-米勒提出了岛屿建筑的想法。Islands Architecture通过将静态内容加载到服务器上的HTML中，同时利用服务器和客户端来呈现应用程序，但是为交互式区域创建占位符，稍后由客户端使用JavaScript进行补充。作为一名开发人员，我确信这个想法将催生下一代前端框架。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/df12ba7573955925f3aa157b5ea9a837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ECcGUG5l3SSTS_9F.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯蒂·塞勒-米勒在演出上讲话。<a class="ae ky" href="https://www.youtube.com/watch?v=qts9gPYoANU" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h2 id="95dc" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">先决条件</h2><p id="91d9" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在我们深入研究web架构之前，让我们先来看看一些重要的关键术语。</p><ol class=""><li id="e43a" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">最大内容绘画(LCP) —这是加载页面主要内容所需的时间。</li><li id="64de" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">首字节时间(TTFB) —这是加载时响应的首字节从服务器到达浏览器所需的时间。</li><li id="ad34" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">第一个内容绘制(FCP) —这是第<em class="nj">个</em>内容呈现在页面上所花费的时间。</li><li id="a0ab" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">第一次输入延迟(FID)——这是当用户<em class="nj">第一次</em>与网页交互时，网页响应所需的时间。</li><li id="3d52" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">互动时间(TTI) —这是网页在其主要资源加载后变得可靠互动所需的时间。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/dd538c9809f213cd4ceb57cd1e56d0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zOGjbTCFgYHoDERV.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">核心网站是LCP、FID和CLS。<a class="ae ky" href="https://akshayranganath.github.io/Understanding-And-Using-Core-Web-Vitals/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="c5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有内容的绘画和第一次输入延迟都被认为是核心网站的要害(第三个是<a class="ae ky" href="https://web.dev/vitals/" rel="noopener ugc nofollow" target="_blank"> CLS </a>)。如果网页的主要内容加载时间少于2.5秒(LCP)，则认为该网页是高性能的。第一个内容的加载时间(FCP)和第一个字节从服务器到达的时间(TTFB)与LCP直接相关。</p><p id="dbaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网页的第一次输入延迟应该保持在100毫秒以下，以保持良好的用户体验。这一指标直接受到主要资源中的交互性加载和可靠工作所需时间的影响(TTI)。</p><p id="d0c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中讨论的关于架构的决策涉及权衡。一个页面可能加载得更快(更好的FCP/TTFB/LCP)，但需要更长的时间才能变成交互式的(更高的TTI/FID)，反之亦然。</p><h1 id="4e72" class="nk ly it bd lz nl nm nn mc no np nq mf jz nr ka mi kc ns kd ml kf nt kg mo nu bi translated">我们是如何来到这里的</h1><p id="7760" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">从根本上说，这一SPA收购是由早期web服务器端呈现(SSR)模式中预先存在的问题促成的。SSR在web开发的早期风靡一时。老实说，当时没有太多选择。有了React和其他SPA框架，客户端呈现(CSR)成为处理网页中JavaScript的新的主导方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/0c94713f812768cd4b0b9bc0bcb89bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RR2FaamK-EWalvKA.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务器端渲染被搁置了。</p></figure><p id="f838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在走出一个神奇药丸解决方案的时代，在这个时代，每个人都希望答案是坚定、明确和简单的。CSR提供了一种避免不断向服务器发送pings和整页重载的方法，但它也带来了一系列问题。现实和网络架构往往需要比我们所希望的更多的细微差别。让我们来看看SSR、CSR，看看我们能否解开每种方法中隐藏的问题。</p><h2 id="736f" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">服务器端呈现(SSR)</h2><p id="ae4a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在我们深入客户端渲染之前，让我们先来看看SSR。服务器端呈现是交付web内容的久经考验的版本。使用SSR，整个HTML网页在服务器上生成，然后发送到请求页面的客户端。这意味着呈现视图的逻辑在服务器上执行。如果需要来自数据库或第三方API的数据，则在交付页面之前，会在服务器上处理这些数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/6a3deef26b3738dfccb5be3ecb30cf5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yIiKTE7kIeaUSjBR.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在SSR中，服务器处理构建前端的逻辑。<a class="ae ky" href="https://www.tothenew.com/blog/server-side-rendering-vs-static-site-generation-in-next-js/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="ad9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着在从服务器收到响应后，客户端浏览器只需处理很少或不需要处理JavaScript。应用程序逻辑的繁重工作已经完成——服务器为客户端完成了这项工作。</p><h2 id="a0e3" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">客户端渲染(CSR)</h2><p id="c4ef" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">客户端呈现采用了不同的方法。有了CSR，服务器在网页渲染中就退居二线了。呈现应用程序的逻辑(包括获取或路由)被委托给前端。如果您曾经使用ReactDOM将整个React App组件附加到单个<code class="fe nx ny nz oa b">&lt;div&gt;</code>或<code class="fe nx ny nz oa b">&lt;main&gt;</code>标签，那么您已经使用CSR构建了应用程序。</p><pre class="kj kk kl km gt ob oa oc bn od oe bi"><span id="6fe8" class="of ly it oa b be og oh l oi oj">// Forcing the browser to do all the work, huh?<br/>const root = ReactDOM.createRoot(document.getElementById('root'));<br/>root.render(&lt;App /&gt;); </span></pre><p id="f310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在CSR中，大量的JavaScript可以被运送到客户端。将整个应用程序的逻辑放到浏览器中并不少见。这在前端教程视频中也很常见，这些视频没有突出CSR的优化技术。</p><h1 id="b5fd" class="nk ly it bd lz nl nm nn mc no np nq mf jz nr ka mi kc ns kd ml kf nt kg mo nu bi translated">SSR与CSR</h1><p id="4c36" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">那么，SSR vs CSR，哪个更好呢？尽管这两种方法在一些比较点上显示了它们不同的优势，但两者都有权衡。</p><h2 id="7e0c" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">搜索引擎优化</h2><p id="f116" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">构建web应用程序时，搜索引擎优化是一个重要的考虑因素。毕竟，你不会为了让代码看起来漂亮而建立一个网站，并在Github repo中收集灰尘。你建立了一个工具供其他人使用，人们找到你的工具的一个主要途径是通过搜索引擎。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b8a3c67cfe474d161efe0e4add6b67c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JHVwUKKQ7tpHs6iX.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不优先考虑SEO，就没有用户。<a class="ae ky" href="https://hookagency.com/blog/seo-content-marketing-memes/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="b477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的网站没有进行搜索引擎优化，你会发现用户流量比其他情况下少得多。默认情况下，通过SSR呈现的应用程序是搜索引擎优化的；服务器呈现的网站很容易被搜索引擎解读。而CSR则不然。客户端呈现的应用程序不会从服务器呈现的应用程序加载发送。浏览器在处理页面时会加载页面的各个部分。有时，这会导致内容被网络爬虫遗漏。虽然有变通办法，但大多数CSR应用程序并没有针对搜索引擎进行高度优化。</p><h2 id="07ab" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">装货</h2><p id="2068" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在SSR和CSR之间有一个明显的负载权衡。每一个都在特定领域胜过另一个。</p><p id="fc06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SSR在呈现初始页面方面非常出色。当用户请求您的站点时，服务器将构建HTML表示，然后将其发送回客户端浏览器。如果您有一个包含大量逻辑和元素的复杂应用程序，SSR会大放异彩。在这种情况下，FCP和TTI的下载量大幅下降(初始内容加载和初始交互性都达到得更快)。</p><p id="d038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当用户决定继续与网页交互时，SSR就没有了。最初的负荷是它的决定性时刻。当用户浏览您的站点时，将会出现对下一个页面的服务器执行ping操作的相同过程，这意味着加载任何页面都和加载第一个页面一样痛苦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2afaa76d8d0c4a73b7eba4afb8e2a942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l_XcU1Rsgjrh5Zae.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CSR和SSR有不同的优势——这不是一个非此即彼的决定。<a class="ae ky" href="https://www.growth-rocket.com/blog/a-closer-look-at-client-side-server-side-rendering/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="85be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CSR颠倒了这个脚本:由于CSR将大量JavaScript加载到浏览器中，特别是在没有尝试优化的情况下，网页的初始加载在计算时间上可能会非常慢。然而，因为整个网站被发送到客户端，包括网站的可导航路线(这是使其成为“单个页面”)的原因，所以当用户在网站的各个页面之间移动时，将享受更平滑的体验。</p><p id="d112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在服务器过载或网络运行缓慢的情况下，SSR也可能增加包含HTML页面的初始响应的时间(更高的TTFB)。这可能会抵消其从下FCP/TTI的收益。</p><h2 id="153c" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">交互性</h2><p id="3fe7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">因为服务器处理SSR中的应用程序逻辑，所以交互可能是昂贵的。每当用户希望与纯粹由服务器提供的应用程序进行交互时，浏览器就必须与服务器进行通信。不断向后端发送pings命令并重新加载整个页面来处理交互性，尤其是在基础设施已经超负荷的情况下，会导致处理用户请求的延迟。毕竟，页面是由服务器构建的。如果内容发生变化，网页需要重建，整个页面可能需要重建。</p><p id="77de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，CSR很好地处理了大多数交互性。应用程序逻辑在前端处理——服务器不需要ping来处理每一个用户交互。然而，这种模式也有缺点。最初可能不会将数据加载到页面中，而是在用户与页面交互时请求数据。这需要pings服务器，这可能会增加用户交互的加载时间。</p><h1 id="4799" class="nk ly it bd lz nl nm nn mc no np nq mf jz nr ka mi kc ns kd ml kf nt kg mo nu bi translated">增加渲染的独创性</h1><p id="b8cc" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">真正的问题不是“SSR还是CSR？”相反，我们应该问“为什么不两者都要呢？”如果这两种方法都有优点，我们可以找到一种方法来结合它们的优点，创造出全新的、改进的工具。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0a7121a939536f88ff58fe0261198586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jd849mdSEUW2U6ds"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不一定要吵架。<a class="ae ky" href="https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8" rel="noopener">来源</a></p></figure><p id="a15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，用纯JavaScript或JSX将整个前端交付给浏览器是不明智的做法，尤其是对于大型应用程序。将所有的代码和所有的依赖打包并把这些逻辑推到浏览器上是没有效率的，浏览器必须构建一个实际的HTML网页。</p><p id="5334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让服务器构建整个页面显然也不是最高效的。当每次用户交互都需要返回到服务器时，你就没有充分利用现代浏览器的全部功能，而且不耐烦的用户也不太可能在每次想要切换页面时等待响应。</p><p id="4957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么不把这两种方法结合起来呢？如果我们充分利用SSR和CSR的优势，通过用一方的优势覆盖另一方的弱点来最小化各自的缺点，我们就可以找到一种同时战胜两者的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/e9c64ff90c449e962e022bdd49210a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aZOMPm97kaNMCEOv.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过结合SSR和CSR获得两个世界的最佳效果。<a class="ae ky" href="https://www.patterns.dev/posts/rendering-patterns/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发者就是这么做的。水疗出现后，涌现出多种新方法，试图利用每种方法的最佳部分。静态生成在构建站点时创建一个预定义的HTML页面，并根据请求立即提供该页面。流式SSR允许服务器构建网站，但将其响应流式传输到浏览器，以获得更快的FCP和TTFB。选择性水合(如React 18中)允许服务器构建整个页面，然后让客户端回溯以选择性水合交互性节点。然而，最新和最具创新性的方法是岛屿建筑。</p><h1 id="a4b8" class="nk ly it bd lz nl nm nn mc no np nq mf jz nr ka mi kc ns kd ml kf nt kg mo nu bi translated">岛屿建筑</h1><p id="0ac3" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">Islands架构背后的想法很简单——在服务器上呈现HTML页面及其静态内容，并在页面内为动态内容创建占位符。这些占位符(或“岛”)然后可以由客户选择性地水合。更好的是，客户机可以使用服务器在这些占位符中呈现的初始HTML。HTML主干与随岛屿一起发送的脚本混合在一起。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7de9a1001c02612424a6d44c4c66d4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*S6k-fkg0kh191EE6.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我不是说有正确的方法，但是…</p></figure><p id="af21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有意识到这一点，这意味着实际上只有很少的JavaScript被发送到客户端。您避免了CSR的一个常见陷阱——您不需要将整个前端逻辑都传送到浏览器。服务器能构造什么——它就构造什么——剩下的留给HTML框架和脚本。这意味着您可以从服务器端渲染获得更低的LCP和更低的TTI，从使用CSR构建的spa获得更快的交互性和导航。</p><p id="fde1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些动态区域都是独立的。一个地区的性能问题不会影响其他地区的性能。这样，这些岛屿就像是它们自己的应用程序。这是看待应用程序的一种全新方式，性能优势几乎还没有被发现。只有少数框架已经开始采用这种思想。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/92b8048e8c7449cdd06b769585ff8387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6OK1RNU8wOeK2r92.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Astro提供了利用岛屿架构的现成方法。<a class="ae ky" href="https://blog.logrocket.com/understanding-astro-islands-architecture/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有Marko，一个由易贝开发的框架，一旦准备好就将静态内容流式传输到浏览器，并且只提供带有动态岛的水合代码。或者您可以探索Astro，它是框架不可知的——您可以将它与React、Vue、Svelte等等一起使用。Astro islands允许您使用如下简单的代码片段来指示哪些组件是客户端加载的:</p><pre class="kj kk kl km gt ob oa oc bn od oe bi"><span id="c5aa" class="of ly it oa b be og oh l oi oj">&lt;MyComponent client:load /&gt;</span></pre><p id="5207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于其他运行时环境，也有其他的框架。一个很好的例子是Fresh，它是Deno的一个前端框架，专门针对孤岛架构而构建。我真的相信这些框架，以及它们的性能优势，将会迅速改变前端开发生态系统。</p><p id="06bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解更多关于前端架构的知识，我强烈推荐您浏览一下<a class="ae ky" href="https://www.patterns.dev/" rel="noopener ugc nofollow" target="_blank"> patterns.dev </a>，它会更深入地探讨这些主题。</p></div></div>    
</body>
</html>