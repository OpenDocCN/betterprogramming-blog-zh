<html>
<head>
<title>Building a Load Balancer in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建负载平衡器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-load-balancer-in-go-3da3c7c46f30?source=collection_archive---------1-----------------------#2022-02-25">https://betterprogramming.pub/building-a-load-balancer-in-go-3da3c7c46f30?source=collection_archive---------1-----------------------#2022-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db02" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Go设置一个<em class="kf">负载平衡代理服务器</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/75c3c5b9ac688bf66fcb38be06980f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ei6vnOcvX73EByRduzTJlQ.jpeg"/></div></div></figure><h1 id="881b" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">什么是负载平衡器？</h1><p id="6671" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">负载平衡器是一种常见的<em class="mg">代理服务器</em>形式，它在一个或多个将执行实际工作的后端服务器之间分发客户端请求。</p><p id="6f1a" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated"><em class="mg">代理</em>是一些其他实体的替身——它可以表现得像其他实体，或者代替其他实体。在(web)软件中，我们通常将代理视为网络中的一个节点，它本质上是在客户端和后端服务器之间转发请求和响应。如果我去一个朋友家，通过他们的门铃和他们说话，那个门铃就充当了我们之间的代理人。同样，<em class="mg">代理服务器</em>提供了<em class="mg">客户端</em>(我)和某个<em class="mg">后端服务器</em>(我的朋友)之间的网关。像门铃一样，充当中介；我可以向服务器发出请求(与我的朋友交谈),而无需获得访问该服务器资源的特权(进入房间)。</p><p id="00d6" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">代理服务器可以为互联网系统提供额外的安全性、性能和可观察性。</p><p id="6e13" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">今天，我们将使用Go构建一个负载平衡代理服务器。</p><h1 id="18dc" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">构建服务器</h1><p id="7a8b" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我们将从定义一个<code class="fe mm mn mo mp b">LoadBalancer</code>开始——这个对象将包含关于服务器的基本信息，包括将处理代理请求的后端服务器，以及负载平衡器将监听的端口。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5340" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">通过包含一系列的<code class="fe mm mn mo mp b">Server</code>——一个代表一组功能的接口——而不是一个硬编码的类型，我们可以将这个负载平衡器与实现基本<code class="fe mm mn mo mp b">Server</code>接口的各种对象一起使用，而不必改变底层代码。为了清楚起见，我们还包含了一个构造函数(<code class="fe mm mn mo mp b">NewLoadBalancer</code>，但是我们也可以直接构造<code class="fe mm mn mo mp b">LoadBalancer</code>。</p><p id="4eef" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">我们现在需要一个实现<code class="fe mm mn mo mp b">Server</code>接口的对象:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5cc2" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">没有错误处理的代码有什么用？对于这个例子，我们将做一个非常简单的表单——如果我们看到一个错误，保释！</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e793" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">接下来，我们将编写一个助手来实例化我们的服务器。这段代码将获取一个地址，并创建一个新的具有<code class="fe mm mn mo mp b">proxy</code>的<code class="fe mm mn mo mp b">simpleServer</code>实例。我们将使用代理来处理我们希望发送到该服务器的任何请求。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="eb01" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">现在，让我们设置我们的<code class="fe mm mn mo mp b">main</code>函数来启动负载平衡器。我们将配置它来处理任何进来的请求，我们将监听为这个<code class="fe mm mn mo mp b">LoadBalancer</code>定义的<code class="fe mm mn mo mp b">port</code>。我们将定义几个<code class="fe mm mn mo mp b">simpleServer</code>实例。<code class="fe mm mn mo mp b">addr</code>是我们将请求重定向到的URL。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cbe4" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">好了，我们已经配置好了服务器的基本结构，以及我们需要的大部分部件。最后一步是定义当我们的<code class="fe mm mn mo mp b">LoadBalancer</code>收到请求时会发生什么。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="94ca" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">我们使用<code class="fe mm mn mo mp b">getNextAvailableServer()</code>通过某种负载平衡算法来确定哪个<em class="mg">后端服务器</em>最适合处理我们的请求(在这种情况下，我们使用一个与健康检查配对的循环法)。一旦我们知道将请求转发到哪个服务器，我们就在该服务器的<em class="mg">代理</em>上发出请求。<em class="mg">代理</em>会将客户端的请求路由到目标，并将目标的响应返回给客户端。</p><p id="1fcb" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">现在剩下要做的就是运行服务器并发出请求！</p><h1 id="570a" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">运行服务器</h1><p id="d38e" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">你可以从<a class="ae ms" href="https://github.com/swayne275/load-balancer-proxy" rel="noopener ugc nofollow" target="_blank"> my GitHub </a>中克隆完整代码，或者按照本教程生成。</p><p id="69dd" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">获得服务器代码后，在终端窗口中导航到该目录并键入<code class="fe mm mn mo mp b">go run src/main.go</code>。您应该看到终端输出表明服务器正在运行。</p><p id="36aa" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">现在，您可以在浏览器中转到<code class="fe mm mn mo mp b">localhost:8000</code>，您应该会被重定向到<code class="fe mm mn mo mp b">servers</code>中定义的一个地址。刷新时，负载平衡器代理服务器会将您重定向到定义的各个URL。</p><p id="0b8c" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">请注意，您的浏览器可能会记住<code class="fe mm mn mo mp b">localhost:8000</code>和一个给定的服务器地址之间的标识，因此使用匿名窗口可能会更好。还要注意，已定义的链接可能会也可能不会从它们各自的主机中给你一个错误(例如，在<code class="fe mm mn mo mp b"><a class="ae ms" href="https://google.com" rel="noopener ugc nofollow" target="_blank">https://google.com</a></code>转到<code class="fe mm mn mo mp b">/</code>会产生一个错误)。</p><p id="619f" class="pw-post-body-paragraph lk ll iq lm b ln mh jr lp lq mi ju ls lt mj lv lw lx mk lz ma mb ml md me mf ij bi translated">祝你旅途愉快！</p></div></div>    
</body>
</html>