<html>
<head>
<title>Data Science and Kotlin — Introducing Dataframes With Krangl</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学和kot Lin——用Krangl介绍数据框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-science-kotlin-introducing-dataframes-with-krangl-c9cdd97e449c?source=collection_archive---------3-----------------------#2022-12-15">https://betterprogramming.pub/data-science-kotlin-introducing-dataframes-with-krangl-c9cdd97e449c?source=collection_archive---------3-----------------------#2022-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Kotlin语言和<strong class="ak"> <em class="ki"> Krangl </em> </strong>库创建、导入和导出数据帧的实践介绍</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/94cf64f35bc7dfefa701614b2de29051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WeXLcVSj1Rtm-LUAduIUA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">运行在Jupyter实验室上的Kotlin和Krangl代码(图片由作者提供)</p></figure><p id="4274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python通常是数据科学项目的参考语言，尤其是机器学习。但是，这并不意味着在开始自己的项目时，您应该强制使用Python。您团队的专业知识和背景，以及其他一些环境限制，应该会影响您选择的技术堆栈。</p><p id="ab40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于这一点，<a class="ae lv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>对于那些基于JVM的环境来说是一个有吸引力的选择，在这些环境中，数据科学活动将被实现。从构建数据管道到生产机器学习模型，<a class="ae lv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>覆盖了大部分需求，这要归功于一个伟大的生态系统，它为数据帧操作、数据可视化、深度学习或自然语言处理等提供了解决方案。</p><p id="81d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍如何使用<a class="ae lv" href="https://github.com/holgerbrandl/krangl" rel="noopener ugc nofollow" target="_blank"> Krangl </a>处理数据框架，这是一个用于数据辩论的Kotlin库。</p><h1 id="7b81" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">环境</h1><p id="1926" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">本分步指南是根据以下要求编写的:</p><ul class=""><li id="5d81" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">操作系统:MacOS蒙特雷12.5.1</li><li id="1757" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Docker社区:v.20.10.2 for Mac ( <a class="ae lv" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank">如何安装docker </a>)</li><li id="1aed" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">采用Kotlin内核的Jupyter笔记本:(<a class="ae lv" href="https://migueldoctor.medium.com/how-to-create-a-docker-image-with-jupyter-notebook-kotlin-2e8bbf212f81" rel="noopener">如何安装</a>)</li></ul><h1 id="bee4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">目标</h1><p id="8311" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">本教程旨在介绍使用<a class="ae lv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>语言和<a class="ae lv" href="https://github.com/holgerbrandl/krangl" rel="noopener ugc nofollow" target="_blank"> Krangl </a>库进行表格数据操作。也就是说，这篇文章关注于使用dataframes创建、导入和导出数据，这是当前数据分析方法背后的核心概念。</p><p id="69a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们简单介绍一下我们将要探索的概念和技术:</p><p id="3df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据帧:</strong>数据帧被定义为具有潜在不同类型的列的二维标记数据结构。这些结构的每一行对应于实例的度量或值，而每一列是包含特定变量数据的向量。这意味着dataframe的行不需要包含，但可以包含相同类型的值:它们可以是数字、字符、逻辑等。</p><p id="655a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae lv" href="https://github.com/holgerbrandl/krangl" rel="noopener ugc nofollow" target="_blank"> Krangl </a>是一个用于数据传输的开源otlin库。Krangl深受其他语言库的启发，如<a class="ae lv" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a> (Python)和<a class="ae lv" href="https://dplyr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> dplyr </a> (R)。Krangl是用Kotlin编写的，这使得它可以与Java完全互操作，并且它依赖于使用函数式实现的数据操作语法。通过这种方式，以dataframes的形式操作表格数据变得非常容易。Krangl提供了方便的方法，允许数据科学家过滤、转换、聚合和重塑他们的数据，以准备好为任何机器学习模型提供数据。</p><h1 id="8087" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">将Krangl库导入Jupyter</h1><p id="415a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要在Jupyter笔记本上使用Krangl，我们通常会开始将库添加到项目中。在下面的脚本中，我们提供了两个选项来指示Jupyter将Krangl依赖项添加到当前的笔记本中。</p><ul class=""><li id="6b2e" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">Magic command (%use):只有Kotlin内核内置库有效。支持的内置库和版本的完整列表可以在这里找到:<a class="ae lv" href="https://github.com/Kotlin/kotlin-jupyter" rel="noopener ugc nofollow" target="_blank">https://github.com/Kotlin/kotlin-jupyter</a>。</li><li id="45cf" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">动态依赖项导入注释:这种技术允许导入任何库，只要提供了存储库和组工件版本id。</li></ul><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="d4df" class="nm lx it ni b be nn no l np nq">//1) Import krangl library using magic command (%use). <br/>%use krangl<br/><br/>//2) Import a specific version (0.18.4) of the krangl library<br/>@file:Repository("https://repo1.maven.org/maven2")<br/>@file:DependsOn("com.github.holgerbrandl:krangl:0.18.4")</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nr"><img src="../Images/9e5ffaba4d749f9f9594a8f64113b69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q28PnkVKdqdd_7PCrofamw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">将克朗格语添加到Jupyter笔记本中(图片由作者提供)</p></figure><p id="bb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确配置好Krangl之后，我们就可以开始处理数据了。本文的其余部分将着重于创建数据框，这是大多数数据科学项目中的主要数据结构。</p><h1 id="6d23" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">用Krangl创建数据框</h1><p id="3d03" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Krangl允许我们通过使用函数<code class="fe ns nt nu ni b">emptyDataFrame</code>轻松创建一个空的数据帧。</p><h2 id="5da7" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">1.使用<strong class="ak"><em class="ki">empty data frame</em></strong>函数创建一个空数据帧</h2><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="69b3" class="nm lx it ni b be nn no l np nq">var df1:DataFrame = emptyDataFrame()</span></pre><h2 id="b2ba" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">2.使用<strong class="ak"> <em class="ki"> dataFrameOf </em> </strong>函数创建一个带有预定义行的数据帧</h2><p id="d6b4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">创建空的数据帧不是很有用。因此，Krangl提供了通过<a class="ae lv" href="https://kotlinlang.org/docs/reflection.html" rel="noopener ugc nofollow" target="_blank">反射</a>将任何可迭代对象转换成dataframe对象的便利方法。以下脚本说明了如何将地图用作dataframe行，并与<code class="fe ns nt nu ni b">dataFrameOf </code>函数结合使用，以创建具有预定义内容的dataframe对象。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="108b" class="nm lx it ni b be nn no l np nq">// We can create DataFrameRow objects using mapOf kotlin function. <br/>// The key of each map entry will become the column name of the row<br/>val row = mapOf("name" to "Miguel", <br/>                "surname" to "Doctor Yuste",<br/>                "age" to 37) as DataFrameRow<br/><br/>val row2 = mapOf("name" to "User", <br/>                 "surname" to "Doe",<br/>                 "age" to 45) as DataFrameRow<br/><br/>// After creating some rows they can be wrapped into a list<br/>val listOfRows = listOf(row,row2)<br/><br/>// Finally the list is wrapped up into a dataFrame using the Krangl function dataFrameOf <br/>// that can be included into the empty dataframe created before<br/><br/>val df2:DataFrame = dataFrameOf(listOfRows)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/19b4e0e29c4b8babe3644fb3a756120c.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*rPbIel-DGsAofuvRYUlDuQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">上面的脚本产生的输出(图片由作者提供)</p></figure><h2 id="4ff2" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">3.使用<strong class="ak">绑定行</strong>向空数据帧添加行</h2><p id="106b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Krangl API提供了<code class="fe ns nt nu ni b">bindRows</code>函数。该方法旨在组合数据帧，以便可以用于向现有数据帧添加新行。如果出现不匹配的列，这些列将在返回的数据帧上用NA填充。下面看看<code class="fe ns nt nu ni b">bindRows</code>是怎么工作的。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="5d27" class="nm lx it ni b be nn no l np nq">var df3:DataFrame = emptyDataFrame()<br/><br/>// We can create DataFrameRow objects using mapOf kotlin function. <br/>// The key of each map entry will become the column name of the row<br/>val row = mapOf("name" to "Miguel", <br/>                "surname" to "Doctor Yuste",<br/>                "age" to 37) as DataFrameRow<br/><br/>val row2 = mapOf("name" to "User", <br/>                 "surname" to "Doe",<br/>                 "age" to 45) as DataFrameRow<br/><br/>// After creating some rows they can be wrapped into a list<br/>val listOfRows = listOf(row,row2)<br/><br/>// Finally the list is wrapped up into a dataFrame using the Krangl function dataFrameOf <br/>// that can be included into the empty dataframe created before<br/>df3.bindRows(dataFrameOf(listOfRows))</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c08ed8c1d0213a4186c3dd8b08107312.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*TwFIViA0zdlfG9c05cG2EA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Jupyter上的输出(图片由作者提供)</p></figure><blockquote class="oj ok ol"><p id="c02c" class="kz la om lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated">Krangl中的dataframe是不可变的，这意味着任何操作都会返回一个新的data frame实例。</p></blockquote><h2 id="bd92" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">4.向数据帧添加行(使用自定义扩展函数)</h2><p id="36f1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><code class="fe ns nt nu ni b">bindRows</code>功能的使用不能像熊猫等其他图书馆的功能一样直观。因此，我们可能想要定义自己的扩展函数<code class="fe ns nt nu ni b">addMapsAsRows</code>来简化追加行的操作。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="f4c5" class="nm lx it ni b be nn no l np nq">fun DataFrame.addMapsAsRows(vararg someRows: DataFrameRow): DataFrame = <br/>    bindRows(this, dataFrameOf(listOf(*someRows)))<br/><br/>var dfCustomRows = emptyDataFrame()<br/>val rowCustomSample1 = mapOf("name" to "Custom_User", <br/>                             "surname" to "Custom_Surname",<br/>                             "age" to 99) as DataFrameRow<br/><br/>val rowCustomSample2 = mapOf("name" to "Custom_User2", <br/>                             "surname" to "Custom_Surname2",<br/>                             "age" to 98) as DataFrameRow<br/><br/><br/>dfCustomRows = dfCustomRows.addMapsAsRows(rowCustomSample1, rowCustomSample2)</span></pre><p id="6bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下，我们可以看到在Jupyter上运行脚本时的输出。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2ec168101b50af8643480552ac19dcc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*LLwWP3evvXNt3Owm6MSOTw.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">上面的脚本使用addMapsAsRows扩展函数生成的输出(图片由作者提供)</p></figure><h2 id="a8a8" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">5.使用addRow函数将值列表添加为dataframe行</h2><p id="1fe9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Krangl的<code class="fe ns nt nu ni b">DataFrame</code>类提供了几种方法来简化数据框架的工作。其中一个功能就是<code class="fe ns nt nu ni b">addRow</code>。此函数通过提供单元格值列表而不指定列，向数据帧添加一行。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="31d1" class="nm lx it ni b be nn no l np nq">dfCustomRows.addRow(listOf("nameListed","surnameListed", 100))</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi or"><img src="../Images/d1e9f7544f7bd1519d8eb968b3fc772c.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*k2Rdj9msda_UKFn89rfZ5g.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">上面的脚本使用addRow函数产生的输出(图片由作者提供)</p></figure><h2 id="a291" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">6.声明和初始化数据帧:缩写语法</h2><p id="e5de" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Krangl为我们提供了一种方便的符号，只需一条语句就可以使用<code class="fe ns nt nu ni b">dataFrameOf</code>函数创建和初始化数据帧。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="940e" class="nm lx it ni b be nn no l np nq">// Create dataframe in memory<br/>val df: DataFrame = dataFrameOf("City name", "Country code", "population", "Timezone")(<br/>    "Madrid", "ES", 3_255_944, "CET - Central European Time",<br/>    "Paris", "FR", 2_138_551, "CET - Central European Time",<br/>    "London", "GB", 8_961_989, "GMT - Greenwich Mean Time",<br/>    "Sydney","AU",4_627_345, "AEST — Australian Eastern Standard Time"<br/>)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi os"><img src="../Images/f445b3432ed7a8573e17c4832562aaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*7OCSd4N9FeHnp2y4zTiTqw.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用上面显示的缩写语法脚本创建的数据帧(图片由作者提供)</p></figure><h2 id="579b" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">7.使用数据对象声明和初始化数据帧</h2><p id="bde5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如前所述，Krangl利用反射从任何可迭代类型创建数据帧，比如map。然而，这种行为可以扩展到我们自己的自定义数据类。如下所示，我们定义了<code class="fe ns nt nu ni b">Employee</code>数据类来创建雇员列表。Krangl允许我们使用<code class="fe ns nt nu ni b">asDataFrame</code>函数，通过自动将类属性映射到dataframe列，从自定义数据对象列表中创建dataframe对象。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="ca0b" class="nm lx it ni b be nn no l np nq">data class Employee(val name:String, val salary: Int, val system:String)<br/><br/>val emploList = listOf(Employee(name = "Mark User",<br/>                                salary = 60000, <br/>                                system= "Windows"),<br/>                       Employee(name = "Danny User",<br/>                                salary = 70000, <br/>                                system= "Linux"))<br/><br/>val dfFromCustomObjects = emploList.asDataFrame()</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e5b080d302e9a9cd1f4e745e373204fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*ufL4fcL-Fqr-gu3Y_JQmTQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">来自自定义数据对象列表的数据帧(图片由作者提供)</p></figure><h1 id="76ae" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用Krangl导入数据</h1><p id="63b4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们已经看到使用Krangl创建dataframe对象是多么容易。然而，处理数据时最常见的场景是从外部源(文件、数据库或在线存储库)导入数据。在本节中，我们将讨论克兰格尔图书馆在这些问题上提供的可能性。</p><h2 id="2075" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">1.从本地CSV文件导入数据</h2><p id="ccfd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Krangl从类<code class="fe ns nt nu ni b">DataFrame</code>中提供了方法<code class="fe ns nt nu ni b">readCSV</code>，这使得将数据从<a class="ae lv" href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000323.shtml#identification" rel="noopener ugc nofollow" target="_blank"> CSV </a>(逗号分隔值)文件加载到Krangl DataFrame对象的过程变得极其简单。</p><p id="6a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从公共数据集存储库中下载一个CSV文件，例如，<a class="ae lv" href="https://zenodo.org/" rel="noopener ugc nofollow" target="_blank">芝诺多</a>。点击<a class="ae lv" href="https://zenodo.org/record/4679520/files/unemployment_rate.csv?download=1" rel="noopener ugc nofollow" target="_blank">这里</a>，你将下载一个包含2006年至2019年欧盟国家失业率的数据集。下载后，文件必须上传到我们的Jupyter笔记本环境，如下图所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/d62e030e293044d7fb931fa9bedf4761.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*nFapYq6razw06K6NB_42oA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">将CSV文件上传到Jupyter实验室环境(图片由作者提供)</p></figure><p id="ff9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，执行下面的脚本将创建包含CSV文件中存储的数据的Krangl dataframe对象。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="394e" class="nm lx it ni b be nn no l np nq">// Read data from disk and load it into a dataframe<br/>val df_csv = DataFrame.readCSV("unemployment_rate.csv")</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ov"><img src="../Images/6f2d810f0e43ce62b17eeafde55c3123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvxHA4JRa9ZBGi1y9cbMMw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">从CSV文件加载数据时创建的Dataframe(图片由作者提供)</p></figure><h2 id="9431" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">2.从本地CSV文件导入数据(自定义分隔符)</h2><p id="7df4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">尽管CSV文件的名称来自逗号(，)字符，但通常会发现CSV文件使用不同的字符作为分隔符。最常见的是分号(；)、制表符(\t)、竖线(|)或空格。</p><blockquote class="oj ok ol"><p id="c972" class="kz la om lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><em class="it"> Krangl </em>依赖于<a class="ae lv" href="https://commons.apache.org/proper/commons-csv/" rel="noopener ugc nofollow" target="_blank"><em class="it">Apache-commons-csv</em></a><em class="it"/>库来处理CSV数据格式，所以为了告诉Krangl使用不同的分隔符，我们需要导入这个库。</p></blockquote><p id="bce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这个场景，我们将使用另一个名为<a class="ae lv" href="https://public.opendatasoft.com/" rel="noopener ugc nofollow" target="_blank"> Opendatasoft </a>的公共数据门户。该门户允许将数据集导出为CSV文件，但使用分号(；)作为分隔符。点击<a class="ae lv" href="https://public.opendatasoft.com/explore/dataset/geonames-all-cities-with-a-population-1000/download/?format=csv&amp;disjunctive.cou_name_en=true&amp;q=population+%3E+1000000&amp;timezone=Europe/Berlin&amp;lang=en&amp;use_labels_for_header=true&amp;csv_separator=%3B" rel="noopener ugc nofollow" target="_blank">此处</a>，您将能够下载一个以分号分隔的CSV文件，其中包含世界上所有人口超过100万的城市。然后将文件上传到Jupyter环境，并运行以下脚本来创建数据帧。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="8578" class="nm lx it ni b be nn no l np nq">// adding apache commons csv dependency<br/>@file:Repository("https://repo1.maven.org/maven2")<br/>@file:DependsOn("org.apache.commons:commons-csv:1.9.0")<br/><br/>// Import CSVFormat class<br/>import org.apache.commons.csv.CSVFormat<br/><br/><br/>val df_csv_custom_delimter = DataFrame.readCSV(<br/>  fileOrUrl="geonames-all-cities-with-a-population-1-million.csv",<br/>  format=CSVFormat.DEFAULT.withDelimiter(';').withHeader())</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ow"><img src="../Images/821a59ca0c87672634fc247235c2aede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szcSNNT-B7OvyA0FiPk7pA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">从分号(；)CSV文件(图片作者提供)</p></figure><h2 id="9402" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">3.从远程CSV文件导入数据</h2><p id="6d0f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如今，大多数数据集都可以在网上获得，并且可以通过HTTP(s)协议访问。因此，您不需要下载文件并将其存储在您的环境中来使用它。Krangl允许你从远程数据源加载数据帧，只需使用<code class="fe ns nt nu ni b">readCSV</code>方法，用一个特定的URL作为参数，而不是一个文件名。为了测试这个特性，我们将使用一个在公共的<a class="ae lv" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>存储库中可用的数据集，即VEGA存储库，它包含一个关于机场信息的CSV文件，并通过以下URL提供:<code class="fe ns nt nu ni b"><a class="ae lv" href="https://raw.githubusercontent.com/vega/vega/main/docs/data/airports.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/vega/vega/main/docs/data/airports.csv</a></code></p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="21d5" class="nm lx it ni b be nn no l np nq">DataFrame.readCSV("https://raw.githubusercontent.com/vega/vega/main/docs/data/airports.csv")</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ox"><img src="../Images/d5abba429c4a7ec25b3045af5759f7e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9z1UW6EaELWvO9-utpxmmg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用CSV远程文件中的数据创建的数据帧(图片由作者提供)</p></figure><h2 id="abc9" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">4.从JSON文件导入数据集</h2><p id="76d0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">尽管CSV是导出表格数据时最常用的格式之一，但它不是唯一的格式。JSON格式的使用日益流行，Krangl意识到了这一点。因此，Krangl提供了方法<code class="fe ns nt nu ni b">fromJSON</code>,这两种方法都接受——文件路径或者将数据导入数据帧的远程URL。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="b1f2" class="nm lx it ni b be nn no l np nq">DataFrame.fromJson("https://raw.githubusercontent.com/vega/vega/main/docs/data/cars.json")</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oy"><img src="../Images/906655dd8e1eb1b199dee02053b46e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1mzsQygm5NRrfpthE6l4g.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用来自JSON远程文件的数据创建的Dataframe(图片由作者提供)</p></figure><h1 id="a29d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用Krangl导出数据</h1><p id="65b1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">将数据导入数据框架是处理数据项目的第一步。通常，一旦创建了数据帧，就应该执行一些操作来更新和清理数据，以便为进一步的分析做好准备。这种活动被称为数据争论，Krangl在这方面提供了出色的支持。然而，用Krangl进行数据操作是一个广泛的话题，所以我决定将它排除在本文的范围之外。</p><p id="7a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在结束这篇文章之前，我不想不提到Krangl是如何帮助我们保存已经处理过的数据帧的。</p><p id="aabb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明它，让我们获得下面的数据帧，并执行一些基本操作来更新它。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="022d" class="nm lx it ni b be nn no l np nq">val df_cities: DataFrame = dataFrameOf("City name", "Country code", "Population", "Timezone")(<br/>    "Madrid", "ES", 3_255_944, "CET - Central European Time",<br/>    "Paris", "FR", 2_138_551, "CET - Central European Time",<br/>    "London", "GB", 8_961_989, "GMT - Greenwich Mean Time",<br/>    "Sydney","AU",4_627_345, "AEST — Australian Eastern Standard Time",<br/>    "Amsterdam", "NL", 883_000, "CET - Central European Time"<br/>)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/df263f2878063c183277a2c78664e264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*KWlj3sl2vj5ruBXWI1jR2w.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">数据帧df_cities(图片由作者提供)</p></figure><p id="abf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我们将选择那些城市人口低于400万的行，然后按城市名称对结果数据帧进行排序。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="7328" class="nm lx it ni b be nn no l np nq"><br/>val df_to_export = df_cities<br/>                      .filter {it["Population"] lt 4_000_000 } <br/>                      .sortedBy("City name")</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/0793545d396ebe39c1de8c09c55f1a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*LoImH9uoG9KJi4wz3LJIIw.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">过滤和排序后要导出的数据帧(图片由作者提供)</p></figure><p id="9b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用Krangl函数导出结果数据帧(名为<code class="fe ns nt nu ni b">df_to_export</code>)。</p><h2 id="9065" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">1.将数据帧导出到CSV文件</h2><p id="25b3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">将数据帧导出为CSV文件就像调用方法<code class="fe ns nt nu ni b">writeCSV</code>一样简单，使用一个文件对象作为参数，该文件对象具有要创建的文件的名称。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="a14b" class="nm lx it ni b be nn no l np nq">import java.io.*<br/><br/>df_to_export.writeCSV(File("cities.csv"))</span></pre><p id="5459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行脚本后，创建了文件<code class="fe ns nt nu ni b">cities.csv</code>，如下图所示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pb"><img src="../Images/d1c3150b996a45ce97bc0a25713d6557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MseGiw1D3bHZ4WlIs1NsgA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">将数据帧导出为cities.csv文件(图片由作者提供)</p></figure><h2 id="ebb4" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">2.使用自定义分隔符将数据帧导出到CSV文件</h2><p id="498d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Krangl允许我们为导出CSV文件定义分隔符。正如之前在谈到导入CSV文件时所解释的，Krangl依赖于<a class="ae lv" href="https://commons.apache.org/proper/commons-csv/" rel="noopener ugc nofollow" target="_blank"> apache-commons-csv </a>库。因此，当必须定义自定义分隔符时，CSVFormat类将完成这一任务，如下面的脚本所示:</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="36d5" class="nm lx it ni b be nn no l np nq">df_to_export.writeCSV(file=File("cities2.csv"), <br/>                      format=CSVFormat.DEFAULT.withDelimiter(';').withHeader())</span></pre><h2 id="f79e" class="nv lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">3.将数据帧导出到JSON</h2><p id="54a4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后，我们将展示如何将数据帧导出为JSON对象。下面的脚本使用了由类<code class="fe ns nt nu ni b">DataFrame</code>提供的方法<code class="fe ns nt nu ni b">toJsonString()</code>。</p><pre class="kk kl km kn gt nh ni nj bn nk nl bi"><span id="3c5c" class="nm lx it ni b be nn no l np nq">df_to_export.toJsonString(prettyPrint = true, asObject = false)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/ae9e4a837ecae8ae4c29558bcaeb9c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*6RIPl2eH3t0OiZ3219EKPg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">将数据帧导出为JSON对象(图片由作者提供)</p></figure><p id="2311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意，该方法提供了一些参数来定制输出。</p><ul class=""><li id="58ff" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">当<code class="fe ns nt nu ni b">prettyPrint</code>参数设置为false时，它将在一行中写入对象，否则将显示JSON对象的可读版本。</li><li id="b596" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果参数<code class="fe ns nt nu ni b">asObject</code>为真，将生成带有嵌套对象的JSON对象。</li></ul><h1 id="67f9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="fd39" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当在基于Kotlin的数据科学项目中处理表格数据时，Krangl是一个很好的选择(但不是唯一的选择)。它简洁明了的语法、扩展能力以及与JVM生态系统中其他工具的兼容性为支持您的研究和生产解决方案提供了坚实的基础。</p><p id="e340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们解释了如何使用Kotlin和Krangl创建数据框架来支持数据科学项目。我们使用带有Kotlin内核的Jupyter Lab实现了一些示例，并讨论了将不同格式(CSV、JSON…)的外部数据源导入到Krangl数据帧中。最后，还介绍了一套由Krangl提供的保存和导出数据帧的方法。</p><p id="d8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随时留下您在文章中发现的评论、见解或错误。在以后的文章中，我们将更深入地探索Krangl，重点关注数据争论任务以及与其他基于Kotlin的数据科学库的交互。因此，欢迎您的反馈，因为它将始终有助于提高文章的质量。</p><p id="e81f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，我强烈希望这篇教程能够帮助您开始使用Kotlin和Krangl进行数据科学项目。</p><h1 id="b284" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考</h1><ul class=""><li id="db6e" class="mt mu it lb b lc mo lf mp li pd lm pe lq pf lu my mz na nb bi translated"><a class="ae lv" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/run/</a></li><li id="49a2" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://jupyter.org/documentation" rel="noopener ugc nofollow" target="_blank">https://jupyter.org/documentation</a></li><li id="1da1" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/</a></li><li id="f363" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://kotlinlang.org/docs/reflection.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/reflection.html</a></li><li id="bf4e" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://towardsdatascience.com/how-to-create-a-docker-image-with-jupyter-notebook-kotlin-2e8bbf212f81" rel="noopener" target="_blank">https://towards data science . com/how-to-create-a-docker-image-with-jupyter-notebook-kot Lin-2e 8 bbf 212 f 81</a></li><li id="70f7" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">【https://github.com/holgerbrandl/krangl T4】</li><li id="b10d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://github.com/vega/" rel="noopener ugc nofollow" target="_blank">https://github.com/vega/</a></li><li id="ef66" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://public.opendatasoft.com/explore/dataset/geonames-all-cities-with-a-population-1000/export" rel="noopener ugc nofollow" target="_blank">https://public . opendatasoft . com/explore/dataset/geonames-all-cities-a-a-population-1000/export</a></li><li id="dc9a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://commons.apache.org/proper/commons-csv/apidocs/org/apache/commons/csv/CSVFormat.html#withDelimiter-char-" rel="noopener ugc nofollow" target="_blank">https://commons . Apache . org/proper/commons-CSV/API docs/org/Apache/commons/CSV/CSV format . html # withDelimiter-char-</a></li><li id="2f8f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae lv" href="https://docs.oracle.com/javase/specs/index.html" rel="noopener ugc nofollow" target="_blank">https://docs.oracle.com/javase/specs/index.html</a></li></ul></div></div>    
</body>
</html>