<html>
<head>
<title>Build a Snake Game in Swift Using the Declarative Domain Paradigm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用声明性域范例在Swift中构建一个贪吃蛇游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-swift-snake-game-using-declarative-domain-paradigm-7eb34a139017?source=collection_archive---------5-----------------------#2021-11-01">https://betterprogramming.pub/build-a-swift-snake-game-using-declarative-domain-paradigm-7eb34a139017?source=collection_archive---------5-----------------------#2021-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7551" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">永恒而有趣</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d410c2e40135afc57cdbd3f56e24c43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JS2CbaKaRD0Coqtg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="bb50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我想向您展示如何在Swift中实现贪吃蛇游戏，并且——您可能以前从未听说过——向您介绍我将使用的声明域(DD)范式。</p><p id="cc5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目标是在追求最高质量的同时快速有效地制作游戏。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/9faa4fb32eee8e4e711fbfb67fe212c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*FPeiXf2MDMtCKpx1NQJD1A.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">贪吃蛇游戏</p></figure><p id="57b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，DD的设计目标是允许创建尽可能简单的代码。</p><p id="27b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我应该提到，我在这里使用的“简单”一词是“复杂”一词的反义词。</p><p id="a7e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看着这段代码并认为“这不简单”，你实际上的意思很简单。简单或复杂是对一个结构的绝对描述，而简单和困难是从每个人的独特视角来看的相对经验，因为它是经验、知识和好奇心的函数。为了进一步澄清简单和容易之间的区别，我强烈推荐Rich Hickey的“简单变得容易”，这是每个开发人员的必看之作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h1 id="ab56" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">声明性领域范例的工具集</h1><p id="d5e7" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">我们经常使用术语范式，但对它的实际含义没有任何共同的理解。对于本文来说，范式是一组关于如何构建软件的想法，这些想法通过约束强加给编码人员。以下是一些例子:</p><ul class=""><li id="3a60" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">理解代码应该是结构良好的导致了goto语句的消亡和结构化编程的引入</li><li id="753c" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">函数式编程通过使用不可变的全局状态来修正可变的全局状态</li><li id="0101" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">面向对象编程通过隐藏可变状态解决了同样的问题</li></ul><p id="7be1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">声明性域范例使用以下约束:</p><ul class=""><li id="b618" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">声明性编码代替命令性编码:告诉编译器<em class="ng">需要做什么</em>，而不是<em class="ng">如何做</em></li><li id="8657" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">完全不可变的模型和状态；可变性只用于局部函数范围或系统的边缘</li><li id="eee5" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">因为类是可变的复杂类型(任意数量的方法；没有执行路径的概念——导致对<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">无数模式</a>的需求；继承摧毁黑拳，…)，它们不会用在架构的中心。</li><li id="ef7c" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">基于类型的特定领域语言用于连接模块和组件，并对行为进行编码。</li></ul><p id="6caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如我所说，类不属于我们架构的中心；相反，我将使用一种称为部分应用的技术，其中一个函数被执行并返回另一个函数或一组函数。那些可以被存储并在任何时候被调用。内部函数可以访问外部函数体——它们从外部函数体使用的任何东西都将被保留，因为函数是闭包。下面是一些让我们开始的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><p id="f731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码显示了一个加法器函数，其中<code class="fe ni nj nk nl b">value</code>是状态。执行完<code class="fe ni nj nk nl b">createAdder()</code>后，只能通过调用返回的<code class="fe ni nj nk nl b">add()</code>函数来访问和更改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><p id="c6d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的<code class="fe ni nj nk nl b">createStack()</code>从返回的元组中返回一个通过调用<code class="fe ni nj nk nl b">push</code>和<code class="fe ni nj nk nl b">pop</code>使用的堆栈——如果你面前没有<code class="fe ni nj nk nl b">Stack</code>的声明，你无法将它与一个类实例区分开来。</p><p id="6e95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将部分应用的函数用作模块——模块是一种数据结构，通过它提供代码执行路径——具有一个输入和输出。</p><p id="d2f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我想保持函数参数列表简单，但定义不同的消息；因此，我将使用DSL对行为进行类型编码。让我们来看看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><p id="02a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe ni nj nk nl b">Change</code>是DSL。它允许对<code class="fe ni nj nk nl b">.move(.forward)</code>、<code class="fe ni nj nk nl b">.move(.left)</code>、<code class="fe ni nj nk nl b">.move(.right)</code>等动作进行编码，并通过<code class="fe ni nj nk nl b">.grow</code>告诉蛇增加一段长度。</p><p id="583b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下代码修改(重新创建)Snake:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="bea4" class="nq lw iq nl b gy nr ns l nt nu">let snake = snake.alter(.move(.right))<!-- --> </span><span id="6676" class="nq lw iq nl b gy nv ns l nt nu">//and</span><span id="4c36" class="nq lw iq nl b gy nv ns l nt nu">let snake = snake.alter(.grow)</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不可变的Snake数据结构</p></figure><p id="2c0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在从<code class="fe ni nj nk nl b">alter()</code>调用的<code class="fe ni nj nk nl b">move()</code>中，我们将简单地切换<code class="fe ni nj nk nl b">Move ⨯ Facing</code>的所有可能组合，并创建一个反映变化的蛇的新版本。</p><p id="c09e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是完整的<code class="fe ni nj nk nl b">Snake</code>数据类型实现:一个<code class="fe ni nj nk nl b">head</code>，一个<code class="fe ni nj nk nl b">tail</code>，一个方向it<code class="fe ni nj nk nl b">facing</code>，以及改变它的方法，返回它自身的新版本。为了对行为进行编码，使用了枚举。</p><p id="6138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这些是可嵌套的，并且可以在Swift中注释模型，这就是我创建DSL所需要的全部。这个蓝图适用于任何不可变的模型类型。</p><p id="dd52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我需要一个模块来实现这个游戏，通过用户输入来移动这条蛇。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">游戏宣言</p></figure><p id="3700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ni nj nk nl b">Game</code>被声明为一个函数元组:</p><ul class=""><li id="ce2b" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">返回游戏中的蛇</li><li id="e03c" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe ni nj nk nl b">size()</code>返回纸板尺寸</li><li id="6fee" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">游戏还在进行吗？</li><li id="f01f" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe ni nj nk nl b">target()</code>是要采集的坐标</li><li id="a113" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe ni nj nk nl b">command()</code>接受移动或重置命令</li><li id="968b" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe ni nj nk nl b">register()</code>实现一个简单的观察者模式，用于连接用户界面</li></ul><p id="a8ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是通过以下方式实现的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">游戏实现</p></figure><p id="d4d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当被调用时，它将执行<code class="fe ni nj nk nl b">run()</code>，一个本地定义的子函数，它将调用子函数<code class="fe ni nj nk nl b">setTargetEventCallback</code>、<code class="fe ni nj nk nl b">executeTargetEvent()</code>、<code class="fe ni nj nk nl b">executeStepEvent()</code>。</p><p id="68ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样会设置两个<code class="fe ni nj nk nl b">Ticks</code>，它们会在特定的时间触发:<code class="fe ni nj nk nl b">stepTick</code>会触发蛇移动一步，而<code class="fe ni nj nk nl b">targetTick</code>用来放置新的目标。你注意到他们递归地调用自己。如果<code class="fe ni nj nk nl b">state</code>或<code class="fe ni nj nk nl b">snake</code>被更新，所有观察者都会得到通知。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><p id="e759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ni nj nk nl b">Tick</code>是一个使用<code class="fe ni nj nk nl b">Timer</code>触发事件的类。它使用类似的DSL进行配置，就像我们在<code class="fe ni nj nk nl b">Snake</code>中看到的那样，但是这次它不是不可变的，状态是可变的。</p><p id="6227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe ni nj nk nl b">Tick</code>是一个位于系统边缘的依赖项，这很好，尽管它也可以实现为部分应用的元组，如前所述，并且可能是不可变的，但我想展示这个实现，因为这允许您与现有代码和依赖项进行交互。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><p id="ebed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ni nj nk nl b">executeStepEvent()</code>通过设置新计算的触发间隔和设置回调来配置<code class="fe ni nj nk nl b">stepTick</code>对象。</p><p id="13ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当这个回调在状态正在进行时被执行时，它将递归地调用<code class="fe ni nj nk nl b">executeStepEvent()</code>。如果状态为<code class="fe ni nj nk nl b">.ended</code>，<code class="fe ni nj nk nl b">stepTick</code>失效。</p><h1 id="121f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">最后缺失的部分:UI</h1><p id="f3cd" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">对于这个项目，我使用swift ui——但是代码是真正解耦的(更好:耦合最小)；它可以连接到UIKit或任何其他UI系统。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><p id="7eda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ni nj nk nl b">SnakeBoard</code>没有使用二维网格来表示棋盘，只是迭代蛇的身体和目标来绘制到上下文中。这意味着，对于不同的电路板尺寸，运行时间和内存使用都不会受到显著影响。简单的代码仍然是聪明的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><p id="c90c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果按下按钮，要么触发运动，要么重置</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="cbf8" class="nq lw iq nl b gy nr ns l nt nu">callback: game.state() == .ongoing<br/> ? { game.command(.move(.left)) }<br/> : { game.command(.reset) }</span></pre><p id="43f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">UI只能通过向<code class="fe ni nj nk nl b">game</code>发送命令来改变行为。它被通知查看一个将自己注册为观察者的<code class="fe ni nj nk nl b">ViewState</code>对象，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh lu l"/></div></figure><h1 id="e8b1" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="3b95" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">只有两个想法——DSL和部分应用程序——我能够在很短的时间内以一种几乎没有错误的风格创建一个游戏。这里有一个总结:</p><ul class=""><li id="78f8" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">设计上不可改变的事情不可能被意外改变——崩溃的幅度是不可能存在的。</li><li id="fbb5" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">使用DSL允许非常可读的代码。枚举本身是静态和无状态的——这是另一个很难想象错误的领域。</li><li id="6a30" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">代码易于测试，测试尽可能简单，<a class="ae kv" href="https://gitlab.com/vikingosegundo/declarative-snake/-/blob/main/SnakeTests/SnakeTests.swift" rel="noopener ugc nofollow" target="_blank">检查测试库</a>。注意，我使用了<a class="ae kv" href="https://github.com/Quick/Quick" rel="noopener ugc nofollow" target="_blank"> Quick </a>和<a class="ae kv" href="https://github.com/Quick/Nimble" rel="noopener ugc nofollow" target="_blank"> Nimble </a>进行测试，尽管简单的XCTests也会非常简单。</li><li id="21da" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">UI尽可能地去耦合:只有一个函数是公开的，UI可以用它来改变系统。没有任何其他方法，这也意味着在UI中执行的调用必须与在单元测试中执行的调用相同。</li></ul><p id="9429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">特别是最后一点很重要，我们知道很长一段时间(大约60年)，任何架构都必须将UI作为客户端或依赖来处理。然而，在许多代码库中，这并没有被真正考虑进去。</p><p id="3732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述项目的完整源代码可在<a class="ae kv" href="https://gitlab.com/vikingosegundo/declarative-snake/" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="7578" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。如果您喜欢您所阅读的内容，并希望更好地构建您的应用程序以用于生产，您可能需要查看以下故事:</p><div class="nw nx gp gr ny nz"><a href="https://decodemeester.medium.com/fully-declarative-swift-for-real-world-projects-9b6ee9403f4c" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">用于真实项目的完全声明式Swift</h2><div class="og l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">decodemeester.medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp nz"/></div></div></a></div></div></div>    
</body>
</html>