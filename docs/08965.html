<html>
<head>
<title>Getting Started With Async/Await in SwiftUI for iOS 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 15 swift ui中的Async/Await入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-async-await-in-swiftui-for-ios-15-f627eb722a4b?source=collection_archive---------8-----------------------#2021-06-30">https://betterprogramming.pub/getting-started-with-async-await-in-swiftui-for-ios-15-f627eb722a4b?source=collection_archive---------8-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7843" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在SwiftUI应用中使用异步/等待</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb8818d383fc6c5d9dc810c6374f5e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0gEOdEVmo1Nt0H0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供(基于SF符号)。</p></figure><p id="f97d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">毫无疑问，WWDC21上最大的声明之一是<a class="ae lu" href="https://developer.apple.com/news/?id=2o3euotz" rel="noopener ugc nofollow" target="_blank">Swift Concurrency</a>——最显著的是对<code class="fe lv lw lx ly b">async/await</code>的支持。</p><p id="0015" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为开发人员，我们经常面对我们编写的应用程序的异步特性。从磁盘读取文件，从web上的远程API获取数据，甚至从用户那里获取输入——所有这些都是异步操作。多年来，已经实现了许多不同的处理异步代码的方法。大多数iOS开发人员都熟悉大中央调度、完成处理程序或委托。</p><p id="a752" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的Swift并发模型建立在线程之上，但从线程中抽象出来。</p><p id="8cce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在2021年WWDC大会上，苹果公司做了一项了不起的工作，解释了<code class="fe lv lw lx ly b">async/await</code>和结构化并发背后的所有概念。有不少于九个视频，加上Swift语言指南中关于并发性的一整章以及大量样本代码(如果你没有尝试过，请查看开发人员应用程序中的复制代码功能)。</p><p id="4e81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是因为有如此多的信息，有时很难只见树木不见森林。</p><p id="a7cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文旨在为您提供编写SwiftUI应用程序所需的一切，这些应用程序利用了Swift中新的并发功能。</p><p id="6e5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们开门见山吧！</p><p id="a7b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lz">注意:本文基于Xcode 13中包含的Swift 5.5(在撰写本文时，Xcode 13b1)。在iOS 15向公众发布并且Apple开始接受用Xcode 13 GA创建的版本之前，您将无法在您的生产版本中使用它。然而，学习如何使用新的语言特性并理解它们可能对您的代码产生的影响是有益的——特别是如果您是一个库或框架供应商的话。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6981" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">示例应用程序</h1><p id="4543" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">在为我们的示例应用程序寻找易于使用的API时，我遇到了<a class="ae lu" href="https://www.wordsapi.com/" rel="noopener ugc nofollow" target="_blank"> WordsAPI </a>。这是一个有趣的API，提供了大量关于单词的有趣信息(在英语中)。你给它发送一个词，比如“Swift”，它会返回一堆信息，比如这个词的不同含义(比如“移动非常快”，“一只像燕子的小鸟”，或者“一个出生在爱尔兰的英国讽刺作家”)。</p><p id="1781" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例应用程序在一个<code class="fe lv lw lx ly b">List</code>视图中显示一串单词。当用户点击其中一个单词时，该应用程序将从WordsAPI中获取该单词的含义，并在详细信息屏幕中显示它们。</p><p id="5943" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文的后面，我们将添加另一个特性，从WordsAPI获取一个随机单词，并在用户进行刷新时将其添加到主列表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e583887acd034d094553f4ada17c9f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*KD9emT4tv_9_sQ_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nf">拉至刷新示例截图</em></p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="aa0d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">使用URLSession和Async/Await</h1><p id="0a7e" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated"><code class="fe lv lw lx ly b">URLSession</code>是许多已经升级支持<code class="fe lv lw lx ly b">async/await</code>的API之一，所以获取数据现在是一个简单的单行程序:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="6c47" class="nk mi it ly b gy nl nm l nn no">let (data, response) = try await URLSession.shared.data(for: urlRequest)</span></pre><p id="f820" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过一些最低级别的错误处理和JSON解析(由Codable提供支持)，获取单词详细信息的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4018" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们通过在方法签名中追加<code class="fe lv lw lx ly b">async</code>将我们的<code class="fe lv lw lx ly b">search(for searchTerm: String)</code>方法标记为异步。这意味着无论何时调用这个方法，我们都必须使用<code class="fe lv lw lx ly b">await</code>。这样做表示一个所谓的暂停点，并给运行库一个机会来暂停当前正在执行的函数。挂起的函数被“挂起”，直到它调用的函数返回。当函数挂起时，它正在执行的线程可以用来执行应用程序中的其他代码。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8c68" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">更新@Published属性</h1><p id="ca84" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">示例应用程序使用视图模型作为从WordsAPI端点获取数据的中心点。它被实现为一个<code class="fe lv lw lx ly b">ObservableObject</code>，因此它可以利用SwiftUI的状态管理系统:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9887" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来讨论一下这是怎么回事:</p><ul class=""><li id="b56d" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt nw nx ny nz bi translated"><code class="fe lv lw lx ly b">result</code>是包含API调用结果的已发布属性(一旦该调用返回)。</li><li id="53bc" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated"><code class="fe lv lw lx ly b">isSearching</code>表示我们当前是否正在执行搜索。该属性将被绑定到一个进度指示器，以向用户提供一些视觉反馈，表明我们正在等待结果。</li><li id="e944" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated"><code class="fe lv lw lx ly b">executeQuery</code>管理<code class="fe lv lw lx ly b">isSearching</code>的状态，然后调用实际代码来执行API调用。注意，这个函数也需要标记为<code class="fe lv lw lx ly b">async</code>，因为它调用<code class="fe lv lw lx ly b">search(for:)</code>，这是一个可能会挂起的函数(正如“Swift中的Meet async/await”中提到的<a class="ae lu" href="https://developer.apple.com/videos/play/wwdc2021/10132?time=1208" rel="noopener ugc nofollow" target="_blank">，可能会挂起的函数也会挂起它们的调用方)。</a></li><li id="29fe" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">最后，整个视图模型被标记为<code class="fe lv lw lx ly b">@MainActor</code>，以表明其中的任何代码都必须在主参与者上运行。</li></ul><p id="d719" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一点很关键:因为发布的属性更新UI，所以对它们的任何更改都需要在主线程上运行。通过用<code class="fe lv lw lx ly b">@MainActor</code>属性标记一个类，Swift编译器将保证该类上的所有方法和属性只从主参与者调用。所以通过用<code class="fe lv lw lx ly b">@MainActor</code>注释来注释<code class="fe lv lw lx ly b">WordDetailsViewModel</code>，我们确保所有的更新都发生在主线程上。</p><p id="1469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lz">注意:我强烈推荐使用视图模型，因为它们有助于保持代码的整洁。然而，放弃视图模型并使</em> <code class="fe lv lw lx ly b"><em class="lz">search(for searchTerm: String)</em></code> <em class="lz">功能成为SwiftUI视图的一员是完全可能的。要了解如何做到这一点，请查看本文GitHub资源库中的</em><a class="ae lu" href="https://github.com/peterfriese/SwiftUI-Concurrency-Essentials/blob/main/WordBrowser/WordBrowser/Views/WordDetailsViewNoViewModel.swift" rel="noopener ugc nofollow" target="_blank"><em class="lz">word detailsviewnoviewmodel</em></a><em class="lz">。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="56cb" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">从SwiftUI调用异步代码</h1><p id="fc19" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">难题的最后一块是如何从SwiftUI调用我们的异步代码。你可以从许多不同的地方打电话:</p><ul class=""><li id="b959" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt nw nx ny nz bi translated">当视图出现时</li><li id="11e3" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">当用户点击按钮时</li><li id="8696" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">当用户拉动刷新时</li><li id="0479" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">响应于搜索请求</li><li id="c8fe" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">基于通知</li><li id="cd5a" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">基于计时器</li></ul><p id="65ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看其中的一些，以了解我们可以使用的不同机制。</p><h2 id="125b" class="nk mi it bd mj of og dn mn oh oi dp mr lh oj ok mt ll ol om mv lp on oo mx op bi translated">当视图出现时</h2><p id="07bd" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">这可能是获取数据最常见的时间，您可能已经在现有的SwiftUI应用程序中使用了<code class="fe lv lw lx ly b">onAppear</code>视图修饰符来触发获取数据。我们仍然可以使用<code class="fe lv lw lx ly b">onAppear</code>，但是编译器会抱怨我们不能在这里调用异步函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ac94f2b9dafe41bc606b3485b72fae03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*LhZcu8Pt84CsnZpE.jpg"/></div></figure><p id="f44e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题的一个解决方案是通过调用静态函数<code class="fe lv lw lx ly b">async</code>来创建一个新的<code class="fe lv lw lx ly b">Task</code>(在Xcode 13b2中这将被替换为<code class="fe lv lw lx ly b">Task.init</code>)，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6eab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很有效，但是还有一个更好的解决方案。因为在视图出现时获取数据是如此常见，SwiftUI有一个新的视图修改器，当视图消失时，它将自动创建一个新的<code class="fe lv lw lx ly b">Task</code> <em class="lz">和</em>取消任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="8c66" class="nk mi it bd mj of og dn mn oh oi dp mr lh oj ok mt ll ol om mv lp on oo mx op bi translated">当用户点击按钮时</h2><p id="13c8" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">有时，我们希望执行异步代码来响应按钮点击。在Xcode 13b1中，大部分按钮动作处理程序都不支持调用异步代码，所以我们需要自己调用<code class="fe lv lw lx ly b">async</code>来创建一个新的异步上下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="da1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些<code class="fe lv lw lx ly b">Button</code>的动作处理程序支持调用异步代码，但是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f174224414b50a2bce98c10f163822f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*taergCTjCL3rRKn2.jpg"/></div></figure><p id="48fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不太清楚为什么这应该只对有角色的<code class="fe lv lw lx ly b">Buttons</code>可行，所以也许我们会在下一个测试版中看到这方面的更新。</p><h2 id="3c91" class="nk mi it bd mj of og dn mn oh oi dp mr lh oj ok mt ll ol om mv lp on oo mx op bi translated">当用户拉动刷新时</h2><p id="b8bb" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">拉至刷新是今年SwiftUI发布的另一个受欢迎的新增功能。通过简单地添加<code class="fe lv lw lx ly b">refreshable</code>视图修饰符，视图就获得了拉至刷新的能力。在闭包内部，我们可以更新视图中显示的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="b385" class="nk mi it bd mj of og dn mn oh oi dp mr lh oj ok mt ll ol om mv lp on oo mx op bi translated">响应于搜索请求</h2><p id="c787" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">今年SwiftUI的发布也为我们带来了<code class="fe lv lw lx ly b">searchable()</code>视图修改器。通过将这个视图修饰符应用到一个列表视图，可以得到一个特定于平台的搜索UI。视图修改器的第一个参数是到一个<code class="fe lv lw lx ly b">String</code>的绑定，然后您可以使用它来驱动搜索。如果你不想使用Combine来监听搜索字符串的变化，你可以使用<code class="fe lv lw lx ly b">onSubmit(of:)</code>视图修改器来响应某些按键。例如，要在用户点击屏幕键盘上的搜索按钮(或按回车键)时触发搜索，您可以使用以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f52d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能已经注意到，<code class="fe lv lw lx ly b">onSubmit</code>的闭包没有被标记为异步，这就是为什么我们需要使用现在熟悉的<code class="fe lv lw lx ly b">async { }</code>语法创建一个新的<code class="fe lv lw lx ly b">Task</code>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="491d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="d323" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">总结一下:</p><ol class=""><li id="beea" class="nr ns it la b lb lc le lf lh nt ll nu lp nv lt oq nx ny nz bi translated">使用苹果API的异步版本(如果这不可能，有一个变通方法，我们将在以后的文章中了解)。</li><li id="070a" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt oq nx ny nz bi translated">将调用异步代码的函数标记为<code class="fe lv lw lx ly b">async</code>。</li><li id="2edb" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt oq nx ny nz bi translated">将您的<code class="fe lv lw lx ly b">ObservableObjects</code>标记为<code class="fe lv lw lx ly b">@MainActor</code>。</li><li id="9ae6" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt oq nx ny nz bi translated">要在视图出现时获取数据，使用<code class="fe lv lw lx ly b">task</code>视图修改器。</li><li id="fd67" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt oq nx ny nz bi translated">使用<code class="fe lv lw lx ly b">refreshable</code>视图修改器使用拉至刷新来异步获取数据。</li><li id="f971" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt oq nx ny nz bi translated">使用<code class="fe lv lw lx ly b">async</code>从同步上下文中启动一个新的异步任务，比如<code class="fe lv lw lx ly b">Button</code>。</li></ol><p id="f5de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你觉得这很有用。如果您有任何问题或建议，请在本文的<a class="ae lu" href="https://github.com/peterfriese/SwiftUI-Concurrency-Essentials" rel="noopener ugc nofollow" target="_blank">资源库</a>上留下评论或提交请求。</p><p id="1bf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or nq l"/></div></figure><p id="6762" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lz">原载于</em><a class="ae lu" href="https://peterfriese.dev/swiftui-concurrency-essentials-part1/" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://peterfriese . dev</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>