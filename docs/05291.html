<html>
<head>
<title>Introducing SwiftUI’s New @AppStorage, @StateObject, and @SceneStorage Property Wrappers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍SwiftUI的新@AppStorage、@StateObject和@SceneStorage属性包装器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-swiftuis-new-appstorage-stateobject-and-scenestorage-property-wrappers-db0df895bd3b?source=collection_archive---------5-----------------------#2020-06-26">https://betterprogramming.pub/introducing-swiftuis-new-appstorage-stateobject-and-scenestorage-property-wrappers-db0df895bd3b?source=collection_archive---------5-----------------------#2020-06-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3701" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">iOS 14带来了全新的属性包装器，用于在SwiftUI中持久化数据</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/1106ea4de54a6a71b0dab029a984a85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QAa_9487V4L7lwsC"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">丹尼·米勒在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="0e1a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI在WWDC 2020期间获得了一些很棒的新增强。其中突出的是对SwiftUI属性包装器库的添加。属性包装器在SwiftUI应用程序中大量用于更新和观察视图，是SwiftUI数据管理的重要组成部分。</p><p id="8c77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 14为我们提供了三种新的数据持久性属性包装器:</p><ul class=""><li id="7755" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe mf mg mh mi b">@AppStorage</code></li><li id="b5e9" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated"><code class="fe mf mg mh mi b">@StateObject</code></li><li id="f0d0" class="lw lx iu lc b ld mj lg mk lj ml ln mm lr mn lv mb mc md me bi translated"><code class="fe mf mg mh mi b">@SceneStorage</code></li></ul><p id="07fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将在新的Xcode 12(在撰写本文时处于测试阶段)中逐一介绍它们。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="758a" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">SwiftUI @AppStorage</h1><p id="0231" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">一个<code class="fe mf mg mh mi b">AppStorage</code>属性包装器用于读写<code class="fe mf mg mh mi b">UserDefaults</code>的值。每次<code class="fe mf mg mh mi b">AppStorage</code>属性包装器的值改变时，SwiftUI视图就会失效并重新绘制。</p><p id="fd38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它的行为与<code class="fe mf mg mh mi b">@State</code>属性包装器相同，除了它用于以一种方便的方式在<code class="fe mf mg mh mi b">UserDefaults</code>键和SwiftUI视图之间进行通信。以下代码展示了在iOS 14之前，我们如何将<code class="fe mf mg mh mi b">UserDefaults</code>与<code class="fe mf mg mh mi b">State</code>属性包装器一起使用:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="d6e9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">新的<code class="fe mf mg mh mi b">@AppStorage</code>属性包装器在一行中完成了这一任务:</p><pre class="kk kl km kn gu nu mi nv nw aw nx bi"><span id="2441" class="ny mw iu mi b gz nz oa l ob oc">@AppStorage("name") var name: String = "hey"</span></pre><p id="9cc8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mf mg mh mi b">AppStorage</code>还允许您对<code class="fe mf mg mh mi b">UserDefaults</code>使用不同于<code class="fe mf mg mh mi b">standard</code>的<code class="fe mf mg mh mi b">suiteName</code>。</p><p id="a9ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我们还可以通过使用<code class="fe mf mg mh mi b">wrappedValue</code>参数直接在<code class="fe mf mg mh mi b">@AppStorage</code>中设置<code class="fe mf mg mh mi b">UserDefaults</code>键的默认值。</p><p id="104c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是上述每种情况的语法:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/e432b117608de9a1b09ce32137529048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otOcnDzU5KPTrCaXiUddIA.png"/></div></div></figure><p id="7036" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意在第二种情况下，<code class="fe mf mg mh mi b">@AppStorage</code>类型是如何从设置为布尔值的<code class="fe mf mg mh mi b">wrappedValue</code>中隐式确定的。</p><p id="aa95" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe mf mg mh mi b">TextField</code>中使用<code class="fe mf mg mh mi b">AppStorage</code>似乎很有吸引力——尤其是因为存储和更新登录凭证是一个常见的用例。但是这样做的话，你的<code class="fe mf mg mh mi b">UserDefaults</code>将会在每次用户输入或删除文本域的内容时更新，这可能并不理想。</p><p id="3649" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<code class="fe mf mg mh mi b">@AppStorage</code>的一个更好的场景是在基于计数器的应用程序中跨应用程序会话保存值。或者甚至在新的SwiftUI <code class="fe mf mg mh mi b">TextEditor</code>中构建一个方便的记事本应用程序。</p><pre class="kk kl km kn gu nu mi nv nw aw nx bi"><span id="bb81" class="ny mw iu mi b gz nz oa l ob oc">@AppStorage("text") var text: String = ""<br/><br/>var body: some View {<br/>        Text($text)<br/>}<!-- --> </span></pre></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="6178" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">SwiftUI @StateObject</h1><p id="b082" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated"><code class="fe mf mg mh mi b">StateObjects</code>被引入以填充<code class="fe mf mg mh mi b">@EnvironmentObject</code>和<code class="fe mf mg mh mi b">@ObservedObject</code>之间的空隙。</p><p id="9e52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然<code class="fe mf mg mh mi b">EnvironmentObject</code>属性包装器用作应用程序中所有SwiftUI视图可用的共享数据，但<code class="fe mf mg mh mi b">ObservedObject</code>通常用于插入符合<code class="fe mf mg mh mi b">ObservableObject</code>协议的数据源类。</p><p id="91e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mf mg mh mi b">@ObservedObject</code>一个SwiftUI中的set也可以与其他视图共享，这可能会无意中导致棘手的问题。例如，如果您试图更新一个已经初始化了<code class="fe mf mg mh mi b">ObservedObject</code>的SwiftUI视图(可能通过改变状态),那么模型将被重新创建:</p><pre class="kk kl km kn gu nu mi nv nw aw nx bi"><span id="7608" class="ny mw iu mi b gz nz oa l ob oc">@ObservedObject var model = MyViewModel()</span></pre><p id="a796" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管您可以去掉上面的默认值<code class="fe mf mg mh mi b">MyViewModel()</code>并将模型作为参数传递给<code class="fe mf mg mh mi b">init</code>，但是当您与其他子视图共享<code class="fe mf mg mh mi b">ObservedObject</code>时，您将失去确定事实来源的能力。</p><p id="6e5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 14中的SwiftUI带来了一个新的<code class="fe mf mg mh mi b">@StateObject</code>属性包装器，它不会在状态变化时重新初始化。</p><p id="0050" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以现在，你可以像这样愉快地用<code class="fe mf mg mh mi b">@StateObject</code>替换<code class="fe mf mg mh mi b">@ObservedObject</code>:</p><pre class="kk kl km kn gu nu mi nv nw aw nx bi"><span id="5a77" class="ny mw iu mi b gz nz oa l ob oc">@StateObject var model = MyViewModel</span></pre></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="cb0a" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">SwiftUI @SceneStorage</h1><p id="4be1" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">新的<code class="fe mf mg mh mi b">SceneStorage</code>属性在具有多窗口支持的应用程序中的状态恢复中非常方便——通常构建在iPadOS和macOS上。</p><p id="2b90" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与<code class="fe mf mg mh mi b">AppStorage</code>不同，它不在<code class="fe mf mg mh mi b">UserDefaults</code>中保存数据。相反，它只是一个状态属性，对于应用程序中的每个场景都是唯一的。</p><pre class="kk kl km kn gu nu mi nv nw aw nx bi"><span id="6f8c" class="ny mw iu mi b gz nz oa l ob oc">@SceneStorage("isLoggedIn") <strong class="mi iv">var</strong> isLoggedIn = false</span></pre></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="9d35" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">结论</h1><p id="f8a5" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">在本文中，我们看到了iOS 14的SwiftUI中引入的三个新的属性包装器。它们都以不同的方式帮助实现状态持久化。虽然<code class="fe mf mg mh mi b">StateObjects</code>只为视图初始化一次，但是<code class="fe mf mg mh mi b">SceneStorage</code>属性对于每个场景是唯一的。最后，<code class="fe mf mg mh mi b">AppStorage</code>是一个状态属性包装器，用于观察<code class="fe mf mg mh mi b">UserDefaults</code>并导致视图在更新时重绘。</p></div></div>    
</body>
</html>