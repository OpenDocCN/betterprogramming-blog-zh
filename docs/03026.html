<html>
<head>
<title>Mapping in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的映射</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mapping-in-swift-a6d6132a38af?source=collection_archive---------16-----------------------#2020-01-15">https://betterprogramming.pub/mapping-in-swift-a6d6132a38af?source=collection_archive---------16-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3cc1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">映射和紧映射是重要的高阶函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/984bc612bdb535fb85c2ae065b2ce3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0B8zToJQvZPJ9bA-a2DNQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dead____artist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">捕捉人心。</a> on <a class="ae ky" href="https://unsplash.com/@dead____artist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="6031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift有很多很酷的功能。其中之一是使用高阶函数，今天本指南将重点介绍<code class="fe lv lw lx ly b">map</code>和<code class="fe lv lw lx ly b">compactMap</code>。</p><p id="8a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难度:初学者| <strong class="lb iu">简单</strong> |普通|挑战</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="91e1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">先决条件</h1><ul class=""><li id="cb5f" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">能够产生一句“你好，世界！”iOS应用程序(指南<a class="ae ky" href="https://medium.com/swlh/your-first-ios-application-using-xcode-9983cf6efb71" rel="noopener">此处</a>)</li><li id="3f37" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">对<a class="ae ky" href="https://medium.com/@stevenpcurtis.sc/simply-optionals-in-swift-or-not-ee63c3999e16" rel="noopener">可选值</a>和<a class="ae ky" href="https://levelup.gitconnected.com/functions-in-swift-7e488190a011" rel="noopener ugc nofollow" target="_blank">功能</a>的一些理解</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="56b6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">术语</h1><p id="636e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><strong class="lb iu">数组</strong> : <strong class="lb iu"> </strong>同一类型的一系列有序对象</p><p id="036a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">集合</strong>:可以被遍历(次数不限)的元素序列，可以通过索引下标访问</p><p id="af42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">连接在一起的:连接在一起的</strong></p><p id="f721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">compactMap</strong></code>:返回一个数组的函数，该数组包含将闭包映射到集合元素的非零结果</p><p id="20ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">Map</strong></code>:返回一个数组的函数，其结果是将闭包映射到集合的元素上</p><p id="d937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">高阶函数</strong>:以函数为自变量，或返回函数的函数</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bc05" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">地图</h1><h2 id="4ced" class="nr mh it bd mi ns nt dn mm nu nv dp mq li nw nx ms lm ny nz mu lq oa ob mw oc bi translated">应用函数的传统方法</h2><p id="a40b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">传统的方法包括迭代一个集合，并对集合中的每个成员应用一个函数。</p><p id="0c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的集合可以是Swift的任何一种集合类型，但是这里我们将使用一个<code class="fe lv lw lx ly b">Integer</code>数组。<code class="fe lv lw lx ly b">let arr = [1,2,3]</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a44ac527d99f3354e64e2bf82f5b387e.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*iPrtghgkomYc8LaGt3y7XQ.png"/></div></figure><p id="459a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望对数组的每个元素运行相同的函数——我们可以简单地<code class="fe lv lw lx ly b">print</code>数组的每个元素。</p><p id="13d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以遍历数组并对每个元素应用<code class="fe lv lw lx ly b">print</code>函数。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="75cd" class="nr mh it ly b gy oi oj l ok ol">for i in 0..&lt;arr.count { <br/>    print (arr[i])<br/>}</span></pre><p id="9ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为替代方案(因为我们在每个元素上执行该功能)，我们可以使用Swift的<code class="fe lv lw lx ly b">forEach</code>。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="b5a0" class="nr mh it ly b gy oi oj l ok ol">arr.forEach { (elem) in <br/>    print (elem)<br/>}</span></pre><p id="83dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以打印数组中的元素。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="77d0" class="nr mh it ly b gy oi oj l ok ol">for element in arr {<br/>    print (elem)<br/>}</span></pre><p id="0341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这向我们展示了如何对数组中的每个元素应用相同的<code class="fe lv lw lx ly b">print</code>函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b07cfdecfde4e53b1756386dba4b9186.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*2YIO0To_URUngBkvMbQPag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">print</code>应用于数组的每个元素</p></figure><p id="3d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有另一种选择…</p><h2 id="1d9d" class="nr mh it bd mi ns nt dn mm nu nv dp mq li nw nx ms lm ny nz mu lq oa ob mw oc bi translated">使用映射来应用函数</h2><p id="49ba" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><strong class="lb iu">将</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">map</strong></code> <strong class="lb iu">应用到数组</strong></p><p id="315e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Map</code>对集合进行操作，并将函数依次应用于每个元素。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="ae4b" class="nr mh it ly b gy oi oj l ok ol">arr.map({ (element: Int) in<br/>    return print(element)<br/>})</span></pre><p id="b0f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用Swift的类型推断，我们可以只返回名为<code class="fe lv lw lx ly b">$0</code>的第一个参数，这是传递到闭包的第一个参数的简写(实际上这里将表示从<code class="fe lv lw lx ly b">array</code>依次传递的每个元素)。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="a9b6" class="nr mh it ly b gy oi oj l ok ol">arr.map({ return print($0) })</span></pre><p id="4782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以进一步减少，因为Swift可以推断出函数的结果是从闭包返回的。</p><p id="68d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">删除退货条款</strong></p><p id="694b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为我们提供了以下信息:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="a9fa" class="nr mh it ly b gy oi oj l ok ol">arr.map{ print($0) }</span></pre><p id="c10c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">map</code>功能相当于执行与上面应用功能的传统方法一节中所示相同的动作。这为我们提供了使用高阶<code class="fe lv lw lx ly b">map</code>函数的选项。</p><p id="10dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，本质上，我们仍然在做同样的事情。也就是说，我们将一个函数(<code class="fe lv lw lx ly b">map</code>，如果你愿意的话)应用于数组的每个元素:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b07cfdecfde4e53b1756386dba4b9186.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*2YIO0To_URUngBkvMbQPag.png"/></div></figure><p id="d0e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所示的语法确实很短。然而，我们应该意识到，就<strong class="lb iu"> <em class="om"> </em> </strong>函数的效率而言，我们依赖于编译器优化<strong class="lb iu"> <em class="om"> </em> </strong>。如果您使用(例如)一个<code class="fe lv lw lx ly b">for</code>循环编写自己的函数，并添加自己的优化，您手工制作的函数可能会更高效。</p><p id="1c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">映射更复杂的示例</strong></p><p id="037a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建自己的函数给一个元素加1(我说的是复杂的例子)。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="a582" class="nr mh it ly b gy oi oj l ok ol">func addOne(a: Int) -&gt; Int {<br/>    return a + 1<br/>}</span></pre><p id="9988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，通过使用<code class="fe lv lw lx ly b">map</code>高阶函数，这可以应用于数组的每个元素。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="4c09" class="nr mh it ly b gy oi oj l ok ol">arr.map{addOne(a: $0)}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ff9d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">紧凑地图</h1><p id="fafc" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">还有更高阶的函数。<code class="fe lv lw lx ly b">compactMap</code>与使用返回可选结果的函数相关。</p><p id="449c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以获取一个新的数组，它将数字和单词的组合作为<code class="fe lv lw lx ly b">String</code>存储在<code class="fe lv lw lx ly b">Array</code>中。<code class="fe lv lw lx ly b">let arr = ["1", "2", "3", "four", "five"]</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/291446790439797d55274d299a19a4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*UcxSk4AG-tpvwZ6DM4evlA.png"/></div></figure><p id="c8c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个元素的类型实际上都是字符串——所以当我们想要将元素转换为<code class="fe lv lw lx ly b">Int</code>时，这只对三个元素有效:1、2和3。但是当应用于“四”和“五”时，该函数将返回<code class="fe lv lw lx ly b">nil</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e5a2d1624557db51aab51f2aecaf5f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*utlnRK8JX3kWNaU4JIl8OA.png"/></div></figure><p id="0119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正在讨论的函数只是简单的<code class="fe lv lw lx ly b">Int()</code>，并会返回如上的结果。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="527d" class="nr mh it ly b gy oi oj l ok ol">arr.compactMap{Int($0)}</span></pre><p id="3384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它返回一个只包含元素<code class="fe lv lw lx ly b">[1, 2, 3]</code>的数组，不包含任何返回的<code class="fe lv lw lx ly b">nil</code>元素。</p><p id="a23a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，我们可以创建自己的函数，然后使用<code class="fe lv lw lx ly b">compactMap</code>以这种简洁的方式映射元素，忽略可选的。</p><p id="57d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好东西！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d702" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="7cd2" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们可以对集合使用这些高阶函数，而不仅仅是<code class="fe lv lw lx ly b">arrays</code>。</p><p id="dd48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些高阶函数有一种特定的风格，函数式编程可能会让你习惯。在任何情况下，你都应该习惯于它们的使用，以及它们会给你带来什么好处——尤其是因为有很多教程希望你熟悉它们的用法。</p><p id="8d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，编码快乐！</p></div></div>    
</body>
</html>