<html>
<head>
<title>The Unexpected Workings of Python’s Default Arguments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python默认参数的意外工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-unexpected-workings-of-pythons-default-arguments-fe1a4addb1dc?source=collection_archive---------10-----------------------#2022-06-20">https://betterprogramming.pub/the-unexpected-workings-of-pythons-default-arguments-fe1a4addb1dc?source=collection_archive---------10-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="272f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可以帮助你创造新鲜的物体</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7343dce0602d5d72ddfb5f0419f45260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3mWq2uoIeBhHSx0m3QPNg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kv" href="https://unsplash.com/s/photos/fixed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5b65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认参数在Python代码中很常见。它们是Python提供的众多灵活性之一，可以让我们的代码更干净、更灵活。然而，如果您不熟悉默认参数，它们也会带来奇怪的副作用。</p><p id="b3cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看下面的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="736c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来很无辜，对吧？</p><p id="e232" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们真的运行这个，这是我们的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3144" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这只是一个玩具示例，但我们可以很容易地看到批处理过程中的一段潜在代码，如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="27e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们期望根据我们提供的输入<code class="fe lu lv lw lx b">user_batch </code>得到一个<code class="fe lu lv lw lx b">core_users</code>列表。</p><p id="b020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，你会发现你的<code class="fe lu lv lw lx b">core_users</code>列表并不是每批都重新设置，而是会一直延续下去。</p><p id="502e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是怎么回事？</p><h1 id="f851" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">默认参数</h1><p id="241b" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">与您的想法相反，默认参数并不是每次调用函数时都重新创建，而是在定义函数时创建一次。</p><p id="b5f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们可以看到这种奇怪的行为，因为我们的<code class="fe lu lv lw lx b">core_users</code>列表实际上并不是每次调用函数时都创建一个新的列表。</p><p id="ef97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们能做些什么呢？</p><p id="41e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，一个解决方案，你们中的一些人可能一看到上面的函数就已经想到了，就是把我们的定义移到函数体中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个简单的更改，我们现在确实获得了每次调用都刷新列表的预期行为。如果我们确实需要提供种子列表的功能，我们可以将它作为可选输入来提供，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="95d9" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">类和实例变量</h1><p id="6fe2" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">关于这种行为需要注意的重要一点是，它不仅仅是函数中的默认参数集，它也适用于类变量。</p><p id="1063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看一个跟踪他们的<code class="fe lu lv lw lx b">email</code>和喜欢的帖子列表的基本用户类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们现在从这个类中创建两个对象并尝试操作这些字段，我们可以看到email字段在实例之间会有所不同，但是<code class="fe lu lv lw lx b">liked_posts</code>将被共享。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a85f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的解决方案可能您已经知道了，那就是用实例属性替换类属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="4c0e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">默认工厂</h1><p id="37ff" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">尽管当我们用额外的方法创建成熟的类时，使用实例变量是有意义的，但有时我们在使用<code class="fe lu lv lw lx b">attrs</code>时可能会忘记这个原则。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="51a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并创建两个独立的实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="806d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我们通常最终会将我们的值定义为类本身的初始化参数，但是如果我们不这样做，而是在以后修改它，我们仍然会得到一个共享变量，这肯定不是我们想要的。</p><p id="8834" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的解决方案是使用默认工厂，它将创建输入变量的深层副本，从而为您创建一个全新的字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="f73d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">Pydantic和数据类</h1><p id="14ad" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">Pydantic和dataclasses是数据对象的另一组流行选项，分别用于解析和验证逻辑以及基本数据对象。</p><p id="dfc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能想知道，这些相同的效应在这里也适用吗？</p><p id="a778" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Pydantic的情况下，您不必担心。设置一个可变的默认参数仍然会为您定义的每个新的类实例创建一个新的参数。</p><p id="aab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果你没有使用工厂，<code class="fe lu lv lw lx b">dataclasses</code>不会让你使用一个可变字段作为你的缺省值，也就是说，这将会失败。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b86f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而是直接提示您使用默认工厂。</p><h1 id="43af" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">摘要</h1><p id="1c2c" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">Python中的默认参数可能会以意想不到的方式工作，因为它们只在定义对象时创建一次。由于这种行为，我们在使用可变默认参数时必须小心，无论是作为类变量还是在方法中。</p><p id="0647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">避免这些问题的一个方法是，对于方法，在方法体中设置默认值，对于类，在类初始化方法中定义变量。</p><p id="1ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用<code class="fe lu lv lw lx b">attrs</code>或<code class="fe lu lv lw lx b">dataclasses</code>时，我们可以使用一个默认的工厂，这样每个实例都有一个为它创建的新对象，而不是重用同一个只创建过一次的可变对象。</p></div></div>    
</body>
</html>