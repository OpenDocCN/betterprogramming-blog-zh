<html>
<head>
<title>How to Build a Multi-Tenant Application Using Spring Boot and Hibernate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Spring Boot和Hibernate构建多租户应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-multi-tenant-application-using-spring-boot-and-hibernate-718e16bfd456?source=collection_archive---------4-----------------------#2020-02-17">https://betterprogramming.pub/how-to-build-a-multi-tenant-application-using-spring-boot-and-hibernate-718e16bfd456?source=collection_archive---------4-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3eba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建一个应用程序，其中一个实例服务于多个租户或用户</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d821eafed82878404db86791126be08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yjV3k8_B8sZVxEN7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@helloquence?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Helloquence </a>拍摄的照片</p></figure><p id="70df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将学习如何使用Spring Boot和Hibernate构建一个多租户应用程序。我们将展示如何构建一个多租户应用程序，其中租户使用共享数据库和共享模式。</p><p id="adc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事是一次成功尝试的结果，在对现有应用程序做尽可能少的更改的情况下，将一个普通应用程序转变为一个多租户应用程序。这个故事受下面的<a class="ae kv" href="https://medium.com/swlh/multi-tenancy-implementation-using-spring-boot-hibernate-6a8e3ecb251a" rel="noopener"> <strong class="ky ir">教程</strong> </a>的影响，旨在改进其提出的指定实现。我们将在拦截器方法中使用注释，而不是使用HandlerInterceptorAdapter并将自己局限于HTTP访问。这样我们就不会只局限于HTTP访问。</p><p id="e124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺点</strong>中提出的<a class="ae kv" href="https://medium.com/swlh/multi-tenancy-implementation-using-spring-boot-hibernate-6a8e3ecb251a" rel="noopener"> <strong class="ky ir"> <em class="ls">条</em> </strong> </a>的解决方案为共享数据库，共享模式方式:</p><ul class=""><li id="3d91" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">该解决方案仅适用于REST APIs。如果你在听一个卡夫卡的话题，或者在阅读RabbitMQ上的信息，这是行不通的。</li><li id="c87a" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">使用Hibernate拦截器的共享数据库共享模式的解决方案太复杂了。我无法让它在现有的应用程序上工作。</li></ul><p id="0c0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">建议的解决方案:</strong></p><ul class=""><li id="9bb7" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">适用于所有界面。公开的API可以是REST API、SOAP API、Kafka listener、Queue consumer或者其他。</li><li id="a686" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">我们将采用一种更简单的方法，而不必使用Hibernate Interceptor。</li></ul><p id="07b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">故事伴随着一个正在工作的</em> <a class="ae kv" href="https://github.com/ivlahek/multitenant-showcase" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">项目</em></strong></a><strong class="ky ir"><em class="ls"/></strong><em class="ls">在</em><a class="ae kv" href="https://github.com/ivlahek/multitenant-showcase" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="ls">GitHub</em></strong></a><em class="ls">上主持。</em></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="256c" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">多租户应用</h1><p id="f35a" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">多租户应用程序是指单个实例服务于多个租户的应用程序。当我们说租户时，最常见的是我们的应用程序所服务的多个公司或组织。</p><p id="83cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种方法可以构建多租户应用程序:</p><ul class=""><li id="49e0" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">每个租户的数据库—每个租户都有自己的数据库。</li><li id="1896" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">共享数据库，独立模式—所有租户都使用同一个数据库，但是每个租户都有自己的模式。</li><li id="1888" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">共享数据库、共享模式—所有租户都使用相同的模式。数据库中的每个表都有一个名为tenant_id的鉴别器列，用于指定数据的所有者。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="4138" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">数据库设计</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/afd902417a99444926ddbb57a228d0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHRStTecXe2AtCKZQ8zYPA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于共享数据库共享模式方法的数据库设计</p></figure><p id="e90e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计多租户应用程序的最大挑战是确保租户可以访问他的数据，并且只能访问他的数据。设计这样一个应用程序的第一步是设计一个数据库。当用共享数据库为多租户应用程序设计数据库模式时，共享模式非常简单。您创建了一个表租户。向所有表添加一个列tenant_id，向表tenant添加外键，就这样。您设计了一个多租户数据库。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="3ded" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">应用程序设计——一种幼稚的方法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8b486420bec099d7d4649a75b55d9d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*LNMvy9KgaE2CRrY2UCArfA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最简单的方法—在整个应用程序中提取租户id</p></figure><p id="6b27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在处理应用程序设计时，就比较棘手了。处理这种问题的最简单的方法是，整个应用程序知道它正在为多个租户服务。在这种方法中，您通过应用程序的所有层传递租户id或租户对象:</p><ul class=""><li id="42ef" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">端口和适配器(API)——在这一层，我们识别我们当前服务的租户；</li><li id="2caa" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">服务层——在这一层，我们只是将这些信息传递给存储库层；</li><li id="84b9" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">存储库层—在这一层，我们需要说明我们正在为哪个租户访问数据库。</li></ul><p id="51b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提议的幼稚方法并不好。所有层都知道租户。更糟糕的是，服务层只是将信息传递给存储库层。它不会处理这些信息。它只是传送到存储库层。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="4e97" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">应用设计——一种先进的方法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/48dcdf88fdf61f28e8170b20b1b90640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*6bHECMZVgZYMgOs7-P22HA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">高级方法—提取第一层的租户id，并对除数据库层之外的其他层隐藏。</p></figure><p id="46a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在高级方法中，我们将使用Hibernate和Spring提供的好东西来创建一个应用程序设计，在这个设计中，只有端口和适配器知道我们在为多个租户服务。其他层不会意识到应用程序正在为多个租户服务。</p><p id="70a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用以下技术:</p><ul class=""><li id="a8ca" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><strong class="ky ir">Spring AOP<em class="ls"/></strong>—我们要定义两个拦截器:一个拦截外部请求，一个拦截对存储库层的请求；</li><li id="2a7b" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir"> Java注释</strong>—我们将定义两个注释:一个用于标记外部请求，一个用于标记方法签名中的租户id；</li><li id="e87c" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir"> Hibernate注释</strong> @PrePersist和@PreUpdate，用于将实体持久化到正确的租户；</li><li id="28c2" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir"> Hibernate filters </strong>确保我们只访问租户的数据。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="a107" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">端口和适配器(公开的API)</h1><p id="a86f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在这一层，我们需要确定我们当前服务的是哪个租户。为此，我们将创建以下注释:</p><ul class=""><li id="0ded" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">@InboundRequest —通过这个注释，我们将对公开的方法进行注释。</li><li id="8b63" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">@TenantId —通过这个注释，我们将在公开的方法中将参数注释为租户Id。</li></ul><p id="1717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们有一个REST API方法，定义为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="28b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将添加前面提到的注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8b5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将创建一个方面来拦截对公开的API的方法的调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="19bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。在第一层，我们已经确定了租户，并将其放在其他层可以使用的地方。服务层呢？</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="ad55" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">服务层</h1><p id="6d0d" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们的服务层不会意识到它正在服务多个租户。服务层将在不指定租户的情况下查询并保存数据库中的数据。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="0284" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">存储库层—获取和保存数据</h1><p id="fd9d" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在存储库层，我们有两件事要做:</p><ul class=""><li id="1a89" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">在获取数据时，我们必须确保获取的是租户的数据；</li><li id="3f98" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">保存数据时，我们必须确保将数据保存到正确的租户。</li></ul><h2 id="7c8a" class="np mp iq bd mq nq nr dn mu ns nt dp my lf nu nv na lj nw nx nc ln ny nz ne oa bi translated">获取数据</h2><p id="50d4" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们将使用休眠过滤器。我们将使用@Filter和@FilterDef注释在所有实体类上定义一个过滤器。使用这些过滤器，我们将添加条件来检查实体是否属于发出请求的租户。对于MobileApplication类，它看起来像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="578a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们将使用Spring AOP来拦截对存储库的所有调用。在这个拦截器中，我们将对应用程序中定义的所有实体应用tenant_id过滤器。这个过滤器将在每次数据库调用之前应用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="66e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JpaRepository 有一个问题。使用<em class="ls"> JpaRepository </em>接口的<em class="ls"> findById </em>方法时，不应用hibernate过滤器(<em class="ls">https://stack overflow . com/questions/45169783/hibernate-filter-is-not-applied-for-findone-crud-operation</em>)。我们将通过如下方式创建一个自定义存储库并创建应该用来代替<em class="ls"> findById </em>方法的<em class="ls"> getById </em>来绕过这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7e25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<em class="ls"> CustomRepository </em>而不是<em class="ls"> JPARepository </em>来确保hibernate过滤器应用于我们所有的数据库查询。</p><p id="8107" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">涵盖了数据查询。在每次存储库调用数据库时，我们将自动应用上述过滤器。当查询数据库时，服务层不会意识到它正在添加这些条件。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="6fe0" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">持久化数据</h1><p id="94e0" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们将使用<a class="ae kv" href="http://twitter.com/PrePersist" rel="noopener ugc nofollow" target="_blank"> @PrePersist </a>和<a class="ae kv" href="http://twitter.com/PreUpdate" rel="noopener ugc nofollow" target="_blank"> @PreUpdate </a>将实体持久化到正确的租户。对于每个已定义的实体类，我们将定义<em class="ls"> prePersist() </em>方法。对于MobileApplication类，它看起来像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a84e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Hibernate会在将实体持久化到数据库之前调用这个方法。使用这种方法，您不需要在代码中显式设置租户。这个方法将从我们在应用程序入口填充的租户上下文中获取租户，并为实体设置它。同样，服务层永远不会显式填充租户字段。这将由Hibernate在事务提交之前完成。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="1367" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">包扎</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/36615fc270f507c1143e05e64614a5cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Jrf3yD7CTbmYOGv"/></div></div></figure><h1 id="c5e4" class="mo mp iq bd mq mr oc mt mu mv od mx my jw oe jx na jz of ka nc kc og kd ne nf bi translated"><strong class="ak">建议设计的优点:</strong></h1><ul class=""><li id="c3f4" class="lt lu iq ky b kz ng lc nh lf oh lj oi ln oj lr ly lz ma mb bi translated">数据库层设置一次，除非应用程序中添加了新表，否则不会更改。</li><li id="0d23" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">在公开一个API时，需要用<a class="ae kv" href="http://twitter.com/InboundRequest" rel="noopener ugc nofollow" target="_blank"> @InboundRequest </a>和<a class="ae kv" href="http://twitter.com/TenantId" rel="noopener ugc nofollow" target="_blank"> @TenantId </a>对公开的方法进行注释。通过使用注释方法，您不会受限于HTTP访问的方法。</li><li id="7881" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">代码是干净的。只有第一层知道租户的情况。其他层不知道它们正在为多个租户服务。</li></ul><h2 id="7098" class="np mp iq bd mq nq nr dn mu ns nt dp my lf nu nv na lj nw nx nc ln ny nz ne oa bi translated"><strong class="ak">建议设计的缺点:</strong></h2><ul class=""><li id="7565" class="lt lu iq ky b kz ng lc nh lf oh lj oi ln oj lr ly lz ma mb bi translated">缺点是您需要注释应用程序的每一个访问点，这样它才能工作。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="1b93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个被提议的设计简单得足以让人满意。主要优点是只有API层(或端口和适配器)知道tenant_id。其他层正在工作，因为它们只为一个租户服务。代码非常简单。这是它的主要优势:代码简洁明了。</p><p id="3717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">故事受以下<a class="ae kv" href="https://medium.com/swlh/multi-tenancy-implementation-using-spring-boot-hibernate-6a8e3ecb251a" rel="noopener"> <strong class="ky ir">教程</strong> </a>影响，旨在完善。</p><p id="58da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事伴随着一个正在工作的<a class="ae kv" href="https://github.com/ivlahek/multitenant-showcase" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">项目</strong> </a>在<a class="ae kv" href="https://github.com/ivlahek/multitenant-showcase" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> GitHub </strong> </a>上主持。</p></div></div>    
</body>
</html>