<html>
<head>
<title>What If You Only Need One Table for Your Entire Database System?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果整个数据库系统只需要一个表，该怎么办？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-if-you-only-need-one-table-for-your-entire-database-system-78078bdc4b50?source=collection_archive---------6-----------------------#2021-07-14">https://betterprogramming.pub/what-if-you-only-need-one-table-for-your-entire-database-system-78078bdc4b50?source=collection_archive---------6-----------------------#2021-07-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="061c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">单表设计方法的剖析。有什么好的吗？</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/96e4f0b2f5348444b9f27ce3f1f6b9a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxprUMZLnZ-pf2tfCnRYwQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">扎拉克汗在<a class="ae kz" href="https://unsplash.com/s/photos/table?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="27c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我告诉你你的系统只需要一张表会怎么样？如果你和我一样，有SQL查询和模式设计的经验，我打赌你会和我一样惊讶。</p><p id="7f85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是这实际上是在NoSQL类型的数据库中对数据库建模的推荐方式——尤其是在DynamoDB中。</p><p id="0112" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天，我将解释如何用一个表来设计一个系统，以及这个决定背后的理由。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="4686" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">告诉我更多</h1><p id="e669" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">单表数据库设计正如其名。整个系统只有一个表。</p><p id="8283" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是它是如何工作的呢？不同的数据有非常不同的结构。</p><p id="7f54" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">是的，没错。NoSQL的美来了。顾名思义，这种类型的数据存储不需要严格的模式。你可以放任何你喜欢的东西。所以在同一个集合中，你可以把用户和产品<strong class="lc iv">和</strong>并排放在一起。</p><p id="ccac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">采用单表设计意味着将所有数据放在同一个表中，DynamoDB不会对此有任何抱怨，因为它是无模式的键值对存储。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="a40c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">但是我怎么把数据拿回来呢？</h1><p id="64a1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这是有趣的部分。DynamoDB对主键的概念有一种奇怪的理解。您将有两个密钥来标识特定数据:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="0a20" class="nf me iu nb b gz ng nh l ni nj">Primary Key = Partition Key + Sort Key</span></pre><p id="59ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了指向特定的数据，我们可以做的是以这样一种方式设计我们的分区键，使得以后获取它们变得容易和可理解。</p><p id="2fa0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们举个例子。我们有一个电子商务系统，需要存储产品、客户、订单等信息。为了存储这些数据，我们可以这样设计分区键:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="d304" class="nf me iu nb b gz ng nh l ni nj"><strong class="nb iv"> ENTITY_TYPE      PARTITION_KEY (here 1234 is just a random id)</strong></span><span id="dfe4" class="nf me iu nb b gz nk nh l ni nj"> Product -&gt;       PRODUCT#1234          <br/> Customer -&gt;      CUSTOMER#1234    <br/> Order -&gt;         ORDER#1234</span></pre><p id="78c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，当您查询数据时，如果您想获得产品，您可以这样做:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="b263" class="nf me iu nb b gz ng nh l ni nj">Where PK = PRODUCT#1234 -&gt; PK means Primary Key</span></pre><p id="c20d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你需要顾客，那也是一样:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="84bf" class="nf me iu nb b gz ng nh l ni nj">Where PK = CUSTOMER#1234 </span></pre><p id="8b65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这样，通过使用分区键的概念，可以将多个表中的数据分割到一个表中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="754a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">关系呢？</h1><p id="8023" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这是一个很好的问题。在现实生活中，我们不只是将单个和离散的数据放入我们的系统。我们必须用一种特殊的方式把它们找回来。让我们回到前面的例子，试着理解我们在说什么。</p><h2 id="8765" class="nf me iu bd mf nl nm dn mj nn no dp mn lj np nq mp ln nr ns mr lr nt nu mt nv bi translated">现实生活场景</h2><ul class=""><li id="5caa" class="nw nx iu lc b ld mv lg mw lj ny ln nz lr oa lv ob oc od oe bi translated">一位客户登录到系统，希望看到他们的订单。</li><li id="0688" class="nw nx iu lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">订单需要知道包括哪些产品。</li><li id="9fb2" class="nw nx iu lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">订单需要包含发票项目。</li></ul><p id="0185" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们如何有效地解决这些问题？</p><p id="3154" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个场景中，<em class="ok">排序键</em>的概念派上了用场。我们前面说过，一个条目的惟一性取决于主键和排序键的组合。</p><p id="95d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">主键更多地用于逻辑划分数据，而排序键用于处理这些情况。让我们对订单进行建模，看看如何存储订单来检索这些查询:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="3225" class="nf me iu nb b gz ng nh l ni nj"><strong class="nb iv">      PRIMARY_KEY</strong>      <strong class="nb iv">SORT_KEY      OTHER_INFO</strong></span><span id="b918" class="nf me iu nb b gz nk nh l ni nj">1.    ORDER#1234       PRODUCT#1     ProductName,Price etc</span><span id="75d4" class="nf me iu nb b gz nk nh l ni nj">2.    ORDER#1234       INVOICE#1     InvoiceDate, PaymentInfo</span><span id="5645" class="nf me iu nb b gz nk nh l ni nj">3.    ORDER#1234       CUSTOMER#1    CustomerName, ShippingAddress</span></pre><p id="7a33" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，现在如果我们想要获得特定订单的产品，我们可以利用查询函数<code class="fe ol om on nb b">begins_with</code>:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="2563" class="nf me iu nb b gz ng nh l ni nj">Where PK = ORDER#1234 and begins_with( SK, PRODUCT# )</span></pre><p id="ef95" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似地，要获得一个产品的发票列表，我们可以这样做:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="eb2a" class="nf me iu nb b gz ng nh l ni nj">Where PK = ORDER#1234 and begins_with( SK, INVOICE# )</span></pre><p id="03c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们必须牢记这一点，并相应地进行设计。要了解更多关于更复杂的查询，您可以查看这篇文章。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="852e" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">这种方法的好处是什么？</h1><p id="cad1" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">嗯，有几个好处。下面就来说说其中的一些。</p><h2 id="ccbe" class="nf me iu bd mf nl nm dn mj nn no dp mn lj np nq mp ln nr ns mr lr nt nu mt nv bi translated">获取多个数据的单一查询</h2><p id="cdb8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">使用DynamoDB进行多表设计的主要限制是一次只能查询一个表。如果您将您的<code class="fe ol om on nb b">orders</code>和<code class="fe ol om on nb b">ordered_produces</code>保存在不同的表中，您将需要查询两个表来获得一个订单的所有细节。</p><p id="39f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是在单表设计中，您只需这样做:</p><pre class="kk kl km kn gu na nb nc nd aw ne bi"><span id="b9cf" class="nf me iu nb b gz ng nh l ni nj">where PK = ORDER#1234</span></pre><p id="711d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一个很大的优势，也是单表设计背后的主要原因。</p><h2 id="8dcf" class="nf me iu bd mf nl nm dn mj nn no dp mn lj np nq mp ln nr ns mr lr nt nu mt nv bi translated">效率</h2><p id="671a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在单表设计中，您可以通过GSI(全局二级索引)的概念轻松处理复杂的访问模式。这样，您的查询会更高效。</p><h2 id="42a5" class="nf me iu bd mf nl nm dn mj nn no dp mn lj np nq mp ln nr ns mr lr nt nu mt nv bi translated">谅解</h2><p id="d4a0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">单表设计更容易理解。乍一看，这可能令人望而生畏，但是如果您只有一个表，那么您就不必担心大量不同的主键和排序键以及它们是如何工作的。你将只有一个地方去了解它的全部。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="2e80" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">那么这一切都是阳光和玫瑰吗？</h1><p id="c4e4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">不，绝对不行。这种方法有许多缺点。第一个是它有一个非常陡峭的学习曲线。也许我们会在另一篇文章中讨论这些缺点。</p><p id="63e6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我仍然不相信这是正确的做法，但这确实是一个非常有趣的想法。请在评论中告诉我你的想法。</p><p id="d084" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">祝您愉快！</p><p id="00d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">通过</strong><a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">LinkedIn</strong></a><strong class="lc iv">或我的</strong> <a class="ae kz" href="https://www.mohammadfaisal.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">个人网站</strong> </a> <strong class="lc iv">与我取得联系。</strong></p></div></div>    
</body>
</html>