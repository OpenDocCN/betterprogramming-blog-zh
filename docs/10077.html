<html>
<head>
<title>A Complete Guide to Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-patterns-a-complete-guide-b2699315961f?source=collection_archive---------1-----------------------#2021-11-24">https://betterprogramming.pub/design-patterns-a-complete-guide-b2699315961f?source=collection_archive---------1-----------------------#2021-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2898" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用简单的例子解释设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bf4b3f6b252a63af17868c89df9010e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DQkiSDUkuOkiRI_4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">因陀罗·乌塔马在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d396" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">1-策略模式</h1><blockquote class="lv lw lx"><p id="c22d" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir">“策略模式</strong>定义了一族算法，封装了每一个，并使它们<strong class="mb ir"> <em class="iq">可互换</em> </strong>。策略让算法从使用它们的客户端独立地变化<strong class="mb ir"><em class="iq"/></strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/0c05bfb483b4703a80adaffd0833c657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvOU--Wo77R2GoodKwks4g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">方钻杆</a>在<a class="ae kv" href="https://unsplash.com/photos/qWwpHwip31M?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="479f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">除了形式上的定义，<strong class="mb ir">策略模式</strong>在你需要<strong class="mb ir"> <em class="ma">切换</em> </strong>你的算法或者策略在你代码的不同地方的时候被广泛使用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="110f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:</strong></p><p id="1ec0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您构建了一个游戏，它有一个实现了<strong class="mb ir"> Diet </strong>类的<strong class="mb ir"> Cat </strong>类。但是，假设你的猫体重增加太多，现在它需要节食来帮助它减肥以保持健康。</p><p id="566d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">在这种情况下，你可以实现<strong class="mb ir">一个策略模式</strong>，比如:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="47fb" class="ne le iq na b gy nf ng l nh ni">interface EatBehavior {<br/>    public void eat();<br/>}</span></pre><p id="1bc2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">实现进食行为的饮食类型</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7df0" class="ne le iq na b gy nf ng l nh ni">public class NormalDiet implements EatBehavior {<br/>    @Override<br/>    public void eat() {<br/>        // normal food<br/>    }<br/>}</span><span id="4111" class="ne le iq na b gy nj ng l nh ni">public class LosingWeightDiet implements EatBehavior {<br/>    @Override<br/>    public void eat() {<br/>        // healthy food<br/>    }<br/>}</span></pre><p id="b5a7" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">猫类认为</em> <strong class="mb ir"> <em class="ma">有-个</em> </strong> <em class="ma">吃行为</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8b52" class="ne le iq na b gy nf ng l nh ni">public abstract class Cat {</span><span id="3560" class="ne le iq na b gy nj ng l nh ni">    EatBehavior eatBehavior;</span><span id="284e" class="ne le iq na b gy nj ng l nh ni">    public Cat(){}<br/>    <br/>    public void eat() {<br/>        eatBehavior.eat();<br/>    }<br/>}</span></pre><p id="4e7f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="3093" class="ne le iq na b gy nf ng l nh ni">cat.eat();            // Cat eats as usual.</span><span id="49ad" class="ne le iq na b gy nj ng l nh ni">cat.setEatBehavior(new LosingWeightDiet());</span><span id="c63a" class="ne le iq na b gy nj ng l nh ni">cat.eat();            // Cat eats with a healthier diet.</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="94de" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">策略模式</strong>也可以帮助你为不同的子类型分配<strong class="mb ir">不同的行为</strong>。</p><p id="5c71" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设你有一只spyhnx猫(一种没有任何皮毛的猫)和一只虎斑猫(或任何其他有皮毛的猫)。</p><p id="7bb3" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">您可以轻松地更新您的类，如下所示:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8c49" class="ne le iq na b gy nf ng l nh ni">interface EatBehavior {<br/>    public void eat();<br/>}<br/>interface DisplayBehavior {<br/>    public void display();<br/>}</span></pre><p id="c613" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">实现显示行为的毛发类型</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1107" class="ne le iq na b gy nf ng l nh ni">public class HasFur implements DisplayBehavior {<br/>    @Override<br/>    public void display() {<br/>        // display with fur<br/>    }<br/>}</span><span id="ddef" class="ne le iq na b gy nj ng l nh ni">public class NoFur implements DisplayBehavior {<br/>    @Override<br/>    public void display() {<br/>        // display without fur<br/>    }<br/>}</span></pre><p id="28a1" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">一只猫类即</em> <strong class="mb ir"> <em class="ma">是——一只</em> </strong> <em class="ma">猫类和</em> <strong class="mb ir"> <em class="ma">有——一只</em> </strong> <em class="ma">吃和显示行为</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="3d63" class="ne le iq na b gy nf ng l nh ni">public class Sphynx extends Cat {</span><span id="e973" class="ne le iq na b gy nj ng l nh ni">    EatBehavior eatBehavior;<br/>    DisplayBehavior displayBehavior;</span><span id="20eb" class="ne le iq na b gy nj ng l nh ni">    public Sphynx() {<br/>        eatBehavior = normalDiet();<br/>        <strong class="na ir">displayBehavior = noFur();</strong><br/>    }</span><span id="ea0c" class="ne le iq na b gy nj ng l nh ni">    public void eat() {<br/>        eatBehavior.eat();<br/>    }</span><span id="f72c" class="ne le iq na b gy nj ng l nh ni">    public void display() {<br/>        displayBehavior.display();<br/>    }<br/>}</span></pre><p id="d5a8" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">另一个猫类即</em> <strong class="mb ir"> <em class="ma">是——一个</em> </strong> <em class="ma">的猫类与</em> <strong class="mb ir"> <em class="ma">有——一个</em> </strong> <em class="ma">的进食行为与一个</em> <strong class="mb ir"> <em class="ma">不同</em> </strong> <em class="ma">的展示行为</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b87a" class="ne le iq na b gy nf ng l nh ni">public class Tabby extends Cat {<br/>    <br/>    EatBehavior eatBehavior;<br/>    DisplayBehavior displayBehavior;</span><span id="1f07" class="ne le iq na b gy nj ng l nh ni">    public Tabby() {<br/>        eatBehavior = normalDiet();<br/>        <strong class="na ir">displayBehavior = hasFur();</strong><br/>    }</span><span id="c2f4" class="ne le iq na b gy nj ng l nh ni">    public void eat() {<br/>        eatBehavior.eat();<br/>    }</span><span id="4042" class="ne le iq na b gy nj ng l nh ni">    public void display() {<br/>        displayBehavior.display();<br/>    }<br/>}</span></pre><p id="fc9d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="55ce" class="ne le iq na b gy nf ng l nh ni">Cat spyhnx = new Spyhnx();<br/>sphynx.display(); // displays cat without fur</span><span id="de8d" class="ne le iq na b gy nj ng l nh ni">Cat tabby = new Tabby();<br/>tabby.display();  // displays cat with fur</span></pre><p id="c928" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如上所见，它还可以帮助你将<strong class="mb ir"><em class="ma"/></strong><strong class="mb ir"><em class="ma">类中的</em> </strong>类分开。</p><p id="8a8b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果有一天你想为你的游戏从tabby中移除毛发，你可以只改变在Tabby类中设置displayBehavior的方式，而不需要通知客户端这个改变。</p><p id="cdfe" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">每个阶级只会关心自己的。(单一责任原则)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/7634028548060f1be62a76f365f5b40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5LLHBtaHOBkREiCi--9vA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@karberg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">方钻杆</a>在<a class="ae kv" href="https://unsplash.com/s/photos/two-cats?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="e589" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:</strong></p><p id="6c48" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您正在编写一个显示天气预报的软件，但是您希望将用户信息存储在一个数据库中，将天气信息存储在另一个数据库中。</p><p id="109a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">实现数据库策略的不同数据库类型</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b626" class="ne le iq na b gy nf ng l nh ni">public class PostgreStrategy implements DatabaseStrategy {<br/>    @Override<br/>    public void save() {<br/>        // save to PostgreSQL<br/>    }<br/>}</span><span id="9401" class="ne le iq na b gy nj ng l nh ni">public class CouchbaseStrategy implements DatabaseStrategy {<br/>    @Override<br/>    public void save() {<br/>        // save to Couchbase<br/>    }<br/>}</span></pre><p id="2ec2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户代码:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ac77" class="ne le iq na b gy nf ng l nh ni">DatabaseContext db = new DatabaseContext();</span><span id="3f22" class="ne le iq na b gy nj ng l nh ni">db.setDatabaseStrategy(new PostgreStrategy());<br/>db.save(userInformation);</span><span id="4a39" class="ne le iq na b gy nj ng l nh ni">db.setDatabaseStrategy(new CouchbaseStrategy());<br/>db.save(weatherInformation);</span></pre><p id="1ece" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">同样，如果有一天你想改变PostgreStrategy或CouchbaseStrategy的工作方式，你就不需要接触客户端代码了。</p><p id="62a5" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">简而言之，<strong class="mb ir">策略模式</strong>帮助我们在编写代码时动态<strong class="mb ir"><em class="ma"/></strong>改变组件的工作方式，并且<strong class="mb ir"> <em class="ma">分离</em>我们的关注点</strong>。</p><p id="26ff" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">把它当成一个单独的故事来读:<br/> </strong> <a class="ae kv" href="http://emretanriverdi.medium.com/design-patterns-strategy-pattern-d57a13c593b7" rel="noopener">策略模式—快速指南</a> (3分钟读完)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7f86" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">2-装饰图案</h1><blockquote class="lv lw lx"><p id="e82d" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">"<strong class="mb ir">装饰模式</strong>动态地给一个对象<strong class="mb ir"><em class="iq"/></strong>附加额外的责任。Decorators为扩展功能提供了子类化的灵活替代方案。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/84557ca822703b20f4429b30185e309b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJSbSQEseuA58aEav7_FNQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯托弗·乔利在<a class="ae kv" href="https://unsplash.com/@chris_jolly?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d2a7" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">除了形式定义，<strong class="mb ir">装饰模式</strong>包装了一个<strong class="mb ir">装饰</strong>类的对象，允许你在客户端代码中动态改变对象的行为。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="6a96" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:</strong></p><p id="9d0e" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设你拥有一家<strong class="mb ir"> <em class="ma">本地</em> </strong> <strong class="mb ir"> <em class="ma">披萨店</em> </strong>，那里有<em class="ma">【随心所欲】</em>风格的披萨。</p><p id="875b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">它的软件有<strong class="mb ir"> Pizza </strong>超类，子类有<strong class="mb ir">Pizza with蘑菇、Pizza with玉米、PizzaWithSalami、Pizza with mushrooms and玉米、PizzaWithMushroomsAndSalami、PizzaWithCornAndSalami、Pizza with mushrooms and cornandsalami。</strong></p><p id="0c9f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">这不是一个很好的做法，是吗？</p><p id="0ce6" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果我们想在未来添加一种新的成分呢？如果我们想添加一种新的外壳类型，比如薄皮披萨，该怎么办？如果我们想更新每种成分的价格，该怎么办？如果我们想增加2倍的玉米呢？</p><p id="fe77" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">在我们的例子中，这种做法会导致<strong class="mb ir"> <em class="ma">维护的噩梦</em> </strong>。</p><p id="b097" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">我们的目标必须是允许我们的类添加新的行为，而不修改现有的代码。(开闭原理)</p><p id="4c00" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">编写的代码应该是<strong class="mb ir"> <em class="ma">可重用</em> </strong>。</p><p id="e5a0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">为了实现这一点，我们可以实现<strong class="mb ir">装饰模式</strong>，例如:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a3a2" class="ne le iq na b gy nf ng l nh ni">public interface Pizza {<br/>    String getSummary();<br/>    int getPrice();<br/>}</span></pre><p id="b6c1" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">实现pizza接口的Pizza类</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="777e" class="ne le iq na b gy nf ng l nh ni">public class StandardCrustPizza implements Pizza</span><span id="34e6" class="ne le iq na b gy nj ng l nh ni"><strong class="na ir">    private static final String PRICE = 25;</strong><br/>    <br/>    @Override<br/>    public String getSummary() {<br/>        return "Standard Pizza (" + PRICE + ")";<br/>    }</span><span id="121d" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public int getPrice() {<br/>        return PRICE;<br/>    }<br/>}</span><span id="c864" class="ne le iq na b gy nj ng l nh ni">public class ThinCrustPizza implements Pizza {</span><span id="36ce" class="ne le iq na b gy nj ng l nh ni"><strong class="na ir">    private static final String PRICE = 30; </strong>   <br/>   <br/>    @Override<br/>    public String getSummary() {<br/>        return "Thin Crust Pizza (" + PRICE + ")";<br/>    }</span><span id="79a8" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public int getPrice() {<br/>        return PRICE;<br/>    }<br/>}</span></pre><p id="4c2d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma"> pizza decorator实现pizza接口的抽象类</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a4c9" class="ne le iq na b gy nf ng l nh ni">abstract class PizzaDecorator implements Pizza {</span><span id="4dbd" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public abstract String getSummary();<br/>    <br/>    @Override<br/>    public abstract int getPrice();<br/>}</span></pre><p id="ec16" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> <em class="ma">披萨配料</em> </strong> <em class="ma">扩展</em> <strong class="mb ir"> <em class="ma">披萨装饰器抽象类</em> </strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="5b0c" class="ne le iq na b gy nf ng l nh ni">public class Corn extends PizzaDecorator {<br/>    <br/>    private Pizza pizza;<br/>    <strong class="na ir">private static final String PRICE = 4;</strong><br/>    <br/>    Corn(Pizza pizza) {<br/>        this.pizza = pizza;<br/>    }</span><span id="be59" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public String getSummary() {<br/>        return pizza.getSummary() +<br/>               ", with corn (" + PRICE + ")";<br/>    }</span><span id="9bb9" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public int getPrice() {<br/>        return pizza.getPrice() + PRICE;<br/>    }<br/>}</span><span id="a759" class="ne le iq na b gy nj ng l nh ni">public class Mushrooms extends PizzaDecorator {</span><span id="4a27" class="ne le iq na b gy nj ng l nh ni">    private Pizza pizza;<br/>    <strong class="na ir">private static final String PRICE = 6;</strong></span><span id="c3cb" class="ne le iq na b gy nj ng l nh ni">    Mushrooms(Pizza pizza) {<br/>        this.pizza = pizza;<br/>    }</span><span id="6aa9" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public String getSummary() {<br/>        return pizza.getSummary() +<br/>               ", with mushrooms (" + PRICE + ")";<br/>    }</span><span id="312b" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public int getPrice() {<br/>        return pizza.getPrice() + PRICE;<br/>    }<br/>}</span><span id="0681" class="ne le iq na b gy nj ng l nh ni">public class Salami extends PizzaDecorator {<br/>    <br/>    private Pizza pizza;<br/>    <strong class="na ir">private static final String PRICE = 5;</strong></span><span id="a58d" class="ne le iq na b gy nj ng l nh ni">    Salami(Pizza pizza) {<br/>        this.pizza = pizza;<br/>    }</span><span id="84df" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public String getSummary() {<br/>        return pizza.getSummary() +<br/>               ", with salami  (" + PRICE + ")";<br/>    }</span><span id="53ec" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public int getPrice() {<br/>        return pizza.getPrice() + PRICE;<br/>    }<br/>}</span></pre><p id="5b85" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ab3e" class="ne le iq na b gy nf ng l nh ni">Pizza pizza = new StandardPizza(); // standard pizza, base: 25<br/>pizza = new Salami(pizza);         // salami added, total: 30<br/>pizza = new Corn(pizza);           // corn added, total: 34<br/>pizza = new Corn(pizza);           // corn x2 added, total: 38</span><span id="db21" class="ne le iq na b gy nj ng l nh ni">Output:<br/>Standard Pizza (25), with salami (5), with corn (4), with corn (4)<br/>Price: 38</span><span id="4a3e" class="ne le iq na b gy nj ng l nh ni">Pizza pizza = new ThinCrustPizza(); // thin crust pizza, base: 30<br/>pizza = new Mushroom(pizza);        // mushroom added, total: 36<br/>pizza = new Salami(pizza);          // salami added, total: 41</span><span id="fe86" class="ne le iq na b gy nj ng l nh ni">Output:<br/>Thin Crust Pizza (30), with mushroom (6), with salami (5)<br/>Price: 41</span></pre><p id="c215" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">看，这都是非常可重复使用的！如果有一天你想添加一种新的面包皮/配料或者更新现有的价格，你不需要接触客户代码。</p><p id="e631" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">每个阶级只会关心自己的。(单一责任原则)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/aeb933236791cdd2c52cf52d6c2d6962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnSwFqQrIuJhGHGfRctHAw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@karthikgarikapati?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Karthik </a>在<a class="ae kv" href="https://unsplash.com/s/photos/pizza?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="f932" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:</strong></p><p id="60c2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">装饰模式</strong>广泛应用于<strong class="mb ir"> <em class="ma"> java.io包、</em> </strong>中，如:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d631" class="ne le iq na b gy nf ng l nh ni">InputStream in = new FileInputStream(file);<br/>in = <!-- -->new BufferedInputStream(in<!-- -->);<br/>in = <!-- -->new DataInputStream(in);</span></pre><p id="4016" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">FileInputStream是这里的<em class="ma">外壳类型</em>，BufferedInputStream和DataInputStream是<strong class="mb ir"> <em class="ma"> </em> </strong> <em class="ma">配料</em>。</p><p id="80fe" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">你甚至可以通过简单地扩展<em class="ma"> java.io包</em>decorator的超类(FilterInputStream)并将其包装在基类FileInputStream周围，来为你的程序编写你自己的decorator <em class="ma"> </em>。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4616" class="ne le iq na b gy nf ng l nh ni">public class UpperCaseInputStream extends FilterInputStream {<br/>    public UpperCaseInputStream(InputStream in) {<br/>        super(in);<br/>    }</span><span id="9cde" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public int read() throws IOException {<br/>        return Character.<em class="ma">toUpperCase</em>(super.read());<br/>    }<br/>}</span></pre><p id="f5f9" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2ef3" class="ne le iq na b gy nf ng l nh ni">InputStream in = new FileInputStream(file);<br/>in = <!-- -->new UpperCaseInputStream(in);</span><span id="0931" class="ne le iq na b gy nj ng l nh ni">// other decorators</span></pre><p id="6a3a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">简而言之，<strong class="mb ir">装饰模式</strong>帮助我们在编写代码时动态地<strong class="mb ir"><em class="ma"/></strong>附加额外的功能到我们的基类。</p><p id="b831" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">把它当成一个故事来读:<br/> </strong> <a class="ae kv" href="http://emretanriverdi.medium.com/design-patterns-decorator-pattern-3b50880173e1" rel="noopener">【装饰图案——快速指南】</a> (4分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="96d7" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">3观察者模式</h1><blockquote class="lv lw lx"><p id="b388" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">"<strong class="mb ir">观察者模式</strong>定义了对象之间一对多的依赖关系，这样当一个对象<strong class="mb ir"> <em class="iq">改变</em> </strong> <strong class="mb ir"> <em class="iq">状态</em> </strong>时，其所有的依赖对象<strong class="mb ir"> <em class="iq">都会得到通知并自动更新。</em></strong><em class="iq"/></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/3df5b9754d6f9aee8c7113207158c183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87yHOvQeAma_QqYbZIK_fQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@daltonabraham?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">道尔顿·亚伯拉罕</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9f3d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">除了正式的定义，<strong class="mb ir">观察者模式</strong>帮助我们倾听(订阅)一个主题，并且<strong class="mb ir"> <em class="ma">在发生变化时保持最新。</em> </strong></p><p id="9837" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">主题</strong>对<strong class="mb ir">观察者</strong>到<em class="ma">开放订阅，</em>不知道(也不关心)它们是如何实现的，反之亦然。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="6261" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:</strong></p><p id="c3ce" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您正在构建一个社交媒体应用程序，并为多个平台实现它。</p><p id="f1f5" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">一个平台枚举(为了简单起见)</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4e52" class="ne le iq na b gy nf ng l nh ni">public enum Platform {<br/>    <em class="ma">WEB(1)</em>,<br/>    MOBILE(2);<br/>}</span></pre><p id="0551" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">具有显示方法的视图界面</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="3f98" class="ne le iq na b gy nf ng l nh ni">public interface View {<br/>    void display();<br/>}</span></pre><p id="5955" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">具有添加/删除观察者和通知观察者方法的主题接口</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4777" class="ne le iq na b gy nf ng l nh ni">public interface Subject {<br/>    void registerObserver(Observer observer);<br/>    void removeObserver(Observer observer);<br/>    void notifyObservers();<br/>}</span></pre><p id="819a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">具有更新方法的观察者接口</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="fe60" class="ne le iq na b gy nf ng l nh ni">public interface Observer {<br/>    void update(Double x, Double y);<br/>}</span></pre><p id="c94a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您想在我们的应用程序中显示货币信息。根据输入的数据，您将更新屏幕上的数字。</p><p id="1210" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">实现主题接口</em>中方法的货币类</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="13e5" class="ne le iq na b gy nf ng l nh ni">public class CurrencyData implements Subject {<br/>    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();<br/>    private Double value;<br/>    private Double interestRate;</span><span id="11e1" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void registerObserver(Observer observer) {<br/>        observers.add(observer);<br/>    }</span><span id="4132" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void removeObserver(Observer observer) {<br/>        observers.remove(observer);<br/>    }</span><span id="6183" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void notifyObservers() {<br/>        observers.forEach(observer -&gt;<br/>                <strong class="na ir">observer.update(value, interestRate)</strong>);<br/>    }</span><span id="bfb2" class="ne le iq na b gy nj ng l nh ni">    public void setValue(Double value) {<br/>        this.value = value;<br/>        <strong class="na ir">notifyObservers();</strong><br/>    }</span><span id="7010" class="ne le iq na b gy nj ng l nh ni">    public void setInterestRate(Double interestRate) {<br/>        this.interestRate = interestRate;<br/>        <strong class="na ir">notifyObservers();</strong><br/>    }</span><span id="72ff" class="ne le iq na b gy nj ng l nh ni">// getters</span><span id="ae66" class="ne le iq na b gy nj ng l nh ni">}</span></pre><p id="a231" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">注意</em><strong class="mb ir"><em class="ma">notify observers()</em></strong><em class="ma">是如何在发生变化时被调用的。</em></p><p id="4509" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">随着应用程序变得越来越大，您可能想要添加新的功能，例如天气信息。</p><p id="a738" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">实现主题接口</em>中方法的天气类</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="fc88" class="ne le iq na b gy nf ng l nh ni">public class WeatherData implements Subject {<br/>    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();<br/>    private Double temperature;<br/>    private Double humidity;</span><span id="d429" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void registerObserver(Observer observer) {<br/>        observers.add(observer);<br/>    }</span><span id="5841" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void removeObserver(Observer observer) {<br/>        observers.remove(observer);<br/>    }</span><span id="c67c" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void notifyObservers() {<br/>        observers.forEach(observer -&gt;<br/>                <strong class="na ir">observer.update(temperature, humidity)</strong>);<br/>    }</span><span id="6d32" class="ne le iq na b gy nj ng l nh ni">    public void setTemperature(Double temperature) {<br/>        this.temperature = temperature;<br/>        <strong class="na ir">notifyObservers();</strong><br/>    }</span><span id="087e" class="ne le iq na b gy nj ng l nh ni">    public void setHumidity(Double humidity) {<br/>        this.humidity = humidity;<br/>        <strong class="na ir">notifyObservers();</strong><br/>    }</span><span id="5633" class="ne le iq na b gy nj ng l nh ni">// getters</span><span id="ea3e" class="ne le iq na b gy nj ng l nh ni">}</span></pre><p id="9fe7" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">实现观察者和视图接口</em>中方法的货币显示类</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="71aa" class="ne le iq na b gy nf ng l nh ni">public class CurrencyDisplay implements Observer, View {<br/>    private Platform platform;<br/>    private Double value;<br/>    private Double interestRate;</span><span id="c56f" class="ne le iq na b gy nj ng l nh ni">    public CurrencyDisplay(Platform platform, Subject subject) {<br/>       this.platform = platform;     <br/>       subject.registerObserver(this);<br/>    }</span><span id="dbfc" class="ne le iq na b gy nj ng l nh ni">    public void unsubscribe(Subject subject) {<br/>        subject.removeObserver(this);<br/>    }</span><span id="9b48" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void update(Double temperature, Double humidity) {<br/>        this.value = temperature;<br/>        this.interestRate = humidity;<br/>        display();<br/>    }</span><span id="6fd0" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void display() {<br/>        // display<br/>    }<br/>}</span></pre><p id="8698" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><em class="ma">天气显示类，实现观察者和视图接口</em>中的方法</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="5d63" class="ne le iq na b gy nf ng l nh ni">public class WeatherDisplay implements Observer, View {<br/>    private Platform platform;    <br/>    private Double temperature;<br/>    private Double humidity;</span><span id="de83" class="ne le iq na b gy nj ng l nh ni">    public WeatherDisplay(Platform platform, Subject subject) {<br/>        this.platform = platform;<br/>        subject.registerObserver(this);<br/>    }</span><span id="f939" class="ne le iq na b gy nj ng l nh ni">    public void unsubscribe(Subject subject) {<br/>        subject.removeObserver(this);<br/>    }</span><span id="430e" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void update(Double temperature, Double humidity) {<br/>        this.temperature = temperature;<br/>        this.humidity = humidity;<br/>        display();<br/>    }</span><span id="35a6" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void display() {<br/>        // display<br/>    }<br/>}</span></pre><p id="c6c2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们来看看它的实际应用:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d2bc" class="ne le iq na b gy nf ng l nh ni">CurrencyData currency = new CurrencyData();<br/>WeatherData weather = new WeatherData();</span><span id="2aa3" class="ne le iq na b gy nj ng l nh ni">CurrencyDisplay webCurrency = new CurrencyDisplay(WEB, currency);<br/>CurrencyDisplay mobileCurrency<br/>                         = new CurrencyDisplay(MOBILE, currency);<br/>// currency information is available for both platforms</span><span id="715a" class="ne le iq na b gy nj ng l nh ni">WeatherDisplay mobileWeather = new WeatherDisplay(MOBILE, weather);<br/>// weather information is available for mobile,<br/>// not available for web</span><span id="f48b" class="ne le iq na b gy nj ng l nh ni">double temperature = 21.05;<br/>weather.setTemperature(temperature);<br/>// for weather -&gt; only mobile is notified</span><span id="6ea2" class="ne le iq na b gy nj ng l nh ni">double interestRate = 14.18;<br/>currency.setInterestRate(interestRate);<br/>// for currency -&gt; both web and mobile got notified</span><span id="68fc" class="ne le iq na b gy nj ng l nh ni">mobileCurrency.unsubscribe(currency);<br/>// for currency -&gt; mobile is not listening anymore</span><span id="8ddb" class="ne le iq na b gy nj ng l nh ni">interestRate = 15.20;<br/>currency.setInterestRate(interestRate);<br/>// for currency -&gt; only web is notified</span></pre><p id="6e2b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">在<strong class="mb ir">观察者模式</strong>中，<strong class="mb ir">主体</strong>是一个<strong class="mb ir"> <em class="ma">开卷</em> </strong>。<strong class="mb ir">观察者</strong>可以根据需要自由订阅和退订<strong class="mb ir">。</strong></p><p id="24ed" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果你想退订，那么简单！既然这个设计是<strong class="mb ir"> <em class="ma">松耦合，</em> </strong>你只要调用<strong class="mb ir">退订(subject) </strong>就搞定了！</p><blockquote class="lv lw lx"><p id="8791" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">松散耦合的设计允许我们构建灵活的面向对象的系统来处理变化。它们最小化了对象之间的相互依赖。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/b60c167ce3028fb16217ab6d3db61308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcNFBGnVAzuVaA4OQOpokg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@claybanks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae kv" href="https://unsplash.com/s/photos/clay-banks-dogecoin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="282e" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:</strong></p><p id="52e7" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">观察者模式</strong>在<strong class="mb ir"> <em class="ma"> javax.swing包中被广泛使用。</em> </strong></p><p id="8d39" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们考虑一个服务，它将根据数据的变化更新显示和数据库信息:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="f177" class="ne le iq na b gy nf ng l nh ni">UserData data = new UserData();</span><span id="99bd" class="ne le iq na b gy nj ng l nh ni">Display webDisplay = new Display(WEB, data);<br/>Display mobileDisplay = new Display(MOBILE, data);</span><span id="8ed7" class="ne le iq na b gy nj ng l nh ni">Database postgresql = new Postgresql(data);<br/>Database couchbase = new Couchbase(data);</span><span id="f036" class="ne le iq na b gy nj ng l nh ni">// web display, mobile display, postgresql and couchbase<br/>// all subscribed to user data.</span></pre><p id="e8a0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">按钮是这里的<strong class="mb ir">主题</strong>，当点击按钮时，数据发生变化。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8705" class="ne le iq na b gy nf ng l nh ni">button.addActionListener((ActionListener) <br/>                ae -&gt; data.setEmail(email));</span></pre><p id="d496" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">当数据发生变化时，所有的观察者都会得到通知并得到更新。</p><p id="3f39" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">把它当成一个故事来读:<br/> </strong> <a class="ae kv" href="http://emretanriverdi.medium.com/observer-pattern-a-quick-guide-38865dc9bae2" rel="noopener">观察者模式—快速指南</a> (4分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="daaa" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">4工厂模式</h1><blockquote class="lv lw lx"><p id="c2f7" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">"工厂模式有三种类型:<strong class="mb ir">简单、方法和抽象."</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a3d8557027edb10c79e2069bf25469a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIj2ay1qzULuOA7ZrgJJDA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nataliekuhl?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">娜塔莉·库尔</a>在<a class="ae kv" href="https://unsplash.com/s/photos/factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="37c9" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">简单工厂</h2><p id="f259" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated">假设您有一个<strong class="mb ir"> <em class="ma">本地披萨店</em> </strong>，并且您为您获得的每一个订单实例化<strong class="mb ir">一个</strong> <strong class="mb ir">披萨对象</strong>。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8808" class="ne le iq na b gy nf ng l nh ni">Pizza pizza = new Pizza();</span></pre><p id="3a5a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">相反，您可以简单地这样做:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ad86" class="ne le iq na b gy nf ng l nh ni">public class Pizza {<br/>    private Pizza(){}     // hide the constructor, so no one         <br/>                                initializes pizza with "new"</span><span id="2408" class="ne le iq na b gy nj ng l nh ni">    public static Pizza create() {<br/>        return new Pizza();<br/>    }<br/>}</span></pre><p id="6aea" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">或者这个:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a3aa" class="ne le iq na b gy nf ng l nh ni">public class PizzaFactory {<br/>    public static Pizza create() {<br/>        return new Pizza();<br/>    }<br/>}</span><span id="891c" class="ne le iq na b gy nj ng l nh ni">public class Pizza {<br/>   <br/>   // assuming your models are in the same package, you can<br/>   make this package-private to make sure constructor won't be    <br/>   called from client code<br/>   protected Pizza(){}<br/>}</span></pre><p id="52a9" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码将如下所示:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="833a" class="ne le iq na b gy nf ng l nh ni">Pizza pizza = Pizza.create();</span><span id="34a5" class="ne le iq na b gy nj ng l nh ni">or</span><span id="415a" class="ne le iq na b gy nj ng l nh ni">Pizza pizza = PizzaFactory.create();</span></pre><p id="88d0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果你想改变这个方法的工作方式(或者可能给它添加一些业务逻辑)，你可以更新<strong class="mb ir"> create </strong>，而不是把逻辑代码放到构造函数中。</p><p id="b0e2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">别担心，我听到了，你说我们可以用构造函数实现同样的事情。简单工厂基本上是一个有自定义名称的构造函数。</p><p id="a5ad" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">这样想吧:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9e63" class="ne le iq na b gy nf ng l nh ni">Person person = new Person(170);</span><span id="b889" class="ne le iq na b gy nj ng l nh ni">to</span><span id="28c6" class="ne le iq na b gy nj ng l nh ni">Person person = Person.fromHeight(170);</span><span id="f930" class="ne le iq na b gy nj ng l nh ni">or</span><span id="c249" class="ne le iq na b gy nj ng l nh ni">Person person = PersonFactory.fromHeight(170);</span></pre><p id="4a02" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">用不用由你决定。我个人很喜欢。</p><p id="efba" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">然而，有些人甚至不把简单工厂算作一种设计模式。<br/>工厂方法和抽象工厂相反，有点不同。</p><p id="8a89" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">那么让我们来看一下<strong class="mb ir">工厂方法</strong>。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="d8c6" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">工厂方法</h2><p id="4316" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated">那么…回到订单管理系统。</p><p id="6a53" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设你的生意越来越大，你开始卖汉堡。</p><p id="c6e2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">工厂方法通过覆盖一个方法来帮助你在比萨饼和汉堡之间进行选择，但是在一个公共方法中保持不变的部分。</p><p id="0bd1" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们首先用实现它的膳食创建一个膳食接口。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="0ee8" class="ne le iq na b gy nf ng l nh ni">public interface Meal {<br/>    // implementations<br/>}</span><span id="2394" class="ne le iq na b gy nj ng l nh ni">public class Pizza implements Meal {<br/>    // implementations<br/>}</span><span id="67b9" class="ne le iq na b gy nj ng l nh ni">public class Burger implements Meal {<br/>    // implementations<br/>}</span></pre><p id="d0c6" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们用PizzaFactory和BurgerFactory实现一个更通用的MealFactory接口。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="325a" class="ne le iq na b gy nf ng l nh ni">interface MealFactory {<br/>    //factory method<br/>    <strong class="na ir">Meal</strong> create();        // compulsory inheritance<br/>}</span><span id="df76" class="ne le iq na b gy nj ng l nh ni">public class PizzaFactory implements MealFactory {<br/>    // implementations</span><span id="4bd7" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    Meal create() {<br/>        return new Pizza();<br/>    }<br/>}</span><span id="79e2" class="ne le iq na b gy nj ng l nh ni">public class BurgerFactory implements MealFactory {<br/>    // implementations<br/>   <br/>    @Override<br/>    Meal create() {<br/>        return new Burger();<br/>    }<br/>}</span></pre><p id="15e3" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">这两种比萨饼都根据自己的需要超越<strong class="mb ir">创造</strong>。</p><p id="e91c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">现在，客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="be5b" class="ne le iq na b gy nf ng l nh ni">MealFactory pizzaFactory = new PizzaFactory();<br/>Meal pizza = pizzaFactory.create();</span><span id="3d4c" class="ne le iq na b gy nj ng l nh ni">MealFactory burgerFactory = new BurgerFactory();<br/>Meal burger = burgerFactory.create();</span></pre><p id="c9c4" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">就是这样！</p><p id="31d4" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果两餐都有一个公共的方法，不管它们是什么类型，你可以把MealFactory变成抽象类，而不是接口。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="5da2" class="ne le iq na b gy nf ng l nh ni">abstract class MealFactory {<br/>    //factory method<br/>    protected abstact <strong class="na ir">Meal</strong> create();     // compulsory inheritance</span><span id="12c7" class="ne le iq na b gy nj ng l nh ni">    public void createAndSendOrder() {<br/>        Meal meal = create();<br/>        // do stuff<br/>    }<br/>}</span><span id="6fbf" class="ne le iq na b gy nj ng l nh ni">public class PizzaFactory extends MealFactory {<br/>    // implementations</span><span id="8f7a" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    protected Meal create() {<br/>        return new Pizza();<br/>    }<br/>}</span><span id="175e" class="ne le iq na b gy nj ng l nh ni">public class BurgerFactory extends MealFactory {<br/>    // implementations<br/>   <br/>    @Override<br/>    protected Meal create() {<br/>        return new Burger();<br/>    }<br/>}</span></pre><p id="c031" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="c7cd" class="ne le iq na b gy nf ng l nh ni">MealFactory pizzaFactory = new PizzaFactory();<br/>pizzaFactory.createAndSendOrder();</span><span id="3376" class="ne le iq na b gy nj ng l nh ni">MealFactory burgerFactory = new BurgerFactory();<br/>burgerFactory.createAndSendOrder();</span></pre><p id="3422" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">这很棒，因为我还完全封装了客户端的创建逻辑。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="7c00" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">抽象工厂</h2><p id="df7d" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated">现在让我们增加比萨饼和汉堡的素食选择。</p><p id="4e9d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">所以会是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="09be" class="ne le iq na b gy nf ng l nh ni">interface MealFactory {<br/>    <strong class="na ir">Pizza</strong> createPizza();      // no inheritance needed<br/>    <strong class="na ir">Burger</strong> createBurger();    // no inheritance needed<br/>}</span><span id="e9c3" class="ne le iq na b gy nj ng l nh ni">public class VeganMealFactory implements MealFactory {</span><span id="b26e" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public Pizza createPizza() {<br/>        return new VeganPizza();<br/>    }</span><span id="f8a9" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public Burger createBurger() {<br/>        return new VeganBurger();<br/>    }<br/>}</span><span id="d60d" class="ne le iq na b gy nj ng l nh ni">public class NonVeganMealFactory implements MealFactory {</span><span id="d19c" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public Pizza createPizza() {<br/>        return new NonVeganPizza();<br/>    }</span><span id="b0bd" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public Burger createBurger() {<br/>        return new NonVeganBurger();<br/>    }<br/>}</span></pre><p id="d48c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">现在它是工厂中的工厂。</p><p id="1240" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">在工厂方法中，只有一个方法负责制作比萨饼，而在这里，我们为不同的比萨饼使用不同的方法，所以整个类都要负责。</p><p id="818e" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">在工厂的方法中，比萨饼和汉堡需要在类型餐，<br/>在这里它不是强制性的。</p><p id="7546" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们看看客户端代码:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="feb5" class="ne le iq na b gy nf ng l nh ni">MealFactory veganMealFactory = new VeganMealFactory();<br/>MealFactory nonVeganMealFactory = new NonVeganMealFactory();</span><span id="013d" class="ne le iq na b gy nj ng l nh ni">Pizza veganPizza = veganMealFactory.createPizza();<br/>Burger veganBurger = veganMealFactory.createBurger();</span><span id="0cb8" class="ne le iq na b gy nj ng l nh ni">Pizza nonVeganPizza = nonVeganMealFactory.createPizza();<br/>Burger nonVeganBurger = nonVeganMealFactory.createBurger();</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="a918" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">既然VeganMealFactory和NonVeganMealFactory都属于PizzaFactory类型，我们就不能用一个简单的判定器在它们之间做出决定吗？</p><p id="74a0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们来试试:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9977" class="ne le iq na b gy nf ng l nh ni">public class MealFactoryDecider {</span><span id="0106" class="ne le iq na b gy nj ng l nh ni">    private MealFactoryDecider(){}</span><span id="9d71" class="ne le iq na b gy nj ng l nh ni">    public static MealFactory decide(MealType mealType) {<br/>        switch (mealType) {<br/>            case <em class="ma">VEGAN</em>:<br/>                return new VeganMealFactory();<br/>            case <em class="ma">NONVEGAN</em>:<br/>                return new NonVeganMealFactory();<br/>            default: throw new RuntimeException("Invalid type.");<br/>        }<br/>    }<br/>}</span></pre><p id="72ce" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">最终的客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="101b" class="ne le iq na b gy nf ng l nh ni">MealFactory veganMealFactory =<br/>MealFactoryDecider.decide(<em class="ma">VEGAN</em>);</span><span id="fce6" class="ne le iq na b gy nj ng l nh ni">MealFactory nonVeganMealFactory = MealFactoryDecider.decide(<em class="ma">NONVEGAN</em>);</span><span id="1615" class="ne le iq na b gy nj ng l nh ni">Pizza veganPizza = veganMealFactory.createPizza();<br/>Burger veganBurger = veganMealFactory.createBurger();</span><span id="4ba7" class="ne le iq na b gy nj ng l nh ni">Pizza nonVeganPizza = nonVeganMealFactory.createPizza();<br/>Burger nonVeganBurger = nonVeganMealFactory.createBurger();</span></pre><p id="0283" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果你觉得多种模式会很合适，记得结合使用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="3dfc" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">总结</h2><p id="16aa" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated"><strong class="mb ir">简单工厂</strong>依赖于可读性:虽然它可能不被认为是一种设计模式，但它是一种将客户从具体类中分离出来的简单方法。</p><p id="48cd" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">工厂方法依赖于继承:对象创建被委托给实现特定工厂方法来创建对象的子类。</p><p id="7b01" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">抽象工厂</strong>依赖组合:对象创建是在工厂接口中暴露的多个方法中实现的。</p><blockquote class="lv lw lx"><p id="03e8" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">所有工厂模式都通过减少应用程序对具体类的依赖来促进松散耦合。</p></blockquote><p id="5892" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">将它作为一个单独的故事来阅读:<br/> </strong> <a class="ae kv" href="https://emretanriverdi.medium.com/factory-pattern-a-quick-guide-cd31eeeefb74" rel="noopener">工厂模式—快速指南</a> (4分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="32ff" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">5-单例模式</h1><blockquote class="lv lw lx"><p id="74cf" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir">“单例模式</strong>确保一个类只有<strong class="mb ir">一个实例</strong>，并提供一个全局访问点。”</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/b0c69841b5bf0106048bced2853b877d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjfFAqhFIA2aP802Js_sJw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@davisuko?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> davisuko </a>在<a class="ae kv" href="https://unsplash.com/s/photos/unique?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="1f2d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:<br/> </strong>假设你需要一个木匠做一个沙发、椅子和橱柜。如果你叫一个木匠，和他一起做所有的工作，那是最好的。为每件物品找不同的木匠是不明智的。</p><p id="56ce" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:<br/> </strong>和简单的例子很像。假设您需要一个数据库客户机来处理所有的CRUD操作。<br/>您不希望有多个数据库客户端，因为这会导致意外行为，如内存问题和数据损坏。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="c5e3" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">履行</h2><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="60dc" class="ne le iq na b gy nf ng l nh ni">public class Singleton {</span><span id="f352" class="ne le iq na b gy nj ng l nh ni">private static Singleton instance;<br/>    <br/>    private Singleton(){}    // hiding the constructor<br/>    <br/>    public static Singleton getInstance() {<br/>        if (instance == null) {<br/>            instance = new Singleton();<br/>        }<br/>        return instance;<br/>    }<br/>    // other methods<br/>}</span></pre><p id="d560" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码是:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2870" class="ne le iq na b gy nf ng l nh ni">Singleton singleton = Singleton.getInstance();</span></pre><p id="496c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">在上面的实现中，逻辑是这样的:<br/>如果对象不存在→创建并返回对象<br/>如果对象存在→返回已经创建的对象</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="1391" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">处理多线程</h2><p id="051d" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated">上述代码块的问题是，在多线程应用程序中，如果线程在第一次使用<strong class="mb ir"> getInstance() </strong>时并发访问同一个<strong class="mb ir"/><strong class="mb ir"/>块，则对象可能会被初始化多次。</p><p id="3f35" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们继续讨论可能的解决方案:</p><p id="22e8" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 1。急切初始化</strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9e6b" class="ne le iq na b gy nf ng l nh ni">public class Singleton {</span><span id="6f6c" class="ne le iq na b gy nj ng l nh ni">private static Singleton instance = new Singleton();<br/>    <br/>    private Singleton(){}    // hiding the constructor<br/>    <br/>    public static Singleton getInstance() {<br/>       return instance;<br/>    }<br/>    // other methods<br/>}</span></pre><p id="7b3d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">使用这种方法，我们将责任交给JVM，当类被加载时，JVM初始化我们的Singleton实例，因此多线程不是问题。</p><p id="0315" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果你确定在你的应用程序中至少会使用<strong class="mb ir"> getInstance() </strong>一次，你可以使用这个。</p><p id="1079" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 2。锁定初始化</strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4c48" class="ne le iq na b gy nf ng l nh ni">public class Singleton {</span><span id="5299" class="ne le iq na b gy nj ng l nh ni">private static Singleton instance;<br/>    <br/>    private Singleton(){}    // hiding the constructor<br/>    <br/>    public static <strong class="na ir">synchronized</strong> Singleton getInstance() {<br/>        if (instance == null) {<br/>            instance = new Singleton();<br/>        }<br/>        return instance;<br/>    }<br/>    // other methods<br/>}</span></pre><p id="c918" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">我们可以使用<strong class="mb ir"> synchronized </strong>关键字锁定<strong class="mb ir"> getInstance() </strong>，并强制其他线程等待当前线程退出后再进入该代码块。</p><p id="d14c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">虽然上面的例子是正确的(并且在大多数例子中使用)，但这是一种不好的做法。我们不需要在每次调用<strong class="mb ir"> getInstance() </strong>时锁定方法，<strong class="mb ir">我们需要在第一次调用时锁定它。</strong>由于锁定是一个性能开销很大的操作，我们最好不要锁定整个方法。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2147" class="ne le iq na b gy nf ng l nh ni">public class Singleton {</span><span id="7040" class="ne le iq na b gy nj ng l nh ni">private static <strong class="na ir">volatile</strong> Singleton instance;<br/>    <br/>    private Singleton(){}    // hiding the constructor<br/>    <br/>    public static Singleton getInstance() {<br/>        if (instance == null) {<br/>            <strong class="na ir">synchronized(Singleton.class) {<br/>                instance = new Singleton();<br/>            }</strong><br/>        }<br/>        return instance;<br/>    }<br/>    // other methods<br/>}</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="6a86" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">需要考虑的事项</h2><p id="f9df" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated">虽然单例模式很棒并且被广泛使用，但它有时被认为是一种反模式，因为它可以帮助我们掩盖糟糕的设计。</p><p id="0922" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 1。违反松耦合<br/> </strong>当我们像<strong class="mb ir"> Singleton.getInstance()，<br/> </strong>一样传递单例类时，我们可能没有意识到我们的应用程序的类彼此知道得太多，太紧耦合了。<br/>例如，在我们的应用程序中传递数据库客户端是一种不好的做法。</p><p id="0281" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 2。违反单一责任原则<br/> </strong>单一模式既要确保一个类只有一个实例，又要提供一个访问它的访问点，这使得它肩负着两项巨大的责任。</p><p id="c7a2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 3。单例模式vs静态类<br/> </strong>我们可以用上面的if检查让单例延迟初始化，静态方法默认是延迟初始化的。<br/>单例允许方法覆盖，静态方法不允许覆盖，但可以通过方法隐藏实现类似的行为。</p><p id="9eb2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">何时使用静态类:</strong>如果你打算编写诸如数学、数组操作等辅助方法。，使用一个充满静态帮助器方法的类可能更容易。</p><p id="dd25" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">何时使用Singleton: </strong>其余一切。Singleton类只是一个遵循普通OOP原则的普通类。</p><p id="6dd9" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 4。单例模式vs依赖注入<br/> </strong>如果你已经在使用一个处理注入的框架，那么仅仅注入类而不是应用单例模式可能是一个更好的实践。</p><p id="51e2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">我更喜欢先检查它是不是一个helper方法，如果是，就创建一个静态类。<br/>如果没有，请检查我们的DI可用性。如果是，使用DI。如果没有，使用Singleton。</p><p id="5c05" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">将它作为一个单独的故事来阅读:<br/> </strong> <a class="ae kv" href="https://emretanriverdi.medium.com/singleton-pattern-a-quick-guide-2836a3e1696e" rel="noopener">单一模式—快速指南</a> (4分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="46af" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">6-构建器模式</h1><blockquote class="lv lw lx"><p id="841d" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir">“构建器模式</strong>通过允许使用相同的构建代码创建对象的不同表示，帮助我们构建复杂的对象。”</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/1e612cedbe969d3b1bf5ef440f41f951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPNYZYkpKjGfMo0SdUvCqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> neonbrand </a>在<a class="ae kv" href="https://unsplash.com/s/photos/brick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="09f0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">构造器模式</strong>只是<strong class="mb ir"> <em class="ma">伸缩式构造器</em> </strong>和<strong class="mb ir"> <em class="ma"> <br/>多行设置器的简单替代。</em> </strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="5aa8" class="ne le iq na b gy nf ng l nh ni">public class Pizza {</span><span id="17b6" class="ne le iq na b gy nj ng l nh ni">   private int slices;<br/>   private boolean cheese;<br/>   private boolean mushrooms;</span><span id="4b0a" class="ne le iq na b gy nj ng l nh ni">public Pizza(int slices) { … }  <br/>   public Pizza(int slices, boolean cheese) { … }<br/>   public Pizza(int slices, boolean cheese, boolean mushrooms) { … }</span><span id="2ea9" class="ne le iq na b gy nj ng l nh ni">// implement methods</span><span id="0e30" class="ne le iq na b gy nj ng l nh ni">}</span></pre><p id="f4c6" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">这就是伸缩构造函数的样子。我们可以进一步扩展:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="0c1c" class="ne le iq na b gy nf ng l nh ni">public Pizza(int slices, boolean cheese, boolean mushrooms, boolean pepperoni, boolean onions, boolean studentDiscount…) { … }</span></pre><p id="a1bf" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设slices是必需的参数，其余的不是，<br/>为每个可选字段创建不同的构造函数来满足所有的对象组合是不明智的。</p><p id="eb52" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">消除这种情况的最简单的方法是创建一个构造函数，它接受slice参数并根据我们的需要设置其余的字段。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="fa4e" class="ne le iq na b gy nf ng l nh ni">public class Pizza {</span><span id="6862" class="ne le iq na b gy nj ng l nh ni">private int slices;<br/>   private boolean cheese;<br/>   private boolean mushrooms;</span><span id="40ba" class="ne le iq na b gy nj ng l nh ni">public Pizza(int slices) { … }</span><span id="4775" class="ne le iq na b gy nj ng l nh ni">}</span></pre><p id="6eba" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="92ab" class="ne le iq na b gy nf ng l nh ni">Pizza pizza = new Pizza(2);</span><span id="31e5" class="ne le iq na b gy nj ng l nh ni">pizza.setCheese(true);<br/>pizza.setMushrooms(true);<br/>pizza.setPepperoni(true);<br/>…</span></pre><p id="d89a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">这个替代方案看起来也不怎么样。<br/>保存这段代码最简单的方法是创建一个构建器类，比如:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ae43" class="ne le iq na b gy nf ng l nh ni">public class Pizza {<br/>    private int slices;<br/>    private boolean cheese;<br/>    private boolean mushrooms;<br/>    private boolean pepperoni;<br/>    private boolean onions;<br/>    private boolean studentDiscount;</span><span id="b8d6" class="ne le iq na b gy nj ng l nh ni">    public Pizza(Builder builder) {<br/>        this.slices = builder.slices;<br/>        this.cheese = builder.cheese;<br/>        this.mushrooms = builder.mushrooms;<br/>        this.pepperoni = builder.pepperoni;<br/>        this.onions = builder.onions;<br/>        this.studentDiscount = builder.studentDiscount;<br/>    }</span><span id="c88b" class="ne le iq na b gy nj ng l nh ni">// getters &amp; setters</span><span id="06fd" class="ne le iq na b gy nj ng l nh ni">public static final class Builder {<br/>        private int slices;<br/>        private boolean cheese;<br/>        private boolean mushrooms;<br/>        private boolean pepperoni;<br/>        private boolean onions;<br/>        private boolean studentDiscount;</span><span id="2f3d" class="ne le iq na b gy nj ng l nh ni">    private Builder() {}</span><span id="12f7" class="ne le iq na b gy nj ng l nh ni">    public static Builder initialize(int slices) {<br/>            return new Builder().withSlices(slices);<br/>        }</span><span id="125f" class="ne le iq na b gy nj ng l nh ni">    public Builder withSlices(int slices) {<br/>            this.slices = slices;<br/>            return this;<br/>        }</span><span id="ede0" class="ne le iq na b gy nj ng l nh ni">    public Builder withCheese() {<br/>            this.cheese = true;<br/>            return this;<br/>        }</span><span id="fb65" class="ne le iq na b gy nj ng l nh ni">    public Builder withMushrooms() {<br/>            this.mushrooms = true;<br/>            return this;<br/>        }</span><span id="4abe" class="ne le iq na b gy nj ng l nh ni">    public Builder withPepperoni() {<br/>            this.pepperoni = true;<br/>            return this;<br/>        }</span><span id="fc3a" class="ne le iq na b gy nj ng l nh ni">    public Builder withOnions() {<br/>            this.onions = true;<br/>            return this;<br/>        }</span><span id="4087" class="ne le iq na b gy nj ng l nh ni">    public Builder withStudentDiscount() {<br/>            this.studentDiscount = true;<br/>            return this;<br/>        }</span><span id="b1a3" class="ne le iq na b gy nj ng l nh ni">    public Pizza build() {<br/>            return new Pizza(this);<br/>        }<br/>    }<br/>}</span></pre><p id="e8cb" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">因为slices是一个必需字段，所以Builder的私有构造函数是隐藏的，它有一个简单的工厂方法，只允许用slices进行初始化。</p><p id="ac3c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">直到<strong class="mb ir"> build() </strong>方法被调用，构建器返回一个构建器类型<strong class="mb ir">，<br/> build() </strong>方法转换比萨饼。一个实际的比萨饼对象。</p><p id="12b8" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="bc6f" class="ne le iq na b gy nf ng l nh ni">Pizza pizza = Pizza<em class="ma">.Builder</em><br/>                  <em class="ma"> .initialize(</em>2<em class="ma">)<br/>                   .withCheese()<br/>                   .withMushrooms()<br/>                   .withStudentDiscount()<br/>                   </em>.build();</span></pre><p id="919b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">将它作为一个单独的故事来阅读:<br/> </strong> <a class="ae kv" href="https://emretanriverdi.medium.com/builder-pattern-a-quick-guide-e93494d5429e" rel="noopener">构建者模式—快速指南</a> (2分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="aa2a" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">7-命令模式</h1><blockquote class="lv lw lx"><p id="00fa" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir">“命令模式</strong>将一个请求封装成一个对象，帮助我们在不同的请求中使用它，并支持撤销操作。”</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/0c52865727d1febaa6ee10469c394640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98CNTMs1GjsZWO06vME4yg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼尔·布拉德利在<a class="ae kv" href="https://unsplash.com/s/photos/order?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="3ff0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">命令模式</strong>就像在餐馆点菜。</p><p id="9533" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">厨师不听顾客自己的命令，他/她使用助手。<br/>(像服务员一样)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/aba1918662751895b6dfc7578fe70d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cup0IhpHkupy0aJBkvzpOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">艺术由<a class="ae kv" href="https://zhart.us/" rel="noopener ugc nofollow" target="_blank">德米特里扎尔特</a></p></figure><p id="2e31" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设你有一台空调，你需要打开/关闭它。</p><p id="8206" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">通常在这个用例中，你可以简单地用<strong class="mb ir"> turnOn() </strong>和<strong class="mb ir"> turnOff() </strong>方法写一个<strong class="mb ir">空调</strong>类，但是这次<strong class="mb ir">我们将在类中而不是在方法中实现动作。</strong></p><p id="8378" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">为此，您可以编写一个助手类，如<strong class="mb ir"> RemoteControl。</strong></p><p id="076b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">现在是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/ff59643b13064d2bde3fd603273e16d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQF8PC6SDWVpuv3wlFpVRw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">艺术由<a class="ae kv" href="https://zhart.us/" rel="noopener ugc nofollow" target="_blank">德米特里扎尔特</a></p></figure><p id="69a8" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">我们是客户，遥控器是服务员，AC是厨师。</p><p id="ee3b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们看看它的代码:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b068" class="ne le iq na b gy nf ng l nh ni">public class AirConditioner {<br/>    private boolean active;</span><span id="9482" class="ne le iq na b gy nj ng l nh ni">    void turnOn() {<br/>        active = true;<br/>    }</span><span id="bde4" class="ne le iq na b gy nj ng l nh ni">    void turnOff() {<br/>        active = false;<br/>    }<br/>}</span></pre><p id="b20f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">开/关动作(命令)需要单独的类，例如:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="c31a" class="ne le iq na b gy nf ng l nh ni">public interface Command {<br/>    void execute();<br/>    void undo();<br/>}</span><span id="fe47" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">AirConditionerOff</strong> implements Command {<br/>    private final AirConditioner airConditioner;</span><span id="e76a" class="ne le iq na b gy nj ng l nh ni">    public AirConditionerOff(AirConditioner airConditioner) {<br/>        this.airConditioner = airConditioner;<br/>    }</span><span id="7b4e" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void execute() {<br/>        <strong class="na ir">airConditioner.turnOff();</strong><br/>    }</span><span id="162f" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void undo() {<br/>        airConditioner.turnOn();<br/>    }<br/>}</span><span id="17ea" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">AirConditionerOn</strong> implements Command {<br/>    private final AirConditioner airConditioner;</span><span id="831b" class="ne le iq na b gy nj ng l nh ni">    public AirConditionerOn(AirConditioner airConditioner) {<br/>        this.airConditioner = airConditioner;<br/>    }</span><span id="12f0" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void execute() {<br/>        <strong class="na ir">airConditioner.turnOn();</strong><br/>    }</span><span id="dbc0" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void undo() {<br/>        airConditioner.turnOff();<br/>    }<br/>}</span></pre><p id="710f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">而且你需要一个助手(invoker)在我们和AC之间沟通:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="eb86" class="ne le iq na b gy nf ng l nh ni">public class RemoteControl {</span><span id="d9dc" class="ne le iq na b gy nj ng l nh ni">private RemoteControl(){}         // hiding the constructor</span><span id="118b" class="ne le iq na b gy nj ng l nh ni">    public static void submit(Command command) {<br/>        command.execute();<br/>    }</span><span id="eaeb" class="ne le iq na b gy nj ng l nh ni">    public static void undo(Command command) {<br/>        command.undo();<br/>    }<br/>}</span></pre><p id="5361" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="e8b3" class="ne le iq na b gy nf ng l nh ni">AirConditioner airConditioner = new AirConditioner();</span><span id="a83b" class="ne le iq na b gy nj ng l nh ni">Command turnOn = new AirConditionerOn(airConditioner);<br/>Command turnOff = new AirConditionerOff(airConditioner);</span><span id="205f" class="ne le iq na b gy nj ng l nh ni">RemoteControl.<em class="ma">submit</em>(turnOn);    // turned air conditioner on<br/>RemoteControl.<em class="ma">undo</em>(turnOn);      // turned air conditioner off</span><span id="b692" class="ne le iq na b gy nj ng l nh ni">RemoteControl.<em class="ma">submit</em>(turnOn);    // turned air conditioner on<br/>RemoteControl.<em class="ma">submit</em>(turnOff);   // turned air conditioner off</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="e6b1" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">多个命令&amp;堆栈</strong></p><p id="618a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果你想创建一个具有多个命令的应用程序，而不仅仅是开/关，该怎么办？</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="6b42" class="ne le iq na b gy nf ng l nh ni">public class AirConditioner {<br/>    private int power;</span><span id="d366" class="ne le iq na b gy nj ng l nh ni">    void off() {<br/>        power = Power.<em class="ma">OFF</em>;     // OFF = 0<br/>    }</span><span id="b603" class="ne le iq na b gy nj ng l nh ni">    void low() {<br/>        power = Power.<em class="ma">LOW</em>;     // LOW = 1<br/>    }</span><span id="9031" class="ne le iq na b gy nj ng l nh ni">    void medium() {<br/>        power = Power.<em class="ma">MEDIUM</em>;  // MEDIUM = 2<br/>    }</span><span id="1e24" class="ne le iq na b gy nj ng l nh ni">    void high() {<br/>        power = Power.<em class="ma">HIGH</em>;    // HIGH = 3<br/>    }<br/>}</span><span id="6027" class="ne le iq na b gy nj ng l nh ni">public interface Command {<br/>    void execute();<br/>    <br/>  <em class="ma"> // undo is gone from here for now, we'll see it below later</em></span><span id="fb8d" class="ne le iq na b gy nj ng l nh ni">}</span><span id="6485" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">AirConditionerOff</strong> implements Command {<br/>    private final AirConditioner airConditioner;</span><span id="4168" class="ne le iq na b gy nj ng l nh ni">    public AirConditionerOff(AirConditioner airConditioner) {<br/>        this.airConditioner = airConditioner;<br/>    }</span><span id="23e0" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void execute() {<br/>        <strong class="na ir">airConditioner.off();</strong><br/>    }<br/>}</span><span id="15fa" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">AirConditionerLowPower</strong> implements Command {<br/>    private final AirConditioner airConditioner;</span><span id="cef0" class="ne le iq na b gy nj ng l nh ni">    public AirConditionerLowPower(AirConditioner airConditioner) {<br/>        this.airConditioner = airConditioner;<br/>    }</span><span id="2316" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void execute() {<br/>        <strong class="na ir">airConditioner.low();</strong><br/>    }<br/>}</span><span id="7680" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">AirConditionerMediumPower</strong> implements Command {<br/>    private final AirConditioner airConditioner;</span><span id="8c19" class="ne le iq na b gy nj ng l nh ni">    public AirConditionerMediumPower(AirConditioner airConditioner){<br/>        this.airConditioner = airConditioner;<br/>    }</span><span id="70bf" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void execute() {<br/>        <strong class="na ir">airConditioner.medium();</strong><br/>    }<br/>}</span><span id="bb1b" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">AirConditionerHighPower</strong> implements Command {<br/>    private final AirConditioner airConditioner;</span><span id="96c3" class="ne le iq na b gy nj ng l nh ni">    public AirConditionerHighPower(AirConditioner airConditioner){<br/>        this.airConditioner = airConditioner;<br/>    }</span><span id="76fa" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void execute() {<br/>        <strong class="na ir">airConditioner.high();</strong><br/>    }<br/>}</span></pre><p id="15c7" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">但是这一次撤销操作有点复杂。由于现在有多个命令，您需要知道客户端采取的确切步骤。</p><p id="c1e9" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">要实现这一点，你可以使用堆栈数据结构。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a2c7" class="ne le iq na b gy nf ng l nh ni">public class RemoteControl {</span><span id="693b" class="ne le iq na b gy nj ng l nh ni">    private RemoteControl() {}</span><span id="5c5a" class="ne le iq na b gy nj ng l nh ni">    private static final Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();<br/>    private static final Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();</span><span id="7560" class="ne le iq na b gy nj ng l nh ni">    public static void submit(Command command) {<br/>        command.execute();</span><span id="cf22" class="ne le iq na b gy nj ng l nh ni">    undoStack.add(command);<br/>        redoStack.clear();<br/>    }</span><span id="973e" class="ne le iq na b gy nj ng l nh ni">    public static void undo() {<br/>        if (!undoStack.isEmpty()) {<br/>            undoStack.peek().execute();<br/>            redoStack.add(undoStack.pop());<br/>        }<br/>    }</span><span id="3efe" class="ne le iq na b gy nj ng l nh ni">    public static void redo() {<br/>        if (!redoStack.isEmpty()) {<br/>            redoStack.peek().execute();<br/>            undoStack.add(redoStack.pop());<br/>        }<br/>    }<br/>}</span></pre><p id="085c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">现在我们应该能够使用多个命令，并且支持撤销/重做操作。:)</p><p id="2db5" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">让我们看看客户端代码:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8684" class="ne le iq na b gy nf ng l nh ni">AirConditioner airConditioner = new AirConditioner();</span><span id="f2cd" class="ne le iq na b gy nj ng l nh ni">Command highPower = new AirConditionerHighPower(airConditioner);<br/>Command mediumPower = new AirConditionerMediumPower(airConditioner);<br/>Command lowPower = new AirConditionerLowPower(airConditioner);<br/>Command off = new AirConditionerOff(airConditioner);</span><span id="8c99" class="ne le iq na b gy nj ng l nh ni">// feel free to apply any creational design pattern above</span><span id="1d71" class="ne le iq na b gy nj ng l nh ni">RemoteControl.<em class="ma">submit</em>(highPower);      // air conditioner set HIGH<br/>RemoteControl.<em class="ma">submit</em>(lowPower);       // air conditioner set LOW<br/>RemoteControl.<em class="ma">submit</em>(mediumPower);    // air conditioner set MEDIUM</span><span id="20f1" class="ne le iq na b gy nj ng l nh ni">RemoteControl.<em class="ma">undo</em>();                 // air conditioner set LOW<br/>RemoteControl.<em class="ma">undo</em>();                 // air conditioner set HIGH</span><span id="3b33" class="ne le iq na b gy nj ng l nh ni">RemoteControl.<em class="ma">redo</em>();                 // air conditioner set LOW</span><span id="52cb" class="ne le iq na b gy nj ng l nh ni">RemoteControl.<em class="ma">submit</em>(off);            // air conditioner set OFF</span></pre><p id="565b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">将它作为一个单独的故事来阅读:<br/> </strong> <a class="ae kv" href="https://emretanriverdi.medium.com/command-pattern-a-quick-guide-3e618fe82f1c" rel="noopener">命令模式—快速指南</a> (4分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="8b81" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">8-适配器模式</h1><blockquote class="lv lw lx"><p id="e842" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir">"适配器模式</strong>将一个类的接口转换成客户期望的另一个接口。<strong class="mb ir"> </strong>适配器<strong class="mb ir">让类一起工作</strong>，否则会因为<strong class="mb ir">不兼容的接口而无法工作</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/be089c1d991d86341df0a18646d988c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omo70eXsCq0D_SPDAmddaA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae kv" href="https://unsplash.com/s/photos/plug?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="bdaa" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:<br/> </strong>假设你从欧洲旅行到美国，由于使用了不同的插座，你需要一个适配器/包装器/转换器来使用你的设备。</p><p id="c94d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:<br/> </strong>假设你正在编写一个应用程序，你正在使用一个Kafka客户端来消费来自一个主题的消息。</p><p id="188c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">这个客户端拥有名为<strong class="mb ir"> consume </strong>和<strong class="mb ir"> produce </strong>的方法来读写Kafka主题的消息，而您正在监听主题的代理拥有1.8版本。<br/>让我们称之为:<em class="ma">客户端a。</em></p><p id="bbf1" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">现在你需要听另一个经纪人的另一个话题。这个代理的版本是2.4，而你的Kafka客户端还不支持这个版本。你找另一个卡夫卡的客户来帮你。<br/>让我们称之为:<em class="ma">客户端b。</em></p><p id="4150" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">但是有一个问题:你根据<em class="ma">客户端A </em>编写了所有代码，但是<br/> <em class="ma">客户端B </em>使用了不同的约定。</p><p id="2fcc" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">例如，它使用名称<strong class="mb ir">读</strong>而不是<strong class="mb ir">消费</strong>，使用名称<strong class="mb ir">写</strong>而不是<strong class="mb ir">生产。</strong></p><p id="dd35" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">你不想把你所有的代码都移植到<em class="ma">客户端B </em>，因为你已经听说<em class="ma">客户端A </em>将很快开始支持更新的版本，并且<em class="ma">客户端B </em>总体上比<em class="ma">客户端A </em>使用更多的内存。</p><p id="85f6" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">由于我们的代码应该<strong class="mb ir">对扩展开放，但对修改关闭，</strong>最好的做法是不要接触现有的代码，只需将<em class="ma">客户端A </em>的代码包装在<em class="ma">客户端B </em>的代码中，就可以使用现有的逻辑。</p><p id="a73f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">可能有很多其他类似的场景使用适配器模式，这是一个非常普遍的需要，相互转换类型。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="2e2f" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">履行</h2><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a442" class="ne le iq na b gy nf ng l nh ni">public class ClientBAdapter extends ClientA {<br/>    private final ClientB clientB;</span><span id="048d" class="ne le iq na b gy nj ng l nh ni">    public ClientBAdapter(ClientB clientB) {<br/>        this.clientB = clientB;<br/>    }</span><span id="bac1" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void consume() {<br/>        clientB.read();<br/>    }</span><span id="9651" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void produce() {<br/>        clientB.write();<br/>    }<br/>}</span></pre><p id="9134" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">使用这种方法，ClientB可以很容易地像ClientA一样工作。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8c9e" class="ne le iq na b gy nf ng l nh ni">ClientB clientB = new ClientB();</span><span id="6daf" class="ne le iq na b gy nj ng l nh ni">clientB.write();<br/>clientB.read();</span><span id="072a" class="ne le iq na b gy nj ng l nh ni">ClientA clientBAdapted = new ClientBAdapter(clientB);<br/>// feel free to use a static helper method instead of a constructor</span><span id="89d5" class="ne le iq na b gy nj ng l nh ni">clientBAdapted.consume();<br/>clientBAdapted.produce();</span></pre><p id="69cf" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">我们没有改变任何现有的代码，只是写了一个助手类。<br/>简单快捷的解决方案。:)</p><blockquote class="lv lw lx"><p id="1aea" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">Facade和Adapter都包装多个类，但是Facade的目的是简化，而Adapter的目的是将接口转换成不同的东西。</p></blockquote><p id="e4e1" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">把它当成一个故事来读:<br/> </strong> <a class="ae kv" href="http://emretanriverdi.medium.com/adapter-pattern-a-quick-guide-3fcd2477eda8" rel="noopener">改编模式——快速指南</a> (2分钟读完)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="8c22" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">九面模式</h1><blockquote class="lv lw lx"><p id="0886" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir"> "Facade模式</strong>提供了一个统一的接口，对于子系统中的接口集来说，这个接口更容易使用。"</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/cbb6c166129f25b18ad424db579cd5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucPTuWA0Bta-dZalerOP4A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@yusufevli?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Yusuf Evli </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="303f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:<br/> </strong>假设你要盖一栋房子，要实现这个有很多步骤。你需要建造墙壁和屋顶，购买家具，粉刷墙壁等… <br/>你可能只是想在未来将墙壁粉刷成独立的功能，<br/>但是拥有一个用于建造房子的一体化软件包会很好，因为我们现在需要一个完整的房子。</p><p id="808e" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:<br/> </strong>假设你正在写一个app，你需要进行HTTP请求。<br/>你需要根据自己的需要，用不同的配置变化来调整它。</p><p id="b51b" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">最好是在一个方法中完成所有的配置，并且只从客户端代码中调用该方法，以简化使用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="03b3" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">履行</h2><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="6839" class="ne le iq na b gy nf ng l nh ni">public class HttpClientFacade {<br/>    private final HttpClient httpClient;</span><span id="a18c" class="ne le iq na b gy nj ng l nh ni">    public HttpClientFacade(HttpClient httpClient) {<br/>        this.httpClient = httpClient;<br/>    }</span><span id="88f8" class="ne le iq na b gy nj ng l nh ni">    public JsonObject getRequest(String url, String agentName) {<br/>        httpClient.setConnectTimeout(5000);<br/>        httpClient.expectCompression(true);<br/>        httpClient.setHeader("agentname", agentName);<br/>        //...<br/>        //...<br/>        return httpClient.get(url);<br/>    }<br/>}</span></pre><p id="0118" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">当您需要在GET请求期间添加/删除属性时，您只需要将它实现到这个方法中，这将是一个快速而简单的更改。<br/>代码的其他部分不需要知道<strong class="mb ir"> getRequest的细节。</strong></p><p id="23b4" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="0e06" class="ne le iq na b gy nf ng l nh ni">HttpClient httpClient = new HttpClient();<br/>HttpClientFacade httpClientFacade =<br/>new HttpClientFacade(httpClient);</span><span id="9cee" class="ne le iq na b gy nj ng l nh ni">httpClientFacade.getRequest("emretanriverdi.medium.com", "itsme");</span></pre><blockquote class="lv lw lx"><p id="0a2f" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">Facade和Adapter都包装多个类，但是Facade的目的是简化，而Adapter的目的是将接口转换成不同的东西。</p></blockquote><p id="94d2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">将它作为一个单独的故事来阅读:<br/> </strong> <a class="ae kv" href="http://emretanriverdi.medium.com/facade-pattern-a-quick-guide-b1f2277f9e52" rel="noopener">立面图案—快速指南</a> (2分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="25ca" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">十态模式</h1><blockquote class="lv lw lx"><p id="1d3e" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">状态模式让一个对象在其内部状态改变时改变它的行为。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/868a3c4dd72337e0b12813626e00d62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZ4xRuvEihKFHJ9-wtQuwg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">艺术由<a class="ae kv" href="https://zhart.us/" rel="noopener ugc nofollow" target="_blank">德米特里扎尔特</a></p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="d0fc" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:<br/> </strong>假设你有一部手机，它有三种呼入模式:<br/>静音模式、震动模式和铃声模式。打进来的电话总是一样的，但是你接电话的方式总是不同的。</p><p id="4beb" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:<br/> </strong>假设你有一个网站，里面有主页、简介和联系页面。<br/>暗模式的内部逻辑与&amp;亮模式相同。如果我们能用一个简单的代码块改变可见性，保持它的抽象性，那将是最好的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="fae7" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">履行</h2><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="cd07" class="ne le iq na b gy nf ng l nh ni">public interface PageViewState {<br/>    void view();<br/>}</span><span id="f7bb" class="ne le iq na b gy nj ng l nh ni">public class ViewStateContext {<br/>    private PageViewState currentState;</span><span id="c973" class="ne le iq na b gy nj ng l nh ni">    public ViewStateContext() {<br/>	currentState = new LightModeState();  // default<br/>    }</span><span id="52d3" class="ne le iq na b gy nj ng l nh ni">    public void setState(PageViewState state) {<br/>	currentState = state;<br/>    }</span><span id="3f61" class="ne le iq na b gy nj ng l nh ni">    public void view() {<br/>	currentState.view(this);<br/>    }<br/>}</span><span id="459b" class="ne le iq na b gy nj ng l nh ni">public class LightModeState implements PageState {<br/>    @Override<br/>    public void view(ViewStateContext ctx) {<br/>        // implementation    <br/>    }<br/>}</span><span id="e520" class="ne le iq na b gy nj ng l nh ni">public class DarkModeState implements PageState {<br/>    @Override<br/>    public void view(ViewStateContext ctx) {<br/>        // implementation    <br/>    }<br/>}</span></pre><p id="5852" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="65bb" class="ne le iq na b gy nf ng l nh ni">ViewStateContext stateContext = new ViewStateContext();</span><span id="f41c" class="ne le iq na b gy nj ng l nh ni">stateContext.view();  // shows pages in light mode<br/>stateContext.view();</span><span id="e814" class="ne le iq na b gy nj ng l nh ni">stateContext.setState(new DarkModeState());</span><span id="531d" class="ne le iq na b gy nj ng l nh ni">stateContext.view();  // shows pages in dark mode<br/>stateContext.view();</span></pre><p id="5053" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">瞧啊。</p><p id="11db" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">把它当成一个单独的故事来读:<br/> </strong> <a class="ae kv" href="https://emretanriverdi.medium.com/e4131b43ebe8" rel="noopener">状态模式—快速指南</a> (2分钟读完)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0574" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">11-责任链模式</h1><blockquote class="lv lw lx"><p id="8c46" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir">"责任链</strong> <strong class="mb ir">模式</strong>让您沿着处理程序链传递请求。收到请求后，每个处理程序决定处理请求或将其传递给链中的下一个处理程序<strong class="mb ir">。”</strong></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/70da4cb4b99b688ea6e1a60952bfcbc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kepM5YzK3Qi6NrBRp5kyDw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@kwhatswong?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">王凯骏</a>在<a class="ae kv" href="https://unsplash.com/s/photos/chain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="acea" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">简单的例子:<br/> </strong>假设你想在电脑上玩一个视频游戏，游戏正在试图根据你的GPU选择最优设置。</p><p id="a0f5" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">它检查你的GPU是否能处理Ultra，如果不能；<br/>它检查你的GPU是否能处理高，如果不能；<br/>检查你的GPU是否能处理中等。如果你足够幸运，它就停在那里了。</p><p id="4322" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果你的GPU仍然不够，它会检查你是否可以处理低，<br/>然后超低(如果游戏有这个选项)。</p><p id="06ac" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果你的GPU仍然不够用，这个游戏就不能在你的电脑上运行。</p><p id="5824" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">责任链</strong> <strong class="mb ir">模式</strong>其实就是这么简单。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="c3f2" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">现实生活中的例子:</strong></p><p id="516f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">到目前为止，你一定已经意识到这都是一堆<strong class="mb ir">if</strong>&amp;<strong class="mb ir">else if</strong>语句。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="c74e" class="ne le iq na b gy nf ng l nh ni">public void initialize(VisualEntity visualEntity,<br/>                       FrameRequest frameRequest) {<br/>    <br/>    initializeCommonFields(visualEntity, frameRequest);</span><span id="307e" class="ne le iq na b gy nj ng l nh ni">    if (frameRequest.isCircle()) {<br/>        // initialize circle<br/>    } else if (frameRequest.isSquare()) {<br/>        // initialize square<br/>    } else if (frameRequest.isRectangle()) {<br/>        // initialize rectangle<br/>    } else throw new UnsupportedOperationException("message");<br/>}</span></pre><p id="ff4e" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您有一个这样的代码块，让您的客户为他们的照片选择一个相框。</p><p id="ec7d" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">我相信我们会同意，如果所有这些<strong class="mb ir">块</strong>看起来不太漂亮，如果有一天你想在可用的帧中添加三角形，或者情侣的心形符号，代码块会变得更大。</p><p id="017a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">因此，让我们尝试一种不同的责任链设计！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="5ec4" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">履行</h2><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="42f0" class="ne le iq na b gy nf ng l nh ni">public abstract class InitializerSelector {<br/>    private InitializerSelector successor;</span><span id="195a" class="ne le iq na b gy nj ng l nh ni">    abstract void initialize(VisualEntity visualEntity,<br/>                             FrameRequest frameRequest);</span><span id="99b2" class="ne le iq na b gy nj ng l nh ni">    public InitializerSelector getSuccessor() {<br/>        return successor;<br/>    }</span><span id="7101" class="ne le iq na b gy nj ng l nh ni">    public void setSuccessor(InitializerSelector successor) {<br/>        this.successor = successor;<br/>    }<br/>}</span><span id="6494" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">CircleInitializer</strong> extends InitializerSelector {</span><span id="a959" class="ne le iq na b gy nj ng l nh ni">    public CircleInitializer(SquareInitializer squareInitializer) {<br/>        <strong class="na ir">setSuccessor(squareInitializer);</strong><br/>    }</span><span id="26b1" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void initialize(VisualEntity visualEntity,<br/>                           FrameRequest frameRequest) {<br/>        if (frameRequest.isCircle()) {<br/>            // initialize circle<br/>        } else {<br/>            <strong class="na ir">getSuccessor().initialize(visualEntity, frameRequest);</strong><br/>        }<br/>    }<br/>}</span><span id="5880" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">SquareInitializer</strong> extends InitializerSelector {</span><span id="4fba" class="ne le iq na b gy nj ng l nh ni">    public SquareInitializer(RectangleInitializer<br/>                             rectangleInitializer) {<br/>        <strong class="na ir">setSuccessor(rectangleInitializer);</strong><br/>    }</span><span id="ecb1" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    public void initialize(VisualEntity visualEntity,<br/>                           FrameRequest frameRequest) {<br/>        if (frameRequest.isSquare()) {<br/>            // initialize square<br/>        } else {<br/>            <strong class="na ir">getSuccessor().initialize(visualEntity, frameRequest);</strong><br/>        }<br/>    }<br/>}</span><span id="4518" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">RectangleInitializer</strong> extends InitializerSelector {<br/>    @Override<br/>    public void initialize(VisualEntity visualEntity,<br/>                           FrameRequest frameRequest) {<br/>        if (frameRequest.isRectangle()) {<br/>            // initialize rectangle<br/>        } else {<br/>            <strong class="na ir">throw new UnsupportedOperationException("message");</strong><br/>        }<br/>    }<br/>}</span></pre><p id="3830" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">如果有一天需要添加TriangleInitializer，可以将其作为RectangleInitializer的继承者添加，并将异常移到TriangleInitializer中。</p><p id="3600" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a967" class="ne le iq na b gy nf ng l nh ni">public void initialize(VisualEntity visualEntity,<br/>                       FrameRequest frameRequest) {<br/>    initializeCommonFields(visualEntity, frameRequest);<br/>    <strong class="na ir">circleInitializer</strong>.initialize(visualEntity, frameRequest);<br/>}</span></pre><p id="e8c0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">您可以通过将初始调用从circleInitializer更改为更抽象的形式来完成客户端代码，从而不向客户端代码显示逻辑。您可以通过调用CircleInitializer创建一个新类来启动该流。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4f2f" class="ne le iq na b gy nf ng l nh ni">public void initialize(VisualEntity visualEntity,<br/>                       FrameRequest frameRequest) {<br/>    initializeCommonFields(visualEntity, frameRequest);<br/>    <strong class="na ir">frameInitializer</strong>.initialize(visualEntity, frameRequest);<br/>}</span></pre><blockquote class="lv lw lx"><p id="2184" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated">实现责任链模式有许多其他方法，Spring有自己的内置方法来实现它，甚至更容易，可以根据您的情况(和框架选择)随意使用不同的方法。</p></blockquote><p id="a15f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">把它当成一个单独的故事来读:<br/> </strong> <a class="ae kv" href="https://emretanriverdi.medium.com/chain-of-responsibility-pattern-a-quick-guide-86b04bdbbba8" rel="noopener">责任链模式——快速指南</a> (3分钟阅读)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="055c" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">12-模板方法模式</h1><blockquote class="lv lw lx"><p id="ca4d" class="ly lz ma mb b mc md jr me mf mg ju mh mi mj mk ml mm mn mo mp mq mr ms mt mu ij bi translated"><strong class="mb ir">"模板方法模式</strong>定义了方法中算法的框架，将一些步骤推迟到子类。模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/63d3aa80170dc3c338531b267cb09086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1rVcixndprNMiFXx5zerw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@mildlee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mildlee </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="dbdf" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">示例:</strong></p><p id="01e6" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您有一个应用程序，可以帮助您将应用程序部署到试运行或生产环境中，如下所示:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8273" class="ne le iq na b gy nf ng l nh ni">public class <strong class="na ir">StagingDeploy</strong> {<br/>    <br/>    public void deploy() {<br/>        runUnitTests();<br/>        pushSemanticVersioningTag();<br/>        pushTaggedImage();<br/>        saveImageToRegistryAsBackup();<br/>    }</span><span id="130e" class="ne le iq na b gy nj ng l nh ni">    void runUnitTests() {<br/>        // implementation for unit tests<br/>    }</span><span id="89e3" class="ne le iq na b gy nj ng l nh ni">    void pushSemanticVersioningTag() {<br/>        // implementation for semantic versioning<br/>    }</span><span id="badc" class="ne le iq na b gy nj ng l nh ni">    void pushTaggedImageToStaging() {<br/>       // implementation for pushing tagged image to staging<br/>    }<br/>    <br/>    void saveImageToRegistryAsBackup() {<br/>       // implementation for saving image as backup<br/>    }<br/>}</span><span id="465f" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">ProductionDeploy</strong> {<br/>    <br/>    public void deploy() {<br/>        runSmokeTests();<br/>        pushReleaseTag();<br/>        pushTaggedImage();<br/>        saveImageToRegistryAsBackup();<br/>    }</span><span id="23d7" class="ne le iq na b gy nj ng l nh ni">    void runSmokeTests() {<br/>        // implementation for smoke tests<br/>    }</span><span id="d19d" class="ne le iq na b gy nj ng l nh ni">    void pushReleaseTag() {<br/>        // implementation for release versioning<br/>    }</span><span id="8032" class="ne le iq na b gy nj ng l nh ni">    void pushTaggedImageToProduction() {<br/>        // implementation for pushing tagged image to production<br/>    }</span><span id="c606" class="ne le iq na b gy nj ng l nh ni">    void saveImageToRegistryAsBackup() {<br/>        // implementation for saving image as backup<br/>    }<br/>}</span></pre><p id="4b72" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">试运行和生产部署之间有明显的相似之处，因此您可以创建一个<strong class="mb ir">模板</strong>供两者使用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="6241" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">履行</h2><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="781a" class="ne le iq na b gy nf ng l nh ni">public <strong class="na ir">abstract</strong> <strong class="na ir">class</strong> <strong class="na ir">Deploy</strong> {<br/>    <br/>    public void final deploy() {<br/>        runTests();<br/>        pushTag();<br/>        pushTaggedImage();<br/>        saveImage();<br/>    }</span><span id="bb41" class="ne le iq na b gy nj ng l nh ni">    abstract void runTests();</span><span id="cbd9" class="ne le iq na b gy nj ng l nh ni">    abstract void pushTag();</span><span id="e4e2" class="ne le iq na b gy nj ng l nh ni">    abstract void pushTaggedImage();</span><span id="abb7" class="ne le iq na b gy nj ng l nh ni">    abstract void saveImage();<br/>}</span></pre><p id="0da4" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">现在你可以这样扩展它:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="bb91" class="ne le iq na b gy nf ng l nh ni">public class <strong class="na ir">StagingDeploy extends Deploy </strong>{</span><span id="ba11" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void runTests() {<br/>        // implementation for unit tests<br/>    }</span><span id="1dee" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTag() {<br/>        // implementation for semantic versioning<br/>    }</span><span id="4dd6" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTaggedImage() {<br/>        // implementation for pushing tagged image to staging<br/>    }</span><span id="5d00" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void saveImage() {<br/>        // implementation for saving image as backup<br/>    }<br/>}</span><span id="7928" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">ProductionDeploy extends Deploy</strong> {</span><span id="048b" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void runTests() {<br/>        // implementation for smoke tests<br/>    }</span><span id="dda4" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTag() {<br/>        // implementation for release versioning<br/>    }</span><span id="4d7b" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTaggedImage() {<br/>        // implementation for pushing tagged image to production<br/>    }</span><span id="e738" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void saveImage() {<br/>        // implementation for saving image as backup<br/>    }<br/>}</span></pre><p id="fa7a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">客户端代码应该是这样的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="533f" class="ne le iq na b gy nf ng l nh ni">StagingDeploy stagingDeploy = new StagingDeploy();<br/>stagingDeploy.deploy();</span><span id="006b" class="ne le iq na b gy nj ng l nh ni">ProductionDeploy productionDeploy = new ProductionDeploy();<br/>productionDeploy.deploy();</span></pre><p id="aedf" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">对于这种情况，您可能已经意识到<em class="ma"> saveImage() </em>方法对于两个类是相同的。所以你可以像这样修改代码:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="e8ff" class="ne le iq na b gy nf ng l nh ni">public <strong class="na ir">abstract</strong> <strong class="na ir">class</strong> <strong class="na ir">Deploy</strong> {<br/>    <br/>    public void final deploy() {<br/>        runTests();<br/>        pushTag();<br/>        pushTaggedImage();<br/>        saveImage();<br/>    }</span><span id="b111" class="ne le iq na b gy nj ng l nh ni">    abstract void runTests();</span><span id="c41b" class="ne le iq na b gy nj ng l nh ni">    abstract void pushTag();</span><span id="58e7" class="ne le iq na b gy nj ng l nh ni">    abstract void pushTaggedImage();</span><span id="d874" class="ne le iq na b gy nj ng l nh ni">    void saveImage() {<br/>        // implementation for saving image as backup<br/>    }</span><span id="f5f6" class="ne le iq na b gy nj ng l nh ni">}</span><span id="63d1" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">StagingDeploy extends Deploy </strong>{</span><span id="ab40" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void runTests() {<br/>        // implementation for unit tests<br/>    }</span><span id="b5f7" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTag() {<br/>        // implementation for semantic versioning<br/>    }</span><span id="b752" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTaggedImage() {<br/>        // implementation for pushing tagged image to staging<br/>    }<br/>}</span><span id="9f8c" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">ProductionDeploy extends Deploy</strong> {</span><span id="73c2" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void runTests() {<br/>        // implementation for smoke tests<br/>    }</span><span id="cb6b" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTag() {<br/>        // implementation for release versioning<br/>    }</span><span id="a452" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTaggedImage() {<br/>        // implementation for pushing tagged image to production<br/>    }<br/>}</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="1ba6" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">钩住</h2><p id="5f35" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated">还有一个概念叫钩子。<br/>钩子是抽象类中的方法，可以被覆盖，但不是必须的。</p><p id="568c" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您想要将“性能测试”步骤添加到我们的<strong class="mb ir">模板</strong>中，但是您不希望它在试运行和生产环境中运行。</p><p id="a72e" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated">假设您现在有一个关键应用程序运行的新环境，并且您希望确保部署在此的应用程序运行速度超过2毫秒。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="880c" class="ne le iq na b gy nf ng l nh ni">public <strong class="na ir">abstract</strong> <strong class="na ir">class</strong> <strong class="na ir">Deploy</strong> {<br/>    <br/>    public void final deploy() {<br/>        runPerformanceTests();<br/>        runTests();<br/>        pushTag();<br/>        pushTaggedImage();<br/>        saveImage();<br/>    }</span><span id="5576" class="ne le iq na b gy nj ng l nh ni"><strong class="na ir">    void runPerformanceTests() {<br/>        // empty<br/>    }</strong></span><span id="d0b5" class="ne le iq na b gy nj ng l nh ni">    abstract void runTests();</span><span id="90b5" class="ne le iq na b gy nj ng l nh ni">    abstract void pushTag();</span><span id="5067" class="ne le iq na b gy nj ng l nh ni">    abstract void pushTaggedImage();</span><span id="952b" class="ne le iq na b gy nj ng l nh ni">    void saveImage() {<br/>        // implementation for saving image as backup<br/>    }<br/>}</span><span id="b69e" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">StagingDeploy extends Deploy </strong>{</span><span id="8b17" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void runTests() {<br/>        // implementation for unit tests<br/>    }</span><span id="79c7" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTag() {<br/>        // implementation for semantic versioning<br/>    }</span><span id="1641" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTaggedImage() {<br/>        // implementation for pushing tagged image to staging<br/>    }<br/>}</span><span id="e2f6" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">ProductionDeploy extends Deploy</strong> {</span><span id="7a66" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void runTests() {<br/>        // implementation for smoke tests<br/>    }</span><span id="fbcd" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTag() {<br/>        // implementation for release versioning<br/>    }</span><span id="20dd" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTaggedImage() {<br/>        // implementation for pushing tagged image to production<br/>    }<br/>}</span><span id="cb4f" class="ne le iq na b gy nj ng l nh ni">public class <strong class="na ir">NewProductionDeploy extends Deploy</strong> {</span><span id="3e2e" class="ne le iq na b gy nj ng l nh ni"><strong class="na ir">    @Override</strong><br/>    <strong class="na ir">void runPerformanceTests() {<br/>        // implementation for performance tests<br/>    }</strong></span><span id="70ce" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void runTests() {<br/>        // implementation for both unit &amp; smoke tests<br/>    }</span><span id="a9a3" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTag() {<br/>        // implementation for release versioning<br/>    }</span><span id="ba01" class="ne le iq na b gy nj ng l nh ni">    @Override<br/>    void pushTaggedImage() {<br/>        // implementation for pushing tagged image to new production<br/>    }<br/>}</span></pre><p id="e2bf" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">钩子:</strong>你可以重写方法来添加行为，但不是必须的。<br/> <strong class="mb ir">抽象方法:</strong>你必须重写方法。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="e8e6" class="ne le iq bd lf nq nr dn lj ns nt dp ln mw nu nv lp mx nw nx lr my ny nz lt oa bi translated">需要考虑的事项</h2><p id="a8d1" class="pw-post-body-paragraph ly lz iq mb b mc ob jr me mf oc ju mh mw od mk ml mx oe mo mp my of ms mt mu ij bi translated">虽然模板方法模式很棒并且被广泛使用(有时甚至没有意识到)，但是我们在使用它之前应该三思:</p><p id="7ba0" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 1。总是偏爱合成而不是继承。在使用模板方法模式之前，检查一下策略模式是否更适合。模板方法模式在类级别工作，所以它更静态一些。策略模式在对象级工作，允许您在运行时切换行为。</strong></p><p id="836a" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 2。要知道你可能违反了利斯科夫替代原理。<br/> </strong> LSP基本上是说一个超类的对象应该可以被它的子类的对象替换，而不会破坏应用。虽然这听起来很容易，但是随着应用程序在未来变得越来越大，我们可能会不知不觉地修改模板，使其不适合所有的子类。</p><p id="8214" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir"> 3。请注意，你可能会违反开闭原则。<br/> </strong> OCD基本上是说类应该对扩展开放，但对修改关闭。随着类变得越来越大，维护每个类的模板成为一个问题，而不是类自己适应模板，事情发生了变化，模板开始自己适应类。</p><p id="777f" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">把它当成一个故事来读:<br/> </strong> <a class="ae kv" href="https://emretanriverdi.medium.com/template-method-pattern-a-quick-guide-f734bd9385a5" rel="noopener">模板方法模式——快速指南</a> (4分钟读完)</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><blockquote class="oq"><p id="7925" class="or os iq bd ot ou ov ow ox oy oz mu dk translated">感谢您的阅读！</p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="f037" class="pw-post-body-paragraph ly lz iq mb b mc md jr me mf mg ju mh mw mj mk ml mx mn mo mp my mr ms mt mu ij bi translated"><strong class="mb ir">参考文献</strong></p><ul class=""><li id="455c" class="pa pb iq mb b mc md mf mg mw pc mx pd my pe mu pf pg ph pi bi translated">头先设计模式。埃里克弗里曼，伊丽莎白罗布森，伯特贝茨，凯西塞拉。2004年10月发布。出版商:奥莱利媒体公司。</li><li id="249c" class="pa pb iq mb b mc pj mf pk mw pl mx pm my pn mu pf pg ph pi bi translated">深入设计模式。作者亚历山大·施韦茨(Alexander Shvets)，2019年发布。</li></ul></div></div>    
</body>
</html>