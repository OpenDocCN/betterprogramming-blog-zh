<html>
<head>
<title>How Lazy Evaluation Works in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中惰性求值的工作原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-lazy-evaluation-works-in-ruby-a90237e99ac3?source=collection_archive---------2-----------------------#2021-12-01">https://betterprogramming.pub/how-lazy-evaluation-works-in-ruby-a90237e99ac3?source=collection_archive---------2-----------------------#2021-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8bc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们变得懒惰——只迭代我们真正需要的东西！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7981ba16b50ea33a3a78c590dcbeda01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PXk9v6GZN9IckqVD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@drewcoffman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德鲁·科夫曼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="e994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的日常工作中，作为开发人员，我们经常不得不处理大数据，有时是未知大小的数据。我们解析大文件并导入我们需要的东西，我们从各种网站收集一些数据来搜索某些东西，或者我们只是使用我们自己数据库中的一些大数据来转换它并对它做一些事情。</p><p id="be9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了有效地做到这一点，我们有许多选择。像大多数语言一样，Ruby为我们提供了很多处理这种情况的选项。当处理文件时，我们可以一行一行地读取它们，我们可以借助自己编写的方法和传递数据块，将数据分成更小的块。但是，我们还有另一个不常用的选项:惰性枚举。</p><h1 id="a257" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是懒惰枚举？</h1><p id="9867" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">惰性枚举意味着只有当我们处理结果时才处理表达式。有些语言在默认情况下是懒惰的，比如<a class="ae ky" href="https://en.wikipedia.org/wiki/Haskell_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Haskell </a>，还有许多其他语言正在实现一种懒惰地计算表达式的方法。</p><p id="da6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用惰性枚举，可以创建一个只在需要时才处理的转换管道，如果需要，管道可以作为一个整体一次处理一个项目。一个小的代码示例将说明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行这个代码片段时，您会注意到<code class="fe mu mv mw mx b">map</code>和<code class="fe mu mv mw mx b">take_while</code>块中的put被一个接一个地调用。这意味着在继续数组中的下一项之前，该项从一个块流到下一个块。相反，如果您删除了对<code class="fe mu mv mw mx b">lazy</code>方法的调用，那么在进入管道的下一步之前，这些块会将所有的项打印到终端，因此这些步骤是针对数组中的所有项按顺序处理的。</p><p id="9b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们自己来看看这个:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="251a" class="nc lw it mx b gy nd ne l nf ng">Enumerator::Lazy<br/>item: one<br/>item: eno<br/>item: two<br/>item: owt<br/>item: three<br/>item: eerht<br/>[["eno", "four"], ["owt", "five"], ["eerht", "six"]]</span></pre><p id="a7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，当我们处理大量数据时，如何利用这一点呢？</p><h1 id="f1c9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">懒惰IO读取</h1><p id="4ec2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们打开一个文件并访问这些行时，我们实际上有了一个枚举器。通过调用lazy方法，我们现在可以以一种对内存更敏感的方式访问它们，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对方法<code class="fe mu mv mw mx b">each_line</code>的调用正在生成一个枚举器，现在我们可以将它转换成一个枚举器::Lazy。当您使用函数管道来获得您想要的行时，这尤其有用。这适用于所有具有each_*操作的IO对象，因此当我们从套接字读取时，它以同样的方式工作。</p><p id="aa82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们现在应该默认使用懒惰枚举吗？让我们来看看它们在较少迭代次数下的性能比较:</p><h2 id="29ac" class="nc lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">谎言、更多的谎言和基准</h2><p id="b316" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在许多默认为懒惰的语言中，懒惰的性能损失实际上是不存在的。但是，对于Ruby来说，这有点不同。下面是一个小基准，它懒洋洋地评估一个大数组中的所有项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f4a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我电脑的测试结果:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="14e4" class="nc lw it mx b gy nd ne l nf ng">Warming up --------------------------------------<br/>             lazy:      6.000  i/100ms<br/>            eager:     24.000  i/100ms<br/>Calculating -------------------------------------<br/>             lazy:      75.752  (± 4.0%) i/s -    156.000  in   2.063805s<br/>            eager:     254.646  (± 6.7%) i/s -    528.000  in   2.083519s<br/><br/>Comparison:<br/>            eager: :      254.6 i/s<br/>             lazy: :       75.8 i/s - 3.36x  (± 0.00) slower</span></pre><p id="44dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，懒惰的评估比急切的解决方案慢三倍以上。但是，如果我们只想做几个项目，会发生什么呢？让我们稍微调整一下基准，找出答案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这变化很大！以下是输出:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="cc78" class="nc lw it mx b gy nd ne l nf ng">Warming up --------------------------------------<br/>             lazy:     23.021k i/100ms<br/>            eager:     22.000  i/100ms<br/>Calculating -------------------------------------<br/>             lazy:     206.116k (±26.3%) i/s -    368.336k in   2.095998s<br/>            eager:     229.351  (± 7.4%) i/s -    462.000  in   2.026127s<br/><br/>Comparison:<br/>             lazy: :   206115.6 i/s<br/> <br/>            eager: :      229.4 i/s - 898.69x  (± 0.00) slower</span></pre><p id="58b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，懒惰的评价真的是值得的！lazy版本比eager解决方案快几个数量级，因为当它找到它要寻找的所有项目时就停止迭代，而eager解决方案反转数组中的所有条目，然后取前五个元素。</p><h1 id="908f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基准裁决</h1><p id="b54d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这清楚地表明，当我们处理数据集中的许多甚至大部分项目时，惰性计算是相当慢的。但是，当我们处理数据的子集时，我们可以快得多！当然，这并不总是正确的。如果我们在数据集中搜索一个条目，并在最后一个条目中找到它，我们会慢一些。所以，我们必须注意什么时候使用它。</p><h1 id="c4a3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">警告的话</h1><p id="4bdd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">此外，我们必须知道对于<code class="fe mu mv mw mx b">Enumerator::Lazy</code>模块可用的方法。例如，方法<code class="fe mu mv mw mx b">#reduce</code>和<code class="fe mu mv mw mx b">#each_with_object</code>对Enumerator::Lazy不可用，因为我们不知道这个对象的最终结果是什么类型。如果我们想将这些方法包含到我们的管道中，我们必须在之后再次调用lazy方法。<a class="ae ky" href="https://ruby-doc.org/core-2.7.0/Enumerator/Lazy.html#method-i-take" rel="noopener ugc nofollow" target="_blank">这里的</a>是所有可用方法的文档链接。</p><h1 id="1f69" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="eb8e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当处理大型数据集的子集时，Ruby中的惰性求值是一个很好的特性。但是，如果它真的对您的用例有用，那么每次都必须单独进行评估。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="9a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ns">不是中等会员？</em> <a class="ae ky" href="https://grnt-grdwhl.medium.com/membership" rel="noopener"> <em class="ns">在这里报名</em> </a> <em class="ns">并支持我的写作过程！</em></p></div></div>    
</body>
</html>