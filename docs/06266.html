<html>
<head>
<title>Adopt Diffable Data Sources With Ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松采用不同的数据源</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adopt-diffable-data-sources-with-ease-85fc128ca6bc?source=collection_archive---------7-----------------------#2020-09-15">https://betterprogramming.pub/adopt-diffable-data-sources-with-ease-85fc128ca6bc?source=collection_archive---------7-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d934" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不同的数据源及其优于使用传统数据源方法的优势</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bff4f2c895c2eb0573c4e51126790403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rUdBKArR0Wh2YIr1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@aows?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德里安</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="87dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的数据源在WWDC 2019上推出，自iOS 13以来一直可用。它们取代了传统的<code class="fe lv lw lx ly b">UICollectionViewDataSource</code>和<code class="fe lv lw lx ly b">UITableViewDataSource</code>协议，使数据视图中的变更迁移变得更加容易。</p><p id="6c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与使用传统的数据源方法相比，不同的数据源有一些好处，是当今处理集合和表视图的首选方法。然而，使用旧方法重写大量集成的现有代码可能并不总是容易的。这太糟糕了，因为它夺走了从这个伟大的新API中获益的机会。</p><p id="1280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我决定向您介绍一个不同数据源的简单扩展，它允许您将它集成到现有项目中，而不会有太多麻烦。但是在我们深入研究之前，让我们先来看看有哪些不同的数据源，以及它们会带来什么样的好处。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6941" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是不同的数据源？</h1><p id="2e27" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">可变数据源提供了一种简单、高效的方式来管理对表或集合视图的数据和UI的更新所需的行为。它取代了众所周知的方法，如<code class="fe lv lw lx ly b">cellForRowAtIndexPath:</code>和<code class="fe lv lw lx ly b">numberOfItemsInSection:</code>。</p><p id="dec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集合或表格视图有两个类(<code class="fe lv lw lx ly b">UICollectionViewDiffableDataSource</code>和<code class="fe lv lw lx ly b">UITableViewDiffableDataSource</code>)。构造示例如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d9b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据源是通用的，定义了区段标识符的类型和所列数据的类型。单元格提供程序将把这个泛型作为第三个参数的输出，该参数包含需要返回单元格的数据。</p><p id="22d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据是通过所谓的快照(数据的快照)提供的。这已经描述了不同数据源的工作方式。数据快照会相互比较，以确定从一个快照到另一个快照所需的最小更改量。</p><p id="0ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供数据快照的示例如下:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="0aa9" class="nj mh it ly b gy nk nl l nm nn">var snapshot = NSDiffableDataSourceSnapshot&lt;Int, BlogPost&gt;()<br/>snapshot.appendSections([1, 2])<br/><br/>snapshot.appendItems(mostPopularBlogPosts, toSection: 1)<br/>snapshot.appendItems(recentBlogPosts, toSection: 2)<br/><br/>dataSource.apply(snapshot, animatingDifferences: true)</span></pre><p id="eb7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据源足够智能，可以计算出差异并替换代码，例如<code class="fe lv lw lx ly b">performBatchUpdates</code>。</p><p id="7e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的数据源会产生更紧凑、更集中的代码，同时带来一些好处。最终，系统接管了许多繁重的工作。</p><p id="71c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让你明白这一切都包括什么，最好列出一些好处。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9ca1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用不同数据源的好处</h1><p id="94df" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您实现了没有不同数据源的集合或表视图数据源，您可能会遇到以下错误:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="ff16" class="nj mh it ly b gy nk nl l nm nn">Invalid update: invalid number of items in section 0. The number of items contained in an existing section after the update (1) must be equal to the number of items contained in that section before the update (1), plus or minus the number of items inserted or deleted from that section (1 inserted, 0 deleted) and plus or minus the number of items moved into or out of that section (0 moved in, 0 moved out).</span></pre><p id="8ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们自己管理数据的结果，其中集合视图的更新与本地管理的数据不同步。这通常是使用<code class="fe lv lw lx ly b">performBatchUpdates</code>或者迁移从<code class="fe lv lw lx ly b">NSFetchedResultsControllerDelegate</code>返回的数据的结果。</p><p id="04af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的数据源旨在通过接管计算快照之间的变化的责任来完全消除这种错误。</p><h2 id="e5c7" class="nj mh it bd mi no np dn mm nq nr dp mq li ns nt ms lm nu nv mu lq nw nx mw ny bi translated">NSFetchedResultsController中不同数据源的采用</h2><p id="c1f7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一个不同数据源大放异彩的地方是一个<code class="fe lv lw lx ly b">NSFetchedResultsController</code>的代表。当显示核心数据实体的列表时，我们经常会在实体改变后遇到更新。我们将迭代每个<code class="fe lv lw lx ly b">NSFetchedResultsChangeType</code>,以确保我们使用正确的集合或表视图方法执行所有这些更改。</p><p id="6414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一次更新都是在<code class="fe lv lw lx ly b">performBatchUpdates</code>中执行的，我们祈求最好的结果。</p><p id="ec58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是前述错误可能发生的另一点。为了应用更改，我们还必须编写许多额外的代码。幸运的是，我们现在可以采用一种方法来替换<code class="fe lv lw lx ly b">NSFetchedResultsControllerDelegate</code>中的所有逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="11e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是在核心数据中使用快照应用更改所需的全部代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c778" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一个没有太多麻烦的移植现有代码的扩展</h1><p id="644f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">但是迁移旧代码怎么样呢？我向您承诺了一个简单的扩展，它简化了向不同数据源的迁移。我们在不到一天的时间里就在WeTransfer app 的<a class="ae ky" href="https://collect.bywetransfer.com/" rel="noopener ugc nofollow" target="_blank"> Collect中实现了这一点，并且已经从这个新的API中受益。</a></p><p id="2945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码重用现有的数据源方法来提供单元格配置。仍然需要提供数据的快照，但是这应该相对容易，并且因情况而异。</p><p id="a718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通用代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，代码要求您传入两个参数:</p><ul class=""><li id="2469" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">我们正在更新的收藏视图</li><li id="bb54" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">对原始集合视图数据源的引用</li></ul><p id="f590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在单元格和补充视图提供程序中，我们使用原始数据源来获取视图。这大大简化了现有项目中不同数据源的实现，尤其是如果您可以利用前面提到的<code class="fe lv lw lx ly b">NSFetchedResultsControllerDelegate</code>方法。</p><p id="1696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您能够放弃iOS 12，请务必重新访问您的代码，以清理旧的数据源方法。最后，建议完全远离<code class="fe lv lw lx ly b">UICollectionViewDataSource</code>实现，以使您的代码可读和可理解。同样的代码也适用于<code class="fe lv lw lx ly b">UITableViewDiffableDataSource</code>,只是做了一些简单的代码修改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e643" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">关于uicollectionviewdiffabledata source reference的注释</h1><p id="b486" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我想指出的是，我们在<code class="fe lv lw lx ly b">UICollectionViewDiffableDataSourceReference</code>上使用了一个扩展。这允许我们远离泛型，使我们的代码对任何类型的任何数据源都可用。这不是推荐的方式:</p><blockquote class="on"><p id="d14d" class="oo op it bd oq or os ot ou ov ow lu dk translated">"如果你在Swift代码库中工作，总是用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasource" rel="noopener ugc nofollow" target="_blank">UICollectionViewDiffableDataSource</a></code>代替."— <a class="ae ky" href="https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasourcereference" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="b7b0" class="pw-post-body-paragraph kz la it lb b lc ox ju le lf oy jx lh li oz lk ll lm pa lo lp lq pb ls lt lu im bi translated">然而，代码是可用的，并且运行良好。它是Objective-C对象的快速表示，用于管理数据和为集合视图提供项目，因此不太可能不被维护。如果您在代码中发现了使用泛型的机会，我建议您这样做。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f5ae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="3df5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">不同的数据源是UIKit的一个很好的新增功能，用于处理集合和表视图中的变化。它消除了一个我们都见过几次的恼人的错误，简化了我们构建数据表示的方式。</p><p id="8d50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>