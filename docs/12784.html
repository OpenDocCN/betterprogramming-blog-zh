<html>
<head>
<title>Build a Real-time Chat With Phoenix and LiveView in Less Than 50 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用不到50行代码构建与Phoenix和LiveView的实时聊天</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/real-time-chat-with-phoenix-liveview-in-fewer-than-50-lines-of-code-1b2cf8af7301?source=collection_archive---------5-----------------------#2022-07-01">https://betterprogramming.pub/real-time-chat-with-phoenix-liveview-in-fewer-than-50-lines-of-code-1b2cf8af7301?source=collection_archive---------5-----------------------#2022-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4192" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Phoenix和LiveView如何让客户端之间可扩展的实时通信变得简单</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f8a0efc52542d8750d981f50a426088a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QmIXrw6G5q_bb27t"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@marekpiwnicki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马雷克·皮尼基</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3e32" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你还没有在<a class="ae kz" href="http://phoenixframework.org" rel="noopener ugc nofollow" target="_blank"> Phoenix framework </a>中体验过<a class="ae kz" href="https://github.com/phoenixframework/phoenix_live_view" rel="noopener ugc nofollow" target="_blank"> LiveView </a>的强大功能，请系好安全带:我们将用不到50行代码构建一个实时、高性能的聊天系统。这包括了前端<em class="lw">和后端</em>的所有代码(剧透:它们是一回事)。</p><p id="6924" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们在这个项目中的基本策略是为每个连接到服务器的用户使用一个持久的Phoenix LiveView进程，然后使用Phoenix内置的PubSub(“发布/订阅”)功能向所有连接的进程广播消息。最后，LiveView进程会将消息呈现给每个连接的用户。</p><p id="519f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了让这个例子尽可能的简洁，我们将抄近路，把重点放在核心用例上。我们<em class="lw">不会</em>解决的一些具体问题(但对于那些想了解更多的人来说是简单的补充)是用户认证和管理；聊天消息持久性；以及对具有大厅的多个频道的支持。</p><h1 id="f5e8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">先决条件—什么是凤凰？什么是LiveView？</h1><p id="e149" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">在开始这个项目之前，你需要按照说明安装<a class="ae kz" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">药剂</a>和<a class="ae kz" href="https://hexdocs.pm/phoenix/installation.html" rel="noopener ugc nofollow" target="_blank">凤凰</a>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/31175d4ca8c5e9d04ea308030169b99f.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*hbRwEXT1rr671814fFBxJw.png"/></div></figure><p id="5eb6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">简言之，<a class="ae kz" href="https://hexdocs.pm/phoenix/installation.html" rel="noopener ugc nofollow" target="_blank"> Phoenix </a>是一个用<a class="ae kz" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">神奇灵药语言</a>编写的复杂的web框架。Elixir之所以如此神奇，部分原因是它构建在<a class="ae kz" href="https://www.erlang.org" rel="noopener ugc nofollow" target="_blank"> Erlang虚拟机</a>之上，这意味着它本质上支持高度可用和高度并发的应用程序。</p><p id="b82a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Phoenix web框架利用了这些特性，并为高度交互式的服务器呈现内容启用了LiveView。这意味着你可以构建高度互动的“单页”风格的webapps <em class="lw">而无需编写一行JavaScript </em>。我以前写过关于<a class="ae kz" href="https://blog.devgenius.io/why-your-next-frontend-might-be-the-backend-b43ff1ca9720" rel="noopener ugc nofollow" target="_blank"> LiveView以及为什么我认为它是一个如此神奇的工具</a>。</p><p id="f800" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您以前没有使用过这个堆栈，这是一个绝佳的机会来尝试一下，亲自看看它的威力。我们开始吧！</p><h1 id="8ae8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">步骤1 —项目设置</h1><p id="8483" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">一旦安装了Elixir &amp; Phoenix，我们要做的第一件事就是创建项目。假设您的环境配置正确，您可以生成一个完整的Phoenix项目目录，包含:</p><pre class="kk kl km kn gt mv mw mx my aw mz bi"><span id="4feb" class="na ly it mw b gy nb nc l nd ne">mix phx.new liveview_chat --no-ecto</span></pre><p id="1396" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的<code class="fe nf ng nh mw b">--no-ecto</code>标志意味着我们不想在我们的项目中包含Ecto <code class="fe nf ng nh mw b">datamapper</code>库。为了简单起见，我们在这个例子中这样做，这样我们就不需要担心设置数据库。如果您计划将这个演示项目构建得更大，您可能希望通过省略<code class="fe nf ng nh mw b">--no-ecto</code>标志来包含Ecto功能。</p><p id="faae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">按照<code class="fe nf ng nh mw b">mix</code>中的步骤创建项目并安装依赖项。如果一切顺利，你应该可以用<code class="fe nf ng nh mw b">mix phx.server</code>运行你的凤凰服务器，并通过在浏览器中导航到<code class="fe nf ng nh mw b">http://localhost:4000</code>来查看默认主页。</p><p id="1032" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，我们将通过在<code class="fe nf ng nh mw b">lib/liveview_chat_web/router.ex</code>编辑路由器文件来为我们的新聊天页面创建一个路由(<code class="fe nf ng nh mw b">/chat</code>)。这是用户访问聊天时将导航到的路径。我们还将告诉它哪个模块将呈现我们的LiveView。在这种情况下，该模块将被命名为<code class="fe nf ng nh mw b">LiveviewChatWeb.ChatLive.Index</code>。要设置路线，在如下所示的块中添加<code class="fe nf ng nh mw b">live</code>行:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="d37b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">第二步——实时取景骨架</strong></h1><p id="4eaf" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">接下来，我们将设置我们的实时视图。为了简单起见，我们将从LiveView模块和HTML模板的最小版本开始。然后，在我们的后续步骤中，我们将填充功能。</p><p id="84d7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，让我们为页面创建一个简单的HTML模板。因为我们在这里追求简单，所以我们使用了一些最小的内联样式——在一个真正的应用程序中，我们希望将样式分离出来，或者使用像Tailwind这样的框架。</p><p id="fee8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是我们的基本模板:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="20bb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">HTML应该是不言自明的，并且看起来像您可能编写的任何其他HTML，只有一个例外:我们表单上的属性<code class="fe nf ng nh mw b">phx-submit=”send”</code> <strong class="lc iu"> </strong>。该属性是一个LiveView <em class="lw">绑定，</em>，它表示我们希望在表单提交时向后端模块发送一条消息。</p><p id="adcf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您过去做过web开发，您会注意到表单提交是一个客户端事件，但是LiveView模块是在服务器端进程中运行的。LiveView和Phoenix对我们隐藏了这种复杂性，所以我们不需要编写API或一行JavaScript来实现它。我们将在下一步看到事件是如何被消费的。</p><p id="901e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在转到后端，让我们编写我们的骨架<em class="lw"> </em> LiveView模块，足以让我们的HTML模板呈现:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0183" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们需要在这里编写的唯一方法是<code class="fe nf ng nh mw b">mount</code>——当用户导航到我们的<code class="fe nf ng nh mw b">/chat</code>路线时，它被调用，并且是我们聊天功能的入口点。我们可以传入请求参数和会话信息，但是对于我们当前的例子，我们可以忽略它们。我们还在socket中得到传递，它表示LiveView连接。</p><p id="02f3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦成功，LiveView期望我们返回一个元组<code class="fe nf ng nh mw b">{:ok, socket}</code>(一个成功的函数调用的常见的Elixir模式)。但是在返回套接字之前，我们还要给它赋值。这些<code class="fe nf ng nh mw b">assigns</code>是连接到LiveView的用户的持久应用程序状态。在这种情况下，我们的应用程序需要存储用户名和消息列表。出于演示的目的，我们将使用一个随机的用户名——在一个真实的应用程序中，您可能需要一些实际的用户管理！</p><p id="de15" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您已经成功添加了这些文件，您应该能够导航到<code class="fe nf ng nh mw b"><a class="ae kz" href="http://localhost:4000/chat" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/chat</a></code>并看到基本页面。不过，您还不能发送任何消息，因为我们还没有添加该功能！</p><h1 id="9ebf" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">步骤3-接受聊天消息，并广播</h1><p id="9653" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">接下来，让我们为前端触发的“发送”事件添加一个处理程序。我们将通过一个<code class="fe nf ng nh mw b">handle_event</code>函数来实现:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9dbf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了从前端处理这些<code class="fe nf ng nh mw b">send</code>事件，我们实现了一个带有如下声明的函数:</p><pre class="kk kl km kn gt mv mw mx my aw mz bi"><span id="afbd" class="na ly it mw b gy nb nc l nd ne">def handle_event(“send”, %{“text” =&gt; text}, socket) do <br/>  ... <br/>end</span></pre><p id="d10d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您不熟悉Elixir的模式匹配，这里的第一个和第二个参数不是像在其他语言中那样的简单变量，而是要匹配的模式。这意味着如果第一个参数是“send ”,第二个参数是包含“text”键的字典，那么这个函数将只被调用。如果我们从客户端添加一个新事件，我们可以创建一个完全不同的函数定义来处理这种情况，而不是使用一个带有条件逻辑的<code class="fe nf ng nh mw b">handle_event</code>函数。</p><p id="fed3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们上面的实现中，当我们从客户端收到一个“发送”消息时，我们将通过PubSub发布一个消息。为我们生成的<em class="lw">端点</em>模块默认支持PubSub。我们只需要指定一个<em class="lw">主题、</em>消息、和<em class="lw">有效负载。</em>主题的所有订阅者都将收到消息和有效负载。我们将在下一步中看到如何处理它。</p><p id="ce95" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们这里的有效负载很简单:发送的消息，以及发送消息的人的名字。在真实的应用程序中，我们会有一个更复杂的数据结构，但这是我们演示所需要的。</p><h1 id="63d7" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">步骤4 —订阅和消费消息</h1><p id="9141" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">接下来，添加了我们的聊天消息广播后，我们需要一些东西来消费它们！让我们添加下面的<code class="fe nf ng nh mw b">handle_info</code>函数来完成我们的LiveView模块。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1bb6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这次更新中，我们添加了两件事:首先，在mount函数中，我们添加了一些行来订阅主题。然后，我们添加了一个<code class="fe nf ng nh mw b">handle_info</code>函数来消费我们订阅的消息。</p><p id="a6af" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你会注意到，在我们订阅之前，我们检查了<code class="fe nf ng nh mw b">connected?(socket)</code> <strong class="lc iu"> — </strong>为什么？如果你开始用LiveView构建很多东西，你迟早会注意到<code class="fe nf ng nh mw b">mount</code> <em class="lw"> </em>被调用了两次<em class="lw">，</em>，如果你没有预料到的话，这会导致一些混乱和错误。原因是当查看LiveView页面时，它实际上是一个两步过程:首先，发出HTTP GET请求以获取初始内容，然后，建立Websocket连接以执行任何交互式渲染。任何支持交互或持久连接的代码都应该只在“套接字连接”的情况下执行。参见我在LiveView 上发表的<a class="ae kz" href="https://blog.devgenius.io/why-your-next-frontend-might-be-the-backend-b43ff1ca9720" rel="noopener ugc nofollow" target="_blank">上一篇文章，了解为什么这个两步过程如此重要的更多细节。</a></p><p id="2112" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的另一个变化是<code class="fe nf ng nh mw b">handle_info</code> <strong class="lc iu"> </strong>函数。像我们在上一步中编写的<code class="fe nf ng nh mw b">handle_event</code>函数一样，我们在这里使用模式匹配只处理我们关心的事件。在这种情况下，我们在套接字的赋值语句中更新“message”数组，以添加新消息。</p><p id="8539" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">(补充说明:如果你想知道，<code class="fe nf ng nh mw b">handle_info</code>和<code class="fe nf ng nh mw b">handle_event</code>是LiveView模块的标准回调接口，如果你对细节感兴趣，<a class="ae kz" href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#c:handle_info/2" rel="noopener ugc nofollow" target="_blank">参见文档</a>)。</p><p id="e07b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">剩下唯一要做的就是更新我们的HTML模板来呈现消息。我们将更新【T4消息】如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="ac09" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">第五步——聊天！</h1><p id="5427" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">一切就绪后，您应该能够在浏览器中导航到<code class="fe nf ng nh mw b">http://localhost:4000/chat</code>并查看应用程序的运行情况。在单独的窗口或浏览器中打开页面，发送一些聊天消息，以查看两者(或三者，或四者)之间的交互。</p><h1 id="9493" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">后续步骤</h1><p id="f5d7" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">如果你已经做到了这一步，你就完成了这篇文章中的演示项目！但是，如果你想继续下去，这里有一些简单的东西，你可以添加到这个项目的扩展:</p><ul class=""><li id="170b" class="nk nl it lc b ld le lg lh lj nm ln nn lr no lv np nq nr ns bi translated">通过<code class="fe nf ng nh mw b">chat:channel_name</code>支持多个频道</li><li id="a4ba" class="nk nl it lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated">让用户指定他们的昵称，并添加基本的用户管理</li><li id="c1b2" class="nk nl it lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated">添加消息持久层，以便新用户可以查看聊天历史</li></ul></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><pre class="kk kl km kn gt mv mw mx my aw mz bi"><span id="d566" class="na ly it mw b gy nb nc l nd ne"><em class="lw">Originally posted on </em><a class="ae kz" href="https://blixtdev.com/real-time-chat-with-phoenix-and-liveview/" rel="noopener ugc nofollow" target="_blank"><em class="lw">Blixtdev</em></a><em class="lw">.</em></span><span id="e139" class="na ly it mw b gy of nc l nd ne"><strong class="mw iu">Want to Connect?</strong></span><span id="004d" class="na ly it mw b gy of nc l nd ne"><a class="ae kz" href="http://medium.com/@jonnystartup" rel="noopener"><em class="lw">Jonathan</em></a><em class="lw"> has over 20 years of engineering leadership experience in startups big &amp; small. </em></span><span id="b39c" class="na ly it mw b gy of nc l nd ne">If you’d prefer to keep reading about the awesome things you can do with Elixir instead, I recommend you check out <a class="ae kz" href="https://blog.devgenius.io/why-your-next-frontend-might-be-the-backend-b43ff1ca9720?source=your_stories_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">my breakdown on LiveView and its benefits</a>, or my list of <a class="ae kz" href="https://blog.devgenius.io/5-elixir-libraries-i-install-on-every-new-project-a76fae7241a1" rel="noopener ugc nofollow" target="_blank">5 Elixir Libraries I Install on Every New Project</a>.</span></pre></div></div>    
</body>
</html>