<html>
<head>
<title>The Best Way to Manage Routes in a React Project With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript管理React项目中的路线的最佳方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-best-way-to-manage-routes-in-a-react-project-with-typescript-c4e8d4422d64?source=collection_archive---------3-----------------------#2020-09-28">https://betterprogramming.pub/the-best-way-to-manage-routes-in-a-react-project-with-typescript-c4e8d4422d64?source=collection_archive---------3-----------------------#2020-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f8f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">获得类型的优势，像冠军一样管理您的路线</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7720317bbe89adbfb8015cfd7975bf3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0VwBMzg9s8Ny08VC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔治·巴科斯在拍的照片。</p></figure><p id="22dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的一年中，我有机会使用TypeScript参与了许多React项目——其中一些是从零开始的，而另一些则是处理维护或添加新功能。无论是简单的还是复杂的，它们都涉及某种路由。</p><p id="7a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我有机会在React项目中尝试管理路线的最佳方法。</p><p id="3230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我尝试了很多不同的方法，但是在这篇文章中我将谈论我最喜欢的方法。</p><p id="7118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些项目几乎总是使用<a class="ae ky" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank"> React Router </a>作为路由解决方案，所以我要展示的方法是在上面测试的。但是它也可以在类似的库中工作，比如Reach Router或者甚至是Next.js。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1aa9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用TypeScript键入路线</h1><p id="32c5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对我来说最重要的优势是对路线有智能感知。特别是在项目中，会有很多带参数的路线，跟踪这些路线并不是一种愉快的体验。</p><p id="bb4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，TypeScript帮了大忙。您可以为路由定义类型，并获得智能感知和类型安全的好处。</p><p id="68da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一部分是定义路线。对此，我更喜欢使用枚举。这样，我可以给每条路线起一个可识别的名字，也可以导入到任何地方以便于使用。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="971c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，每条路线都有一个清晰可辨的名称，您可以在任何地方导入<code class="fe nb nc nd ne b">ROUTE</code> enum以方便使用。</p><p id="f1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里会出现一个关于相对路径的问题:如果您需要相对路径呢？</p><p id="f08d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案很简单。只需为每个相对路由组创建不同的枚举:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里。它有一个明确的名称，表明它的用途。您可以根据需要创建许多这样的。没毛病。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2aea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">输入路径参数</h1><p id="f0f2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了使用带参数的路由，您需要一个函数来替换路由定义中的那些参数占位符。但在此之前，您需要考虑如何为这个函数的参数定义类型。这是您开始受益于智能感知和类型安全的地方。</p><p id="1aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以做到这一点，我将向你们展示这两种方法。</p><p id="8b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方法是使用元组。您可以将元组与联合类型结合起来，瞧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="563d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在函数定义中使用spread运算符，将它用作参数类型。稍后你会看到这个。</p><p id="a78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是使用单个参数作为对象，这是我的首选方法。它让一切都变得更加清晰，也有助于智能感知:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6eb7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">createPath函数</h1><p id="bc12" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如我所提到的，您还需要一个部件来使一切变得完整:一个可以使用route enums和params来创建使用路径的函数。</p><p id="ac12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是带有元组参数的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="794c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是将单个参数作为对象的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以创建一个路径，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="333b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并获得TypeScript的好处:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/d6e665a9a69f16ee0cebbc20b47e90d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TW1Xm-fkZSi34ibcjtqcVA.jpeg"/></div></div></figure><p id="4690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我用React Router v6创建了一个CodeSandbox来演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c456" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="63f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript非常棒，您可以在许多地方从中受益。我在多个React项目中使用过这种方法，它让每个人都很开心。</p><p id="5dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意尝试更多，并让我知道你可能有的一些提示！</p></div></div>    
</body>
</html>