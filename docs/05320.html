<html>
<head>
<title>Solidity 0.6.x Features: Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity 0.6.x特性:继承</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-0-6-x-features-inheritance-5d760dc1ad22?source=collection_archive---------12-----------------------#2020-06-29">https://betterprogramming.pub/solidity-0-6-x-features-inheritance-5d760dc1ad22?source=collection_archive---------12-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f969" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Solidity中的继承，以及如何使用它来构建智能契约</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/374fec04e09318d1818f0fd9f03809b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8H51GOpSIc-aW1kcGiA7A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@contrastband?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克雷格·赛伯特</a>在<a class="ae kv" href="/s/photos/twins?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6f17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于Solidity中的面向对象编程——一种面向契约的语言——继承和多态特性被广泛采用，并对语言的发展至关重要。几乎没有任何Solidity开发人员没有在他们的合同中使用这些语言特性来分离逻辑和增加代码重用。在语言的0.6版本中，除了引入接口继承和不允许危险的状态变量隐藏之外，引入的主要改进是使现有规则显式化。编译器继续使用C3线性化——参见<a class="ae kv" href="https://solidity.readthedocs.io/en/latest/contracts.html#inheritance" rel="noopener ugc nofollow" target="_blank">坚实度文档</a>了解继承。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e324" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">显式虚拟和O <code class="fe mr ms mt mu b">verride</code></h1><p id="5fcd" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">默认情况下，函数不再是虚拟的。这意味着对非虚函数的调用将总是执行该函数，而不管继承层次结构中的任何其他契约。这减少了0.5版本中存在的不确定性，在0.5版本中，所有函数都是隐式虚拟的，允许它们在继承结构中被覆盖。这在大型继承图中尤其危险，因为这种模糊性会导致意想不到的行为和错误。</p><p id="7d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在下面的契约<code class="fe mr ms mt mu b">C</code>中，调用<code class="fe mr ms mt mu b">setValue</code>将调用来自契约<code class="fe mr ms mt mu b">B</code>的最派生的实现。然而，从实现来看，这并不明显。</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="4ae4" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.5.17;<br/><strong class="mu ir">contract</strong> A {<br/>    <strong class="mu ir">uint</strong> <strong class="mu ir">public</strong> x;<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">public</strong> {<br/>        x <strong class="mu ir">=</strong> _x;<br/>    }<br/>}<br/><br/><strong class="mu ir">contract</strong> B {<br/>    <strong class="mu ir">uint</strong> <strong class="mu ir">public</strong> y;<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _y) <strong class="mu ir">public</strong> {<br/>        y <strong class="mu ir">=</strong> _y;<br/>    }<br/>}<br/><br/><strong class="mu ir">contract</strong> C <strong class="mu ir">is</strong> A, B {<br/>}</span></pre><p id="59de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于以上示例的0.6版本，编译器会引发一个类型错误:<code class="fe mr ms mt mu b">Derived contract must override function "setValue". Two or more base classes define functions with the same name and parameter types</code>。上面是一个多重继承的例子，同一个函数从多个基类继承而来:<code class="fe mr ms mt mu b">A</code>和<code class="fe mr ms mt mu b">B</code>。在这种情况下，它必须被重写，并且基必须在重写说明符中列出。需要注意的是<code class="fe mr ms mt mu b">override(A,B)</code>中的顺序并不重要——具体来说，它不会改变<code class="fe mr ms mt mu b">super</code>的行为。这仍然由继承图的C3线性化决定，该线性化由<code class="fe mr ms mt mu b">contract C is A, B { ... }</code>声明中的顺序决定。</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="e8f9" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.6.10;<br/><strong class="mu ir">contract</strong> A {<br/>    <strong class="mu ir">uint</strong> <strong class="mu ir">public</strong> x;<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">public</strong> <strong class="mu ir">virtual</strong> {<br/>        x <strong class="mu ir">=</strong> _x;<br/>    }<br/>}<br/><br/><strong class="mu ir">contract</strong> B {<br/>    <strong class="mu ir">uint</strong> <strong class="mu ir">public</strong> y;<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _y) <strong class="mu ir">public</strong> <strong class="mu ir">virtual</strong> {<br/>        y <strong class="mu ir">=</strong> _y;<br/>    }<br/>}<br/><br/><strong class="mu ir">contract</strong> C <strong class="mu ir">is</strong> A, B {<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">public</strong> <strong class="mu ir">override</strong>(A,B) {<br/>        A.setValue(_x);<br/>    }<br/>}</span></pre><p id="af99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，您只能覆盖标记为<code class="fe mr ms mt mu b">virtual</code>的函数。此外，任何覆盖函数必须标记为<code class="fe mr ms mt mu b">override</code>。如果它再次被覆盖，它也必须被标记为<code class="fe mr ms mt mu b">virtual</code>。</p><p id="8a70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数是隐式的，所以当实现一个接口时，你必须在实现中显式地覆盖它的函数。这个设计<a class="ae kv" href="https://github.com/ethereum/solidity/issues/8281" rel="noopener ugc nofollow" target="_blank">正在这里</a>进行讨论。</p><p id="4648" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，关键字<code class="fe mr ms mt mu b">super</code>的作用和以前一样。它调用扁平继承层次结构中更高一级的函数。同样没有变化:<code class="fe mr ms mt mu b">super</code>仍然不允许在<code class="fe mr ms mt mu b">external</code>功能上使用。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="65f2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">接口可以继承</h1><p id="bfb7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">此功能是0.6版的新增功能，允许接口继承。产生的接口是契约必须实现的所有继承接口功能的组合。</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="616f" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.6.10;<br/><strong class="mu ir">interface</strong> X {<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">external</strong>;<br/>}<br/><br/><strong class="mu ir">interface</strong> Y <strong class="mu ir">is</strong> X {<br/>    <strong class="mu ir">function</strong> getValue() <strong class="mu ir">external</strong> <strong class="mu ir">returns</strong> (<strong class="mu ir">uint</strong>);<br/>}<br/><br/><strong class="mu ir">contract</strong> Z <strong class="mu ir">is</strong> Y {<br/>    <strong class="mu ir">uint</strong> x;<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">external</strong> <strong class="mu ir">override</strong> { x <strong class="mu ir">=</strong> _x; }<br/>    <strong class="mu ir">function</strong> getValue() <strong class="mu ir">external</strong> <strong class="mu ir">override</strong> <strong class="mu ir">returns</strong> (<strong class="mu ir">uint</strong>) { <strong class="mu ir">return</strong> x; }<br/>}</span></pre><p id="92ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，如果合同没有实现所有功能，则必须标记为<code class="fe mr ms mt mu b">abstract</code>。</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="3d49" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.6.10;<br/><strong class="mu ir">abstract</strong> <strong class="mu ir">contract</strong> Z <strong class="mu ir">is</strong> Y {<br/>    <strong class="mu ir">uint</strong> x;<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">external</strong> <strong class="mu ir">override</strong> { x <strong class="mu ir">=</strong> _x; }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d278" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">抽象合同</h1><p id="d96b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在0.5版中，没有实现其所有功能的契约被编译器隐式地抽象为:</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="f6cd" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.5.17;<br/><strong class="mu ir">contract</strong> X {<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">public</strong> <strong class="mu ir">virtual</strong>;<br/>}</span></pre><p id="f887" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于0.6，这种区别必须是明确的，编译器会产生错误<code class="fe mr ms mt mu b">contract X should be made abstract</code>。否则:</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="4347" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.6.10;<br/><strong class="mu ir">abstract</strong> <strong class="mu ir">contract</strong> X {<br/>    <strong class="mu ir">function</strong> setValue(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">public</strong> <strong class="mu ir">virtual</strong>;<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="d491" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">公共变量更安全地覆盖外部函数</h1><p id="bc4f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">虽然这个特性在0.6之前就存在了，但是现在增加了检查变量的getter函数(由编译器生成)是否与被覆盖的外部函数的参数和返回类型相匹配的功能，这样就更安全了。在0.5版中，可能允许有所不同，如下例所示:</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="050b" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.5.17;<br/><strong class="mu ir">interface</strong> A<br/>{<br/>    <strong class="mu ir">function</strong> f() <strong class="mu ir">external</strong> <strong class="mu ir">pure</strong> <strong class="mu ir">returns</strong>(<strong class="mu ir">uint8</strong>);<br/>}<br/><br/><strong class="mu ir">contract</strong> B <strong class="mu ir">is</strong> A<br/>{<br/>    <strong class="mu ir">uint256</strong> <strong class="mu ir">public</strong> f <strong class="mu ir">=</strong> 257;<br/>}</span></pre><p id="de62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">契约<code class="fe mr ms mt mu b">A</code>对基础契约<code class="fe mr ms mt mu b">B</code>的调用将返回<code class="fe mr ms mt mu b">1</code>，因为<code class="fe mr ms mt mu b">257</code>的值在转换为<code class="fe mr ms mt mu b">uint8</code>时溢出。</p><p id="e42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了0.6，现在上面生成了<code class="fe mr ms mt mu b">TypeError: Overriding public state variable return types differ</code>，迫使我们解决类型冲突，避免溢出:</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="aa19" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.6.10;<br/><strong class="mu ir">interface</strong> A<br/>{<br/>    <strong class="mu ir">function</strong> f() <strong class="mu ir">external</strong> <strong class="mu ir">pure</strong> <strong class="mu ir">returns</strong>(<strong class="mu ir">uint256</strong>);<br/>}<br/><br/><strong class="mu ir">contract</strong> B <strong class="mu ir">is</strong> A<br/>{<br/>    <strong class="mu ir">uint256</strong> <strong class="mu ir">public</strong> <strong class="mu ir">override</strong> f <strong class="mu ir">=</strong> 257;<br/>}</span></pre><p id="5cd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe mr ms mt mu b">public</code>状态变量只能覆盖<code class="fe mr ms mt mu b">external</code>函数，并且不允许变量覆盖<code class="fe mr ms mt mu b">internal</code>或<code class="fe mr ms mt mu b">public</code>函数。</p><h1 id="261f" class="lz ma iq bd mb mc nj me mf mg nk mi mj jw nl jx ml jz nm ka mn kc nn kd mp mq bi translated">没有状态变量阴影</h1><p id="bcf2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在0.5版中，编译器允许继承同名的可见状态变量，只有一些静态分析工具才会提出这个问题。下面的例子说明了这种设计的问题:</p><pre class="kg kh ki kj gt na mu nb nc aw nd bi"><span id="dbd8" class="ne ma iq mu b gy nf ng l nh ni"><strong class="mu ir">pragma</strong> solidity <strong class="mu ir">^</strong>0.5.17;<br/><strong class="mu ir">contract</strong> A {<br/>    <strong class="mu ir">uint</strong> <strong class="mu ir">public</strong> x;<br/><br/>    <strong class="mu ir">function</strong> setValue1(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">public</strong> { x <strong class="mu ir">=</strong> _x; }<br/>}<br/><br/><strong class="mu ir">contract</strong> B <strong class="mu ir">is</strong> A {<br/>    <strong class="mu ir">uint</strong> <strong class="mu ir">public</strong> x;<br/><br/>    <strong class="mu ir">function</strong> setValue2(<strong class="mu ir">uint</strong> _x) <strong class="mu ir">public</strong> { x <strong class="mu ir">=</strong> _x; }<br/>}</span></pre><p id="9413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个上下文中，引用<code class="fe mr ms mt mu b">x</code>的契约<code class="fe mr ms mt mu b">A</code>中的函数正在使用它自己的状态变量实例- <code class="fe mr ms mt mu b">A.x</code>。对于<code class="fe mr ms mt mu b">B</code>，是<code class="fe mr ms mt mu b">B.x</code>。因此调用<code class="fe mr ms mt mu b">B.setValue2(100)</code>的结果是<code class="fe mr ms mt mu b">B.x</code>将被设置为<code class="fe mr ms mt mu b">100</code>，而调用<code class="fe mr ms mt mu b">B.setValue1(200)</code>将<code class="fe mr ms mt mu b">A.x</code>设置为<code class="fe mr ms mt mu b">200</code>。</p><p id="9cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在0.6版本中，这是被禁止的，并且会引发一个编译器<code class="fe mr ms mt mu b">DeclarationError: Identifier already declared</code>错误。</p></div></div>    
</body>
</html>