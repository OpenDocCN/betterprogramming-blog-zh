<html>
<head>
<title>There and Back Again: Refactoring Object-Oriented to Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一去不复返:重构面向对象的函数式编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/there-and-back-again-refactoring-oo-to-fp-f7f19bd2396d?source=collection_archive---------14-----------------------#2022-06-14">https://betterprogramming.pub/there-and-back-again-refactoring-oo-to-fp-f7f19bd2396d?source=collection_archive---------14-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="006d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们能发现一种新的范式“FOOP”吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/80bf775551a4d8670127fc113b27cfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ppa5SwNhp6wymxn3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@jeneyeo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杨紫琼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1afe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式编程(FP)最近似乎非常流行。虽然我确实认为FP有很多好处，但是我经常很难接受FP优于面向对象(OO)编程的教条式的比较。</p><p id="e70d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与流行的观点相反，我认为OO和FP比看起来更接近。至少，如果OO代码是按照坚实的设计原则编写的，这一点似乎尤其正确。</p><p id="a1e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将探索使用TypeScript从可靠的面向对象(OO)代码到更具功能性的编程(FP)风格的重构。</p><p id="82c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了“如何做”方面，我们将从可测试性的角度来看每一个重构。我发现这是衡量代码质量的一个很好的标准。如果它易于测试，那么很有可能没有一堆奇怪的状态或隐藏的依赖关系。</p><p id="462a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟…我们来重构一下！</p><p id="8723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们将使用一个非常<em class="ls">非常</em>简化的银行账户例子。我们将有一个帐户域对象，我们的用例是开立一个新帐户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="c4bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在这个例子中看到的，这是一个非常典型的代码。我们有一些无状态的服务类，包含我们用例的业务规则，我们依赖数据层来保存我们的帐户信息。这很容易测试，因为我们可以使用内存数据库或mock注入一个假的实现。</p><p id="915b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们对FP的第一次重构中，我们需要把它变成一个函数。就像他们说的，“终结是穷人的目标”。所以让我们把它变成一个功能性的闭包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8cb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始工作了吗？不完全是。在这个迭代中，我们仍然有可能保持私有状态，所以让我们去掉闭包，引入一个高阶函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="a6e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，这太酷了！我们将依赖关系直接传递给函数。我们排除了在闭包中保持状态的能力，它仍然是可测试的。感觉就像一个接口有一个方法和一个内置的构造函数。我喜欢。</p><p id="8892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管如此，仍有工作要做。我们能完全排除依赖性吗？首先，我们可以创建account对象，并将其提取到自己的函数中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="ad55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<code class="fe lv lw lx ly b">createAccount</code>函数现在是纯函数。不依赖于接口，我们可以直接编写saveAccount函数实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="56e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以组合这两个来满足我们的用例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="0d3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等等，这怎么可考！？我们无法将我们的假刀注入到函数中。这里的答案是我们<em class="ls">不</em>单元测试作文。相反，我们对非常简单的纯部分进行单元测试。</p><p id="9813" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试整个组合，我们需要一个集成测试(名副其实)。</p><p id="2c00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，也许我们的目标不是决定使用OO还是FP，而是更多的具有清晰职责和有限耦合的无状态编程。</p><p id="f9a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像生活中的大多数事情一样，它并不是非黑即白的。注意，所有这些重构从一开始就是可行的。每一个都是无状态的，可测试的，责任明确的！这里的主要区别是通过使用依赖性反转或依赖性拒绝的依赖性管理。</p><p id="b4c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想我会得出这样的结论，也许平衡就在中间的某个地方。就我个人而言，我更喜欢高阶函数重构。它似乎拥有两个世界的最佳之处，因为它:</p><ul class=""><li id="5f35" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">避免了类和闭包带来的混乱</li><li id="f3ff" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">不会把事情做得太细，以至于很难跟踪(功能组合)</li></ul><p id="f0f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许我们可以发明一种叫做FOOP的新模式？感谢阅读！</p></div></div>    
</body>
</html>