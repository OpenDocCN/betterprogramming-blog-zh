<html>
<head>
<title>Cache Handling Using Service Workers and the Cache API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用服务工作者和缓存API进行缓存处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cache-handling-using-service-workers-and-the-cache-api-on-the-web-7c00c478d39b?source=collection_archive---------19-----------------------#2020-01-07">https://betterprogramming.pub/cache-handling-using-service-workers-and-the-cache-api-on-the-web-7c00c478d39b?source=collection_archive---------19-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="70ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用服务人员和强大的缓存API在网络上创建快速的类似应用程序的体验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36b135f8ea7356f0976e34a67d6ef02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftyXDhkdOwgGYmAvskdu6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://undraw.co/illustrations" rel="noopener ugc nofollow" target="_blank">展开的插图</a></p></figure><p id="5375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将包括你可以在网络上利用强大的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存API </a>的各种方法。</p><p id="44d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存API允许开发人员轻松控制缓存内存。这个内存不要与浏览器缓存/内存缓存或者HTTP缓存混淆。</p><p id="385c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缓存API允许HTTP <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Request" rel="noopener ugc nofollow" target="_blank">请求</a>缓存，这在几乎所有<em class="lv">网站上都很有用。</em></p><p id="5882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结合<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" rel="noopener ugc nofollow" target="_blank">服务人员</a>解锁的独特功能，可以在任何网站上提供离线功能。无论是静态网站还是服务器端渲染的应用程序。</p><p id="67cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们继续讨论如何利用缓存API和服务工作者在我们的web应用程序中实现缓存。</p><p id="ba60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在普通JavaScript和<a class="ae ky" href="https://developers.google.com/web/tools/workbox" rel="noopener ugc nofollow" target="_blank">工具箱</a>中展示类似的实现。普通的JavaScript会给你更多的清晰度，但是为了避免错误和增加简单性，推荐使用Workbox。</p><p id="5108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:对于以下部分，我考虑到您熟悉<a class="ae ky" href="https://www.w3schools.com/js/js_es6.asp" rel="noopener ugc nofollow" target="_blank"> JavaScript ES6 </a>、<a class="ae ky" href="https://developers.google.com/web/ilt/pwa/introduction-to-service-worker" rel="noopener ugc nofollow" target="_blank">服务人员</a>、<a class="ae ky" href="https://developers.google.com/web/tools/workbox" rel="noopener ugc nofollow" target="_blank">工作箱</a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>。<br/> <a class="ae ky" href="https://developers.google.com/web/fundamentals/primers/service-workers/registration" rel="noopener ugc nofollow" target="_blank">服务人员登记</a>假定已经到位。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2798" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">预缓存</h1><p id="bda3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时候，当用户一进入你的网页，在用户请求之前，你就想预先缓存一些资源。这可能包括后续用户导航所需的资源或附加文件，以确保脱机功能。</p><p id="0102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务工作者可以主动请求资源并将其保存到缓存中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bb3f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">预缓存—普通</h1><p id="a18d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一般来说，在预缓存和缓存过程中，版本控制很重要，它可以防止您在开发时以及您的用户出现常见的混淆。我们需要确保资源的任何旧版本都被网络上的最新版本所替换。</p><p id="2fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您愿意，您可以实现自己的版本控制系统，但是，为了简单起见，我不会在本文中深入讨论。</p><h2 id="146b" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">删除以前的缓存</h2><p id="772d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">相反，我们将清除缓存。在服务工作者的<code class="fe nm nn no np b">activate</code>事件中，如果需要，删除所有以前缓存的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6b5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:在删除之前，请记住<a class="ae ky" href="https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker#removing_outdated_caches" rel="noopener ugc nofollow" target="_blank">缓存是在相同来源</a>的页面/路径之间共享的！</p><h2 id="4755" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">将文件添加到缓存中</h2><p id="c66a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">幸运的是，缓存API使得向缓存添加文件变得非常容易。在<strong class="lb iu"/>service worker<code class="fe nm nn no np b">install</code><strong class="lb iu"/>事件期间，我们只需要打开预缓存的缓存，使用缓存的<code class="fe nm nn no np b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll" rel="noopener ugc nofollow" target="_blank">addAll</a></code>功能添加所有文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子展示了缓存API是多么强大。</p><p id="77ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll" rel="noopener ugc nofollow" target="_blank">addAll</a></code>函数接受一个字符串数组(资源URL ),并为每个资源创建一个<code class="fe nm nn no np b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Request" rel="noopener ugc nofollow" target="_blank">Request</a></code>对象。然后，它在将完成的请求保存到设备内存之前获取资源。很棒吧，哈？</p><p id="f507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码运行之后，用户将下载<code class="fe nm nn no np b">precacheFiles</code>并保存在他们的设备上，甚至不需要首先请求它们。当用户离线时,<code class="fe nm nn no np b">offline.html</code>文件将可用并显示，因此预缓存该文件很重要。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="07b1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">预缓存—工具箱</h1><p id="18fb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果您还没有使用Workbox，希望在这次演示之后，您会对它有所了解。</p><p id="c4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了以最简单的方式使用Workbox进行预缓存，我们只需要在服务工作者JavaScript文件中的任何地方包含以下行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ff63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一些真正的web开发人员来说，使用Workbox库工具<a class="ae ky" href="https://developers.google.com/web/tools/workbox/guides/precache-files#generating_a_precache_manifest" rel="noopener ugc nofollow" target="_blank">生成一个预缓存清单</a>，它将包含所有需要预缓存的文件，包括它们的版本！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="761e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不需要担心版本控制、跟踪修订和更新您的每个文件。Workbox会通过只更新<em class="lv">有新版本的</em>文件来处理所有这些问题。</p><p id="acf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Workbox还负责缓存命名和拦截HTTP请求。好东西！</p><p id="b284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:获取Workbox默认预缓存的缓存名称，然后获取<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存对象</a>:</p><p id="ccf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">const cache = await caches.open(workbox.core.cacheNames.precache)</code></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="db33" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">运行时缓存—普通</h1><p id="12c1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">运行时缓存对于那些“不受你控制”的资源非常有用。</p><p id="7ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，从其中获取资源的第三方脚本，如<a class="ae ky" href="http://fonts.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Fonts </a>将获取<a class="ae ky" href="https://fonts.googleapis.com/css?family=Montserrat&amp;display=swap" rel="noopener ugc nofollow" target="_blank">CSS</a>作为回报，CSS将获取字体的最新版本的WOFF 2/TTF文件。</p><p id="5553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，重要的是要理解为什么服务工作者对于这项任务来说是方便的，为什么它是如此强大。主要原因是这样的:</p><p id="1426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务工作者充当应用程序与网络和缓存之间的“代理”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.wisdomgeek.com/development/web-development/service-worker-progressive-web-applications/"><div class="gh gi ns"><img src="../Images/1226e5a83c88fc7735372db3ecadeebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_0ap80mvgToNSPAm.jpeg"/></div></a><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务工作器充当应用程序与网络和缓存之间的代理</p></figure><p id="d50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于服务工作者拦截客户端HTTP请求的强大能力，<strong class="lb iu"> </strong>它赋予我们添加以下示例功能的超级能力:</p><p id="502b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果资源不存在于缓存中:</p><ul class=""><li id="6ca8" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">从网络上索取。</li><li id="93a2" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">并将其添加到缓存中以备后用。</li></ul><p id="596c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果资源存在于缓存中:</p><ul class=""><li id="f3a9" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">用缓存的资源响应。</li></ul><h2 id="9608" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">从网络获取并将响应保存到缓存</h2><p id="6389" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于普通JS中的运行时缓存，我们将在服务工作线程中使用缓存API和<code class="fe nm nn no np b">fetch</code>事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="948e" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">从缓存响应，否则从网络获取</h2><p id="f312" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">然后，我们将检查缓存中请求的资源，并使用该资源进行响应，从而提高性能！</p><p id="f12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加其余的逻辑来相应地响应客户端的请求，最终的代码将类似于下面这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="09eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe nm nn no np b">Response</code>对象的克隆！<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Response/clone" rel="noopener ugc nofollow" target="_blank">响应应该只使用一次</a>因此，因为我们将它放入缓存并返回给用户，所以我们需要首先克隆它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6d19" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">运行时缓存—工具箱</h1><p id="2ae7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了更进一步，我们需要确保你对<a class="ae ky" href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies" rel="noopener ugc nofollow" target="_blank"> Workbox的策略</a>感到舒适，并且知道何时使用每一个策略。</p><p id="8d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还不舒服，我建议先花三分钟浏览一下我的关于工具箱策略的文章。</p><h2 id="3ff1" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">使用工具箱策略</h2><p id="8f72" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">策略应用于指定的HTTP路由。为此，Workbox通过<code class="fe nm nn no np b">registerRoute</code>函数提供了一个高级接口。</p><p id="07de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能通过基于路线的URL配置特定策略，允许<a class="ae ky" href="https://developers.google.com/web/tools/workbox/guides/route-requests" rel="noopener ugc nofollow" target="_blank">路线处理</a>。</p><ul class=""><li id="eb78" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies#stale-while-revalidate" rel="noopener ugc nofollow" target="_blank">重新验证时过时</a>示例:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的单行代码包含在服务工作者JavaScript文件中。</p><p id="158e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们声明，对于以这些扩展<code class="fe nm nn no np b">js</code>、<code class="fe nm nn no np b">css</code>、<code class="fe nm nn no np b">webp</code>、<code class="fe nm nn no np b">png</code>或<code class="fe nm nn no np b">svg</code>结尾的每个请求，它应该由<code class="fe nm nn no np b"><a class="ae ky" href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies#stale-while-revalidate" rel="noopener ugc nofollow" target="_blank">StaleWhileRevalidate</a></code>策略处理。</p><p id="73e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当没有指定策略时，应用默认策略，即<code class="fe nm nn no np b">CacheFirst</code>。</p><ul class=""><li id="c91d" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies#network_first_network_falling_back_to_cache" rel="noopener ugc nofollow" target="_blank">网络第一</a>举例:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b559" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的路由注册对于服务器端呈现的应用程序来说很方便，在这种应用程序中，显示网站和数据库的最新版本很重要，但仍然希望在脱机时至少向用户显示一些内容。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7093" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">默认脱机页面</h1><p id="a0af" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">说到线下…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b0c2daf9225f453aa6fc3f897a4c261c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*xWdXt2qr4Z1pfeYCx6ZcVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不要在网上喂鸭嘴龙！🦖</p></figure><p id="a8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不言而喻，一个真正的PWA绝不会向用户展示“downasaur”！</p><p id="cdf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务人员允许我们在网上安全行事，确保我们的用户总是能看到一些东西，即使是在不存在的路线上或离线时。</p><h2 id="87dc" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">我们分三步完成</h2><ol class=""><li id="4d48" class="nt nu it lb b lc mv lf mw li oi lm oj lq ok lu ol nz oa ob bi translated">在服务人员的<code class="fe nm nn no np b">fetch</code>事件中监听<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/mode" rel="noopener ugc nofollow" target="_blank">导航类型请求</a>。</li><li id="3b63" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ol nz oa ob bi translated">从缓存或网络获取资源。</li><li id="b361" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ol nz oa ob bi translated">检查任何网络问题(例如:404 HTTP状态)<em class="lv">。</em></li><li id="d72c" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ol nz oa ob bi translated">如果在任一位置都没有找到资源，则使用缓存的脱机页面进行响应。</li></ol><p id="660c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但首先，我们需要打下基础！</p><p id="8f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在服务人员的<code class="fe nm nn no np b">install</code>事件期间预缓存离线页面可以确保离线页面在设备的缓存中，这样我们就可以安全地返回到它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f53d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Workbox，您应该<a class="ae ky" href="https://developers.google.com/web/tools/workbox/guides/precache-files#generating_a_precache_manifest" rel="noopener ugc nofollow" target="_blank">在构建时生成一个包含<code class="fe nm nn no np b">offline.html</code>文件的预缓存清单</a>。</p><p id="40af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当请求是<code class="fe nm nn no np b">navigation</code>模式时，我们可以处理<code class="fe nm nn no np b">fetch</code>事件内部的网络错误，并根据情况用适当的资源进行响应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="186d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，继续创建一个有趣而聪明的离线页面，让你的用户兴奋得不想离开！</p><p id="f426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要灵感？<a class="ae ky" href="https://thegoodmobileui.com/#/search/offline" rel="noopener ugc nofollow" target="_blank">离线页面示例</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/4c351786c0622a4385c935dde12cf080.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*EuRCL2C6NU-U5B4Oz7pVXw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例<a class="ae ky" href="https://www.pwa.recipes/offline.html" rel="noopener ugc nofollow" target="_blank">离线页面</a>用于列出所有离线可用页面</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ea4a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">进一步阅读</h1><ul class=""><li id="f954" class="nt nu it lb b lc mv lf mw li oi lm oj lq ok lu ny nz oa ob bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存API文档</a> — MDN文档。</li><li id="16bf" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/cache-api" rel="noopener ugc nofollow" target="_blank">使用缓存API </a> —谷歌开发者。</li><li id="80ea" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><a class="ae ky" href="https://developers.google.com/web/tools/workbox/guides/precache-files#generating_a_precache_manifest" rel="noopener ugc nofollow" target="_blank">生成预缓存清单</a> —谷歌开发者。</li><li id="a0ce" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><a class="ae ky" href="https://medium.com/@charistheodoulou/5136edea7de1?source=friends_link&amp;sk=1001086f7c6f2cf2bcdc5bff1257bc51" rel="noopener">在PWA中标记并列出离线可用页面</a> — Medium。</li><li id="e48b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><a class="ae ky" href="https://medium.com/@charistheodoulou/ebb32f8cbe4d?source=friends_link&amp;sk=606fc308bec8dcd553111f5a79c5e859" rel="noopener">基于示例和用例的工具箱策略</a> —中等。</li><li id="3598" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">PWA维基。</li></ul></div></div>    
</body>
</html>