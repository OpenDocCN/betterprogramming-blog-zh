<html>
<head>
<title>JavaScript Is A Great Language — If You Use TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript是一种很棒的语言——如果你使用TypeScript的话</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/its-time-we-admit-the-truth-about-javascript-98d197c0f1ec?source=collection_archive---------2-----------------------#2021-05-11">https://betterprogramming.pub/its-time-we-admit-the-truth-about-javascript-98d197c0f1ec?source=collection_archive---------2-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a732" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是时候我们承认JavaScript的真相了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe40048125493108663eadb205bb9b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LZZ0wFHUSXkou8lz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="25d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript受到很多人的讨厌。汤姆·布拉迪也是。</p><blockquote class="lv"><p id="6fad" class="lw lx it bd ly lz ma mb mc md me lu dk translated">"世界上只有两种语言:人们抱怨的语言和没人使用的语言。"——比雅尼·斯特劳斯特鲁普，C++的创造者</p></blockquote><p id="d121" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">如果你不喜欢JavaScript，可能有三个原因:</p><ul class=""><li id="0154" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">你没有真正尝试过。毫无疑问，你会听到目空一切的程序员告诉你，JavaScript之所以不好，是因为<code class="fe mt mu mv mw b">"5"</code>松散地等于<code class="fe mt mu mv mw b">5</code>(优秀的JavaScript开发人员几乎从不使用松散的等式)，或者是因为与性能相关的原因(<a class="ae ky" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/javascript.html" rel="noopener ugc nofollow" target="_blank"> Node.js只是比Java </a>慢一点)。</li><li id="342c" class="mk ml it lb b lc mx lf my li mz lm na lq nb lu mp mq mr ms bi translated">很难写出高质量的代码。也许你已经尝试过了，但是发现它缺乏结构鼓励了糟糕的代码实践。如果这是你的原因，请继续阅读，了解更多关于编写可读和可伸缩的JavaScript代码的知识。</li><li id="47e3" class="mk ml it lb b lc mx lf my li mz lm na lq nb lu mp mq mr ms bi translated">它没有类型系统。一直读到最后，因为使用JavaScript的一个最有说服力的理由是使用TypeScript。</li></ul><p id="3c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你已经知道了你的立场，这里有三个你应该在下一个项目中使用Node.js的理由。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="9bb0" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">1.JavaScript非常适合函数式编程</h1><p id="6477" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">谁不爱函数式编程？</p><p id="5ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript令人难以置信的灵活性可不是闹着玩的——你可以只用纯函数编写一个无状态的应用程序。</p><p id="c5a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中函数式编程如此自然的一个原因是函数是一级变量，就像字符串或数字一样。</p><p id="5350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="9c51" class="ok nk it mw b gy ol om l on oo">const addThree = (x) =&gt; x + 3;<br/>console.log(addThree(4)); // prints 7</span></pre><p id="01e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将这个函数传递给<code class="fe mt mu mv mw b">Array.map()</code>，它将数组的值从函数的输入映射到它的输出:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="102a" class="ok nk it mw b gy ol om l on oo">const arr = [3, 4, 5];<br/>const mappedArr = arr.map(addThree);<br/>console.log(mappedArr); // =&gt; [6, 7, 8]</span></pre><p id="dbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以编写一个返回另一个函数的函数:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="b1ba" class="ok nk it mw b gy ol om l on oo">const mapByAdding = (x) =&gt; (n) =&gt; n + x;</span></pre><p id="1b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以通过向每个元素添加任意数字来映射数组:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="0954" class="ok nk it mw b gy ol om l on oo">const arr = [3, 4, 5];<br/>const addFourToAll = arr.map(mapByAdding(4));<br/>console.log(addFourToAll); // =&gt; [7, 8, 9]</span></pre><p id="6146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回其他函数的函数，称为<em class="op">高阶函数</em>，帮助我们设计健壮的抽象，同时保持函数风格。</p><p id="0fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript数组也有一个<code class="fe mt mu mv mw b">filter</code>方法，该方法采用谓词函数并返回一个数组，该数组只包含满足谓词的元素:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="f55d" class="ok nk it mw b gy ol om l on oo">const arr = [3, 4, 5];<br/>const oddNumbers = arr.filter((n) =&gt; n % 0 === 1);<br/>console.log(oddNumbers); // =&gt; [3, 5]</span></pre><p id="4fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这没什么值得大书特书的。但是看看组合谓词有多容易:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="752b" class="ok nk it mw b gy ol om l on oo">const andPredicate = (pred1, pred2) =&gt; {<br/>  return (el) =&gt; pred1(el) &amp;&amp; pred2(el); <br/>}</span></pre><p id="4fa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数接受两个谓词，如果元素满足这两个谓词，则返回另一个返回<code class="fe mt mu mv mw b">true</code>的谓词。</p><p id="7b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以根据需要将函数嵌套在其他函数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="90c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些特性——以及更多特性——使得用漂亮、实用的JavaScript代码编写复杂模块变得容易。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="b07b" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">2.JS非常适合异步编程</h1><p id="6d90" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">不管是哪种语言，异步编程通常都很困难，但是JavaScript的承诺和<code class="fe mt mu mv mw b">async</code> / <code class="fe mt mu mv mw b">await</code>方法可能是最直观的。</p><p id="cb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺表示一些涉及其他异步操作的操作。</p><p id="bc11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mt mu mv mw b">await</code>关键字来等待一个承诺的完成:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="9891" class="ok nk it mw b gy ol om l on oo">const response = await someApiCall();</span></pre><p id="8309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只能在异步函数中使用<code class="fe mt mu mv mw b">await</code>，因为等待承诺完成的函数本身必须返回一个承诺。我们用<code class="fe mt mu mv mw b">async</code>来表示这一点:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="2d1a" class="ok nk it mw b gy ol om l on oo">async function getDataFromApi() {<br/>  const response = await someApiCall();<br/>  return response.data.sort();<br/>}</span></pre><p id="957a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe mt mu mv mw b">Promise</code>构造函数获得相同的结果，它采用一个执行一些异步操作的函数，然后进行解析或拒绝。如果我们<code class="fe mt mu mv mw b">resolve()</code>，承诺实现，返回一个可选的结果值，我们可以传递给<code class="fe mt mu mv mw b">resolve</code>。如果我们<code class="fe mt mu mv mw b">reject()</code>，指示错误，诺言必须被抓住。</p><p id="0068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是前面使用<code class="fe mt mu mv mw b">Promise</code>构造函数的代码片段的等效代码:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="dc10" class="ok nk it mw b gy ol om l on oo">const getDataFromApi = new Promise(async (resolve, reject) =&gt; {<br/>  const response = await someApiCall();<br/>  resolve(response.data.sort());<br/>});</span></pre><p id="d4a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们传递给Promise的函数是<code class="fe mt mu mv mw b">async</code>，它允许我们在它的主体内部使用<code class="fe mt mu mv mw b">await</code>。</p><p id="a1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想对一个数组中的所有值执行一些异步任务呢？</p><p id="d3d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个用户数组<code class="fe mt mu mv mw b">ids</code>,想要从某个服务器获取相应的数据库条目。然而，它的API只允许我们一次检索一个用户。</p><h2 id="2355" class="ok nk it bd nl os ot dn np ou ov dp nt li ow ox nv lm oy oz nx lq pa pb nz pc bi translated">糟糕的解决方案</h2><p id="c5e1" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">我们可以在<code class="fe mt mu mv mw b">async</code>函数中使用<code class="fe mt mu mv mw b">for-each</code>循环:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这样不好？由于<code class="fe mt mu mv mw b">for</code>循环和<code class="fe mt mu mv mw b">await</code>是同步的，API调用将顺序完成，而不是并行完成。这意味着我们的加载时间随着id数量的增加而线性增加——这可不好！</p><h2 id="35ed" class="ok nk it bd nl os ot dn np ou ov dp nt li ow ox nv lm oy oz nx lq pa pb nz pc bi translated">更好的解决方案</h2><p id="a847" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">相反，我们应该使用<code class="fe mt mu mv mw b">Promise.all</code>来并行调用一组承诺，清理我们的代码并大大提高效率。</p><p id="a183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将数组<code class="fe mt mu mv mw b">userIds</code>映射到将返回相应用户的承诺:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="e1a6" class="ok nk it mw b gy ol om l on oo">const getUserPromises = userIds.map(id =&gt; {<br/>  return asyncGetUserById(id); // returns a Promise, NOT the result<br/>});</span></pre><p id="91c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们简单地将这个数组传递给<code class="fe mt mu mv mw b">Promise.all()</code>，它并行调用承诺，并按照给定承诺的顺序返回API结果的数组:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="3d4f" class="ok nk it mw b gy ol om l on oo">const users = await Promise.all(getUserPromises);</span></pre><p id="af08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Promises和<code class="fe mt mu mv mw b">async</code> / <code class="fe mt mu mv mw b">await</code>极大地简化了JavaScript中的异步编程，使之成为调度大量网络请求的应用程序的特别谨慎的选择。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="6a0d" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">然而，JavaScript有点糟糕</h1><p id="c8f6" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">尽管JavaScript有优势，但缺乏类型系统让许多潜在用户望而却步——这是有充分理由的。开发一个没有类型的大型应用程序就像用Vim编码一样。你只是要求做更多的工作。</p><p id="e093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢天谢地，有一个解决方案:TypeScript(也就是过去十年中web开发领域发生的最好的事情之一)。</p><p id="bf39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript是由C#背后的许多相同的微软工程师开发的，是一个健壮的、高度灵活的JavaScript类型系统。</p><p id="4f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地键入变量:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="71e3" class="ok nk it mw b gy ol om l on oo">const val: string = "5";</span></pre><p id="bfe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:这是一个虚构的例子。TypeScript会简单地推断字符串文字的类型。</p><p id="40f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以定义像变量这样的类型。下面是一个<code class="fe mt mu mv mw b">Predicate</code>函数的类型定义:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="fe0f" class="ok nk it mw b gy ol om l on oo">type Predicate = (val: any) =&gt; boolean;</span></pre><p id="e82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像许多其他强类型语言一样，TypeScript支持泛型:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="9ce0" class="ok nk it mw b gy ol om l on oo">type Predicate&lt;T&gt; = (val: T) =&gt; boolean;</span></pre><p id="76ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了熟悉的<code class="fe mt mu mv mw b">enum</code>构造，TypeScript还允许我们定义联合类型:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="3a9c" class="ok nk it mw b gy ol om l on oo">type ApiResponseStatus = "ok" | "error";</span></pre><p id="4cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经拥有了为API响应定义简单类型所需的一切:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="244e" class="ok nk it mw b gy ol om l on oo">type ApiResponse&lt;T&gt; = {<br/>  status: "ok" | "error";<br/>  data: T;<br/>  error: string;<br/>}</span></pre><p id="ed0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以更进一步。如果API响应的状态为<code class="fe mt mu mv mw b">ok</code>，我们知道它一定有数据，不能有错误。否则，它一定有错误，不能有数据。</p><p id="378e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一个巧妙的联合式来表达这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="184a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们处理一个<code class="fe mt mu mv mw b">ApiResponse</code>时，我们的IDE将根据<code class="fe mt mu mv mw b">status</code>准确地知道哪些字段是可用的。</p><p id="611d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这段代码将编译为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="5fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这不会:</p><pre class="kj kk kl km gt og mw oh oi aw oj bi"><span id="0adc" class="ok nk it mw b gy ol om l on oo">if (apiResponse.status === "error") {<br/>  return apiResponse.data;<br/>}</span></pre><p id="b3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这仅仅触及了赋予TypeScript独特能力和多功能性的大量特性的表面。这也不是一项新技术——大多数流行的npm包已经支持TypeScript，越来越多的小型库也在效仿。</p><p id="f2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，毫不奇怪，TypeScript是堆栈溢出用户第二喜欢的编程语言，仅次于Rust:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/28d62bd23e8ccc0e5d6af069741d7b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vO30pquNWni7hWQXDqm32g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://insights.stackoverflow.com/survey/2020" rel="noopener ugc nofollow" target="_blank">栈溢出开发者调查</a></p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="e4a3" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">一种又爱又恨的语言</h1><p id="d26d" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">C++的创造者比雅尼·斯特劳斯特鲁普曾经说过:“世界上只有两种语言:人们抱怨的语言和没人使用的语言。”</p><p id="a2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，JavaScript是世界上使用最多的编程语言——这不仅仅是因为web开发人员几乎没有选择。在过去的十年中，JS在整个堆栈中的使用激增。</p><p id="2e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管普遍对这种语言不屑一顾，但拥有多年JavaScript应用程序开发经验的开发人员都知道，它在大多数领域都很出色:它功能多样、灵活，而且使用Node.js很快。</p><p id="c361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着TypeScript的广泛采用，JavaScript的最后一个最大的缺陷得到了解决，Node.js成为2021年最通用、对开发人员友好的软件开发工具。</p></div></div>    
</body>
</html>