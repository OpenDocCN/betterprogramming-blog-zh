<html>
<head>
<title>Mastering Software Engineering in iOS: Open-Closed Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握iOS中的软件工程:开闭原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-software-engineering-in-ios-open-close-principle-5f28d2f09f8c?source=collection_archive---------13-----------------------#2019-10-07">https://betterprogramming.pub/mastering-software-engineering-in-ios-open-close-principle-5f28d2f09f8c?source=collection_archive---------13-----------------------#2019-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ef3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">OCP:软件开发基础简单易懂</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ce29dd56ba8ec2c80dcd9d4f9cf49d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x74pqqCPcinkLfig"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Dmitry Chernyshov 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="cd8e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">固体</h1><p id="c311" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://medium.com/@adrianzyga/from-hobbyist-to-professional-ios-developer-solid-part-1-5a256e1d3b43" rel="noopener">在上一篇文章</a>中，我已经讲述了什么是坚实的原则，并解释了第一条。所以现在我们要继续第二个固体原理，叫做开/闭原理。但在此之前，让我提醒您我将如何在整个系列中展示这些示例，以使一切变得清晰明了:</p><ul class=""><li id="025c" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">我给个简单的定义</li><li id="c98e" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">我将给出一个糟糕代码的例子，它在某种程度上违背了我们讨论的原则</li><li id="35f6" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">我将解释为什么这个原则在给定的例子中被打破了</li><li id="163f" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">我将重构代码，因此该示例符合所讨论的原则</li><li id="ad7b" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">我将解释为什么现在它符合它</li></ul><p id="45b9" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我将向你们展示的每个例子都将在Swift Playground中发挥作用。</p><h1 id="93e2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">开闭原理</h1><blockquote class="nd ne nf"><p id="6ba6" class="lo lp ng lq b lr mm jr lt lu mn ju lw nh na lz ma ni nb md me nj nc mh mi mj ij bi translated">“软件实体(类、模块、函数等)。)应该对扩展开放，但对修改关闭”<br/>——伯特兰·迈耶</p></blockquote><p id="c345" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这到底是什么意思？</p><p id="ed37" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">简而言之:一旦我们编写了一段提供功能的代码，我们就不应该去修改它，即使需要修改功能。我们应该能够编写一个新的代码来替代旧的功能。</p><p id="c29b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">你要记住，你的最终作品要符合这个原则！这条规则并不阻止重构糟糕的代码或者在需要的时候进行修改！</p><p id="84d9" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">许多初级开发人员曲解了它，并避免重构(经常进行不必要的继承和重写方法，这样他们就可以添加新的代码，而不是替换坏的代码)。</p><p id="955e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">当你在应用上工作时，尤其是当你在开发过程中，大多数时候你需要修改已经写好的东西来完成工作。在你实现了所有你想要的功能后，你的代码应该遵循开闭原则。</p><p id="219c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/49de2eae3785cf5ee4de8a96f2789a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPR2tWgMxkjfrU6Vs1fcvA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自:<a class="ae kv" href="https://www.minecraft.net/" rel="noopener ugc nofollow" target="_blank">https://www.minecraft.net/</a></p></figure><p id="6eb2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">你可以为<em class="ng">《我的世界》</em>安装改变其功能的插件(mod ),而无需改变<em class="ng">《我的世界》</em>客户端本身的代码。这是一个模块级的OCP的美丽例子。</p><p id="071b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">游戏本身对扩展(插件)是开放的，对修改是封闭的(你不需要重新编译整个客户端，改变游戏本身的代码来做这些改变)。</p><p id="ef64" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">但这并不意味着曾经在《我的世界》代码库中的东西将永远留在那里。《我的世界》的开发者仍然在改变客户端本身，发布新版本，改变旧代码(进行修改)。一旦他们做了所有的修改，他们发布了一个新版本的游戏，仍然符合OCP T21。你仍然可以使用和创建插件。</p><p id="122d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这一原则可以应用于3个最常见的级别:<code class="fe nl nm nn no b">func</code>、<code class="fe nl nm nn no b">class</code>和模块。《我的世界》的例子展示了模块层次(整个游戏本身是一个模块，模块是其他与之交互的模块)。我将用代码展示<code class="fe nl nm nn no b">func</code>和<code class="fe nl nm nn no b">class</code>的例子。</p><h1 id="1c08" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">开始之前</h1><p id="eff2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Swift Playground可以让你看到单个<code class="fe nl nm nn no b">UIView</code>和<code class="fe nl nm nn no b">UIViewController</code>，而不用创建整个iOS应用。</p><p id="2018" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我们将在我们的例子中使用它。创建一个“空白”或单一视图的游乐场，复制代码，确保您已经启用了“实时视图”(橙色箭头)，并按下播放按钮(绿色箭头)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/3f48f2c36b85f985a797f81d54eeca72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KmBZnOW1skaHwApgc6rJw.png"/></div></div></figure><p id="a8b8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">当您复制第一个示例时，应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/c41d233cd7fd810b5d0183e5ecb2ddcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9e7EfHK3HuEJoxstLa15lw.png"/></div></div></figure><h2 id="537d" class="nq kx iq bd ky nr ns dn lc nt nu dp lg lx nv nw li mb nx ny lk mf nz oa lm ob bi translated">示例:<code class="fe nl nm nn no b">UIView</code>的样式</h2><p id="c45e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所以我们最后来看看这个<code class="fe nl nm nn no b">UIViewController</code>和关联的<code class="fe nl nm nn no b">UIView</code>。如你所见，它可以配置两个主题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="fd50" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">现在尝试添加另一个主题…</p><p id="b7d6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">类<code class="fe nl nm nn no b">BadView</code>打破了<em class="ng">打开/关闭原则</em>，因为不修改<code class="fe nl nm nn no b">setup(theme:)</code>方法就不能添加另一个颜色主题。您还需要通过添加另一个案例来修改<code class="fe nl nm nn no b">AppTheme</code>枚举。</p><p id="65ce" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">您可以通过编写适用于无限多主题的代码来轻松避免这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a526" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">正如你所看到的，你仍然可以很容易地选择<code class="fe nl nm nn no b">.dark</code>或<code class="fe nl nm nn no b">.light</code>主题，但是你也可以提供无限数量的自定义样式，只需将它们作为参数传递给<code class="fe nl nm nn no b">GoodView</code>构造函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c47d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><code class="fe nl nm nn no b">GoodView</code>为修改而关闭(无需修改)，为扩展而打开(无限数量的<code class="fe nl nm nn no b">Style</code>结构可以扩展其功能)。</p><p id="2c62" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">如果您愿意，您也可以通过添加静态常量向<code class="fe nl nm nn no b">Style</code>结构添加新的样式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8467" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">如果您将在许多地方使用新的“joker”样式，那么添加这个静态常量是有意义的，即使这意味着您正在修改<code class="fe nl nm nn no b">Style</code>结构。这样做是可以的，因为整体解决方案符合<em class="ng">OCP</em>——你可以在不改变代码的情况下改变功能。这并不意味着你总是要这样做。这一原则的全部思想就是拥有选择权。如果重构是一条路要走，不要害怕去做。</p><p id="5cd9" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">我可以保证，在<em class="ng"> iOS </em>开发中，你每天都会被这个糟糕的设计绊倒。甚至苹果公司也在很多地方犯了这个错误，它提供了一个带有可能样式的枚举，而不是让我们有可能将它们创建为某种样式结构/对象。就看<a class="ae kv" href="https://developer.apple.com/documentation/uikit/uibutton/buttontype" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae kv" href="https://developer.apple.com/documentation/uikit/uitableview/style" rel="noopener ugc nofollow" target="_blank">这里</a>！</p><h1 id="0a72" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">好了🎉</h1><p id="1473" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所以现在你知道了<em class="ng">扎实</em>的前两条原则。还剩3个！</p><p id="5874" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">顺便说一下，本文中的例子展示了一种很好的结构化方法，可以通过编程来制作视图和视图控制器，避免使用xib文件和故事板！</p><p id="d898" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">查看下一部分:<a class="ae kv" href="https://medium.com/@adrianzyga/from-hobbyist-to-professional-ios-developer-liskov-substitution-principle-f98d6e1e6b19" rel="noopener"> <em class="ng">利斯科夫代入原理</em> </a> <em class="ng">。</em></p></div></div>    
</body>
</html>