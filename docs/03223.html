<html>
<head>
<title>How to Extend Legacy Functions in JavaScript Without Breaking Anything</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不破坏任何东西的情况下扩展JavaScript中的遗留函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-extend-legacy-functions-in-javascript-without-breaking-anything-54a7ec3549b8?source=collection_archive---------24-----------------------#2020-01-28">https://betterprogramming.pub/how-to-extend-legacy-functions-in-javascript-without-breaking-anything-54a7ec3549b8?source=collection_archive---------24-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f18" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">希望…</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7cae2ed958e44140fba0b83e931ff866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBadcrK12jgQNHLslP08tg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保罗·基亚布兰多在<a class="ae kv" href="https://unsplash.com/s/photos/lightbulb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8ca3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开发过程中的某个时刻，您可能会遇到遗留代码，您的任务是扩展其功能，而不破坏或更改代码库中其他地方的功能。</p><p id="aeaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您有一个简单的函数来截断一个预定义长度为七个字符的字符串，添加一个椭圆，并返回结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想扩展这个函数来截断一个参数提供的长度。快速浏览一下这个函数，你就有了扩展它的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="cd2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了，你的功能起作用了！</p><p id="f565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，您的遗留功能不再像以前那样工作。</p><p id="dce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为遗留代码没有长度，所以当函数被调用时需要一个<code class="fe lu lv lw lx b">length</code>参数，它会像正常情况一样继续使用<code class="fe lu lv lw lx b">undefined</code>作为那个参数。</p><p id="ee7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe lu lv lw lx b">str.length</code>不能大于或小于<code class="fe lu lv lw lx b">undefined,</code>，所以<code class="fe lu lv lw lx b">if</code>语句只返回<code class="fe lu lv lw lx b">str</code>。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="5675" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">快速解决方案</h1><p id="24f3" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们有几个选项可以快速让遗留代码再次工作。对于这些例子，我们将添加另一个参数，以说明一些积极和消极的方面。</p><h2 id="252a" class="nc mg iq bd mh nd ne dn ml nf ng dp mp lf nh ni mr lj nj nk mt ln nl nm mv nn bi translated">默认值</h2><p id="1e60" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">分配参数默认值是非常常见的。当我们添加几个参数，但仍然希望能够在不指定这些参数的情况下使用该函数时，我们会使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正<em class="no"> : </em></p><ul class=""><li id="1ed1" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">在小参数表(0-3个参数)中，默认值很容易添加和维护。</li></ul><p id="5776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">底片<em class="no"> : </em></p><ul class=""><li id="8650" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">如果只想改变更右边的参数，函数调用会变得混乱。</li><li id="817f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">此外，如果试图淘汰旧代码，寻找只有一次调用而不是三次或更多次调用的函数调用可能有些耗时。</li></ul><h2 id="4e04" class="nc mg iq bd mh nd ne dn ml nf ng dp mp lf nh ni mr lj nj nk mt ln nl nm mv nn bi translated">存根函数</h2><p id="fe68" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这将被实现为在旧函数上调用的单行代码，然后由处理更多情况的新函数来处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7f2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阳性<em class="no"> : </em></p><ul class=""><li id="586f" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">拥有一个保存所有逻辑的新函数允许对每个版本的使用方式有更严格的预期，并且可以使将来查找和替换遗留代码变得更容易。</li></ul><p id="463d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">底片<em class="no"> : </em></p><ul class=""><li id="9357" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">对于更长的参数列表和函数的未来迭代，这种方法与默认方法一样容易混淆。</li><li id="9810" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">它还引入了意外使用减少了功能的先前功能的可能性。如<code class="fe lu lv lw lx b">let res = truncate('Tiny Dancer', 4, '---') // 'Tiny Da...'</code>。</li></ul></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="35b8" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">强大的解决方案</h1><p id="8fe1" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">对于一个强大的解决方案，我们希望有许多好处:</p><ul class=""><li id="7afb" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">支持所有遗留函数调用。</li><li id="663c" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">尽量减少我们需要添加的新函数的数量，只需添加一个参数。</li><li id="b8f1" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">扩展我们的参数列表，没有对<code class="fe lu lv lw lx b">void 0</code>或<code class="fe lu lv lw lx b">undefined</code>的丑陋调用。</li><li id="3c4a" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">让所有未来的程序员更容易添加新功能或更改默认功能。</li></ul><h2 id="c98f" class="nc mg iq bd mh nd ne dn ml nf ng dp mp lf nh ni mr lj nj nk mt ln nl nm mv nn bi translated">对象参数</h2><p id="6a73" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">支持这些好处的一个很好的方法是改变我们的函数来接受一个参数对象。这有很多好处，包括:</p><ul class=""><li id="efe1" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">每个参数为用户提供一个可见的名称。</li><li id="f3e5" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">消除了对有序参数的需求。</li><li id="26bc" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">无需手动跳过未使用的参数。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="cfa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这使得我们的代码更容易扩展，但这破坏了遗留调用。</p><p id="fc8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们解决这个问题，看看如何同时支持两种类型的参数:简单易用的遗留单输入参数和未来可扩展性的对象参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="b381" class="nc mg iq bd mh nd ne dn ml nf ng dp mp lf nh ni mr lj nj nk mt ln nl nm mv nn bi translated">附加:对象中带有默认值的对象参数</h2><p id="c1a0" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">虽然前面的例子解决了我们的问题，但是默认值可能会在函数中丢失，所以让我们把它们取出来。</p><p id="1355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们将稍微改变一下结构，把函数和它的选项放在另一个对象中，以显示这种方法可能具有的一些额外的效用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="491d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想用某个值多次执行这个函数，我们可以设置任何参数的默认值。</p><p id="a70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们所有的调用都可以非常明确地说明我们要求操作的内容，并且可扩展性变得简单，而无需添加不必要的参数顺序或什么函数正在进行处理的精神负担。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="8274" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="81be" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这是一种扩展遗留代码的方式，如果未来的程序员进一步扩展该功能，他们的生活会变得更加轻松。</p><p id="f501" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，它不是一个神奇的子弹，你可能会发现更简单的函数形式更适合你所面临的问题。</p><p id="9d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它通常是帮助人们编写可维护代码的技术组合，所以这只是为了提供更多的工具来解决出现的可维护性问题。</p></div></div>    
</body>
</html>