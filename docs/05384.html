<html>
<head>
<title>Kotlin Advanced Programming (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin高级编程(第3部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-advanced-programming-part-3-c459a6af435c?source=collection_archive---------2-----------------------#2020-07-05">https://betterprogramming.pub/kotlin-advanced-programming-part-3-c459a6af435c?source=collection_archive---------2-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="339f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Kotlin范围函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/65f5e6ed6c9651976a2b496ca82c834c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*QlEfR6QVN0-JjlgUEEZt6A.png"/></div></figure><p id="e3f8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你是科特林的新手，请查看我以前的帖子:</p><ul class=""><li id="a4e4" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-guide-for-beginners-5ba6018b5368?source=your_stories_page---------------------------" rel="noopener"> Kotlin初学者指南</a> —解释变量声明的基础知识&amp;为什么要学习Kotlin</li><li id="70c4" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-advanced-programming-89aef9b2ecb8?source=your_stories_page---------------------------" rel="noopener"> Kotlin高级编程</a>——这篇文章是关于Kotlin中函数&amp;类型的基础知识</li><li id="70e6" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-advanced-programming-108d7047691b" rel="noopener"> Kotlin高级编程第二部分</a> —这篇文章是关于Kotlin中的函数式编程</li></ul><p id="4de0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇文章中，我们将检查Kotlin中的检查范围函数以及如何使用它们。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="9274" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">什么是范围函数？</h1><p id="3cac" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">在科特林函数是非常重要的。作用域函数是在对象的上下文中执行代码块的函数。当我们用lambda表达式在一个对象上调用这样的函数时，它形成了一个我们可以执行操作的临时范围。在这个作用域中，基于我们使用的作用域函数，对象的上下文通常被称为<code class="fe nf ng nh ni b">it</code>(或任何自定义名称)或<code class="fe nf ng nh ni b">this</code>。</p><p id="f277" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们举一个运行函数的简单例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e8d7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，在<code class="fe nf ng nh ni b">sample(),</code>内部<code class="fe nf ng nh ni b">a</code>值被定义为<code class="fe nf ng nh ni b">1</code>，但是在<code class="fe nf ng nh ni b">run</code>范围内它被重新定义——修改后的值直到范围结束都有效。范围函数非常有用，我们可以找到许多使用它们的方法。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c769" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">不同的范围功能</h1><p id="f943" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">Kotlin中有五种不同的作用域函数。这些是:<code class="fe nf ng nh ni b">let</code>、<code class="fe nf ng nh ni b">run</code>、<code class="fe nf ng nh ni b">with</code>、<code class="fe nf ng nh ni b">apply</code>和<code class="fe nf ng nh ni b">also</code>。这五个函数做同样的事情:对一个对象执行一段代码。它们在两个主要方面有所不同:</p><ul class=""><li id="ad2c" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">引用上下文对象的方式</li><li id="217e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">返回值。</li></ul><p id="7d00" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们开始之前，让我们先来探索一下上下文对象。我们通常用简称来指代lambda表达式中的上下文对象。每个作用域函数使用两种方法中的一种作为lambda接收器(<code class="fe nf ng nh ni b">this</code>)或作为lambda参数(<code class="fe nf ng nh ni b">it</code>)来访问上下文对象。让我们逐一检查一下。</p><h2 id="dc94" class="nl mj it bd mk nm nn dn mo no np dp ms kz nq nr mu ld ns nt mw lh nu nv my nw bi translated"><strong class="ak">这个</strong> —作为接收方</h2><p id="4fe9" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">在范围函数<code class="fe nf ng nh ni b">apply</code>、<code class="fe nf ng nh ni b">run</code>和<code class="fe nf ng nh ni b">with</code>中，上下文对象由关键字<code class="fe nf ng nh ni b">this</code>引用。它们将上下文对象作为lambda接收器。在这种情况下，我们可以在访问上下文对象的成员时省略<code class="fe nf ng nh ni b">this</code>，使代码更短更干净。</p><p id="123a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们想创建一个<code class="fe nf ng nh ni b">Person</code>对象，我们这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="df53" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用<code class="fe nf ng nh ni b">this</code>和<code class="fe nf ng nh ni b">apply</code>范围:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0556" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以上所有方法都是一样的——它们用相同的值创建相同的<code class="fe nf ng nh ni b">Person</code>对象。</p><blockquote class="nx ny nz"><p id="fb09" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">“如果省略<code class="fe nf ng nh ni b">this</code>，可能很难区分接收器成员和外部对象或功能。因此，<strong class="ks iu">建议</strong>将上下文对象作为接收者(<code class="fe nf ng nh ni b">this</code>)用于主要操作对象成员的lambdas:调用其函数或分配属性”</p><p id="21a2" class="kq kr oa ks b kt ku ju kv kw kx jx ky ob la lb lc oc le lf lg od li lj lk ll im bi translated">— <a class="ae lv" href="https://kotlinlang.org/docs/reference/scope-functions.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p></blockquote><h2 id="04b4" class="nl mj it bd mk nm nn dn mo no np dp ms kz nq nr mu ld ns nt mw lh nu nv my nw bi translated">它——作为论点</h2><p id="7746" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">在范围函数<code class="fe nf ng nh ni b">let</code>和<code class="fe nf ng nh ni b">also</code>中，上下文对象由关键字<code class="fe nf ng nh ni b">it</code>引用。它们将上下文对象作为lambda参数。但是，我们有一个选项可以在这里指定参数名，如果没有指定，对象将被隐式默认名称<code class="fe nf ng nh ni b">it</code>访问。当我们没有隐式可用的对象时，比如<code class="fe nf ng nh ni b">this</code>，我们需要在调用对象函数或属性时指定预先附加到它们的<code class="fe nf ng nh ni b">it</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="44b1" class="nl mj it bd mk nm nn dn mo no np dp ms kz nq nr mu ld ns nt mw lh nu nv my nw bi translated">返回值</h2><p id="0e91" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">范围函数的不同之处在于它们返回的结果:</p><ul class=""><li id="1876" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><code class="fe nf ng nh ni b">apply</code>和<code class="fe nf ng nh ni b">also</code>返回上下文对象。</li><li id="0c23" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><code class="fe nf ng nh ni b">let</code>、<code class="fe nf ng nh ni b">run</code>和<code class="fe nf ng nh ni b">with</code>返回lambda结果。</li></ul><p id="9233" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用哪个作用域函数可以根据我们在作用域函数旁边做什么来决定。</p><p id="1717" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，让我们看看每个作用域函数</p><h1 id="6649" class="mi mj it bd mk ml oe mn mo mp of mr ms jz og ka mu kc oh kd mw kf oi kg my mz bi translated">让</h1><pre class="kj kk kl km gt oj ni ok ol aw om bi"><span id="2505" class="nl mj it ni b gy on oo l op oq">inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R</span></pre><p id="57ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">开发过程中使用最广泛的作用域函数之一，主要用于空检查。上下文对象可作为参数(<code class="fe nf ng nh ni b">it</code>)使用。返回值是lambda结果。<code class="fe nf ng nh ni b">NullPointerException</code>在大多数编程语言中都很常见。<code class="fe nf ng nh ni b">let</code>主要用于执行只有非空值的代码块。要在一个非空对象上执行操作，可以对其使用安全调用操作符<code class="fe nf ng nh ni b">?.</code>，并使用其lambda中的操作调用<code class="fe nf ng nh ni b">let</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e359" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它主要用于以<code class="fe nf ng nh ni b">it</code> <strong class="ks iu"> </strong>为参数的空检查，以及接受一种类型的输入并返回另一种类型作为结果的转换。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="cd00" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">奔跑</h1><pre class="kj kk kl km gt oj ni ok ol aw om bi"><span id="c58c" class="nl mj it ni b gy on oo l op oq">inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R</span></pre><p id="45d1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上下文对象可用作接收器(<code class="fe nf ng nh ni b">this</code>)。返回值是lambda结果。<code class="fe nf ng nh ni b">run</code>基本上可以服务于相同的用例，但是唯一的区别是上下文对象可以作为<code class="fe nf ng nh ni b">this</code>使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5a76" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们的lambda包含对象初始化和返回值的计算时，这是很有用的。</p><h1 id="681e" class="mi mj it bd mk ml oe mn mo mp of mr ms jz og ka mu kc oh kd mw kf oi kg my mz bi translated">应用</h1><pre class="kj kk kl km gt oj ni ok ol aw om bi"><span id="9114" class="nl mj it ni b gy on oo l op oq">inline fun &lt;T&gt; T.apply(<strong class="ni iu">block</strong>: T.() -&gt; Unit): T</span></pre><p id="b02c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上下文对象可用作接收器(<code class="fe nf ng nh ni b">this</code>)。返回值是对象本身。<code class="fe nf ng nh ni b">apply</code>不返回值，主要操作receiver对象的成员。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2f75" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，<code class="fe nf ng nh ni b">apply</code>访问<code class="fe nf ng nh ni b">City</code>名称的属性并覆盖它的值。它类似于<code class="fe nf ng nh ni b">let</code>——唯一的区别是<code class="fe nf ng nh ni b">apply</code>不接受返回语句，总是返回它所引用的同一个receiver对象。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1881" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">也</h1><pre class="kj kk kl km gt oj ni ok ol aw om bi"><span id="d47f" class="nl mj it ni b gy on oo l op oq">inline fun  T.also(block: (T) -&gt; Unit): T</span></pre><p id="c89f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上下文对象可作为参数使用(<code class="fe nf ng nh ni b">it</code>)。返回值是对象本身。它与<code class="fe nf ng nh ni b">apply</code>非常相似——这里唯一的区别是引用上下文对象的方式。在<code class="fe nf ng nh ni b">apply</code>中，我们可以提供一个自定义名称，以增加在<code class="fe nf ng nh ni b">let</code>情况下的可读性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7fa9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它可以用于对象的初始化，提高代码的可读性。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d44e" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">随着</h1><pre class="kj kk kl km gt oj ni ok ol aw om bi"><span id="1aa6" class="nl mj it ni b gy on oo l op oq">inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R</span></pre><p id="99a7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">上下文对象作为一个参数传递，但是在lambda内部，它可以作为一个接收器使用(<code class="fe nf ng nh ni b">this</code>)。返回值是lambda结果。在接收者对象到返回类型的转换方面，它类似于<code class="fe nf ng nh ni b">let</code>和<code class="fe nf ng nh ni b">run</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d974" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是为了更好的可读性，建议在不提供lambda结果的情况下调用上下文对象上的函数。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="11f3" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">摘要</h1><p id="e8d8" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">到目前为止，您应该对Kotlin中作用域函数的用法有了基本的了解。看看我在科特林的帖子</p><ul class=""><li id="d78d" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-guide-for-beginners-5ba6018b5368?source=your_stories_page---------------------------" rel="noopener"> Kotlin初学者指南</a> —解释变量声明的基础知识&amp;为什么要学习Kotlin</li><li id="feaf" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-advanced-programming-89aef9b2ecb8?source=your_stories_page---------------------------" rel="noopener">科特林高级编程</a>——这篇文章是关于科特林中函数&amp;类型的基础知识</li><li id="c00b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-advanced-programming-108d7047691b" rel="noopener"> Kotlin高级编程第二部分</a>——这篇文章是关于Kotlin中的函数式编程</li><li id="a1b8" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/kotlin-advanced-programming-part-3-c459a6af435c" rel="noopener"> Kotlin高级编程第3部分</a> —这篇文章是关于Kotlin中的作用域函数</li><li id="257e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-advanced-programming-part-4-4b23a17b23ff" rel="noopener"> Kotlin高级编程第4部分</a> —这篇文章是关于Kotlin中的内嵌函数&amp;具体化类型</li><li id="7ceb" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/kotlin-delegates-19d0445848eb" rel="noopener"> Kotlin委托</a>——这篇文章解释了Kotlin中的内嵌函数&amp;具体化类型</li><li id="f139" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@pavan.careers5208/explore-kotlin-sealed-classes-7f54ddb74f28" rel="noopener"> Kotlin密封类</a> —这篇文章是关于enums扩展的密封类。</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="09a0" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">参考</h1><ul class=""><li id="61a0" class="lm ln it ks b kt na kw nb kz or ld os lh ot ll lr ls lt lu bi translated"><a class="ae lv" href="https://kotlinlang.org/docs/reference/scope-functions.html" rel="noopener ugc nofollow" target="_blank">科特林文件</a></li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="5ed1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请给我你的建议和意见！</p><p id="4690" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢阅读。</p></div></div>    
</body>
</html>