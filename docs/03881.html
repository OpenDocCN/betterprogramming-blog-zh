<html>
<head>
<title>How to Mock Alamofire and URLSession Requests in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中模拟Alamofire和URLSession请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-mock-alamofire-and-urlsession-requests-in-swift-69c8f8b30097?source=collection_archive---------16-----------------------#2020-03-10">https://betterprogramming.pub/how-to-mock-alamofire-and-urlsession-requests-in-swift-69c8f8b30097?source=collection_archive---------16-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7a2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">很难相信这是唯一需要的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a6ee22d6877c2a1194a7416ebd6b4f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGVZNumaardo7QD73ayrhQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模仿数据请求从未如此容易。</p></figure><p id="dd64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们开始为我们的网络层编写测试时，嘲笑由Alamofire或<code class="fe lu lv lw lx b">URLSession</code>触发的数据请求是我们都会遇到的事情。当编写测试时，重要的是我们不实际运行请求，这样我们就不会用虚拟数据搞乱我们的后端数据库。此外，如果需要的话，这允许我们离线运行我们的测试，并带走测试的碎片。</p><p id="2019" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管许多文章建议使用依赖注入来模拟测试，但这并不是我们最终在WeTransfer所做的。总的来说，这绝对是编写测试的一项伟大技术，但它也要求您为了测试而替换代码实现。</p><p id="4bd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们决定编写一个代码解决方案，允许我们使用<code class="fe lu lv lw lx b">URLProtocol</code>模拟数据请求，并防止我们接触实际的代码实现。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="b464" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">什么是URLProtocol，为什么我要用它来模仿？</h1><p id="b7cd" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在我的文章<a class="ae nc" href="https://www.avanderlee.com/swift/printing-data-requests/" rel="noopener ugc nofollow" target="_blank">使用自定义URL协议打印数据请求</a>中，我已经详细解释了如何使用T2。基本上，您可以向您的<code class="fe lu lv lw lx b">URLSession</code>或Alamofire管理器添加一个自定义的<code class="fe lu lv lw lx b">URLProtocol</code>，它将被每个传出的请求调用。</p><p id="ba1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">苹果<a class="ae nc" href="https://developer.apple.com/documentation/foundation/urlprotocol" rel="noopener ugc nofollow" target="_blank">对</a>类的描述如下:</p><blockquote class="nd"><p id="dc9f" class="ne nf it bd ng nh ni nj nk nl nm lt dk translated">"处理特定于协议的URL数据加载的抽象类。"</p></blockquote><p id="83c4" class="pw-post-body-paragraph ky kz it la b lb nn ju ld le no jx lg lh np lj lk ll nq ln lo lp nr lr ls lt im bi translated">该类允许我们处理加载，但也操纵URL数据的加载。换句话说，它允许我们在调用之前改变响应。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="c657" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">介绍Mocker:一个简化请求模拟的框架</h1><p id="3817" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我可以编写一个定制的<code class="fe lu lv lw lx b">URLProtocol</code>解决方案来模拟本文中的请求。然而，这将需要对实现细节做一些额外的解释，而我们已经在我们的<a class="ae nc" href="https://github.com/WeTransfer/Mocker" rel="noopener ugc nofollow" target="_blank"> Mocker </a>框架中为你解决了这个问题。</p><p id="dac9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在WeTransfer，我们在所有的私人和公共项目中都使用了Mocker(例如<a class="ae nc" href="https://github.com/WeTransfer/GitBuddy" rel="noopener ugc nofollow" target="_blank"> GitBuddy </a>)。自2017年<a class="ae nc" href="https://github.com/WeTransfer/Mocker/commit/230b91fc08ec36b723b871b8299aeef292310274" rel="noopener ugc nofollow" target="_blank">起，我们一直在开发它，并在过去几年中添加了许多功能来满足我们的需求。这使得它成为一个健壮的框架，支持许多情况，包括像重定向这样的边缘情况。</a></p><h2 id="3eac" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">它是如何工作的？</h2><p id="4863" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在我们深入研究实现细节之前，最好理解一下Mocker框架是如何工作的。在其核心，它利用了<a class="ae nc" href="https://github.com/WeTransfer/Mocker/blob/master/Sources/MockingURLProtocol.swift" rel="noopener ugc nofollow" target="_blank"> MockingURLProtocol </a>，该协议负责捕捉请求并返回注册的模拟数据。</p><p id="0a70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过实例化一个新的<code class="fe lu lv lw lx b"><a class="ae nc" href="https://github.com/WeTransfer/Mocker/blob/master/Sources/Mock.swift" rel="noopener ugc nofollow" target="_blank">Mock</a></code>实例，在<code class="fe lu lv lw lx b"><a class="ae nc" href="https://github.com/WeTransfer/Mocker/blob/master/Sources/Mocker.swift" rel="noopener ugc nofollow" target="_blank">Mocker</a></code>结构的共享实例中注册<code class="fe lu lv lw lx b">Mocks</code>。所有有趣的设置逻辑都可以在这个<code class="fe lu lv lw lx b">Mock</code>结构中找到，它包含了所有符合您要求的特定逻辑。</p><p id="01de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注册了<code class="fe lu lv lw lx b">MockingURLProtocol</code>之后，请求就不可能再到达服务器了。每当在没有匹配<code class="fe lu lv lw lx b">Mock</code>的情况下执行请求时，将显示一条打印语句:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="4368" class="ns mg it lx b gy oi oj l ok ol">🚨 No mocked data found for url Optional("https://api.example.com/items") method Optional("GET"). Did you forget to use `register()`? 🚨</span></pre><p id="7283" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这改进了调试，同时防止您忘记模拟某个测试。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="69e9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">模拟Alamofire数据请求</h1><p id="0ece" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">模拟Alamofire请求可以通过在管理器中注册<code class="fe lu lv lw lx b">MockingURLProtocol</code>来完成。这是我们必须改变代码实现的唯一部分，因为我们必须注入<code class="fe lu lv lw lx b">URLProtocol</code>进行测试。</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="95cc" class="ns mg it lx b gy oi oj l ok ol">let configuration = URLSessionConfiguration.af.default<br/>configuration.protocolClasses = [MockingURLProtocol.self] + (configuration.protocolClasses ?? [])<br/><br/>let sessionManager = Session(configuration: configuration)</span></pre><p id="b147" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们可以运行我们的测试来验证我们的模拟<code class="fe lu lv lw lx b">URLProtocol</code>是否被正确注册。对于这个例子，假设我们有一个API通过使用<code class="fe lu lv lw lx b">https://api.example.com/user</code>端点来获取用户。它产生一个非常简单的JSON响应，用户只有一个<code class="fe lu lv lw lx b">name</code>属性:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="df86" class="ns mg it lx b gy oi oj l ok ol">struct User: Codable {<br/>    let name: String<br/>}</span></pre><p id="02b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以为这个端点编写如下测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7ab7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本测试中，我们完成了以下工作:</p><ul class=""><li id="02c0" class="oo op it la b lb lc le lf lh oq ll or lp os lt ot ou ov ow bi translated">我们向阿拉莫菲尔经理注册了<code class="fe lu lv lw lx b">MockingURLProtocol</code>。</li><li id="85fc" class="oo op it la b lb ox le oy lh oz ll pa lp pb lt ot ou ov ow bi translated">我们执行了从端点获取用户的请求。</li><li id="6ee2" class="oo op it la b lb ox le oy lh oz ll pa lp pb lt ot ou ov ow bi translated">我们在响应中验证了该用户与我们的预期结果用户Antoine van der Lee相匹配。</li></ul><p id="7e9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行该测试后，我们可以看到我们的<code class="fe lu lv lw lx b">MockingURLProtocol</code>被正确注册，因为控制台中打印出以下错误:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="0ea8" class="ns mg it lx b gy oi oj l ok ol">🚨 No mocked data found for url Optional("https://api.example.com/user") method Optional("GET"). Did you forget to use `register()`? 🚨</span></pre><p id="0fb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候为这个请求注册一个<code class="fe lu lv lw lx b">Mock</code>了，这样我们的测试才能成功。</p><h2 id="a41e" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">注册一个模拟</h2><p id="15c5" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">为了让我们的测试成功，我们需要创建一个<code class="fe lu lv lw lx b">Mock</code>，返回一个用户名为Antoine van der Lee的用户的JSON响应。最棒的是我们可以简单地使用符合<code class="fe lu lv lw lx b">Encodable</code>协议的用户实例！</p><p id="edd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过创建一个新的<code class="fe lu lv lw lx b">Mock</code>实例来做到这一点，该实例由端点URL和我们的JSON数据初始化:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="8dbb" class="ns mg it lx b gy oi oj l ok ol">let mockedData = try! JSONEncoder().encode(expectedUser)<br/>let mock = Mock(url: apiEndpoint, dataType: .json, statusCode: 200, data: [.get: mockedData])<br/>mock.register()</span></pre><p id="f098" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们回顾一下所采取的步骤:</p><ul class=""><li id="695e" class="oo op it la b lb lc le lf lh oq ll or lp os lt ot ou ov ow bi translated">我们的<code class="fe lu lv lw lx b">expectedUser</code>实例使用JSON编码器转换成JSON数据。</li><li id="b9a7" class="oo op it la b lb ox le oy lh oz ll pa lp pb lt ot ou ov ow bi translated">使用JSON数据和API端点创建一个<code class="fe lu lv lw lx b">Mock</code>实例。</li><li id="8a2b" class="oo op it la b lb ox le oy lh oz ll pa lp pb lt ot ou ov ow bi translated">数据类型设置为JSON，预期状态代码设置为200。</li></ul><p id="56f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们能够详细指定响应。这允许您为图像响应、400个响应代码等等编写测试。关于可能性的所有细节可以在<a class="ae nc" href="https://github.com/WeTransfer/Mocker" rel="noopener ugc nofollow" target="_blank">模仿器</a>自述文件中找到。</p><p id="bd5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的测试最终看起来如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="fa32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用我们的<code class="fe lu lv lw lx b">Mock</code>，我们的测试成功，注册的JSON数据作为响应返回。太好了！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4558" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">模拟URLSession请求</h1><p id="aa25" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">模仿<code class="fe lu lv lw lx b">URLSession</code>请求的方式几乎和Alamofire一样。我们首先必须向我们的<code class="fe lu lv lw lx b">URLSession</code>实例注册<code class="fe lu lv lw lx b">MockingURLProtocol</code>:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="f616" class="ns mg it lx b gy oi oj l ok ol">let configuration = URLSessionConfiguration.default<br/>configuration.protocolClasses = [MockingURLProtocol.self] + (configuration.protocolClasses ?? [])<br/>let sessionManager = URLSession(configuration: configuration)</span></pre><p id="ea5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们可以运行我们的请求并验证结果。为此，我们使用完全相同的<code class="fe lu lv lw lx b">Mock</code>设置:</p><pre class="kj kk kl km gt oe lx of og aw oh bi"><span id="e4aa" class="ns mg it lx b gy oi oj l ok ol">let mockedData = try! JSONEncoder().encode(expectedUser)<br/>let mock = Mock(url: apiEndpoint, dataType: .json, statusCode: 200, data: [.get: mockedData])<br/>mock.register()</span></pre><p id="9ab0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终测试如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="32d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是在单元测试中模仿你的<code class="fe lu lv lw lx b">URLSession</code>请求所需要的一切。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8876" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">模仿其他常见用例</h1><p id="f02c" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">既然我们知道了如何为Alamofire和<code class="fe lu lv lw lx b">URLSession</code>编写一个<code class="fe lu lv lw lx b">Mock</code>，我们可以研究一些编写<code class="fe lu lv lw lx b">Mocks</code>的常见用例。</p><h2 id="5471" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">验证请求是否已被调用</h2><p id="46da" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在某些情况下，您只想知道某个请求是否被调用。您可以通过使用<code class="fe lu lv lw lx b">Mock</code>上的<code class="fe lu lv lw lx b">completion</code>回调来验证这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0e7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经将响应代码设置为“204 No Content”，正如我们的实现所期望的那样，并且我们在注册<code class="fe lu lv lw lx b">Mock</code>之前设置了完成回调。</p><p id="143c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终的测试实现可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="8e00" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">验证POST主体参数</h2><p id="8d3a" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">您的代码通常会设置一个带有一定数量参数的请求。在执行请求时，最好验证您的代码是否使用了预期的参数。为此，您可以利用用请求及其POST主体参数调用的<code class="fe lu lv lw lx b">Mock</code>上的<code class="fe lu lv lw lx b">onRequest</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="0233" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">验证GET参数</h2><p id="c69f" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我们可以对GET参数做同样的事情，忽略POST主体参数，只从<code class="fe lu lv lw lx b">URLRequest</code>中提取GET参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="3b25" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="0a05" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">就是这样！我们已经介绍了利用<a class="ae nc" href="https://github.com/WeTransfer/Mocker" rel="noopener ugc nofollow" target="_blank">模仿器</a>框架模仿Alamofire和<code class="fe lu lv lw lx b">URLSession</code>请求的基础知识。你可以在项目的自述文件中找到这个框架更多的可能性。希望本文能让您更容易编写和维护模拟数据请求。</p><p id="8195" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>