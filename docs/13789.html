<html>
<head>
<title>Hands-On Explanation of How Test-Driven Design Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对测试驱动的设计如何工作的实际解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hands-on-explanation-of-how-tdd-works-c009135dfc79?source=collection_archive---------10-----------------------#2022-09-27">https://betterprogramming.pub/hands-on-explanation-of-how-tdd-works-c009135dfc79?source=collection_archive---------10-----------------------#2022-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e3a6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/528fa4a023cf3142bede202a379543b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JIQrKLURWAt0nDBv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·布纳季奇的照片</p></figure><p id="e41a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在“<a class="ae lu" href="https://medium.com/@alexbunardzic/failure-is-essential-in-devops-culture-dace2a72bfa1" rel="noopener">失败在DevOps文化中是必不可少的</a>”中，我讨论了失败在通过征求反馈交付质量中的核心作用。这是敏捷开发运维团队赖以指导和推动开发/交付的失败。<a class="ae lu" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发(TDD) </a>是任何敏捷开发价值流交付的<a class="ae lu" href="https://www.merriam-webster.com/dictionary/conditio%20sine%20qua%20non" rel="noopener ugc nofollow" target="_blank">必要条件</a>。以失败为中心的TDD方法只有在与可测量的测试相结合时才有效。</p><p id="f69c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TDD方法论是基于自然如何工作以及自然如何在进化游戏中产生赢家和输家而建模的。</p><h1 id="86d6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">自然选择</h1><p id="5a9c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">1859年，<a class="ae lu" href="https://en.wikipedia.org/wiki/Charles_Darwin" rel="noopener ugc nofollow" target="_blank">查尔斯·达尔文</a>在《物种起源 一书中提出了进化论。达尔文的论点是，自然变异是由个体生物的自发突变和不同的环境压力共同造成的。这些压力淘汰了不太适应的生物体，同时有利于其他更适应的生物体。</p><p id="23f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每一个生物都会使其染色体发生突变，这些自发的突变会遗传给下一代(后代)。然后在自然选择下测试新出现的可变性——由于环境条件的可变性而存在的环境压力。</p><p id="b198" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个简图说明了适应环境条件的过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/61ae9147017271cbec40256ca90eb525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*THEy2M81FJPWUDVa.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。不同的环境压力导致不同的自然选择结果。理查德·道金斯的<a class="ae lu" href="https://www.youtube.com/watch?v=MgK5Rf7qFaU" rel="noopener ugc nofollow" target="_blank">视频截图。</a></p></figure><p id="15cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上图展示了一群生活在自然栖息地的鱼。栖息地不同(海底或河床较深或较浅的砾石)，每条鱼也不同(较深或较浅的身体花纹和颜色)。</p><p id="d7f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还显示了两种情况(即环境压力的两种变化):</p><ol class=""><li id="4ec4" class="mu mv it la b lb lc le lf lh mw ll mx lp my lt mz na nb nc bi translated">捕食者出现了</li><li id="fe4d" class="mu mv it la b lb nd le ne lh nf ll ng lp nh lt mz na nb nc bi translated">捕食者不在</li></ol><p id="015a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一种情况下，在砾石树荫下更容易被发现的鱼被捕食者吃掉的风险更高。当沙砾颜色变深时，鱼群中颜色较浅的部分就会变得稀疏。反之亦然——当沙砾颜色较浅时，鱼群中颜色较深的部分就会变得越来越少。</p><p id="3651" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二种情况下，鱼足够放松来进行交配。在没有捕食者和有交配仪式的情况下，可以预期相反的结果:在背景中脱颖而出的鱼有更好的机会被选中交配，并将其特征传递给后代。</p><h1 id="95c2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">选择标准</h1><p id="29b3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当在可变性中进行选择时，过程决不是任意的、反复无常的、异想天开的，也不是随机的。决定性因素总是可以衡量的。这个决定性因素通常被称为测试或目标。</p><p id="ff31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个简单的数学例子可以说明这个决策过程。(只是在这种情况下它不会受自然选择的支配，而是受人工选择的支配。)假设有人让你构建一个小函数，它接受一个正数并计算这个数的平方根。你将如何着手做那件事？</p><p id="035d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">敏捷开发的方式是快速失败。从谦逊开始，坦率地承认你真的不知道如何开发这个功能。在这一点上，你所知道的是如何描述你想做的事情。用技术术语来说，你已经准备好进行一个微测试了。</p><p id="9855" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“微观测试”描述了你的具体期望。它可以简单地表述为“给定数字16，我期望平方根函数返回数字4。”你可能知道16的平方根是4。然而，你不知道，在你的头顶上，一些更大的数字(如533)的平方根。</p><p id="37aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至少，你已经制定了你的选择标准，你的测试，或者你的目标。</p><h1 id="767c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实施失败的测试</h1><p id="044d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><a class="ae lu" href="https://dotnet.microsoft.com/" rel="noopener ugc nofollow" target="_blank">。NET Core </a>平台可以说明实现。。NET通常使用<a class="ae lu" href="https://xunit.net/" rel="noopener ugc nofollow" target="_blank">xUnit.net</a>作为单元测试框架。(要遵循编码示例，请安装。NET Core和xUnit.net)</p><p id="7345" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打开命令行并创建一个文件夹，您的平方根解决方案将在其中实现。例如，键入:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7454" class="nn lw it nj b gy no np l nq nr">mkdir square_root</span></pre><p id="c3b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后键入:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2b03" class="nn lw it nj b gy no np l nq nr">cd square_root</span></pre><p id="aef5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为单元测试创建单独的文件夹:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="40f1" class="nn lw it nj b gy no np l nq nr">mkdir unit_tests</span></pre><p id="0cb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入<code class="fe ns nt nu nj b">unit_tests folder</code> (cd单元测试)并启动xUnit框架:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="a2e6" class="nn lw it nj b gy no np l nq nr">dotnet new xunit</span></pre><p id="0c94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，将一个文件夹移到square_root文件夹，并创建app文件夹:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="233b" class="nn lw it nj b gy no np l nq nr">mkdir app<br/>cd app</span></pre><p id="2155" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为C#代码创建必要的框架:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="4d47" class="nn lw it nj b gy no np l nq nr">dotnet new classlib</span></pre><p id="4520" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在打开你最喜欢的编辑器，开始破解！</p><p id="5405" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码编辑器中，导航到unit_tests文件夹并打开UnitTest1.cs。</p><p id="cf75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将UnitTest1.cs中自动生成的代码替换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0bbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个单元测试描述了期望变量应该是4的期望。下一行描述实际值。它建议通过向名为<code class="fe ns nt nu nj b">calculator</code>的组件发送消息来计算实际值。该组件被描述为能够通过接受一个数值来处理<code class="fe ns nt nu nj b">CalculateSquareRoot</code>消息。那个组件还没开发出来。但这并不重要，因为这只是描述了预期。</p><p id="fa6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，它描述了当消息被触发发送时会发生什么。此时，它断言期望值是否等于实际值。如果是，测试通过，目标达到。如果期望值不等于实际值，测试失败。</p><p id="33d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，要实现名为calculator的组件，在app文件夹中创建一个新文件，并将其命名为<code class="fe ns nt nu nj b">Calculator.cs</code>。要实现计算数字平方根的函数，请将以下代码添加到这个新文件中:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="4777" class="nn lw it nj b gy no np l nq nr">namespace app {<br/>   public class Calculator {<br/>       public double CalculateSquareRoot(double number) {<br/>           double bestGuess = number;<br/>           return bestGuess;<br/>       }<br/>   }<br/>}</span></pre><p id="9cad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在测试这个实现之前，您需要指导微测试如何找到这个新组件(<code class="fe ns nt nu nj b">Calculator</code>)。导航到<code class="fe ns nt nu nj b">unit_tests</code>文件夹并打开<code class="fe ns nt nu nj b">unit_tests.csproj</code>文件。在&lt; <code class="fe ns nt nu nj b">ItemGroup</code> &gt;代码块中添加下面一行:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7ccd" class="nn lw it nj b gy no np l nq nr">&lt;ProjectReference Include="../app/app.csproj" /&gt;</span></pre><p id="05aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保存<code class="fe ns nt nu nj b">unit_test.csproj</code>文件。现在，您已经为第一次试运行做好了准备。</p><p id="4a1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">转到命令行，将cd放入<code class="fe ns nt nu nj b">unit_tests</code>文件夹。运行以下命令:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e04d" class="nn lw it nj b gy no np l nq nr">dotnet test</span></pre><p id="fefd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行单元测试将产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/99aaaa488b42215d90c96539cb11ada5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDRk0l14If1Cqy6SMs2g3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。单元测试运行失败后的xUnit输出。</p></figure><p id="ec22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，微测试失败了。它预计向<code class="fe ns nt nu nj b">calculator</code>组件发送数字16将导致数字<code class="fe ns nt nu nj b">4</code>作为输出，但是输出(实际值)是数字<code class="fe ns nt nu nj b">16</code>。</p><p id="b59b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜你！你制造了你的第一次失败。您的微测试提供了强烈的即时反馈，敦促您修复故障。</p><h1 id="ec0f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">修复故障</h1><p id="6d54" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">要修复故障，必须改进<code class="fe ns nt nu nj b">bestGuess</code>。现在，<code class="fe ns nt nu nj b">bestGuess </code>仅仅接受函数接收的数字并返回它。不够好。</p><p id="7a06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如何计算平方根值呢？我有一个想法——看看大自然是如何解决问题的。</p><h1 id="c448" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">通过迭代模仿自然母亲</h1><p id="3a41" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">很难(几乎不可能)从第一次(也是唯一一次)尝试中猜出正确的值。你必须允许多次猜测，以增加解决问题的机会。允许多次尝试的一种方法是迭代。</p><p id="3053" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要进行迭代，将<code class="fe ns nt nu nj b">bestGuess</code>值存储在<code class="fe ns nt nu nj b">previousGuess </code>变量中，转换<code class="fe ns nt nu nj b">bestGuess </code>值，并比较两个值之间的差异。如果差的是<code class="fe ns nt nu nj b">0</code>，你就解决了问题。否则继续迭代。</p><p id="3be7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是为任何正数的平方根生成正确值的函数体:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f71b" class="nn lw it nj b gy no np l nq nr">double bestGuess = number;<br/>double previousGuess;</span><span id="3575" class="nn lw it nj b gy ny np l nq nr">do {<br/>   previousGuess = bestGuess;<br/>   bestGuess = (previousGuess + (number/previousGuess))/2;<br/>} while((bestGuess - previousGuess) != 0);</span><span id="6949" class="nn lw it nj b gy ny np l nq nr">return bestGuess;</span></pre><p id="25d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个循环(迭代)将<code class="fe ns nt nu nj b">bestGuess</code>值收敛到期望的解。现在您精心制作的单元测试通过了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/6d6e4251328f1da9b7f5f45a4d94c5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKYUtgI25gabuz9AoHKCWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">图三。单元测试成功，0个测试失败。</em></p></figure><h1 id="d558" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">迭代解决了这个问题</h1><p id="3620" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">就像大自然母亲的方法一样，在这个练习中，迭代解决了问题。结合逐步完善的渐进方法是获得满意解决方案的可靠途径。这个游戏的决定性因素是有一个可衡量的目标和测试。一旦你有了它，你就可以继续迭代直到你达到目标。</p><h1 id="7852" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">现在是笑点！</h1><p id="b03b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">好吧，这是一个有趣的实验，但更有趣的发现来自对这个新发明的解决方案的研究。到目前为止，您的starting <code class="fe ns nt nu nj b">bestGuess</code>始终等于函数作为输入参数接收的数字。如果改了开头的<code class="fe ns nt nu nj b">bestGuess</code>会怎么样？</p><p id="72ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试这一点，您可以运行几个场景。首先，当迭代试图计算25的平方根时，通过一系列猜测来观察逐步细化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0d22272118947c627367c02b7b51f619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQc_QBtfeJMWBYWAP3y74Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">图4。迭代计算25的平方根。</em></p></figure><p id="27da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从25作为<code class="fe ns nt nu nj b">bestGuess</code>开始，这个函数需要八次迭代来计算25的平方根。但是如果你在<code class="fe ns nt nu nj b">bestGuess</code>做了一个滑稽可笑的错误尝试，会发生什么呢？如果你从一个毫无头绪的第二个猜测开始，100万可能是25的平方根，会怎么样？在这种明显错误的情况下会发生什么？你的功能能够处理这样的白痴行为吗？</p><p id="52a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看马的嘴。重新运行场景，这次从100万开始，作为<code class="fe ns nt nu nj b">bestGuess</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f26408cf455b1f04f50c94a36e588c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_MtQOC4zf0_GS3U3zfNKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">图5。计算25的平方根时，从1，000，000开始逐步细化，作为初始最佳猜测。</em></p></figure><p id="6874" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哦，哇哦！从一个可笑的大数字开始，迭代次数只增加了三倍(从8次迭代到23次)。并不像你直觉预期的那样有戏剧性的增长。</p><h1 id="9450" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">这个故事的寓意</h1><p id="4595" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">啊哈！当你意识到，迭代不仅保证解决问题，而且不管你对解决方案的搜索是从一个好的还是一个糟糕的初步猜测开始，这一时刻都到来了。无论您最初的理解多么错误，迭代的过程，再加上可测量的测试/目标，将您置于正确的轨道上，并交付解决方案。保证。</p><p id="87fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图4和图5显示了急剧的烧毁。从一个非常不正确的起点开始，迭代很快燃烧到一个绝对正确的解决方案。</p><p id="c66b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，这种令人惊叹的方法是敏捷开发的精髓。</p><h1 id="8fab" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">回到一些高层次的观察</h1><p id="4f4c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">敏捷开发实践源于这样一种认识，即我们生活在一个从根本上基于不确定性、模糊性、不完整性和适度混乱的世界中。从科学/哲学的角度来看，这些特质在<a class="ae lu" href="https://en.wikipedia.org/wiki/Uncertainty_principle" rel="noopener ugc nofollow" target="_blank">海森堡的不确定性原理</a>(涵盖不确定性部分)<a class="ae lu" href="https://en.wikipedia.org/wiki/Tractatus_Logico-Philosophicus" rel="noopener ugc nofollow" target="_blank">维特根斯坦的逻辑哲学研究</a>(模糊性部分)<a class="ae lu" href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems" rel="noopener ugc nofollow" target="_blank">哥德尔的不完全性定理</a>(不完全性方面)，以及<a class="ae lu" href="https://en.wikipedia.org/wiki/Second_law_of_thermodynamics" rel="noopener ugc nofollow" target="_blank">热力学第二定律</a>(无情熵引起的混乱)中得到了很好的证明和支持。</p><p id="61a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一言以蔽之，无论你如何努力，在试图解决任何问题时，你永远无法获得完整的信息。因此，放弃傲慢的姿态，采用更谦逊的方法来解决问题，会更有利可图。谦逊会给你带来丰厚的回报——不仅是希望的解决方案，还有一个结构良好的解决方案的副产品。</p><h1 id="0486" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="c5ad" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">大自然不停地运转——它是一个连续的流动。大自然没有总体规划；所有事情的发生都是对之前发生的事情的回应。反馈回路非常紧密，表面上的进步/退步是零碎的。在自然界的任何地方，你都可以看到一步一步的改进，以一种或另一种形式。</p><p id="a958" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">敏捷开发运维是工程模型逐渐成熟的一个非常有趣的结果。DevOps是基于这样一种认识，即你现有的信息总是不完整的，所以你最好谨慎行事。</p><p id="463d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">获得一个可测量的测试(例如，一个假设，一个可测量的期望)，尝试满足它，很可能失败，然后收集反馈，修复失败，并继续。除了同意每一步都必须有一个可测量的假设/测试之外，没有其他计划。</p><p id="92c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一篇文章的<a class="ae lu" href="https://medium.com/@alexbunardzic/mutation-testing-by-example-how-to-leverage-failure-by-experimenting-fc4f13aa39bd" rel="noopener">中，我将仔细研究突变测试如何提供推动价值的急需反馈。</a></p></div></div>    
</body>
</html>