<html>
<head>
<title>Implement In-App Dark Mode Using Swift Observation Protocols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift观察协议实施应用内黑暗模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-in-app-dark-mode-using-swift-observation-protocols-7f1e960d4f7e?source=collection_archive---------13-----------------------#2019-12-16">https://betterprogramming.pub/implement-in-app-dark-mode-using-swift-observation-protocols-7f1e960d4f7e?source=collection_archive---------13-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22db" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">覆盖iOS系统范围的用户界面风格，变得容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c70857a0bd64a6dfb23b22a2da0aa4b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvAeUmpl3dpDPG20QeIxYQ.png"/></div></div></figure><p id="5019" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在iOS 13中，苹果向全世界推出了黑暗模式。要启用黑暗模式，您必须使用设备上的<em class="lq">设置</em>应用程序，并在系统范围内启用该功能。</p><p id="4d6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果不是遵循系统级的黑暗模式设置，而是希望您的应用程序有自己独立的黑暗模式设置，该怎么办？这可以实现吗？当然有一种方法，我将在本文中向您展示如何实现。</p><p id="c9f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地理解我们在这篇文章中想要达到的目的，请看下面的动画GIF。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/264ffc4ee513aacaa541f83cf86c6f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/1*pAIpVFqnocWTANuQOfvzfQ.gif"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">应用内黑暗模式设置</p></figure><p id="d6ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我不会深究在iOS中采用黑暗模式时你应该知道什么。如果想了解更多，可以看看这篇<a class="ae lw" href="https://swiftsenpai.com/design/what-a-designer-need-to-know-about-ios-dark-mode/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="53e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我将关注如何使用面向协议的方法来实现上面GIF中展示的内容。说了这么多，我们开始吧。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="eced" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">整体架构</h1><p id="5252" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">如上所述，我们将使用Swift观察协议来实现应用内黑暗模式。下图展示了我们的示例应用程序的整体架构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/1b12767246d69941f41bc2bf9de98ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a_RZRW5xrCwX_oUQ"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">示例应用程序整体架构</p></figure><p id="5015" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的示例应用程序中，我们将有两个主要组件负责跟踪和更新用户界面风格。</p><h2 id="e240" class="nc mf it bd mg nd ne dn mk nf ng dp mo ld nh ni mq lh nj nk ms ll nl nm mu nn bi translated"><strong class="ak">用户界面风格管理器</strong></h2><ul class=""><li id="698c" class="no np it kw b kx mw la mx ld nq lh nr ll ns lp nt nu nv nw bi translated">跟踪应用程序当前的用户界面风格。</li><li id="3654" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">跟踪所有的用户界面风格观察者。</li><li id="5c08" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">负责在界面风格改变时通知所有观察者。</li></ul><h2 id="5370" class="nc mf it bd mg nd ne dn mk nf ng dp mo ld nh ni mq lh nj nk ms ll nl nm mu nn bi translated"><strong class="ak">用户界面风格观察者</strong></h2><ul class=""><li id="9f48" class="no np it kw b kx mw la mx ld nq lh nr ll ns lp nt nu nv nw bi translated">在用户界面样式管理器中观察界面样式变化的协议。</li><li id="2b13" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">负责在用户界面风格改变时更新视图外观。</li></ul><p id="4653" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的想法是使所有视图控制器符合用户界面风格观察者协议，以便每当用户在示例应用程序中打开/关闭黑暗模式时，用户界面风格管理器将被更新，并将通知所有观察视图控制器相应地改变它们的视图外观。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="e51e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">实现用户界面样式管理器</h1><p id="af40" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">由于用户界面样式管理器是一个集中式组件，在示例应用程序的整个生命周期中我们只需要一个，所以我们将使它成为一个单例结构。</p><p id="4e1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe oc od oe of b">UserInterfaceStyleManager</code>结构最初的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ol class=""><li id="6add" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp ol nu nv nw bi translated">通过创建一个静态共享实例并将其初始化器设置为private来创建一个<code class="fe oc od oe of b">UserInterfaceStyleManager</code>单例。</li><li id="f8d3" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated"><code class="fe oc od oe of b">currentStyle</code>是一个私有变量，用于跟踪当前的用户界面风格。这里，我们从<code class="fe oc od oe of b">UserDefaults</code>获得它的初始值。</li><li id="a4cc" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">创建公共函数<code class="fe oc od oe of b">updateUserInterfaceStyle(_:)</code>来允许应用程序的其他组件，在我们的例子中，这将是<code class="fe oc od oe of b">UISwitch</code>，通知我们的<code class="fe oc od oe of b">UserInterfaceStyleManager</code>关于用户界面风格的改变。</li></ol><p id="d716" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了在<code class="fe oc od oe of b">currentStyle</code>发生变化时通知所有的观察者，我们的<code class="fe oc od oe of b">UserInterfaceStyleManager</code>需要引用所有的观察者。</p><p id="1888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们将使用字典来跟踪所有的观察者。此外，我们将添加两个公共函数，使我们能够从<code class="fe oc od oe of b">UserInterfaceStyleManager</code>添加和删除观察者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ol class=""><li id="3477" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp ol nu nv nw bi translated"><code class="fe oc od oe of b">observers</code>是一个字典，记录所有添加的观察点。请注意，观察者是作为弱引用添加到字典中的，这是为了避免发生保留循环(稍后将详细介绍)。此外，我们使用观察者的<code class="fe oc od oe of b">ObjectIdentifier</code>作为字典键。</li><li id="f388" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">一个公共函数，使其他组件能够向<code class="fe oc od oe of b">UserInterfaceStyleManager</code>添加观察者。</li><li id="281d" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">一个公共函数，允许其他组件从<code class="fe oc od oe of b">UserInterfaceStyleManager</code>中移除观察者。</li></ol><p id="ef1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能会注意到在上面的代码片段中使用了<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>和<code class="fe oc od oe of b">WeakStyleObserver</code>。</p><p id="4b9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oc od oe of b">UserInterfaceStyleObserver</code>是我们尚未实现的观察协议，我们将在稍后讨论。现在，我们来看看<code class="fe oc od oe of b">WeakStyleObserver</code>。</p><p id="567e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oc od oe of b">WeakStyleObserver</code>是一种包装器类型，它用弱引用跟踪<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>实例。</p><p id="ac49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要这样做的原因是Swift中的字典总是有对它们的元素的强引用，这可能会引入保留循环并导致内存泄漏。</p><p id="d541" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe oc od oe of b">WeakStyleObserver</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="56a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将向<code class="fe oc od oe of b">currentStyle</code>变量添加一个属性观察者，这样当<code class="fe oc od oe of b">currentStyle</code>的值改变时<code class="fe oc od oe of b">UserInterfaceStyleManager</code>将执行一个动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="cce2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面代码片段中的<code class="fe oc od oe of b">styleDidChanged()</code>函数将遍历观察者的字典，并通知每个观察者用户界面样式的变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ba0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将暂时让<code class="fe oc od oe of b">for-loop</code>的身体空着。一旦我们实现了<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>，我们将回到这个话题。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="c7ee" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">实现用户界面样式观察器</h1><p id="94bd" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">下面的代码片段显示了<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>协议的定义。</p><p id="ec1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们将<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>定义为一个类专用协议。</p><p id="ec89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为我们在<code class="fe oc od oe of b">UserInterfaceStyleManager</code>中使用<code class="fe oc od oe of b">ObjectIdentifier</code>作为<code class="fe oc od oe of b">observers</code>字典的键，而<code class="fe oc od oe of b">ObjectIdentifier</code>只是一个支持类对象。</p><p id="1e54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们将不得不使<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>成为一个类专用协议，这样只有类才能符合该协议。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d4e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oc od oe of b">UserInterfaceStyleObserver</code>的功能相当简单。它只包含两个功能。</p><ol class=""><li id="6811" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp ol nu nv nw bi translated">负责向<code class="fe oc od oe of b">UserInterfaceStyleManager</code>添加观察者的功能。</li><li id="af64" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">当用户界面样式改变时触发的功能。因此，这个函数会在需要的时候改变视图的外观。</li></ol><p id="969c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将使<code class="fe oc od oe of b">UIViewController</code>符合<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>协议并实现这两个功能。</p><p id="1c83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用iOS 13中引入的新属性<code class="fe oc od oe of b">UIViewController</code>—<code class="fe oc od oe of b"><a class="ae lw" href="https://developer.apple.com/documentation/uikit/uiviewcontroller/3238087-overrideuserinterfacestyle" rel="noopener ugc nofollow" target="_blank">overrideUserInterfaceStyle</a></code>来控制视图控制器的外观。</p><p id="56d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该属性使我们能够覆盖系统用户界面样式，并强制视图控制器遵循我们想要的外观。</p><p id="4839" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要强制视图控制器始终以黑暗模式显示，我们可以如下操作:</p><pre class="kj kk kl km gt om of on oo aw op bi"><span id="722f" class="nc mf it of b gy oq or l os ot">overrideUserInterfaceStyle = .dark</span></pre><p id="39ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住这一点，我们现在可以开始实现<code class="fe oc od oe of b">UIViewController</code>的<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="4884" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe oc od oe of b">startObserving(_:)</code>函数中，我们将视图控制器注册为<code class="fe oc od oe of b">UserInterfaceStyleManager</code>的观察者。之后，我们将设置视图控制器的<code class="fe oc od oe of b">overrideUserInterfaceStyle</code>值。</p><p id="e7fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每当<code class="fe oc od oe of b">UserInterfaceStyleManager</code>的<code class="fe oc od oe of b">currentStyle</code>发生变化时，就会触发<code class="fe oc od oe of b">userInterfaceStyleManager(_:didChangeStyle:)</code>功能，因此，这是设置<code class="fe oc od oe of b">overrideUserInterfaceStyle</code>值的最佳位置，这样当用户界面风格发生变化时，视图控制器的外观也会随之更新。</p><p id="cd63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们也在<code class="fe oc od oe of b">userInterfaceStyleManager(_:didChangeStyle:)</code>函数内部调用<code class="fe oc od oe of b">setNeedsStatusBarAppearanceUpdate()</code>。这是为了确保状态栏外观将始终遵循当前的用户界面样式。</p><p id="d783" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两个功能都实现后，<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>现在可以与<code class="fe oc od oe of b">UserInterfaceStyleManager</code>集成了。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="19a3" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">重新访问用户界面样式管理器</h1><p id="aa48" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">这是我们开始将<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>与示例应用程序的视图控制器集成之前需要做的最后一点工作。</p><p id="c6c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将从我们离开的地方继续，实现<code class="fe oc od oe of b">UserInterfaceStyleManager</code>的<code class="fe oc od oe of b">styleDidChanged()</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b40d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe oc od oe of b">styleDidChanged()</code>函数中，我们将遍历每一个观察者并触发其<code class="fe oc od oe of b">userInterfaceStyleManager(_:didChangeStyle:)</code>来通知观察者用户界面风格的变化。</p><p id="cc9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，在遍历所有观察器的同时，我们也借此机会清理所有已被释放的观察器。</p><p id="40ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至此，我们的示例应用程序的两个核心组件已经启动并运行。现在，我们可以将它们与示例应用程序的视图控制器集成起来。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="a680" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">与视图控制器集成</h1><p id="284e" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">这就是乐趣的开始！</p><p id="a6b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们终于可以看到我们的<code class="fe oc od oe of b">UserInterfaceStyleManager</code>和<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>在行动。下面是我们将要使用的两个视图控制器— <code class="fe oc od oe of b">MainViewController</code>和<code class="fe oc od oe of b">SettingsViewController</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/c9d85432a822e0cf7d74bed44fe643eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yhMcyfebhQVv78lw"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">主视图控制器和设置视图控制器</p></figure><p id="12d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要做的第一件事是连接<code class="fe oc od oe of b">SettingsViewController</code>中的<code class="fe oc od oe of b">UISwitch</code>并实现它的<em class="lq">值已更改的</em>事件方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ol class=""><li id="9efb" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp ol nu nv nw bi translated">我们需要在<code class="fe oc od oe of b">darkModeSwitch</code>的状态上反映当前的用户界面风格，因此，我们将基于<code class="fe oc od oe of b">UserInterfaceStyleManager</code>的<code class="fe oc od oe of b">currentStyle</code>值来设置<code class="fe oc od oe of b">darkModeSwitch</code>的状态。</li><li id="42ea" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">每次用户触发<code class="fe oc od oe of b">darkModeSwitch</code>，我们都会在<code class="fe oc od oe of b">UserDefaults</code>中跟踪它的状态。</li><li id="2880" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp ol nu nv nw bi translated">根据<code class="fe oc od oe of b">darkModeSwitch</code>的状态更新<code class="fe oc od oe of b">UserInterfaceStyleManager</code>的基地。</li></ol><p id="73ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将让<code class="fe oc od oe of b">MainViewController</code>和<code class="fe oc od oe of b">SettingsViewController</code>都成为<code class="fe oc od oe of b">UserInterfaceStyleManager</code>的观察者。我们需要做的是为两个视图控制器调用<code class="fe oc od oe of b">viewDidLoad()</code>中的<code class="fe oc od oe of b">startObserving(_:)</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1e9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！现在，<code class="fe oc od oe of b">MainViewController</code>和<code class="fe oc od oe of b">SettingsViewController</code>都会在<code class="fe oc od oe of b">UserInterfaceStyleManager</code>变化时更新外观。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="a56c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">但是等等…</h1><p id="e712" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">如果到目前为止您已经阅读了整篇文章，那么您可能已经注意到，除了导航栏之外，所有内容都工作正常。即使我们在示例应用程序中打开了黑暗模式，它仍然处于明亮模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/4ce86ab8b7ef16bbb3c1452ad4e6c517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/0*ooiR7FpIBmv55vBS"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">导航条仍处于亮灯模式</p></figure><p id="f372" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是导航控制器没有观察到<code class="fe oc od oe of b">UserInterfaceStyleManager</code>。由于<code class="fe oc od oe of b">UINavigationController</code>也是<code class="fe oc od oe of b">UIViewController</code>的子类，这个问题的解决方案非常简单，你只需要:</p><ul class=""><li id="392c" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp nt nu nv nw bi translated">创建<code class="fe oc od oe of b">UINavigationController</code>的子类，调用<code class="fe oc od oe of b">viewDidLoad()</code>中的<code class="fe oc od oe of b">startObserving(_:)</code>函数。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="1733" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp nt nu nv nw bi translated">将子类指定为storyboard中导航控制器的自定义类。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/dc4d2d98652569fddfb829afe2e83846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gH-yd6Gz7TU3cetG"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">将自定义类分配给导航控制器</p></figure><p id="660a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您尝试构建并再次运行您的示例应用程序，您应该能够在切换<code class="fe oc od oe of b">UISwitch</code>状态时看到导航栏外观被更新。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="c82a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">更进一步</h1><p id="d642" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">到目前为止，应用内黑暗模式的实现被认为已经完成<em class="lq"/>。通过使用我们讨论的概念，我们可以轻松地将任何视图控制器添加到示例应用程序中，并使其支持应用程序内黑暗模式。</p><p id="ca39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们不会就此止步。</p><p id="7e2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果参考苹果的<a class="ae lw" href="https://developer.apple.com/documentation/uikit/uiview/3238086-overrideuserinterfacestyle" rel="noopener ugc nofollow" target="_blank">文档</a>，<code class="fe oc od oe of b">overrideUserInterfaceStyle</code>也是一个<code class="fe oc od oe of b">UIView</code>的实例属性。这意味着我们可以通过改进我们的<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>来进一步支持<code class="fe oc od oe of b">UIView</code>。</p><p id="e0e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了展示一个支持应用内黑暗模式的<code class="fe oc od oe of b">UIView</code>,我们将创建一个仅支持光照模式的视图控制器，其中包含一个支持应用内黑暗模式的子视图。下面的动画GIF展示了我们接下来要实现的目标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/93f78b011ecf8f6f651528fc441750e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/1*bbpvcnFe3cL4Yy2FHrelWQ.gif"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">UIView的应用内黑暗模式</p></figure><p id="4af2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们必须通过遵守<code class="fe oc od oe of b">UserInterfaceStyleObserver</code>协议来扩展<code class="fe oc od oe of b">UIView</code>类。</p><p id="e471" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oc od oe of b">startObserving(_:)</code>和<code class="fe oc od oe of b">userInterfaceStyleManager(_:didChangeStyle:)</code>的实现与<code class="fe oc od oe of b">UIViewController</code>的实现非常相似。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="19f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将创建<code class="fe oc od oe of b">UIView</code>的子类，并在<code class="fe oc od oe of b">draw(_:)</code>中调用<code class="fe oc od oe of b">startObserving(_:)</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c74c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样，你做了自定义<code class="fe oc od oe of b">UIView</code>支持应用内黑暗模式。现在，将自定义的<code class="fe oc od oe of b">UIView</code>添加到仅灯光模式的视图控制器中，以查看它的运行情况。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3435" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">最后但并不是最不重要的</h1><p id="4f63" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">我已经将完整的样本项目上传到了GitHub。请随意下载并使用它。</p><p id="a1a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章能让你很好地理解如何使用面向协议的编程方式实现应用内黑暗模式。</p><p id="72ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多关于在你的iOS应用中采用黑暗模式的信息，请查看以下两篇文章:</p><ul class=""><li id="8eae" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp nt nu nv nw bi translated"><a class="ae lw" href="https://swiftsenpai.com/design/what-a-designer-need-to-know-about-ios-dark-mode/" rel="noopener ugc nofollow" target="_blank">设计师与开发者合作时需要了解的iOS黑暗模式</a>。</li><li id="f6de" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><a class="ae lw" href="https://www.fivestars.blog/code/ios-dark-mode-how-to.html" rel="noopener ugc nofollow" target="_blank">如何在你的iOS App中采用黑暗模式</a>。</li></ul><p id="5f84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想了解更多关于观察协议设计模式的知识，请看这篇文章:</p><ul class=""><li id="c9bd" class="no np it kw b kx ky la lb ld oi lh oj ll ok lp nt nu nv nw bi translated"><a class="ae lw" href="https://www.swiftbysundell.com/articles/observers-in-swift-part-1/" rel="noopener ugc nofollow" target="_blank">Swift中的观察员</a>。</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="7022" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="3876" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">如果你有任何问题或想法，请随时给我留言。我希望这对你有所帮助！</p><p id="d137" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读和快乐编码。</p></div></div>    
</body>
</html>