<html>
<head>
<title>Build Your Own E-Commerce Keystone.js-Based System — Environment Setup and Base Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您自己的基于Keystone.js的电子商务系统——环境设置和基本模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-own-e-commerce-keystone-js-based-system-environment-setup-and-base-models-2c02a3e3a70b?source=collection_archive---------3-----------------------#2022-03-18">https://betterprogramming.pub/build-your-own-e-commerce-keystone-js-based-system-environment-setup-and-base-models-2c02a3e3a70b?source=collection_archive---------3-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4030" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这一周，我们将亲自动手开始编码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e72a27b203244a6d9156347852e789fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qfNa230Ta9ZJQZNc"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ludo_photos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ludovic Charlet </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="b507" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="3f63" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">上周的文章是关于使用Keystone.js构建电子商务系统的系列文章的第一篇，它主要关注于<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-e-commerce-keystone-js-based-system-requirements-and-architecture-3d639241b963">系统需求及其基本架构</a>。这一周，我们将尝试一下，开始编写代码。首先，我们将讨论开发环境及其设置。然后是Keystone和Next设置，最后是基本型号设置。此外，本文的完成代码可以在我的<a class="ae kv" href="https://github.com/eabald/keystone-e-commerce/tree/Environment-setup-and-base-models" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="bd48" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">开发环境设置</h1><p id="fba6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们开始为我们的系统<code class="fe mk ml mm mn b">keystone-e-commerce</code>创建一个项目文件夹，在我的例子中，并创建一些必要的文件。在控制台中运行以下命令:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="c51d" class="ms kx iq mn b gy mt mu l mv mw">mkdir keystone-e-commerce &amp;&amp; cd keystone-e-commerce<br/>touch README.md docker-compose.dev.yml .gitignore .env.example .env</span></pre><p id="4295" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">根据前面的文章，这个系统的数据层包含两个元素:数据库和搜索引擎。在我们的开发环境中本地使用它们的最简单的方法是使用Docker。所以，是时候更新我们的<code class="fe mk ml mm mn b">docker-compose.dev.yaml</code>文件了。只需添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3992" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">另外，我在这里添加了<code class="fe mk ml mm mn b">pgAdmin</code>。这是一个非常有用的工具，尤其是在开发环境中。接下来，必要的事情是为系统设置环境变量。最简单的方法是创建一个<code class="fe mk ml mm mn b">.env</code>文件，并在所有容器中使用它。好了，让我们添加所有必要的变量，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="31f9" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">我已经添加了云二进制集成所需的变量；我们稍后将把<br/>还给他们。接下来更新<code class="fe mk ml mm mn b">.gitgnore</code>文件。就目前而言，这就足够了。以下代码将有所帮助:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="8453" class="ms kx iq mn b gy mt mu l mv mw">**/node_modules<br/>.env</span></pre><p id="0226" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">现在，有了这个基本设置，我们可以用这个命令启动我们的容器:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="014e" class="ms kx iq mn b gy mt mu l mv mw">docker-compose -f docker-compose.dev.yml up</span></pre><h1 id="8a0f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Kesytone.js和Next.js设置</h1><p id="ad27" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">完成这个设置后，我们可以专注于系统的其他部分。首先，让我们创建Next.js客户端应用程序。老实说，这里我们只打算创建它并将其添加到Docker设置中。在本系列的后续文章中将会做更多的工作。让我们运行适当的命令:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="b79e" class="ms kx iq mn b gy mt mu l mv mw">yarn create next-app --typescript</span></pre><p id="ed4e" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">脚本会要求我们输入应用程序的名称。我把我的名字叫做<code class="fe mk ml mm mn b">client</code>。安装后，我们必须为这个应用程序创建<code class="fe mk ml mm mn b">Dockerfile.dev</code>来与其他容器一起使用。如你所见，这是一个相当简单的问题:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="83ed" class="ms kx iq mn b gy mt mu l mv mw">FROM node:16</span><span id="1aae" class="ms kx iq mn b gy ne mu l mv mw">WORKDIR /usr/app</span><span id="41a4" class="ms kx iq mn b gy ne mu l mv mw">CMD yarn dev -p 3000</span></pre><p id="b9b8" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">此外，用以下代码更新<code class="fe mk ml mm mn b">services</code>部分下的<code class="fe mk ml mm mn b">docker-compose.dev.yml</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c489" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">像这样的解决方案允许一个主要的<code class="fe mk ml mm mn b">.env</code>文件，这是很好的，并给出了所有系统秘密的集中控制。此外，它将整个系统封装在一个封闭的docker网络中。目前，这就是应用程序的这一部分。所以，我们切换到后端部分，设置Kesytone.js。</p><p id="158e" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">首先，运行脚本来创建应用程序。我选择了<code class="fe mk ml mm mn b">backend</code>作为它的文件夹名。</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="a191" class="ms kx iq mn b gy mt mu l mv mw">yarn create keystone-app</span></pre><p id="af2d" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">之后就基本可以用了，但是首先要更新数据库等配置。在<code class="fe mk ml mm mn b">keystone.ts</code>中，添加凭证并更新列表的导入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7228" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">然后，使用以下代码创建额外的文件夹，以便有一个清晰易懂的结构:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="6691" class="ms kx iq mn b gy mt mu l mv mw">mkdir consts enums schema</span></pre><p id="5614" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">此外，在主配置文件中导入需要我们在<code class="fe mk ml mm mn b">schema</code>文件夹中添加<code class="fe mk ml mm mn b">index.ts</code>才能正常工作。剩下的最后一个设置元素是创建<code class="fe mk ml mm mn b">Dockerfile.dev</code>文件并更新<code class="fe mk ml mm mn b">docker-compose.dev.yml</code>。它将与前一个非常相似，如下所示:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="c112" class="ms kx iq mn b gy mt mu l mv mw">FROM node:16</span><span id="3254" class="ms kx iq mn b gy ne mu l mv mw">WORKDIR /usr/app</span><span id="e53b" class="ms kx iq mn b gy ne mu l mv mw">CMD yarn dev</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8e71" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">这也将允许我们用一个命令启动整个系统。</p><h1 id="7ae4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">模型设置</h1><p id="63c3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">设置工作完成后，我们可以开始创建所有必要的Keystone列表(在我们的例子中是数据模型)。先说<code class="fe mk ml mm mn b">User</code>型号。基本上，它将保存所有用户数据，包括系统内部的角色和权限。在模式文件夹中创建<code class="fe mk ml mm mn b">user.schema.ts</code>。目前，我们只关心列表的<code class="fe mk ml mm mn b">fields</code>属性。我们必须在那里添加所有必需的字段，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="98b3" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">字段<code class="fe mk ml mm mn b">name</code>、<code class="fe mk ml mm mn b">email</code>和<code class="fe mk ml mm mn b">password</code>相当明显。其目的是识别<code class="fe mk ml mm mn b">user</code>，是授权和认证过程所必需的。这三个都是必须的。此外，<code class="fe mk ml mm mn b">email</code>必须是唯一的，在管理用户界面，它可以用来过滤所有的用户。更有意思的是<code class="fe mk ml mm mn b">role</code>领域。它的类型是select，保存系统中用户权限的信息。它将在数据库中创建<code class="fe mk ml mm mn b">enum</code>列来保持它的整洁。我已经将选项值移到了<code class="fe mk ml mm mn b">consts</code>文件夹中的一个单独的文件中。</p><p id="a060" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="70ad" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">此外，我已经将所有值移动到<code class="fe mk ml mm mn b">enums</code>文件夹中的文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2306" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">目前来看，这两个角色已经足够了。以后，我们会需要更多的。最后一个字段保存对<code class="fe mk ml mm mn b">Address</code>列表的引用。准确地说，是一对多的关系。下一个列表包含与用户相关的所有地址；每一个都可以有多个。因此，创建如下所示的<code class="fe mk ml mm mn b">address.schema.ts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5010" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">该列表包含用户订单运输中需要的所有必要的地址信息。为了提供足够的交货信息，大多数字段都是必需的。此外，该列表还保存了记录创建和最后一次修改的时间戳。最后一个字段是对这个地址的所有者<code class="fe mk ml mm mn b">user</code>的引用，在这种情况下，它是多对一关系。</p><p id="36ef" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">接下来，与<code class="fe mk ml mm mn b">user</code>列表紧密相关的是<code class="fe mk ml mm mn b">Cart</code>型号。它包含用户添加到购物车中的产品的所有信息、它们的总和以及最后一次修改的日期。每个用户有一个<code class="fe mk ml mm mn b">Cart</code>，所以是一对一的关系。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f43b" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">在每个<code class="fe mk ml mm mn b">Cart</code>中，可以添加许多产品，并且同一产品可以添加到多个购物车中，因此它创建了多对多关系。</p><p id="1221" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">这样一来，我们可以专注于其他模型。接下来，与<code class="fe mk ml mm mn b">User</code>相关并且与<code class="fe mk ml mm mn b">Cart</code>松散耦合的是<code class="fe mk ml mm mn b">Order</code>列表。它包含当前正在处理和已经处理的订单的所有信息。第一个字段是对这个订单的所有者<code class="fe mk ml mm mn b">user</code>的引用，一个一对一的关系。每个用户可以有多个订单，但每个订单只有一个所有者。</p><p id="a32b" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">下一个字段包含这个订单中序列化为JSON的产品的信息。通过这种方式，我们可以有序地保存所有产品的信息，不仅是当前库存的产品，还包括从报价中删除的产品。</p><p id="6f99" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">接下来，两个字段保持与列表<code class="fe mk ml mm mn b">Payment</code>和<code class="fe mk ml mm mn b">Shipment</code>的关系，都是一对一的关系。最后三个字段包含有关创建日期、上次修改和订单状态的信息。最后一个是在选择类型中，我将所有选项和值移动到单独的文件中，就像之前的用户角色一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3503" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">接下来的两个列表补充了<code class="fe mk ml mm mn b">Order</code>模型，并保存了与其相关的<code class="fe mk ml mm mn b">Payment</code>和<code class="fe mk ml mm mn b">Shipment</code>的信息。它们都包含关于两个业务流程的时间戳和状态的基本信息(以与订单状态相同的方式创建)以及它们与<code class="fe mk ml mm mn b">Order</code>的关系。</p><p id="9435" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">其中第一个还包含来自第三方提供者的订单总数、货币和交易ID的信息。这件事我还没想好具体整合，但大概会是<a class="ae kv" href="https://stripe.com/" rel="noopener ugc nofollow" target="_blank">条纹</a>因为我最熟悉了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ca3a" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">另一方面，<code class="fe mk ml mm mn b">Shipment</code>模型保存负责处理、打包和发送货物的员工的信息。类似地，像前一个例子一样，还有来自负责处理交付的第三方系统的外部ID的信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="dd7c" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">目前，所有状态字段只包含一个选项— <code class="fe mk ml mm mn b">Created</code>。在本系列的下一部分中，我们将更多地关注系统的这些部分，我们将添加其他必要的选项。</p><p id="ece8" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">最后一组模型侧重于产品。主<code class="fe mk ml mm mn b">Product</code>列表包含<code class="fe mk ml mm mn b">name</code>、<code class="fe mk ml mm mn b">description</code>、<code class="fe mk ml mm mn b">SEO description</code>、<code class="fe mk ml mm mn b">price</code>、<code class="fe mk ml mm mn b">rating </code>(星星)和<code class="fe mk ml mm mn b">timestamps</code>等产品基本信息。其余的字段与更具体的产品信息建立各种关系，如产品图片、类别和库存。</p><p id="3327" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">第一个创建一对多关系；第二个是多对多关系，最后一个是一对一关系。基本上，一个产品可以有多个图像，但是图像只属于一个产品。每个可能有类别，类别有许多产品，最后，每个只有一个库存信息(正如我在上一篇文章中提到的，我决定只支持一个仓库设置)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1fd0" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">下一个列表包含产品图像。这里有两个重要的字段:<code class="fe mk ml mm mn b">alt</code>和<code class="fe mk ml mm mn b">image</code>。第一个包含为每个图像填充HTML alt属性所需的信息。第二个允许直接上传图片到Cloudinary CDN。所有这些都由时间戳字段补充。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d1e0" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">下一个列表<code class="fe mk ml mm mn b">Stock</code>，包含可订购产品数量的信息。此外，还有关于下一次预期交付和其中产品数量的信息。当用户试图订购比现有产品更多的产品时，这是必要的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7562" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">最后一个模型<code class="fe mk ml mm mn b">Category</code>，保存了关于产品类别及其相互关系的信息。这里的字段包括<code class="fe mk ml mm mn b">category name</code>、<code class="fe mk ml mm mn b">related products</code>、<code class="fe mk ml mm mn b">parent category</code>(如果有的话)和常用的<code class="fe mk ml mm mn b">timestamps</code>。这种内部关系允许很容易地创建类别树，这在创建我们的系统前端时会很有用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1c19" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">这里要做的最后一件事是将所有模型导入到<code class="fe mk ml mm mn b">index.ts</code>中，该模型被导入到如下所示的<code class="fe mk ml mm mn b">keystone.ts</code>主配置文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3362" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">关于时间戳的一个快速说明，每个时间戳都有一组默认值，用户不能编辑。但是在下一篇文章中会有更多关于这个主题的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/8f301c6d7bd249ad4bd56490fb0a2d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z060l7IpY-RVkeikvf9wKA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ER图</p></figure><p id="841d" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">好了，这就是我们要创建的所有模型。现在是时候在数据库中创建必要的迁移和相应的表了。从旋转数据库容器开始。</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="c310" class="ms kx iq mn b gy mt mu l mv mw">docker-compose -f docker-compose.dev.yml up database</span></pre><p id="7942" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">之后，从我们后端的独立终端开始:</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="1087" class="ms kx iq mn b gy mt mu l mv mw">cd backend &amp;&amp; yarn dev</span></pre><p id="d325" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">脚本将询问新迁移的名称，键入<code class="fe mk ml mm mn b">initial_models</code>并按回车键。它将处理表的创建并生成迁移文件。现在我们可以停止这两个进程并启动整个系统。</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="849b" class="ms kx iq mn b gy mt mu l mv mw">docker-compose -f docker-compose.dev.yml up database</span></pre><h1 id="346f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="bf40" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们有了一个工作的开发环境和基本的模型设置，所以它为我们的系统提供了一个坚实的基础。下一次，我们将开始构建电子商务系统中所需的附加功能。首先，我们将关注访问控制和访问系统不同部分的用户特权。</p><p id="3014" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">我希望你喜欢它。如果您有任何问题或意见，请随时提问。</p><p id="0e0f" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">祝您愉快！</p></div></div>    
</body>
</html>