<html>
<head>
<title>How to Keep Your App Dependencies Up-To-Date?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让你的应用依赖保持最新？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-keep-your-app-dependencies-up-to-date-833fc45dae4?source=collection_archive---------1-----------------------#2021-12-03">https://betterprogramming.pub/how-to-keep-your-app-dependencies-up-to-date-833fc45dae4?source=collection_archive---------1-----------------------#2021-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="42f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有哪些挑战，如何正确地自动化维护？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dfef445e5b285af4d6ade2ea1de7819e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFhPZpm9GjOzALRpAzUFhQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@fahrulazmi" rel="noopener ugc nofollow" target="_blank">法鲁拉斯米</a>在<a class="ae ky" href="https://unsplash.com/photos/BnWDqUCWQDU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="143f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件开发的一个方面经常被忽视:维护依赖关系。我不会说谎，在很长一段时间里，我和我的团队都是如此。</p><h1 id="d70c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么要花时间在维护上？</h1><p id="ca96" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">保持过时的依赖关系不仅会造成不兼容，或者看起来不酷。它提出了两个大问题:安全性和性能。</p><p id="7ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得<a class="ae ky" href="https://www.google.com/amp/s/www.wired.com/story/equifax-breach-no-excuse/amp" rel="noopener ugc nofollow" target="_blank"> Equifax事件</a>吗？好吧，这是一笔本可以避免的4.25亿美元的和解金，但如何避免呢？Apache Struts的副总裁René Gielen说:</p><blockquote class="ms mt mu"><p id="32a4" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">我们意识到的大多数违规行为都是由于未能更新软件组件造成的，而这些组件在数月甚至数年内都是易受攻击的</p></blockquote><p id="774c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，维护依赖关系对性能也有很大的影响。带有<a class="ae ky" href="https://medium.com/opendoor-labs/how-we-improved-app-performance-and-code-quality-by-upgrading-react-navigation-25ccd8363432" rel="noopener">反应本地导航</a>的用例就是一个很好的例子。它展示了最新版本如何带来更高的性能，同时也有助于提高代码质量。</p><div class="mz na gp gr nb nc"><a href="https://medium.com/opendoor-labs/how-we-improved-app-performance-and-code-quality-by-upgrading-react-navigation-25ccd8363432" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">我们如何通过升级React Navigation来提高应用性能和代码质量</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">深入探讨Opendoor如何升级我们最重要的第三方库&amp;在不重写的情况下提高性能…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><h1 id="8a03" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">挑战</h1><p id="3796" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当升级依赖关系时，有一个主要问题:<strong class="lb iu">时间</strong>。</p><p id="0450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须了解每一个依赖项更新，并应用必要的更改。对于大型应用程序来说，在同一天进行多次更新并不罕见。</p><p id="07c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">应用必要的变更</em>意味着:</p><ul class=""><li id="315d" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">更新您的配置(package.json with NodeJS，Maven config with Java，或者pip for Python，..)</li><li id="1a1c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">通常将升级后的配置发送到GIT存储库</li><li id="ed2b" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">如果您希望您的应用程序能够工作，那么在将它们添加到您的主工作之前，您需要测试您的新配置(有时还需要进行更改)。</li></ul><p id="d207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些工具允许您获取要更新的依赖项列表。例如NPM有一个<a class="ae ky" href="https://docs.npmjs.com/cli/v8/commands/npm-outdated" rel="noopener ugc nofollow" target="_blank">内置命令</a>。其他社区工具也有助于达到同样的效果，但功能更多，比如<a class="ae ky" href="https://www.npmjs.com/package/npm-check-updates" rel="noopener ugc nofollow" target="_blank"> npm-check-updates </a>。</p><p id="6c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里你面临第二个挑战:这个更新<strong class="lb iu">会打破什么</strong>？</p><div class="mz na gp gr nb nc"><a href="https://semver.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">语义版本2.0.0</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">给定主要版本号。补丁，增加:主要版本当你做不兼容的API改变，次要…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">semver.org</p></div></div></div></a></div><p id="6ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包经理要求开发人员遵循一个版本控制系统(<a class="ae ky" href="https://docs.npmjs.com/about-semantic-versioning" rel="noopener ugc nofollow" target="_blank"> NPM </a>、<a class="ae ky" href="https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm" rel="noopener ugc nofollow" target="_blank">玛文</a>、<a class="ae ky" href="https://www.python.org/dev/peps/pep-0440/" rel="noopener ugc nofollow" target="_blank">皮普</a>)。这通常至少包括一个次要版本和一个主要版本。次要版本指定一个新功能，而主要版本表示一个<a class="ae ky" href="https://en.wiktionary.org/wiki/breaking_change" rel="noopener ugc nofollow" target="_blank"> <em class="mv">突破性变化</em> </a>。</p><p id="3a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么经常使用版本范围:您指定您的依赖版本，但默认情况下接受较新的、较小的更新。所以我们可以放心地使用新的小更新，对不对？嗯，没有。</p><blockquote class="ms mt mu"><p id="c105" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">您可以像创建库的开发人员一样，确信小的更新不会破坏任何东西。一句忠告:不要。</p></blockquote><p id="dc56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，对于每次更新，您需要验证没有任何损坏。通过手动测试，任何项目都有可能不需要建立专门的架构和过程。但这是正确的解决方案吗？</p><p id="dfbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个中等规模的应用程序来说，每天列出和更新过时的依赖项已经是一件非常困难的事情了。添加手动测试是不现实的，你既没有时间去做，也不能避免每次都打破常规。</p><h1 id="b9fc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决办法</h1><p id="c4b8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个词:自动化。这是使这个过程不仅可以忍受，而且现实的唯一方法。</p><h2 id="c9fe" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">获取过期的依赖关系</h2><p id="7484" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先也是最重要的，我们需要定期获取需要更新的依赖项。已经有几个很好的解决方案，可以集成到GIT提供者中。</p><p id="6dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配置完成后，它们会为新的依赖项创建一个带有更新配置的拉请求。反过来，您可以选择将它们合并到您的主分支中。我在搜索过程中考虑了两个工具:<a class="ae ky" href="https://docs.renovatebot.com/" rel="noopener ugc nofollow" target="_blank"> renovatebot </a>和<a class="ae ky" href="https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/enabling-and-disabling-dependabot-version-updates" rel="noopener ugc nofollow" target="_blank">dependent bot</a>。</p><p id="e612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都是很好的工具，可以与多种语言一起工作。Dependabot的优势是可以直接集成到Github中。另一方面，renew可以与多个提供商合作。</p><p id="5154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的旅程是从GitLab开始的，所以我选择了renew，并继续这样做，即使我现在正在Github上使用它。如果您正在使用Github，请放心使用Dependabot！</p><h2 id="3f1c" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">固定依赖关系</h2><p id="b787" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在讨论依赖项更新的相关问题之前，我们先来讨论一下固定依赖项。Renovate发出的第一个拉请求是<strong class="lb iu">锁定</strong>您的依赖项:它是什么，为什么？</p><p id="d795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">renewal有一个很棒的部分是关于<a class="ae ky" href="https://docs.renovatebot.com/dependency-pinning/" rel="noopener ugc nofollow" target="_blank">版本范围和固定依赖</a>。固定依赖关系意味着使用依赖关系的精确版本，而不是范围。还记得我关于不要盲目信任正在创建库的开发人员的建议吗？</p><p id="df00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">我敢打赌，99.9%的读者在他们的旅途中都会遇到以下问题。</em></p><p id="7958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在一个项目上工作了一段时间，但是生活发生了，你把它搁置了，一切都工作得很好，并且保存在你最喜欢的GIT提供者上。几个月后，您克隆了您的存储库，并再次开始工作，但是请注意:您无法构建您的应用程序，某些东西已经坏了。</p><p id="9b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么会？这就是版本范围的危险。在某个时候，一个库创建者发布了一个错误的版本。也许这使它与另一个库不兼容，或者它不能与你的代码一起工作。</p><p id="1c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">版本范围是个好主意，理论上是<em class="mv"/>。请使用精确的版本，或者换句话说，固定您的依赖项。</p><h2 id="4e5c" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">避免破坏性的改变</h2><p id="fbf6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这一点上，我们应该理解并接受任何依赖关系更新<em class="mv">可能</em>破坏某些东西。</p><p id="0fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，更新一个依赖项与添加一个新特性没有什么不同。软件工程已经有了确保一切正常运行的技术，我个人使用的是:</p><ul class=""><li id="5e60" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">静态分析</li><li id="2e34" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">单元/集成测试</li><li id="8342" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">e2e测试</li><li id="6ae9" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">有时候，手工测试</li></ul><p id="8b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为依赖关系更新工具处理拉请求，所以运行检查/测试非常容易。这允许完整和快速的反馈:这个更新破坏了什么吗？此外，在<strong class="lb iu"> </strong>将任何东西合并到我们的主要工作之前，我们确保一切正常。</p><p id="3d40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这要归功于CI。在renew案例中，用名称<code class="fe or os ot ou b">renovate/&lt;dependency&gt;</code>创建分支。CI可以被配置为在那些特定的分支上自动运行语法检查、单元/集成或e2e测试。</p><p id="526e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，我们想要更多的信心，例如关于一个重要库的主要版本。可以部署应用程序，允许在需要时进行简单的手动测试。</p><p id="2e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数更新不需要手动测试，这意味着一切都可以自动化，甚至合并依赖更新！</p><div class="mz na gp gr nb nc"><a href="https://docs.renovatebot.com/configuration-options/#automerge" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">配置选项</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">本文档描述了您可以在更新配置文件中配置的所有配置选项。任何配置…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">docs.renovatebot.com</p></div></div><div class="nl l"><div class="ov l nn no np nl nq ks nc"/></div></div></a></div><p id="658d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没错，如果测试成功，大多数依赖项更新工具可以被配置为自动合并拉请求。当自动化测试不够时，对于最重要的库，或者对于开发工具，可以给出例外。</p><p id="8d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何保证<a class="ae ky" href="https://github.com/typicode/husky" rel="noopener ugc nofollow" target="_blank">哈士奇</a>的一个主要版本不坏你的配置？那么<a class="ae ky" href="https://github.com/conventional-changelog/commitlint" rel="noopener ugc nofollow" target="_blank">指挥官</a>呢？可以接受自动合并带来的风险，或者添加例外。</p><h2 id="367a" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">建议</h2><p id="6d19" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">将依赖项更新到最新版本并不一定会提高安全性和性能。</p><p id="cb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">偶尔，它会引入一个漏洞。如果你运气不好，构建系统的变化可能会给你的包增加很大一部分，从而降低性能。</p><p id="7dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是避免更新的理由:新版本可能会引起问题，旧版本会更糟。这意味着应该使用性能测试和安全工具。</p><p id="51d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<a class="ae ky" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank"> lighthouse </a>的多次运行之间的巨大差异可能表明存在性能问题。</p><p id="f32a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，定期运行<a class="ae ky" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"> snyk </a>是一个很好的安全实践。</p><h1 id="a50a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">实践中的相关性更新</h1><p id="5a86" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在写这几行的时候，我有几个托管的应用程序。他们是用React做的(用<a class="ae ky" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> CRA </a>、<a class="ae ky" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank">盖茨比</a>，或者<a class="ae ky" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">下一个</a>)、<a class="ae ky" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> React Native </a>、<a class="ae ky" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">Electron</a>(<a class="ae ky" href="https://www.electronforge.io/guides/framework-integration/react" rel="noopener ugc nofollow" target="_blank">React Forge+React</a>)。</p><p id="dd9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">都配置了renew，托管在Github上。我和<a class="ae ky" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>合作，因为它性能好，而且不太贵。CircleCI被配置为在所有的<code class="fe or os ot ou b">renovate/&lt;dependency&gt;</code>分支上运行测试，并将一切部署到测试环境中。</p><p id="191a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启用自动合并，运行以下测试，并在一切成功的情况下合并依赖项更新。对于我想在升级前手动验证的特定库，添加了一些例外。</p><h2 id="d577" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">单元测试和语法</h2><p id="2df7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">无论使用哪种技术，第一次测试总是相同的:</p><ul class=""><li id="a5f1" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">所有这些应用程序都是用打字稿制作的。我的第一个语法检查使用了带有<code class="fe or os ot ou b">--noEmit</code>标志的<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank"> tsc </a>，以及ESLint和Prettier。</li><li id="a5e1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">然后，我的单元/集成测试正在运行。这些都是感谢<a class="ae ky" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>写的。</li></ul><p id="219a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从一般的角度来看，过程的第二部分是相同的，但是技术堆栈不同。</p><h2 id="d69b" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">端到端</h2><p id="ea59" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于用CRA、盖茨比或Next编写的应用程序，<strong class="lb iu"> e2e测试</strong>多亏了<a class="ae ky" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>才能运行。</p><p id="e8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">柏树不能用于反应原生生物，并且不再支持电子。</p><p id="797a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择了React Native的<a class="ae ky" href="https://github.com/wix/Detox" rel="noopener ugc nofollow" target="_blank"> Detox </a>，因为根据我的经验，这是我最喜欢的。对于电子来说，<a class="ae ky" href="https://github.com/electron-userland/spectron" rel="noopener ugc nofollow" target="_blank"> Spectron </a>现在被弃用，但是<a class="ae ky" href="https://github.com/electron-userland/spectron/issues/1045" rel="noopener ugc nofollow" target="_blank">弃用公告</a>建议<a class="ae ky" href="https://playwright.dev/" rel="noopener ugc nofollow" target="_blank">编剧</a>。</p><p id="0357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都可以很容易地配置为在CircleCI上运行。React Native存在一个问题，它需要Android和IOS环境才能运行。</p><p id="d727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，CircleCI提供了<a class="ae ky" href="https://circleci.com/docs/2.0/android-machine-image/" rel="noopener ugc nofollow" target="_blank"> Android </a>和<a class="ae ky" href="https://circleci.com/docs/2.0/testing-ios/" rel="noopener ugc nofollow" target="_blank"> IOS </a>执行器。</p><p id="adb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我能够在正确的环境中运行我的所有测试，让我有足够的信心允许自动合并。</p><h2 id="e81e" class="of lw it bd lx og oh dn mb oi oj dp mf li ok ol mh lm om on mj lq oo op ml oq bi translated">部署</h2><p id="4778" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我需要在两种情况下访问我的应用程序的生产版本:</p><ul class=""><li id="b062" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">对于我的主分支，要有最终的结果。</li><li id="68cb" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">对于为更新特定依赖项而创建的分支(禁用自动合并)。</li></ul><p id="6f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我使用的技术，我使用不同的服务。</p><p id="c7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>是用CRA或盖茨比等制作的静态应用程序的一个很好的解决方案。它可以配置为部署您的主分支，以及针对您的主分支发出的所有拉请求。</p><p id="5148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，Netlify应该能够部署下一个应用程序，但实际上，它几乎不稳定。令人欣慰的是，<a class="ae ky" href="https://vercel.com/dashboard" rel="noopener ugc nofollow" target="_blank"> Vercel </a>提供了相同的功能，集中在Next。</p><p id="13a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于React Native，Android和IOS的应用程序构建在管道上，并作为工件上传。这允许我在需要时下载它们，并在我的设备上测试它们。</p><p id="a59a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，带有电子的应用程序也作为我们可以下载的神器上传。</p><h1 id="a904" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="1382" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，您已经了解了中型和大型应用程序如何保持它们的依赖关系是最新的。实用的解决方案应该可以帮助你设置它。</p><p id="7a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请随意分享您的想法以及您个人是如何处理这些问题的！</p></div></div>    
</body>
</html>