# 构建器设计模式轻松解决 JavaScript 中的 4 个危险问题

> 原文：<https://betterprogramming.pub/4-dangerous-problems-in-javascript-easily-solved-by-the-builder-design-pattern-7f0eb5b4455c>

## 用构建器模式建立您对代码的信心

![](img/fbac2f127b88896cc3c8a43d9177bfec.png)

*瑞安·昆塔尔在 Unsplash 上拍摄的照片*

当你用 JavaScript 开发应用程序时，你有时会发现很难构造复杂的对象。一旦它在你的代码中达到这一点，它就变得更加重要，因为随着你的应用程序变大，它会变得更加复杂。

这种复杂性有几种形式。一种可能是，当你试图创建某些对象的不同变体时，你的代码变得重复。

另一个可能是，试图创建这些对象的变体可能会变得很长，因为你必须在某个巨大的块中执行逻辑，就像在[类](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes)的[构造器](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor)块中一样。

本文将讨论这些问题，并向您展示 JavaScript 中的构建器设计模式将如何使这些问题变得不那么严重。

那么，builder 模式能*轻松*解决哪些问题呢？

让我们首先看一个没有构建器模式的示例*，然后看一个有*构建器模式的示例*，这样在我们进行的过程中，我不是唯一一个想到可视化代码示例的人。*

在下面的代码示例中，我们定义了一个`Frog`类。我们将假设，为了让`Frog`职业完全有能力在野外生存和冒险而不出问题，他们将需要*两只眼睛，所有的四条腿，一种气味，一条舌头和一颗心*。

现在，很明显，在现实世界中，有更多的东西牵涉其中，需要一种*气味*才能生存听起来很荒谬，但我们只会让它简单有趣，而不是对所有事情都完全真实。

我们可以在另一个时间的另一篇文章中得到 100%正确的事实。

# 如果没有生成器模式

# 使用构建器模式

现在，这似乎有点矫枉过正，因为构建器模式示例的代码更长。

但是，如果您更深入地研究在潜在的 frog 应用程序的开发过程中可能出现的所有情况，您将会看到，通过查看这两个示例，应用了 builder 模式的代码示例将会慢慢地提高简单性、可维护性，并为实现健壮的功能提供更多的机会。

以下是生成器设计模式在 JavaScript 中可以轻松解决的四个问题。

# 1.代码混乱和困惑

在开发大尺寸的功能块时，由于不小心而导致的错误和事故并不少见。另外，当单个块中有*太多事情在*进行的时候，就*容易搞混*。

那么，当函数块中有太多的事情发生时，你会陷入什么样的情况，比如*构造函数*？

回到我们的第一个代码示例，在没有生成器模式的情况下实现了*，让我们假设我们必须添加一些额外的逻辑来接受传入的参数，然后再将它们应用到实例:*

我们的构造函数有点长，在某些情况下，它甚至看起来不需要很多逻辑。处理不同参数的逻辑使它变得混乱。这可能会令人困惑，尤其是如果我们已经很久没有查看它的源代码了。

当我们开发一个 frog 应用程序并希望实例化一个`Frog`的实例时，缺点是我们必须确保每个参数都接近 100%完美，以符合函数签名或在构造阶段会抛出的东西。

如果我们需要在某个时候再次检查`eyes`的类型，我们将不得不扫描杂乱的代码以找到我们要找的代码。

如果您最终找到了您正在寻找的代码行，但随后意识到还有另一行代码引用并影响了仅 50 行以上的*相同的*参数，您会感到困惑吗？

现在你必须回过头去浏览这些，以便能够理解将会发生什么。

如果我们再看一下前面例子中的`FrogBuilder`构造函数，我们可以简化构造函数，让它看起来更自然，同时消除混淆。

我们仍然会做额外的验证，它只是被隔离到它们自己的小方法中，这是构建器模式的核心和灵魂。

# 2.可读性

如果我们看一下最近的代码示例，它已经变得有点难以阅读，因为我们必须同时处理这些不同的处理方式。

没有别的办法，如果我们想创建一个`Frog`的实例，只有立刻理解整个*的事情。*

此外，我们必须提供一些文档，否则我们不知道为什么`tongueWidth`要改名为`width`。这太荒谬了！

如果我们将示例转换为使用构建器模式，我们可以使内容更易于阅读:

我们获得了以几种方式使我们的代码更具可读性的能力:

## 1.这些方法的名字足够*不言自明*

`updateTongueWidthFieldName`很容易向我们解释它做了什么以及*为什么*它要这么做。

我们知道它在更新字段名。我们也知道*为什么是*，因为单词 *update* 已经意味着更新！这个自文档化的代码帮助我们假设一个字段名称是旧的，需要修改以使用新的字段名称。

## 2.构造函数简短而简化

稍后设置其他属性完全没问题！

## 3.启动新的 f `rog`时清楚了解每个参数

就像读英语一样。很明显你在设置眼睛，腿等。，最后调用 build 方法创建一个`Frog`。

## 4.每个逻辑现在都被隔离在单独的块中，我们可以很容易地理解

当你做一些改变时，你只需要关注一件事，那就是在功能块中被隔离的东西。

# 3.缺乏控制

这个列表中最重要的一个是受益于对实现的更多控制。

在构建器示例之前，可以在构造器中编写更多的代码，但是您尝试放入的代码越多，可读性就越差，从而导致混乱。

由于我们能够将实现细节隔离到它们各自的功能块，我们现在可以在许多方面进行更好的控制。

一种方法是我们可以在不增加更多问题的情况下添加验证，这使得构建阶段更加健壮:

我们利用了这样一个事实，即通过添加验证和一个`validate`方法来隔离构造函数的每个部分，以确保在最终构建`Frog`之前已经设置了所有必需的字段。

我们还可以利用这些开放的机会来添加更多的自定义输入数据类型，以构建参数的原始返回值。

例如，我们可以添加更多调用方可以传入`eyes`的自定义方式，为他们提供比我们之前提供的更加方便的方式:

这样，呼叫者可以更容易地选择他们想要的任何输入类型:

# 4.样板文件(通过模板解决)

我们将来可能会遇到的一个问题是，我们最终会得到一些重复的代码。

例如，回头看看我们的`Frog`类，你认为当我们想要创造某种类型的青蛙时，它们中的一些会有完全相同的特征吗？

在现实世界中，青蛙有不同的变种。例如，蟾蜍是青蛙的一种，但并不是所有的青蛙都是蟾蜍。所以，这告诉我们，蟾蜍有一些与众不同的特性，不应该属于正常的青蛙。

蟾蜍和青蛙的一个区别是，蟾蜍大部分时间呆在陆地上，而正常的青蛙大部分时间呆在水里。此外，蟾蜍也有干燥凹凸不平的皮肤，而正常青蛙的皮肤有点黏糊糊的。

这意味着我们必须确保每次青蛙被实例化时，*只有一些值*可以通过，而一些值*必须*通过。

让我们回到我们的`Frog`构造函数，添加两个新参数:`habitat`和`skin`:

对这个构造函数做两个简单的修改已经有点令人困惑了！这就是为什么建议使用构建器模式的原因。

如果我们把`habitat`和`skin`参数放在最后，可能会导致错误，因为`weight`和`height`可能是未定义的，因为它们都是可选的！

而且，由于它们是可选的，如果调用者没有传入它们，那么`habitat`和`skin`将被错误地用于它们。呀！

让我们编辑`FrogBuilder`以支持`habitat`和`skin`:

现在让我们假设我们需要创建两个不同的蟾蜍和一只正常的青蛙:

那么，这里面的重复代码在哪里呢？

如果我们仔细观察，会注意到我们必须重复 toad 的`habitat`和`skin`设置器。如果再有五只蟾蜍专用的塞特犬会怎样？每次创建蟾蜍时，我们都必须手动应用这个模板——对于普通的青蛙也是如此。

我们能做的是创建一个*模板*，按照惯例，它通常被称为*导演*。

导演负责执行创建对象的步骤——通常在构建最终对象时会有一些可以预先定义的公共结构，就像在这种情况下，我们的 *toad* 。

因此，我们可以让导演为我们生成模板，而不必手动设置蟾蜍之间的独特属性:

这样，您可以避免实现所有蟾蜍共有的样板文件，并且可以只关注您需要的属性。当有更多专属于蟾蜍的属性时，这变得更加有用。

# 结论

这就是这首曲子的结尾！我希望你发现这是有价值的，并期待在未来更多。