# 探索数据结构

> 原文：<https://betterprogramming.pub/explore-data-structures-e21b270077ad>

## 快速复习数组、队列、堆栈、字典、链表和树

![](img/44926d9f606fd813e616c90525d80ac6.png)

[法托斯 Bytyqi](https://unsplash.com/@fatosi?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/search/photos/code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

## **目录**

1.  [数组](https://medium.com/p/e21b270077ad#80a6)
2.  [队列](https://medium.com/p/e21b270077ad#a1d4)
3.  [堆栈](https://medium.com/p/e21b270077ad#46bb)
4.  [字典/哈希/对象](https://medium.com/p/e21b270077ad#7fe9)
5.  [链表](https://medium.com/p/e21b270077ad#c43e)
6.  [树木](https://medium.com/p/e21b270077ad#4813)
7.  [结论](https://medium.com/p/e21b270077ad#b6b7)

几乎我们编写的每个程序都需要某种形式的数据存储。这可能是一个姓名、人物或其他东西的列表。

通常，我们将数据集合存储在一个数组中。这通常也是人们引入的第一个数据结构，由于它的灵活性，它成为大多数开发人员使用的一种数据结构。

在本文中，我的目标是给出一些最常见的数据结构的介绍性理解。

正如你可能猜到的，*数据结构*是一种组织我们的数据如何被存储的方式，因此也是如何被访问的方式。

理解不同数据结构的优缺点是很重要的，因为它可以直接影响我们程序的效率，也有助于管理我们的控制流。

我将介绍几种不同的数据组织方式，解释我们何时何地想要使用/实现它们，并简要介绍它们的大 O 符号。

# 1.数组

鉴于它们的流行，从数组开始似乎是最自然的事情。

先说一个简单的定义，以后可以参考。一个*数组*是一个条目的索引集合。这些项通常属于相同的数据类型，但情况并非总是如此。

需要注意的重要一点是，并非所有语言都以相同的方式处理数组。在许多编程语言(例如 Java)中，数组指的是一个列表，其长度是固定的，并在创建时定义。

这意味着当你用 Java 创建一个新的数组时，你将指定你想要的数组长度。创建后，长度不可更改。

另一方面，JavaScript 和 [Ruby](https://www.ruby-lang.org/en/) 数组是动态数组。这意味着它们的数组长度不需要在创建时指定，而是根据需要调整大小。

这个的 Java 版本叫做`ArrayList`。

```
const arr = ['Harry', 'Larry', 'Barry'];
console.log(arr[0]); // => 'Harry'
console.log(arr[1]); // => 'Larry'
console.log(arr[2]); // => 'Barry'
```

## 数组的重要属性

1.  数组对任何索引值都有固定的时间访问。
2.  出于迭代的目的，项目按顺序存储。对上述数组的迭代将总是导致“Harry”在“Larry”之前被评估，依此类推。
3.  项目也按顺序插入。假设您的数组中还有剩余空间，该项将放在下一个可用的索引处。这个操作也是在恒定时间内完成的。
4.  默认情况下，数组是不排序的，但是可以通过不同的排序算法进行排序。

数组有很多优点，但它们最大的优点是易于实现。

大多数现代语言会让你快速创建一个新的数组。这是我们将在下面讨论的所有其他东西的一个巨大优势。

此外，数组相当简单。在不太了解数组或其用途的情况下，您也可以很好地使用数组。它们还需要更少的使用规划。

继续之前有一点很重要。上面的重点是线性数组，而不是多维数组。这很重要，尤其是对于不同排序算法的时间复杂度。

我还使用了一个保存字符串的数组示例。总的来说，我将给出构造原始数据类型的例子。但是，您应该知道几乎任何东西都可以存储在数组中，甚至是其他复杂的数据结构。

# 2.行列

*队列*是一种数据结构，它按照先进先出的原则工作。在 Ruby 和 JavaScript 这样的语言中，将队列表示为修改后的数组很有意义。

队列也是一个项目列表。唯一的区别是我们挑选了某些方法来约束它的行为。这就是为什么将队列表示为数组是有意义的，因为 Ruby 和 JavaScript 已经有了封装队列所需功能的数组方法。

这就是我们如何创建队列的示例:

我们现在可以创建一个新队列来组织我们的数据。我们的数据仍然是列表格式，和数组一样，但是这里有一些关键的区别。

注意我们精心挑选的方法。

`Enqueue`接受一个项目并将其插入数组的末尾。`Dequeue`从数组前面移除元素。这是创建队列的基本要求。其余的不是必需的，但可能有用。

## 队列的属性

1.  上面的实现是以数组为模型的。也就是说，它们在技术上是阵列，但是有“先进先出”的限制。
2.  通过将项目添加到队列的末尾，将它们排入队列。因为队列是使用数组建模的，所以入队是在恒定时间内完成的。
3.  上面的出列是通过从队列的前面移除元素来实现的。这要求我们将每个项目的索引下移一位。该过程在线性时间内执行。

当我们特别希望我们的数据遵循先进先出时，就使用队列。熟食柜台就是一个例子。我们希望第一个顾客买票，这样他们也是第一个被服务的顾客。

这是队列的完美任务。我们特别防止从除了队伍前面的任何地方被移走，因为我们不希望一个后来出现的顾客在第一个进来的顾客之前被服务。

然而，队列也有一些缺点。首先，他们的用例不像传统阵列那样经常出现。此外，实现会极大地影响性能。

上面的实现可以很好地工作，但是它不是最有效的实现。我们可以分摊我们的出列方法，这样我们就可以使用堆栈获得常量时间出列(很快会有更多相关内容)。

请注意这两个构造函数和出列方法之间的区别。

现在，我们的构造函数中有了一个堆栈，出列方法变得有点混乱，但总体而言，这个实现的性能明显更好。

下面是正在发生的事情的分类:

1.  首先，我们检查这个新的堆栈数组是否为空，这将是第一次调用`dequeue`。
2.  接下来，我们从队列中弹出每个元素，并将其推入堆栈。请注意，这意味着我们的堆栈与队列相反。
3.  然后，从堆栈中弹出一个元素。

第一次调用`dequeue`时，情况基本相同。我们弹出队列中的每个元素，并将其推入堆栈。

这仍然是一个线性时间操作。请注意，在堆栈为空之前，该方法只是弹出堆栈中的一个元素，这是在常数时间内完成的。

这给了我们的队列摊销常数时间出列。

# 3.大量

我们已经看到了提高出列方法效率的堆栈实现。

一个*栈*是一个数据结构，它在后进先出的原则下运行。

同样，我们拥有的是一个数组，其中有一些精选的方法来约束它的行为。栈是非常高效的，在插入和删除中总是提供恒定的时间访问。

如果我们回想一下，推入数组和弹出都是恒定的时间。

扫视是另一种对栈很流行的方法。它基本上可以让你看到堆栈中的下一个项目，而不需要实际移除它。

程序员无时无刻不在与堆栈进行交互。编程语言使用调用栈来处理指令。当调用方法时，第一个返回值对应于被调用的最后一个方法。

如果这种情况需要后进先出的方法，堆栈是一种非常有效的方法。

# 4.字典/散列/对象

这有很多不同的名字，取决于你使用哪种语言。

它们是一种抽象数据类型，依赖于键值对。

你可以把它们想象成数组，其中的键代替了索引，并且不限于数字。

下面是一个小实现:

```
const dog = {
 name: 'Fido',
 sex: 'M'
}
```

## 字典/哈希/对象的属性

1.  键是唯一的，但值不需要。
2.  如果传递了一个键，就有恒定的时间访问。
3.  键值对的顺序无关紧要。您可以交换键-值对的位置，或者姓名和性别，一切都会很好。

存储数据的一种常见方法是在对象数组中。这使您可以对更复杂的数据集合进行分组，而不仅仅是简单的原始数据类型。因此，我会优先学习数组和对象。

# 5.链接列表

到目前为止，所有的东西要么是数组，要么是用数组实现的。这是事情开始改变的地方。

一个*链表*是一个线性数据集，其中每个单独的数据片段指向另一个。

这是第一个不包含某种索引的数据结构。相反，每个项目都是按顺序排列的，您可以按顺序浏览列表中的每个项目。

乍一看，这似乎很奇怪，而且没有办法轻松地获取单个元素。然而，与数组相比，链表有一个主要的优势——与数组相比，你可以更有效地插入和删除列表的任何部分。

这是因为，不必重新创建一个新数组并复制值，您可以简单地更改每个数据块指向的位置。

上面提供了一个非常简单的实现。

注意，我们的节点保存了一段数据和一个指向列表中下一个条目的指针。我们在开始时将这个指针初始化为等于 null，因为自然地，一个单项式列表不会有指向第二项的指针。

然后，每当我们想要将一个项目添加到列表的末尾时，我们就重新分配它的下一个指针的值。这个新项目将再次拥有一些数据，以及一个被初始化为等于 null 的下一个指针。

这个过程可以无限期地继续下去。

上面，我还将 temp 赋值为等于列表中的一个新节点。这只是为了说明我们可以将链表中的节点保存到变量中，这有助于减少我们在遍历链表时需要调用`next`的次数。

链表会变得非常复杂。它们有几个缺点和问题，因此已经有了几个试图改进它们的尝试。

有双向链表、循环链表和多重链表。虽然每一个之间都有自然的差异，但它们都建立在这个初始实现的基础上。

让我们快速浏览一遍。

## 双向链表

双向链表通过保存一个指向前一个条目的指针和一个指向下一个条目的指针来帮助解决向后搜索的问题。

这提高了在链表上后退的性能，但是需要更多的空间来放置指针。

## 多重链表

多重链表更进了一步，有更多指向链表其他部分的指针。双向链表可以被看作是这种情况的一个特例，但是因为它们更常见，所以它们通常被赋予自己的类别。

可以说，当从列表的一部分移动到另一部分时，每个添加的额外链接都给了数据结构额外的速度。然而，这是以维护每个指针所需的额外空间为代价的。

## 循环链表

循环链表相当简单。顾名思义，列表中的最后一个条目指向列表中的第一个条目。

通常，你也可以将链表的功能封装在它自己的类中。然而，在本例中，我只是为节点创建了一个，并创建了它的实例来创建我的列表。

# 6.树

这是一个我们每天都在不知不觉中与之互动的问题。

一个*树*是一个节点的集合，其中每个节点都包含其数据和指向其子节点的指针。网站使用的文档对象模型是一棵树。

树有点复杂，所以让我们把它们分解一下:

1.  第一个节点被称为*根节点*。它很特殊，因为树上没有其他节点可以指向它。
2.  每个节点包含的数据可以是任何东西，就像链表一样。
3.  指向节点的指针不能重复，并且总是从父节点向下指向子节点。

和链表一样，树的核心是一个节点。这个节点和链表一样，包含一些数据和指向其子节点的指针。

一个关键的区别是子节点从不链接回父节点。

在链表的例子中，我们看到双向链表有指针，既指向链表中的下一项，也指向链表中的上一项。树木不会这样。

此外，只有父类可以直接指向其子类。假设，我们有一棵树，上面有三个节点。

我们可以收集到的信息是，创建的第一个节点是根节点。这意味着第二个节点必须是根节点的子节点。这也意味着第二个节点上的唯一指针是来自根节点的指针。

然而，第三个节点有一点灵活性。它也可以是根节点的子节点，在这种情况下，第三和第二个节点都是兄弟节点，因此不能相互指向对方。

当然，这也意味着指向第三个节点的指针将来自根节点。另一种选择是让第三个节点成为第二个节点的子节点。

在这种情况下，我们有一个类似于奇异链表的东西。根指向第二个，第二个指向第三个。

虽然树不一定是二叉树，也不需要排序，但它们的一些最大好处确实来自于排序。

排序二叉树允许一些真正有效的搜索、插入和删除。事实上，所有这三个操作都可以使用 AVL 树在`O(log n)`时间内完成。

这种有效的搜索是树的最大优点之一。树，很像链表，有各种各样的风格。这些味道中的许多都是为了平衡圣诞树，防止它倾斜。这些例子包括 AVL 树和红黑树。

最后，和链表一样，我在这里展示了一个非常简单的例子。通常情况下，你会有像插入和删除这样的独立方法，而不是像我在这里做的那样手工分配它们。

# 7.结论

有许多不同类型的数据结构。每种数据结构都提供了一种不同且独特的数据访问方式。

它们也有各种优点和缺点。如果您需要在数据列表的中心执行许多插入操作，那么链表可能比数组提供更好的性能。

另一方面，树可以提供非常有效的插入、删除和搜索——如果你愿意实现它们的话。

使用哪种方法最终取决于您和您的需求，但希望本文向您展示了数组和散列的几种替代方法。