<html>
<head>
<title>Create a Portable Makefile for Continuous Delivery With Hugo and GitHub Pages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Hugo和GitHub页面创建一个可移植的Makefile来连续交付</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-portable-makefile-for-continuous-delivery-with-hugo-and-github-pages-98aa44fe059b?source=collection_archive---------14-----------------------#2020-02-07">https://betterprogramming.pub/create-a-portable-makefile-for-continuous-delivery-with-hugo-and-github-pages-98aa44fe059b?source=collection_archive---------14-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4edb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建您的Hugo站点，优化图像，并运行您的CI/CD GitHub操作流程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/95fdfcd2b051ca6a6f461d95292b897d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*yv9Ne_tJG4rTVm25.png"/></div></figure><p id="1f6e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你了解我，你就会知道我喜欢自动化。我一直在使用AWS Lambda、Netlify和Travis CI的组合来自动构建和发布我的博客。我的任务工作流程包括:</p><ul class=""><li id="fcd6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">与雨果一起构建，按照Netlify和Lambda的计划推进</li><li id="ab9c" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">优化和调整图像大小(Netlify)</li><li id="7a39" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">使用<a class="ae lv" href="https://github.com/gjtorikian/html-proofer" rel="noopener ugc nofollow" target="_blank"> HTMLProofer </a>进行测试(Travis CI)</li><li id="cd7e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">部署到我的<a class="ae lv" href="https://victoria.dev/blog/two-ways-to-deploy-a-public-github-pages-site-from-a-private-hugo-repository/" rel="noopener ugc nofollow" target="_blank">单独的公共GitHub页面库</a> (Netlify)</li></ul><p id="1db0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">多亏了GitHub Actions的引入，我能够只用一个可移植的Makefile 就完成以上所有工作。</p><p id="1195" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">稍后，我将介绍我的动作设置；今天，我将带您了解我的Makefile的本质，以便您可以编写自己的Makefile。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d704" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Makefile可移植性</h1><p id="f47f" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated"><a class="ae lv" href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html" rel="noopener ugc nofollow" target="_blank">POSIX standard——flavor Make</a>可以在所有类似Unix的系统上运行。<a class="ae lv" href="https://en.wikipedia.org/wiki/Make_(software)#Derivatives" rel="noopener ugc nofollow" target="_blank"> Make衍生产品</a>，如<a class="ae lv" href="https://www.gnu.org/software/make/" rel="noopener ugc nofollow" target="_blank"> GNU Make </a>和几种风格的BSD Make，也运行在类Unix系统上，尽管它们的特定用途需要安装相应的程序。</p><p id="158e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了编写一个真正可移植的Makefile，我的遵循POSIX标准。(关于POSIX兼容makefile的更全面总结，我发现这篇文章很有帮助:<a class="ae lv" href="https://nullprogram.com/blog/2017/08/20/" rel="noopener ugc nofollow" target="_blank">关于可移植makefile的教程</a>。)</p><p id="930c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我运行Ubuntu，所以我用BSD Make程序<code class="fe nf ng nh ni b">bmake</code>、<code class="fe nf ng nh ni b">pmake</code>和<code class="fe nf ng nh ni b">fmake</code>测试了可移植性。因为shell命令不同，所以与非混合系统的兼容性稍微复杂一些。有了NMAKE这样的衍生工具，最好用适当的Windows命令编写一个单独的Makefile。</p><p id="e83c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">虽然我的许多特定用例可以通过shell脚本实现，但我发现Make提供了一些有价值的优势。当涉及到组织我的步骤时，我喜欢使用变量和<a class="ae lv" href="https://en.wikipedia.org/wiki/Make_(software)#Macros" rel="noopener ugc nofollow" target="_blank">宏</a>以及<a class="ae lv" href="https://en.wikipedia.org/wiki/Makefile#Rules" rel="noopener ugc nofollow" target="_blank">规则</a>的模块性。</p><p id="2c1e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">规则的编写主要归结于shell命令，这是Makefiles如此可移植的主要原因。最好的部分是你可以在终端中做几乎所有的事情——你当然可以处理上面列出的所有工作流程步骤。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="c2bb" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">我的连续部署(CD)生成文件</h1><p id="b9c5" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">这是处理我的工作流的可移植Makefile。是的，我在里面放了表情符号。我是个怪物。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cdc6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，该工作流:</p><ol class=""><li id="2885" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll nm ls lt lu bi translated">克隆公共<code class="fe nf ng nh ni b">Pages</code>存储库</li><li id="0bff" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nm ls lt lu bi translated">清除(删除)以前的生成文件</li><li id="d713" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nm ls lt lu bi translated">下载并安装指定版本的Hugo(如果Hugo尚未安装)</li><li id="5f73" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nm ls lt lu bi translated">构建网站</li><li id="de7e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nm ls lt lu bi translated">优化图像</li><li id="623f" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nm ls lt lu bi translated">用HTMLProofer测试生成的网站</li><li id="6718" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll nm ls lt lu bi translated">准备新的提交并将其推送到公共的<code class="fe nf ng nh ni b">Pages</code>存储库</li></ol><p id="f8f9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您熟悉命令行，这其中的大部分可能看起来很熟悉。这里有几个可能需要解释一下的地方。</p><h2 id="cc5b" class="nn mj it bd mk no np dn mo nq nr dp ms kz ns nt mu ld nu nv mw lh nw nx my ny bi translated">检查程序是否已经安装</h2><p id="4844" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">我认为这一点很整洁:</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="b7b9" class="nn mj it ni b gy od oe l of og">if ! [ -x "$$(command -v hugo)" ]; then\<br/>...<br/>fi</span></pre><p id="ea1d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我使用一个否定的<code class="fe nf ng nh ni b">if</code>条件和<code class="fe nf ng nh ni b">command -v</code>来检查是否存在一个名为<code class="fe nf ng nh ni b">hugo</code>的可执行文件(<code class="fe nf ng nh ni b">-x</code>)。</p><p id="ce41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果没有，脚本会获取指定版本的Hugo并安装它。<a class="ae lv" href="https://stackoverflow.com/a/677212" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出答案</a>很好地总结了为什么<code class="fe nf ng nh ni b">command -v</code>比<code class="fe nf ng nh ni b">which</code>更便于移植。</p><h2 id="9ee6" class="nn mj it bd mk no np dn mo nq nr dp ms kz ns nt mu ld nu nv mw lh nw nx my ny bi translated">图像优化</h2><p id="a0dd" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">我的Makefile使用<code class="fe nf ng nh ni b">mogrify</code>将调整大小和压缩后的图像批量放入特定的文件夹中。它会使用文件扩展名自动查找它们，并且只修改任何维度上大于1000px目标大小的图像。在这篇文章中，我写了更多关于<a class="ae lv" href="https://victoria.dev/blog/how-to-quickly-batch-resize-compress-and-convert-images-with-a-bash-one-liner/" rel="noopener ugc nofollow" target="_blank">批处理一行程序的内容。</a></p><p id="80a4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有几种不同的方法可以完成同样的任务，理论上，其中一种方法是利用Make的<a class="ae lv" href="https://en.wikipedia.org/wiki/Make_(software)#Suffix_rules" rel="noopener ugc nofollow" target="_blank">后缀规则</a>只对图像文件运行命令。我发现shell脚本可读性更好。</p><h2 id="d36c" class="nn mj it bd mk no np dn mo nq nr dp ms kz ns nt mu ld nu nv mw lh nw nx my ny bi translated">使用Dockerized HTMLProofer</h2><p id="be2c" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">HTMLProofer与<code class="fe nf ng nh ni b">gem</code>一起安装，并使用Ruby和<a class="ae lv" href="https://nokogiri.org/tutorials/ensuring_well_formed_markup.html" rel="noopener ugc nofollow" target="_blank"> Nokogiri </a>，这为CI工作流增加了大量的安装时间。</p><p id="5e39" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">谢天谢地，<a class="ae lv" href="https://github.com/18F" rel="noopener ugc nofollow" target="_blank"> 18F </a>有一个<a class="ae lv" href="https://github.com/18F/html-proofer-docker" rel="noopener ugc nofollow" target="_blank">dockered版本</a>，实现起来要快得多。它的使用需要启动容器，将构建的站点目录<a class="ae lv" href="https://docs.docker.com/storage/volumes/#start-a-container-with-a-volume" rel="noopener ugc nofollow" target="_blank">挂载为数据卷</a>，这可以通过将它附加到<code class="fe nf ng nh ni b">docker run</code>命令轻松实现。</p><pre class="kj kk kl km gt nz ni oa ob aw oc bi"><span id="3e06" class="nn mj it ni b gy od oe l of og">docker run -v /absolute/path/to/site/:/mounted-site 18fgsa/html-proofer /mounted-site</span></pre><p id="80ec" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我的Makefile中，我使用<a class="ae lv" href="https://help.github.com/en/articles/virtual-environments-for-github-actions#environment-variables" rel="noopener ugc nofollow" target="_blank">默认环境变量</a> <code class="fe nf ng nh ni b">GITHUB_WORKSPACE</code>指定了绝对站点路径。我将在另一篇文章中深入探讨这个和其他GitHub Actions特性。</p><p id="3000" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同时，祝你快乐！</p></div></div>    
</body>
</html>