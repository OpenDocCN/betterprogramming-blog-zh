<html>
<head>
<title>Why You Should Use a PUT Request Instead of a POST request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该使用PUT请求而不是POST请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-should-use-a-put-request-instead-of-a-post-request-13b593b6e67c?source=collection_archive---------2-----------------------#2021-11-05">https://betterprogramming.pub/why-you-should-use-a-put-request-instead-of-a-post-request-13b593b6e67c?source=collection_archive---------2-----------------------#2021-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c57f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以及如何在FastAPI中轻松创建一个</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3c1ea2a6d1b99030b4e088670d289e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MyBEMTz3Hmys_Jiy"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森派</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="a0ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题我已经收到十几次了:为什么用PUT请求而不是POST请求？</p><p id="27be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看完这篇文章，你就明白为什么了。您将使用FastAPI在Python中实现它，还将学习如何正确地测试它，以便在实践中能够自如地使用它。</p><h1 id="fb77" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">PUT和POST请求之间的区别</h1><p id="1f44" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们从解释PUT请求的关键特征开始:<strong class="js iu">幂等</strong>。</p><p id="84d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您多次调用put请求，将会导致相同的结果。所以，想象你创造了一种资源:一本书。如果您调用该方法两次，结果是相同的。更准确地说，数据库中有一本书。不是多个，是一个。</p><p id="971f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">POST请求则完全不同。如果您创建了一本书，然后又创建了同一本书，那么您将拥有多本书。换句话说，第二次，你会得到不同的结果。</p><p id="2207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两种方法各有优点。PUT请求便于防止副作用。</p><p id="61d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，为了让你更好地理解，让我来解释一个场景:Juliette点击一个按钮来购买一个三明治。因为网店有点慢，她又按了一次同一个按钮。同一请求到达服务器两次。因为您已经用put请求实现了该方法，所以它在第二次到达服务器时没有任何效果。你让朱丽叶不用吃双份餐，还帮她省钱。很棒，不是吗？</p><p id="3a27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多用例中，PUT请求对于防止不必要的更新非常重要。</p><p id="0e18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注</strong>:小心，即使使用PUT方法，仍然可能违反幂等性。如果您以与POST请求相同的方式实现PUT请求，那将是相同的，违反了PUT原则。作为API开发人员，您有责任创建一个有效的PUT请求。</p><h1 id="4657" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">如何创建卖出请求</h1><p id="f5ed" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，设置您的Python环境。为此，您需要一些库:FastAPI、uvicorn、pydantic和requests。请随意用你选择的工具安装它们——我个人最喜欢的是虚拟环境。</p><p id="25fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，您将从头开始构建PUT请求。我们从一个空的图书收藏开始，您将创建一本新书。我们在本教程中使用的数据类型非常简单:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="9fb7" class="mn lg it mj b gy mo mp l mq mr">class Book:<br/>  <strong class="mj iu">isbn</strong>: int<br/>  <strong class="mj iu">title</strong>: str</span></pre><p id="acda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时最好不要使用数据库，因为我们试图让事情变得简单。对于这样的更新，一个很好的数据结构是字典，我们将使用它。</p><p id="5a65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的PUT请求将创建一本新书。如果这本书不存在，它将为字典创建一个新的。如果这本书存在，它将取代整本书。PUT请求允许我们一次更新整个book对象。</p><p id="dc86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在FastAPI中，可能是这样的(取决于您的底层数据结构):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5843" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们回顾一下这里发生了什么。如果书已经存在，你替换它。如果书不存在，在执行这个方法后它将存在。最后，该方法返回我们添加到字典中的对象。</p><p id="fd6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很棒吧？</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="cdaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">POST方法的主要区别在于如何处理类似资源的更新。如果您用post方法进行同样的更新，并且惟一键已经存在于我的字典中，那么您最好抛出一个异常。</p><p id="1ea2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您的数据结构允许重复，您就不会在POST方法中抛出异常。每次调用POST方法时，您都会创建一本新书。这在某些情况下也是有意义的，例如，在卖书的时候。在这种情况下，您将允许多本书存在。</p><h1 id="2829" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">测试您的卖出请求</h1><p id="b5cc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">你正在阅读有关FastAPI的资料。FastAPI允许您编写简单的单元和集成测试。从测试开始总是很难，尤其是对于较新的框架。随着你对FastAPI越来越熟悉，你会发现你也可以做完全测试驱动的事情。</p><p id="ab76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你应该写的第一个测试是最重要的。当你创作一本不存在的书时，你的收藏中会有一本新书。代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="454b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们使用了字典，所以不允许相同的元素出现两次。这意味着为这个场景编写测试是没有用的。不过，还有一种情况需要考虑。如果您提供了对原书的更新，您应该会得到一本新书，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1caa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们还可以编写一个集成测试。集成测试最重要的部分是看我们是否用正确的主体得到200 OK响应。这个测试与用Postman调用我们的API是一样的，但是额外的价值是您可以自动化这个检查。代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="f9f2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="0128" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">阅读完本文后，您可以看到PUT方法创建了一个稳定的API。现在您理解了幂等的含义，并且能够自己实现PUT方法了。</p><p id="0308" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">FastAPI使我们创建PUT请求变得简单，这使得测试变得轻而易举。这个框架的简单性无人能敌。想继续学习FastAPI吗？我以前的关于<a class="ae le" href="https://medium.com/p/ecdc794b0cf" rel="noopener">获取</a>、<a class="ae le" href="https://medium.com/p/3dbd017dd998" rel="noopener">发布</a>和<a class="ae le" href="https://medium.com/p/b4577f9bcb77" rel="noopener">删除</a>方法的文章可能会有所帮助。也可以随意阅读这些文章。</p><p id="f7f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您阅读本文！</p></div></div>    
</body>
</html>