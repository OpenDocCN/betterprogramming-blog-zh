<html>
<head>
<title>The Complete Guide to OAuth 2.0 and OpenID Connect Protocols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OAuth 2.0和OpenID连接协议完全指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a?source=collection_archive---------1-----------------------#2020-06-01">https://betterprogramming.pub/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a?source=collection_archive---------1-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解最广泛使用的身份验证和授权协议是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3d46c0754d0062c427d322a85bf188d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qYZ161zVErqQ5NFp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jamesponddotco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹姆斯·庞德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="a23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都在网站和手机应用上看到过“登录谷歌”和“连接脸书”按钮。点击按钮，会打开一个屏幕，显示“此应用程序想要访问您的公开个人资料，联系人…”并询问您是否要授予访问权限。这是高层次的OAuth。理解这些协议对于每个软件工程师、安全专家甚至黑客来说都是至关重要的。</p><h2 id="628a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="b4fb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">OAuth 2.0和OpenID Connect的完整指南，这是当今互联网上最广泛使用的两种授权和认证协议。OAuth 2.0用于授权，OpenID Connect用于认证。有两种最常见的OAuth 2.0授权流，用于服务器端应用程序的授权代码流和用于基于浏览器的应用程序的隐式流。OpenID Connect是OAuth 2.0协议之上的身份层，使OAuth适用于身份验证用例。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="8992" class="na lw it bd lx nb nc nd ma ne nf ng md jz nh ka mg kc ni kd mj kf nj kg mm nk bi translated">为什么是OAuth？</h1><p id="b1bc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了理解OAuth诞生的原因，我们需要理解一个叫做委托授权的术语。</p><h2 id="a981" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">委托授权</h2><p id="d3b0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">委托授权是一种允许第三方应用程序访问用户数据的方法。</p><h2 id="eb3b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">委托授权的两种方法</h2><p id="c975" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">委托授权有两种方法，一种是您给第三方应用程序您的帐户密码，以便他们可以代表您登录您的帐户并访问您的数据<em class="nl">另一种是</em>您授权应用程序使用OAuth访问您的数据，而无需提供您的密码(我们谁也不会提供我们的密码！).</p><p id="913a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了OAuth的必要性和重要性，让我们更深入地研究这个协议。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="82c8" class="na lw it bd lx nb nc nd ma ne nf ng md jz nh ka mg kc ni kd mj kf nj kg mm nk bi translated">OAuth是什么？</h1><p id="fec3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">OAuth(开放授权)是委托授权的标准协议。它允许应用程序无需用户密码即可访问用户数据。</p><h2 id="443d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">OAuth 2.0术语</h2><p id="391c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">理解该协议需要我们理解其术语:</p><ul class=""><li id="6edd" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><strong class="lb iu">资源所有者:</strong>拥有客户端应用程序想要访问的数据的用户。</li><li id="27e1" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">客户端:</strong>希望访问用户数据的应用程序。</li><li id="e999" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">授权服务器:</strong>授权服务器通过授予用户权限来授权客户端访问用户的数据。</li><li id="9a15" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">资源服务器:</strong>保存客户端想要访问的数据的系统。在某些情况下，资源服务器和授权服务器是相同的。</li><li id="64c6" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">访问令牌:</strong>访问令牌是客户端可以用来访问资源服务器上用户授予的数据的唯一密钥。</li></ul><p id="cd2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看OAuth 2.0抽象流程中的术语:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b8c959d0e8ad61840d0ee938370dd076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sY_SVlcBpVDhqsFDwcdHTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="10d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">授权密钥/授权可以是代码或令牌类型。稍后我们将了解不同的授权许可。现在，我们来详细了解一下授权流程:</p><ol class=""><li id="6c9e" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu ob ns nt nu bi translated">用户开始授权流程，通常是通过点击一个按钮，如与谷歌或脸书或任何其他服务连接。</li><li id="5e74" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">然后，客户端将用户重定向到授权服务器。重定向时，客户端发送诸如客户端id和重定向URI之类的信息。</li><li id="4dd4" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">授权服务器处理用户身份验证，并显示同意屏幕，授予用户权限。如果你登录谷歌，你必须向谷歌提供你的登录凭证——即accounts.google.com而不是客户端。</li><li id="c282" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">如果用户授予权限，授权服务器会使用授权密钥(代码/令牌)将用户重定向到客户端。</li><li id="9dae" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">然后，客户机用包含的授权密钥请求资源服务器，要求资源服务器用用户的数据进行响应。</li><li id="26e2" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu ob ns nt nu bi translated">然后，资源服务器验证授权密钥，并用请求的数据响应客户端。</li></ol><p id="f0a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是用户如何让第三方应用程序访问他们的数据，而无需给他们密码。此时，会出现以下问题:</p><ul class=""><li id="c32b" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">我们如何限制客户机只能访问资源服务器上的部分数据？</li><li id="8338" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">如果我们希望客户端只读取我们的数据而不更改它，该怎么办？</li></ul><p id="281c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题将我们带到OAuth术语的另一个重要部分:作用域。</p><h2 id="3a7b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">OAuth中的作用域</h2><p id="1976" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">OAuth 2.0中的作用域用于限制应用程序对用户数据的访问。通过发布仅限于用户授权范围的授权许可。</p><p id="4745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当客户端向授权服务器请求授权时，它会发送一个作用域列表。授权服务器使用该范围列表来生成同意屏幕，并授予用户权限。如果用户同意同意屏幕，授权服务器发出仅限于用户授权范围的令牌或授权码。</p><p id="cd5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我授权一个客户端应用程序查看我的Google联系人列表，那么授权服务器发给客户端的令牌就不能用来删除我的联系人或查看我的日历事件——它的作用范围只是读取我的Google联系人。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="85cd" class="na lw it bd lx nb nc nd ma ne nf ng md jz nh ka mg kc ni kd mj kf nj kg mm nk bi translated">OAuth 2.0的设置</h1><p id="6920" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在进入OAuth流程之前，最好先了解一些OAuth配置。当授权许可请求启动时，客户端将一些配置数据作为查询参数发送给授权服务器。基本查询参数包括:</p><ul class=""><li id="bc4c" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe oc od oe of b">response_type</code>我们希望从授权服务器获得的响应类型。</li><li id="97f9" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">scope</code>客户端想要访问的作用域列表。授权服务器使用该列表为用户生成同意屏幕。</li><li id="bacd" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">client_id</code>由授权服务在为OAuth设置客户端时提供。这个ID有助于授权服务器确定启动OAuth流的客户端。</li><li id="cf21" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">redirect_uri</code>告诉授权服务器OAuth流完成后的去向。</li><li id="4eaf" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">client_secret</code>由授权服务提供。根据OAuth流程，该参数可能是必需的，也可能不是必需的。我们将在授权代码流中看到它的重要性。</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="fb47" class="na lw it bd lx nb nc nd ma ne nf ng md jz nh ka mg kc ni kd mj kf nj kg mm nk bi translated">了解不同的OAuth流</h1><p id="fd4c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">两个最常用的OAuth 2.0流是基于服务器的应用程序的授权代码流和纯JavaScript单页应用程序(SPAs)的隐式流。</p><p id="0c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释OAuth流程，我考虑将Google作为OAuth服务提供商。</p><h2 id="ce9a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">授权代码流</h2><p id="abff" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">授权代码流或授权代码授权是一个理想的OAuth流，它被认为是高度安全的，因为它使用前端通道(浏览器)和后端通道(服务器)来实现OAuth 2.0机制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/3d8ae9975cfe8b7e37aafc4e43c90dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOBSxYJi6onbvZDc1c6_gQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="650b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端通过将<code class="fe oc od oe of b">response_type</code>设置为<code class="fe oc od oe of b">code</code>将用户重定向到授权服务器来开始授权序列，这告诉授权服务器用授权码进行响应。该流量的URI如下所示:</p><pre class="kj kk kl km gt oh of oi oj aw ok bi"><span id="942a" class="lv lw it of b gy ol om l on oo"><a class="ae ky" href="https://accounts.google.com/o/oauth2/v2/auth?" rel="noopener ugc nofollow" target="_blank">https://accounts.google.com/o/oauth2/v2/auth?</a><br/> response_type=code&amp;<br/> client_id=your_client_id&amp;<br/> scope=profile%20contacts&amp;<br/> redirect_uri=https%3A//oauth2.example.com/code</span></pre><p id="f581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的请求中，客户端通过在请求的<code class="fe oc od oe of b">scope</code>参数中定义用户的公共配置文件和联系人来请求用户的许可。这个请求的结果是一个授权码，客户端可以用它来交换访问令牌。授权代码如下所示:</p><pre class="kj kk kl km gt oh of oi oj aw ok bi"><span id="855a" class="lv lw it of b gy ol om l on oo">4/W7q7P51a-iMsCeLvIaQc6bYrgtp9</span></pre><h2 id="9c70" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">为什么要用代码换令牌？</h2><p id="0e67" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">访问令牌是唯一可以用来访问资源服务器上的数据的东西，而不是应用程序代码。那么，当客户端实际上需要一个访问令牌时，为什么要将<code class="fe oc od oe of b">response_type</code>设置为<code class="fe oc od oe of b">code</code>？原因是为了使OAuth流高度安全。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/02a3f7f35360c7c4b95f46e4e82d60bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePkpjMPakMDAdO-NDg5D4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="72e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题:</strong>访问令牌是我们不希望有人访问的秘密信息。如果客户端直接请求访问令牌并将其存储在浏览器中，它可能会被窃取，因为浏览器并不完全安全。任何人都可以看到页面源代码，或者使用开发工具来获取访问令牌。</p><p id="7216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案:</strong>为了避免访问令牌在浏览器中暴露，客户端前端通道从授权服务器获取应用代码，然后将应用代码发送到客户端后端通道。现在要将这个应用程序代码换成一个访问令牌，需要一个叫做<code class="fe oc od oe of b">client_secret</code>的东西。只有客户端的后端通道知道<code class="fe oc od oe of b">client_secret</code>，然后后端通道向授权服务器发出POST请求，其中包含应用程序代码和客户端机密。该请求可能如下所示:</p><pre class="kj kk kl km gt oh of oi oj aw ok bi"><span id="d324" class="lv lw it of b gy ol om l on oo">POST /token HTTP/1.1<br/>Host: oauth2.googleapis.com<br/>Content-Type: application/x-www-form-urlencoded</span><span id="d1f5" class="lv lw it of b gy oq om l on oo">code=4/W7q7P51a-iMsCeLvIaQc6bYrgtp9&amp;<br/>client_id=your_client_id&amp;<br/>client_secret=your_client_secret_only_known_by_server&amp;<br/>redirect_uri=https%3A//oauth2.example.com/code</span></pre><p id="a381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">授权服务器验证客户端密码和应用程序代码，并使用访问令牌进行响应。后端通道存储访问令牌，并可能使用该令牌来访问资源服务器。这样，浏览器无法访问访问令牌。</p><h2 id="cf03" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">隐式流</h2><p id="7bbd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当您没有后端通道并且您的网站是一个只使用浏览器的静态网站时，使用OAuth 2.0隐式流。在这种情况下，当您将应用程序代码交换为访问令牌时，可以跳过反向通道上发生的最后一步。在隐式流中，授权服务器立即用一个访问令牌进行响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/48ceeb04f55be4d225d9b35da93292cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmULPvcojWyICSdxZ8h5mA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="5d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端将浏览器重定向到授权服务器URI，在<code class="fe oc od oe of b">response_type</code>设置为<code class="fe oc od oe of b">token</code>的情况下启动授权流程。授权服务器处理用户的登录和同意。请求的结果是一个访问令牌，客户端可以使用它来访问资源服务器。</p><p id="f6f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">隐式流被认为不太安全，因为浏览器负责管理访问令牌，所以它可能会被窃取。尽管如此，它还是被广泛用于单页应用程序。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="e480" class="na lw it bd lx nb nc nd ma ne nf ng md jz nh ka mg kc ni kd mj kf nj kg mm nk bi translated">身份验证与授权</h1><p id="a1ab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">众所周知，OAuth解决了委托授权问题，但是它没有提供一种标准的方法来认证用户。你可以这么说:</p><ul class=""><li id="8d0c" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><strong class="lb iu"> OAuth 2.0 </strong>用于授权。</li><li id="ca58" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu"> OpenID Connect </strong>用于认证。</li></ul><p id="8f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对这些术语感到困惑，下面是它们之间的区别:</p><ul class=""><li id="3b28" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><strong class="lb iu">认证</strong>是确保通信实体就是所声明的实体。</li><li id="4880" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">授权</strong>是验证通信实体是否有权访问资源的过程。</li></ul><p id="ddff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，认证关心你是谁，授权关心你有什么权限。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="a862" class="na lw it bd lx nb nc nd ma ne nf ng md jz nh ka mg kc ni kd mj kf nj kg mm nk bi translated">OpenID连接</h1><p id="cca1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">OpenID Connect是OAuth 2.0协议之上的身份层。它扩展了OAuth 2.0，使认证方式标准化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5dc46d95fcc217e21122496e213019fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*oFe0Jr3Y-s46834I4CI9YQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="11b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OAuth并不立即提供用户身份，而是提供一个用于授权的访问令牌。OpenID Connect使客户端能够根据授权服务器执行的身份验证来识别用户。这是通过在请求授权服务器进行用户登录和同意时定义一个名为<code class="fe oc od oe of b">openid</code>的范围来实现的。<code class="fe oc od oe of b">openid</code>是一个强制作用域，用来告诉授权服务器需要OpenID Connect。</p><p id="2a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端发出的OpenID Connect身份验证请求的URI如下所示:</p><pre class="kj kk kl km gt oh of oi oj aw ok bi"><span id="ba52" class="lv lw it of b gy ol om l on oo"><a class="ae ky" href="https://accounts.google.com/o/oauth2/v2/auth?" rel="noopener ugc nofollow" target="_blank">https://accounts.google.com/o/oauth2/v2/auth?</a><br/> response_type=code&amp;<br/> client_id=your_client_id&amp;<br/> scope=openid%20contacts&amp;<br/> redirect_uri=https%3A//oauth2.example.com/code</span></pre><p id="e460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求的结果是一个应用程序代码，客户端可以用它来交换访问令牌和ID令牌。如果OAuth流是隐式的，那么授权服务器立即用一个访问令牌和一个ID令牌进行响应。</p><p id="5dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ID令牌是一个JWT或JSON Web令牌。JWT是一种编码的令牌，由三部分组成:报头、有效负载和签名。获取ID令牌后，客户端可以对其进行解码，以获得编码在有效负载部分中的用户信息，如下所示:</p><pre class="kj kk kl km gt oh of oi oj aw ok bi"><span id="cf4a" class="lv lw it of b gy ol om l on oo">{<br/>  "iss": "https://accounts.google.com",<br/>  "sub": "10965150351106250715113082368",<br/>  "email": "johndoe@example.com",<br/>  "iat": 1516239022,<br/>  "exp": 1516242922<br/>}</span></pre><h2 id="143c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">要求</h2><p id="8d9a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">ID令牌的有效负载包含一些称为声明的字段。基本要求是:</p><ul class=""><li id="fd3b" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe oc od oe of b">iss</code>代币发行者。</li><li id="4d76" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">sub</code>用户的唯一标识符。</li><li id="f257" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">email</code>用户的邮箱。</li><li id="9735" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">iat</code>令牌发放时间表示为Unix时间。</li><li id="b0da" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe oc od oe of b">exp</code>以Unix时间表示的令牌到期时间。</li></ul><p id="6c32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，权利要求不限于这些领域。由授权服务器对声明进行编码。客户端可以使用这些信息对用户进行身份验证。</p><p id="2941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果客户机需要更多的用户信息，客户机可以指定标准的OpenID连接作用域，告诉授权服务器在ID令牌的有效负载中包含所需的信息。这些范围是<code class="fe oc od oe of b">profile</code>、<code class="fe oc od oe of b">email</code>、<code class="fe oc od oe of b">address</code>和<code class="fe oc od oe of b">phone</code>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="723e" class="na lw it bd lx nb nc nd ma ne nf ng md jz nh ka mg kc ni kd mj kf nj kg mm nk bi translated">结束注释</h1><p id="ada1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">实践所学总是好的。要使用OAuth 2.0范围、授权码和令牌，请访问<a class="ae ky" href="https://developers.google.com/oauthplayground/" rel="noopener ugc nofollow" target="_blank"> Google OAuth 2.0游乐场</a>。</p><p id="c0bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读到最后！如果觉得有用，请为故事鼓掌支持。</p></div></div>    
</body>
</html>