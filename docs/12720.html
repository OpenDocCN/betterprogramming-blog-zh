<html>
<head>
<title>Microservice — Tracing Log in the Distributed System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务——分布式系统中的跟踪日志</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/microservice-tracing-log-in-the-distributed-system-96f49bcb7bd?source=collection_archive---------0-----------------------#2022-06-26">https://betterprogramming.pub/microservice-tracing-log-in-the-distributed-system-96f49bcb7bd?source=collection_archive---------0-----------------------#2022-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="466f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Dotnet示例快速找出您的微服务中的日志相关性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2fddd2569cf9b3e6d340764bb05eec5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v9813htWvNiJ3PGD"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@martenbjork?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marten Bjork </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="79db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">日志可以帮助开发人员很快发现系统中的问题。</p><p id="b116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通常使用日志来确保当系统出现问题时问题能够得到解决。</p><p id="b253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在整体架构的系统中，跟踪日志很容易。</p><p id="6e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要求客户端(如app、浏览器或API invoker)在HTTP头中发送<code class="fe ls lt lu lv b">x-request-id</code>，并在每个日志行中记录<code class="fe ls lt lu lv b">x-request-id</code>。</p><p id="6cdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果系统是微服务架构，事情就完全不同了。</p><p id="eb5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不仅在每个服务中都通过了<code class="fe ls lt lu lv b">x-request-id</code>，而且需要将它带到下一个服务中。</p><p id="702c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，我们像ELK一样在日志收集系统中收集日志并搜索<code class="fe ls lt lu lv b">x-request-id</code>；我们可以获得整个用户操作日志序列，从A服务到B服务和C服务，所发生的一切都出现在你的监视器上。</p><p id="2cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务之间有许多集成方式，如web API、gRpc和消息队列。</p><p id="115a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是怎么做？怎么做呢？</p><p id="5bec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将演示Dotnet中的解决方案，并使用NLog包。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="7bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将把它分成两部分来解释解决方案:一部分是接收<code class="fe ls lt lu lv b">x-request-id</code>，另一部分是发送<code class="fe ls lt lu lv b">x-request-id</code>。</p><p id="4387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">粗略的流程是从某处获取请求ID，并将其放入<code class="fe ls lt lu lv b">HttpContext.TraceIdentifier</code>。</p><p id="f18e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们需要发送请求时，我们从<code class="fe ls lt lu lv b">HttpContext.TraceIdentifier</code>获取请求ID，并把它放在某个地方。</p><p id="6a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么我说在某个地方？因为不是每一种整合方式都有表头。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="959b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">接收请求ID</h1><p id="82a2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">当我们在HTTP头中收到x-request-id时，我们开始一个日志记录器范围，并将请求id放入<code class="fe ls lt lu lv b">HttpContext.TraceIdentifier</code>。</p><h2 id="bf7c" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">Web API</h2><p id="a9b9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">中间件注册的顺序非常重要。</p><p id="dcdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">RequestIdMiddleware</code>必须在<code class="fe ls lt lu lv b">WebApiLogginMiddleware</code>之前，这样日志中间件才能在日志记录器的范围内。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="8dbc" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">gRpc</h2><p id="d5c6" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">gRpc中接收和发送请求ID的方式可以存在于同一个类中，所以稍后在发送请求ID部分会解释这一点。</p><h2 id="eb9f" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">信息排队</h2><p id="2313" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们将请求ID放入消息的内容中，这样请求ID仍然可以在分布式系统中传递。</p><p id="143c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为不是每种消息队列都有可以放置请求ID的头，所以我们将请求ID放在内容中。</p><p id="a9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，因为消息队列的消费者不通过HTTP，所以方式也没有<code class="fe ls lt lu lv b">HttpContext</code>。</p><p id="b58d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您创建一个新的<code class="fe ls lt lu lv b">HttpConext</code>并将其放入<code class="fe ls lt lu lv b">IHttpContextAccessor</code>中，将会有所帮助。</p><p id="d472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从消息内容中获取请求ID，将其放入新的<code class="fe ls lt lu lv b">HttpContext</code>，并将值<code class="fe ls lt lu lv b">HttpContext</code>赋给<code class="fe ls lt lu lv b">IHttpContextAccessor</code>的实现。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8fff" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">发送请求ID</h1><p id="4db0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">发送请求ID比接收它更容易访问。</p><p id="0742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从<code class="fe ls lt lu lv b">HttpContext.TraceIdentifier</code>获取请求ID，并将其放入头中。</p><h2 id="2a6c" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">Web API</h2><p id="5576" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在web API调用中，我们使用<code class="fe ls lt lu lv b">DeletaingHandler</code>来发送请求ID。</p><p id="1737" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一需要注意的一点是<code class="fe ls lt lu lv b">HttpClientXRequestIdHandler</code>需要在DI容器中注册为Transient。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="6d80" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">gRpc</h2><p id="7dbc" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们在<code class="fe ls lt lu lv b">UnaryServerHandler</code>方法中从元数据接收请求ID，并将其放入<code class="fe ls lt lu lv b">HttpContext.TraceIdentifier</code>，这与Web API的逻辑相同。</p><p id="0f82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在发送请求ID的过程中，我们从<code class="fe ls lt lu lv b">HttpContext.TraceIdentifier</code>中获取请求ID，并将其放入元数据的头部。</p><p id="8cf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要发送请求ID，您必须在每个gRpc客户端中添加<code class="fe ls lt lu lv b">RequestIdGrpcInterceptor</code>。</p><p id="dfdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参见<code class="fe ls lt lu lv b">Program.cs</code>中的详细说明。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="341b" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">信息排队</h2><p id="0b94" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">只需从<code class="fe ls lt lu lv b">HttpContext.TraceIdentifier</code>获取请求ID，并将其放入消息内容中。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="5c08" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">在日志中打印请求ID</h1><p id="27ec" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们已经完成了每个服务中请求ID的接收和发送；下一步是在日志文件中打印请求ID。</p><p id="3c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下示例用于NLog配置。</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="8b11" class="na me iq lv b gy ns nt l nu nv">&lt;target xsi:type="File" name="info" fileName="logs/${shortdate}.info.log" layout="${longdate}|${mdlc:request}|${message}"/&gt;</span></pre><p id="e3d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打印请求ID的关键是日志渲染器<code class="fe ls lt lu lv b">mdlc:request</code>。</p><p id="2bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的日志目标标记中添加渲染器<code class="fe ls lt lu lv b">${mdle:requestid}</code>。</p><p id="bd99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意,“request”字符串需要与您在logger BeginScope中编写的相同。</p><p id="3cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关“mdlc”渲染器的更多信息，您可以参考该文档。<a class="ae kv" href="https://github.com/NLog/NLog/wiki/Mdlc-Layout-Renderer#net-core-logging" rel="noopener ugc nofollow" target="_blank">https://github . com/NLog/NLog/wiki/Mdlc-Layout-Renderer # net-core-logging</a>。</p><h1 id="a713" class="md me iq bd mf mg nw mi mj mk nx mm mn jw ny jx mp jz nz ka mr kc oa kd mt mu bi translated">结论</h1><p id="1473" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">随着服务越来越多，我们需要一个解决方案来快速确定整个系统之间的业务逻辑的操作顺序。</p><p id="ba72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向整个系统发送请求ID有助于跟踪日志。</p><p id="b490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以将用户ID发送给整个系统；它对每个服务中的允许列表或禁止列表都有帮助。</p><p id="a452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们收集整个系统的日志时，我们可能包含敏感数据，如身份号码、电话号码或银行账户等。</p><p id="25cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将演示如何屏蔽NLog包中的敏感数据。</p><p id="2acf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇文章能解决你的问题。</p></div></div>    
</body>
</html>