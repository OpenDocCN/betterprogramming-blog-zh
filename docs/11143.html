<html>
<head>
<title>3 Things You Might Not Know About PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于PostgreSQL你可能不知道的3件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-things-you-might-not-know-about-postgresql-1805cc85bf42?source=collection_archive---------16-----------------------#2022-02-21">https://betterprogramming.pub/3-things-you-might-not-know-about-postgresql-1805cc85bf42?source=collection_archive---------16-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="201a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">增进您对流行数据库的了解</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/349be7d84371f61f69b4cdb34411e566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xog2B4NQc3nraoTHR2qtmw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@katerina-holmes?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Katerina Holmes </a>从<a class="ae ky" href="https://www.pexels.com/photo/black-boy-watching-video-on-laptop-5905700/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="f0ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PostgreSQL是遵循SQL规范的流行关系数据库。自1996年首次发布以来，它一直吸引着许多数字企业和开发者。作为一个开源项目，每个人都可以浏览代码并为之做出贡献。它表现出良好的性能，其基准测试能够与其他数据库竞争，如MySQL、SQL Server和Oracle数据库。</p><p id="5f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL查询在所有数据库管理系统中都是标准化的。他们可能有一些细微的差别，但这并不重要。工程师们更感兴趣的是，Postgres不仅仅是存储数据。这可以给团队带来一些关于他们工作的信息的见解。</p><h1 id="8eb0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">获取任何东西的大小</h1><p id="3a13" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当您的系统在大规模上运行时，您会很想知道您收集了多大规模的数据。我们希望了解数据库、特定表甚至某一列的大小。此类信息对于了解空间是否得到有效利用以及预测任何结垢事件非常有价值。</p><p id="9e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Postgres提供了一组与大小相关的命令。例如，要获得整个数据库的大小，我们可以使用命令<code class="fe ms mt mu mv b">pg_database_size()</code>。它将以字节为单位打印出特定数据库的大小。命令<code class="fe ms mt mu mv b">pg_table_size()</code>显示当前数据库中某个表的字节大小，不包括索引。命令<code class="fe ms mt mu mv b">pg_total_relation_size()</code>几乎做了同样的事情，但是包括索引所需的空间。如果我们想知道混凝土柱需要多少空间，我们可以使用命令<code class="fe ms mt mu mv b">pg_column_size()</code>。</p><p id="b37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行这些命令，我们需要通过在终端运行<code class="fe ms mt mu mv b">psql</code>进入Postgres控制台。我们也可以使用第三方工具，如Jetbrains的DataGrip或类似工具。一旦我们进入控制台，我们就可以运行SQL查询和这些命令。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="06d0" class="na lw it mv b gy nb nc l nd ne">SELECT pg_database_size('my_database');</span></pre><p id="c874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的查询打印出以下输出。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5e72" class="na lw it mv b gy nb nc l nd ne"> pg_database_size<br/>------------------<br/>          8258415</span></pre><p id="e3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你不愿意把字节转换成KB或MB时，有一个专用的命令。用命令<code class="fe ms mt mu mv b">pg_size_pretty()</code>包装尺寸可以进行可读的格式化。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e465" class="na lw it mv b gy nb nc l nd ne">SELECT pg_size_pretty(pg_database_size('my_database'));</span><span id="92b6" class="na lw it mv b gy nf nc l nd ne"> pg_size_pretty<br/>----------------<br/> 8065 kB</span></pre><p id="c4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些命令的完整列表可以在足够有表现力的官方文档中找到。</p><h1 id="44cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">获取统计数据</h1><p id="4956" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Postgres有一个收集不同统计数据的内置系统。这些统计数据可以包括对某些表的访问次数、最近的查询、特定数据库中由查询修改的数据的数量。这些统计数据可能不是每天都能看到的。然而，在分析数据库的性能和发现见解时，这是第一个要考虑的地方。</p><p id="5a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着统计数据的收集，我们需要做的一切只是查询它。我们可以编写一个常规的SQL查询来获取特定的信息。例如，让我们获取数据库中每个表插入、更新和删除的行数。该信息出现在视图<code class="fe ms mt mu mv b">pg_stat_user_tables</code>中。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="63be" class="na lw it mv b gy nb nc l nd ne">SELECT relname, n_tup_ins, n_tup_upd, n_tup_del FROM pg_stat_user_tables;</span></pre><p id="cd8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的查询返回当前数据库中每个表的插入、更新和删除行的列表。在我的例子中，输出如下所示。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="79ea" class="na lw it mv b gy nb nc l nd ne"> relname     | n_tup_ins | n_tup_upd | n_tup_del<br/>-------------+-----------+-----------+-----------<br/> users       |        51 |         0 |         0<br/> payments    |       128 |         6 |         0<br/> profiles    |       139 |         0 |         0<br/> guides      |       801 |         0 |         8</span></pre><p id="a719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，当常规SQL对我不起作用时，我不得不使用它一次。我面临的挑战是计算表中用户的数量。这个故事是巨大的，超过了几个亿。因此，语句<code class="fe ms mt mu mv b">COUNT</code>永久超时。谢天谢地，使用统计视图成为可能。以下查询从我的数据库中返回Users表的估计行数。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d1a9" class="na lw it mv b gy nb nc l nd ne">SELECT n_live_tup FROM pg_stat_user_tables WHERE relname = 'users';</span></pre><p id="3c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">n_live_tup</code>表示数据库中每个表的估计行数，<code class="fe ms mt mu mv b">relname</code>显示每个表的名称。视图<code class="fe ms mt mu mv b">pg_stat_user_tables</code>包含关于用户表的数据，不包括任何系统表。</p><p id="5564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下视图中找到最有趣的统计数据:</p><ul class=""><li id="006d" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe ms mt mu mv b">pg_stat_database</code> -数据库范围统计；</li><li id="23de" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe ms mt mu mv b">pg_stat_all_tables</code> -统计当前数据库中的所有表格；</li><li id="c8e4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe ms mt mu mv b">pg_stat_activity</code> -与查询和流程相关的统计；</li></ul><p id="5ee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有视图及其栏目的完整列表可在<a class="ae ky" href="https://www.postgresql.org/docs/9.3/monitoring-stats.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到。请查看它，了解您的数据库的性能。</p><h1 id="1b79" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">了解查询如何执行</h1><p id="d0fa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你有没有问过自己运行一个查询需要什么？有多少行将受到影响？运行该查询的成本是多少？SQL有一个非常强大的命令<code class="fe ms mt mu mv b">EXPLAIN</code>，Postgres和其他数据库都支持这个命令。它是如何工作的？</p><p id="c29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行语句<code class="fe ms mt mu mv b">EXPLAIN</code>时，它检查下面的查询。它将检查运行它的所有操作，如顺序扫描、索引和位图索引扫描。当查询更复杂(包括连接)时，将会执行更多的扫描。在这种情况下，命令<code class="fe ms mt mu mv b">EXPLAIN</code>记录所有这些信息，并为显示做准备。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6659" class="na lw it mv b gy nb nc l nd ne"> EXPLAIN SELECT * FROM users;<br/>                          QUERY PLAN<br/>--------------------------------------------------------------<br/> Seq Scan on users  (cost=0.00..10.50 rows=50 width=1388)</span></pre><p id="9dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们分析了简单的<code class="fe ms mt mu mv b">SELECT</code>查询，从Users表中检索所有记录。我们看到的结果是<em class="nu">查询计划</em>。它只包含一个条目，是对Users表的顺序扫描。除此之外，我们还能够看到运行查询的估计成本、返回的行数以及行的平均宽度。</p><p id="affa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在复杂查询中进行故障排除和识别瓶颈时，这个命令非常有用。可以得到详细的查询计划，轻松发现有问题的语句。由于它在许多其他数据库中可用，它成为每个软件工程师的一个非常有用的工具。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="af73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PostgreSQL有一些隐藏的宝石。了解它们可以给工程团队带来好处。他们将能够实现其解决方案的最佳性能，并让客户满意。</p></div></div>    
</body>
</html>