<html>
<head>
<title>The TICK Stack as a Docker Application Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为Docker应用程序包的TICK堆栈</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-tick-stack-as-a-docker-application-package-1d0d6b869211?source=collection_archive---------0-----------------------#2018-10-08">https://betterprogramming.pub/the-tick-stack-as-a-docker-application-package-1d0d6b869211?source=collection_archive---------0-----------------------#2018-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="591e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TL；速度三角形定位法(dead reckoning)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/849f1f7c077dfb17d05a6fdd0dcef18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suQarOhWeCNL3VQojarQcA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tirzavandijk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Tirza van Dijk </a>在<a class="ae ky" href="https://unsplash.com/search/photos/application?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>应用包是DockerCon SF 2018上展示的实用程序。它简化了Docker合成应用程序的打包和分发。TICK stack是一个很好的例子来说明这实际上是如何工作的。</p><h2 id="f2ff" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">关于TICK堆栈</h2><p id="cffe" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个应用程序堆栈主要用于处理时序数据。这使得它成为物联网项目的绝佳选择，在物联网项目中，设备会发送数据(温度、天气指标、水位等。)定期。</p><p id="14f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的名字TICK来自于它的组成部分:</p><ul class=""><li id="3233" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">Telegraf</li><li id="0059" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">InfluxDB</li><li id="4636" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Chronograf</li><li id="3d5d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Kapacitor</li></ul><p id="568d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的模式说明了整体架构，并概述了每个组件的角色。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/df643f924640c8a86b0d3905caed68ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7uRhGM_vOXFxT7kdqwNfw.png"/></div></div></figure><p id="5ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，数据被发送到Telegraph，然后存储在InfluxDB数据库中。Chronograf允许通过一个漂亮的网络界面查询数据库。Kapacitor可以根据数据进行处理、监控和发出警报。</p><h2 id="4d2b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">合成文件中的简单定义</h2><p id="2074" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下面的<code class="fe ni nj nk nl b">tick.yml</code>文件定义了堆栈的四个组件以及它们相互通信的方式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="940f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TK不认为我们有媒体格式的问题了吗？注意:如果您复制/粘贴该文件的内容，您必须将'—'更改为常规的连字符'-'。(此处为中等格式问题)。</p><p id="70c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TK留下了要点和灰线代码——请告知哪个是正确的。Telegraf的配置是通过Docker Config对象提供的，该对象是由下面的<code class="fe ni nj nk nl b">telegraf.conf </code>文件创建的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="2063" class="lv lw it nl b gy ns nt l nu nv">[agent]<br/>  interval = "5s"<br/>  round_interval = true<br/>  metric_batch_size = 1000<br/>  metric_buffer_limit = 10000<br/>  collection_jitter = "0s"<br/>  flush_interval = "5s"<br/>  flush_jitter = "0s"<br/>  precision = ""<br/>  debug = false<br/>  quiet = false<br/>  logfile = ""<br/>  hostname = "$HOSTNAME"<br/>  omit_hostname = false</span><span id="d4d6" class="lv lw it nl b gy nw nt l nu nv">[[outputs.influxdb]]<br/>  urls = ["http://influxdb:8086"]<br/>  database = "test"<br/>  username = ""<br/>  password = ""<br/>  retention_policy = ""<br/>  write_consistency = "any"<br/>  timeout = "5s"</span><span id="4b2e" class="lv lw it nl b gy nw nt l nu nv">[[inputs.http_listener]]<br/>  service_address = ":8186"</span><span id="94cc" class="lv lw it nl b gy nw nt l nu nv">[cpu]<br/>  # Whether to report per-cpu stats or not<br/>  percpu = true<br/>  # Whether to report total system cpu stats or not<br/>  totalcpu = true</span></pre><p id="87d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会太深入这个文件的细节，但基本上它:</p><ul class=""><li id="d781" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">定义定期收集主机CPU指标的代理。</li><li id="d798" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">定义一个附加的输入方法，允许Telegraf通过HTTP端点接收数据。</li><li id="bb90" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">指定收集/接收的数据应该存储在名为<code class="fe ni nj nk nl b">test</code> <em class="nx">的数据库中。</em></li></ul><h1 id="dd33" class="ny lw it bd lx nz oa ob ma oc od oe md jz of ka mg kc og kd mj kf oh kg mm oi bi translated">Docker应用程序包</h1><h2 id="7fcf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">安装(在MacOS上)</strong></h2><p id="38fe" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">以下命令允许您安装Docker应用程序包的最新版本(<code class="fe ni nj nk nl b">docker-app</code> Go二进制文件)</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="d8c9" class="lv lw it nl b gy ns nt l nu nv"># Install release 0.6.0 (published on October 4th)<br/>VERSION="v0.6.0"<br/>wget --no-check-certificate https://github.com/docker/app/releases/download/$VERSION/docker-app-darwin.tar.gz<br/>tar xf docker-app-darwin.tar.gz<br/>cp docker-app-darwin /usr/local/bin/docker-app</span></pre><p id="4df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们检查一切正常。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="08bd" class="lv lw it nl b gy ns nt l nu nv"># Check version<br/><strong class="nl iu">$ docker-app version</strong><br/>Version:      v0.6.0<br/>Git commit:   9f9c6680<br/>Built:        Thu Oct  4 13:30:33 2018<br/>OS/Arch:      darwin/amd64<br/>Experimental: off<br/>Renderers:    none</span></pre><h2 id="98c3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">可用命令</h2><p id="3e53" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">仅供参考，下面的截图列出了<code class="fe ni nj nk nl b">docker-app</code> CLI提供的所有命令。我们将在本文的后面举例说明其中的一些。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/184eb425f1321722728b01a4e9e50faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1s9drrzJnLWlA9zMXlTMQ.png"/></div></div></figure><h2 id="8cde" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">为TICK堆栈创建Docker应用程序包</strong></h2><p id="b879" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们从一个只包含上面定义的<code class="fe ni nj nk nl b">Compose</code>和<code class="fe ni nj nk nl b">configuration</code>文件的文件夹开始。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="40e4" class="lv lw it nl b gy ns nt l nu nv">$ tree .<br/>.<br/>├── telegraf.conf<br/>└── tick.yml</span></pre><p id="8a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用以下命令创建名为“tick”的Docker应用程序:</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="2a6c" class="lv lw it nl b gy ns nt l nu nv">$ docker-app init -c tick.yml tick</span></pre><p id="451b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了文件夹<code class="fe ni nj nk nl b">tick.dockerapp</code>，和三个附加文件。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="2469" class="lv lw it nl b gy ns nt l nu nv">$ tree .<br/>.<br/>├── telegraf.conf<br/>├── <strong class="nl iu">tick.dockerapp<br/></strong>│ ├── <strong class="nl iu">docker-compose.yml</strong><br/>│ ├── <strong class="nl iu">metadata.yml</strong><br/>│ └── <strong class="nl iu">settings.yml</strong><br/>└── tick.yml</span></pre><ul class=""><li id="38dc" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe ni nj nk nl b">docker-compose.yml</code>是<code class="fe ni nj nk nl b">tick.yml</code>文件的副本</li><li id="c6de" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe ni nj nk nl b">metadata.yml</code>定义了额外的参数，如下所示。我刚刚更改了名称空间，以匹配发布应用程序时将使用的Docker Hub帐户。</li></ul><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="8412" class="lv lw it nl b gy ns nt l nu nv">$ cat tick.dockerapp/metadata.yml<br/># Version of the application<br/>version: 0.1.0<br/># Name of the application<br/>name: tick<br/># A short description of the application<br/>description:<br/># Namespace to use when pushing to a registry. This is typically your Hub username.<br/>namespace: lucj<br/># List of application maintainers with name and email for each<br/>maintainers:<br/> — name: luc<br/>   email:</span></pre><ul class=""><li id="b8d8" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe ni nj nk nl b">settings.yml</code>定义应用程序使用的默认参数(稍后会详细介绍)。默认情况下，该文件为空。</li></ul><p id="4b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:初始化Docker应用程序时，可以使用<code class="fe ni nj nk nl b">-s</code>标志。这将导致创建一个包含上述三个文件内容的文件，而不是文件夹/文件层次结构。</p><p id="ce3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">定义开发和生产环境的设置</strong></p><p id="b59c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们上面所说的，<code class="fe ni nj nk nl b">settings.yml</code>文件的目的是为应用程序提供一些默认值。但是，等等…哪些参数的默认值，因为我们没有指定任何参数？这实际上是Docker应用程序包的主要功能之一——可以针对不同的环境使用不同的设置。</p><p id="b5ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个dev和一个prod环境，并假设这两个环境只有在应用程序向外界公开端口时有所不同:</p><ul class=""><li id="103c" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">Telegraf在dev中监听端口8000，在prod中监听端口9000。</li><li id="9275" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Chronograf监听dev中的端口8001和prod中的端口9001。</li></ul><p id="c46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:当然，在现实世界的应用程序中，dev和prod之间的差异不仅限于端口号。目前的例子过于简化，所以更容易掌握主要概念。</p><p id="3dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将首先为每个环境创建一个设置文件，然后我们将修改<code class="fe ni nj nk nl b">docker-compose.yml</code>文件以添加一些占位符。</p><p id="1637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">settings.yml</code>文件用于为Telegraf和Chronograf服务定义一些默认端口。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="9539" class="lv lw it nl b gy ns nt l nu nv">// settings.yml<br/>ports:<br/>  telegraf: 8186<br/>  chronograf: 8888</span></pre><p id="c2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还定义了<code class="fe ni nj nk nl b">dev.yml</code>来为开发环境指定不同的值，</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="4d68" class="lv lw it nl b gy ns nt l nu nv">// dev.yml<br/>ports:<br/>  telegraf: 8000<br/>  chronograf: 8001</span></pre><p id="b922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe ni nj nk nl b">prod.yml</code>，用于生产环境。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="b983" class="lv lw it nl b gy ns nt l nu nv">// prod.yml<br/>ports:<br/>  telegraf: 9000<br/>  chronograf: 9001</span></pre><p id="856f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们修改<code class="fe ni nj nk nl b">docker-compose.yml</code>文件，并更改Telegraf和Chronograf的已发布端口，以便它们使用上述文件中定义的变量。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="e34d" class="lv lw it nl b gy ns nt l nu nv">$ cat tick.dockerapp/docker-compose.yml<br/>version: "3.6"<br/>services:<br/>  telegraf:<br/>    image: telegraf<br/>    configs:<br/>    — source: telegraf-conf<br/>      target: /etc/telegraf/telegraf.conf<br/>    ports:<br/>    — <strong class="nl iu">${ports.telegraf}</strong>:8186<br/>  influxdb:<br/>    image: influxdb<br/>  chronograf:<br/>    image: chronograf<br/>    ports:<br/>    — <strong class="nl iu">${ports.chronograf}</strong>:8888<br/>    command: ["chronograf", "--influxdb-url=http://influxdb:8086"]<br/>  kapacitor:<br/>    image: kapacitor<br/>    environment:<br/>    — KAPACITOR_INFLUXDB_0_URLS_0=http://influxdb:8086<br/>configs:<br/>  telegraf-conf:<br/>    file: ./telegraf.conf</span></pre><p id="ebbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上面的更改中看到的，访问Telegraf端口号的方法是使用<code class="fe ni nj nk nl b">ports.telegraf</code>符号。Chronograf港也是如此。</p><p id="34f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">render</code>命令允许生成Docker合成文件，用指定的设置文件内容替换变量<code class="fe ni nj nk nl b">${ports.XXX}</code>。如果没有指定，则使用默认的<code class="fe ni nj nk nl b">settings.yml</code>。正如我们在下面看到的，Telegraf端口现在是8186，Chronograf端口是8888。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="e830" class="lv lw it nl b gy ns nt l nu nv">$ docker-app render<br/>version: "3.6"<br/>services:<br/>  chronograf:<br/>    command:<br/>    — chronograf<br/>    — --influxdb-url=http://influxdb:8086<br/>    image: chronograf<br/>    ports:<br/>    — mode: ingress<br/>      target: 8888<br/>      published: <strong class="nl iu">8888</strong><br/>      protocol: tcp<br/>  influxdb:<br/>    image: influxdb<br/>  kapacitor:<br/>    environment:<br/>      KAPACITOR_INFLUXDB_0_URLS_0: http://influxdb:8086<br/>    image: kapacitor<br/>  telegraf:<br/>    configs:<br/>    — source: telegraf-conf<br/>      target: /etc/telegraf/telegraf.conf<br/>    image: telegraf<br/>    ports:<br/>    — mode: ingress<br/>      target: 8186<br/>      published: <strong class="nl iu">8186</strong><br/>      protocol: tcp<br/>configs:<br/>  telegraf-conf:<br/>    file: telegraf.conf</span></pre><p id="e5b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在<code class="fe ni nj nk nl b">render</code>命令中指定一个设置文件，则使用该文件中的值。正如我们在下面的例子中看到的，如果我们在渲染过程中使用<code class="fe ni nj nk nl b">dev.yml</code>，Telegraf在端口8000上发布，Chronograf在端口8001上发布。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="1c8b" class="lv lw it nl b gy ns nt l nu nv">$ docker-app render -f dev.yml<br/>version: "3.6"<br/>services:<br/>  chronograf:<br/>    command:<br/>    — chronograf<br/>    —-influxdb-url=http://influxdb:8086<br/>    image: chronograf<br/>    ports:<br/>    — mode: ingress<br/>      target: 8888<br/>      published: <strong class="nl iu">8001</strong><br/>      protocol: tcp<br/>  influxdb:<br/>    image: influxdb<br/>  kapacitor:<br/>    environment:<br/>      KAPACITOR_INFLUXDB_0_URLS_0: http://influxdb:8086<br/>    image: kapacitor<br/>  telegraf:<br/>    configs:<br/>    — source: telegraf-conf<br/>      target: /etc/telegraf/telegraf.conf<br/>    image: telegraf<br/>    ports:<br/>    — mode: ingress<br/>      target: 8186<br/>      published: <strong class="nl iu">8000</strong><br/>      protocol: tcp<br/>configs:<br/>  telegraf-conf:<br/>    file: telegraf.conf</span></pre><h2 id="1227" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">检查应用程序</h2><p id="a412" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">正如我们在下面看到的，<code class="fe ni nj nk nl b">inspect</code>命令提供了与应用程序相关的所有信息:</p><ul class=""><li id="f9a3" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">它的元数据。</li><li id="c7dd" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">涉及的服务(包括定义的副本数量、公开的端口和使用的映像)。</li><li id="b764" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">使用的设置。</li><li id="b604" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">附件。(在<code class="fe ni nj nk nl b">docker-compose.yml</code>上使用的所有文件)</li></ul><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="b287" class="lv lw it nl b gy ns nt l nu nv">$ docker-app inspect<br/>tick 0.1.0</span><span id="d7aa" class="lv lw it nl b gy nw nt l nu nv">Maintained by: luc</span><span id="026e" class="lv lw it nl b gy nw nt l nu nv">Services (4) Replicas Ports Image<br/> — — — — — — — — — — — — — — — -<br/>influxdb 1 influxdb<br/>chronograf 1 8888 chronograf<br/>kapacitor 1 kapacitor<br/>telegraf 1 8186 telegraf</span><span id="0deb" class="lv lw it nl b gy nw nt l nu nv">Settings (2) Value<br/> — — — — — — — — -<br/>ports.chronograf 8888<br/>ports.telegraf 8186</span><span id="2048" class="lv lw it nl b gy nw nt l nu nv">Attachments (4) Size<br/> — — — — — — — — — — <br/>dev.yml 43B<br/>prod.yml 43B<br/>telegraf.conf 668B</span></pre><p id="46e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在集群上部署应用</strong></p><p id="5d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于堆栈使用基于<code class="fe ni nj nk nl b">telegraf.conf</code>文件的Docker配置，我们需要将该文件复制到<code class="fe ni nj nk nl b">tick.dockerapp</code>文件夹中。Docker应用包从0.6版本开始就允许嵌入配置文件)。文件夹结构如下所示:</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="0a65" class="lv lw it nl b gy ns nt l nu nv">$ tree .<br/>.<br/>├── telegraf.conf<br/>├── tick.dockerapp<br/>│   ├── dev.yml<br/>│   ├── docker-compose.yml<br/>│   ├── metadata.yml<br/>│   ├── prod.yml<br/>│   ├── settings.yml<br/>│   └── telegraf.conf<br/>└── tick.yml</span></pre><p id="297c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用下面的命令，我们通过Docker栈在Swarm上部署应用程序。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="0702" class="lv lw it nl b gy ns nt l nu nv">$ docker-app deploy -f prod.yml<br/>Creating network tick_default<br/>Creating config tick_telegraf-conf<br/>Creating service tick_influxdb<br/>Creating service tick_chronograf<br/>Creating service tick_kapacitor<br/>Creating service tick_telegraf</span></pre><p id="4a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列出所创建的服务，我们可以看到来自<code class="fe ni nj nk nl b">prod.yml</code>设置文件的值已被考虑在内(因为Telegraf和Chronograf的公开端口分别是9000和9001)。</p><p id="2f8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:目前在0.6.0中有一个小问题，因为<code class="fe ni nj nk nl b">deploy</code>命令并不总是从包中提取附件，而是在某些情况下使用当前文件夹中的附件。此处的<a class="ae ky" href="https://github.com/docker/app/pull/406" rel="noopener ugc nofollow" target="_blank">解决了此问题</a>，并将在0.6.1版本中修复。</p><h2 id="e3ca" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">在非群集主机上部署应用程序</h2><p id="8675" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">出于开发目的，我们可以使用以下命令将应用程序部署在非Swarm Docker主机上:</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="3562" class="lv lw it nl b gy ns nt l nu nv">$ docker-app render -f dev.yml | docker-compose -f — up</span></pre><p id="670b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令可以分为两部分:</p><ul class=""><li id="50ac" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">使用<code class="fe ni nj nk nl b">dev.yml</code>设置文件进行渲染，生成最终的Docker合成文件。</li><li id="16ed" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">这个生成的合成文件通过管道传递给第二个命令，该命令从标准输入中读取文件并运行合成应用程序。</li></ul><p id="9151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:这只是为了记录，因为在这里部署带有Docker Compose的应用程序没有实际意义。事实上，Compose不会考虑config原语，因为它是一个群体专有的东西。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="36cf" class="ny lw it bd lx nz or ob ma oc os oe md jz ot ka mg kc ou kd mj kf ov kg mm oi bi translated">试验</h1><p id="1d78" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当我们使用与生产环境(<code class="fe ni nj nk nl b">prod.yml</code>)相关的设置文件部署应用程序时，我们将数据发送到端口9000(tele graf发布的端口)，并检查端口9001(chrono graf发布的端口)上的结果。</p><p id="f911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们发送一些虚拟数据。为此，我们使用图像<code class="fe ni nj nk nl b">lucj/genx</code>,这是一个简单的Go应用程序，可以生成遵循线性或余弦分布的数据(将来会得到增强)。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="72dc" class="lv lw it nl b gy ns nt l nu nv">$ docker run lucj/genx<br/>Usage of /genx:<br/> -duration string<br/>      duration of the generation (default “1d”)<br/> -first float<br/>      first value for linear type<br/> -last float<br/>      last value for linear type (default 1)<br/> -max float<br/>       max value for cos type (default 25)<br/> -min float<br/>       min value for cos type (default 10)<br/> -period string<br/>       period for cos type (default “1d”)<br/> -step string<br/>       step / sampling period (default “1h”)<br/> -type string<br/>       type of curve (default “cos”)</span></pre><p id="d680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们模拟了一条余弦曲线。让我们生成三天的数据，以一天为周期，最小值/最大值为10/25，采样步长为一小时。显然不是真实世界的温度模型，但足以进行测试。)</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="0442" class="lv lw it nl b gy ns nt l nu nv">$ docker run lucj/genx:0.1 -type cos -duration 3d -min 10 -max 25 -step 1h &gt; /tmp/data</span></pre><p id="0281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们用几个shell命令将这些数据发送到Telegraf端点:</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="a0cb" class="lv lw it nl b gy ns nt l nu nv">PORT=9000<br/>endpoint="http://localhost:$PORT/write"<br/>cat /tmp/data | while read line; do<br/>  ts="$(echo $line | cut -d' ' -f1)000000000"<br/>  value=$(echo $line | cut -d' ' -f2)<br/>  curl -i -XPOST $endpoint --data-binary "temp value=${value} ${ts}"<br/>done</span></pre><p id="7b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Chronograf用户界面，我们可以看到数据被正确接收。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/7dbf36fea7585d81a476fb89fd9ccbc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RcGt9hhefACcfbt9_TIP3w.png"/></div></div></figure><p id="f338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">将应用程序推送到Docker Hub </strong></p><p id="2045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦应用程序运行良好，就可以通过简单的推送通过Docker Hub进行分发。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="cc31" class="lv lw it nl b gy ns nt l nu nv">$ docker-app push<br/>sha256:bb16877acb67...3462d4ac81a1cf440</span></pre><p id="090f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以看到它在那里，旁边是我的Docker Hub帐户的“常规”Docker图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/507e66a750d6bac0f3efa6a09655fde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nuWmYyeWXeKKfVkXKS9xw.png"/></div></div></figure><p id="024c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序现在可供任何人使用。如果你想修改这个应用程序，只需使用<code class="fe ni nj nk nl b">fork</code>命令并指定(可选)一个文件夹，应用程序的所有资源都将被下载到这个文件夹中。下面是一个使用<code class="fe ni nj nk nl b">fork</code>命令的例子。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="7465" class="lv lw it nl b gy ns nt l nu nv">$ docker-app fork lucj/tick.dockerapp:0.1.0 myuser/tick --path /tmp/mytickapp</span></pre><p id="9d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">生成舵图</strong></p><p id="85f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在上面看到了在集群上部署应用程序是多么容易。让它准备好部署在Kubernetes集群上并不难。这是通过创建一个HELM图表来实现的(HELM是Kubernetes包管理器)。以下命令创建图表:</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="5dc2" class="lv lw it nl b gy ns nt l nu nv">$ docker-app helm<br/>$ tree .<br/>.<br/>├── telegraf.conf<br/><strong class="nl iu">├── tick.chart<br/>│   ├── Chart.yaml<br/>│   ├── templates<br/>│   │   └── stack.yaml<br/>│   └── values.yaml</strong><br/>├── tick.dockerapp<br/>│   ├── dev.yml<br/>│   ├── docker-compose.yml<br/>│   ├── metadata.yml<br/>│   ├── prod.yml<br/>│   ├── settings.yml<br/>│   └── telegraf.conf<br/>└── tick.yml</span></pre><p id="f23c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，在这个过程中生成了一个文件夹和几个文件:</p><ul class=""><li id="d823" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe ni nj nk nl b">Charts.yaml</code>包含项目元数据。</li></ul><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="a25d" class="lv lw it nl b gy ns nt l nu nv">description: ""<br/>keywords: []<br/>maintainers:<br/>- name: luc &lt;&gt;<br/>name: tick<br/>version: 0.1.0</span></pre><ul class=""><li id="ae3a" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe ni nj nk nl b">templates/stack.yaml</code>包含应用程序的Kubernetes清单。这里使用了一个特殊的堆栈资源。</li></ul><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="839c" class="lv lw it nl b gy ns nt l nu nv"><strong class="nl iu">kind: Stack<br/></strong>apiVersion: compose.docker.com/v1beta2<br/>metadata:<br/>  name: tick<br/>  generatename: ""<br/>  namespace: ""<br/>  selflink: ""<br/>  uid: ""<br/>  resourceversion: ""<br/>  generation: 0<br/>  creationtimestamp: "0001–01–01T00:00:00Z"<br/>  deletiontimestamp: null<br/>  deletiongraceperiodseconds: null<br/>  labels: {}<br/>  annotations: {}<br/>  ownerreferences: []<br/>  initializers: null<br/>  finalizers: []<br/>  clustername: <br/>spec:<br/>  services:<br/>  — name: chronograf<br/>    command:<br/>    — chronograf<br/>    — --influxdb-url=http://influxdb:8086<br/>    image: chronograf<br/>    ports:<br/>    — mode: ingress<br/>      target: {{.Values.ports.chronograf}}<br/>      published: 8888<br/>      protocol: tcp<br/>  — name: influxdb<br/>    image: influxdb<br/>  — name: kapacitor<br/>    environment:<br/>      KAPACITOR_INFLUXDB_0_URLS_0: http://influxdb:8086<br/>    image: kapacitor<br/>  — name: telegraf<br/>    configs:<br/>    — source: telegraf-conf<br/>      target: /etc/telegraf/telegraf.conf<br/>    image: telegraf<br/>    ports:<br/>    — mode: ingress<br/>      target: {{.Values.ports.telegraf}}<br/>      published: 8186<br/>      protocol: tcp<br/>  configs:<br/>    telegraf-conf:<br/>      file: telegraf.conf</span></pre><ul class=""><li id="3cf6" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe ni nj nk nl b">values.yaml</code>包含将在上述占位符中使用的默认值。由于我们在生成舵图时没有指定任何设置文件，因此使用<code class="fe ni nj nk nl b">settings.yml</code>中的值。</li></ul><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="c068" class="lv lw it nl b gy ns nt l nu nv">ports:<br/>  chronograf: 8081<br/>  telegraf: 8080</span></pre><p id="6920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦生成了helm图表，就可以使用我们在上面使用的相同的deploy命令在Kube上部署应用程序，但是使用额外的<code class="fe ni nj nk nl b"> -o kubernetes</code>标志来指示要使用的orchestrator(默认为Swarm)。</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="326e" class="lv lw it nl b gy ns nt l nu nv">$ docker-app deploy -o kubernetes<br/>Waiting for the stack to be stable and running…<br/>chronograf: Ready [pod status: 1/1 ready, 0/1 pending, 0/1 failed]<br/>influxdb: Ready [pod status: 1/1 ready, 0/1 pending, 0/1 failed]<br/>kapacitor: Ready [pod status: 1/1 ready, 0/1 pending, 0/1 failed]<br/>telegraf: Ready [pod status: 1/1 ready, 0/1 pending, 0/1 failed]</span><span id="f623" class="lv lw it nl b gy nw nt l nu nv">Stack tick is stable and running</span></pre><p id="12f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们使用默认设置，Telegraf的公布端口为8080，Chronograf的公布端口为8081<em class="nx"/>(值在<code class="fe ni nj nk nl b">values.yaml</code>中定义)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/6f28f7951dd0d2b0e31df6f4938c3c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlGvc2ADhewHovDbSKZP5g.png"/></div></div></figure><p id="223b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:Kubernetes上的部署只能在Docker Desktop或Docker Enterprise Edition上运行，它们运行处理<strong class="lb iu">栈</strong>资源所需的服务器端组件。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="cc19" class="ny lw it bd lx nz or ob ma oc os oe md jz ot ka mg kc ou kd mj kf ov kg mm oi bi translated">摘要</h1><p id="8d13" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我希望这篇文章能对Docker应用程序包提供一些见解。该项目还很年轻——在撰写本文时才几个月——所以在它达到1.0.0之前可能会发生重大变化。尽管如此，它看起来确实很有前途，我将在以后的文章中跟踪它的发展。</p><p id="6d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢<a class="oz pa ep" href="https://medium.com/u/271f3deb4b07?source=post_page-----1d0d6b869211--------------------------------" rel="noopener" target="_blank">Gareth rush grove</a>&amp;Christ Crone的评论，并指出额外的资源。</p></div></div>    
</body>
</html>