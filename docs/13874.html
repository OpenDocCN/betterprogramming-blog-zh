<html>
<head>
<title>Server as a Function With Kotlin — A Detailed Look at http4k</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的服务器功能——http 4k详解</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/server-as-a-function-with-kotlin-a-detailed-look-on-http4k-22bf42055f54?source=collection_archive---------1-----------------------#2022-10-07">https://betterprogramming.pub/server-as-a-function-with-kotlin-a-detailed-look-on-http4k-22bf42055f54?source=collection_archive---------1-----------------------#2022-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="38a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写只包含函数的高性能轻量级HTTP服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20c88c71aa1c895c9bba85e7e55b1a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tuim6S3dBaqRVKSL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼斯·简斯在瑞士军刀上的照片</p></figure><p id="c01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道的许多服务器框架都很笨重，固执己见，有时很难调试，并且不是特别有效。幸运的是，有非常有趣的选择。在今天的文章中，我想和你谈谈“服务器作为一种功能”的概念我们将了解服务器、镜头、客户端、无服务器以及如何测试http4k应用程序。</p><p id="c225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是我们仅仅基于普通的功能来编写服务器应用程序。这是一种轻量级的方法，基于Marius Eriksen(Twitter)撰写并发表的论文<a class="ae ky" href="https://monkey.org/~marius/funsrv.pdf" rel="noopener ugc nofollow" target="_blank"> Your Server as a Function </a>中概述的概念。在Kotlin世界中，这个概念最突出的实现是<a class="ae ky" href="https://github.com/http4k/http4k" rel="noopener ugc nofollow" target="_blank"> http4k </a>。http4k工具包被描述为“用Kotlin编写的http工具集，重点是创建简单的、可测试的API。”最重要的一点是，http4k应用程序只是我们可以直接使用的Kotlin函数。</p><p id="6f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给你一个想法，这里有一个简单的例子。</p><h1 id="ee91" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第一个http4k服务器示例</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码展示了一个功能完整的http4k应用程序，它由一个Kotlin函数<code class="fe mp mq mr ms b">app</code>组成，我们将这个函数嵌入到一个<code class="fe mp mq mr ms b">SunHttp</code>服务器中，这是我们可以选择的可用服务器实现的一个例子。注意这里的类型<code class="fe mp mq mr ms b">HttpHandler</code>,它代表了作为功能的服务器的两个基本部分之一:</p><ol class=""><li id="752a" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">HttpHandler ( <code class="fe mp mq mr ms b">(Request) -&gt; Response</code>):通过将HTTP请求映射到响应来将HTTP请求处理成响应的抽象。</li><li id="97e3" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Filter ( <code class="fe mp mq mr ms b">HttpHandler -&gt; HttpHandler</code>):向一个<code class="fe mp mq mr ms b">HttpHandler</code>添加预处理和后处理的抽象，比如缓存、调试、认证处理等等。过滤器是可组合/堆叠的。</li></ol><p id="82fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个http4k应用程序都可以由<code class="fe mp mq mr ms b">HttpHandler</code>和<code class="fe mp mq mr ms b">Filter</code>组合而成，两者都是普通Kotlin函数类型的简单类型别名。如果我们不把Kotlin标准库算作一个的话，Http4k是零依赖的。</p><p id="2905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为纯粹形式的http4k应用程序只需要一些嵌套的Kotlin函数；不涉及反射或注释处理。因此，http4k应用程序可以超级快速地启动和停止<a class="ae ky" href="https://www.http4k.org/performance/" rel="noopener ugc nofollow" target="_blank"/>，这使它们成为部署在功能即服务环境中的合理候选对象(例如，与Spring Boot应用程序相反，后者被认为更重)。</p><h1 id="b603" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更高级的http4k应用</h1><p id="c0cb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">让我们看一个更高级的http4k服务器的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个片段中，我们可以看到http4k应用程序可能带来的一些令人兴奋的事情。前两个表达式是对<code class="fe mp mq mr ms b">HttpHandler</code>的定义，其中第一个表达式接受任何响应，并将其映射到一个主体中包含“pong”的<code class="fe mp mq mr ms b">OK</code>响应。第二个处理程序接受一个请求，提取一个名字，并问候调用者。在下一步中，我们通过为每个处理程序分配一个特定的路由来将路由应用到处理程序。正如我们所见，<code class="fe mp mq mr ms b">pingPongHandler</code>用于服务调用<code class="fe mp mq mr ms b">/ping</code>的客户端，而<code class="fe mp mq mr ms b">greetHandler</code>被映射到<code class="fe mp mq mr ms b">/greet</code>。让我们来看看这个微型服务器的不同方面:</p><h1 id="b7d0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.按指定路线发送</h1><p id="098b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><a class="ae ky" href="https://www.http4k.org/blog/meet_http4k/#routing" rel="noopener ugc nofollow" target="_blank">http4k中的路由</a>可以使用任意级别的嵌套，这种方式可以完美地工作，因为<code class="fe mp mq mr ms b">routing</code>本身会产生一个新的<code class="fe mp mq mr ms b">HttpHandler</code>(严格来说，是一种特殊的类型<code class="fe mp mq mr ms b">RoutingHttpHandler</code>)，就像原来的类型一样。</p><h1 id="1c9d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.过滤</h1><p id="082e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如前所述，我们想看的另一个重要概念是<code class="fe mp mq mr ms b">Filter</code>。首先，我们创建一个<code class="fe mp mq mr ms b">requestTimeLogger</code>,它通过测量处理时间和记录运行时间来拦截每个传入的请求。可以使用<code class="fe mp mq mr ms b">then</code>方法组合过滤器，这允许我们定义过滤器链。相应的API如下所示:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="9837" class="nq lw it ms b gy nr ns l nt nu">fun Filter.then(next: Filter): Filter</span></pre><p id="7e72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的示例应用程序中，我们将自定义过滤器添加到一个名为<code class="fe mp mq mr ms b">GZip</code>的默认过滤器中。一旦我们组合了所有的过滤器，我们想要添加一个<code class="fe mp mq mr ms b">HttpHandler</code>到我们的过滤器链中。同样，我们可以使用一个<code class="fe mp mq mr ms b">then</code>函数来实现:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="45f5" class="nq lw it ms b gy nr ns l nt nu">fun Filter.then(next: HttpHandler): HttpHandler</span></pre><p id="2b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，这又导致了一个<code class="fe mp mq mr ms b">HttpHandler</code>。你现在可能已经明白了；它只需要两个简单的类型来表达HTTP服务器应该如何操作。</p><p id="c9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示的<code class="fe mp mq mr ms b">GZip</code>滤镜只是我们可以选择的众多默认滤镜之一。其他包括缓存、CORS、基本认证或cookie处理，可以在<code class="fe mp mq mr ms b">org.http4k.filter</code>包中找到。</p><h1 id="c367" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.调用HttpHandlers</h1><p id="68fc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">该示例的最后一条语句显示了如何创建<code class="fe mp mq mr ms b">app</code> o。它本身只是一个我们可以从服务器开始的<code class="fe mp mq mr ms b">HttpHandler</code>。但是我们不需要。<code class="fe mp mq mr ms b">app</code>处理程序描述了如何处理请求。我们可以使用这个对象，以及其他单独的<code class="fe mp mq mr ms b">HttpHandler</code>和<code class="fe mp mq mr ms b">Filter</code>并直接调用它(例如，在我们的测试中)。这不需要HTTP。让我们来看看实际情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Http4k自带了一个<code class="fe mp mq mr ms b">Request</code>和一个<code class="fe mp mq mr ms b">Response</code>的实现，其中第一个可以用来调用一个<code class="fe mp mq mr ms b">HttpHandler</code>。调用不吸引人的<code class="fe mp mq mr ms b">pingPongHandler</code>会产生类似于<code class="fe mp mq mr ms b">HTTP/1.1 200 OK pong!</code>的结果，而调用最终的<code class="fe mp mq mr ms b">app</code>处理程序会由于应用了GZip过滤器而给出一个gzipped响应。这个调用还包含一个服务器日志，通知请求的持续时间:<code class="fe mp mq mr ms b">2019-09-20T21:22:55.300768Z LOG - Request to /ping took 3ms</code>。</p><p id="18a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，虽然用随机URI ( <code class="fe mp mq mr ms b">/any</code>)调用<code class="fe mp mq mr ms b">pingPongHandler</code>是没问题的，但是在调用路由支持的<code class="fe mp mq mr ms b">app</code>时，我们必须使用指定的<code class="fe mp mq mr ms b">/ping</code> URI。</p><p id="9d2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，但同样重要的是，我们在端口<code class="fe mp mq mr ms b">9000</code>上的<code class="fe mp mq mr ms b">Jetty</code>上启动我们自己的http4k <code class="fe mp mq mr ms b">HttpHandler</code>作为服务器。在这里找到可用的服务器实现列表<a class="ae ky" href="https://www.http4k.org/guide/modules/servers/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="07d9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">镜头</h1><p id="2141" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">一个复杂的HTTP应用程序必须处理的事情之一是取出内容，以及将内容放入HTTP消息。当我们从请求中提取参数时，我们也关心相应值的验证。Http4k有一个迷人的概念，可以帮助我们处理所陈述的问题:镜头。</p><h2 id="2185" class="nq lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">基本定义</h2><p id="f553" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">根据多种<a class="ae ky" href="https://medium.com/javascript-scene/lenses-b85976cb0534" rel="noopener">资源</a>的说法，镜头最初是在<a class="ae ky" href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing" rel="noopener ugc nofollow" target="_blank">哈斯克尔世界</a>中使用的，是一个可能看起来有点难以理解的功能概念。让我试着用一种可以理解的方式来描述它。假设我们有一个类<code class="fe mp mq mr ms b">Whole</code>，它有不同的字段<code class="fe mp mq mr ms b">part1</code>、<code class="fe mp mq mr ms b">part2</code>，等等。一个镜头基本上由一个getter和一个setter组成，精确聚焦于<code class="fe mp mq mr ms b">Whole</code>的一个部分。一个<code class="fe mp mq mr ms b">Part1Lens</code>镜头获取器会获取一个<code class="fe mp mq mr ms b">Whole</code>的实例来返回它所关注的部分，例如<code class="fe mp mq mr ms b">part1</code>。</p><p id="07b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，镜头设置器接受一个<code class="fe mp mq mr ms b">Whole</code>和一个设置聚焦部分的值，然后返回一个新的<code class="fe mp mq mr ms b">Whole</code>和更新后的部分。记住，镜头既可以用来拍摄也可以用来拍摄整个物体的一部分。这在实践中是什么样子的？</p><h2 id="7f79" class="nq lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">http4k中的镜头</h2><p id="0356" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">按照透镜的基本思想，http4k透镜是双向实体，可以用来从http消息中获取或设置特定的值。描述镜头的相应API以DSL的形式出现，它也允许我们定义HTTP部分的可选性，我们将镜头安装到这个HTTP部分。由于HTTP消息是一个相当复杂的容器，我们可以将镜头聚焦于消息的不同区域:查询、头部、路径、表单字段或主体。</p><p id="110c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一些如何制作镜头的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="241f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，创建镜头的API看起来或多或少很简单，但是如何在目标上使用它们呢？下面是<br/>的伪代码语法a)检索一个值:<code class="fe mp mq mr ms b">&lt;lens&gt;.extract(&lt;target&gt;)</code>或<code class="fe mp mq mr ms b">&lt;lens&gt;(&lt;target&gt;)</code> <br/> b)设置一个值:<code class="fe mp mq mr ms b">&lt;lens&gt;.inject(&lt;value&gt;, &lt;target&gt;)</code>或<code class="fe mp mq mr ms b">&lt;lens&gt;(&lt;value&gt;, &lt;target&gt;)</code></p><h2 id="5134" class="nq lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">使用Lens从HTTP请求中检索值</h2><p id="5357" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">重用之前的<code class="fe mp mq mr ms b">greet</code>示例，让我们修改代码，使用镜头来检索名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="36ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个双向镜头，聚焦于消息的查询部分，从中提取一个必需的非空名称。现在，如果客户机碰巧调用端点而没有提供<code class="fe mp mq mr ms b">name</code>查询参数，镜头会自动返回一个错误，因为它被定义为“必需的”和“非空的”</p><p id="0524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，默认情况下，应用程序向客户端公开了大量细节，将错误声明为<code class="fe mp mq mr ms b">org.http4k.lens.LensFailure: query 'name' must be string</code>，包括详细的堆栈跟踪。相反，我们希望将所有镜头错误映射到HTTP 400响应，以表示客户端提供了无效数据。因此，http4k提供了一个<code class="fe mp mq mr ms b">ServerFilters.CatchLensFailure</code>过滤器，我们可以很容易地在我们的过滤器链中激活它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="6d03" class="nq lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">使用Lens在HTTP请求中设置值</h2><p id="31b4" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在研究了从HTTP消息中提取值之后，我们如何使用<code class="fe mp mq mr ms b">nameLens</code>在HTTP请求中设置值呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="cc66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子展示了我们如何创建一个<code class="fe mp mq mr ms b">Request</code>的实例，并通过一个或多个透镜注入一个值。我们可以使用<code class="fe mp mq mr ms b">Lens::inject</code>函数来指定我们想要设置到任意<code class="fe mp mq mr ms b">Request</code>实例中的值。既然我们已经看到了一个字符串镜头的基本示例，我们想深入研究如何处理一些更高级的JSON内容。</p><h1 id="6c20" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">JSON处理</h1><p id="b9cc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们可以从几个JSON实现中进行选择，包括常见的Gson和Jackson库。我个人更喜欢杰克逊，因为它有一个伟大的科特林模块。在我们的应用程序中添加了JSON格式模块之后，我们可以开始使用lenses在HTTP消息之间封送对象。</p><p id="e634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个管理人员的部分完整的REST API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们看到了一个类，它提供了两个处理程序，表示您期望从REST API中得到的常见操作。<code class="fe mp mq mr ms b">getAllHandler</code>获取所有存储的实体并将它们返回给客户端。我们使用了通过Jackson的<code class="fe mp mq mr ms b">org.http4k.format.Jackson.auto</code>扩展创建的<code class="fe mp mq mr ms b">BiDiBodyLens&lt;List&lt;Person&gt;&gt;</code>(双向的)。</p><p id="7382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如http4k文档中所提到的，<code class="fe mp mq mr ms b">auto()</code>方法需要手动导入，因为IntelliJ不会自动选择它。我们可以通过提供一个类型为<code class="fe mp mq mr ms b">List&lt;Person&gt;</code>的值并将其注入到一个HTTP <code class="fe mp mq mr ms b">Response</code>中，如<code class="fe mp mq mr ms b">getAllHandler</code>实现所示，来使用前面已经展示过的结果透镜。</p><p id="cec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe mp mq mr ms b">postHandler</code>提供了一个<code class="fe mp mq mr ms b">HttpHandler</code>的实现，它从请求中提取一个<code class="fe mp mq mr ms b">Person</code>实体并将其添加到存储中。同样，我们使用镜头轻松地从请求中提取JSON实体。</p><p id="d106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这已经结束了我们对镜头的先睹为快。正如我们所看到的，lets是一个奇妙的工具，它让我们提取和注入HTTP消息的一部分，并提供了验证这些部分的简单方法。现在，我们已经看到了http4k工具集的最基本的概念，让我们考虑如何测试这样的应用程序。</p><h1 id="9597" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">测试</h1><p id="e677" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">大多数时候，当我们考虑测试位于web框架之上的应用程序时，我们不得不担心框架的细节，这会使测试变得更加困难。</p><p id="d2aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剧透一下:http4k的情况并不完全如此🎉。</p><p id="0713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经知道，http4k工具集中的两个核心概念之一的<code class="fe mp mq mr ms b">HttpHandlers</code>，只是将请求映射到响应的普通Kotlin函数，甚至一个完整的http4k应用程序也只是一个<code class="fe mp mq mr ms b">HttpHandler</code>，因此是一个可调用的函数。因此，整个和部分http4k应用程序可以很容易地进行测试，而不需要额外的工作。</p><p id="2acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，http4k的开发者认为提供一些额外的模块来支持我们测试我们的应用程序仍然是有帮助的。其中一个模块是<code class="fe mp mq mr ms b">http4k-testing-hamkrest</code>，它增加了一组<a class="ae ky" href="https://github.com/npryce/hamkrest" rel="noopener ugc nofollow" target="_blank"> Hamkrest </a> matchers，我们可以用它来更容易地验证消息对象的细节。</p><h1 id="9b79" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Http4k处理程序测试示例</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b0c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个片段演示了我们之前已经使用过的<code class="fe mp mq mr ms b">PersonHandlerProvider</code>的测试。如图所示，用一个<code class="fe mp mq mr ms b">Request</code>对象调用一个<code class="fe mp mq mr ms b">HttpHandler</code>，然后使用Hamkrest或任何您喜欢的断言库来检查结果<code class="fe mp mq mr ms b">Response</code>，这非常简单。另一方面，测试<code class="fe mp mq mr ms b">Filter</code> s稍微困难一些。</p><p id="0574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">老实说，这只是我们在处理程序上需要做的一件小事。过滤器通过应用一些中间预处理或后处理将一个<code class="fe mp mq mr ms b">HttpHandler</code>映射到另一个。与其研究处理程序本身之间的映射，不如再次通过那个过滤器发送一个<code class="fe mp mq mr ms b">Request</code>并查看结果<code class="fe mp mq mr ms b">Response</code>会更方便。好消息是这样做非常容易。</p><h1 id="e14c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Http4k过滤器测试示例</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个名为<code class="fe mp mq mr ms b">addExtraHeaderFilter</code>的<code class="fe mp mq mr ms b">Filter</code>,它向一个已处理的请求添加一个自定义头，然后将其转发给下一个过滤器。我们的目标是通过测试中的过滤器发送一个简单的请求。我们能做的是通过<code class="fe mp mq mr ms b">then</code>给过滤器添加一个哑的<code class="fe mp mq mr ms b">{ Response(OK) }</code>处理程序，使其成为一个简单的<code class="fe mp mq mr ms b">HttpHandler</code>。因此，我们可以调用新创建的处理程序，现在它包含了我们自己的过滤器，并调查产生的<code class="fe mp mq mr ms b">Response</code>对象是否包含新的预期头。我们开始吧——处理程序和过滤器都得到了测试。</p><p id="01d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我想说的是，这只是用最熟悉的工具测试http4k应用程序的愉快经历的一瞥。可能有必要对实际运行的服务器进行测试，并在较低的级别上验证响应，即比较生成的JSON。通过<a class="ae ky" href="https://www.http4k.org/guide/modules/approvaltests/" rel="noopener ugc nofollow" target="_blank">认证测试</a>模块也可以做到这一点。在本文的后面，我们想看看http4k的客户机模块，这又打开了一些新的可能性。</p><h1 id="b594" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无服务器</h1><p id="3be3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们这个时代最热门的话题之一是无服务器计算。我们可以在别人的服务器上运行我们的代码。其中一部分被称为功能即服务(FaaS)。最常见的FaaS平台包括AWS Lambda、谷歌云函数和微软Azure函数。总的想法是，这些供应商提供了一个平台，我们可以在那里部署我们的代码，他们负责管理资源和按需扩展我们的应用程序。</p><p id="48d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无服务器的一个棘手之处是，如果我们的功能暂时不用，它可能会被平台关闭。这需要在有人再次需要他们的时候重新创业。这对我们意味着什么？我们需要选择允许应用程序快速启动的目标平台和工具。例如，传统形式的JVM上的Spring可能不是该用例的最佳工具。然而，正如您所想象的，http4k占用空间小，启动时间超级快，是一个很好的选择。它甚至自带对AWS Lambda的原生支持。</p><h1 id="3976" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">客户作为一个功能</h1><p id="2b51" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">到目前为止，我们已经了解了http4k有多酷，以及为什么它是开发服务器应用程序的好工具。如果客户机不使用HTTP服务器，那么HTTP服务器就没有多大意义，所以我们想从另一个角度——客户机作为一种功能——来结束本文。</p><p id="8ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">http4k <code class="fe mp mq mr ms b">core</code>库提供了我们开始使用客户端所需的一切。http4k中的客户端也是一种特殊形式的<code class="fe mp mq mr ms b">HttpHandler</code>，正如我们在这个小片段中看到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="20ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里使用的<code class="fe mp mq mr ms b">JavaHttpClient</code>是<code class="fe mp mq mr ms b">core</code>库附带的默认实现。如果我们更喜欢OkHttp、Apache或Jetty，我们将使用相关的<a class="ae ky" href="https://www.http4k.org/guide/modules/clients/" rel="noopener ugc nofollow" target="_blank">模块</a>来替换默认模块。因为我们是针对接口编程的(客户是T4)，所以在任何时候交换实现都不是什么大事。显然,<code class="fe mp mq mr ms b">core</code>库附带了几个默认的<code class="fe mp mq mr ms b">Filter</code>,我们可以应用到我们的客户端。这些都可以在<code class="fe mp mq mr ms b">ClientFilters.kt</code>文件中找到，该文件包含像<code class="fe mp mq mr ms b">BasicAuth</code>、<code class="fe mp mq mr ms b">Gzip</code>这样的内容，以及更多您所期望的内容。</p><p id="3be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，http4k服务器的所有概念——包括处理程序、过滤器和镜头——都可以在http4k客户机中重用，这带来了很多可能性。例如，使用客户机模块来测试您的服务器，反之亦然，这是很有意义的。我很快就爱上了整个堆栈，并在生产中使用了几年。</p><h1 id="ebd2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">总结与展望</h1><p id="3d9e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在过去的几年里，我个人学会了欣赏http4k。一旦熟悉了基本概念，快速开发服务器应用程序就变得简单了。Http4k附带了一系列令人难以置信的受支持的概念和技术，包括OAuth、Swagger、Websockets、XML等等。</p><p id="ee1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的模块化本质允许我们根据需要通过应用依赖关系来添加功能，并且由于它简单的基本类型，它是高度可扩展的。Http4k是一个工具集，它允许我们编写具有快速启动时间的应用程序，因此当涉及到FaaS和无服务器计算时，它也是一个有效的选择。</p><p id="dbcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎这还不够，这个工具集还包括了编写HTTP客户端的复杂方法，这是我们在上一节中了解到的。总的来说，http4k是一项很有前途的技术，在选择下一个http工具集时，您绝对应该考虑它。</p></div></div>    
</body>
</html>