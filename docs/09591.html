<html>
<head>
<title>Two Misconceptions About Memory Leaks in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Swift中内存泄漏的两个误解</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-misconceptions-about-memory-leaks-in-swift-7128f41dbe15?source=collection_archive---------4-----------------------#2021-09-14">https://betterprogramming.pub/two-misconceptions-about-memory-leaks-in-swift-7128f41dbe15?source=collection_archive---------4-----------------------#2021-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1de8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">他们告诉你的内存泄漏并不完全正确</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abeebd934aabc58ab888a811d6b9978f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*75fBiqX2yw3eZxab"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@daniloalvesd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达尼洛·阿尔维斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="58fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift严重依赖两种类型的实体:结构和类。两者的主要区别在于，结构是值类型，而类是引用类型。</p><p id="db3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者的不同之处在于Swift如何在内存中处理它们。<a class="ae ky" href="https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation" rel="noopener ugc nofollow" target="_blank">引用类型在堆中分配，而值类型在栈中分配</a>。对于堆栈上的变量，一旦变量超出范围，内存就会自动释放。从堆中释放内存并不容易，不同的语言为此实现了不同的系统。</p><p id="08b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift使用一种叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting" rel="noopener ugc nofollow" target="_blank">自动引用计数</a>的静态方法，简称ARC。编译器为每个引用类型的变量保留一个计数器:每当实体创建对变量的引用时，计数器就增加。每当参考中断时，计数器就会减少。当计数器到达<code class="fe lv lw lx ly b">0</code>时，内存立即被释放。</p><p id="3c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该系统最常见的问题是参考周期。当两个变量相互引用时，就会发生这种情况。当这种情况发生时，计数器永远不会到达<code class="fe lv lw lx ly b">0</code>，因为这两个对象保持一个指向彼此的指针，并且计数器对于它们自己的引用总是至少为<code class="fe lv lw lx ly b">1</code>。当我们用来访问这些对象的变量变得不可访问时(例如，因为它超出了它的作用域),我们的应用程序就出现了内存泄漏:这两个变量保存在内存中，但我们无法再访问它们。</p><p id="16f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免这种情况的常见建议是尽可能使用值类型。作为值类型，假设它们不会产生内存泄漏。</p><p id="a0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这并不完全正确。我们不能在我们的应用程序中只使用值类型(例如，<code class="fe lv lw lx ly b">UIKit</code>和<code class="fe lv lw lx ly b">Combine</code>都严重依赖于类),当结构的属性是引用类型时，我们仍然可以对它们进行引用循环。更糟糕的是，符合协议的类可能会在看似无辜的代码后面隐藏引用循环！</p><p id="e362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看几个例子。</p><h1 id="80f1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">协议和参考周期</h1><p id="834d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们有一个协议<code class="fe lv lw lx ly b">Person</code>允许一个人拥有一个伴侣。伙伴必须符合相同的<code class="fe lv lw lx ly b">Person</code>协议。</p><p id="d86e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有一个实现协议的类<code class="fe lv lw lx ly b">Married</code>。出于调试目的，我添加了一个<code class="fe lv lw lx ly b">name</code>属性，当类为<code class="fe lv lw lx ly b">deinit</code>时，我们将打印一条消息。</p><p id="c589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用这些实体来创建一个参考循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ecd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们创造了一对夫妇的人，我们将他们结合在一起。然后我们释放这些对象……没有来自<code class="fe lv lw lx ly b">deinit</code>的消息被打印在控制台上。这是意料之中的。我们有两个相互引用的类。</p><p id="4774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在<code class="fe lv lw lx ly b">Married</code>类中，伙伴的类型是<code class="fe lv lw lx ly b">Person</code>，这是一个协议！这意味着一个<code class="fe lv lw lx ly b">Married</code>人可以接受任何其他对象作为伙伴，只要它符合<code class="fe lv lw lx ly b">Person</code>协议。</p><p id="1aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Married</code>类不会立即显示存在引用循环的风险，因为<code class="fe lv lw lx ly b">Person</code>类型不是一个类。</p><p id="afe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题并打破引用循环，我们需要在<code class="fe lv lw lx ly b">partner</code>属性上使用<code class="fe lv lw lx ly b">weak</code>关键字。通过使用该关键字，编译器不会增加引用计数器，因此它可以释放引用。然而，如果我们试图添加<code class="fe lv lw lx ly b">weak</code>属性，我们会得到下面的编译器错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/74cdbcc1f8f4d8cc762f741956f6fc55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yl5badLtWNNTixbIqN68gA.png"/></div></div></figure><p id="c7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在抱怨不能使用<code class="fe lv lw lx ly b">weak</code>关键字，因为<code class="fe lv lw lx ly b">Person</code>也可以是值类型。为了解决这个问题，我们需要更新协议，将一致性添加到<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/anyobject" rel="noopener ugc nofollow" target="_blank">AnyObject</a></code>协议中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ca54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们再次运行创建人的代码，我们最终设法正确地释放我们的<code class="fe lv lw lx ly b">Married</code>对象。</p><p id="a422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一点:总是将只由类实现的协议标记为<code class="fe lv lw lx ly b">AnyObject</code>协议。这样，如果我们有一个参考循环，就可以做参考<code class="fe lv lw lx ly b">weak</code>并求解。</p><h1 id="f950" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结构和引用循环</h1><p id="a233" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">第二个谎言是，结构不能生成引用循环。不幸的是，当他们的一个属性是一个类时，他们可以。让我们考虑一个可以包含一个<code class="fe lv lw lx ly b">Person</code>的<code class="fe lv lw lx ly b">House</code>结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码看起来很安全，但事实并非如此。我们的<code class="fe lv lw lx ly b">Person</code>可以由一个类实现，通过使用不带<code class="fe lv lw lx ly b">weak</code>关键字的<code class="fe lv lw lx ly b">Married</code>版本，我们将结束一个引用循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">找到这个引用循环更加微妙:我们有一个保存协议属性的结构，我们通常不能为它添加<code class="fe lv lw lx ly b">weak</code>关键字。但是当协议由一个类实现时，我们可能仍然有一个引用循环。</p><p id="0a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决引用循环，我们需要使用类边界协议和<code class="fe lv lw lx ly b">weak</code>关键字。</p><h1 id="317a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">如何确保我们的应用程序没有内存泄漏</h1><p id="2f78" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在为这篇文章做研究的时候，我在<a class="ae ky" href="https://www.essentialdeveloper.com/" rel="noopener ugc nofollow" target="_blank"> Essential Developer </a>的<a class="ae ky" href="https://www.youtube.com/watch?v=Gg-2nZYRd2g&amp;list=PLyjgjmI1UzlTtsImzQ4cT8bQ3_RXtkqLg&amp;index=4" rel="noopener ugc nofollow" target="_blank">这个视频</a>上找到了答案。它的简单和有效打动了我。</p><p id="3466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，每当我们为我们的类编写测试时，我们应该稍微改变我们的方法。我们需要使用工厂函数，而不是在<code class="fe lv lw lx ly b">setUpWithError()</code>方法中创建测试变量。然后，我们可以向我们的引用类型添加一个弱引用，并断言它们在<code class="fe lv lw lx ly b">tearDownWithError()</code>方法中成为<code class="fe lv lw lx ly b">nil</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7c39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个测试中，我们通过添加一个参考循环来创建被测系统(SUT)。在第15行，我们创建了<code class="fe lv lw lx ly b">weakSUT</code>变量，在<code class="fe lv lw lx ly b">tearDownWithError()</code>中，我们断言弱引用在测试结束时变成了<code class="fe lv lw lx ly b">nil</code>。</p><p id="a165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用带有强引用的<code class="fe lv lw lx ly b">Married</code>类版本，这个测试将会失败。如果我们使用正确的版本，带有<code class="fe lv lw lx ly b">weak var partner</code>属性，测试将会通过。</p><h1 id="bf1d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="5e51" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在今天的文章中，我们指出了一些关于Swift语言的误解。诚然，值类型本身不会创建引用循环，但是，它们可以保存可以创建引用循环的变量。</p><p id="fe8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得发现这样的问题变得非常困难，并且当我们将协议加入其中时，事情会变得更糟。</p><p id="9831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当编写我们的应用程序时，我们应该意识到我们的协议是如何使用的。如果我们希望它们只被类使用，我们应该使用<code class="fe lv lw lx ly b">: AnyObject</code>一致性将它们标记为类绑定协议，这样我们就可以打破可能的引用循环。</p><p id="8961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，每次我们在应用程序中创建一个类时，我们都应该用<code class="fe lv lw lx ly b">weakSUT</code>属性编写一个测试，并断言它在<code class="fe lv lw lx ly b">tearDownWithError()</code>方法中变成了<code class="fe lv lw lx ly b">nil</code>。</p><p id="2cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些小预防措施将使我们的代码更具表现力，我们的应用程序更健壮，缺陷更少。</p></div></div>    
</body>
</html>