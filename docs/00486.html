<html>
<head>
<title>Kubernetes Tips: Using a ServiceAccount</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes提示:使用服务帐户</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/k8s-tips-using-a-serviceaccount-801c433d0023?source=collection_archive---------0-----------------------#2019-05-30">https://betterprogramming.pub/k8s-tips-using-a-serviceaccount-801c433d0023?source=collection_archive---------0-----------------------#2019-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="71f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何从Pod与API服务器通信</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/016d5260e2b288c34917ffbe1d08bc9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2OHCGlh-XH87ZT9xW2e0A.png"/></div></div></figure><p id="0d15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Pod中运行的容器使用ServiceAccount与<a class="ae lq" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群的API服务器进行通信。在本帖中，我们将看到这是如何完成的，以及Kubernetes资源在这个过程中的作用。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0be0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">API服务器— HTTP REST API</h1><p id="efbb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果您使用Kubernetes集群，那么您可能会使用<code class="fe mv mw mx my b">kubectl</code>二进制文件或web接口来调用API服务器。在幕后，所有的调用都是通过API公开的HTTP端点进行的。</p><p id="572b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个API有很好的文档记录；所有端点都在<a class="ae lq" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14" rel="noopener ugc nofollow" target="_blank">官方文档</a>中有描述。</p><p id="c1fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个简单的例子:这里是在默认名称空间中运行的pod的<a class="ae lq" href="https://API_SERVER/api/v1/namespaces/default/pods/" rel="noopener ugc nofollow" target="_blank">列表。当然，请求需要被认证和授权来执行这个动作。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2c30" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">从Pod访问API服务器</h1><p id="de1e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">许多在集群中运行的应用程序(阅读:在Pods中运行)需要与API服务器通信。其中包括在控制平面内运行的进程(调度程序、控制器管理器、代理等)。)，以及所有需要对集群执行某种形式管理的应用程序。</p><p id="0aef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，一些应用程序可能需要知道:</p><ul class=""><li id="f068" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">群集节点的状态。</li><li id="c62b" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">可用的命名空间。</li><li id="0e45" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">在集群或特定名称空间中运行的pod。</li><li id="f469" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">以及其他类似的事情。</li></ul><p id="8fdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了与API服务器通信，Pod使用包含身份验证令牌的ServiceAccount。角色(例如:列出给定名称空间内所有pod的权限)或ClusterRole(例如:读取整个集群内所有机密的权限)可以绑定到这个ServiceAccount。因此ServiceAccount有权执行这些操作。</p><ul class=""><li id="a159" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><strong class="kw iu">从集群外部:</strong>可以使用kube配置文件中指定的端点来访问API服务器(默认为<code class="fe mv mw mx my b">$HOME/.kube/config</code>)。举个例子，如果你使用数字海洋管理的Kubernetes，那么端点就是类似于<a class="ae lq" href="https://b703a4fd-0d66-4802-a354-ba2c2a734a77.k8s.ondigitalocean.com" rel="noopener ugc nofollow" target="_blank">https://b 703 a4 FD-0d 56-4802-a354-ba 2c 2 a 767 a 77 . k8s . ondigitalocean . com</a></li><li id="0d2c" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><strong class="kw iu">从集群内部</strong>(阅读:从Pod):可以使用名为<code class="fe mv mw mx my b">kubernetes</code>的<code class="fe mv mw mx my b">ClusterIP</code>类型的专用服务来访问API服务器。默认情况下，这个服务在那里，如果它被错误地删除了，它会自动重新创建。</li></ul><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="1f56" class="nr lz it my b gy ns nt l nu nv">$ kubectl get svc<br/>NAME       TYPE      CLUSTER-IP  EXTERNAL-IP PORT(S) AGE<br/>kubernetes ClusterIP 10.96.0.1   &lt;none&gt;      443/TCP 23h</span></pre><p id="b1eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了正确的权限(稍后将详细介绍)，在<em class="nw">默认</em>名称空间中列出Pod可以通过这个简单的<a class="ae lq" href="https://kubernetes/api/v1/namespaces/default/pods/" rel="noopener ugc nofollow" target="_blank"> GET请求</a>从一个Pod中完成。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d30b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用命名空间默认ServiceAccount</h1><p id="46e1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">每个名称空间都有一个默认的ServiceAccount，名为<code class="fe mv mw mx my b">default</code>。我们可以使用以下命令来验证这一点:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="c20e" class="nr lz it my b gy ns nt l nu nv">$ kubectl get sa --all-namespaces | grep default<br/>default     default 1 6m19s<br/>kube-public default 1 6m19s<br/>kube-system default 1 6m19s</span></pre><p id="67cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查一下<em class="nw">默认</em>名称空间中名为<code class="fe mv mw mx my b">default</code>的ServiceAccount(这与另一个名称空间的默认ServiceAccount非常相似)。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="632b" class="nr lz it my b gy ns nt l nu nv">$ kubectl get sa default -o yaml<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/> name: default<br/> namespace: default<br/> ...<br/>secrets:<br/>- name: default-token-dffkj</span></pre><p id="1240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里可以看到，向这个ServiceAccount提供了一个密码。让我们仔细看看这个:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="5d0c" class="nr lz it my b gy ns nt l nu nv">$ kubectl get secret default-token-dffkj -o yaml<br/>apiVersion: v1<br/>data:<br/> ca.crt: LS0tLS1CRU...0tLS0tCg==<br/> namespace: ZGVmYXVsdA==<br/> token: ZXlKaGJHY2...RGMUlIX2c=<br/>kind: Secret<br/>metadata:<br/> name: default-token-dffkj<br/> namespace: default<br/> ...<br/>type: kubernetes.io/service-account-token</span></pre><p id="6fb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个秘密的数据键下有几个键/值对。为了可读性，我缩短了<code class="fe mv mw mx my b">ca.crt</code>和<code class="fe mv mw mx my b">token</code>的值)，基本上是:</p><ul class=""><li id="13fd" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><code class="fe mv mw mx my b">ca.crt</code>是集群证书的Base64编码。</li><li id="9105" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe mv mw mx my b">namespace</code>是当前名称空间的Base64编码(默认)。</li><li id="9f02" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated"><code class="fe mv mw mx my b">token</code>是用于验证API服务器的JWT的Base64编码。</li></ul><p id="fe80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:JSON Web Token (JWT)是一个开放标准(<a class="ae lq" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>)，它定义了一种紧凑的自包含方式，以JSON对象的形式在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p><p id="fe74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来关注一下<code class="fe mv mw mx my b">token</code> <em class="nw">。</em>一旦解码(在Linux上使用<code class="fe mv mw mx my b">base64 -d</code>，或者在MacOS上使用<code class="fe mv mw mx my b">base64 -D</code>，我们可以很容易地从命令行，或者像<a class="ae lq" href="https://jwt.io" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>这样的在线服务中获得这个JWT的有效载荷。</p><p id="a7fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此有效负载具有以下格式:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="1b87" class="nr lz it my b gy ns nt l nu nv">{<br/> “iss”: “kubernetes/serviceaccount”,<br/> “kubernetes.io/serviceaccount/namespace”: “default”,<br/> “kubernetes.io/serviceaccount/secret.name”: “default-token-dffkj”,<br/> “kubernetes.io/serviceaccount/service-account.name”: “default”,<br/> “kubernetes.io/serviceaccount/service-account.uid”: “ac5aa972–80ae-11e9–854d-0800278b691f”,<br/> “sub”: “system:serviceaccount:default:default”<br/>}</span></pre><p id="a604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到它所链接的ServiceAccount、它所在的名称空间以及其他一些内部信息。</p><p id="0116" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在下面看到如何根据下面的规范在一个简单的Pod中使用这个令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="91ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设该规范在<code class="fe mv mw mx my b">pod-default.yaml</code>文件中，您可以使用以下(标准)命令创建Pod:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="9f97" class="nr lz it my b gy ns nt l nu nv">$ kubectl apply -f <em class="nw">pod-default.yaml</em></span></pre><p id="3186" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为没有指定<code class="fe mv mw mx my b">serviceAccountName</code>键，所以使用Pod的名称空间的默认ServiceAccount。我们可以通过检查这个创建过的Pod的规范来确认这一点(Kubernetes在创建过程中为我们添加了很多东西)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3eb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里需要注意的重要事项:</p><ul class=""><li id="d24a" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated"><code class="fe mv mw mx my b">serviceAccountName</code>键设置为默认ServiceAccount的名称。</li><li id="01cf" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">ServiceAccount的信息通过使用volume安装在Pod的容器中，在<code class="fe mv mw mx my b">/var/run/secrets/kubernetes.io/serviceaccount</code>中(稍后会详细介绍)。</li></ul><h2 id="d782" class="nr lz it bd ma nz oa dn me ob oc dp mi ld od oe mk lh of og mm ll oh oi mo oj bi translated">API服务器的匿名调用</h2><p id="d220" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们在这个容器中运行一个shell并安装<code class="fe mv mw mx my b">curl</code>实用程序:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="5ca2" class="nr lz it my b gy ns nt l nu nv">$ kubectl exec -ti pod-default -- sh<br/>/ # apk add --update curl</span></pre><p id="92ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这个shell中，我们可以尝试从API服务器获取信息，而无需进行身份验证。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="c9e3" class="nr lz it my b gy ns nt l nu nv">/ # curl <a class="ae lq" href="https://kubernetes/api/v1" rel="noopener ugc nofollow" target="_blank">https://kubernetes/api/v1</a> --insecure</span></pre><p id="b82c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:如上所述，从集群中运行的Pod，可以使用Kubernetes ClusterIP服务访问API服务器。</p><p id="3e71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们得到一条错误消息，因为未经身份验证的用户不允许执行该请求。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="3814" class="nr lz it my b gy ns nt l nu nv">/ # curl <a class="ae lq" href="https://kubernetes/api" rel="noopener ugc nofollow" target="_blank">https://kubernetes/api</a> --insecure<br/>{<br/> “kind”: “Status”,<br/> “apiVersion”: “v1”,<br/> “metadata”: {},<br/> “status”: “Failure”,<br/> “message”: “forbidden: User \”system:anonymous\” cannot get path \”/api\””,<br/> “reason”: “Forbidden”,<br/> “details”: {},<br/> “code”: 403<br/>}</span></pre><p id="4601" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更进一步，尝试使用默认ServiceAccount的令牌发出相同的查询。</p><h2 id="4032" class="nr lz it bd ma nz oa dn me ob oc dp mi ld od oe mk lh of og mm ll oh oi mo oj bi translated">使用ServiceAccount令牌调用</h2><p id="1fbc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">从<code class="fe mv mw mx my b">alpine</code>容器中，可以从<code class="fe mv mw mx my b">/var/run/secrets/kubernetes.io/serviceaccount/token</code>检索默认ServiceAccount的令牌(记住上面的volume/volumeMounts指令)。使用此令牌，我们可以将其用作针对API服务器进行身份验证的承载令牌:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="c767" class="nr lz it my b gy ns nt l nu nv">/ # TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)<br/>/ # curl -H “Authorization: Bearer $TOKEN” <a class="ae lq" href="https://kubernetes/api/v1/" rel="noopener ugc nofollow" target="_blank">https://kubernetes/api/v1/</a> --insecure</span></pre><p id="0336" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次请求进行得很顺利——查询这个端点时不再有错误。将返回资源列表。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="6194" class="nr lz it my b gy ns nt l nu nv">{<br/>  "kind": "APIResourceList",<br/>  "groupVersion": "v1",<br/>  "resources": [<br/>   {<br/>     "name": "bindings",<br/>     "singularName": "",<br/>     "namespaced": true,<br/>     "kind": "Binding",<br/>     "verbs": [<br/>       "create"<br/>     ]<br/>   },<br/>   ...<br/>  ]<br/>}</span></pre><p id="edc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们尝试一些更大胆的东西，使用这个标记列出默认名称空间中的所有pod:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="33c9" class="nr lz it my b gy ns nt l nu nv">/ # curl -H “Authorization: Bearer $TOKEN” <a class="ae lq" href="https://kubernetes/api/v1/namespaces/default/pods/" rel="noopener ugc nofollow" target="_blank">https://kubernetes/api/v1/namespaces/default/pods/</a> --insecure<br/>{<br/> “kind”: “Status”,<br/> “apiVersion”: “v1”,<br/> “metadata”: {},<br/> “status”: “Failure”,<br/> “message”: “pods is forbidden: User \”system:serviceaccount:default:default\” cannot list resource \”pods\” in API group \”\” in the namespace \”default\””,<br/> “reason”: “Forbidden”,<br/> “details”: {<br/>   “kind”: “pods”<br/> },<br/> “code”: 403<br/>}</span></pre><p id="e0d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认的ServiceAccount没有足够的权限执行此查询。在接下来的部分中，我们将创建自己的ServiceAccount，并为它提供执行此操作所需的额外权限。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e4a9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用自定义服务帐户</h1><h2 id="10fe" class="nr lz it bd ma nz oa dn me ob oc dp mi ld od oe mk lh of og mm ll oh oi mo oj bi translated">服务帐户的创建</h2><p id="aecc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们在默认名称空间中创建一个新的ServiceAccount，并将其命名为<code class="fe mv mw mx my b">demo-sa</code>。这个ServiceAccount在下面的规范中定义，并使用标准的<code class="fe mv mw mx my b">kubectl apply -f</code>命令创建。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="f84a" class="nr lz it my b gy ns nt l nu nv">apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/> name: demo-sa</span></pre><h2 id="d7c0" class="nr lz it bd ma nz oa dn me ob oc dp mi ld od oe mk lh of og mm ll oh oi mo oj bi translated">角色的创建</h2><p id="cea8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">除非绑定了特定的权限，否则ServiceAccount没有多大用处。在Kubernetes中，权限被称为角色或集群角色。它们分别与ServiceAccount、RoleBinding和ClusterRoleBinding相关联。</p><p id="e65a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">角色(同样适用于集群角色)包含一系列规则。每个规则都定义了一些可以针对<code class="fe mv mw mx my b">apiGroups</code>(例如:<code class="fe mv mw mx my b">core</code>、<code class="fe mv mw mx my b">apps/v1</code>)内的<code class="fe mv mw mx my b">resources</code>(例如:<code class="fe mv mw mx my b">Pod</code>、<code class="fe mv mw mx my b">Service</code>、<code class="fe mv mw mx my b">Secret</code>)列表执行的动作(例如:<code class="fe mv mw mx my b">list</code>、<code class="fe mv mw mx my b">get</code>、<code class="fe mv mw mx my b">watch</code>)。角色定义特定命名空间的权限，而ClusterRole的范围是整个集群。</p><p id="fe4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下规范定义了一个<code class="fe mv mw mx my b">Role</code>，允许在默认<code class="fe mv mw mx my b">namespace</code>中列出所有pod。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="c0d0" class="nr lz it my b gy ns nt l nu nv">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: Role<br/>metadata:<br/> name: list-pods<br/> namespace: default<br/>rules:<br/> — apiGroups:<br/>   — ''<br/> resources:<br/>   — pods<br/> verbs:<br/>   — list</span></pre><h2 id="512a" class="nr lz it bd ma nz oa dn me ob oc dp mi ld od oe mk lh of og mm ll oh oi mo oj bi translated">将角色与ServiceAccount绑定</h2><p id="098f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">最后一步，我们绑定上面创建的角色和ServiceAccount。为此，我们用以下规范定义了一个<code class="fe mv mw mx my b">RoleBinding</code>:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="6a1f" class="nr lz it my b gy ns nt l nu nv">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: RoleBinding<br/>metadata:<br/> name: list-pods_demo-sa<br/> namespace: default<br/>roleRef:<br/> kind: Role<br/> name: list-pods<br/> apiGroup: rbac.authorization.k8s.io<br/>subjects:<br/> — kind: ServiceAccount<br/>   name: demo-sa<br/>   namespace: default</span></pre><p id="056d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦创建了<code class="fe mv mw mx my b">RoleBinding</code>,<code class="fe mv mw mx my b">demo-sa</code>service account可以在<code class="fe mv mw mx my b">default</code> <code class="fe mv mw mx my b">namespace</code>中列出pod(这是在角色规范中的<code class="fe mv mw mx my b">rules</code>键下定义的动作)。让我们检查一下这个。</p><h2 id="6e13" class="nr lz it bd ma nz oa dn me ob oc dp mi ld od oe mk lh of og mm ll oh oi mo oj bi translated">在Pod中使用ServiceAccount</h2><p id="69c9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们根据以下规范创建一个简单的Pod:</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="c32c" class="nr lz it my b gy ns nt l nu nv">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/> name: pod-demo-sa<br/>spec:<br/> serviceAccountName: demo-sa<br/> containers:<br/> — name: alpine<br/>   image: alpine:3.9<br/>   command:<br/>   — "sleep"<br/>   — "10000"</span></pre><p id="b6a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">指定了<code class="fe mv mw mx my b">serviceAccountName</code>键，该键包含该Pod使用的ServiceAccount的名称<code class="fe mv mw mx my b">demo-sa</code>。正如我们在上面看到的，如果在Pod规范中没有指定<code class="fe mv mw mx my b">serviceAccountName</code>，则使用名称空间的默认ServiceAccount。</p><p id="91cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们对<code class="fe mv mw mx my b">pod-default</code> Pod所做的那样，我们现在在Pod <code class="fe mv mw mx my b">pod-demo-sa</code>的<code class="fe mv mw mx my b">alpine</code>容器中运行一个shell，获取属于<code class="fe mv mw mx my b">demo-sa</code> ServiceAccount的令牌，并使用它来查询默认名称空间中的Pod列表。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="e443" class="nr lz it my b gy ns nt l nu nv"># Get the ServiceAccount token from within the Pod's container<br/>/ # TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)</span><span id="4cb8" class="nr lz it my b gy ok nt l nu nv"># Call an API Server's endpoint (using the ClusterIP kubernetes service) to get all the Pods running in the default namespace<br/>/ # curl -H “Authorization: Bearer $TOKEN” <a class="ae lq" href="https://kubernetes/api/v1/namespaces/default/pods/" rel="noopener ugc nofollow" target="_blank">https://kubernetes/api/v1/namespaces/default/pods/</a> --insecure</span></pre><p id="b890" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这次不会再出现错误，因为ServiceAccount有权执行此操作。我们得到一个在默认名称空间中运行的pod列表。</p><pre class="kj kk kl km gt nn my no np aw nq bi"><span id="fa4c" class="nr lz it my b gy ns nt l nu nv">{<br/>  "kind": "PodList",<br/>  "apiVersion": "v1",<br/>  "metadata": {<br/>    "selfLink": "/api/v1/namespaces/default/pods/",<br/>    "resourceVersion": "96296"<br/>  },<br/>  "items": [<br/>    ...<br/>  ]<br/>}</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="567f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">主要要点</h1><p id="476b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">默认情况下，每个Pod都可以与运行它的集群的API服务器进行通信。如果未指定ServiceAccount，它将使用其命名空间的默认ServiceAccount。由于默认的ServiceAccount只有有限的权限，因此通常最佳做法是为每个应用程序创建一个service account，赋予它所需的权限(仅此而已)。</p><p id="1b62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了对API服务器进行身份验证，Pod使用附加ServiceAccount的令牌。这个令牌在Pod的每个容器的文件系统中都是可用的。</p><p id="ac16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们使用了<code class="fe mv mw mx my b">curl</code>来查询API服务器的HTTP端点。真正的应用程序显然会使用专用的库——其中几个库有不同的语言版本。</p></div></div>    
</body>
</html>