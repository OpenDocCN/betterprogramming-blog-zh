<html>
<head>
<title>Build a Reusable CollectionView With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI构建可重用的集合视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reusable-collection-view-with-swiftui-118f8c72730?source=collection_archive---------0-----------------------#2020-01-01">https://betterprogramming.pub/reusable-collection-view-with-swiftui-118f8c72730?source=collection_archive---------0-----------------------#2020-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="280e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI中缺少CollectionViews，但下面是我们如何轻松构建自己的视图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f199e8f4d94ea02252e805ffe7a8456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYg7JIgUQ0VEfnJShsnk6Q.png"/></div></div></figure><p id="e755" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着SwiftUI的引入，构建可重用视图变得异常简单。SwiftUI的视图构建器允许我们将视图嵌入到其他视图中(如VStack、HStack等)。</p><p id="da9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天我们将通过构建一个简单的<code class="fe lq lr ls lt b">Collection</code>视图来展示这一功能。以上是我们将要构建的内容(卡片可以替换为任何数据阵列和卡片视图)</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0e11" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">入门指南</h1><p id="c627" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">首先，创建一个名为<code class="fe lq lr ls lt b">Collection</code>的新SwiftUI视图。首先，我们需要添加一些通用约束:</p><ul class=""><li id="f345" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">Content</strong></code> ( <code class="fe lq lr ls lt b">View</code>)将代表我们在集合单元格中嵌套的任何视图类型</li><li id="9465" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">Data</strong></code> ( <code class="fe lq lr ls lt b">Hashable</code>)将代表我们收集的数据来源</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="43f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将添加一些属性和一个初始化器。</p><ul class=""><li id="2349" class="my mz it kw b kx ky la lb ld na lh nb ll nc lp nd ne nf ng bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">data</strong></code> ( <code class="fe lq lr ls lt b">Binding&lt;[Data]&gt;</code>)将是提供给<code class="fe lq lr ls lt b">Collection</code>视图的数据。我们在这里使用一个绑定来确保任何变化都反映在我们的<code class="fe lq lr ls lt b">Collection</code>视图中。</li><li id="6cf7" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">viewBuilder</strong></code> ( <code class="fe lq lr ls lt b">(Data) -&gt; Content</code>)将返回我们嵌入到<code class="fe lq lr ls lt b">Collection</code>单元格中的视图</li><li id="2d52" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">cols</strong></code> ( <code class="fe lq lr ls lt b">Int</code>)是我们要显示的列数</li><li id="59a2" class="my mz it kw b kx nh la ni ld nj lh nk ll nl lp nd ne nf ng bi translated"><code class="fe lq lr ls lt b"><strong class="kw iu">spacing</strong></code> ( <code class="fe lq lr ls lt b">CGFloat</code>)是我们想要的单元格间距(垂直和水平)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="43c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们添加一个助手函数来标识一个数据项，给定一个特定的行和列，并使用我们的<code class="fe lq lr ls lt b">viewBuilder</code>将它作为<code class="fe lq lr ls lt b">View</code>返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b5c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来让我们画出我们的<code class="fe lq lr ls lt b">Collection</code>。</p><p id="f58e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先需要一个<code class="fe lq lr ls lt b">GeometryReader</code> <em class="no"> </em>来给我们一个<code class="fe lq lr ls lt b">View</code>框架，这样我们就可以计算出<code class="fe lq lr ls lt b">ScrollView</code>中内容的最大单元格宽度和最小高度。<code class="fe lq lr ls lt b">ScrollView</code>内容是使用辅助函数<em class="no"> </em> <code class="fe lq lr ls lt b">setupView(geometry:)</code>绘制的。</p><p id="14b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们简单地创建了两个栈来迭代我们的行和列索引。这样，我们可以使用每个索引组合，通过辅助函数<code class="fe lq lr ls lt b">cell(rowIndex:, colIndex:)</code>返回我们的单元格。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fb33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就完成了我们的<code class="fe lq lr ls lt b">Collection</code>组件。现在，让我们将它添加到我们的<code class="fe lq lr ls lt b">ContentView.swift</code>中来看看它的运行情况。</p><p id="4583" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面，我们将一组颜色传递给组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0cd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们为每种颜色添加一些显示在<code class="fe lq lr ls lt b">Collection</code>视图中的单元格内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3f2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就完成了！</p></div></div>    
</body>
</html>