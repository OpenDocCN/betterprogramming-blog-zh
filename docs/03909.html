<html>
<head>
<title>Why Smart Engineers Do Stupid Things: Local vs. Global Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么聪明的工程师做蠢事:局部优化与全局优化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-smart-engineers-do-stupid-things-local-vs-global-optimization-7bf769c04832?source=collection_archive---------15-----------------------#2020-03-11">https://betterprogramming.pub/why-smart-engineers-do-stupid-things-local-vs-global-optimization-7bf769c04832?source=collection_archive---------15-----------------------#2020-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="53a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">获得5000万美元收入的经验教训</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f440890e0fc03230b503a9aca9b354ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7TnEuCuNu8C_q4chqvxLg.png"/></div></div></figure><h1 id="7f7b" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="b5ea" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你像我一样，你会遭受建议疲劳。关于过程和管理的文章太多了，不可能全部读完，更不用说决定遵循哪一篇了。</p><p id="29fd" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我发现，在过去的几年里，Collage.com的收入从零增长到5000万美元的原因是流程来来去去，但聪明的工程师做蠢事的原因更永恒、更普遍。如果你明白聪明人是如何通过一系列看似合理的决策把事情搞砸的，那么你就会知道什么时候你需要一个管理解决方案，以及当前的流程是否可行。</p><p id="2275" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">本文的主题是局部优化与全局优化。当软件是全新的并且由一个小团队管理时，很容易做出好的决策。</p><p id="a1d9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这个阶段，代码库很小，你不会考虑未来，因为你只是想起步。随着团队的成长和产品的成熟，做决策时越来越难看到全局。当局部目标与全局优先级一致时，这是好的，比如编写高质量的代码。然而，随着时间的推移，当推断到更广泛的背景时，最好的本地决策有时可能是有害的。</p><p id="1d44" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这里，我们将看看这个问题可能出现的几种常见方式。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="e4d5" class="kr ks iq bd kt ku ms kw kx ky mt la lb jw mu jx ld jz mv ka lf kc mw kd lh li bi translated">降低一致性与灵活性的比重</h1><p id="910d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当面临一个问题时，工程师喜欢寻找最佳解决方案。然而，这通常需要复杂的分析。另一种方法是应用一种通用的启发式方法，这种方法平均来说效果很好，但不一定总是最好的。</p><p id="2c4c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这种情况在软件开发指南中经常出现。为情有可原的情况破例是很诱人的——但是这样做会削弱一致性。这种做法的成本可能很难把握，因为其影响往往是微妙而长期的，而灵活性的好处则更加明显和直接。</p><p id="79ee" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在过去，我们在Collage.com没有一个规则，关于为新特性增加多少回归测试覆盖率。我们让每个开发人员自行决定是从一开始就添加完整的覆盖，还是以手工测试开始，并计划以后添加自动化测试。</p><p id="549f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这种灵活性对于解决我们的测试基础设施中可能严重延迟项目的问题是很有价值的。如果手工测试是彻底的，提前几天或几周发布可以帮助我们更快地迭代，而不会产生更多的错误。与此同时，我们仍然在大多数情况下在推出前添加了回归测试。</p><p id="fef3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">虽然测试覆盖的灵活性使得更好的局部决策成为可能，但是它所产生的不一致性随着时间的推移会造成很大的损失。首先，只有当人们真正做出正确的决定时，灵活性才会更好；经验不足的工程师可能会犯更多的错误。为了使决策灵活性有价值，必须指定谁可以做决策，培训那些人，建立评审过程，并评估决策质量作为绩效评审的一部分。在一天结束的时候，我们团队中的人有时会对测试覆盖率做出错误的判断，并且需要花费大量的精力来管理这种灵活性。</p><p id="77ae" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">灵活性的另一个代价是它会导致更多的决策开销，这些开销以讨论和决策文档的形式出现。我们的团队花了很多时间来讨论每个任务的自动化测试是否是最好的。然后，我们不得不记录是否在我们的问题跟踪系统中编写测试，这为误解创造了另一个机会。</p><p id="db3b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当人们对工程和产品的目标有不同程度的理解时，这些讨论也是有争议的。它们经常演变成质量和速度价值之间更广泛分歧的代表。</p><p id="9f71" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">由于引入了额外的变量，测试自动化缺乏可预测性也使得评估更加困难。因为测试自动化是可选的，不同的人的估计包含了不同的关于测试工作范围的隐含假设。这进一步使决策变得复杂，因为我们经常通过不估计测试自动化的时间来为自己制造人为的时间压力，这导致了更少的测试。</p><p id="3bf4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这种特殊类型的灵活性也造成了积压问题，因为它允许推迟工作。如果你把一项任务放在待办事项中，管理起来并不困难，也不像是一个负担。然而，随着时间的推移，以非线性的方式重复做这件事会变得更加昂贵，因为每一次处理backlog都会变得越来越耗时。此外，任务在待办事项列表中的时间越长，就越有可能变得陈旧。任何积压工作比完成工作更快的流程都会产生大量的长期开销。</p><p id="2410" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">可选测试进一步导致了关于修复测试基础设施的糟糕的短期决策。因为不需要测试自动化，所以当有复杂的测试基础设施问题时，我们会避免它。因此，这些重要的问题给每个项目增加了负担，最终，从长远来看，超过了我们节省的时间。</p><p id="386e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当以这种方式呈现时，似乎很明显正确的做法是要求每个项目的测试自动化。然而，我们花了很长时间才做到这一点，并克服了对破坏项目时间表的担忧。为了不太明显的未来利益，很难接受特定项目的明确延迟。</p><p id="0b86" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了识别团队中不良的一致性与灵活性之间的权衡，并打破短期思维模式，请考虑以下问题:</p><ul class=""><li id="e298" class="mx my iq ll b lm mf lp mg ls mz lw na ma nb me nc nd ne nf bi translated">在不同的情境下，人们花最多的时间反复讨论哪些决策？这些决定是否可以被大多数时候导致相同答案的简单准则所取代？</li><li id="9d18" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">如果不同的个人或团队被赋予相同的任务，他们会有什么不同？这种缺乏可预测性给其他人带来了多大的代价？</li><li id="4159" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">您是否在某些地方积累了大量的修复工作？这可能是一个糟糕的短期优化，最好是马上做这些事情，或者立即决定它们不值得做。</li><li id="9488" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">在你的团队中，人们有多频繁地违反指导方针？这些例外是明智的吗，还是会导致长期成本超过短期收益？</li><li id="7c46" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">特定的人是否对过程的长期结果负责，并被授权做出短期牺牲来实现这些结果？</li><li id="b9f3" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">你团队中的每个人都可以解释流程要解决的长期问题吗？有没有可靠的途径让新人了解这些问题？如果没有，那么人们可能会对那些过程做出糟糕的例外。</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="db75" class="kr ks iq bd kt ku ms kw kx ky mt la lb jw mu jx ld jz mv ka lf kc mw kd lh li bi translated">忽略总成本和收益</h1><p id="766a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">明智的地方决策可能导致糟糕的全球结果的另一种方式是，重大成本或收益只会产生总体影响。因为没有一个单一的决定会打破平衡，所以人们在做每个决定时不会考虑总体效应。</p><p id="f801" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">也许软件工程中最常见的综合效应是使用特定技术或方法的固定成本，这进一步增加了成本。</p><p id="eb3d" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">例如，考虑编程语言。每种语言都需要招聘懂该语言的工程师，建立培训项目，创建开发实践，购买工具，管理知识等。拥有多种语言也使得为项目分配开发人员变得更加困难。即使一种不同语言的少量代码也会导致巨大的全球固定成本，完全消除一种语言将会节省大量成本。</p><p id="69e5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">同样的原则也适用于使用其他技术和实践，比如不同的库或框架、操作系统，甚至敏捷规划过程。</p><p id="0fe1" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">对于工程团队来说，保持最佳实践是一场持续的战斗。当您有一个大的代码库时，这尤其具有挑战性，这通常使得一次性迁移到一项新技术不切实际。处理这个问题的常见方法是逐步重构代码，一点一点地移动代码。因为重构的主要好处是降低维护开销，所以优先考虑需要最多维护的模块是有意义的。</p><p id="7288" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这种增量方法的问题是，您可能会陷入一种从未重构最少使用的模块的境地。如果你孤立地看待其中一个，未来节省的成本可能不会超过重构的成本。然而，保留下来的旧代码越少，维护每一部分的成本就越大，因为拥有这方面专业知识的人越少。</p><p id="eb29" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">此外，新旧代码并存极大地增加了整体复杂性。如果旧代码停留了很长时间，公共文档、支持以及愿意并能够从事这些工作的开发人员就会变得越来越少。这造成了一个更大的洞，使得挖掘的努力不那么吸引人，尽管有持续的维护负担。如果没有人着眼于大局，合理的地方决策可能会导致巨大的全球成本和深深的遗憾。</p><p id="c30a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们在Collage.com的一些领域遇到了这个问题，但是最大的代价是五年来忽视重构我们的相册代码。在此期间，相册已经占到我们收入的10%左右，并且拥有一些最复杂的用户界面。我们有更好的机会用更少的努力改进其他产品，所以产品经理决定不在书上工作。到了重构决策的时候，我们避免了相册，因为由于缺乏未来的产品计划，估计的收益不会很高。</p><p id="fcbd" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们的第一个错误是当我们修改其他区域时，没有考虑测试和修复bug的开销。因为这本书的代码很复杂，结构很差，而且回归测试有限，所以它总是因为不相关的变化而出错。由于我们没有更新代码，所以没有人熟悉代码，这加剧了问题的严重性。这对于不得不花大量时间测试和调试旧代码的新开发人员来说尤其痛苦。</p><p id="e9ab" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">虽然我们有几年没有给我们的book builder添加新的功能，但更新它最终成为了一个优先事项。到这个时候，领导这个项目的人除了修复一些bug之外，从来没有处理过代码，而最初编写它的人(我！)无法提供帮助。这段代码的大量问题使得重构非常耗时。</p><p id="f7ca" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">随着多年的错误修复和测试，清理这些代码需要付出比保持代码更新更多的努力。我们为避免这种情况而做出的每一个决定，单独来看似乎都是合理的，但技术债务的滑坡最终让我们付出了沉重的代价。</p><p id="e3c3" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">以下是一些需要考虑的问题，以避免陷入忽视总体效应的陷阱:</p><ul class=""><li id="b63f" class="mx my iq ll b lm mf lp mg ls mz lw na ma nb me nc nd ne nf bi translated">是否有一个人明确负责整个软件栈的长期维护成本？此人是否有权优先考虑对单个团队来说不值得但对整个公司有益的改进？</li><li id="9501" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">对于您不打算更新的代码模块和系统，相对于它们被完全抛弃的可能性，更新它们在未来成为优先事项的可能性有多大？</li><li id="3e2c" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">落后的模块和系统有多孤立？它们真的有很低的维护成本吗，或者在对不相关的代码进行修改时，它们需要频繁的错误修复和测试吗？</li><li id="aa20" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">随着时间的推移，由于缺乏开发人员知识和公众支持，哪些仍在使用的旧技术将变得更难使用？如果现有员工离职，而你不得不雇佣新员工来管理他们，哪一个会是最大的问题？</li><li id="de62" class="mx my iq ll b lm ng lp nh ls ni lw nj ma nk me nc nd ne nf bi translated">为同一目的使用多种技术或方法会增加整体代码的复杂性，这种情况在哪里呢？</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="5050" class="kr ks iq bd kt ku ms kw kx ky mt la lb jw mu jx ld jz mv ka lf kc mw kd lh li bi translated">最后一个音符</h1><p id="6d48" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在本文中，我们主要关注本地与。全局优化，并介绍了人们做出错误决策的几种方式。虽然这些例子有望防止某些错误，但它们并不全面。</p><p id="1b55" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在以后的文章中，我希望探索其他导致聪明的工程师做蠢事的场景。我渴望听到关于这些例子的反馈或对未来主题的建议。感谢您的阅读！</p></div></div>    
</body>
</html>