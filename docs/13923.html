<html>
<head>
<title>Migrating a Node.js App to Cloudflare Workers From Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Node.js应用程序从Heroku迁移到Cloudflare Workers</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/migrating-a-node-js-app-to-cloudflare-workers-from-heroku-62c679552af?source=collection_archive---------4-----------------------#2022-10-14">https://betterprogramming.pub/migrating-a-node-js-app-to-cloudflare-workers-from-heroku-62c679552af?source=collection_archive---------4-----------------------#2022-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="106e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为Cloudflare工作人员重新设计Node.js/MongoDB应用程序，以及我在开始时没有意识到的事情</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/61defbe5acca43a48839171d04dce16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHas2c6hyXVh-aRhRMGPTw.png"/></div></div></figure><blockquote class="kr ks kt"><p id="52ca" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第1部分:将Node.js应用从Heroku </strong> <br/>迁移到Cloudflare Workers第2部分:<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/in-memory-database-for-cloudflare-workers-b9c61810ef37">使用Upstash的Cloudflare Workers内存数据库</a> <br/>第3部分:在Cloudflare Workers中使用Cloudflare KV数据存储(进行中)<br/>第4部分:Cloudflare Workers的调试和日志管理(进行中)</p></blockquote><p id="3e19" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">注意:<a class="ae lr" href="https://www.cloudflare.com/products/workers/" rel="noopener ugc nofollow" target="_blank"> Cloudflare Workers </a>绝对不是Heroku的直接替代品。如果我们希望对Node.js应用程序进行最小的调整，<a class="ae lr" href="https://cloud.google.com/appengine" rel="noopener ugc nofollow" target="_blank">谷歌云应用程序引擎</a>可能是更好的选择。</p><h1 id="81ec" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">介绍</h1><p id="4dd0" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">很长一段时间以来，Heroku一直是我托管我的兼职项目的默认选择，因为它方便易用。可悲的是，Heroku将很快停止其免费产品计划。这篇文章是为了记录我将我的一个副业项目- <a class="ae lr" href="https://medium-rare.vercel.app/" rel="noopener ugc nofollow" target="_blank">中稀有</a> (MR)迁移到<a class="ae lr" href="https://www.cloudflare.com/products/workers/" rel="noopener ugc nofollow" target="_blank"> Cloudflare Workers </a>的经历👷🏻。</p><blockquote class="kr ks kt"><p id="6860" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://medium-rare.vercel.app/" rel="noopener ugc nofollow" target="_blank">中稀</a> (MR)是一款web app，在中稀平台上索引和分发中文文章。目前它只支持中文。我的动机来自于这样一个事实，即Medium只主要支持英文文章，而非英文文章的发行几乎没有。</p></blockquote><p id="e682" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">MR后端相当简单。它只有3个端点。它正在连接一个MongoDB。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="798a" class="mx lw iq mt b gy my mz l na nb">1. GET /articles<br/>2. GET /writers<br/>3. POST /articles/read</span></pre><p id="e0d4" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">我们以<code class="fe nc nd ne mt b">GET /articles</code>为例。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="8340" class="lv lw iq bd lx ly nm ma mb mc nn me mf jw no jx mh jz np ka mj kc nq kd ml mm bi translated">重新设计应用程序</h1><p id="d7e6" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">有两个方面——路由和数据库连接，需要进行调整以使我们的应用适合Cloudflare工作人员。</p><h2 id="f69e" class="mx lw iq bd lx nr ns dn mb nt nu dp mf ls nv nw mh lt nx ny mj lu nz oa ml ob bi translated"><strong class="ak"> 1。路由</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="93d3" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">上面是用Express.js编写的演示<code class="fe nc nd ne mt b">GET /articles</code> API。如果我们想在CF Workers中实现类似的东西，下面是它的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b512" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">使用原生CF Workers <a class="ae lr" href="https://developers.cloudflare.com/workers/runtime-apis/fetch-event/" rel="noopener ugc nofollow" target="_blank"> fetch event </a>运行时API似乎对开发者并不友好。幸运的是，有一些路由库支持CF Workers，例如<a class="ae lr" href="https://www.npmjs.com/package/itty-router" rel="noopener ugc nofollow" target="_blank"> itty-router </a>和<a class="ae lr" href="https://honojs.dev/" rel="noopener ugc nofollow" target="_blank"> Hono </a>。我发现自己倾向于Hono，这是它的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="1d1f" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">噪音。有家的感觉！</p><h2 id="6d5c" class="mx lw iq bd lx nr ns dn mb nt nu dp mf ls nv nw mh lt nx ny mj lu nz oa ml ob bi translated"><strong class="ak"> 2。数据库连接</strong></h2><p id="ea61" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">当我们使用CF Workers时，我们不能用驱动程序直接连接到我们的MongoDB。相反，<a class="ae lr" href="https://blog.cloudflare.com/workers-adds-support-for-two-modern-data-platforms-mongodb-atlas-and-prisma/" rel="noopener ugc nofollow" target="_blank"> CF Workers的策略是支持可以通过HTTP </a>连接的数据库，MongoDB现在提供了数据API，让您<a class="ae lr" href="https://www.mongodb.com/docs/atlas/api/data-api/" rel="noopener ugc nofollow" target="_blank">通过标准HTTPS请求来读取或写入数据</a>！</p><blockquote class="kr ks kt"><p id="6600" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺便说一下，我创建了<a class="ae lr" href="https://github.com/patrick-kw-chiu/mongo-http.js" rel="noopener ugc nofollow" target="_blank">mongo-http . js</a>——一个关于<a class="ae lr" href="https://www.mongodb.com/docs/atlas/api/data-api/" rel="noopener ugc nofollow" target="_blank"> Mongodb Atlas数据API </a>的瘦包装器，它提供了与<a class="ae lr" href="https://www.npmjs.com/package/mongodb" rel="noopener ugc nofollow" target="_blank"> Mongodb Node.js驱动</a>类似的API。</p></blockquote><p id="b45e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">回到我们最初的数据库查询，它可能看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="596a" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">当我们使用MongoDB数据API时，应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="56a3" class="lv lw iq bd lx ly nm ma mb mc nn me mf jw no jx mh jz np ka mj kc nq kd ml mm bi translated">我不知道的事情</h1><p id="e54b" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated"><strong class="kx ir"> 1。环境变量是</strong> <a class="ae lr" href="https://developers.cloudflare.com/workers/runtime-apis/fetch-event/#parameters" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">沿着上下文/请求</strong> </a> <strong class="kx ir">传递，而不是从上面数据库连接部分的</strong> <code class="fe nc nd ne mt b"><strong class="kx ir">process.env </strong></code> <strong class="kx ir"> — </strong>中获取，我们使用<code class="fe nc nd ne mt b">MONGODB_URL</code>和<code class="fe nc nd ne mt b">MONGODB_API_KEY</code>向MongoDB数据API发出HTTPS请求。如果使用本机<a class="ae lr" href="https://developers.cloudflare.com/workers/runtime-apis/fetch-event/" rel="noopener ugc nofollow" target="_blank">获取事件</a>运行时API，它将在参数中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="7e04" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">在Hono中，<code class="fe nc nd ne mt b">env</code>在<code class="fe nc nd ne mt b">context</code>参数中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8e81" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir"> 2。</strong> <code class="fe nc nd ne mt b"><strong class="kx ir">wrangler.toml</strong></code> <strong class="kx ir">中环境变量的更新需要</strong> <code class="fe nc nd ne mt b"><strong class="kx ir">wrangler publish</strong></code> <strong class="kx ir">才能生效— </strong>我原本以为<code class="fe nc nd ne mt b">wrangler dev</code>是从<code class="fe nc nd ne mt b">wrangler.toml</code>中抓取环境变量。看起来它是从云中的实际CF工作者那里获取的。这也导致了第三点。</p><p id="6833" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir"> 3。</strong> <code class="fe nc nd ne mt b"><strong class="kx ir">wrangler dev</strong></code> <strong class="kx ir">也在使用你的请求配额——</strong>原来，如果我们想要完全本地化发展，我们应该使用<a class="ae lr" href="https://github.com/cloudflare/miniflare" rel="noopener ugc nofollow" target="_blank">的迷你照明弹</a>。这也导致了#4(最后一个)。</p><p id="d721" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated"><strong class="kx ir"> 4。如果您有</strong> <code class="fe nc nd ne mt b"><strong class="kx ir">wrangler publish</strong></code> <strong class="kx ir">多个环境，那么对“本地”服务器的每个API调用都将使用来自每个环境的1个请求——例如，如果您有<code class="fe nc nd ne mt b">wrangler publish</code>个环境<code class="fe nc nd ne mt b">api-dev</code>、<code class="fe nc nd ne mt b">api-staging</code>和<code class="fe nc nd ne mt b">api-production</code>，并且您用<code class="fe nc nd ne mt b">wrangler dev</code>启动了一个“本地”服务器。然后你向“本地”服务器发出一个请求，它将用完3个请求配额。</strong></p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="cbda" class="lv lw iq bd lx ly nm ma mb mc nn me mf jw no jx mh jz np ka mj kc nq kd ml mm bi translated">收场白</h1><p id="f7b4" class="pw-post-body-paragraph ku kv iq kx b ky mn jr la lb mo ju ld ls mp lg lh lt mq lk ll lu mr lo lp lq ij bi translated">有几件事我还没有涉及到——调试和日志记录。总之调试体验很棒，因为CF Workers的Devtools在用浏览器的Devtools。对于日志，CF Workers有一个<a class="ae lr" href="https://developers.cloudflare.com/workers/learning/logging-workers/#view-logs-from-the-dashboard" rel="noopener ugc nofollow" target="_blank">日志流仪表板</a>用于实时日志，而我们需要“自带日志服务”来保存日志。</p><p id="c172" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld ls lf lg lh lt lj lk ll lu ln lo lp lq ij bi translated">总的来说，在CF Workers上开发是一个很棒的开发者体验。当我把更多的副业项目迁移给CF工作者时，我期待着探索更多！</p></div></div>    
</body>
</html>