<html>
<head>
<title>How To Create a Universal Backend With Symfony</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Symfony创建一个通用后端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graphql-api-symphony-mongodb-c866a79fdf48?source=collection_archive---------6-----------------------#2021-04-16">https://betterprogramming.pub/graphql-api-symphony-mongodb-c866a79fdf48?source=collection_archive---------6-----------------------#2021-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a55e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解使用GraphQL、Symfony和MongoDB可以做什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e67c9c46ea36145167a4190e64f59e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwJ8R4x1diXB5IVb_be0jA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德烈亚斯·M在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="9c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2021年，没有再发明轮子的空间了。开发是一门艺术，它越来越依赖于挑选和组装策略，而不是从零开始开发。按照这种趋势，仅仅为了读写数据而写代码是一个乱糟糟的时代。这可能就是为什么无头CMS解决方案在过去几年里一直在传播的原因，而SaaS的采用是迁移到云的最常见的方式。</p><p id="73d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，我们经常不得不对抗复杂的业务逻辑或复杂的集成，并且我们需要编写定制代码的灵活性。</p><p id="3dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看到如何使用<a class="lv lw ep" href="https://medium.com/u/56007848df01?source=post_page-----c866a79fdf48--------------------------------" rel="noopener" target="_blank"> Symfony </a>和<a class="lv lw ep" href="https://medium.com/u/db5cd12199bd?source=post_page-----c866a79fdf48--------------------------------" rel="noopener" target="_blank"> MongoDB </a>从头开始创建一个无头CMS。这个项目的输出是一个可以作为composer包安装的工作应用程序，您可以使用它作为实现您的应用程序的基础(是的，轻松应用定制业务逻辑)！</p><p id="b0d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅是实现数据服务的一种有趣方式，也是Symfony框架的一个很好的展示。正如我在我的<a class="ae ky" href="https://towardsdatascience.com/how-i-wasted-two-years-in-opensource-development-9be71491ce62?sk=225ba4fd88e40549e1d47ebc73adf8d0" rel="noopener" target="_blank">上一篇文章</a>中提到的，我完全重写了一个完整的无头低代码平台CMS(之前是在。NET)用Symfony只用了两天。是的，两年对两天！</p><p id="3659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将展示我的工作，并解释这是如何由于该框架的本机特性而成为可能的。</p><p id="5ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在本文末尾找到完整源代码的参考。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="ff8c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">建筑</h1><p id="8ddf" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我创建的平台具备所有这些特性:</p><ul class=""><li id="aa2d" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">无需编写一行代码就能在数据上创建REST和GraphQL APIs。</li><li id="f156" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">通过简单地进入管理UI并编写它来创建自定义端点。</li><li id="3d9e" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">使用外部身份验证机制或自托管Oauth2提供程序。</li><li id="bd19" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">让用户通过实现他们自己的代码(控制器、作业等)来扩展平台。)在模块中。</li></ul><p id="2315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的架构如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/3bc54ccd567507e0438506ef6b70436e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clhoL15gba2SOvcijAvPUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通用后端架构</p></figure><p id="e2bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此图中，我们可以看到完整的应用程序架构，包括:</p><ul class=""><li id="eb28" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated">自动化维护活动的控制台工具</li><li id="b30f" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">依赖Oaut2的身份验证引擎</li><li id="1df6" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">用于简单老式API的REST API控制器</li><li id="996a" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">现代应用程序的GraphQL端点</li><li id="ce1c" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">用于访问数据库的数据管理引擎</li></ul><p id="1110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文围绕通用数据访问展开。因此，我们将重点关注数据引擎、数据接口(API和REST)和身份验证。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="08a7" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">垃圾服务</h1><p id="9ade" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">要描述的第一个元素是CRUD服务。CRUD服务负责向集合数据库读写数据。为了保持所有系统数据库的独立性，并允许最终用户定制所有与数据相关的行为，该平台基于由抽象类实现的通用接口。</p><p id="4b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段显示了<code class="fe nq nr ns nt b">ICrudService</code>界面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ee3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们对每种方法都有一个标准的实现。我们以<code class="fe nq nr ns nt b">add</code>和<code class="fe nq nr ns nt b">get</code>方法为例。那么所有其他的或多或少都是一样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的代码片段中，我们可以理解<code class="fe nq nr ns nt b">add</code>和<code class="fe nq nr ns nt b">get</code>方法是如何工作的:它们将数据库名称和集合作为参数，并通过包装MongoDB APIs对数据进行操作。</p><p id="2bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经发现了数据引擎是如何工作的，那么是时候将该特性公开为常规的REST APIs了。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="ad8f" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">REST API控制器</h1><p id="87f2" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在上一节中，我们发现了数据引擎是如何工作的。现在我们可以通过REST APIs公开该服务。第一步是创建一个常规的Symfony控制器，并为每个服务方法添加一个方法。产生的类显示在下一个代码片段中。和前面的例子一样，我只关注了<code class="fe nq nr ns nt b">add</code>和<code class="fe nq nr ns nt b">get</code>方法，但是其他方法都以同样的方式工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的代码片段中，我从URL路径中获取DB和collection参数，并包装服务方法。因此，当调用<code class="fe nq nr ns nt b">/api/data/mydb/mycoll/xyz</code>时，服务将在包含在<code class="fe nq nr ns nt b">mydb</code>数据库中的名为<code class="fe nq nr ns nt b">mycoll</code>的集合中查找ID为<code class="fe nq nr ns nt b">mydb</code>的记录。</p><p id="6108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们有机会不受任何限制地读写数据。我们只需要进行API调用来实现任何逻辑。这是非常灵活和强大的——也许太多了。事实上，我们错过了身份验证层和拥有数据验证层的机会。我们将在本文后面讨论身份验证。就数据建模图像而言，有一个收集实体定义的集合。这个集合叫做<code class="fe nq nr ns nt b">_schema</code>，可以使用常规API编写。每个项目都包含字段列表、字段类型和有效性规则。单个项目的示例如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a57f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经理解了REST APIs公开数据的可能性，我们就可以讨论GraphQL格式了。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="7474" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">GraphQL端点</h1><p id="4d7b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">GraphQL现在是最常见的API标准，它在过去几年中的发展让我们认为它在未来会被越来越多地使用。所以，我们必须用它来公开数据。</p><p id="861e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一段代码展示了一个PHP查询实现的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的代码中，我们看到了如何定义主<code class="fe nq nr ns nt b">Query</code>对象来获取名为<code class="fe nq nr ns nt b">hero</code>的实体。<code class="fe nq nr ns nt b">type</code>字段是另一个<code class="fe nq nr ns nt b">ObjectType</code>，我们在这里和<code class="fe nq nr ns nt b">field compose</code>解释<code class="fe nq nr ns nt b">hero</code>类。这看起来有些棘手，但这就是GraphQL的工作方式。事实上，GraphQL看不出实体和查询之间的区别，为每个实体添加一个list类型的“字段”并用查询来解决它是很常见的。因此，我们将有一个名为<code class="fe nq nr ns nt b">Query</code>的主<code class="fe nq nr ns nt b">ObjectType</code>，它为数据库中的每个集合提供一个字段，每个集合都有一个用另一个<code class="fe nq nr ns nt b">ObjectType</code>实例定义的条目结构。</p><p id="a3e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ApiFarm案例中，我们必须:</p><ol class=""><li id="6971" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu nw nh ni nj bi translated">为数据库中的每个集合创建一个<code class="fe nq nr ns nt b">ObjectType</code>。这代表真正的实体，并具有所有的字段定义(名称、类型等。).</li><li id="c63b" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu nw nh ni nj bi translated">为所有实体创建一个名为<code class="fe nq nr ns nt b">ObjectType</code>的包装器，其中每个集合有一个假字段。</li></ol><p id="46bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们可以访问数据库中的任何实体，用<code class="fe nq nr ns nt b">field retrieve</code>选择并传递分页信息作为参数。</p><p id="bf58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的过程很长，但是你可以在GitHub的<a class="ae ky" href="https://github.com/zeppaman/api-farm/blob/main/bundle/CoreBundle/Controller/GraphQLController.php" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>控制器中找到它。无论如何，重要的是要知道这只是一个到模式定义的循环，它生成所有的实体定义，然后包装整个<code class="fe nq nr ns nt b">Query</code>对象。</p><p id="a503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以将数据库作为常规的GraphQL资源进行查询。在下面的代码片段中，您可以看到如何使用分页并只选择一些属性来查询<code class="fe nq nr ns nt b">product</code>实体。</p><pre class="kj kk kl km gt nx nt ny nz aw oa bi"><span id="e076" class="ob mf it nt b gy oc od l oe of">query { <br/>  product(skip: 10, limit: 20){<br/>      _id,<br/>      sku,<br/>      price<br/>  }<br/>}</span></pre><p id="fd48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="207c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步非常重要，因为它简化了与第三方应用程序的集成，并帮助前端开发人员探索和测试他们的API。现在，在测试之前，我们必须讨论最后一点:身份验证！</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="ac7e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">认证</h1><p id="0a77" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">到目前为止，我们所看到的一切都非常有趣，但API对世界开放，它不是安全的最佳选择。这里我们要做的是接受一个认证标准，并让应用程序知道谁是谁。第一步是激活Oauth2服务器。如果您已经有一个外部Oauth2服务器，就可以避免这种情况。我使用的PHP库是<a class="ae ky" href="https://github.com/trikoder/oauth2-bundle" rel="noopener ugc nofollow" target="_blank"> Trikoder Oauth2 </a>，这是一个Symfony包，包含了最重要的Oauth2选项。</p><p id="f394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的设置中，唯一的问题是它只支持使用教条作为ORM的传统数据库。因此，我所做的是实现一个不同的用户提供者来从MongoDB集合中读取用户，并实现第二个类来验证密码。</p><p id="f2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一段代码是<code class="fe nq nr ns nt b">UserProvider</code>的实现。它负责从数据库中读取用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的代码检查用户是来自本地服务器(独立模式)还是来自不同的Oauth2服务器。在第一种情况下，数据直接取自本地数据库。在第二个示例中，调用OpenId端点，数据用于扩展用户有效负载。</p><p id="7ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在独立模式下工作的最后一步是验证密码。假设您将用户存储在一个集合中，您所要做的就是简单地对密码进行编码和比较。下一个类会这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的代码显示了密码比较过程。如果输入的密码正确，则返回用户，身份验证成功。</p><p id="721e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在这两种情况下，数据都是通过使用本文第一点中实现的CRUD服务来访问的。</p><p id="d464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们只需要配置安全层来保护API，然后我们就可以测试项目了。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="7534" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">看看它的实际效果</h1><p id="0aae" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">第一步是使用内置的控制台应用程序来生成用于身份验证的客户端。这可以通过键入以下命令来完成:</p><pre class="kj kk kl km gt nx nt ny nz aw oa bi"><span id="38d2" class="ob mf it nt b gy oc od l oe of">bin/console trikoder:oauth2:create-client --grant-type password<br/><br/> -------- <br/>  Identifier                 Secret                                                                                                                            <br/> -------------------------- ----------------------------------------<br/> c0a71bf0379c66c46da3e       93656e75c7e8e3bc3b221eca2be796790<br/> -------------------------- ----------------------------------------</span></pre><p id="7a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步是获得一个有效的令牌。您可以使用任何可用的Oauth2授权类型，但是在本例中，我们将使用<code class="fe nq nr ns nt b">password</code>协议。因此，我们需要调用令牌端点，传递凭证和<code class="fe nq nr ns nt b">client_id</code>。下一段代码显示了执行该操作的<code class="fe nq nr ns nt b">curl</code>命令:</p><pre class="kj kk kl km gt nx nt ny nz aw oa bi"><span id="bbb5" class="ob mf it nt b gy oc od l oe of">curl --location --request POST 'localhost/token' \<br/>--header 'Content-Type: application/x-www-form-urlencoded' \<br/>--data-urlencode 'grant_type=password' \<br/>--data-urlencode 'username=bob' \<br/>--data-urlencode 'password=xyz' \<br/>--data-urlencode 'client_id=c0a71bf0379c66c46da3e' \<br/>--data-urlencode 'client_secret=93656e75c7e8e3bc3b221eca2be796790'</span></pre><p id="aa16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Oauth2标准，<code class="fe nq nr ns nt b">curl</code>请求的结果是一个JSON有效负载，您可以在结果中使用token元素将其作为授权头传递。这将验证您的身份，您将得到一个响应，而不是401错误代码。</p><p id="b8c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了填充数据库，我们可以使用控制台应用程序或常规API。你可以在GitHub 上查看完整的API规范<a class="ae ky" href="https://github.com/zeppaman/api-farm" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="da58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以使用REST或GraphQL APIs读取数据，如下例所示:</p><pre class="kj kk kl km gt nx nt ny nz aw oa bi"><span id="7344" class="ob mf it nt b gy oc od l oe of">#get data GraphQL<br/>curl --location --request GET 'localhost/api/graph/test' --header 'Content-Type: application/json' --data-raw '{"query":"query { \r\n  entity1{\r\n      _id,\r\n      title,\r\n      amount\r\n  }\r\n}","variables":{}}'</span><span id="24e5" class="ob mf it nt b gy og od l oe of">#get using REST<br/>curl --location --request GET 'http://localhost/api/data/test/entity1' \<br/>--header 'Authorization: Bearer {token}'</span></pre><p id="1526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，我们已经看到了如何使用测试来使用API，但是您可以想象集成到JavaScript应用程序中也是一样容易的。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="2b38" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">带什么回家</h1><p id="2ae3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在本文中，我们已经看到了通过整合Symfony框架的一些智能特性来实现通用后端是多么容易。</p><p id="f4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，我们已经看到了如何将数据库访问封装到一个服务中，在这个服务中，我们可以集中数据访问逻辑并实现事件监听器和日志记录。此外，这种特性可以使用API公开，实现一个简单的REST API引擎。对于那些寻找更现代的东西的人来说，我们能够使用数据模型定义建立一个GraphQL端点。我们通过添加Oauth2服务器和基于JWT的令牌验证以及用于扩展用户信息的OpenID协议来保护一切。</p><p id="3c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，这一切只花了我两天的工作是了不起的，这是可能的，只有感谢现成的组件与Symfony可用。</p><p id="5a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候下载代码并进行测试了！因此，这里有一个参考列表:</p><ul class=""><li id="e482" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><a class="ae ky" href="https://github.com/zeppaman/api-farm" rel="noopener ugc nofollow" target="_blank">GitHub项目</a></li><li id="1086" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://packagist.org/packages/zeppaman/api-farm" rel="noopener ugc nofollow" target="_blank">包装商参考页</a></li><li id="f71e" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://packagist.org/packages/zeppaman/api-farm-skeleton" rel="noopener ugc nofollow" target="_blank">基于此模板建立新项目的框架项目</a></li><li id="133a" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://symfony.com/" rel="noopener ugc nofollow" target="_blank">Symfony项目主页</a></li></ul></div></div>    
</body>
</html>