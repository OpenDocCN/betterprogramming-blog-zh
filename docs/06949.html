<html>
<head>
<title>Rust Events Revisited</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铁锈事件再探</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-events-revisited-926486721e3f?source=collection_archive---------6-----------------------#2020-11-19">https://betterprogramming.pub/rust-events-revisited-926486721e3f?source=collection_archive---------6-----------------------#2020-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d811" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松编写Rust事件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1b51495c1687028436ba638b7e134c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L7VPdbveNYUB8cY-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rockinrakozy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">J·斯科特·拉科齐</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近写了<a class="ae ky" href="https://medium.com/better-programming/custom-events-in-rust-c4e534b6b8cb" rel="noopener">一篇关于Rust </a>中写事件的文章。我必须承认，我对自己得出的解决方案并不完全满意。我之前的代码使用了一种笨拙的宏捕获模式来定义信号，并产生了不能像事件接收者应该做的那样容易地转换数据的接收者。</p><p id="5f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们必须为我们的每个接收器编写定制的转换——不太符合人体工程学。我决定我可以做得更好！我最终得出的结论是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/7e4e59014f03d03d47b174791c890722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLkeuIVpF2wqb4fETqgnfQ.png"/></div></div></figure><p id="b2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们既可以声明又可以使用发射器和接收器的变量，<code class="fe lw lx ly lz b">emitter1</code>、<code class="fe lw lx ly lz b">r1</code>和<code class="fe lw lx ly lz b">r2</code>。我们可以使用任何名称作为我们的标识符。通过使用重复捕获，我们可以通过将它们与一个独特的闭包配对来拥有多个具有不同功能的接收器。</p><p id="3405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，您使用的类型并不一定存在——我们实际上是通过这个宏创建的。因此，当您声明<code class="fe lw lx ly lz b">MySignal&lt;MySignalReceiver, MySignalData&gt;</code>时，即使这些标识符还不存在，也会通过宏扩展用提供的名称创建它们。</p><p id="0879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个版本似乎更通用，更符合人体工程学。我也采纳了一些评论员的建议，改变了我的命名习惯，使之更具描述性。</p><p id="a12b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从头到尾走一遍我的过程，这既是因为我已经更改了大量代码，也是因为新读者无需阅读我的另一篇Rust events文章就能更容易理解。此外，这篇文章包含了我认为是一个优秀的解决方案。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e04a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">信号和接收器</h1><p id="054a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最好将事件看作是一个<em class="ne">发射器</em>或<em class="ne">信号</em>(发送事件数据)和一个<em class="ne">接收器</em>(对信号发送的数据做一些事情)。我认为实现信号和接收器的最佳方式是使用Rust特性。一、<code class="fe lw lx ly lz b">Receiver</code>特质:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/6566daf8bdd45b89605ecf6bdf1b905f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdUFTaigFAmF1AzizpO2ig.png"/></div></div></figure><p id="f720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定利用特征<code class="fe lw lx ly lz b">type</code>声明。<code class="fe lw lx ly lz b">type Data</code>和<code class="fe lw lx ly lz b">type Transformer</code>仅仅意味着在实现<code class="fe lw lx ly lz b">Receiver</code>的结构中，你必须同时定义<code class="fe lw lx ly lz b">Data</code>和<code class="fe lw lx ly lz b">Transformer</code>类型。</p><p id="1617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Receiver</code>也使用典型的函数定义——在这种情况下，<code class="fe lw lx ly lz b">on_emit</code>是事件被触发时将被调用的函数。它利用了我们的<code class="fe lw lx ly lz b">Self::Data</code>定义——我们定义的类型之一。我们实际上不需要<code class="fe lw lx ly lz b">Receiver</code>的<code class="fe lw lx ly lz b">Transformer</code>类型，但是我们<em class="ne">需要</em>稍后告诉<code class="fe lw lx ly lz b">Signal</code>期望什么类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/db839cc6c51f4e591b2c9de4261f8afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2lu_T6f1VPcMqL9RO1YCQ.png"/></div></div></figure><p id="a892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这里也发生了一些类似的事情。同样，我们使用类型声明，这次我们甚至添加了一个绑定到<code class="fe lw lx ly lz b">RecType</code>的trait，它告诉编译器只接受实现<code class="fe lw lx ly lz b">Receiver</code>的项目。我们在<code class="fe lw lx ly lz b">emit</code>中利用了我们的<code class="fe lw lx ly lz b">Self::Data</code>类型声明。</p><p id="f457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在<code class="fe lw lx ly lz b">connect</code>中发生了一些古怪的事情。为了让我们能够稍后优雅地声明我们的接收者，我们需要指定期望什么类型的闭包。我们将把定义该类型的工作留给实现结构。最后，我们有<code class="fe lw lx ly lz b">disconnect</code>，它用一个<code class="fe lw lx ly lz b">usize</code>表示被断开的接收者的ID。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ba95" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">又大又胖的宏</h1><p id="4a6e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当我第一次决定如何让事件在Rust中工作时，我意识到实现这些特征需要反复使用相同的样板代码。因此，我决定最好的路线将是宏观的方式。</p><p id="ef99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust里的宏其实很棒。它们(粗略地)将类型安全、用户定义的令牌模式转换成Rust代码。作为输入，宏接受在宏调用中提供的令牌流本身。这是非常强大的，随着重复捕获，宏可以让你的生活变得更好。定义宏很简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/8c842742e5d15c9dcd2b6cfd20a0bfef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjyf3INdKTd_OlpiUwRX7Q.png"/></div></div></figure><p id="cb19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要一个匹配臂来实现我们庞大的宏:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/8e9f96d2c3237c8d677771007a616052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33bhLJoe7WAsDkL8NeOxLQ.png"/></div></div></figure><p id="5104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很拗口。为了更加清晰，回头看看第一张图片(关于我们的最终声明将会是什么样子),并与这张图片进行比较。我在这里定义的模式允许我们使用我在最初的例子中定义的语法来声明信号。让我们来分解一下:</p><ul class=""><li id="162d" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">首先，查看以<code class="fe lw lx ly lz b">$</code>开头的模式的任何部分。这表示有俘虏。你可以用这些变量来表示展开的部分。捕获是键入的。看看<code class="fe lw lx ly lz b">$this</code>变量。这是一个<code class="fe lw lx ly lz b">ident</code>类型的捕获。这可以是任何有效的标识符(<code class="fe lw lx ly lz b">type</code>、<code class="fe lw lx ly lz b">struct</code>、<code class="fe lw lx ly lz b">variable</code>或<code class="fe lw lx ly lz b">trait</code>名称)。</li><li id="6b8a" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">接下来让我们看看这些符号。很难辨别，但是看第一个<code class="fe lw lx ly lz b">ident</code>之后马上看。你会看到一个<code class="fe lw lx ly lz b">:</code>。我决定使用一个<code class="fe lw lx ly lz b">:</code>来分隔我们生成的信号实例的名称和它的类型，以保留某种预期的声明语法(sans <code class="fe lw lx ly lz b">let mut</code>)。</li><li id="2bd9" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lw lx ly lz b">:</code>之后的下一部分是另一个捕获— <code class="fe lw lx ly lz b">$sig</code>。又是一个<code class="fe lw lx ly lz b">ident</code>。这是我们将用来命名我们生成的<code class="fe lw lx ly lz b">Signal</code>结构的捕获。紧随<code class="fe lw lx ly lz b">$sig</code>之后的是尖括号。这将让我们使用接下来的两个<code class="fe lw lx ly lz b">ident</code>、<code class="fe lw lx ly lz b">$rectype</code>和<code class="fe lw lx ly lz b">$data</code>，就好像它们是我们的<code class="fe lw lx ly lz b">Signal</code>类型的类型参数。这让我们在定义信号时有了熟悉的语法<code class="fe lw lx ly lz b">MySignal&lt;MySignalReceiver, MySignalData&gt;</code>。还要注意，数据类型必须存在于宏之外。请确保您使用的数据类型已经存在，因为在扩展中不会为我们创建该参数。也可以使用大多数内置类型— <code class="fe lw lx ly lz b">i32</code>、元组或任何<code class="fe lw lx ly lz b">Copy + Clone</code>的结构。</li><li id="ae26" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">宏的下一部分看起来像是使用<code class="fe lw lx ly lz b">=</code>对方括号中的内容进行赋值。这仅仅意味着当我们调用宏时，在类型声明后面会有方括号。如果您没有给一个项目加上前缀<code class="fe lw lx ly lz b">$</code>，它将被解释为应该出现在模式中的<em class="ne">文字字符</em>。在我们的括号内是<code class="fe lw lx ly lz b">$(),+</code>中的一些截图。包围的<code class="fe lw lx ly lz b">$(),+</code>意味着我们期望重复捕获被包围的模式，<code class="fe lw lx ly lz b">,+</code>表示我们期望一次或多次逗号分隔的集合。</li><li id="f7e6" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">在重复捕获中，我们要寻找由<code class="fe lw lx ly lz b">=</code>字符分隔的<code class="fe lw lx ly lz b">$rec</code>、<code class="fe lw lx ly lz b">ident</code>和<code class="fe lw lx ly lz b">$cls</code>、<code class="fe lw lx ly lz b">expr</code>。这样，看起来就像我们在做赋值(我们将在宏声明的末尾)。重复捕获中有一种新的捕获类型— <code class="fe lw lx ly lz b">expr</code>。这将捕获任何有效的Rust表达式。在我们的情况下，我们期待一个结束。我们将把这个闭包封装在扩展中的函数指针中。</li></ul><p id="970f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，Rust宏捕获模式看起来有点难。但是不用担心——一旦你理解了语法和捕获类型，你马上就可以编写自己的宏了。因为您可以使用您喜欢的任何模式，所以您可以轻松地扩展Rust语法或编写特定于领域的脚本语言，所有这些都在宏中。</p><p id="f377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我不是100%确定Rust社区关于宏语法的政策，但是我希望我的<code class="fe lw lx ly lz b">signal</code>定义没有违反太多规则！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9b89" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">过程生成和实现</h1><p id="08dd" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在我们已经了解了match arm中发生的事情，让我们开始扩展呼叫。我们希望我们的宏为我们创建结构来代表我们的<code class="fe lw lx ly lz b">Signal</code>和<code class="fe lw lx ly lz b">Receiver</code>实现者。让我们看看如何使用我们捕获的一些令牌来实现这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/5313e3925cd07c13bce9909647af6593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEyK0OH5LagVKCQMHUnNKQ.png"/></div></div></figure><p id="22de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用捕获的<code class="fe lw lx ly lz b">$sig</code>标识符作为<code class="fe lw lx ly lz b">Signal</code>实现结构的名称，使用<code class="fe lw lx ly lz b">$rectype</code>标识符作为<code class="fe lw lx ly lz b">Receiver</code>实现结构的名称。非常简单。</p><p id="2494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的信号总是需要一种方法来跟踪听众，所以我们使用程序生成的<code class="fe lw lx ly lz b">$rectype</code>中的<code class="fe lw lx ly lz b">Vec</code>。我们还需要为连接到信号的接收器生成id，所以我们给<code class="fe lw lx ly lz b">Signal</code>结构一个叫做<code class="fe lw lx ly lz b">counter</code>的<code class="fe lw lx ly lz b">usize</code>。</p><p id="7b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe lw lx ly lz b">$rectype</code>结构中，我们有一个相应的<code class="fe lw lx ly lz b">id</code>、<code class="fe lw lx ly lz b">usize</code>，用于在我们的信号上使用计数器值。<code class="fe lw lx ly lz b">$rectype</code>还有一个保存函数指针的字段。我们可以再次使用捕获的变量来建立函数的签名。</p><p id="df25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在写这篇文章之前，我并不知道这一点，但是你显然可以将一个正确签名的闭包赋给一个匹配的函数指针。这样做最好的部分是函数指针总是相同大小的<em class="ne">并且</em>已经实现了<code class="fe lw lx ly lz b">Copy + Clone</code>，允许我们程序定义的结构也实现<code class="fe lw lx ly lz b">Copy + Clone</code>。</p><p id="8ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始实现我们的信号和接收器。让我们从在生成的结构上定义一些帮助器方法开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/8e0ed30c3a117308d61f7070bb65a63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sl2gesutlQVvY3dURyBzkA.png"/></div></div></figure><p id="d659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在这里充分利用捕获，使我们的实现相当通用。当它扩展时，我们可以在编译时显式地输入像函数指针<code class="fe lw lx ly lz b">cls</code>这样的东西。我们给这两种类型一个惯用的<code class="fe lw lx ly lz b">new</code>构造函数，我们的信号类型得到一个增量来分配接收者id。</p><p id="d974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将为程序定义的结构实现<code class="fe lw lx ly lz b">Signal</code>和<code class="fe lw lx ly lz b">Receiver</code>。我们将从实现接收器开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/57b8a92356077f8c6ae2212bb1934c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4we0f9xz7qZqvHeFJdfuAQ.png"/></div></div></figure><p id="d5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次大量使用我们的捕获来定义所需的特征类型。数据不言自明。就像我之前提到的，我们将需要那个<code class="fe lw lx ly lz b">Transformer</code>类型在以后用省略类型声明来声明我们的闭包。在<code class="fe lw lx ly lz b">on_emit</code>中，我们简单地调用存储在函数指针末尾的函数。</p><p id="c142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现<code class="fe lw lx ly lz b">Signal</code>稍微复杂一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/bc495516ee67eb00bdf2e15a1c3e6bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3zTVL4B9aGmSYQ2ESZF2Q.png"/></div></div></figure><ul class=""><li id="a537" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">我们的类型声明任务是通过使用我们的<code class="fe lw lx ly lz b">$data</code>和<code class="fe lw lx ly lz b">$rectype</code>捕获来完成的。</li><li id="d62e" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lw lx ly lz b">emit</code>的实现简单地迭代内部结构的<code class="fe lw lx ly lz b">receivers</code>集合，并调用每个接收者的<code class="fe lw lx ly lz b">on_emit</code>函数。</li><li id="21e4" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lw lx ly lz b">connect</code>的实现必须使用相当冗长的类型转换(就像我们在定义<code class="fe lw lx ly lz b">Signal</code>特征时必须做的那样),以向编译器澄清可能的类型歧义。但除此之外，事情很简单。我们递增并将信号的<code class="fe lw lx ly lz b">counter</code>返回到变量<code class="fe lw lx ly lz b">i</code>中。然后，我们使用提供的<code class="fe lw lx ly lz b">i</code>和<code class="fe lw lx ly lz b">trns</code>值创建一个新的接收器，并将其推入我们信号的<code class="fe lw lx ly lz b">Vec</code>。我们返回我们的接收器，<code class="fe lw lx ly lz b">r</code>，所以我们可以使用它作为宏扩展的结果。</li><li id="93f3" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lw lx ly lz b">disconnect</code>使用迭代器的<code class="fe lw lx ly lz b">position</code>函数来查找相关条目的索引。在这种情况下，我通过它的<code class="fe lw lx ly lz b">id</code>字段来识别匹配。这返回一个选项，所以我们<code class="fe lw lx ly lz b">unwrap</code>它知道ID存在，因为我们在构造接收器时分配了ID。我们现在可以在信号接收器的<code class="fe lw lx ly lz b">Vec</code>的<code class="fe lw lx ly lz b">remove</code>方法中使用这个变量<code class="fe lw lx ly lz b">idx</code>。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="20ba" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">重复捕获</h1><p id="54e6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当我们定义宏的模式时，我们在一些方括号中放置了一个重复的捕获。这为我们提供了两个功能:</p><ul class=""><li id="2942" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">我们可以定义我们的接收器，就好像它们是在一个未确定大小的数组中声明的一样(也称为JavaScript风格)。</li><li id="7e1f" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">我们可以展开我们的重复捕获来实际定义我们传递给宏的重复部分的<code class="fe lw lx ly lz b">ident</code>,所以我们的<code class="fe lw lx ly lz b">ident</code>不仅仅是占位符——它们是扩展结束时真正定义的标识符。</li></ul><p id="7b5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将我们的捕获用于重复扩展，我们使用了与定义重复捕获基本相同的语法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/0d6221eec4aa77e6d49b1589abb15bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBJwRPls74Gl3Jl-FzYNOA.png"/></div></div></figure><p id="00e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们声明我们的信号，使用<code class="fe lw lx ly lz b">$this</code>标识符作为信号实例的名称。然后，我们用<code class="fe lw lx ly lz b">$()*</code>语法打开我们的重复展开。我们告诉编译器为每个捕获提供这行代码，它定义了一个变量，其名称与当前的<code class="fe lw lx ly lz b">$rec</code>值相关联，作为我们信号的连接接收器。</p><p id="55ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在这里提供它的类型作为<code class="fe lw lx ly lz b">$rectype</code>，由于我们的<code class="fe lw lx ly lz b">Transformer</code>关联类型，我们可以省略闭包中的类型声明。</p><p id="324d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们几乎准备好测试它了。现在让我们通过定义一个愚蠢的结构来展示如何使用任何<code class="fe lw lx ly lz b">Copy + Clone</code>结构作为信号的数据类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/8a250735ab7cd63b8e38c5e667bb6978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b69-XA8NOXX81rmUpDi0yw.png"/></div></div></figure><p id="df9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这可以通过一个<code class="fe lw lx ly lz b">i32</code>来完成。但这只是证明我们能做到的问题。这是一个简单的连接、发射和断开功能测试的证明。它还展示了我们如何用一个原语替换我们的结构，以获得更简单的<code class="fe lw lx ly lz b">Signal</code>定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/370f354df013e25d65259f7583bfff08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BH-MzFeNmMGnwtrivM8eYg.png"/></div></div></figure><p id="d581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里可以玩<a class="ae ky" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9c50fba4ea6e443387c7079afbcdb376" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b74e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">铁锈很聪明</h1><p id="e1e6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们现在可以用我们的<code class="fe lw lx ly lz b">signal!</code>宏和一点即兴的语法相当容易地定义信号和接收器。我们可以用各种方式将事件连接起来。因为我们的实现使用简单的结构和闭包，所以我们甚至可以通过向<code class="fe lw lx ly lz b">Signal::connect</code>函数传递一个带有预期签名的闭包来添加新的接收者。</p><p id="dfcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至不必关心我们生成的类型，因为<code class="fe lw lx ly lz b">connect</code>从提供的闭包构建实例。编译器对我们的扩展非常聪明，当我们没有使用我们的接收器变量时，它甚至会警告我们(意味着你从来没有断开它们！)或者当我们未能将connect的结果赋给一个变量时(意味着我们没有将一个接收器标记化以在后面的<code class="fe lw lx ly lz b">disconnect</code>中使用)。Rust就是那样聪明。</p><p id="6d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这结束了大树中的另一个节点，那就是我的生锈之旅。直到我的下一次冒险，FP on，读者们！</p></div></div>    
</body>
</html>