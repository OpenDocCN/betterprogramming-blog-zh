<html>
<head>
<title>Build the Rust Web App — Reducing CRUD Boilerplate Code With Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Rust Web应用程序——减少数据库中的CRUD样板代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-web-app-in-rust-part-2-2da195369fc1?source=collection_archive---------1-----------------------#2022-07-03">https://betterprogramming.pub/how-to-write-a-web-app-in-rust-part-2-2da195369fc1?source=collection_archive---------1-----------------------#2022-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2d35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将我们基于文件的CRUD操作转化为基于数据库的CRUD操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2a173972d1f75b0e070aef821a3f5655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RN1aeTFEOp9JKxTr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@vorosbenisop" rel="noopener ugc nofollow" target="_blank">本杰明·沃罗斯</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="d16e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是关于编写web应用程序的系列文章的第二部分。对于这个系列，我们将在<a class="ae kv" href="https://www.rust-lang.org/learn/get-started" rel="noopener ugc nofollow" target="_blank"> Rust </a>中编写web应用程序，我将向您解释如何自己编写它。</p><p id="7491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您不愿意自己编写代码，我已经创建了一个存储库，其中包含本系列中编写的所有代码<a class="ae kv" href="https://github.com/garrettudstrand/rust-web-app/tree/main" rel="noopener ugc nofollow" target="_blank">这里</a>。在本系列每一部分的结尾，我都提交了一个存储库。在上一部分中，我们介绍了如何通过文件进行CRUD操作。在这一部分中，我们将介绍如何利用数据库来减少样板代码。</p><h1 id="0bd3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">向应用程序添加数据库</h1><p id="9101" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这一部分中，我们将删除应用程序中基于文件的保存系统，代之以一个更强大的系统，它是专为我们这样的任务创建的:数据库。</p><p id="7d76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数数据库都是存储表的程序(这个定义比数据库的<a class="ae kv" href="https://en.wikipedia.org/wiki/Database" rel="noopener ugc nofollow" target="_blank">实际定义更为有限，但就我们的目的而言，假设这是真的)。这些表记录了某个类别中各种个人的信息。例如，您可能有一个名为<code class="fe mp mq mr ms b">Persons</code>的表，其中存储了各种人的数据。在这个例子中，每一行都是一个人，每一列都存储这个人的不同信息。下图显示了这个例子。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/993beaf513a82c97ea6f462da23cddaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hu5LQwaGW2D5gh4C.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自SQLShack的文章:<a class="ae kv" href="https://www.sqlshack.com/an-introduction-to-sql-tables/" rel="noopener ugc nofollow" target="_blank">SQL表介绍</a></p></figure><p id="536b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这张桌子可以容纳四个人。对于每个人，我们将他们的姓名和年龄存储在表的列中。第一列，id，与我们在定义任务时使用的id完全一样。id是访问某个人的一种简单易行的方法。</p><p id="06ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，与我们的文件示例不同，数据库使得在这些表上执行CRUD操作变得非常容易。创建、读取、更新和删除表中的某些条目是通过简单的命令来处理的，因此我们不必担心写入、重命名和删除文件的开销。随着我们继续编写我们的web应用程序，它还带来了其他各种优势，这些优势会自然而然地显现出来。</p><p id="2c26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是现在我们知道了什么是数据库，让我们试着使用一个。</p><h1 id="f13a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一种数据库系统</h1><p id="3d43" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于我们的目的来说，<a class="ae kv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>就足够了。有许多不同的数据库，都有各自的优缺点，所以如果您最终使用自己的软件，请记住这一点，并进行研究以确定最佳选择。无论如何，安装Postgres。让它监听端口<code class="fe mp mq mr ms b">5432</code>,当它询问你的数据库的密码时，现在就使用<code class="fe mp mq mr ms b">password</code>。</p><p id="2138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在Windows上安装或使用postgres有问题，可以查看Amigoscode的以下视频:<a class="ae kv" href="https://www.youtube.com/watch?v=BLH3s5eTL4Y" rel="noopener ugc nofollow" target="_blank">Windows PostgreSQL入门| 2021 </a>。遗憾的是，我运行的是Windows机器，所以我不能保证任何Mac或Linux资源可以设置postgres，但网上有几个。对于Mac来说，Codementor 的这篇<a class="ae kv" href="https://www.codementor.io/@engineerapart/getting-started-with-postgresql-on-mac-osx-are8jcopb" rel="noopener ugc nofollow" target="_blank">文章似乎不错。我假设如果你在Linux上，你知道你在做什么，但是如果你有困难，这篇微聚焦文章可能会有帮助。</a></p><p id="1ca7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用新安装的数据库！运行<code class="fe mp mq mr ms b">psql</code>，这是您为了使用postgres而安装的SQL Shell。使用以下信息登录到您的数据库:</p><ul class=""><li id="bb61" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">服务器:<code class="fe mp mq mr ms b">localhost</code></li><li id="0ada" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">数据库:<code class="fe mp mq mr ms b">postgres</code></li><li id="b6d9" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">端口:<code class="fe mp mq mr ms b">5432</code></li><li id="b01e" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">用户名:<code class="fe mp mq mr ms b">postgres</code></li><li id="4c56" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">密码:<code class="fe mp mq mr ms b">password</code></li></ul><p id="fb61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将连接到postgres数据库。现在，我们将使用这个连接创建一个新的数据库来测试我们可用的CRUD操作。此时，您可能会问为什么我们必须创建数据库。我刚才不是把Postgres叫做数据库吗？嗯，Postgres是一个存储多个数据库的应用程序。因此，在做任何事情之前，我们需要创建一个数据库来使用。现在，要做到这一点，只需在<code class="fe mp mq mr ms b">psql</code>应用中运行以下命令:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="4608" class="nm lt iq ms b gy nn no l np nq">CREATE DATABASE test;</span></pre><p id="32ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，分号很重要，因为postgres不会将命令视为“可以使用”，直到找到分号。这样，如果您运行<code class="fe mp mq mr ms b">\l</code>，您应该得到以下输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/3bbfcf042f54727b365ff7d557b990af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nq8ElsCeEyawotEjH2HpWw.png"/></div></div></figure><p id="0889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，postgres预装了3个数据库:<code class="fe mp mq mr ms b">postgres</code>、<code class="fe mp mq mr ms b">template0</code>和<code class="fe mp mq mr ms b">template1</code>。第四个数据库<code class="fe mp mq mr ms b">test</code>，是我们创建的数据库。现在，运行<code class="fe mp mq mr ms b">quit</code>离开外壳，重新进入外壳。以与上次相同的方式登录，但是将<code class="fe mp mq mr ms b">test</code>列为您的数据库，而不是<code class="fe mp mq mr ms b">postgres</code>。这样，您将登录到新创建的数据库。</p><p id="2e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了测试我们的CRUD操作，我们必须创建一个表，所以运行下面的命令(顺便说一下，因为postgres直到命令到达分号才处理它，所以您可以在多行中写出命令)。</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="06ea" class="nm lt iq ms b gy nn no l np nq">CREATE TABLE person (<br/>    id BIGSERIAL NOT NULL PRIMARY KEY,<br/>    name VARCHAR(100) NOT NULL,<br/>    country VARCHAR(50) NOT NULL<br/>);</span></pre><p id="ace8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，您将创建一个表格。该表将列出有名称和国家的条目，id是一个数字，每当我们创建一个新条目时，它将自动递增。如果您想查看数据库中的所有关系(包括您的表和自动递增id)，您可以运行<code class="fe mp mq mr ms b">\d</code>。如果您想查看数据库中的所有表(目前只有person ),运行<code class="fe mp mq mr ms b">\dt</code>。如果一切都正确，那么<code class="fe mp mq mr ms b">\d</code>的输出应该是这样的:</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="747b" class="nm lt iq ms b gy nn no l np nq">List of relations<br/> Schema |     Name      |   Type   |  Owner<br/>--------+---------------+----------+----------<br/> public | person        | table    | postgres<br/> public | person_id_seq | sequence | postgres<br/>(2 rows)</span></pre><p id="dbf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们做一些CRUD操作！首先，让我们做创建操作。运行以下命令，向person表中添加一些人。</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="6054" class="nm lt iq ms b gy nn no l np nq">INSERT INTO person (name, country) VALUES ('Torvald', 'Norway');<br/>INSERT INTO person (name, country) VALUES ('Abelarda', 'Germany');<br/>INSERT INTO person (name, country) VALUES ('Melete', 'Italy');</span></pre><p id="6fb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们来做一个读操作。运行以下命令来查看表中的所有新条目。</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="87f7" class="nm lt iq ms b gy nn no l np nq">SELECT * FROM person</span></pre><p id="1818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出应该如下所示</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="2729" class="nm lt iq ms b gy nn no l np nq">id  |   name   | country<br/>----+----------+---------<br/>  1 | Torvald  | Norway<br/>  2 | Abelarda | Germany<br/>  3 | Melete   | Italy<br/>(3 rows)</span></pre><p id="c8e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以通过运行以下命令来执行更新操作。</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="acfb" class="nm lt iq ms b gy nn no l np nq">UPDATE person SET country = 'USA' WHERE id = 3;</span></pre><p id="8cfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使梅莱特的国家成为美国。</p><p id="0f58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们来做删除操作。只需运行下面的命令从我们的表中删除Abelarda</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="84a6" class="nm lt iq ms b gy nn no l np nq">DELETE FROM person WHERE id = 2;</span></pre><p id="a461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在这些操作之间退出并重新进入数据库，即使您关闭了计算机，您的数据库仍将保留这些值。因此，我们能够通过最少的努力实现持久的CRUD操作。我相信您可能会同意命令和数据库比文件更容易使用和管理，即使两者都试图解决相同的问题。</p><p id="1423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果我们不能在我们的应用程序中使用它，仅仅因为我们有这个数据库就没有任何意义。这就是数据库驱动发挥作用的地方。</p><h1 id="1dae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据库驱动程序</h1><p id="4427" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">数据库驱动程序正好解决了我们的问题。它允许你通过程序连接和使用数据库。我们不像上一节那样手动登录并运行数据库上的操作，而是使用数据库驱动程序连接到数据库，然后在程序中写出我们的操作。这些数据库驱动通常是你为你的项目安装的库，就像我们安装Rocket一样。</p><p id="ead9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在我们的例子中，Rocket要求我们为我们的应用程序使用他们支持的数据库驱动程序之一。但是，不管我们使用什么，让我们设置驱动程序。顺便说一下，这里的大部分代码都有点粗制滥造，因为我们最终会用稍微复杂一点的代码来替换它，这样会减少代码。</p><p id="8c63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在任何情况下，修改您的<code class="fe mp mq mr ms b">Cargo.toml</code>,以获得以下导入</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="eb38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，进入<code class="fe mp mq mr ms b">main.rs</code>并在所有其他结构旁边添加下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7ab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在与<code class="fe mp mq mr ms b">Cargo.toml</code>相同的级别，创建一个名为<code class="fe mp mq mr ms b">Rocket.toml</code>的文件，并输入以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a9f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，转到<code class="fe mp mq mr ms b">main.rs</code>中的<code class="fe mp mq mr ms b">rocket</code>功能，修改成如下所示。这将初始化我们的数据库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="468e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们实现CRUD操作时，我们将假设我们的数据库中有一个名为<code class="fe mp mq mr ms b">tasks</code>的表。下一步是在postgres中创建我们的数据库(根据我们的配置，我们将其命名为<code class="fe mp mq mr ms b">todo</code>和<code class="fe mp mq mr ms b">tasks</code>表)。只需转到<code class="fe mp mq mr ms b">psql</code>并运行以下命令</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="2b16" class="nm lt iq ms b gy nn no l np nq">CREATE DATABASE todo;</span></pre><p id="2adb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将创建一个名为<code class="fe mp mq mr ms b">todo</code>的数据库。现在，连接到<code class="fe mp mq mr ms b">todo</code>并运行该命令</p><pre class="kg kh ki kj gt ni ms nj nk aw nl bi"><span id="7c16" class="nm lt iq ms b gy nn no l np nq">CREATE TABLE IF NOT EXISTS tasks (<br/>    id   BIGSERIAL NOT NULL PRIMARY KEY,<br/>    item TEXT NOT NULL<br/>);</span></pre><p id="8326" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在我们的数据库中创建我们的<code class="fe mp mq mr ms b">tasks</code>表。</p><h1 id="bc30" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据库的CRUD操作</h1><p id="aff6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在已经完成了，我们可以改变我们的CRUD操作来使用我们的数据库而不是一个文件。我们通过在方法中包含一个参数来访问数据库，然后我们可以使用这个变量和各种函数来运行我们之前运行的命令。所以，让我们开始修改我们的函数。我们要做的第一件事是添加创建操作，我们还添加了一点代码来使错误生效。我还对<code class="fe mp mq mr ms b">Task</code>和<code class="fe mp mq mr ms b">TaskId</code>结构做了一些小小的调整，使它们能很好地与数据库驱动程序配合。这些更改的代码如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7fef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想知道<code class="fe mp mq mr ms b">DatabaseError</code>的代码，我只是使用了一个<a class="ae kv" href="https://doc.rust-lang.org/1.9.0/book/structs.html#tuple-structs" rel="noopener ugc nofollow" target="_blank">元组结构</a>来包装<code class="fe mp mq mr ms b">rocket_db_pools::sqlx::Error</code>，所以我可以为它实现<code class="fe mp mq mr ms b"><a class="ae kv" href="https://docs.rs/rocket/0.5.0-rc.2/rocket/response/trait.Responder.html" rel="noopener ugc nofollow" target="_blank">Responder</a></code>特征。在Rust中，<a class="ae kv" href="https://doc.rust-lang.org/book/ch10-02-traits.html" rel="noopener ugc nofollow" target="_blank">特征</a>是一种确保在结构或枚举上实现某些功能的方式。使用Rocket，我们必须为我们希望从请求中返回的任何结构、枚举或类型实现<code class="fe mp mq mr ms b">Responder</code>特征。在<code class="fe mp mq mr ms b">Responder</code>中实现的函数告诉Rocket如何将该结构、枚举或类型转换成可以在响应中发送的适当数据。</p><p id="abfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Rust的<a class="ae kv" href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type" rel="noopener ugc nofollow" target="_blank">孤儿规则</a>规定不能在外部类型上实现外部特征，所以由于<code class="fe mp mq mr ms b">rocket_db_pools::sqlx::Error</code>和<code class="fe mp mq mr ms b">Responder</code>都没有在我们工作的文件中定义，我们不能为我们的错误实现<code class="fe mp mq mr ms b">Responder</code>特征。因此，我们使用<a class="ae kv" href="https://www.lurklurk.org/effective-rust/newtype.html" rel="noopener ugc nofollow" target="_blank"> newtype模式</a>，它让我们将外部结构包装在我们自己的结构中，这允许我们在其上实现我们想要的任何特征。</p><p id="cbcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们还为<code class="fe mp mq mr ms b">DatabaseError</code>实现了<code class="fe mp mq mr ms b"><a class="ae kv" href="https://doc.rust-lang.org/std/convert/trait.From.html" rel="noopener ugc nofollow" target="_blank">From</a></code>特征。我们特意这样做是为了让它与Rust的<a class="ae kv" href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html" rel="noopener ugc nofollow" target="_blank">问号操作符</a>配合得更好。当你调用一个返回<code class="fe mp mq mr ms b"><a class="ae kv" href="https://doc.rust-lang.org/std/result/" rel="noopener ugc nofollow" target="_blank">Result</a></code>枚举的函数时，使用问号操作符。此枚举器存储值或错误。如果在<code class="fe mp mq mr ms b">Result</code>上使用问号运算符，如果<code class="fe mp mq mr ms b">Result</code>正在存储一个，它将立即返回一个错误。否则，如果<code class="fe mp mq mr ms b">Result</code>保持一个值，它将像正常一样使用该值。例如，<code class="fe mp mq mr ms b">add_task</code>在声明<code class="fe mp mq mr ms b">added_task</code>时使用问号运算符。语句<code class="fe mp mq mr ms b">added_task</code>被赋值给返回一个<code class="fe mp mq mr ms b">Result</code>，它或者保存一个<code class="fe mp mq mr ms b">Task</code>或者保存一个<code class="fe mp mq mr ms b">rocket_db_pools::sqlx::Error</code>。在<code class="fe mp mq mr ms b">Result</code>持有错误的情况下，问号运算符强制<code class="fe mp mq mr ms b">add_task</code>返回持有<code class="fe mp mq mr ms b">DatabaseError</code>的<code class="fe mp mq mr ms b">Result</code>。否则，<code class="fe mp mq mr ms b">added_task</code>将被赋予<code class="fe mp mq mr ms b">Task</code>值，我们可以在下一行中很好地使用它。</p><p id="443b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，问号操作符隐式地使用了<code class="fe mp mq mr ms b">From</code>特征。如果<code class="fe mp mq mr ms b">Result</code>保存的错误不同于函数返回的错误，那么问号操作符使用<code class="fe mp mq mr ms b">From</code>特征将错误从其当前类型转换为函数在返回错误之前可以返回的类型。在我们之前的例子中，<code class="fe mp mq mr ms b">added_task</code>语句返回一个<code class="fe mp mq mr ms b">rocket_db_pools::sqlx::Error</code>，然而函数返回一个<code class="fe mp mq mr ms b">DatabaseError</code>。为了使一切变得简单，问号运算符在返回<code class="fe mp mq mr ms b">Result</code>之前隐式地使用<code class="fe mp mq mr ms b">From</code>特征将<code class="fe mp mq mr ms b">rocket_db_pools::sqlx::Error</code>转换为<code class="fe mp mq mr ms b">DatabaseError</code>。然而，这要求<code class="fe mp mq mr ms b">DatabaseError</code>为<code class="fe mp mq mr ms b">rocket_db_pools::sqlx::Error</code>实现<code class="fe mp mq mr ms b">From</code>特征。</p><p id="95ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于应用程序代码，很多人使用<code class="fe mp mq mr ms b"><a class="ae kv" href="https://crates.io/crates/anyhow" rel="noopener ugc nofollow" target="_blank">anyhow</a></code> crate来实现错误(<a class="ae kv" href="https://www.lurklurk.org/effective-rust/errors.html#trait-objects" rel="noopener ugc nofollow" target="_blank">这个链接</a>稍微讲了一下)。一般来说，这比我们在这里使用特定的枚举来处理我们的错误需要更少的代码。通常，如果你正在创建一个库，你只需要把错误放在枚举或元组结构中，你希望返回的错误是清晰的。然而，在这种情况下，我们仍然需要为<code class="fe mp mq mr ms b">anyhow</code>错误类型实现<code class="fe mp mq mr ms b">Responder</code>特征，所以我们仍然需要声明一个元组结构，这最终并没有节省我们任何时间！它将允许我们改变我们使用的底层错误，但是，正如我们将看到的，这不是必要的，因为我们将在以后改变我们如何处理错误。</p><p id="da88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于<code class="fe mp mq mr ms b">add_task</code>功能的实际内容，它只是使用了我们刚刚设置的<a class="ae kv" href="https://github.com/launchbadge/sqlx" rel="noopener ugc nofollow" target="_blank"> sqlx数据库驱动</a>。它用它在数据库上运行一个<code class="fe mp mq mr ms b">INSERT</code>命令。</p><p id="0e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管解释很长，但您可以看到避免使用文件而使用数据库大大简化了创建操作。我们的大部分代码只是让数据库驱动程序发送适当的请求(<code class="fe mp mq mr ms b">add_task</code>之后的内容)并确保我们的错误得到适当的响应(<code class="fe mp mq mr ms b">add_task</code>以上的所有内容)，这非常棒。解决了这个问题，现在让我们实现读操作</p><p id="eadc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">读取操作也很简单，我们只需使用之前使用过的<code class="fe mp mq mr ms b">SELECT</code>命令来获取所有可用的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，更新操作简单地使用我们前面讨论过的<code class="fe mp mq mr ms b">UPDATE</code>命令，并且，就像创建操作一样，我们使用<code class="fe mp mq mr ms b">RETURNING</code>语句返回我们实际修改的任务，因此我们可以将它返回给用户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6a1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe mp mq mr ms b">DELETE</code>操作也是一样的故事。使用我们之前使用的命令，将它放入数据库驱动程序并让它运行</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="31f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们就可以用更少的代码实现持久的CRUD操作。删除所有冗余/不需要的代码后，我们有了一个少于100行的代码库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f44d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。在这一部分中，我们能够将基于文件的CRUD操作转化为基于数据库的CRUD操作。这大大降低了我们操作的复杂性和规模。然而，编程是迭代的，仍然有可以对这个代码库进行改进的地方，我们将会做出改进。在本系列的下一部分，我们将通过ORM进一步减少样板代码。</p><p id="a8a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读这篇文章。我希望这个系列能够继续帮助您提高web开发技能。</p><h1 id="c00c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="9a51" class="mu mv iq ky b kz mk lc ml lf nv lj nw ln nx lr mz na nb nc bi translated"><a class="ae kv" href="https://www.rust-lang.org/learn/get-started" rel="noopener ugc nofollow" target="_blank">入门— Rust编程语言(rust-lang.org)</a></li><li id="7110" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://github.com/garrettudstrand/rust-web-app/tree/main" rel="noopener ugc nofollow" target="_blank">本系列的GitHub库</a></li><li id="2086" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Database" rel="noopener ugc nofollow" target="_blank">数据库—维基百科</a></li><li id="0217" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.sqlshack.com/an-introduction-to-sql-tables/" rel="noopener ugc nofollow" target="_blank">SQL表介绍(sqlshack.com)</a></li><li id="912e" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL:世界上最先进的开源数据库</a></li><li id="e291" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=BLH3s5eTL4Y" rel="noopener ugc nofollow" target="_blank">Windows | 2021版PostgreSQL入门— YouTube </a></li><li id="ae25" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.codementor.io/@engineerapart/getting-started-with-postgresql-on-mac-osx-are8jcopb" rel="noopener ugc nofollow" target="_blank">在Mac OSX上开始使用PostgreSQL | code mentor</a></li><li id="1fab" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">【microfocus.com T2】在Linux上建立PostgreSQL数据库</li><li id="14eb" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">【rust-lang.org】元组结构<a class="ae kv" href="https://doc.rust-lang.org/1.9.0/book/structs.html#tuple-structs" rel="noopener ugc nofollow" target="_blank"/></li><li id="6455" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://docs.rs/rocket/0.5.0-rc.2/rocket/response/trait.Responder.html" rel="noopener ugc nofollow" target="_blank">火箭中的响应者::response — Rust (docs.rs) </a></li><li id="a5f1" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/ch10-02-traits.html" rel="noopener ugc nofollow" target="_blank">特点:定义共享行为Rust编程语言(rust-lang.org)</a></li><li id="bcba" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type" rel="noopener ugc nofollow" target="_blank"> Rust的孤儿规则——Rust编程语言(rust-lang.org)</a></li><li id="1bf7" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.lurklurk.org/effective-rust/newtype.html" rel="noopener ugc nofollow" target="_blank">第7项:拥抱新型模式——有效防锈(lurklurk.org)</a></li><li id="8e0f" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://doc.rust-lang.org/std/convert/trait.From.html" rel="noopener ugc nofollow" target="_blank">来自于标准::转换-生锈(rust-lang.org)</a></li><li id="8f10" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html" rel="noopener ugc nofollow" target="_blank">？—生锈的例子(rust-lang.org)</a></li><li id="9896" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://doc.rust-lang.org/std/result/" rel="noopener ugc nofollow" target="_blank">标准::结果—生锈(rust-lang.org)</a></li><li id="f06d" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://crates.io/crates/anyhow" rel="noopener ugc nofollow" target="_blank">总之—crates . io:Rust Package Registry</a></li><li id="d711" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.lurklurk.org/effective-rust/errors.html#trait-objects" rel="noopener ugc nofollow" target="_blank">第4项:偏好惯用错误变体——有效Rust(lurklurk.org)</a></li><li id="cdc7" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">launchbadge/sqlx: 🧰的Rust SQL工具包。一个异步的、纯Rust SQL框架，其特点是没有DSL的编译时检查查询。支持PostgreSQL、MySQL、SQLite和MSSQL。(github.com)</li></ul></div></div>    
</body>
</html>