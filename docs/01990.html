<html>
<head>
<title>A Simple CRUD App Using GraphQL, NodeJS, and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL、NodeJS和MongoDB的简单CRUD应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-simple-crud-app-using-graphql-nodejs-mongodb-78319908f563?source=collection_archive---------4-----------------------#2019-10-29">https://betterprogramming.pub/a-simple-crud-app-using-graphql-nodejs-mongodb-78319908f563?source=collection_archive---------4-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ac2fbba2bb35343fdce28fd13a5496b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9o7wDZP5pBquR0RE5mRD8w.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jakobowens1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雅各布·欧文</a>在<a class="ae kf" href="https://unsplash.com/s/photos/movie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5cff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的<a class="ae kf" href="https://medium.com/@soufianecharkaoui98/what-is-graphql-f001d35c4737" rel="noopener">上一篇文章</a>中，我对GraphQL做了一个全球性的介绍。我将它与REST进行了比较，因为两者倾向于做相同的工作，但是在质量和性能方面存在一些差异。</p><p id="985d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在本文中，我们将构建一个简单的电影应用程序，我们可以在其中显示、添加、编辑和删除电影。这样，我们将了解GraphQL的基础知识，这也是本文的主要目标——因为我假设阅读本文的每个人都已经使用过NodeJS和MongoDB。</p><h2 id="c034" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">要求:</h2><ul class=""><li id="adaf" class="lx ly it ki b kj lz kn ma kr mb kv mc kz md ld me mf mg mh bi translated">对NodeJS有很好的理解</li><li id="3381" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">MongoDB和Mongoose也是如此</li><li id="d480" class="lx ly it ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">MongoDB已经在您的计算机上设置好了，因为我不会进行环境设置</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e44b" class="mu lf it bd lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh ni nj lv nk bi translated">创建项目和安装依赖项</h1><p id="8964" class="pw-post-body-paragraph kg kh it ki b kj lz kl km kn ma kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">首先，在本地磁盘上创建一个新的项目文件夹。比如，我给我的取名为<code class="fe no np nq nr b">graphql-tuto</code>。在节点命令提示符下，输入:</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="6a1c" class="le lf it nr b gy oa ob l oc od">cd graphql-tuto<br/>npm install express mongoose body-parser cors --save</span></pre><p id="0452" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经安装了Express、Mongoose、body-parser和CORS。我不打算详述这一点，因为这不是本教程的主要目标。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="7934" class="le lf it nr b gy oa ob l oc od">npm install apollo-server-express --save</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="4613" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从Apollo文档中，我发现“Apollo Server是一个社区维护的开源GraphQL服务器，可以与所有Node.js HTTP服务器框架一起工作”，比如Express。</p><p id="590e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以创建一个名为<strong class="ki iu"> <em class="oe"> </em> </strong> <code class="fe no np nq nr b">app.js</code>的文件。向其中添加以下代码，以设置Apollo Express服务器和MongoDB数据库。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="1b7e" class="le lf it nr b gy oa ob l oc od">const express = require('express');<br/>const mongoose = require('mongoose');<br/>const schema = require('./schema');<br/>const bodyParser = require('body-parser');<br/>const cors = require('cors');</span><span id="3425" class="le lf it nr b gy of ob l oc od">const { ApolloServer } = require('apollo-server-express');</span><span id="ef8c" class="le lf it nr b gy of ob l oc od">const url = "mongodb://localhost:27017/moviesdb";</span><span id="d38f" class="le lf it nr b gy of ob l oc od">const connect = mongoose.connect(url, { useNewUrlParser: true });<br/>connect.then((db) =&gt; {<br/>      console.log('Connected correctly to server!');<br/>}, (err) =&gt; {<br/>      console.log(err);<br/>});</span><span id="edd7" class="le lf it nr b gy of ob l oc od">const server = new ApolloServer({<br/>      typeDefs: schema.typeDefs,<br/>      resolvers: schema.resolvers<br/>});</span><span id="64ee" class="le lf it nr b gy of ob l oc od">const app = express();</span><span id="d729" class="le lf it nr b gy of ob l oc od">app.use(bodyParser.json());</span><span id="85e9" class="le lf it nr b gy of ob l oc od">app.use('*', cors());</span><span id="9390" class="le lf it nr b gy of ob l oc od">server.applyMiddleware({ app });</span><span id="476d" class="le lf it nr b gy of ob l oc od">app.listen({ port: 4000 }, () =&gt;<br/>  console.log(`🚀 Server ready at <a class="ae kf" href="http://localhost:4000${server.graphqlPath}" rel="noopener ugc nofollow" target="_blank">http://localhost:4000${server.graphqlPath}</a>`));</span></pre><p id="631b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphQL有两个主要工作原理:类型和解析器。我在阿波罗服务器中定义了它们。我们将从稍后创建的文件中导入它们。</p><p id="e479" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们创建一个包含电影猫鼬模型的文件<code class="fe no np nq nr b">models/movie.js</code> <strong class="ki iu"> </strong>。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="493d" class="le lf it nr b gy oa ob l oc od">const mongoose = require('mongoose');</span><span id="a1dd" class="le lf it nr b gy of ob l oc od">const Schema = mongoose.Schema;<br/>const movieSchema = new Schema({<br/>    name: {<br/>       type: String,<br/>       required: true<br/>    },<br/>    rating: {<br/>       type: Number,<br/>       required: true<br/>    },<br/>    producer: {<br/>       type: String,<br/>       required: true<br/>   }<br/>}, {<br/>    timestamps: true<br/>});</span><span id="3a3f" class="le lf it nr b gy of ob l oc od">var Movies = mongoose.model('Movie', movieSchema);<br/>module.exports = {Movies, movieSchema};</span></pre><p id="5daa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每部电影都有一个名字和一个类型为<code class="fe no np nq nr b">String</code>的制片人，以及一个类型为<code class="fe no np nq nr b">Number</code>的分级。</p><p id="a366" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以现在我们添加一个新文件<code class="fe no np nq nr b">schema.js</code>，在这里我们将构建我们的GraphQL API。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="6a84" class="le lf it nr b gy oa ob l oc od">const { gql } = require('apollo-server-express');<br/>const Movie = require('./models/movie').Movies;</span></pre><p id="b346" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们从Apollo服务器和我们的movie-mongose模型导入GraphQL作为<code class="fe no np nq nr b">gql</code>。</p><p id="e37f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphQL APIs由<em class="oe">类型</em>和<em class="oe">解析器</em>组成。</p><p id="1635" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型是我们定义我们想要表示的实体的模型或模式的地方(在我们的例子中是<code class="fe no np nq nr b">Movie</code>)。在type中，我们还声明了我们的查询(例如，获取电影列表)和变化(例如，添加电影)。GraphQL类型仅限于id的<code class="fe no np nq nr b">ID</code>、整数的<code class="fe no np nq nr b">Int</code>、浮点数的<code class="fe no np nq nr b">Float</code>、<code class="fe no np nq nr b">String</code>和<code class="fe no np nq nr b">Boolean</code>。因此，在我们的模式文件中，我们添加了以下代码行:</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="938e" class="le lf it nr b gy oa ob l oc od">const typeDefs = gql `</span><span id="ad50" class="le lf it nr b gy of ob l oc od">   type Movie {<br/>     id: ID!<br/>     name: String!<br/>     producer: String!<br/>     rating: Float!<br/>   }</span><span id="9900" class="le lf it nr b gy of ob l oc od">   type Query {<br/>     getMovies: [Movie]<br/>     getMovie(id: ID!): Movie<br/>   }</span><span id="c0bc" class="le lf it nr b gy of ob l oc od">   type Mutation {<br/>     addMovie(name: String!, producer: String!, rating: Float!): Movie<br/>     updateMovie(name: String!, producer: String!, rating: Float): Movie<br/>     deleteMovie(id: ID!): Movie<br/>   }<br/>`</span></pre><p id="da7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义了<code class="fe no np nq nr b">Movie</code> <strong class="ki iu"> </strong>类型，当然，每部电影都会有一个<code class="fe no np nq nr b">id</code>。我们将<code class="fe no np nq nr b">!</code>放在类型(例如<code class="fe no np nq nr b">String!</code>)的旁边，表示这个属性是必需的。在我们的例子中，一切都是必需的。在<code class="fe no np nq nr b">Query</code>类型中，我们有查询(GET操作)。</p><p id="a186" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe no np nq nr b">Mutation</code> <strong class="ki iu"> </strong>类型中，我们有其他的操作来修改我们的数据库。在<code class="fe no np nq nr b">getMovies</code>、<strong class="ki iu">、</strong>中，我们返回一个电影列表——这就是为什么我们有括号、<code class="fe no np nq nr b">[Movie]</code>。</p><p id="b5a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们的GraphQL API的第一部分。现在，我们将这与直接影响数据库的Mongoose数据库查询联系起来。这就是解决方案的用武之地。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="d662" class="le lf it nr b gy oa ob l oc od">const resolvers = {<br/>  Query: {<br/>    getMovies: (parent, args) =&gt; {<br/>      return Movie.find({});<br/>    },<br/>    getMovie: (parent, args) =&gt; {<br/>      return Movie.findById(args.id);<br/>    }<br/>  },<br/>  Mutation: {<br/>    addMovie: (parent, args) =&gt; {<br/>      let Movie = new Movie({<br/>        name: args.name,<br/>        producer: args.producer,<br/>        rating: args.rating,<br/>      });<br/>      return Movie.save();<br/>    },<br/>    updateMovie: (parent, args) =&gt; {<br/>      if (!args.id) return;<br/>        return Movie.findOneAndUpdate(<br/>         {<br/>           _id: args.id<br/>         },<br/>         {<br/>           $set: {<br/>             name: args.name,<br/>             producer: args.producer,<br/>             rating: args.rating,<br/>           }<br/>         }, {new: true}, (err, Movie) =&gt; {<br/>           if (err) {<br/>             console.log('Something went wrong when updating the movie');<br/>           } else {<br/>           }<br/>         }<br/>      );<br/>    }<br/>  }<br/>}</span></pre><p id="f035" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在类型定义中声明的查询和变异被详细描述为与数据库交互的操作。我假设您熟悉Mongoose，因为这不是本文的重点，本文主要是为GraphQL编写的。</p><p id="6545" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将在GraphQL Playground中测试我们的API。所以在你的导航器中，转到http://localhost:4000/graphql。</p><p id="20d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先向数据库中添加一部电影:</p><figure class="ns nt nu nv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/d9e594b13cde0f2c78217eac188d1b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdWpskRaXHL9tzRSOheFeg.png"/></div></div></figure><p id="e560" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们列出我们的电影，因为我只添加了一个，我们将得到一个元素(电影)的列表作为输出。</p><figure class="ns nt nu nv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/816284ff3d3d554842d78875409c282a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POBrL7wymcL7mtZT9tTZlw.png"/></div></div></figure><p id="498a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，您可以看到，当我们在所有操作都汇聚到一个单一端点时，端点的痛苦就消失了。我会让你用和我一样的方法测试其他操作。</p><p id="97ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你学到了新的或有用的东西。我将很快制作另一个关于GraphQL中嵌套对象的教程。</p></div></div>    
</body>
</html>