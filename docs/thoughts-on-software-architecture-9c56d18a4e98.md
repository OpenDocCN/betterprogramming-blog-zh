# 关于软件体系结构的思考

> 原文：<https://betterprogramming.pub/thoughts-on-software-architecture-9c56d18a4e98>

## 为什么永远不会有一个“纯粹的”架构来统治它们…

![](img/dd8f7581f5093c411af08576be40af1b.png)

[柯克·桑顿](https://unsplash.com/@kirkthornton?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/frank-lloyd-wright?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍照

软件开发人员中有一个学派认为软件架构应该完全独立于它所支持的用户界面。

他们认为，人们应该能够将任何软件架构放在任何用户界面之上，一切都应该正常工作。

这是一个吸引人的，几乎是诱人的观点…

我碰巧认为这是错误的。或者，至少，比这更微妙。

阅读时，请记住，我是从一个 iOS 应用程序开发人员的角度，特别是从 SwiftUI 的角度来写这篇文章的，我们讨论的是内部客户端*应用程序*架构，而不是后端架构。

那是故意的，但稍后会详细说明。

让我们开始吧。

# 毒蛇

我[写了一篇关于 SwiftUI 和 VIPER 的文章](/viper-for-swiftui-please-no-ee61ce99694c),在这篇文章中，我阐述了我认为 VIPER 不适合作为 iOS 和 Mac 上 SwiftUI 应用程序的架构选择的所有原因。

底线是 VIPER 背后的核心机制是委托。它被设计成在对象之间传递动作和消息，为了做到这一点，它在每个对象之间维护一组直接的引用。(观点、演示者等。)

换句话说，VIPER 被设计成可以用它的`UIViews`和`UIViewControllers`整齐地插入 UIKit。它是围绕这些对象在内存中的持久化方式和`UIViewController`生命周期设计的。

问题是 SwiftUI `Views`不是`UIViews`。它们不是对象，它们没有引用，它们不断被创建和区分，以驱动 SwiftUI 接口。

因此，虽然你可以用 SwiftUI 做一些类似于 VIPER 的工作，但你必须跳过许多关卡，并为此编写大量的代码。

正如文章中提到的，我看到一个代码库，开发人员被迫向他的 VIPER-VM 代码添加一个 ViewModel，这样他就有地方放置他的可观察值。谈谈胶水代码。

还有更多的问题，但不用说，我在那篇文章中提出的所有问题都强调了 VIPER 架构不适合在 SwiftUI 中使用。

当然，除非你*喜欢*写很多额外的适配器和样板代码。

明白了吗？好吧，我们继续。

# 那不是真正的建筑

有些人可能会说，像 VIPER 这样的东西并不是真正的*架构，它只是一堆对象，它们的工作是从*真正的*架构中获取信息，并将其转化为适合用户界面使用的形式。*

*我也不同意这一点。*

*在[选择应用架构](/swiftui-choosing-an-application-architecture-6ec9289f8e8f)中，我写道，应用架构基本上可以归结为我们用来决定*如何将代码分割成单独组件的规则。为什么那部分在那里*和为什么这部分在这里*和*。***

我们编写具有明确定义的角色、行为和责任的类、结构和函数。这是一个观点。那是一个模型。这里的代码是一个提供模型的服务。诸如此类。

而*这个*代码就是从这些服务中获取信息，并将其提供给视图进行显示的代码。而*代码*负责执行一组给定的动作，并操纵我们的应用程序的状态。

所有这些部分:模型；服务；存储库；视图模型；视图和视图控制器；模块和框架；所有这些组成了我们应用程序的整体架构。

你会不会指着一栋建筑的地下室说，“那里！那就是*真正的*建筑！其余的，地板、房间、出入口和屋顶，这些都不算！”

当然不是。建筑是一个有凝聚力的整体，建筑是其所有部分的总和。

应用程序也是如此。

这是格式塔。

# 服务

当然，你可以走进一个住宅，换掉炉子或热水器。但是这些物品在很大程度上被设计成可互换的。

它们被设计来为住宅提供特定的服务，并适合其整体建筑中的特定空间。

如果他们需要被替换，我不应该被迫重建整个房子。

这是一个精心设计的架构。

还要记住，这样的服务为应用程序提供服务。他们很少驱动应用程序。

# 有机建筑

弗兰克·劳埃德·赖特可能是美国历史上最著名的建筑师之一，他的指导原则之一是有机建筑。

对赖特来说，一座建筑的结构必须与其环境相适应。人们小心翼翼地选择形状、风格和材料。

但是实际因素也发挥了作用。在北方，房屋通常建有高高的斜屋顶，以更好地遮挡雨雪。它们反映了所处环境的现实。

一个人可以在西南沙漠建造这样的东西，但目的是什么？它不太适合那种环境，也许更重要的是，这是对稀缺资源的浪费。

事实上，在西南地区，我们经常想把水收集起来，而不是简单地把它放掉。

因此，这不仅是一个为不同环境设计的解决方案，而且是一个完全*错误*的解决方案。

# 毒蛇，Redux

回到 VIPER，我们看到它很大程度上不适合在 SwiftUI 中使用，许多其他常见的架构选择也是如此。

当我在全局应用程序状态中增加一个数字时，使用 Redux 风格的“整个应用程序的单一数据源”模式可能会导致 SwiftUI 中的性能和更新问题，现在需要检查整个应用程序视图树以查看需要更新和呈现的内容。

其他的设计是为了解决 Swift 以外的语言中固有的问题。

例如，不可变数据和数据流旨在防止基于引用类型的语言发生变化，并且不具备 Swift 的写时复制语义。参见[Swift 中反对不可变对象的案例](/the-case-against-immutable-objects-88343bbd7912)了解更多

我可以继续说下去，但我想你已经开始明白了。

# UIKit

在许多方面，UIKit 强化了我们的“架构”和用户界面代码之间有一个清晰界限的想法。

用户可以自由选择 VIPER、MVP、MVVM、Clean，甚至是完整的 RxSwift 数据流。

因此，架构和用户界面之间的界限看起来清晰明确。架构是我们在 UIKit 上添加的所有其他东西。

但是几乎所有的选择都是为了配合 UIKit 而设计的。他们需要引用类型、目标和委托。他们期望视图和视图控制器能够持久。

大多数人生活在一个命令式的世界里。

但是世界已经变了。

# 斯威夫特伊

SwiftUI 是声明性的，而不是命令性的，因此它对如何构造和管理“视图”有自己的看法。

它固执地认为某个特定元素的状态只有一个真实的来源。

它坚持将这种状态绑定在尽可能低的层次结构中，以最小化过多的视图更新周期和渲染。

它坚持认为状态应该如何用`@State`和`@Binding`属性包装器表示，如何定义和使用`ObservableObjects`，以及如何通过组合接收事件和更新。

它甚至开始表达对任务的偏好，并使用 async/await。

忽略这些意见，你最终会让*与*swift ui 看待世界的方式背道而驰，最糟糕的是一个完全功能失调的应用程序。

世界，环境，都变了。

这就是为什么我不断回到特定架构与 SwiftUI 配合得有多好的原因。

因为如果它*跟 swift ui*配合不好，真的能通用吗？我真的可以把以前为 UIKit 设计的任何架构打包到 SwiftUI 上，并期待一个不错的结果吗？

我想我已经相当明确地证明了你不能。

当世界改变时，架构也需要改变。

# 平台无关的服务

但是尽管如此，我们也应该尽最大努力防止我们的用户界面选择渗透到我们的业务逻辑和服务层。

例如，我可以创建以下服务…

```
class AccountLoadingService: ObservableObject {
    @Published var accounts: [Account] = []
    func load() async throws {
        // logic goes here
    }
}
```

但是在这样做的时候，我已经让 SwiftUI 惯例和期望融入了我的加载服务。最好是…

```
struct BetterAccountLoadingService {
    func load() async throws -> [Account] {
        // logic goes here
    }
}
```

在这个阶段，没有理由让它成为一个类，它提供了一个简单的接口，仍然可以很容易地从 SwiftUI `.task`处理程序中访问。

此外，它使得从另一个服务、从一个视图模型甚至从一个 UIKit 组件使用服务变得更加容易。并不是我打算这么做。这只是认识到这样一个事实:有一天需求或环境可能会改变，我可能需要这样做。

因此，如果一开始就没有必要，最好不要把自己逼入困境。

最后，请记住，更好的选择是让我们的服务成为一个协议，以使模拟和测试更加容易。更不用说在我们的数据源发生变化的情况下保护我们的应用程序。

```
protocol AccountLoader {
    func load() async throws -> [Account]
}struct EvenBetterAccountLoadingService: AccountLoader {
    func load() async throws -> [Account] {
        // logic goes here
    }
}
```

# 体系结构

在 Clean Architecture 中，Robert Martin 写了许多我们今天使用的设计原则，比如 SOLID，他还写了我们的应用程序中对边界和层的需求。

这里也是如此。

如上所示，并非 SwiftUI 应用程序中的所有东西都需要知道 SwiftUI 是我们正在使用的用户界面。事实上，我们的大多数模型和服务、网络和身份验证层以及数据存储应该都没有意识到这个事实。

但是现实情况是我们已经在编写一个 iOS 应用程序。我们*已经*使用 Swift 和 SwiftUI。

我们已经做出了选择。

这意味着我们的*其他*架构选择必须嵌入该平台并与该环境集成。

因此，我们归结到这样一个问题:这种集成需要做多少工作？我们需要多少“胶水”？这些选择是*与*我们的环境合作，还是*与*环境对抗？

在 [SwiftUI:选择应用架构](/swiftui-choosing-an-application-architecture-6ec9289f8e8f)中，我在文章结尾列出了我选择 SwiftUI 架构的标准:

1.  无论应用程序大小如何，它都必须是高性能的。
2.  它必须与 SwiftUI 行为和状态管理兼容。
3.  它应该简洁、轻量、适应性强、灵活。
4.  它鼓励 SwiftUI 视图合成。
5.  它支持测试。

换句话说，它让 SwiftUI 成为 SwiftUI。

弗兰克·劳埃德·赖特多次说过，建筑永远不应该脱离环境而独立存在。

我倾向于同意。人们需要为手头的工作选择合适的架构、合适的工具。

# 完成块

这个可能会有点争议，所以继续吧。

让我知道你的想法。