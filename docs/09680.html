<html>
<head>
<title>How To Write Your Own Go Module Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写自己的Go模块代理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-your-own-go-module-proxy-ed2d861c577a?source=collection_archive---------0-----------------------#2021-09-27">https://betterprogramming.pub/how-to-write-your-own-go-module-proxy-ed2d861c577a?source=collection_archive---------0-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd41" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的私有存储库去掉所有烦人的“替换”指令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c6b7381e8ea18c37c8e648c302871d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qMPE9yiC_0Eh1U0b"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@bruno_nascimento?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁诺·纳西门托</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管理项目中的依赖关系总是一枚双面硬币。我们使用的编程语言和工具无关紧要。使用这些工具总是<a class="ae ky" href="https://www.npmjs.com/package/npm" rel="noopener ugc nofollow" target="_blank">流血</a>、<a class="ae ky" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank">流汗</a>和<a class="ae ky" href="https://getcomposer.org/" rel="noopener ugc nofollow" target="_blank">流泪</a>。</p><p id="5733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有点害怕围棋的可能解法。几年前，我们用<a class="ae ky" href="https://github.com/golang/dep" rel="noopener ugc nofollow" target="_blank"> Dep </a>。它友好且易于使用，有许多可能性来精确定义依赖关系。</p><p id="f06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go社区还不是很大，所以不太可能出现依赖性。这可能是我的机器没有像几年前运行时那样爆炸的主要原因。</p><p id="8763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一段时间，<a class="ae ky" href="https://go.dev/blog/using-go-modules" rel="noopener ugc nofollow" target="_blank">围棋模块</a>来到了晚会现场。这是一个超级酷的、合乎逻辑的解决方案，正是我期望从谷歌得到的(抱歉，但我永远不会忘记我的初恋，谷歌是我的初恋)。</p><p id="914e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">然后，我开始用私人包。</em></p><h1 id="f4f1" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">“替换”指令的激增</h1><p id="ab67" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">让我们假设我们在私有的、自我管理的<a class="ae ky" href="https://about.gitlab.com/install/" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上有多个git存储库，充满了不同的Go模块。这可能不是一个可以想象的复杂场景，因为它是当今许多It公司的设置。</p><p id="34fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">注:本文发布时，</em> <a class="ae ky" href="https://docs.gitlab.com/ee/user/packages/go_proxy/" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> Gitlab Go代理</em> </a> <em class="lz">仍然默认未启用，性能可疑，每个包都有一个特定的代理URL。</em></p><p id="ee70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，让我们假设我们的项目共享相同的代码，不仅来自公共包，还来自我们的代码库。开发团队希望交换他们的解决方案，而不用每天重新发明热水。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/afd82d49fd2932cb7cb46f25f45041df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6TQXXV8jLOPIEuOqTUTjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单依赖图</p></figure><p id="e5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某种程度上，我们的应用程序的依赖图可能看起来像上面的图表。除了只依赖公共包之外，我们的应用程序还可以依赖私有git存储库中的包A和包B。</p><p id="5c36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的包可能在嵌套的子组中，实际的git存储库将有一个类似于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://gitlab.company.com/group/sub-group/package-a." rel="noopener ugc nofollow" target="_blank">https://gitlab.company.com/group/sub-group/package-a</a></code> <a class="ae ky" href="https://gitlab.company.com/group/sub-group/package-a." rel="noopener ugc nofollow" target="_blank">的URL。</a>所以，不可避免的是在我们的<code class="fe lv lw lx ly b">go.mod</code>文件中使用<code class="fe lv lw lx ly b">replace</code>指令。</p><p id="2a73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我使用模块名<code class="fe lv lw lx ly b">company.com/package-a</code>，因为无论如何，我需要有<code class="fe lv lw lx ly b">replace</code>指令——所以，我们的包最好使用更短的。</p><p id="3bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://gitlab.company.com/group/sub-group/package-a." rel="noopener ugc nofollow" target="_blank">gitlab.company.com/group/sub-group/package-a</a></code>作为包名，唯一的区别就是少了一个。git "后缀在<code class="fe lv lw lx ly b">replace</code>指令的末尾。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序的<code class="fe lv lw lx ly b">go.mod</code>文件示例</p></figure><p id="64e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以接受自己的选择，因为我们的应用程序只依赖于解决我们问题的那两个包，所以不时更新依赖关系是我们愿意做的权衡。</p><p id="02f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，更新几个依赖项并不是什么大不了的事情，尤其是如果我们已经存储了一些命令来完成这项工作，比如在Makefile中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于更新相关性的命令</p></figure><p id="d7c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切顺利。我们仍然能够轻松地更新我们的依赖关系。但是，当我们的依赖项开始从我们的私有git库获取依赖项时，问题就开始出现了。</p><p id="631d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们有和下图一样的包结构。我们的应用程序只直接依赖于包A和包B，但间接依赖于许多其他私有包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/75e93d4924602747c2e97b3268d5924e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INK2w36heWus4_-PteIc9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复杂依赖图</p></figure><p id="c063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有包都是公共的典型情况下，这不是问题。但是现在，当所有这些包都是私有的时，我们需要在应用程序的<code class="fe lv lw lx ly b">go.mod</code>文件中添加一个<code class="fe lv lw lx ly b">replace</code>指令，即使你没有直接使用这些包中的任何代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“替换”指令的激增</p></figure><p id="0d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这开始令人讨厌了。我们现在需要更新所有的间接依赖关系，而不是更新我们的主要依赖关系，让Go模块依赖关系算法来解决剩下的问题。</p><p id="f10f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使使用Makefile，这也不会很愉快，在此期间，您将开始质疑您的依赖策略。</p><p id="5491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">做依赖关系的工作不能这么蠢。</em></p><h1 id="49c1" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">Go模块代理</h1><p id="112d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">Go模块代理是一个包含Go模块实际来源数据库的服务。在大多数情况下，源名称是公共git存储库的URL，因此Go模块代理执行简单的请求转发。</p><p id="08cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在某些情况下，模块的名称可以不同于git URL，这是Go模块代理的主要目的。在这里，代理找到模块的实际源，并将请求转发到那里。</p><p id="2172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过从控制台设置环境变量<code class="fe lv lw lx ly b">GOPROXY</code>来指定Go模块代理的用法。如果<code class="fe lv lw lx ly b">GOPROXY</code>变量为空或者等于<code class="fe lv lw lx ly b">direct</code>，你将不会使用代理，而是直接从它们的源下载包。</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="a829" class="nf mb it ly b gy ng nh l ni nj">$ go env | grep GOPROXY<br/>GOPROXY="<a class="ae ky" href="https://proxy.golang.org,direct" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org,direct</a>"</span></pre><p id="dd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae ky" href="https://golang.org/doc/go1.13#modules" rel="noopener ugc nofollow" target="_blank"> Go版本1.13 </a>开始，环境变量GOPROXY默认为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://proxy.golang.org,direct" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org,direct</a></code>。这意味着，当你需要某个库时，算法会首先联系来自谷歌的公共<a class="ae ky" href="https://proxy.golang.org/" rel="noopener ugc nofollow" target="_blank">代理</a>。</p><p id="d21d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它不能从代理中找到一个源，下一次尝试将是直接的，发送一个请求到等于包名的URL。GOPROXY值中单词<code class="fe lv lw lx ly b">direct</code>后面的一切都是不相关的，算法不会搜索源。</p><p id="3546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go模块代理有一个简单的HTTP接口，要检查它提供哪种类型的URL，可以在控制台中运行以下命令:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="f5f3" class="nf mb it ly b gy ng nh l ni nj">$ go help goproxy</span><span id="c3e7" class="nf mb it ly b gy nk nh l ni nj">....</span><span id="c023" class="nf mb it ly b gy nk nh l ni nj">GET $GOPROXY/&lt;module&gt;/@v/list returns a list of known versions of the given module, one per line.</span><span id="bbb4" class="nf mb it ly b gy nk nh l ni nj">GET $GOPROXY/&lt;module&gt;/@v/&lt;version&gt;.info returns JSON-formatted metadata about that version of the given module.</span><span id="4aba" class="nf mb it ly b gy nk nh l ni nj">GET $GOPROXY/&lt;module&gt;/@v/&lt;version&gt;.mod returns the go.mod file for that version of the given module.</span><span id="b441" class="nf mb it ly b gy nk nh l ni nj">GET $GOPROXY/&lt;module&gt;/@v/&lt;version&gt;.zip returns the zip archive for that version of the given module.</span><span id="95b3" class="nf mb it ly b gy nk nh l ni nj">GET $GOPROXY/&lt;module&gt;/@latest returns JSON-formatted metadata about the latest known version of the given module in the same format as &lt;module&gt;/@v/&lt;version&gt;.info. The latest version should be the version of the module the go command may use if &lt;module&gt;/@v/list is empty or no listed version is suitable. &lt;module&gt;/@latest is optional and may not be implemented by a module proxy.<br/>....</span></pre><p id="51cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，理论上，如果你能够在你的公司内部提供一个内部服务，支持来自上面的URL，你就能够为你的私人项目摆脱所有的<code class="fe lv lw lx ly b">replace</code>指令。</p><p id="79df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，可能有解决办法。</p><h1 id="4851" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">Go模块代理的简单实现</h1><p id="8bf4" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">对于本文，我在这个<a class="ae ky" href="https://gist.github.com/Ompluscator/9bd4b552b0bd900ddf3f24c011fd244f" rel="noopener ugc nofollow" target="_blank"> Github Gist </a>中编写了超小型Go模块代理。也可以使用雅典<a class="ae ky" href="https://github.com/gomods/athens" rel="noopener ugc nofollow" target="_blank">软件包中的SDK来创建您的存储。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单服务器</p></figure><p id="76d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，一个kickstarted应用程序提供了一个带有三个端点的简单HTTP服务器。为了让这段代码更加简单，我使用了来自<a class="ae ky" href="https://github.com/gorilla" rel="noopener ugc nofollow" target="_blank"> Gorilla </a>的<a class="ae ky" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Mux </a>包。</p><p id="30bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示一些具体的用例，我通过使用来自<a class="ae ky" href="https://github.com/xanzy" rel="noopener ugc nofollow" target="_blank"> Xanzy </a>的<a class="ae ky" href="https://github.com/xanzy/go-gitlab" rel="noopener ugc nofollow" target="_blank">包</a>添加了与Gitlab API的集成。在init函数中，一个新的Gitlab <code class="fe lv lw lx ly b">client</code>被初始化，带有模块名和Gitlab项目id的映射。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Yaml文件定义了项目id和模块名之间的联系</p></figure><p id="8cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该提供的第一个端点是<code class="fe lv lw lx ly b">info</code>端点。这个端点为特定的标签提供包的版本信息或者提交散列。例如，Mux包的输出如下所示:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="d504" class="nf mb it ly b gy ng nh l ni nj"><a class="ae ky" href="https://proxy.golang.org/github.com/gorilla/mux/@v/3cf0d013.info" rel="noopener ugc nofollow" target="_blank">https://proxy.golang.org/github.com/gorilla/mux/@v/3cf0d013.info</a></span><span id="bd62" class="nf mb it ly b gy nk nh l ni nj"><strong class="ly iu">{<br/>  </strong>"Version": "v1.8.1-0.20210914121219-3cf0d013e53d",<br/>  "Time": "2021-09-14T12:12:19Z"<br/><strong class="ly iu">}</strong></span></pre><p id="fde2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里最简单的解决方案是假设我们将被要求提交版本，以便我们可以查询Gitlab API来检索关于所需提交的信息并呈现信息，如下面的代码片段所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">覆盖“信息”端点的函数“版本”</p></figure><p id="14ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">version</code>功能覆盖了<code class="fe lv lw lx ly b">info</code>端点。它检索一个版本名，并从所需的项目ID中搜索该版本表示的提交散列。最后，它将响应呈现为JSON，带有最终的版本名称和时间。</p><p id="8a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该对<code class="fe lv lw lx ly b">mod</code>端点使用类似的方法。这个端点返回给我们属于那个确切版本的<code class="fe lv lw lx ly b">go.mod</code>文件的内容。</p><p id="e903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当请求这个端点时，Go模块算法发送在<code class="fe lv lw lx ly b">info</code>端点中提供的完整版本名。为此，函数<code class="fe lv lw lx ly b">mod</code>稍微复杂一些。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">覆盖“mod”端点的函数“mod”</p></figure><p id="b699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们应该实现的最后一个端点是<code class="fe lv lw lx ly b">zip</code>端点。此端点返回包的存档版本。但是，为了拥有有效的存档，我们的端点必须遵守一些规则。</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="1a20" class="nf mb it ly b gy ng nh l ni nj">Expected folder structure in ZIP archive by Go Module Algorithm:<br/><strong class="ly iu">company.com<br/>  |--project-a@v0.0.0-2021111111111-abcdef</strong></span><span id="7b46" class="nf mb it ly b gy nk nh l ni nj">Actual folder strcuter in ZIP archive provided by Gitlab:<br/><strong class="ly iu">project-a-2021111111111-abcdef</strong></span></pre><p id="a28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的例子中可能注意到的，Go模块算法期望ZIP存档中有一个特定的文件夹结构。一个将分裂成文件夹和子文件夹的模块网址。</p><p id="e0bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在我们的例子中，Gitlab返回一个具有不同文件夹结构的归档文件，因此为了支持这一需求，我们需要在内存中解压缩该归档文件，在新的归档文件中更改文件夹，并将其作为输出返回，如下面的代码片段所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">涵盖“zip”端点的功能“归档”</p></figure><p id="178d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。我们需要做的最后一点是运行我们的Go代理，将其添加为环境变量，并获取我们的包:</p><pre class="kj kk kl km gt nb ly nc nd aw ne bi"><span id="c55c" class="nf mb it ly b gy ng nh l ni nj">$ go env -w GOPROXY='<a class="ae ky" href="http://localhost:8080,https://proxy.golang.org,direct'" rel="noopener ugc nofollow" target="_blank">http://localhost:8080,https://proxy.golang.org,direct'</a></span><span id="4d16" class="nf mb it ly b gy nk nh l ni nj">$ go get company.com/package-a@abcdef<br/>...<br/>$ go get company.com/package-b@abcdef<br/>...</span></pre><p id="2463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一段时间后，<code class="fe lv lw lx ly b">go.mod</code>文件看起来好多了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">go.mod文件的最终外观</p></figure><p id="7259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子只是许多可能性的开始。它给出了为我们的私有存储库添加代理的一般想法，但是我们可以为更复杂的需求添加许多其他特性。</p><p id="928a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，可以在不使用任何地图的情况下自动抓取Gitlab。或者Gitlab管道的钩子来刷新我们的映射。我们也可以为<a class="ae ky" href="https://pkg.go.dev/github.com/ktrysmt/go-bitbucket" rel="noopener ugc nofollow" target="_blank"> Bitbucket </a>做集成。诸如此类。</p><h1 id="8f21" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论</h1><p id="be56" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">Go Module Proxy可以作为将私有存储库用作项目包的替代方案。它们提供了避免使用<code class="fe lv lw lx ly b">replace</code>指令的可能性。</p><p id="eb7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是当自我管理的git服务器越来越流行时，拥有一些可以使我们的依赖性更干净的解决方案是非常有价值的。</p><p id="10e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您对<code class="fe lv lw lx ly b">replace</code>指令有什么体验？如何管理私有存储库中的依赖关系？</p></div></div>    
</body>
</html>