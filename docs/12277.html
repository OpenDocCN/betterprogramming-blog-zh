<html>
<head>
<title>16 Useful Extensions for SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI的16个有用扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/16-useful-extensions-for-swiftui-88aae6ff8909?source=collection_archive---------0-----------------------#2022-05-25">https://betterprogramming.pub/16-useful-extensions-for-swiftui-88aae6ff8909?source=collection_archive---------0-----------------------#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a876" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我在项目中反复使用的一些有用的代码片段</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8412932cde65eae2b4fb73174b02cdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u463l4sfYcxcSrlo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mygallery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> KS KYUNG </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我们越来越接近WWDC 2022，可能还有SwiftUI的4.0版本，这是一个我很幸运一直在使用的框架，我想我可能会发布一个我发现自己反复使用的扩展的小集合。我希望下一个版本中会有一些这样的内容。</p><h1 id="45b2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.隐藏</h1><p id="6be2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个视图修改器，允许您显示或隐藏通常无法显示或隐藏的视图。值得一提的是，视图修改器是一个非常有用的模式，你最好记住它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c41c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是作为视图的修饰符，条件变量只是一个布尔值。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d6c6" class="mz lw it mv b gy na nb l nc nd">.modifier(Show(isVisible: condition))</span></pre><p id="5579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做很好，但是正如你会注意到的，它确实释放了<code class="fe ne nf ng mv b">view</code>上的空间，并强制进行重绘——因此影响了性能。或者，您也可以始终使用<code class="fe ne nf ng mv b">opacity</code>选项卡来获得类似的效果。它会运行得更快，但不会释放您使用的空间。</p><h1 id="f96f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.树枝</h1><p id="213e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我遇到的这个修改器是控制属性包含/排除的完美解决方案。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="aa64" class="mz lw it mv b gy na nb l nc nd">extension View {<br/>  @ViewBuilder<br/>  func `if`&lt;Transform: View&gt;(_ condition: Bool, transform: (Self) -&gt;  Transform) -&gt; some View {<br/>    if condition { transform(self) }<br/>    else { self }<br/>  }<br/>}</span></pre><p id="5df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样使用的代码，也有一个变量，在这个例子中是彩色的。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e870" class="mz lw it mv b gy na nb l nc nd">.if(colored) { view in<br/>  view.background(Color.blue)<br/>}</span></pre><h1 id="8b0d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.打印</h1><p id="2f39" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你是SwiftUI的新手，首先会抓住你的是<code class="fe ne nf ng mv b">print</code>。它可能是调试技术的恐龙，但他们仍然在课堂上教授它，并且发现自己无法在SwiftUI视图中使用它是令人痛苦的。所以，这段代码是非常宝贵的。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3a68" class="mz lw it mv b gy na nb l nc nd">extension View {<br/>    func Print(_ vars: Any...) -&gt; some View {<br/>        for v in vars { print(v) }<br/>        return EmptyView()<br/>    }<br/>}</span></pre><p id="da8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它允许你在代码中使用这样的语句。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d5d7" class="mz lw it mv b gy na nb l nc nd">self.Print("Inside ForEach", varOne, varTwo ...)</span></pre><h1 id="f54b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.耽搁</h1><p id="3a30" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这在iOS15中有所改变，虽然不是SwiftUI本身，但这绝对是你在代码中发现自己在做的事情。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e58f" class="mz lw it mv b gy na nb l nc nd">extension Task where Success == Never, Failure == Never {<br/>  static func sleep(seconds: Double) async throws {<br/>  let duration = UInt64(seconds * 1000_000_000)<br/>  try await sleep(nanoseconds: duration)<br/>  }<br/>}</span></pre><p id="6d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您希望在延迟后运行的代码需要遵循创建延迟本身的<code class="fe ne nf ng mv b">Task</code>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a3c0" class="mz lw it mv b gy na nb l nc nd">Task { try! await Task.sleep(seconds: 0.5) }</span></pre><h1 id="58e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.passthrustubjects</h1><p id="cf60" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我开始在SwiftUI上使用<code class="fe ne nf ng mv b">Combine</code>时，我发现<code class="fe ne nf ng mv b">PassThroughSubjects</code>是一种连接新旧的超级有用的方式。我写了一篇关于在应用内购买中使用它们的文章，但是它们并不完美，当你发送它们时，我经常会触发不止一次。这段代码可以帮助您发现这个问题。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="fd9b" class="mz lw it mv b gy na nb l nc nd">let changeColor = PassthroughSubject&lt;Int,Never&gt;()</span></pre><p id="e20a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您使用的代码如下所示:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="cfe6" class="mz lw it mv b gy na nb l nc nd">.onReceive(signalButton<br/>  .eraseToAnyPublisher()<br/>  .throttle(for: .milliseconds(10), scheduler: RunLoop.main, latest: true))<br/>{ value in<br/>  if value == 2 {<br/>    button2 = true<br/>    levelColor = Color.red<br/>  }<br/>}</span></pre><p id="3b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ne nf ng mv b">calling</code>例程，在这种情况下，这里的数字用于让我命名一个主题，这样我就可以在同一个SwiftUI代码中触发多个分支。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7217" class="mz lw it mv b gy na nb l nc nd">changeColor.send(3)</span></pre><h1 id="67a0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.捐款</h1><p id="dbd7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">开始代码的另一个替代方法，虽然不是SwiftUI，但它是我在SwiftUI代码中反复使用的一个无价元素。您可以使用以下代码进行设置:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="82d8" class="mz lw it mv b gy na nb l nc nd">let cameraGesture = PassthroughSubject&lt;cameraActions,Never&gt;()<strong class="mv iu"><br/></strong>var cameraSubscription:AnyCancellable? = nil</span></pre><p id="7e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后像这样使用两个<code class="fe ne nf ng mv b">combine</code>声明:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="afeb" class="mz lw it mv b gy na nb l nc nd">cameraSubscription = cameraGesture<br/>  .eraseToAnyPublisher()<strong class="mv iu"><br/>  </strong>.throttle(for: .milliseconds(10), scheduler: RunLoop.main, latest: true)<br/>   .sink(receiveValue: { value in   <br/>  // do something with the value                 <br/>})</span></pre><p id="5631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过像以前一样发送一个<code class="fe ne nf ng mv b">combine</code>消息。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4472" class="mz lw it mv b gy na nb l nc nd">cameraGesture.send(._1orbitTurntable)</span></pre><h1 id="155c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.计时器</h1><p id="8579" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个<code class="fe ne nf ng mv b">publisher</code>是一个创建计时器的好方法。我发现我几乎在我想到的每个项目中都在使用它。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="369c" class="mz lw it mv b gy na nb l nc nd">let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()</span></pre><p id="c2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是代码。</p><p id="8245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:我在<code class="fe ne nf ng mv b">_ unused</code>变量中有时间值。与<code class="fe ne nf ng mv b">send</code>不同，这种方式更可靠，因为它只发送一条信息，而不是一堆。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="5cf3" class="mz lw it mv b gy na nb l nc nd">.onReceive(timer) { _ in<br/>  // do something<br/>}</span></pre><h1 id="7776" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">8.坐标/尺寸</h1><p id="fd36" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我不太记得我是怎么说的了，所以这里有一个例子。这也有点棘手，因为它返回的大小是父元素，而不是您在其中使用它的子元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b85c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，你通常用它作为背景视图。以下是如何使用此命令返回视图的大小:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d9bd" class="mz lw it mv b gy na nb l nc nd">.background(returnSize())</span></pre><h1 id="e3d6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">9.属性字符串</h1><p id="689b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我在栈溢出时遇到的一个超级有用的扩展；它适用于iOS 15的<code class="fe ne nf ng mv b">Text</code>对象中的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像这样使用上面的片段:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a260" class="mz lw it mv b gy na nb l nc nd">Text("GAME OVER") { $0.kern = CGFloat(2) }</span></pre><p id="e012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这几种参数，你可以在这篇<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/ios-15-attributed-strings-in-swiftui-markdown-271204bec5c1">文章</a>中详细添加。</p><h1 id="5dcf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">10.任意视图</h1><p id="6801" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来是对抱怨不匹配视图的SwiftUI消息的修复。虽然我通常不鼓励使用<code class="fe ne nf ng mv b">AnyView</code>，但有时候似乎也没有其他解决办法。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="44e4" class="mz lw it mv b gy na nb l nc nd">extension View {<br/>    func eraseToAnyView() -&gt; AnyView {<br/>        AnyView(self)<br/>    }<br/>}</span></pre><p id="9b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个扩展的例子，我想返回一个文本项或一个图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="f676" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">11.下标</h1><p id="6fe8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个扩展允许你给一个字符串加下标；它使用了一个已经存在很长时间的标准</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像在其他语言中一样使用代码。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="03b8" class="mz lw it mv b gy na nb l nc nd">let word = "Start"<br/>  for i in 0..&lt;word.length {<br/>    print(word[i])<br/>}</span></pre><h1 id="51b3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">12.检测震动</h1><p id="9086" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我发现自己一直在查找这个谷歌代码。谁能记住这个序列？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a21b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像这样创建扩展:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a802" class="mz lw it mv b gy na nb l nc nd">.onShake {<br/>  print("stop it shaking")<br/>}</span></pre><h1 id="f7b8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">13.拍摄视图快照</h1><p id="0858" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">此宝石来自<a class="ae ky" href="https://www.hackingwithswift.com" rel="noopener ugc nofollow" target="_blank"> HWS </a>网站；这是所有迅捷事物的绝佳来源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样使用它:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d997" class="mz lw it mv b gy na nb l nc nd">let image = textView.snapshot().ignoresSafeArea</span></pre><h1 id="4304" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">14.保存/加载图像</h1><p id="0402" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果在苹果开发者门户上找到这个；它会派上用场。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在扩展中，您可以像这样使用代码:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="8ba8" class="mz lw it mv b gy na nb l nc nd">@State private var image = UIImage(systemName: "xmark")!<br/>private var url: URL {  let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)  return paths[0].appendingPathComponent("image.jpg")}</span><span id="1d2a" class="mz lw it mv b gy nh nb l nc nd">var body: some View { <br/>Image(uiImage: image)  <br/>  .onAppear {   url.load(&amp;image)  }  <br/>  .onTapGesture {   url.save(image)  }<br/>}</span></pre><h1 id="5148" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">15.列出字体</h1><p id="99d3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">快结束了。下一个很有用。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ecc9" class="mz lw it mv b gy na nb l nc nd">let fontFamilyNames = UIFont.familyNames<br/>for familyName in fontFamilyNames {<br/>  print("Font Family Name = [\(familyName)]")<br/>  let names = UIFont.fontNames(forFamilyName: familyName)<br/>  print("Font Names = [\(names)]")<br/>}</span></pre><p id="d438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用SwiftUI代码，您可以找到如下字体:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f5de" class="mz lw it mv b gy na nb l nc nd">struct Fonts {<br/>  static func avenirNextCondensedBold (size: CGFloat) -&gt; Font {<br/>  return Font.custom("AvenirNextCondensed-Bold", size: size)<br/>}</span></pre><p id="d103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将调用这个构造来使用代码:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="07ba" class="mz lw it mv b gy na nb l nc nd">.font(Fonts.avenirNextCondensedBold(size: 12))</span></pre><h1 id="49d0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">16.三元运算符</h1><p id="ec3e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这最后一个扩展可以用在SwiftUI的很多领域，但是我总是记不住语法。</p><p id="9a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，三元运算符计算<code class="fe ne nf ng mv b">condition</code>和</p><ul class=""><li id="70fc" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">如果<code class="fe ne nf ng mv b">condition</code>为<code class="fe ne nf ng mv b">true</code>，则执行<code class="fe ne nf ng mv b">expression1</code>。</li><li id="fedf" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">如果<code class="fe ne nf ng mv b">condition</code>为<code class="fe ne nf ng mv b">false</code>，则执行<code class="fe ne nf ng mv b">expression2</code>。</li></ul><p id="e9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三元运算符有三个操作数(<code class="fe ne nf ng mv b">condition</code>、<code class="fe ne nf ng mv b">expression1</code>和<code class="fe ne nf ng mv b">expression2</code>)。因此，命名为三元运算符。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ea70" class="mz lw it mv b gy na nb l nc nd">flipColor = flipColor == .blue ? .green : .blue</span></pre><p id="3e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果<code class="fe ne nf ng mv b">flipColor</code>是<code class="fe ne nf ng mv b">blue</code>，我返回<code class="fe ne nf ng mv b">green</code>，如果<code class="fe ne nf ng mv b">flipColor</code>是<code class="fe ne nf ng mv b">green</code>，我返回<code class="fe ne nf ng mv b">blue</code>。</p><p id="628b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些把我带到了这个列表的末尾。我希望你在这里找到了一些有用的片段。</p><p id="aab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>