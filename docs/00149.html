<html>
<head>
<title>Recursive Dependency in RxJava and Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJava和Kotlin协程中的递归依赖</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursive-dependency-in-rxjava-and-kotlin-coroutines-926a3ea4f0cb?source=collection_archive---------9-----------------------#2018-06-30">https://betterprogramming.pub/recursive-dependency-in-rxjava-and-kotlin-coroutines-926a3ea4f0cb?source=collection_archive---------9-----------------------#2018-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9f62c211e01497d05ecece6e9c0657a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FeTxowbGkf2rJVoV"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">尼古拉斯·霍伊泽在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="48c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我们要玩这个有趣的递归游戏——递归依赖流。那是一条自给自足的溪流。首先，让我们尝试一下这个概念在<code class="fe lb lc ld le b">RxJava</code>中的简单实现:</p><pre class="lf lg lh li gt lj le lk bn ll lm bi"><span id="acb7" class="ln lo iq le b be lp lq l lr ls">fun numbersRx(): Observable&lt;Int&gt; = Observable.concat(<br/>  Observable.range(0, 3),<br/>  numbersRx()<br/>)</span></pre><p id="e533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个想法很清楚。必须开始发射一些基数，在它们用完之后，钩住它自己，继续发射来自内部的东西。很像大毒蛇吃它的尾巴。</p><p id="1c7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这并没有真正起作用:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/511d3f2141943bddf7b544ca326143db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*vtL3WSAu-QR4xDsOY4Y4EQ.png"/></div></figure><p id="8206" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是<code class="fe lb lc ld le b">Observable</code>在组装时陷入无限递归下降。让我们希望介绍一些懒惰会有所帮助:</p><pre class="lf lg lh li gt lj le lk bn ll lm bi"><span id="b3db" class="ln lo iq le b be lp lq l lr ls">fun numbersRx(): Observable&lt;Int&gt; = Observable.concat(<br/>  Observable.range(0, 3),<br/>  Observable.defer(::numbersRx)<br/>)</span></pre><p id="f486" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">的确如此:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/f443c38dc0c1b29667d7bc47aa64d182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*G0siJ24tCZN7vZriMUEJWA.png"/></div></figure><p id="bf83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只是再次发出相同的数字，这并不好玩。让我们给这个流添加一些动态:</p><pre class="lf lg lh li gt lj le lk bn ll lm bi"><span id="a15d" class="ln lo iq le b be lp lq l lr ls">fun numbersRx(): Observable&lt;Int&gt; = Observable.concat(<br/>  Observable.range(0, 3),<br/>  Observable.defer(::numbersRx).map { it + 3 }<br/>)</span></pre><p id="fbd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次<code class="fe lb lc ld le b">Observable</code>在吃它的尾巴时抵消了它一点点，它的工作就像一个魔咒:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/bc0f9603a73bf05e133d5ac3955b6a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*EH0XgmyMbFqH_K_DmGbnDA.png"/></div></figure><p id="af7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听着，我们不用计数器就能得到无穷多的数字。让我们暂时离开Rx，尝试使用Kotlin协程达到同样的效果。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="857e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要建造一台发电机，所以<code class="fe lb lc ld le b">buildSequence</code>是这里显而易见的选择:</p><pre class="lf lg lh li gt lj le lk bn ll lm bi"><span id="441c" class="ln lo iq le b be lp lq l lr ls">fun numbersCr(): Sequence&lt;Int&gt; = buildSequence {<br/>    yieldAll(0..2)<br/>    val numbersSupply = numbersCr().iterator()<br/>    while (true) yield(numbersSupply.next() + 3)<br/>}</span></pre><p id="c178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我看来，这更像是必不可少的，类似于pythonic生成器，这是一件好事。当然，它运行顺畅:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/69396f6d7e53b2aa75b2e987a5d2cc15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*D5WINk3588gw9fnxtfTs5w.png"/></div></figure><p id="83c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来很棒。我可以想象我们可以用这个机械做很多有趣的事情。例如，让我们基于惰性筛子构建一个无限素数生成器。</p><p id="b0d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种算法本质上是必要的，因为筛子是一个可变的地图，它在道路上标记数字。我将为这个特定的实现选择协程，因为它们对状态更友好，代码也更清晰。</p><pre class="lf lg lh li gt lj le lk bn ll lm bi"><span id="e88b" class="ln lo iq le b be lp lq l lr ls">fun primesCr(): Sequence&lt;Int&gt; = buildSequence {<br/>  yieldAll(listOf(2, 3, 5, 7))<br/>  val sieve = mutableMapOf&lt;Int, Int&gt;()<br/>  val basePrimes = primesCr().iterator()      // generate supply of "base" primes<br/>  var p = basePrimes.apply { next() }.next()  // discard 2 then get 3<br/>  var q = p * p         // square next base prime to keep track of in sieve<br/>  var n = 9             // n is the next candidate number<br/>  while (true) {<br/>    if (n !in sieve) {  // n is not a multiple of any of base primes,<br/>      if (n &lt; q) {      // below next base prime's square, so<br/>        yield(n)        // n is prime<br/>      } else {<br/>        val p2 = p * 2        // n == p * p: for prime p, add p * p + p * 2<br/>        sieve[q + p2] = p2    // to the sieve, with p * 2 as the increment step<br/>        p = basePrimes.next() // pull next base prime<br/>        q = p * p             // and get its square<br/>      }<br/>    } else {<br/>      val s = sieve.remove(n)!!<br/>      var nxt = n + s         // n is a multiple of some base prime, find next multiple<br/>      while (nxt in sieve) {  // ensure each entry is unique<br/>        nxt += s<br/>      }<br/>      sieve[nxt] = s          // nxt is next non-marked multiple of this prime<br/>    }<br/>    n += 2                    // work on odds only<br/>  }<br/>}</span></pre><p id="3afe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以用它做有趣的事情，比如得到900到1000之间的所有素数</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8cf527be015f45d1574938dd2a3e0e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*LREFjE9OGHE3uMs0nR4Pqg.png"/></div></figure><p id="9a0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者得到第10001个素数</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/d5a139cb0fa8d73529a9bae22181a437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*UXx5ODE6ITP-VIsCMM-L3Q.png"/></div></figure><p id="e76d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天就到这里，祝你愉快！</p></div></div>    
</body>
</html>