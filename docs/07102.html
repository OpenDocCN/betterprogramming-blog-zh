<html>
<head>
<title>CombineLatest: An Easy RxJS Operator Pattern to Manage Interdependent Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CombineLatest:管理相互依赖的流的简单RxJS操作符模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/combinelatest-an-easy-rxjs-operator-pattern-to-manage-interdependent-streams-ecc72b162227?source=collection_archive---------10-----------------------#2020-12-07">https://betterprogramming.pub/combinelatest-an-easy-rxjs-operator-pattern-to-manage-interdependent-streams-ecc72b162227?source=collection_archive---------10-----------------------#2020-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6414" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松管理必须关联多个数据流的角度分量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b52f4752743e93adfa91fb0bfe33b501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCOC8c6rqAEeGZfwBdSt8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="6c5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">CombineLatest</code>言出必行:它会记住任何订阅流发出的最后一个值，然后将它们组合起来。这是非常有用的，因为它使您不必在每次一个流发出时检查所有其他流的值。</p><p id="120f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有一个包含许多相互依赖的数据流的角度分量，那么您可以使用本文中的<code class="fe lu lv lw lx b">combineLatest</code>模式来轻松地关联这些可观测量的数据。</p><p id="40fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么有必要同时检查来自不同流的最新值？因为通常情况下，只有当来自不同流的数据相关时，才允许某些场景。例如，在下面的代码中，只有当来自另一个流的用户文档表明用户已经支付了他们的sub时，来自一个流的私人帖子才能显示。</p><p id="6f1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我们来看看角形组件类。每次我细化代码的时候，我都会展示整个类，这样你就不用想象新代码是什么样子了。</p><p id="3ded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NgRx存储中的观察值<code class="fe lu lv lw lx b">userDoc$</code>和<code class="fe lu lv lw lx b">latestPost$</code>在<code class="fe lu lv lw lx b">combinedObservable$$</code>中合并，并且在执行任何操作之前，在<code class="fe lu lv lw lx b">if</code>语句中访问任何相互依赖的数据。<code class="fe lu lv lw lx b">combinedObservable$$</code>将组合的数据流作为一个数组发出。在这种情况下，输入到<code class="fe lu lv lw lx b">tap</code>操作符中的<code class="fe lu lv lw lx b">dataArray</code>的格式是:<code class="fe lu lv lw lx b">[{…}, {…}]</code>。</p><p id="30f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用了<code class="fe lu lv lw lx b">tap</code>操作符来托管一系列<code class="fe lu lv lw lx b">if</code>语句，这些语句可以用来同时访问值并对它们进行操作。如您所见，<code class="fe lu lv lw lx b">combineLatest</code>操作符就像一个漏斗，让您可以访问来自任何订阅流的最新值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1334" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">添加类范围变量的可观察值</h1><p id="b498" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">经常需要的下一个需求是对类范围变量中值的变化做出反应。这种变化可能是由于用户在模板中的选择，也可能是由于某些操作改变了变量值。在执行操作之前，可能需要将新的变量值与来自其他数据流的最新值进行比较或组合。</p><p id="58ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，有必要将类范围内的变量<code class="fe lu lv lw lx b">this.classScopedVar</code>转换为可观察变量，并将其输入<code class="fe lu lv lw lx b">combinedObservable$$</code>。</p><p id="0dfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么要创造一个<code class="fe lu lv lw lx b">this.classScopedVar</code>的可观察对象？为什么不在<code class="fe lu lv lw lx b">combinedObservable$$</code>里直接用<code class="fe lu lv lw lx b">this.classScopedVar</code>？原因很简单，只有当它的一个可观测量发出时，<code class="fe lu lv lw lx b">combinedObservable$$</code>才会发出一个组合流。因此，有必要将<code class="fe lu lv lw lx b">this.classScopedVar</code>转换成那些可观测量之一，以便它的值可以与来自其他流的最新值一起使用。</p><p id="4953" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经在类中添加了变量<code class="fe lu lv lw lx b">classScopedVar: string;</code>和<br/> <code class="fe lu lv lw lx b">classScopedVar$: BehaviorSubject&lt;string&gt;;</code>。然后我定义了<code class="fe lu lv lw lx b">this.classScopedVar$ = new BehaviorSubject(this.classScopedVar);</code>并将<code class="fe lu lv lw lx b">this.classScopedVar$</code>添加到<code class="fe lu lv lw lx b">combinedObservable$$</code>流中。在第三个<code class="fe lu lv lw lx b">if</code>语句中，您可以看到两个流的值是如何一起使用的(即<code class="fe lu lv lw lx b">postObject[classVar]</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c618" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ne">警告:在</em> <code class="fe lu lv lw lx b"><em class="ne">combineLatest</em></code> <em class="ne">流发出之前，所有输入流必须至少发出一次。确保您的所有流至少发出一次！</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0ccd" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">合并流的问题是</h1><p id="50b0" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">解析为<code class="fe lu lv lw lx b">true</code>的所有<code class="fe lu lv lw lx b">if</code>语句将在<code class="fe lu lv lw lx b">combinedObservable$$</code>的每次发射时被触发。这会导致问题，因为值不变的<code class="fe lu lv lw lx b">if</code>语句会被不必要地触发。例如，随着<code class="fe lu lv lw lx b">combinedObservable$$</code>的每次发射，第二个<code class="fe lu lv lw lx b">if</code>语句将总是被触发，因为数值不变，从而连续触发<code class="fe lu lv lw lx b">askUserToPay()</code>。</p><p id="04c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一些方法可以确保这种情况不会发生:</p><ul class=""><li id="eb6a" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">根据需要，使用一个手动的类范围变量来覆盖单个的<code class="fe lu lv lw lx b">if</code>语句。您可以根据需要打开和关闭该变量。作为一个类变量的替代，你可以使用另一个可观察的流，比如<code class="fe lu lv lw lx b">BehaviorSubject()</code>，并把它输入到组合流中，但是要记住它会导致组合流的另一次发射，这必须由任何其他<code class="fe lu lv lw lx b">if</code>语句来处理。</li><li id="ae39" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">使用不同的<code class="fe lu lv lw lx b">combineLatest</code>流将可观察性捆绑到不同的用例中。不要形成一个巨大的<code class="fe lu lv lw lx b">combineLatest</code>流，这会让管理你的<code class="fe lu lv lw lx b">if</code>报表成为一场噩梦。</li><li id="a9d6" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">使用<code class="fe lu lv lw lx b">distinctUntilChanged</code>过滤掉与上次发射相同的发射。</li><li id="bb56" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">使用<code class="fe lu lv lw lx b">filter</code>运算符排除不相关的值。</li><li id="ca33" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">如果你确定你已经完成，用<code class="fe lu lv lw lx b">takeUntil()</code>终止合并流，或者如果你知道你需要多少排放，使用<code class="fe lu lv lw lx b">take(#)</code>操作符。</li></ul><p id="d37f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在下面的代码中实现了这些更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="dbe0" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="af53" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">感谢阅读。如果你喜欢这篇文章，可以考虑在这里<a class="ae nt" href="https://craftedwebpages.medium.com/membership" rel="noopener">订阅</a>中级会员，以获得数以千计的其他文章。</p><p id="9b0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将在未来发布更多Angular、RxJS、NgRx和通用编程技巧。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5f90" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">学习资源</h1><ul class=""><li id="19a5" class="nf ng it la b lb mz le na lh nu ll nv lp nw lt nk nl nm nn bi translated"><a class="ae nt" href="https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest" rel="noopener ugc nofollow" target="_blank">组合测试</a>操作员</li><li id="fa35" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae nt" href="https://medium.com/angular-in-depth/rxjs-avoiding-takeuntil-leaks-fb5182d047ef" rel="noopener">直到泄漏</a></li><li id="137e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae nt" href="https://stackoverflow.com/questions/52198240/rxjs-difference-between-complete-and-unsubscribe-in-observable/52198997" rel="noopener ugc nofollow" target="_blank"> RxJs完成和退订的区别在可观察到吗？</a></li><li id="c234" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae nt" href="https://stackoverflow.com/questions/48771350/rxjs-subscriber-unsubscribe-vs-complete" rel="noopener ugc nofollow" target="_blank"> RxJS订户退订与完成</a></li><li id="64a5" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae nt" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/distinctuntilchanged" rel="noopener ugc nofollow" target="_blank"> distinctUntilChanged </a>运算符</li><li id="4039" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae nt" href="https://rxjs-dev.firebaseapp.com/api/operators/filter" rel="noopener ugc nofollow" target="_blank">过滤</a>操作符，还有这里的<a class="ae nt" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/filter" rel="noopener ugc nofollow" target="_blank"/></li><li id="cab9" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae nt" href="https://www.learnrxjs.io/learn-rxjs/operators/utility/do" rel="noopener ugc nofollow" target="_blank">抽头</a>操作符</li><li id="412b" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae nt" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/take" rel="noopener ugc nofollow" target="_blank">带</a>符</li></ul></div></div>    
</body>
</html>