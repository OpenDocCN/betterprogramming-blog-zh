<html>
<head>
<title>Recursion Schemes Explained Using Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用正则表达式解释递归方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-schemes-explained-using-regular-expressions-467765771fa3?source=collection_archive---------11-----------------------#2022-11-21">https://betterprogramming.pub/recursion-schemes-explained-using-regular-expressions-467765771fa3?source=collection_archive---------11-----------------------#2022-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5f05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">变形和同态的教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f2656051970000eaf2d7d49ad1179feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GiYydvccRdgTm-4lO1JCvQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由史蒂芬·米勒拍摄的照片<a class="ae kv" href="https://www.flickr.com/photos/aloha75/8398411519/in/photostream/" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="4d56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归方案是一种抽象递归的方式。有些人认为没有递归方案的函数式编程等同于没有循环的命令式编程，但是有语句。</p><blockquote class="lw lx ly"><p id="15e8" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">正如使用<code class="fe ls lt lu lv b">while</code>和<code class="fe ls lt lu lv b">for</code>循环而不是<code class="fe ls lt lu lv b">goto</code>给命令式控制流带来了结构和协调，使用递归方案而不是手写递归给递归计算带来了相似的结构。这一观点非常重要，我将重复一遍:递归模式对于惯用的函数式编程来说就像<code class="fe ls lt lu lv b">for</code>和<code class="fe ls lt lu lv b">while</code>对于惯用的命令式编程一样重要。— <a class="ae kv" href="https://t.co/3akhET7qPk" rel="noopener ugc nofollow" target="_blank">帕特里克·汤普森</a></p></blockquote><p id="56da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有这么强烈的意见。我认为递归方案非常有趣，而且我也对Patrick Bahr与树自动机的联系有偏见，因为我已经用树自动机做了相当多的工作，看到它被应用到实践中对我来说比对你来说更令人兴奋。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/c95bd33bc1566edea99ac9c20bddc9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUCCeUoSJljGHxHquSF0wg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">米先生试图递归地召唤米先生来完成不可能完成的任务——从杰瑞的高尔夫比赛中拿掉两杆——正如在<a class="ae kv" href="https://en.wikipedia.org/wiki/Rick_and_Morty" rel="noopener ugc nofollow" target="_blank">里克和莫蒂</a>中看到的</p></figure><p id="019c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与我们习惯的递归不同，这些递归方案限制了我们对将在函数中应用的递归类型的明确性。递归模式有助于可读性(最终),并允许递归求值函数的更简单实现，但在定义数据类型时确实需要一些额外的样板文件，并需要一些实践来学习如何使用它们。</p><p id="887b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归有几种类型，所以我们有几个方案来涵盖它们。在本文中，我将尝试解释两种最常见的递归方案:</p><ul class=""><li id="aef9" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated">变形:一个简单的自底向上递归的别称。</li><li id="d44a" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">同态性:另一个稍微聪明一点的需要一些堆栈信息的自底向上递归的别称。还是挺简单的。</li></ul><p id="2295" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="lz">注意</em> </strong> <em class="lz">:本文要求对Haskell有所了解，至少达到实现一个函子。</em></p><h1 id="e2cd" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">正则表达式的导数算法</h1><p id="aaa1" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">解释递归方案需要一个例子。为此，我选择了正则表达式的导数算法，我在之前的文章中已经介绍过了。</p><p id="3db0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将只包括使用普通递归的实现代码，这样我们就可以看到添加递归方案会有什么不同。这里是完整的正则表达式匹配算法，使用我们习惯的递归。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="30b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定一个字符作为输入，derivative或<code class="fe ls lt lu lv b">deriv</code>函数返回要匹配的正则表达式。我们使用<code class="fe ls lt lu lv b">foldl</code>对输入字符串进行循环，以获得在我们用完整个字符串后剩下的匹配正则表达式。然后我们使用<code class="fe ls lt lu lv b">nullable</code>函数检查得到的正则表达式是否与空字符串匹配，以了解使用了整个字符串的正则表达式是否与该字符串匹配。</p><p id="d355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从技术上来说，<code class="fe ls lt lu lv b">foldl</code>已经抽象了一些递归，但是我们将通过递归方案把这种抽象提升到另一个层次。</p><h1 id="bd37" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">一种味道</h1><p id="27ef" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在我们深入之前，让我们先了解一下我们要去哪里。<code class="fe ls lt lu lv b">nullable</code>函数是一个完美的变形，因为它只做自底向上的递归。自底向上递归是指函数的结果仅依赖于应用于其子函数的递归函数的结果，而不依赖于递归函数中传递的任何中间结果。我们将用下面的等价函数替换上面原始实现中的<code class="fe ls lt lu lv b">nullable</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ls lt lu lv b">nullableAlg</code>函数不需要对自己做任何递归调用。在本文中，我们将解释这是如何实现的，以及:</p><ul class=""><li id="368c" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated">什么是<code class="fe ls lt lu lv b">FAlgebra</code></li><li id="ae69" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">为什么会有一种新的类型叫做<code class="fe ls lt lu lv b">RegexF</code></li><li id="82d0" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><code class="fe ls lt lu lv b">cata</code>函数如何执行自底向上的递归</li></ul><h1 id="9792" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">什么函子</h1><p id="df8c" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们的递归方案需要一个地方来存储递归过程中的中间结果。我们需要一个容器来存放这些结果。我们知道仿函数是一个很好的容器，所以我们将通过参数化把我们的<code class="fe ls lt lu lv b">Regex</code>数据类型变成仿函数。这个参数可以在我们的递归算法中存储各种中间结果。</p><p id="106d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先将<code class="fe ls lt lu lv b">Regex</code>重命名为<code class="fe ls lt lu lv b">RegexF</code>，其中<code class="fe ls lt lu lv b">F</code>代表函子。我们对所有的递归<code class="fe ls lt lu lv b">Regex</code>字段进行参数化。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你回头看一下<code class="fe ls lt lu lv b">Regex</code>的原始定义，你会发现我们已经用<code class="fe ls lt lu lv b">r</code>替换了所有递归出现的<code class="fe ls lt lu lv b">Regex</code>。我们将参数<code class="fe ls lt lu lv b">r</code>命名为递归或结果。这个<code class="fe ls lt lu lv b">r</code>将用于存储布尔结果，因为我们使用catamorphism对可空函数进行自底向上的递归，但很快会有更多内容。</p><p id="dba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们有一个问题。我们必须选择将<code class="fe ls lt lu lv b">r</code>设置为什么参数，以使用<code class="fe ls lt lu lv b">RegexF</code>的定义恢复我们原来的<code class="fe ls lt lu lv b">Regex</code>。</p><ul class=""><li id="061c" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated">如果我们把<code class="fe ls lt lu lv b">r</code>做成<code class="fe ls lt lu lv b">Bool</code>，那就只能造出像<code class="fe ls lt lu lv b">EmptyString</code>这样非常小的表情，其他的就更没意义了:<code class="fe ls lt lu lv b">Concat True False</code>。</li><li id="4d35" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">如果我们选择<code class="fe ls lt lu lv b">r</code>为<code class="fe ls lt lu lv b">Regex</code>，我们得到<code class="fe ls lt lu lv b">RegexF Regex</code>，这将工作，但是我们失去了递归仿函数的属性。</li><li id="44d3" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">我们可以尝试选择<code class="fe ls lt lu lv b">r</code>为<code class="fe ls lt lu lv b">RegexF</code>，然后我们得到<code class="fe ls lt lu lv b">RegexF RegexF</code>，这是接近的，但是现在我们要求另一个<code class="fe ls lt lu lv b">RegexF</code>为第二个<code class="fe ls lt lu lv b">RegexF</code>的参数，所以我们得到<code class="fe ls lt lu lv b">RegexF (RegexF RegexF)</code>，但是这是一个永无止境的问题。在某个时刻，我们希望这个递归结束。</li><li id="a6bc" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">我们可以尝试两个层次的<code class="fe ls lt lu lv b">RegexF</code>，然后我们得到<code class="fe ls lt lu lv b">RegexF (RegexF (RegexF ()))</code>，但是这样我们只能表示两个层次深的正则表达式。</li></ul><p id="e27e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想要一个函子，但是我们也不想被最大递归深度所限制。</p><h1 id="fd6c" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">修好它，菲利克斯</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/43f7414eff5f3d639b945122de249ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*AuC9w0NKXd_lBjM1I273jw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在监狱里，如果你想逃跑，修理东西是没什么用的——就像在《破坏王拉尔夫》里看到的那样</p></figure><p id="7e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不动点是函数收敛的地方，或者是函数的输入等于输出的地方。比如:f(x) = x因为1 = 1所以有一个不动点1。</p><p id="26e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用一个固定点重新创建我们的等价数据类型:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="c406" class="nw mt iq lv b gy nx ny l nz oa">type Regex = Fix RegexF</span></pre><p id="aae7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ls lt lu lv b">Fix RegexF</code>怎么等同于我们原来的<code class="fe ls lt lu lv b">Regex</code>？为了理解这一点，我们需要仔细看看<code class="fe ls lt lu lv b">Fix</code>。<code class="fe ls lt lu lv b">Fix</code>是定点数据类型:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="1c45" class="nw mt iq lv b gy nx ny l nz oa">newtype Fix f = Fix (f (Fix f))</span></pre><p id="350d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我花了很长时间来理解这一点，但最终，我的思想达到了一个固定的点。</p><p id="1636" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你冷静地看每一件作品，它就有意义了:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="e734" class="nw mt iq lv b gy nx ny l nz oa">newtype Fix f = Fix (f (Fix f))</span></pre><ol class=""><li id="18c7" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr ob mk ml mm bi translated">第一个<code class="fe ls lt lu lv b">Fix</code>是类型名。</li><li id="0cea" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr ob mk ml mm bi translated">第二个<code class="fe ls lt lu lv b">Fix</code>是类型构造函数名。</li><li id="5ea5" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr ob mk ml mm bi translated">第三个<code class="fe ls lt lu lv b">Fix</code>是正在使用的类型。</li></ol><p id="e375" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Fix</code>类型接受一个名为<code class="fe ls lt lu lv b">f</code>的类型参数。<code class="fe ls lt lu lv b">f</code>是一个函子，这意味着它也需要一个类型参数。在这种情况下，type参数将是最后一个<code class="fe ls lt lu lv b">Fix f</code>。</p><p id="4672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们选择<code class="fe ls lt lu lv b">RegexF</code>作为我们的<code class="fe ls lt lu lv b">f</code>，我们的类型参数<code class="fe ls lt lu lv b">r</code>就会是<code class="fe ls lt lu lv b">Fix RegexF</code>，但是我们知道<code class="fe ls lt lu lv b">Fix RegexF</code>真的是<code class="fe ls lt lu lv b">Fix (RegexF (Fix RegexF))</code>，我们知道真的是<code class="fe ls lt lu lv b">Fix (RegexF (Fix (RegexF (Fix RegexF))))</code>等等。这正是我们想要的。我们现在可以表示任何深度的正则表达式。费利克斯修好了！</p><p id="fa70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">screen it Ralph</em>也可以取消固定我们的<code class="fe ls lt lu lv b">Fix</code>数据类型，这将有助于实现catamorphism函数。</p><p id="1a91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">wreckit</code>模式与<code class="fe ls lt lu lv b">Fix</code>匹配并返回内部值:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="e32e" class="nw mt iq lv b gy nx ny l nz oa">wreckit :: Fix f -&gt; f (Fix f)<br/>wreckit (Fix x) = x</span></pre><h1 id="3370" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">什么是F代数</h1><p id="769e" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">现在我们已经创建了函子表达式，让我们来介绍一些关于如何抽象递归的理论。</p><p id="86f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代数由以下内容组成:</p><ol class=""><li id="9a4d" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr ob mk ml mm bi translated">形成表情的能力。例如，<code class="fe ls lt lu lv b">Regex</code>构造函数和</li><li id="8897" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr ob mk ml mm bi translated">评估这些表达式的能力，例如<code class="fe ls lt lu lv b">nullable :: Regex -&gt; Bool</code></li></ol><p id="933b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管代数由两部分组成，但评估函数通常被称为代数:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="8205" class="nw mt iq lv b gy nx ny l nz oa">type Algebra e r = e -&gt; r</span></pre><p id="ec25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着<code class="fe ls lt lu lv b">nullable</code>功能实际上是<code class="fe ls lt lu lv b">NullableAlgebra</code></p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="1857" class="nw mt iq lv b gy nx ny l nz oa">type NullableAlgebra = Algebra Regex Bool<br/>nullable :: NullableAlgebra</span></pre><p id="1b96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">范畴理论中的F-代数由下列组成:</p><ol class=""><li id="9e47" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr ob mk ml mm bi translated">形成函子表达式的能力，例如<code class="fe ls lt lu lv b">RegexF r</code>和</li><li id="198e" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr ob mk ml mm bi translated">评价这些表情的能力，比如:<code class="fe ls lt lu lv b">nullable :: RegexF Bool -&gt; Bool</code>。</li></ol><p id="5af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着F-代数的类型是:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="b5e1" class="nw mt iq lv b gy nx ny l nz oa">type FAlgebra f r = f r -&gt; r</span></pre><p id="902d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">nullableAlg</code>功能就是<code class="fe ls lt lu lv b">NullableAlgebra</code>:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="996c" class="nw mt iq lv b gy nx ny l nz oa">type NullableFAlgebra = FAlgebra RegexF Bool<br/>nullableAlg :: NullableFAlgebra</span></pre><h1 id="8359" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">变形:自底向上递归</h1><p id="cc22" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe ls lt lu lv b">cata</code>函数如何抽象出自底向上的递归？下面是整个函数:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="3970" class="nw mt iq lv b gy nx ny l nz oa">cata :: Functor f =&gt; FAlgebra f r -&gt; Fix f -&gt; r<br/>cata alg = alg . fmap (cata alg) . wreckit</span></pre><p id="857e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个很抽象。让我们说得更具体些。为了有助于可读性，让我们首先<a class="ae kv" href="https://github.com/tfausak/flow/blob/main/source/library/Flow.hs" rel="noopener ugc nofollow" target="_blank">将Elm的管道操作符添加到Haskell </a>中，它相当于Haskell中的<code class="fe ls lt lu lv b">&amp;</code>操作符，但它看起来更像一个Unix管道，并指示方向。抱歉，我觉得这个更好读。</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="bcae" class="nw mt iq lv b gy nx ny l nz oa">infixl 0 |&gt;<br/>(|&gt;) :: a -&gt; (a -&gt; b) -&gt; b<br/>x |&gt; f = f x</span></pre><p id="501a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使<code class="fe ls lt lu lv b">cata</code>函数的实现更具体到<code class="fe ls lt lu lv b">nullableAlg</code>函数的应用:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="28b4" class="nw mt iq lv b gy nx ny l nz oa">cata :: NullableFAlgebra -&gt; Regex -&gt; Bool<br/>cata nullableAlg regex = <br/>  wreckit regex<br/>  |&gt; fmap (cata nullableAlg)<br/>  |&gt; nullableAlg</span></pre><p id="7844" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为第一步，<code class="fe ls lt lu lv b">wreckit</code>将取出我们的<code class="fe ls lt lu lv b">Regex</code>并移除外部的<code class="fe ls lt lu lv b">Fix</code>:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="9de7" class="nw mt iq lv b gy nx ny l nz oa">wreckit :: Regex -&gt; RegexF Regex</span></pre><p id="e412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个函子，这意味着我们可以<code class="fe ls lt lu lv b">fmap</code>超过<code class="fe ls lt lu lv b">RegexF</code>。<code class="fe ls lt lu lv b">fmap</code>向下递归一级。我们想要递归的函数是与<code class="fe ls lt lu lv b">cata nullableAlg</code>等价的<code class="fe ls lt lu lv b">nullable</code>函数。</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="8dfb" class="nw mt iq lv b gy nx ny l nz oa">nullable :: Regex -&gt; Bool<br/>nullable = cata nullableAlg</span></pre><p id="b629" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在递归的每一层，我们都想调用我们的<code class="fe ls lt lu lv b">nullable</code>函数。因此，每当我们<code class="fe ls lt lu lv b">fmap</code>向下一级，我们就向下传递<code class="fe ls lt lu lv b">cata nullableAlg</code>以在下一级被调用。</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="5d2c" class="nw mt iq lv b gy nx ny l nz oa">fmap (cata nullableAlg) :: RegexF Regex -&gt; RegexF Bool</span></pre><p id="8655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们递归返回时，我们返回一个<code class="fe ls lt lu lv b">RegexF Bool</code>，它存储了较低级别的<code class="fe ls lt lu lv b">nullable</code>计算的中间结果。然后我们必须让它通过最终的<code class="fe ls lt lu lv b">nullableAlg</code>来得到最终的<code class="fe ls lt lu lv b">Bool</code>结果。</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="a4cc" class="nw mt iq lv b gy nx ny l nz oa">nullableAlg :: RegexF Bool -&gt; Bool</span></pre><p id="c093" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们现在可以定义没有任何递归的<code class="fe ls lt lu lv b">nullableAlg</code>函数，因为<code class="fe ls lt lu lv b">cata</code>函数将为我们的<code class="fe ls lt lu lv b">nullable</code>函数做所有自底向上的递归:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="cc8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是使用同态的一个例子，同态仅限于简单的自底向上递归，所以让我们学习另一个递归方案。</p><h1 id="6245" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">智能构造函数</h1><p id="b6ae" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在我们检查下一个递归方案之前，您可能会担心API会是什么样子。你将如何向用户解释定点对你的图书馆用户来说是什么？我们的想法是将这些实现细节限制在库的内部。我们的API不会暴露任何固定点。它不会向这个库的用户公开<code class="fe ls lt lu lv b">nullableAlg</code>函数，只公开<code class="fe ls lt lu lv b">nullable</code>函数。数据类型构造函数也是如此。我们不想将<code class="fe ls lt lu lv b">Fix</code>暴露在我们的库之外，所以我们创建了更智能的构造器，为用户构造我们可以暴露的固定点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也是为了我们在下一节使用同态实现<code class="fe ls lt lu lv b">deriv</code>函数时的内部便利。</p><h1 id="0d7a" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">同质异晶</h1><blockquote class="lw lx ly"><p id="72e2" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">如果你不理解循环，它们只是一个自然数上的同态——约瑟夫·斯文宁松</p></blockquote><p id="c4c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再来看看最初的<code class="fe ls lt lu lv b">deriv</code>功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="104e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">deriv</code>函数不是简单的自底向上递归，因为<code class="fe ls lt lu lv b">Concat</code>步骤需要检查第一个表达式<code class="fe ls lt lu lv b">r</code>是否可为空。这是仅在堆栈上可用的信息。一个同态不仅在函子参数中保留一个间歇的结果，而且保留一个原始表达式的副本，这样我们就可以检查它是否可为空。这需要一个叫做<code class="fe ls lt lu lv b">RAlgebra</code>的新代数:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="20e0" class="nw mt iq lv b gy nx ny l nz oa">type RAlgebra f r = f (Fix f, r) -&gt; r</span></pre><p id="4de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函子现在包含一个元组，其中第一个参数是原始表达式的副本，第二个是中间结果。我们的<code class="fe ls lt lu lv b">DeriveRAlgebra</code>，看起来会有点混乱，因为我们的中间结果与原始结果的副本是同一类型的:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="ef9b" class="nw mt iq lv b gy nx ny l nz oa">type DeriveRAlgebra = RAlgebra RegexF Regex :: RegexF (Regex, Regex) -&gt; Regex</span></pre><p id="c260" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ls lt lu lv b">RAlgebra</code>将由<code class="fe ls lt lu lv b">para</code>函数进行评估:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="e4a6" class="nw mt iq lv b gy nx ny l nz oa">para :: (Functor f) =&gt; RAlgebra f r -&gt; Fix f -&gt; r<br/>para alg f =<br/>  wreckit f<br/>  |&gt; fmap (\x -&gt; (x, para alg x))<br/>  |&gt; alg</span></pre><p id="b5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以针对<code class="fe ls lt lu lv b">derivAlg</code>功能做更具体的说明:</p><pre class="kg kh ki kj gt ns lv nt nu aw nv bi"><span id="2821" class="nw mt iq lv b gy nx ny l nz oa">para :: DeriveRAlgebra -&gt; Regex -&gt; Regex<br/>para derivAlg regex = <br/>  wreckit regex<br/>  |&gt; fmap (\x -&gt; (x, para derivAlg x))<br/>  |&gt; derivAlg</span></pre><p id="f471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">cata</code>函数的唯一不同之处是在元组中存储原始<code class="fe ls lt lu lv b">Regex</code>、<code class="fe ls lt lu lv b">x</code>的副本，而不仅仅是中间结果<code class="fe ls lt lu lv b">para derivAlg x</code>。</p><ol class=""><li id="108e" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr ob mk ml mm bi translated">我们使用<code class="fe ls lt lu lv b">wreckit :: Regex -&gt; RegexF Regex</code>移除<code class="fe ls lt lu lv b">Fix</code>的外层。</li><li id="b5cf" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr ob mk ml mm bi translated">我们使用<code class="fe ls lt lu lv b">fmap</code>向下递归一级仿函数。</li><li id="bea3" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr ob mk ml mm bi translated">我们在较低层次应用的函数取一个<code class="fe ls lt lu lv b">Regex</code>并返回原始的<code class="fe ls lt lu lv b">Regex</code>以及派生的<code class="fe ls lt lu lv b">Regex</code> : <code class="fe ls lt lu lv b">Regex -&gt; (Regex, Regex)</code></li><li id="19d6" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr ob mk ml mm bi translated">结果在一个函子<code class="fe ls lt lu lv b">RegexF (Regex, Regex)</code>中，我们可以使用<code class="fe ls lt lu lv b">derivAlg c :: RegexF (Regex, Regex) -&gt; Regex</code>对其求值，得到最终的派生结果<code class="fe ls lt lu lv b">Regex</code>。</li></ol><p id="1ed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们现在可以定义没有任何递归的<code class="fe ls lt lu lv b">derivAlg</code>函数，因为<code class="fe ls lt lu lv b">para</code>函数将为我们的<code class="fe ls lt lu lv b">deriv</code>函数做所有的递归工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5c94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会注意到，我们需要交换<code class="fe ls lt lu lv b">derivAlg</code>函数的输入参数才能让它工作。</p><h1 id="5159" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">完整的算法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/321c7a9d8f5983792989492bf569575c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QSSBeM2FyvxO4AgPT4o6Nw.gif"/></div></div></figure><p id="352e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是使用递归方案的两个例子，但它足以完成我们的算法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在GitHub 上找到完整的<a class="ae kv" href="https://github.com/awalterschulze/recursion-schemes-demo" rel="noopener ugc nofollow" target="_blank">演示。</a></p><h1 id="1bcf" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="3586" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们只讨论了两种递归方案，但是还有很多其他的方案:</p><ul class=""><li id="e698" class="me mf iq ky b kz la lc ld lf mg lj mh ln mi lr mj mk ml mm bi translated">除了<code class="fe ls lt lu lv b">para</code>和<code class="fe ls lt lu lv b">cata</code>之外，还有一个文件夹叫做<code class="fe ls lt lu lv b">histo</code>。历史形态保存了所有递归计算的历史，这对于需要记忆以提高效率的算法很有用，比如Fibonacci。</li><li id="fc1a" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">展开，包括<code class="fe ls lt lu lv b">ana</code>、<code class="fe ls lt lu lv b">apo</code>和<code class="fe ls lt lu lv b">futu</code>。变形是变形主义的范畴理论对偶。在希腊语中，<code class="fe ls lt lu lv b">cata</code>是毁灭的意思，而<code class="fe ls lt lu lv b">ana</code>是建设的意思。变形可以递归地构建一个表达式，例如构建一个给定长度的零列表。</li><li id="b0ad" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">然后还有重折:<code class="fe ls lt lu lv b">hylo</code>，是一个<code class="fe ls lt lu lv b">ana</code>后的一个<code class="fe ls lt lu lv b">cata</code>和<code class="fe ls lt lu lv b">chrono</code>，是一个<code class="fe ls lt lu lv b">histo</code>和一个<code class="fe ls lt lu lv b">futu</code>。</li></ul><p id="e42e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有兴趣了解更多关于递归方案的知识，我在参考资料部分链接了一些资源，这样您就可以用morph继续您自己的史诗般的冒险:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/197473c0e67625fa0efea29d99025346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*YlX2wz0Iivqvp4ZGFCKa2Q.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我小时候在电视上看的:变形</p></figure><h1 id="cd06" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">谢谢你</h1><ul class=""><li id="a38c" class="me mf iq ky b kz nk lc nl lf oe lj of ln og lr mj mk ml mm bi translated">Andor Pénzes 校对并解释所有其他递归方案，尤其是因为我仍然只理解其中的一些。</li><li id="8946" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated">Max Heiber 发现了一个错误，并对自底向上递归提出了更好的解释。</li></ul><h1 id="1573" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">参考</h1><ul class=""><li id="2e25" class="me mf iq ky b kz nk lc nl lf oe lj of ln og lr mj mk ml mm bi translated"><a class="ae kv" href="https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html" rel="noopener ugc nofollow" target="_blank">递归方案介绍——帕特里克·汤姆森</a></li><li id="1d0a" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae kv" href="https://blog.sumtypeofway.com/posts/recursion-schemes-part-3.html" rel="noopener ugc nofollow" target="_blank">递归方案，第三部分:上下文中的折叠——帕特里克·汤姆森</a></li><li id="a581" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae kv" href="https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/" rel="noopener ugc nofollow" target="_blank">理解F-代数—巴托什·米莱斯基</a></li><li id="f7ce" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae kv" href="https://bahr.io/pubs/talks/bahr12uucs.html" rel="noopener ugc nofollow" target="_blank">从树自动机中导出模块递归方案——帕特里克·巴尔</a></li><li id="3d98" class="me mf iq ky b kz mn lc mo lf mp lj mq ln mr lr mj mk ml mm bi translated"><a class="ae kv" href="https://github.com/awalterschulze/recursion-schemes-demo" rel="noopener ugc nofollow" target="_blank">使用递归方案的正则表达式导数的Haskell实现— awalterschulze </a></li></ul></div></div>    
</body>
</html>