<html>
<head>
<title>The Advanced YAML Syntax Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级YAML语法备忘单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-advanced-yaml-syntax-cheatsheet-f860043decb4?source=collection_archive---------2-----------------------#2021-05-07">https://betterprogramming.pub/the-advanced-yaml-syntax-cheatsheet-f860043decb4?source=collection_archive---------2-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eede" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">查看验证器、解析器、分隔符、指令等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/773ced76b622712304c8fcf65630e420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6o0FZmfjeJOhmYxQnsxGg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="e5de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">YAML (YAML不是标记语言)是一种数据序列化语言，用于创建键值对配置文件和应用程序API。它是JSON的超集，使用换行符和空白进行格式化，以提高可读性。</p><p id="245f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然不是日常使用的技术，但它是Ansible等许多现代技术的重要基础，因此是高薪开发人员角色的先决条件。</p><p id="3f73" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将帮助你完善你的YAML知识，这样你就能给下一位面试官留下深刻印象。</p><p id="b5f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新来YAML吗？在继续之前，你可能想让<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/yaml-tutorial-get-started-with-yaml-in-5-minutes-549d462972d8">快速浏览一下这篇文章</a>。</p><p id="4a09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是我们今天要讲的内容:</p><ul class=""><li id="f942" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">验证器和解析器</li><li id="5a27" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">锚点和别名</li><li id="63c2" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">计划</li><li id="cf74" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">转义序列</li><li id="4754" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">分隔符和指令</li><li id="5f6d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">包扎</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="addc" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">验证器和解析器</h1><p id="7527" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">虽然YAML比XML可读性更好，但是很容易忽略格式错误，比如多行部分的空格数或者忘记换行符。这可能会给YAML解析器带来巨大的错误，该解析器会将YAML解释成更多机器可读的动作。</p><p id="402e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">手工很难发现解析错误，所以许多开发人员选择使用web验证器或linter。这些工具会检查您的YAML文档并突出显示任何潜在的错误，以确保您在投入使用之前拥有有效的YAML。</p><p id="53aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最流行的验证器是YAMLLint，这是一个免费的开源工具，可以在你的浏览器或GitHub上找到。YAMLLint被认为是最方便的linter，因为它提供了错误高亮、复制/粘贴YAML的自动格式化和自动纠正选项。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="8fc8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">锚点和别名</h1><p id="13e3" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">锚和别名是YAML构造，允许您减少重复语法并扩展现有数据节点。您可以在实体上放置锚点(<code class="fe nk nl nm nn b">&amp;</code>)来标记多行部分。然后，您可以使用别名(<code class="fe nk nl nm nn b">*</code>)在文档中调用该锚来引用该部分。锚点和别名对大型项目非常有帮助，因为它们减少了额外线条造成的视觉混乱。</p><p id="a0dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">别名本质上充当“见上”命令，使程序暂停标准遍历，返回到锚点，然后在完成锚定部分后继续标准遍历。如果你熟悉面向对象的编程设计，你会对锚有宾至如归的感觉。</p><p id="836a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面，<code class="fe nk nl nm nn b">build-test</code>锚从第3行开始，在第13行和第15行被别名调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="ee2d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">覆盖和扩展</h1><p id="e90d" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">您也可以通过在别名前输入<code class="fe nk nl nm nn b">&lt;&lt;:</code>来调整锚。在这下面，你可以写下任何想要的改变。如果新映射具有相同的名称，映射将被覆盖；如果名称不同，映射将在以后添加。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c701" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">计划</h1><p id="400f" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">模式是YAML 1.2中的规则集，它告诉加载器/解析器YAML文件的每个部分在实际命令中转换成什么。它们本质上是一组用于处理人类可读的YAML标签的<code class="fe nk nl nm nn b">if</code> / <code class="fe nk nl nm nn b">then</code>语句的集合。例如，YAML核心模式声明<code class="fe nk nl nm nn b">!!str my string</code>和<code class="fe nk nl nm nn b">my string</code>是等价的，应该被解析为相同的动作。</p><p id="d245" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通用YAML有一个默认的模式，而许多特殊用途的模式适合某些特殊的场景。您甚至可以在JSON模式存储上创建自己的定制模式或下载其他用户的模式。</p><p id="8cb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当配置文件包含自定义对象时，或者如果您希望创建特定于语言的对象序列化，自定义架构会很有帮助。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9446" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">YAML的三种默认模式是:</p><ul class=""><li id="e75b" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">Failsafe —一个极简模式，只支持字符串(<code class="fe nk nl nm nn b">!!str</code>)、映射(<code class="fe nk nl nm nn b">!!map</code>)和序列(<code class="fe nk nl nm nn b">!!seq</code>)标签。由于其简单性，Failsafe保证可以与任何YAML文档一起工作，但是它不支持任何复杂的标签。</li><li id="0c79" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">JSON:一个基础模式，旨在可靠地解析等价的YAML和JSON文件，得到相同的最终结果。这是最常用的模式，也是大多数模式的起点。它支持所有故障保护标签，以及布尔(<code class="fe nk nl nm nn b">!!bool</code>)、空(<code class="fe nk nl nm nn b">!!null</code>)、整数(<code class="fe nk nl nm nn b">!!int</code>)和浮点(<code class="fe nk nl nm nn b">!!float</code>)。</li><li id="c434" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">核心:默认的YAML模式，在YAML端扩展了匹配标准。它本质上是JSON模式的一个不那么固执己见的版本。例如，JSON接受符合标准“匹配:<code class="fe nk nl nm nn b">true</code> | <code class="fe nk nl nm nn b">false</code>”的布尔值。相比之下，Core的布尔接受形式如下:"<code class="fe nk nl nm nn b">true</code>|<code class="fe nk nl nm nn b">True</code>|<code class="fe nk nl nm nn b">TRUE</code>|<code class="fe nk nl nm nn b">false</code>|<code class="fe nk nl nm nn b">False</code>|<code class="fe nk nl nm nn b">FALSE</code>"</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f993" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">转义序列</h1><p id="a1a7" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">YAML的可读语法之所以可行，是因为它在方括号或花括号之类的行内语法标记上使用了缩进和空白。然而，在引号标量中使用特殊字符时，这可能会变得很困难。</p><p id="1ff9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">YAML提供了转义序列，允许您指示字符应该被解释为特殊字符还是标量的一部分。例如，您可以使用<code class="fe nk nl nm nn b">&amp;#x20;</code>转义一个空格，以创建一个值为<code class="fe nk nl nm nn b">“ “</code>的字符串。</p><p id="f383" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">转义序列有三种类型:</p><ul class=""><li id="1518" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">实体转义，这允许您通过空格(<code class="fe nk nl nm nn b">&amp;#x20;</code>)、冒号(<code class="fe nk nl nm nn b">&amp;#58;</code>)或&amp;符号(<code class="fe nk nl nm nn b">&amp;amp;</code>)来使用语法上重要的字符。</li><li id="2570" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">Unicode转义，它允许您通过直接从键值对的Unicode列表中调用它们的惟一键来添加空格(<code class="fe nk nl nm nn b">\u0020</code>)、单引号(<code class="fe nk nl nm nn b">\u0027</code>)或双引号(<code class="fe nk nl nm nn b">\u0022</code>)。</li><li id="dd04" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">引用转义，允许您使用附加引号显示引用的句子。例如，双引号可以显示在单引号(<code class="fe nk nl nm nn b">‘ “quote” ’</code>)中，嵌套在另一组双引号(<code class="fe nk nl nm nn b">“abc “quote” cba”</code>)中，或者嵌套在单引号(<code class="fe nk nl nm nn b">‘ ‘quote’ ’</code>)中。</li></ul><p id="d7b0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:YAML转义序列的完整列表可以在官方的YAML规范中找到。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="a7b7" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">分隔符和指令</h1><p id="3259" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">你可能已经注意到所有的YAML文档都是以<code class="fe nk nl nm nn b">---</code>开头的。这通知解析器这个数据是一个单独的块，但是为了提高效率，它是作为同一个请求的一部分发送的。</p><p id="497f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个更高级的分隔符是<code class="fe nk nl nm nn b">...</code>，它标志着一个文档的结束。文档结束分隔符后面必须跟有文档开始分隔符(<code class="fe nk nl nm nn b">---</code>)或一组指令。指令是由<code class="fe nk nl nm nn b">%</code>标记的已定义设置，位于文档之前，其后是<code class="fe nk nl nm nn b">---</code>。</p><p id="7776" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着需要<code class="fe nk nl nm nn b">...</code>和<code class="fe nk nl nm nn b">---</code>来标记指令空间的边界。当前的两个指令是<code class="fe nk nl nm nn b">%YAML</code>，它允许您为即将到来的文档设置YAML版本，以及<code class="fe nk nl nm nn b">%TAGS</code>，它允许您为将在文档中使用的标签创建定制的快捷方式。</p><p id="4c64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">指令只在特殊情况下有用，比如使用一个太大而无法更新的旧YAML文档。通常，您不需要指令或文档分隔符。</p><pre class="kg kh ki kj gt nr nn ns nt aw nu bi"><span id="65fc" class="nv mo iq nn b gy nw nx l ny nz">doc 1 <br/>... </span><span id="77dd" class="nv mo iq nn b gy oa nx l ny nz">%TAG !foo! !foo-types/ </span><span id="607c" class="nv mo iq nn b gy oa nx l ny nz">-------- </span><span id="ac80" class="nv mo iq nn b gy oa nx l ny nz">doc 2</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="1263" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">时间戳</h1><p id="2715" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">Timestamp是一种有用的数据类型，它允许您将时间存储为一个单元，而不是不同数字的集合。它由<code class="fe nk nl nm nn b">!!timestamp</code>数据标签标记，可以保存各种级别的特异性，例如简单(<code class="fe nk nl nm nn b">yyyy/mm/dd</code>)或精确到几分之一秒(<code class="fe nk nl nm nn b">2001-12-15T2:59:43.10</code>)。你也可以用空格分隔日期和时间，让时间戳更易读，就像<code class="fe nk nl nm nn b">2001-12-15 2:59:43.10</code>。</p><p id="5a28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有时间戳都记录为协调世界时(UTC ),除非在时间戳末尾指定了另一个时区。您可以通过包括比UTC早或晚多少小时来定义时区。</p><p id="33fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，我可以将时间戳设置为太平洋标准时间(PST ),并在末尾加上一个<code class="fe nk nl nm nn b">-8</code>:</p><pre class="kg kh ki kj gt nr nn ns nt aw nu bi"><span id="342b" class="nv mo iq nn b gy nw nx l ny nz">2001-12-15 2:59:43.10 -8`.</span></pre><p id="10b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这类似于JavaScript或Python等流行编程语言中使用的<code class="fe nk nl nm nn b">DateTime</code>，除了它如何处理时区。<code class="fe nk nl nm nn b">DateTime</code>默认记录主机服务器时区中列出的时间。</p><p id="7856" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果使用本地时区之外的网络，这可能会导致问题。每次调用日期时，计算机都需要转换为UTC，然后转换为目标时区，从而降低了处理速度。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="ff2e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">包扎</h1><p id="e388" class="pw-post-body-paragraph kv kw iq kx b ky nf jr la lb ng ju ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">干得好，解决了这个高级YAML语法。虽然YAML可能看起来像是一个利基技能，但它是市场上许多工作的先决条件。然而，大多数编码面试不会包括YAML。</p><p id="74d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">展示你的YAML知识的最好方式是在一个组合项目中使用它，或者能够展示过去使用该技术的经验。</p><p id="3988" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快乐学习！</p></div></div>    
</body>
</html>