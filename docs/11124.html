<html>
<head>
<title>Hiding Secrets From Git in SwiftPM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftPM中对Git隐藏秘密</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hiding-secrets-from-git-in-swiftpm-1463c023c67?source=collection_archive---------4-----------------------#2022-02-20">https://betterprogramming.pub/hiding-secrets-from-git-in-swiftpm-1463c023c67?source=collection_archive---------4-----------------------#2022-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6d5e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模块化您的应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1bc1d39422c0194ac5c84da96089306d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzDFYkL_ZYB6GoXkV9GGMA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@flyd2069" rel="noopener ugc nofollow" target="_blank">飞:D </a>上<a class="ae ky" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank">的Unsplash </a></p></figure><p id="f5ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能知道一些隐藏秘密的传统方法，比如你的应用程序需要的API密钥或第三方服务令牌。但是现在使用SwiftPM模块化应用程序的方法变得越来越流行。</p><p id="e9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，Point-Free有一个关于这个主题的很棒的<a class="ae ky" href="https://www.pointfree.co/episodes/ep171-modularization-part-1" rel="noopener ugc nofollow" target="_blank">免费剧集</a>，Majid Jabrayilov最近写了一个关于“微应用架构”的4集系列(第<a class="ae ky" href="https://swiftwithmajid.com/2022/01/12/microapps-architecture-in-swift-spm-basics/" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae ky" href="https://swiftwithmajid.com/2022/01/19/microapps-architecture-in-swift-feature-modules/" rel="noopener ugc nofollow" target="_blank"> 2 </a>、<a class="ae ky" href="https://swiftwithmajid.com/2022/01/26/microapps-architecture-in-swift-resources-and-localization/" rel="noopener ugc nofollow" target="_blank"> 3 </a>、<a class="ae ky" href="https://swiftwithmajid.com/2022/02/02/microapps-architecture-in-swift-dependency-injection/" rel="noopener ugc nofollow" target="_blank"> 4 </a>)，我都可以推荐开始。</p><p id="a987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您甚至可能希望在公共开源库中隐藏秘密，例如，在一些第三方服务集成的单元测试中，库的用户将提供他们自己的令牌，但是您希望<a class="ae ky" href="https://github.com/Flinesoft/BartyCrouch/blob/baece7f4786bc805358f35ba5fd60d6259d5c8b9/Tests/BartyCrouchTranslatorTests/MicrosoftTranslatorApiTests.swift#L8" rel="noopener ugc nofollow" target="_blank">您的测试与您自己的</a>一起运行。</p><p id="d7b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些情况的共同点是它们基于自定义维护的<code class="fe lv lw lx ly b">Package.swift</code>文件——而不是Xcode为您维护的文件(如果您只是将依赖项添加到应用程序项目)。app或者项目被拆分成很多小模块，没有对应的<code class="fe lv lw lx ly b">.xcodeproj</code>文件，Xcode只是直接打开<code class="fe lv lw lx ly b">Package.swift</code>文件，不需要项目。</p><p id="b01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也意味着，对于单独的模块，没有办法在Xcode中指定任何构建设置或构建脚本，所有这些都需要在<code class="fe lv lw lx ly b">Package.swift</code>清单文件中完成。</p><p id="714b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在未来的版本中，越来越多的此类功能被添加到SwiftPM中(如<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/main/proposals/0303-swiftpm-extensible-build-tools.md" rel="noopener ugc nofollow" target="_blank"> SE-303 </a>、<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/main/proposals/0325-swiftpm-additional-plugin-apis.md" rel="noopener ugc nofollow" target="_blank"> SE-325 </a>、<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md" rel="noopener ugc nofollow" target="_blank"> SE-332 </a>)，但没有迹象表明它们将支持任何Xcode特有的功能，如<code class="fe lv lw lx ly b">.xcconfig</code>文件。</p><p id="135e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何隐藏提交给Git的秘密，以确保不会泄露给我们的Git提供商或任何能够访问我们的回购<em class="lz">的人？</em></p><h1 id="e859" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">SwiftPM资源和JSONDecoder助您一臂之力</h1><p id="ac9b" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我确信这个问题没有唯一的“最佳”答案，其他人可能有比我更聪明的想法。但是我喜欢<a class="ae ky" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">保持事情简单</a>并且我也喜欢使用基本功能，因为我很了解它们&amp;如果需要的话，我希望其他开发人员能很快理解它们。另外，我可以肯定它们是经得起未来考验的。</p><p id="fc79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想使用的方法是web开发中常见的经典的文件方法。但是我不想要一个定制格式的<code class="fe lv lw lx ly b">.env</code>文件，我只想有一个<code class="fe lv lw lx ly b">.json</code>文件，里面有我的秘密，因为JSON文件是许多iOS开发者所熟悉的，并且由于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/jsondecoder" rel="noopener ugc nofollow" target="_blank">JSONDecoder</a></code>，我们已经内置了对Swift解析它们的支持。从Swift 5.3开始，SwiftPM也支持加载文件或更一般的“资源”(<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/main/proposals/0271-package-manager-resources.md" rel="noopener ugc nofollow" target="_blank"> SE-271 </a>)。</p><p id="911e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我想如何对Git隐藏秘密的基本想法:</p><ol class=""><li id="f183" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">将一个<code class="fe lv lw lx ly b">secrets.json.sample</code>文件签入到Git中，带有键，但是没有值</li><li id="b266" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">让开发人员复制它，删除<code class="fe lv lw lx ly b">.sample</code>扩展&amp;添加值</li><li id="f37e" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">通过<code class="fe lv lw lx ly b">.gitignore</code>忽略<code class="fe lv lw lx ly b">secrets.json</code>文件，这样它就永远不会被检入</li><li id="1de0" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">提供一个简单的符合<code class="fe lv lw lx ly b">Decodable</code>的<code class="fe lv lw lx ly b">struct</code>来读取秘密</li></ol><p id="6faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的其余部分是如何应用这种方法的分步指南。作为一个例子，我将使用我的开源翻译工具<a class="ae ky" href="https://github.com/Flinesoft/BartyCrouch" rel="noopener ugc nofollow" target="_blank"> BartyCrouch </a>的单元测试，它集成了两个第三方翻译服务。</p><blockquote class="nl nm nn"><p id="cfcb" class="kz la lz lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">⚠️请注意，如果你计划将这种方法应用于你将交付给用户的<strong class="lb iu">应用目标</strong>，你可能会遇到与这篇NSHipster文章中的<code class="fe lv lw lx ly b">.xcconfig</code>方法所描述的相同的问题。我的方法只是帮助隐藏Git的秘密，如果你打算发布给用户，你将需要额外的混淆。</p></blockquote><h1 id="e6ed" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">添加<code class="fe lv lw lx ly b">secrets.json</code>资源文件</h1><p id="7bf2" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">首先，让我们将<code class="fe lv lw lx ly b">secrets.json</code>文件添加到我们的项目中。由于将有一个相应的<code class="fe lv lw lx ly b">secrets.json.sample</code>和一个<code class="fe lv lw lx ly b">Secrets.swift</code>文件，我选择先创建一个文件夹<code class="fe lv lw lx ly b">Secrets</code>，然后创建一个空文件，命名为<code class="fe lv lw lx ly b">secrets.json</code>，并添加一个简单的JSON字典结构，包含两个键:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/a8e7374f66b037493cdad6fb29c335fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0dsG3EdsmFDJHTBlrXq_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加到项目中的带有两个实际秘密的“secrets.json”文件。</p></figure><p id="4f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，让我们通过将<code class="fe lv lw lx ly b">secrets.json</code>附加到我们的<code class="fe lv lw lx ly b">.gitignore</code>文件来确保我们不会意外提交该文件。如果您的项目中还没有一个<code class="fe lv lw lx ly b">.gitignore</code>文件，只需在您的库的根目录下创建一个，例如通过运行<code class="fe lv lw lx ly b">touch .gitignore</code>。如果您在Finder中看不到该文件，只需通过<code class="fe lv lw lx ly b">Cmd+Shift+.</code>打开显示隐藏文件。结果应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/323fa8dfcdb43cefda5366cf1c1d91da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HagK14ptcuEtX6ImbIWkLw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“. gitignore”文件中的“secrets.json”条目结束。文件在<a class="ae ky" href="https://atom.io" rel="noopener ugc nofollow" target="_blank"> Atom </a>文本编辑器中打开。</p></figure><blockquote class="nl nm nn"><p id="56d4" class="kz la lz lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">顺便说一下:<code class="fe lv lw lx ly b">.gitignore</code>文件中上面的其他条目都是从<a class="ae ky" href="https://github.com/github/gitignore" rel="noopener ugc nofollow" target="_blank">这个</a> GitHub社区项目，特别是从<a class="ae ky" href="https://github.com/github/gitignore/blob/main/Global/macOS.gitignore" rel="noopener ugc nofollow" target="_blank"> macOS </a>和<a class="ae ky" href="https://github.com/github/gitignore/blob/main/Swift.gitignore" rel="noopener ugc nofollow" target="_blank"> Swift </a>文件中复制过来的。</p></blockquote><p id="01e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三，让我们在Finder中复制我们的<code class="fe lv lw lx ly b">secrets.json</code>文件(Xcode不支持复制文件AFAIK)并命名为<code class="fe lv lw lx ly b">secrets.json.sample</code>。这个文件将被签入Git，因此签出项目的其他人可以轻松地复制它并删除<code class="fe lv lw lx ly b">.sample</code>扩展，而不必查找实际需要哪些键。当然，我们必须删除文件中的秘密，我将用一些有用的提示来代替它，比如<code class="fe lv lw lx ly b">&lt;add secret here after duplicating this file &amp; removing .sample ext&gt;</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/f76a7bd12233cf9cd620030867cfd279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0MpcTtc_div59UAwx5sTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加到项目中的不带任何秘密值的“secrets.json.sample”文件。</p></figure><p id="4e1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四，我们需要告诉SwiftPM在哪里可以找到我们的新JSON文件，这样我们以后就可以在代码中访问它。为此，我们只需在清单文件中向目标的<code class="fe lv lw lx ly b">resources</code>参数添加一个<code class="fe lv lw lx ly b">.copy</code>条目。提供目标文件夹的相对路径就足够了，在我的例子中是<code class="fe lv lw lx ly b">BartyCrouchTranslatorTests</code>。结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/bda12fb3f2a4a6c90a2ee7b7e9ed2620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NztTgVwnNT2eLzbNihKiuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">` secrets.json '文件作为资源添加到` Package.swift `清单文件中。</p></figure><p id="d62d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于这个单独的<code class="fe lv lw lx ly b">resources</code>条目，我们从Xcode得到一个警告，因为它在包文件夹中找到了我们的<code class="fe lv lw lx ly b">secrets.json.sample</code>文件，却不知道如何处理它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/72444f76bbfd395e0e031a44ff111327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjFKYVk_EgJvaH7jrGiXMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当Xcode发现软件包清单中没有声明的资源文件时，它会发出警告。</p></figure><p id="5d81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过将上面的条目从<code class="fe lv lw lx ly b">.copy("Secrets/secrets.json")</code>改为<code class="fe lv lw lx ly b">.copy("Secrets")</code>来接受<code class="fe lv lw lx ly b">Secrets</code>文件夹中的所有文件来解决。或者，我认为更正确的是，我们可以通过将文件<code class="fe lv lw lx ly b">.sample</code>添加到<code class="fe lv lw lx ly b">exclude</code>参数中来告诉SwiftPM显式忽略该文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/a705d5ece63c3e4aabd1392e7e177e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBdhI3p_Tsm30ylU6BDJ_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">程序包清单文件中的“exclude”条目，用于消除警告。</p></figure><h1 id="9208" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">使用<code class="fe lv lw lx ly b">JSONDecoder</code>加载代码中的秘密</h1><p id="544c" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在我们有了<code class="fe lv lw lx ly b">secrets.json</code>资源文件，让我们在Swift中访问它。</p><p id="58f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个名为<code class="fe lv lw lx ly b">Secrets.swift</code>的新Swift文件，在一个简单的<code class="fe lv lw lx ly b">struct</code>中使用我们的两个密钥作为属性，它符合<code class="fe lv lw lx ly b">Decodable</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="75a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，让我们实现一些解析我们的<code class="fe lv lw lx ly b">secrets.json</code>文件的代码。我更喜欢将功能作为<code class="fe lv lw lx ly b">static</code> func直接添加到我们的新<code class="fe lv lw lx ly b">Secrets</code>结构中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lv lw lx ly b">Bundle.module</code>只有在您实际上至少有一个资源添加到您的目标中时才会由编译器生成。所以如果你得到一个编译器错误，检查你是否已经添加了<code class="fe lv lw lx ly b">resources</code>并且你的目标中确实有至少一个资源文件，就像我们上面做的那样。</p><p id="d651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三也是最后一点，是时候在我们需要的地方访问我们的秘密了，在我的例子中是在单元测试中。之前我有一行这样的代码，因为我不想在公共存储库中提交我自己的密钥:</p><pre class="kj kk kl km gt nz ly oa ob aw oc bi"><span id="1389" class="od mb it ly b gy oe of l og oh">let subscriptionKey = ""</span></pre><p id="5cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在可以从<code class="fe lv lw lx ly b">secrets.json</code>文件中加载我的密钥，并像这样访问它:</p><pre class="kj kk kl km gt nz ly oa ob aw oc bi"><span id="a233" class="od mb it ly b gy oe of l og oh"><strong class="ly iu">let</strong> subscriptionKey = <strong class="ly iu">try</strong>! Secrets.load().microsoftSubscriptionKey</span></pre><p id="26dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我成功地在我的机器上访问了我的秘密，而没有将它们签入Git！你可以在GitHub的<a class="ae ky" href="https://github.com/Flinesoft/BartyCrouch/commit/b1a98e8d8a83ed725ee29999daa714373eba49dc" rel="noopener ugc nofollow" target="_blank">单次提交</a>中找到我在示例项目中所做的所有更改。</p><p id="92f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，从现在开始，每个想用正确的密钥运行我的测试的人都需要复制<code class="fe lv lw lx ly b">.sample</code>文件并添加正确的秘密。我的下一步可能是在我的<code class="fe lv lw lx ly b">README.md</code>或<code class="fe lv lw lx ly b">CONTRIBUTING.md</code>中记录这一点。同样，您可能想告诉您的团队，甚至在一个安全的地方共享项目的适当的<code class="fe lv lw lx ly b">secrets.json</code>文件，比如密码管理器。</p><h1 id="be95" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">Extra:在GitHub CI上设置secrets.json</h1><p id="b865" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">既然我正在从JSON文件加载秘密，我还想配置我的GitHub CI管道，以便在CI上运行测试时使用我的秘密密钥。</p><p id="efa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，让我们使用秘密特性将秘密添加到GitHub操作中(参见此处的<a class="ae ky" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets" rel="noopener ugc nofollow" target="_blank">文档</a>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b5336a515409ef7735dd67f3a1b7d2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_7LsgLvwwCM9kqy2DpdEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将秘密添加到我的GitHub存储库中。</p></figure><p id="c603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，在GitHub Actions工作流中，我只使用了<code class="fe lv lw lx ly b">echo</code>命令，并通过<code class="fe lv lw lx ly b">&gt;&gt; path/to/secrets.json</code>参数在我期望的路径下创建一个包含全部<code class="fe lv lw lx ly b">secrets.json</code>文件内容的文件。通过<code class="fe lv lw lx ly b">${{ secrets.MICROSOFT_SUBSCRIPTION_KEY }}</code>安全访问秘密:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/3f7a91716122e9fae33d1bca4ab3f1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mocdm7tGGNYcktDu0aMjUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全面测试GitHub Action CI作业。</p></figure><p id="4fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在每次CI运行时，在运行测试之前配置了<code class="fe lv lw lx ly b">secrets.json</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/1c8552556223b1fff21555935c493954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6U2nRj3lMPxoCnGVA6WYsg.png"/></div></div></figure><p id="7f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我的CI也可以安全地访问我的秘密，而不会泄露出去。</p><pre class="kj kk kl km gt nz ly oa ob aw oc bi"><span id="4d46" class="od mb it ly b gy oe of l og oh"><strong class="ly iu">Want to Connect?</strong></span><span id="1fe3" class="od mb it ly b gy ol of l og oh">Follow me also on 👾 <a class="ae ky" href="https://www.twitch.tv/Jeehut" rel="noopener ugc nofollow" target="_blank">Twitch</a>, on 🎬 <a class="ae ky" href="https://www.youtube.com/channel/UCtg6Ck7oYa_9k1oSTmFGNRw" rel="noopener ugc nofollow" target="_blank">YouTube</a> and on 🐦 <a class="ae ky" href="https://twitter.com/Jeehut" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>