<html>
<head>
<title>The Circuit Breaker Pattern in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《长生不老药》中的断路器模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/circuit-breaker-pattern-in-elixir-fff06199083c?source=collection_archive---------12-----------------------#2020-11-05">https://betterprogramming.pub/circuit-breaker-pattern-in-elixir-fff06199083c?source=collection_archive---------12-----------------------#2020-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="661b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Elixir中有趣的架构模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d79bc1dd5e7742e07e252c6abc9bbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6Pj7AkKo-AToQ6kB0ATGw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Adrien Olichon 在<a class="ae ky" href="https://unsplash.com/s/photos/domino-effect?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="45c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">断路器用于检测故障，并封装逻辑以防止故障在维护、临时外部系统故障或意外系统故障期间不断重复出现。</p><p id="b086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在微服务时代，我们更有可能拥有正在调用并依赖于不受控制的外部服务的服务。</p><p id="f909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">远程服务可能会挂起、失败或无响应。我们如何防止这些故障在系统中蔓延？获取关键资源？</p><p id="1649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入<strong class="lb iu"> </strong>断路器模式。该模式在书<a class="ae ky" href="https://www.oreilly.com/library/view/release-it/9781680500264/" rel="noopener ugc nofollow" target="_blank">中得到推广，发布吧！迈克尔·尼加德和像马丁·福勒这样的思想领袖。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/b0eee1bbca6ce1dc99e06e7df4f1e308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_td77EGKs22aDeTpfkbUQ.png"/></div></div></figure><p id="b391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式背后的想法非常简单:失败是不可避免的，试图完全防止失败是不现实的。</p><p id="30b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理这些失败的一种方法是将这些操作封装到某种代理中。该代理负责监控最近的故障，并使用该信息来决定是允许操作继续进行还是返回早期故障。</p><p id="2d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代理通常被实现为模拟物理断路器的功能的状态机，该物理断路器可以具有三种状态:</p><ul class=""><li id="ced5" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">闭合:</strong>在此状态下，断路器让所有请求通过，同时记录最近的故障次数，如果故障次数在特定时间范围内超过特定阈值，它将切换到断开状态。</li><li id="f854" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">打开:</strong>在此状态下，任何请求都不会发送到外部服务。相反，我们要么立即失败，返回一个扩展，要么回退到一个二级系统，如缓存。</li><li id="5c0c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">半开:</strong>在这种状态下，来自应用程序的有限数量的请求被允许通过并调用我们的外部服务。根据这些请求的结果，断路器将翻转到闭合状态或回到断开状态，在试图再次断开之前重置计数器。</li></ul><p id="e3a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">断路器模式提供了一些值得注意的关键优势:</p><ul class=""><li id="6d87" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu">半开</strong>状态使外部系统恢复而不会被淹没。</li><li id="b186" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu">Open</strong>-状态实现给出了我们希望如何处理故障的选项，无论是立即故障还是退回到缓存层或辅助系统。</li><li id="fe6f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">这种模式还可以通过快速拒绝可能失败或超时的呼叫来帮助保持响应时间。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="e819" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">例子</h1><p id="6365" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">对于我们的示例，假设我们有以下场景:</p><p id="9e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在运行一个工作板聚合器，它将消耗来自GitHub和其他来源的职位发布。然而，由于我们正在使用一些API，我们面临着API达到极限或停机的风险。</p><p id="7603" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建一个Github作业的示例API连接器开始，该连接器检索最近发布的50个作业:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="88e2" class="nt ms it np b gy nu nv l nw nx">defmodule CircuitBreaker.Api.GithubJobs do <br/>    ...<br/>    @spec get_positions :: none<br/>    def get_positions do<br/>        case HTTPoison.get(url()) do<br/>        {:ok, response} -&gt; {:ok, parse_fields(response.body)}<br/>        {:error, %HTTPoison.Error{id: _, reason: reason}} -&gt; {:error, reason}<br/>        end<br/>    end<br/>    ...<br/>end</span></pre><p id="be41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">文件</strong>:<a class="ae ky" href="https://github.com/amacgregor/circuit_breaker_example/blob/main/lib/circuit_breaker/api/github_jobs.ex" rel="noopener ugc nofollow" target="_blank">lib/circuit _ breaker/API/github _ jobs . ex</a></p><p id="11db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个连接器所做的就是请求<code class="fe ny nz oa np b">jobs.github.com</code>检索JSON，解析并返回作业列表。如果我们想测试这个，我们可以在控制台上手动调用<code class="fe ny nz oa np b">get_positions</code>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fc8c" class="nt ms it np b gy nu nv l nw nx">iex(1)&gt; CircuitBreaker.Api.GithubJobs.get_positions<br/>{:ok,<br/> ["Software Engineer", "Backend Engineer (w/m/d)",<br/>  "Senior Frontend Engineer (f/m/d)", ...]}</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6952" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">断路器开关</h1><p id="587e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在，我们已经能够通过调用来获取招聘信息，我们需要构建断路器来包装API适配器。让我们来看看我们的交换机的框架。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fa20" class="nt ms it np b gy nu nv l nw nx">defmodule CircuitBreaker.Api.Switch do<br/>  use GenStateMachine, callback_mode: :state_functions<br/><br/>  @name :circuit_breaker_switch<br/>  @error_count_limit 8<br/>  @time_to_half_open_delay 8000<br/><br/>  def start_link do<br/>    GenStateMachine.start_link(__MODULE__, {:closed, %{error_count: 0}}, name: @name)<br/>  end<br/><br/>  def get_positions do<br/>    GenStateMachine.call(@name, :get_positions)<br/>  end<br/>  ...<br/>end</span></pre><p id="ef69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">文件</strong>:<a class="ae ky" href="https://github.com/amacgregor/circuit_breaker_example/blob/main/lib/circuit_breaker/api/switch.ex" rel="noopener ugc nofollow" target="_blank">lib/circuit _ breaker/API/switch . ex</a></p><p id="31d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现我们的断路器，我们可以直接使用<code class="fe ny nz oa np b">gen_statem</code>行为。或者在这种情况下，我们可以利用GenStateMachine包，它为我们提供跟踪和错误报告，并将与监督树一起工作。</p><p id="1de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们添加的前两个函数是:</p><ul class=""><li id="69e6" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ny nz oa np b">start_link</code>:这将启动具有初始状态和特定名称的断路器。</li><li id="6b44" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">get_positions</code>:这是我们的公共客户端API，包装了我们刚刚构建的GitHub作业适配器。</li></ul><p id="7a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的一点是第一行:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="575a" class="nt ms it np b gy nu nv l nw nx">use GenStateMachine, callback_mode: :state_functions</span></pre><p id="0a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种回调模式下，每次你执行<code class="fe ny nz oa np b">call/3</code>或<code class="fe ny nz oa np b">cast/2</code>时，消息将由与当前状态同名的<code class="fe ny nz oa np b">state_name/3</code>函数处理。在这种情况下，我们的<code class="fe ny nz oa np b">state_name</code>函数将是<code class="fe ny nz oa np b">open</code>、<code class="fe ny nz oa np b">closed</code>和<code class="fe ny nz oa np b">half_open</code>。</p><p id="3c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续，从添加我们的关闭状态代码开始:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b8d0" class="nt ms it np b gy nu nv l nw nx">def closed({:call, from}, :get_positions, data) do<br/>    case CircuitBreaker.Api.GithubJobs.get_positions() do<br/>      {:ok, positions} -&gt;<br/>        {:keep_state, %{error_count: 0}, {:reply, from, {:ok, positions}}}<br/>      {:error, reason} -&gt;<br/>        handle_error(reason, from, %{ data | error_count: data.error_count + 1 })<br/>    end<br/>  end</span></pre><p id="8872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">文件</strong>:<a class="ae ky" href="https://github.com/amacgregor/circuit_breaker_example/blob/main/lib/circuit_breaker/api/switch.ex" rel="noopener ugc nofollow" target="_blank">lib/circuit _ breaker/API/switch . ex</a></p><p id="c943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们所做的就是调用API适配器<code class="fe ny nz oa np b">get_positions</code>，根据结果，我们要么返回位置列表，要么处理错误。</p><p id="111e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们直接进入终端，尝试通过断路器获取位置列表:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4863" class="nt ms it np b gy nu nv l nw nx">iex(1)&gt; CircuitBreaker.Api.Switch.start_link<br/>{:ok, #PID&lt;0.231.0&gt;}<br/>iex(2)&gt; CircuitBreaker.Api.Switch.get_positions<br/>{:ok,<br/> ["Software Engineer", "Backend Engineer (w/m/d)",<br/>  "Senior Frontend Engineer (f/m/d)", ...]}</span></pre><p id="a7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加另外两种状态的函数，并回顾电路状态变化的工作原理:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="bbe7" class="nt ms it np b gy nu nv l nw nx">def half_open({:call, from}, :get_positions, data) do<br/>    case CircuitBreaker.Api.GithubJobs.get_positions() do<br/>      {:ok, positions} -&gt;<br/>        {:next_state, :closed, %{count_error: 0}, {:reply, from, {:ok, positions}}}<br/>      {:error, reason} -&gt;<br/>        open_circuit(from, data, reason, @time_to_half_open_delay)<br/>    end<br/>  end<br/><br/>  def open({:call, from}, :get_positions, data) do<br/>    {:keep_state, data, {:reply, from, {:error, :circuit_open}}}<br/>  end<br/><br/>  def open(:info, :to_half_open, data) do<br/>    {:next_state, :half_open, data}<br/>  end</span></pre><p id="421b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加几个私有的实用函数:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="669e" class="nt ms it np b gy nu nv l nw nx">defp handle_error(reason, from, data = %{error_count: error_count}) when error_count &gt; @error_count_limit do<br/>      open_circuit(from, data, reason, @time_to_half_open_delay)<br/>  end<br/><br/>  defp handle_error(reason, from, data) do<br/>    {:keep_state, data, {:reply, from, {:error, reason}}}<br/>  end<br/><br/>  defp open_circuit(from, data, reason, delay) do<br/>    Process.send_after(@name, :to_half_open, delay)<br/>    {:next_state, :open, data, {:reply, from, {:error, reason}}}<br/>  end</span></pre><p id="2d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数神奇的事情都发生在<code class="fe ny nz oa np b">open_circuit</code>函数上，它做了两件事:</p><ul class=""><li id="bfa9" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">首先，我们安排一条消息，在指定的延迟后将断路器状态设置为<code class="fe ny nz oa np b">half_open</code>。</li><li id="3e88" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第二，我们返回一个新状态，将断路器完全设置<code class="fe ny nz oa np b">open</code>。</li></ul><p id="3447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">8000毫秒后，现在处于<code class="fe ny nz oa np b">open</code>状态的断路器将收到我们预定的消息，并将状态改为<code class="fe ny nz oa np b">half_open</code>。</p><p id="a650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在<code class="fe ny nz oa np b">half_open</code>状态期间，我们将尝试调用API端点。如果失败，我们将自动切换回完全<code class="fe ny nz oa np b">open</code>并重试。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7e98" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="ccbc" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">断路器是我们的武器库中的一个有价值的模式，因为它们可以帮助增加系统的稳定性，并给我们一个更可靠的方法来处理远程服务的错误。</p><p id="6971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子只是触及了断路器的表面。有很多机会可以进一步扩展这种模式，例如，</p><ul class=""><li id="e04a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">通过查看错误类型和频率，改进断路器跳闸的逻辑</li><li id="2cbd" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一旦断路器改变状态，增加监控和记录</li><li id="042f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在返回故障之前，退回到辅助服务或缓存层</li></ul><p id="54f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，与任何模式一样，记住用例并决定这种行为是否是所期望的是很重要的。</p><p id="1172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例的完整代码可在<a class="ae ky" href="https://github.com/amacgregor/circuit_breaker_example" rel="noopener ugc nofollow" target="_blank">电路断路器示例</a>中找到</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8af6" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">进一步阅读</h1><ul class=""><li id="83fa" class="lw lx it lb b lc nj lf nk li ob lm oc lq od lu mb mc md me bi translated"><a class="ae ky" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker" rel="noopener ugc nofollow" target="_blank">微软—断路器模式</a></li><li id="4fe3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://netflixtechblog.com/fault-tolerance-in-a-high-volume-distributed-system-91ab4faae74a" rel="noopener ugc nofollow" target="_blank">大容量分布式系统中的容错</a>作者:Ben Christensen</li><li id="a666" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://microservices.io/patterns/reliability/circuit-breaker.html" rel="noopener ugc nofollow" target="_blank">微服务架构—断路器模式</a></li></ul></div></div>    
</body>
</html>