# 让我们在 Python 中同步线程

> 原文：<https://betterprogramming.pub/synchronization-primitives-in-python-564f89fee732>

## *因为同步就是和谐*

![](img/898eca9f057998ebadaadd4660c8c8c0.png)

在 Python 的众多特性中，这种语言支持多种同步原语。图片来源:Heroku 的 Python 俳句艺术

那是一声神奇的“啊哈！”我第一次了解多线程的时刻。事实上，我可以让我的计算机以并行方式执行操作，这让我很高兴(尽管这里应该注意的是，在单核计算机上，事情不会以并行方式精确地发生。更重要的是，在 Python 中，由于语言的全局解释器锁，它们不能精确地并行执行。多线程为计算开辟了新的空间。但是权力带来了责任。

人们可以想象多线程有明显的麻烦——许多试图访问同一数据的线程会导致问题——比如使数据不一致或得到混乱的输出(比如在控制台上用`HWeolrldo`代替`Hello World`)。当我们不告诉计算机如何以有组织的方式管理线程时，就会出现这样的问题。

但是我们如何“告诉”计算机保持我们程序的线程同步呢？我们通过使用*同步原语来做到这一点。*这些是简单的软件机制，确保您的线程以和谐的方式运行。

这篇文章展示了 Python 中一些最流行的同步原语，这些原语是在其标准的`threading.py`模块中定义的。这些原语的大多数阻塞方法(即在满足某些条件之前阻塞特定线程执行的方法)都提供了可选的超时功能，但为了简单起见，我没有在这里包括它。同样，为了简单起见，我只包括了这些对象的主要功能。这篇文章假设你有使用 Python 实现多线程的基本知识。

我们将学习`Locks`、`RLocks`、`Semaphores`、`Events`、`Conditions`和`Barriers`。当然，您可以通过对这些类进行子类化来构建您自己的定制同步原语。我们将从`Locks`开始，因为它们是最简单的原语，然后我们将逐渐转向越来越复杂的原语。

# 锁

可能是 Python 中最简单的同步原语。一个`Lock`只有两种状态——锁定和(意外)解锁。它是在解锁状态下创建的，有两个主要方法— `acquire()`和`release()`。`acquire()`方法锁定`Lock`并阻止执行，直到其他协程中的`release()`方法将其设置为解锁。然后它再次锁定`Lock`并返回`True`。`release()`方法只能在锁定状态下调用，它将状态设置为解锁并立即返回。如果`release()`在解锁状态下被调用，则`RunTimeError`被引发。

下面是使用`Lock`原语安全访问共享变量的代码:

这仅仅给出了 3 的输出，但是现在我们确信这两个函数没有同时改变全局变量`g`的值，尽管它们运行在两个不同的线程上。因此，`Lock` s 可用于通过一次只允许一个线程修改数据来避免不一致的输出。

# RLocks

标准`Lock`不知道哪个线程当前持有
锁。如果锁被持有，任何试图获取它的线程都会
阻塞，即使同一个线程本身已经持有锁。
在这种情况下，使用`RLock`(重入锁)。您可以通过添加输出语句来扩展下面代码片段中的代码，以演示`RLock`如何防止不必要的阻塞。

一个很好的用例是递归，当一个函数的父调用阻塞了它的嵌套调用时。因此，`RLock` s 的主要用途是嵌套访问共享资源。

# 信号灯

信号量只是高级计数器。对信号量的`acquire()`调用只有在大量线程`acquire()`调用后才会被阻塞。相关的计数器在每次`acquire()`呼叫时减少，在每次`release()`呼叫时增加。如果`release()`调用试图将计数器增加到超过其分配的最大值(这是在阻塞发生之前能够`acquire()`信号量的线程数量)，就会发生`ValueError`。下面的代码演示了在一个简单的生产者-消费者问题中信号量的使用:

![](img/a371bd9e8ef2509c564753672ef6df38.png)

semaphore_tut.py 在运行

`threading`模块也提供了简单的`Semaphore`类。一个`Semaphore`提供了一个非有界的计数器，它允许你调用`release()`任意次来递增。然而，为了避免编程错误，使用`BoundedSemaphore`通常是一个正确的选择，如果`release()`调用试图将计数器增加到超过其最大值，就会引发错误。

信号量通常用于限制资源，例如限制服务器一次只能处理 10 个客户端。在这种情况下，多个线程连接竞争一个有限的资源(在我们的例子中，是服务器)。

# 事件

`Event`同步原语充当线程间的简单通信器。它们基于内部标志，线程可以`set()`或`clear()`。其他线程可以`wait()`将内部标志设为`set()`。`wait()`方法阻塞，直到标志变为真。下面的代码片段演示了如何使用`Event`来触发动作。

![](img/7bda867507a96fea0b1579d7705254e8.png)

event_tut.py 的执行

# 情况

一个`Condition`对象只是一个更高级版本的`Event`对象。它也充当线程间的通信器，可以用来`notify()`其他线程关于程序状态的变化。例如，它可以用来表示可供消费的资源的可用性。在满足条件之前，其他线程也必须`acquire()`该条件(及其相关的锁)`wait()`。此外，一旦线程完成了相关的动作，它就应该`release()` a `Condition`，这样其他线程就可以为它们的目的获取条件。下面的代码借助于`Condition`对象演示了另一个简单的生产者-消费者问题的实现:

![](img/97c4a97c3e56843898c2395c713c8cdd.png)

condition_tut.py 的输出

还有其他使用`Condition`的方法。我认为当你需要开发一个流 API 来通知一个等待中的客户端有数据可用时，它们会很有用。

# 障碍

屏障是一个简单的同步原语，不同的线程可以使用它来相互等待。每个线程都试图通过调用`wait()`方法来通过一个障碍，这个方法会一直阻塞，直到所有的线程都进行了那个调用。一旦发生这种情况，线程就会被同时释放。下面的代码片段演示了`Barrier`的用法。

![](img/92045c35b5a4654fb3f3b888f715d799.png)

下面是 barrier_tut.py 的输出

屏障可以有许多用途；其中之一是同步一个服务器和一个
客户端——因为服务器在初始化自己之后必须等待客户端。

至此，我们已经结束了对 Python 中同步原语的讨论。我写这篇文章是作为 Wesley Chun 所著的《核心 Python 应用程序编程》一书中一个练习的[解决方案。](https://github.com/schedutron/CPAP/blob/master/Chap4/sync_prim.md)

来源:[effbot.org](http://effbot.org/zone/thread-synchronization.htm)、[bogotobogo.com](http://www.bogotobogo.com/python/Multithread/)、 [Python 文档](https://docs.python.org/3/library/threading.html)

我是博客新手，所以建设性的批评不仅受欢迎，而且非常受欢迎！