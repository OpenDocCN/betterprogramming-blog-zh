<html>
<head>
<title>Algorithms and Their Impact on Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法及其对性能的影响</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-and-their-impact-on-performance-ed7b6d6156de?source=collection_archive---------8-----------------------#2022-07-12">https://betterprogramming.pub/algorithms-and-their-impact-on-performance-ed7b6d6156de?source=collection_archive---------8-----------------------#2022-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b010" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何选择合适的算法？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8a8913942e343f3877fa7a62361a4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQEqKDUPkBt2OWWwJs7V5A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">网站加载优化(授权给作者的图片)</p></figure><h1 id="3d9d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="ea19" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">“你好，海拉！你能帮我检查一下为什么我的代码用了这么长时间吗？”，“嗨赫拉！您能帮我检查一下为什么我的代码会消耗大量内存吗？”，“当我在本地测试我的代码时，一切都很好，但是在生产中，我的代码挂起了！”</p><p id="a701" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这些都是我的日常问题，我爱他们！为什么？因为这给了我接近机器(电脑)和底层执行的机会。要了解一台机器，就要像机械师或医生一样，了解它的内部工作原理！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/bf9d5aa2af2fdfd4512fb0722da4d701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDbIT5xyPVSLwr4NcttK1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主板城市(图片授权给作者)</p></figure><p id="9861" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我确信，如果我想写一个性能代码，我必须从底层开始:</p><ul class=""><li id="7d9e" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">运行算法所需的步骤(指令)</li><li id="a3a5" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">保存算法代码所需的内存量</li><li id="cbc5" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">输入数据所需的内存量</li><li id="389b" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">所有输出数据所需的内存量</li></ul><p id="2441" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">用计算机术语来说，所需的步骤反映了时间复杂度，所需的内存量反映了空间复杂度。</p><p id="bd1e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">通过减少时间和空间的复杂性，我们获得了资源和金钱。我们不能每次都通过增加和修改硬件来应对性能和资源的缺乏。</p><p id="b2a5" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我们写的软件应该是有效和高效的！</p><p id="d70a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">太棒了。但是，让我们停下来简化一下我的意思！</p><p id="c049" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">假设你是一名飞行员，你需要从法国飞到伊斯坦布尔。你的煤油数量有限，因为飞机的油箱是有限的。你要怎么办？是啊，很好！你会选择短轨迹！这样一来，你将节省时间和消耗！</p><p id="f351" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">代码也是如此:为了让它消耗更少的资源(CPU、内存、GPU)，我们应该总是选择最优路径。</p><p id="1701" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果软件是一辆汽车，那么我们可以说设计和架构使得拥有一个好的和漂亮的框架成为可能:有弹性的，可伸缩的，可扩展的，可维护的，等等。另一方面，低水平使得拥有高效的高性能汽车成为可能。啊哈，外在美是不够的。代码也必须从内部美观！</p><p id="12f8" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">请注意，在本文中，当我谈到性能时，我指的是执行速度，当我谈到消耗时，我指的是分配的内存。</p><p id="640a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">那么，代码指令是如何在内部执行的呢？让我们来看看这幅插图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/67ccde02b5d18aeb76e1dc626dd03a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8O8rXh8rZE3fjElVpwbRMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指令的生命(作者图片)</p></figure><ul class=""><li id="9854" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">CPU执行作为机器语言指令序列存储在主存储器中的程序。</li><li id="a688" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">它通过从内存中反复读取或检索指令，然后执行该指令来实现这一点。</li><li id="66f0" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">完成后，结果将被保存回内存。</li></ul><p id="df1c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">就这些了，伙计们！</p><p id="4686" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">你可以看到我们需要内存来存储程序以及最终和中间的结果。</p><p id="6f26" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">现在是时候给你我解决算法相关的性能和内存问题的神奇配方了！</p><p id="307c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我的食谱包括:</p><ul class=""><li id="c990" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">选择正确的算法</li><li id="1cbb" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">选择正确的数据结构</li><li id="2691" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">一些分析和验证我们选择的技巧</li></ul><p id="6135" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在本文中，我将重点介绍如何选择正确的算法，并使用一些技术来分析和验证我们的选择。在我以后的文章中，我将解释其他部分。说够了，我们开始吧！</p><h1 id="7a2a" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">哦！哦！大O！</h1><h2 id="56b0" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">等等，什么是大O？</h2><p id="ced9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们来看看这张图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/bb237bb63a8214ca4f900c1c49402529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*9QZNKa85t_ul-FG1YqOCyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">算法变异的极限(图片由作者提供)</p></figure><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="357c" class="ni kz it nw b gy oa ob l oc od">min: when we have a reduced number of input data (usually locally).<br/>max: when we have a lot of input data (usually in production).</span><span id="5230" class="ni kz it nw b gy oe ob l oc od">f(min) = minimum required steps to execute the code.<br/>f(max) = maximum required steps to execute the code.</span></pre><p id="4353" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在计算机世界里，我们称之为:</p><ul class=""><li id="8afd" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated"><code class="fe of og oh nw b">f(max)</code> : <em class="mm"> O(N) </em>，N的大O。</li><li id="8dc8" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated"><code class="fe of og oh nw b">f(min)</code>:<em class="mm">ω(N)</em>，N的大ω。</li><li id="93be" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">大O用来描述算法最坏情况下的运行时间。</li><li id="1422" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">大ω用于描述给定算法的最佳运行时间。</li></ul><p id="cd5f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">啊哈，魔法！</p><p id="0fa6" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在这篇文章中，我将重点放在大O(噩梦)。</p><blockquote class="oi oj ok"><p id="b775" class="lq lr mm ls b lt mn ju lv lw mo jx ly ol mp mb mc om mq mf mg on mr mj mk ml im bi translated">“大O告诉你数据和算法的效率之间的比例关系。它准确地描述了步骤数是如何随着数据的增加而增加的。”——数据结构和算法常识指南，第二版，Jay Wengrow</p></blockquote><p id="98f7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">简而言之，大O表示算法的性能如何随着数据的变化而变化？如果有<code class="fe of og oh nw b">N</code>数据项，算法要走多少步？</p><p id="a313" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">大O将是我们衡量算法速度的度量。</p><p id="7152" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果一个算法需要减少的指令(或步骤)来执行，那么它就被认为是快速的。注意到了！</p><h2 id="58ed" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">等等，记忆呢？</h2><p id="b313" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">你知道我们也可以用大O来表示空间复杂度吗？啊哈，我们只需要重新表述概念和问题。</p><p id="dfb3" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">对于内存消耗，我们要说:如果有<code class="fe of og oh nw b">N</code>个数据元素，算法会消耗多少内存单元？哒哒！</p><h2 id="26c0" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">那大O怎么帮我们呢？</h2><p id="bebc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们总结一下:</p><ul class=""><li id="83c2" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">性能:如果有<code class="fe of og oh nw b">N</code>数据元素，算法要走多少步？</li><li id="1268" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">内存:如果有<code class="fe of og oh nw b">N</code>个数据元素，算法会消耗多少内存单元？</li></ul><p id="5987" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">大O帮助我们预测一个算法的性能和消耗，甚至在它被执行之前！</p><p id="8c77" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">让我们看看大O在行动中的力量！</p><h1 id="232e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">一些经典算法</h1><h2 id="6caa" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">冒泡排序</h2><p id="8543" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">冒泡排序是一种简单的排序算法，它比较列表中一对相邻的元素。如果一个元素的顺序不对，我们就把它和之前的元素交换。否则，元素保持在相同的位置。哇，大数据的敏感算法！</p><p id="26cd" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">下面是一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">老式冒泡排序</p></figure><p id="c4b6" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">执行步骤:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="c15d" class="ni kz it nw b gy oa ob l oc od">"data input : ", [89, 13, 57, 44, 71, 51]<br/>"data i : ", [89, 13, 57, 44, 71, 51]<br/>"data i : ", [13, 57, 44, 71, 51, 89]<br/>"data i : ", [13, 44, 57, 51, 71, 89]<br/>"data i : ", [13, 44, 51, 57, 71, 89]<br/>"data i : ", [13, 44, 51, 57, 71, 89]<br/>"data i : ", [13, 44, 51, 57, 71, 89]<br/>"sortedTab : ", [13, 44, 51, 57, 71, 89]</span></pre><p id="df5c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">冒泡排序的效率:</p><p id="0c48" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">第一个循环需要<code class="fe of og oh nw b">data.length</code>步骤:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="1682" class="ni kz it nw b gy oa ob l oc od">for (let i = 0; i &lt; data.length; i++) {</span></pre><p id="ce07" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">第二个循环也需要<code class="fe of og oh nw b">data.length</code>步骤:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="4c54" class="ni kz it nw b gy oa ob l oc od">for (let j = 0; j &lt; data.length; j++) {</span></pre><p id="25c0" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果<code class="fe of og oh nw b">data.length = n</code>，那么冒泡排序算法的最坏情况时间复杂度为O(n)。OMG！</p><p id="0333" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">因为我们是在不创建副本或临时数组的情况下就地修改数组，所以冒泡排序的空间复杂度为O(1)。</p><p id="86ec" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">当数组元素较少且数组接近排序时，冒泡排序是有效且高效的。</p><h2 id="56b8" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">插入排序</h2><p id="7883" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">插入排序背后的思想是，数组实际上被分成一个排序部分和一个未排序部分。未排序部分的值被选择并放置在排序部分的正确位置。</p><p id="016b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">就像整理扑克牌一样:</p><ul class=""><li id="7d8e" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">假设在纸牌游戏中第一张牌已经被分类。</li><li id="6671" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">然后我们选择一张未分类的卡片。</li><li id="7f0b" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">如果选定的未排序卡片大于第一张卡片，它将被放置在右侧。</li><li id="53e4" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">否则会放在左侧。</li><li id="d3ea" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">类似地，所有未分类的卡片被取出并放在它们的确切位置。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/5759ce5c55a48bf2e35c8355854dade7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A72MRZllItOB0HmkaYhSYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">订购的卡片(授权给作者的图片)</p></figure><p id="9ce9" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">哇，又一个棘手的大数据算法！</p><p id="b0d2" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">插入排序中有四种步骤:删除、比较、移位和插入。</p><p id="aeb9" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">下面是更多的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复古插入排序</p></figure><p id="d9ce" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">以下是一些执行步骤:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="eb53" class="ni kz it nw b gy oa ob l oc od">"data input : ", [89, 13, 57, 44, 71, 51]</span><span id="d406" class="ni kz it nw b gy oe ob l oc od">"data i : ", [89, 13, 57, 44, 71, 51]<br/>"data i : ", [13, 89, 57, 44, 71, 51]<br/>"data i : ", [13, 57, 89, 44, 71, 51]<br/>"data i : ", [13, 44, 57, 89, 71, 51]<br/>"data i : ", [13, 44, 57, 71, 89, 51]</span><span id="90f4" class="ni kz it nw b gy oe ob l oc od">[13, 44, 51, 57, 71, 89]</span></pre><p id="7d40" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">插入排序的效率:</p><p id="d002" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">冒泡排序算法的最坏情况时间复杂度为O(n)，空间复杂度为O(1)。OMG！</p><h2 id="ad48" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">线性搜索</h2><p id="c05b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这是最简单、最自然、最直观的算法:</p><ul class=""><li id="324e" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">线性搜索将接受一个数组和一个目标值。</li><li id="e5ea" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">从数组的开头开始搜索。</li><li id="50ad" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">检查该值是否等于目标值。</li><li id="7602" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">如果是，停止并返回该值的索引。</li><li id="bf7b" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">如果没有，继续下一个元素。</li></ul><p id="d3fd" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">哇哦。简单但昂贵且贪婪，尤其是对于大数据！</p><p id="84c9" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">下面是更多的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">老式线性搜索</p></figure><p id="c545" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">线性搜索的效率:</p><ul class=""><li id="de9c" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">如果目标值在开始，算法将总是在恒定时间<code class="fe of og oh nw b">O(1)</code>运行。</li><li id="579f" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">如果目标是数组中的最后一个元素，那么算法将进行<code class="fe of og oh nw b">n</code>比较(<code class="fe of og oh nw b">n</code>是输入数据的长度)。</li><li id="2c1c" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">如果目标元素在数组中间的某个地方，那么时间复杂度大约为<code class="fe of og oh nw b">O(n/2)</code>。</li></ul><p id="98b3" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">线性搜索的时间复杂度为1 —线性时间复杂度。</p><p id="c7c8" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">线性搜索的空间复杂度为<code class="fe of og oh nw b">O(1)</code> —常数空间。它不使用辅助数据结构来寻找目标值。</p><p id="2509" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">哇，一个敏感的大数据搜索算法！</p><h2 id="3fd5" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">二进位检索</h2><p id="9790" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">二分搜索法背后的思想是通过将搜索区间一分为二来搜索一个有序的数组。我特别喜欢这个算法，因为它让我想起了我们猜数字的游戏:更低，更高，更多！</p><p id="1c59" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">为您提供更多代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复古二分搜索法</p></figure><p id="341e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">二进制排序的效率:</p><p id="2ff4" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">二分搜索法算法的时间复杂度为<code class="fe of og oh nw b">O(log n)</code>。</p><ul class=""><li id="ad2e" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">当中心索引将直接匹配期望值时，最佳情况的时间复杂度将是<code class="fe of og oh nw b">O(1)</code>。</li><li id="4992" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">最坏的情况可能是列表两端的值或者不在列表中的值。</li></ul><p id="589b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在迭代方法中，空间复杂度将是<code class="fe of og oh nw b">O(1)</code>。而在递归方法中，空间复杂度将是<code class="fe of og oh nw b">O(log n)</code>。</p><p id="c686" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">还不错！我们还可以改进，看！</p><h1 id="1018" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">改进老式算法</h1><h2 id="a81d" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">合并排序</h2><p id="c41d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你想在现实生活中看到“分而治之”的策略，这个算法将是最好的例子。</p><p id="349a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">以下是合并排序的工作原理:</p><ul class=""><li id="d996" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">它将整个列表分成子列表或“n”个子列表。</li><li id="ce16" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">它递归地继续这个过程，直到每个子列表都有一个元素。</li><li id="03f4" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">一旦这个“分而治之”的过程完成，它就开始合并每个子列表来创建一个排序列表。</li></ul><p id="f239" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">将问题分解成更小的子问题，直到它们变得足够简单，可以直接解决。我喜欢！</p><p id="d516" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">下面是更多的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并排序</p></figure><p id="dc42" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">现在，让我们一步一步地看代码:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="8824" class="ni kz it nw b gy oa ob l oc od">Consider this input data :<br/>[5, 7, 1, 4, 6, 3, 2]</span><span id="ac37" class="ni kz it nw b gy oe ob l oc od">Divide the array into two sub-arrays :<br/>[5, 7, 1] and [4, 6, 3, 2]</span><span id="697b" class="ni kz it nw b gy oe ob l oc od">Again each array will be divided into two subarrays :<br/>[5], [7, 1] and [4, 6], [3, 2]</span><span id="d7d7" class="ni kz it nw b gy oe ob l oc od">Continue over and over :<br/>[5], [7], [1], [4], [6], [3], [2]<br/>[5, 7], [1, 4], [3, 6], [2]<br/>[1, 4, 5, 7] [2, 3, 6]<br/>[5], [7], [1], [4], [6], [3], [2]</span><span id="4773" class="ni kz it nw b gy oe ob l oc od">Now the first step is complete as each array has only one item in it.</span><span id="1f85" class="ni kz it nw b gy oe ob l oc od">Now we will compare the array elements and merge these single item arrays into pairs :<br/>[5, 7], [1, 4], [3, 6], [2]<br/>[1, 4, 5, 7] [2, 3, 6]<br/>[1, 2, 3, 4, 5, 6, 7]</span></pre><p id="204b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">合并排序的效率:</p><p id="734c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">合并排序的时间复杂度为<code class="fe of og oh nw b">O(n log(n))</code>。</p><p id="c8be" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">归并排序的空间复杂度为<code class="fe of og oh nw b">O(n)</code>。</p><p id="df77" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">对于排序算法来说，合并排序非常快，但是速度的提高是以占用更多内存空间为代价的。数组越大，需要存储在内存中的数组就越多(因为要分割它们)。行动。</p><p id="113d" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">快速排序算法也遵循分治法。它根据某种条件将元素划分成更小的部分，并对这些划分的更小部分执行排序操作。啊哈，它对大型数据集很有效！</p><p id="f13b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">是的，更多的代码给你:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">快速排序</p></figure><p id="32e0" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">以下是我们工作的更多解释:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/800932f0f9ce38f23ef8d6c66b80417a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYA9J1pj_WhhWeURDFfXXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">快速排序执行步骤(图片由作者提供)</p></figure><p id="e324" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">快速排序的效率:</p><ul class=""><li id="b924" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">快速排序的平均事例时间复杂度为O(n log (n))，与归并排序相同。即使输入数组很大，它的表现也很好。它提供了高性能，并且相对容易编码。</li><li id="7d42" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">它不需要任何额外的内存。</li><li id="4b0e" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">快速排序的主要缺点是主元选择不当会将算法的时间复杂度降低到O(n)。</li></ul><p id="a0e1" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">哇，这不是一个稳定的排序算法！</p><h2 id="d7d5" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">蒂姆排序</h2><p id="1929" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Tim排序是一种混合的稳定排序算法，源自合并排序和插入排序，旨在对多种真实数据执行良好。哇哦。</p><p id="6006" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">它是由Tim Peters在2002年开发的，用来取代Python之前的排序算法。此后，它被Java的OpenJDK、V8 JavaScript引擎以及Swift和Rust语言所采用。啊哈，这证明了蒂姆是表演型的。</p><p id="60a6" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">出于好奇:</p><p id="a1ab" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><a class="ae os" href="https://svn.python.org/projects/python/trunk/Objects/listsort.txt" rel="noopener ugc nofollow" target="_blank">提姆排序Python定义</a></p><p id="ad44" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><a class="ae os" href="https://svn.python.org/projects/python/trunk/Objects/listobject.c" rel="noopener ugc nofollow" target="_blank"> Tim Sort Python实现</a></p><p id="f710" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在我们继续之前，我想说，如果你不知道Tim Sort的算法，你真的错过了计算机科学中一个重要而有趣的部分！</p><p id="c640" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">下面是一个开源实现示例(JavaScript):</p><div class="ot ou gp gr ov ow"><a href="https://github.com/LXSMNSYC/TimSort" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">GitHub-LXSMNSYC/TimSort:JS/ES中的Tim sort实现。</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">JS/ES中TimSort的实现。为教育目的制作的。TimSort是一种混合稳定排序算法，由…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><p id="8127" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">时间排序的效率:</p><ul class=""><li id="b0f7" class="mt mu it ls b lt mn lw mo lz mv md mw mh mx ml my mz na nb bi translated">Tim Sort是一种自适应排序算法，需要O(n log n)次比较来对n个元素的数组进行排序。</li><li id="2d22" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">Tim排序的空间复杂度为O(n)。</li></ul><h2 id="077a" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">是时候总结一下到目前为止我们所看到的了！</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/bcb2cc3b85d8279e574695dd69136f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZ93ikmhhMYoqpXnPSFnAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">排序算法的比较(图片由作者提供)</p></figure><h1 id="c66b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">一些空间复杂性提示</h1><h2 id="9bf1" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">就地更改数组</h2><p id="3124" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">默认情况下，我在代码中采用函数式方法。不允许突变，所有函数都是纯函数。然而，在我创建副本之前，特别是对于大量数据，我必须确保这种语言提供了浅层副本、结构化共享或写时复制等概念(我们将在后面看到)。如果没有，我选择“就地改变阵列”策略。</p><p id="727b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">上述函数就地更改输入数据:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="b012" class="ni kz it nw b gy oa ob l oc od">const inPlaceChange = (data) =&gt; {<br/>  for (let i in data) {<br/>    data[i] = data[i] * 2;<br/>  }<br/>}</span><span id="e97b" class="ni kz it nw b gy oe ob l oc od">const tab  = [1, 2, 3, 4];</span><span id="b410" class="ni kz it nw b gy oe ob l oc od">console.log(tab) // [1, 2, 3, 4]</span><span id="b535" class="ni kz it nw b gy oe ob l oc od">inPlaceChange(tab);</span><span id="7433" class="ni kz it nw b gy oe ob l oc od">console.log(tab) // [2, 4, 6, 8]</span></pre><p id="94d3" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">上面的函数在改变数组之前创建一个副本:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="6a5a" class="ni kz it nw b gy oa ob l oc od">const copyChange = (data) =&gt; {<br/>  const dataCopy = [<br/>    ...data<br/>  ]<br/>  for (let i in dataCopy) {<br/>    dataCopy[i] = dataCopy[i] * 2;<br/>  }<br/>  return dataCopy;<br/>}</span><span id="fbe5" class="ni kz it nw b gy oe ob l oc od">const tab = [1, 2, 3, 4];</span><span id="0d75" class="ni kz it nw b gy oe ob l oc od">console.log(tab) // [1, 2, 3, 4]</span><span id="e105" class="ni kz it nw b gy oe ob l oc od">const newTab = copyChange(tab);</span><span id="382b" class="ni kz it nw b gy oe ob l oc od">console.log(tab) // [1, 2, 3, 4]<br/>console.log(newTab) // [2, 4, 6, 8]</span></pre><p id="98ae" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">创建副本前要小心。我们通常避免对大数据进行深度拷贝，而是使用浅层拷贝或一些技术，如结构共享和写入时拷贝。让我们看看！</p><h2 id="9db4" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">结构共享</h2><p id="05c0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当我们采用函数式风格和数据不变性时，我们通过创建数据的副本(新版本)来处理数据更改，而不是在不影响性能的情况下改变数据。</p><p id="2772" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">结构化共享提供了一种在多个版本的it之间共享数据的有效方式，而不是复制整个数据。这类似于git的工作方式。哇哦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/139467f07a9f625e953a2dad1053ca9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/0*FRra15-wWdtN7XVF.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae os" href="https://en.wikipedia.org/wiki/Persistent_data_structure#/media/File:Purely_functional_tree_after.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a> —持久数据结构</p></figure><p id="3211" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在上面的模式中，<code class="fe of og oh nw b">ys</code>共享<code class="fe of og oh nw b">xs</code>的结构。</p><h2 id="7036" class="ni kz it bd la nj nk dn le nl nm dp li lz nn no lk md np nq lm mh nr ns lo nt bi translated">写入时复制(cow)</h2><p id="00bd" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">“写入时拷贝”意味着每个人都有一份相同数据的共享拷贝，直到数据被写入，然后制作一份拷贝。复制大量复杂的数据可能是一项昂贵的操作。如果副本从未被修改，那么就没有必要产生这个成本。超级！</p><p id="290a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">更多详情如下:</p><div class="ot ou gp gr ov ow"><a href="https://raganwald.com/2019/01/14/structural-sharing-and-copy-on-write.html" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">探索结构化共享和写时复制语义，第一部分</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">这篇文章非常随意地探讨了在使用大型数据时实现高性能的两种相关技术…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">raganwald.com</p></div></div><div class="pf l"><div class="pn l ph pi pj pf pk ks ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://en.wikipedia.org/wiki/Persistent_data_structure" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">持久数据结构-维基百科</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">在计算中，持久数据结构或非短暂数据结构是一种总是保持数据完整性的数据结构</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">写时复制-维基百科</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">写时复制(COW)，有时也称为隐式共享或隐藏，是一种资源管理技术，用于…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">en.wikipedia.org</p></div></div><div class="pf l"><div class="po l ph pi pj pf pk ks ow"/></div></div></a></div><h1 id="387f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">你知道吗？</h1><p id="a413" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Timsort从V8 v7.0和Chrome 70开始提供！</p><div class="ot ou gp gr ov ow"><a href="https://v8.dev/blog/array-sort" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">在V8中整理东西</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">Array.prototype.sort是V8中自托管JavaScript实现的最后几个内置功能之一。移植它为我们提供了…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">v8.dev</p></div></div><div class="pf l"><div class="pp l ph pi pj pf pk ks ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://github.com/v8/v8/commit/5a3893958a8211722b01f6b5bbfdd4498a45ff57" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">[array]将Array.p.sort移动到Torque并使用TimSort而不是QuickSort v8/v8@5a38939</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">浏览文件[array]Move array . p . sort to Torque并使用TimSort代替QuickSort这个CL改变了排序…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pq l ph pi pj pf pk ks ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://github.com/v8/v8/commit/9d406a0249289880f13be1c057fe95077533a9a9" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">Reland "[array]将Array.p.sort的QuickSort更改为TimSort " V8/V8 @ 9d 406 A0</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">browse files Reland "[array]Change quick sort to Tim sort for array . p . sort "这是原始更改的Reland…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pr l ph pi pj pf pk ks ow"/></div></div></a></div><h1 id="fbf1" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="a89b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">嗯，这或多或少是一个漫长的算法之旅。</p><p id="601a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">很明显，算法的选择对性能和所使用的资源，尤其是存储器，有直接的影响。</p><p id="609b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">感谢发明家和数学家，他们为我们提供了一种度量标准，在算法真正执行之前，或多或少地准确预测了算法的行为。</p><p id="5af3" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在这个层次上，有些人会问我:如果编程语言已经提供了排序、搜索等本地方法，我们为什么还要学习和了解这一部分呢？？这个问题问得好，下面是我的回答。</p><p id="845f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">首先，我们需要知道我们在生产中出现问题或调试时使用什么。如果本地方法的内部算法实现了快速排序或Tim排序，我们就放心了。否则，我们必须提高警惕并加以改进。</p><p id="cc34" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">然后，有时一些语言本身没有实现最优方法。</p><p id="41ac" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">知道并掌握大O概念，能够在问题出现之前就预测出来，这是非常好的。在执行之前，一切都是精心计算和选择的。</p><p id="d73f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">为了提高性能和资源消耗，您应该接近低水平。大O，时间复杂度和空间复杂度在软硬部分之间提供了很好的抽象。</p><p id="4681" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">啊哈，你现在知道如何选择正确的算法了吗？是的，很好，你知道怎么根据“大O”！</p><p id="51fb" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">大O不仅仅指排序和搜索算法，而是一个适用于所有类型算法的通用概念。排序和研究通常作为一个简单的例子来说明大o的应用。</p><p id="a857" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">最后，我祝你在算法优化的世界和大O. O .的宇宙中一路顺风！哦！大O！</p><p id="66b1" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在以后的文章中再见！</p></div><div class="ab cl ps pt hx pu" role="separator"><span class="pv bw bk pw px py"/><span class="pv bw bk pw px py"/><span class="pv bw bk pw px"/></div><div class="im in io ip iq"><p id="5b60" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">感谢您阅读我的文章。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="b5e8" class="ni kz it nw b gy oa ob l oc od"><strong class="nw iu">Want to Connect?</strong></span><span id="dc02" class="ni kz it nw b gy oe ob l oc od">You can find me at GitHub: <a class="ae os" href="https://github.com/helabenkhalfallah" rel="noopener ugc nofollow" target="_blank">https://github.com/helabenkhalfallah</a></span></pre></div></div>    
</body>
</html>