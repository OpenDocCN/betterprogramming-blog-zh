<html>
<head>
<title>Data Structures. What’s a List?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构。什么是列表？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-structures-whats-a-list-ca04b0ba9fa2?source=collection_archive---------3-----------------------#2019-09-26">https://betterprogramming.pub/data-structures-whats-a-list-ca04b0ba9fa2?source=collection_archive---------3-----------------------#2019-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4630" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">列表数据结构及其实现的详细指南——数组列表和链表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f626e73f1bfa9bf476e16ce21a70afab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RrbsorsjEN6rqvhGaB_P9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塞缪尔·泽勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="923a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道数据结构是如何运作的吗？</p><p id="39b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掌握数据结构对每个软件工程师来说都是必不可少的。在这里，我将尽力提供新的和有趣的信息。</p><p id="572c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c53f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到<a class="ae ky" href="https://en.wikipedia.org/wiki/List_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">列表</a>数据结构时，我们应该提到它定义了一组连续的元素，您可以向其中添加新元素，删除或更改现有的元素。</p><p id="d0e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表数据结构通常有两个非常独特的实现——<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_array" rel="noopener ugc nofollow" target="_blank">数组列表</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表</a>。</p><p id="cba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将讨论数组列表和链表，并解释它们背后的思想。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c8d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数组表</h1><p id="db48" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们来看看列表的第一个也是最常用的实现——数组列表。</p><h2 id="91b0" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">概观</h2><p id="4f4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数组列表基本上是一个自调整大小的<a class="ae ky" href="https://en.wikipedia.org/wiki/Array_data_structure" rel="noopener ugc nofollow" target="_blank">数组</a>，或者换句话说，是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_array" rel="noopener ugc nofollow" target="_blank">动态数组</a>。</p><p id="6ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组列表背后的魔法肯定没那么复杂。让我们揭开这个秘密。</p><p id="f3bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，它只是在幕后管理一个普通的静态数组。</p><p id="6d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种数据结构的行为与普通数组完全一样，但具有一个额外的容量属性，每次超出该属性时都会调用大小扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3cfc5161987069f5cc75d4e5f430e1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*dLr3ucvxDwKm8VyRCrAgdQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大小为3、容量为4的数组列表</p></figure><p id="04e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着这种数据结构可以按需增长，而传统的静态数组则不能，因为它有一个预定义的最大大小。</p><p id="ef15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给我们带来了数组列表的优点和缺点。</p><p id="a4ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组列表和数组作为一个整体的奇妙之处在于，因为它们的元素在内存中是连续的，所以它们可以极大地从<a class="ae ky" href="https://www.infoworld.com/article/3217388/how-to-speed-your-code-using-cpu-caches.html" rel="noopener ugc nofollow" target="_blank"> CPU缓存</a>中获益<a class="ae ky" href="https://www.infoworld.com/article/3217388/how-to-speed-your-code-using-cpu-caches.html" rel="noopener ugc nofollow" target="_blank">。这极大地提高了操作数据结构的速度。</a></p><p id="e828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一件不太妙的事情是，调整大小操作有时会由于我们将在后面提到的问题而失败。</p><p id="a8fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，数组列表有时会使用比实际需要更多的空间。</p><h2 id="708f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">使用</h2><p id="31a6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当您迫切需要存储项目，但事先不知道需要多少空间时，对这种数据结构的需求最为明显。</p><p id="d1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当您经常需要从数据结构中添加或获取元素时，数组列表将非常适合，因为这些操作快速而高效。</p><p id="f7cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要经常删除或插入元素，那么选择数据结构并不是很好。</p><h2 id="9468" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">复杂性</h2><ul class=""><li id="d2e1" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">加法(元素)→ O(1)</li><li id="e9a3" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">移除(元素)→ O(n)</li><li id="a974" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">insert(元素，索引)→ O(n)</li><li id="f0a1" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">get(索引)→ O(1)</li></ul><h2 id="430b" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">履行</h2><p id="4380" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好吧，让我们看看真正的东西。</p><p id="a462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先来看一个典型的数组列表定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操作和变量的数组列表定义</p></figure><p id="eaff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续实现构造函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组列表无参数和容量参数构造函数</p></figure><p id="eace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将展示一些典型数组列表操作的实现。</p><p id="8ac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">添加操作</strong></p><p id="63cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个操作在大多数情况下是快速的，当它不快速时，是在数组列表必须增加其容量的情况下。</p><p id="7d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解调整大小是如何工作的，让我们考虑一下这个数组列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/834eb468fbf305306ec82c24a4586a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*3pMv0_27dYzyolusfJkgng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大小为4、容量为4的数组列表</p></figure><p id="ed07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图中的数组列表已经达到了它的容量，在下一次添加操作时，将会触发调整大小机制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/434ea2ed9a441016fba6d52867803440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldBQ8RTKvzYDA5OsFvyXqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大小为5、容量为8的数组列表</p></figure><p id="97a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是容量溢出添加操作后您将得到的结果—容量加倍的数组列表。</p><p id="997f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组列表添加操作</p></figure><p id="ab84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">移除At操作</strong></p><p id="a496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移除数组列表中的元素是一个相当慢的操作。</p><p id="99f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为当您删除一个元素时，为了保持内部静态数组数据结构的连续性，您必须将所有跟在已删除元素后面的元素向左移动一个位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a48738c5b9861719f69c1642ba68b43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGnTzCbq4_440Ym04fpCaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内部数组列表移除元素操作</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操作时删除数组列表</p></figure><p id="7319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">移除操作</strong></p><p id="5e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个操作差不多可以用<code class="fe of og oh oi b">removeAt</code> <em class="oj"> </em>操作来概括。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组列表删除操作</p></figure><p id="5cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">插入操作</strong></p><p id="4b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">insert</code>操作类似于<code class="fe of og oh oi b">removeAt</code>操作，但为了给新元素腾出空间，从指定索引的相反方向移动元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组列表插入操作</p></figure><p id="01f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">调整尺寸操作</strong></p><p id="fa78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">女士们先生们，这是标志性的调整大小操作。</p><p id="a578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种操作可以被认为是这种数据结构的缺点，因为它可能相当慢..</p><p id="eebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为数组列表不能简单地替换它当前的静态数组。正如我们之前提到的，它需要创建一个新的、更大的静态数组，并用当前存储的数据填充它。</p><p id="0666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个操作需要时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/502584d978c4e7c877dfef8f3c9103fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yb_y-4JVp8Nn1IcZeIwltQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内部数组列表调整大小操作</p></figure><p id="d53a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了速度慢之外，调整大小操作有时还会由于<a class="ae ky" href="https://library.softwareverify.com/memory-fragmentation-your-worst-nightmare/" rel="noopener ugc nofollow" target="_blank">内存碎片</a>而失败。</p><p id="6c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们之前提到的，这个操作还会使数据结构占用比实际需要更多的空间。这种情况下，我们只需要存储很少的额外元素，但没有足够的空间来存储它们，因此数据结构的大小会翻倍，这会导致不必要的大数据结构。</p><p id="694a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，说够了(嗯，实际上是阅读，但是嘿，你说到点子上了)，让我们编码吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组列表调整大小操作</p></figure><p id="cbc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到了吗？看起来没有听起来那么恐怖。</p><p id="b5ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获取操作</strong></p><p id="e8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，简单的<code class="fe of og oh oi b">get</code>操作是一个非常快速的操作，它只是通过索引来检索元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组列表获取操作</p></figure><p id="65dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/danielgospodinow/PracticeWorkspace/blob/master/c%2B%2B/dsp2k19/DataStructures/data_structures/array_list/array_list.hpp" rel="noopener ugc nofollow" target="_blank">我的GitHub页面</a>找到这个通用C++数组列表的完整源代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9381" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">链表</h1><p id="7095" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在是时候看看列表的第二个最常见的实现了——链表。</p><h2 id="3095" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">概观</h2><p id="d605" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">链表是一种数据结构，它的思想与数组列表相似，但不同之处在于它的元素以完全不同的方式存储。</p><p id="aed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种数据结构的元素分布在整个内存中，而数组列表是按顺序排列的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/ae8ec3539ff39ba4e6aafe5b561c519d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YI3eeYQ_QxiNjxDz2DgNrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数组列表与链表内存布局</p></figure><p id="6c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为元素在内存中不是连续的，所以链表中的每个元素都必须存储下一个元素的地址。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5bc52a826113a3271872e78158708f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*wSZFJyxwnH5TDZGvPJGtfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">head标记注释列表的第一个元素，而tail标记注释最后一个元素</p></figure><p id="c35c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这带来了一些好处，也带来了一些坏处。</p><p id="00d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点之一是，由于链表的非顺序内存布局特性，它不能提供对元素的快速随机访问。</p><p id="e981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个被认为是缺点的事情是，伴随数据结构的每个数据节点的所有指针都存在内存开销。</p><p id="3cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，同样由于其非顺序内存布局，链表无法从CPU的缓存优化中获益。</p><p id="dded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们继续讲优点。</p><p id="c2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优点之一是链表可以安全地增长，而没有由于内存碎片而失败的风险，因为它的元素分布在整个内存中。为单个元素找到自由空间比为一系列元素找到自由空间更容易，数组列表就是这种情况。</p><p id="a8bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，需要指出的一点是，链表只使用它需要的内存，不像数组链表那样会分配很多额外的空闲空间，从而浪费宝贵的内存。</p><h2 id="1c5e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">使用</h2><p id="3794" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与数组列表数据结构一样，当您需要存储某种元素但不知道它们的总量时，您会发现链表非常有用。</p><p id="2623" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">链表非常适合需要经常从一组元素的开头或结尾添加或删除元素的应用程序。</p><p id="9a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对元素移除、获取或插入操作有很高的需求，那么选择数据结构并不是很好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/cef34de0f77308c1f927d7130cc121f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LptOYvxjgwOcfLRZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@melanie_sophie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅勒妮·庞格拉茨</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="6332" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">复杂性</h2><ul class=""><li id="e820" class="nm nn it lb b lc mu lf mv li no lm np lq nq lu nr ns nt nu bi translated">加法(元素)→ O(1)</li><li id="eaee" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">移除(元素)→ O(n)</li><li id="6c31" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">insert(元素，索引)→ O(n)</li><li id="b782" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">get(索引)→ O(n)</li></ul><h2 id="14f4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">履行</h2><p id="fe95" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">链表的实现比数组稍微复杂一些，所以要准备好面对很多问题。</p><p id="1228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次用一些C++代码来弄脏我们的手。</p><p id="d100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">链表中的元素被称为<em class="oj">节点、</em>，它们通过引用相互连接。每个节点都有一个<code class="fe of og oh oi b">nextElement</code> <em class="oj"> </em>属性。</p><p id="8e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先定义我们的元素，我们也称之为节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单一元素(节点)实现</p></figure><p id="7605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们定义链表本身。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链接列表定义</p></figure><p id="06b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和它的构造函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链表构造函数</p></figure><p id="54f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们展示最重要操作的实现。</p><p id="909c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">添加操作</strong></p><p id="a3ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">add</code>操作非常有效，因为这是一件非常简单的事情。</p><p id="2d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有需要做的就是更新尾部元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/2f93f8cb673ed66dd864da440a7b50b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*8sLKKJ8iO5EVEQsxpO581Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有新添加元素的链表72</p></figure><p id="8e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在下面的代码中看到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链表添加操作</p></figure><p id="ab6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">插入操作</strong></p><p id="9d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">插入操作的整体速度很大程度上取决于新元素必须插入的位置。</p><p id="21b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里所要做的就是将一个指针从一个指定的元素直接指向下一个元素，并在它们之间引入新元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/9f70ccd360f739d2856a63883f4ff035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVIKR8ibpzsnGKs7h0BXBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在链表中的元素69之后插入元素104</p></figure><p id="0d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编码这个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链表插入操作</p></figure><p id="6446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">移除At操作</strong></p><p id="ef22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">removeAt</code>操作与<code class="fe of og oh oi b">insert</code>操作具有相同的复杂性。</p><p id="d312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也只是一个替换指针的问题，但是操作是否快速完全取决于必须移除的元素的位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a4ac84d29826021575efc3861213761e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*SQZX0xqSmiYTuuccV7h8Vw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">移除链表中的元素69</p></figure><p id="72a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操作时移除链表</p></figure><p id="8ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">移除操作</strong></p><p id="176f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个操作再次被总结为<code class="fe of og oh oi b">removeAt</code>操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链表移除操作</p></figure><p id="1705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获取操作</strong></p><p id="0dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">get</code>的操作听起来很简单。唯一的问题是，它不如数组列表中的对应元素那么快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链表获取操作</p></figure><p id="61e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">咻…好了，就这些了。</p><p id="41aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只展示了最重要的操作的实现。剩下的，加上这个通用链表的全部源代码，可以在这里找到<a class="ae ky" href="https://github.com/danielgospodinow/PracticeWorkspace/blob/master/c%2B%2B/dsp2k19/DataStructures/data_structures/linked_list/linked_list.hpp" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c8b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数组列表和链表的比较</h1><p id="8a20" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好吧，只是做一个简单快速的比较:</p><ul class=""><li id="13aa" class="nm nn it lb b lc ld lf lg li op lm oq lq or lu nr ns nt nu bi translated">数组列表快速添加和获取元素，而链表可以快速添加或删除数据结构开头和结尾的元素。</li><li id="8049" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">链表没有内存碎片的问题，不像它的替代品，数组列表。</li><li id="030d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">数组列表可以从CPU缓存优化中受益，不像它的替代品链表。</li><li id="a2e5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">与分配额外内存的数组列表相比，链表只使用它需要的内存。</li></ul><p id="3e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用哪一种完全取决于您想要完成的任务类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1864" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0e33" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数组列表和链表都是最常用的数据结构。</p><p id="c511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们适合几乎所有的用例。</p><p id="c113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，使用它们时感到舒适是非常重要的。</p></div></div>    
</body>
</html>