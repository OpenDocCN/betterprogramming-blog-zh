<html>
<head>
<title>3 Steps to Turn a Random React Application Into a Micro-Frontend Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将随机React应用程序转变为微前端容器的3个步骤</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-steps-to-turn-a-random-react-application-into-a-micro-frontend-container-a80e33b6a066?source=collection_archive---------4-----------------------#2020-03-16">https://betterprogramming.pub/3-steps-to-turn-a-random-react-application-into-a-micro-frontend-container-a80e33b6a066?source=collection_archive---------4-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d7da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始使用微前端，这是一种运行多个应用程序的新方法，就像运行一个应用程序一样</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0acae1e61ba4a8cd3d38552ffafc0477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUWJhZZKUrrsVnulBmri0A.png"/></div></div></figure><p id="dbf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在发布了“<a class="ae lq" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">将随机React应用程序转变为微前端的5个步骤</a>之后，有人问我，“你的步骤简单易懂，易于遵循。但是我们如何将<a class="ae lq" href="https://camjackson.net/" rel="noopener ugc nofollow" target="_blank"> Cam Jackson </a>的<a class="ae lq" href="https://github.com/micro-frontends-demo" rel="noopener ugc nofollow" target="_blank">演示</a>应用到我们的项目中呢？"</p><p id="b117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题问得好。这引出了本系列的第二篇文章:“将随机React应用程序转变为微前端容器的3个步骤。”</p><p id="ad49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么是微前端方法？<em class="lr">微前端</em>这个术语在2016年11月<a class="ae lq" href="https://www.thoughtworks.com/radar/techniques/micro-frontends" rel="noopener ugc nofollow" target="_blank"> ThoughtWorks的技术雷达</a>中首次出现。它将微服务的概念扩展到前端开发。由于这是一个新词，它被拼写为<em class="lr">微前端、微前端、微前端、</em>和<em class="lr">微前端。</em></p><p id="754b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图显示了它的工作原理。前端开发必须分离为一些现有的产品代码和一些新开发的应用程序。在捆绑阶段或运行时，这些应用程序被加载到微前端容器中。容器运行它，就好像微前端是它自己的组件，并向用户提供无缝的工作流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/32e927a111e83ea4128ec4aeeac330cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3i08RF_S_XEi2KjqE82y4A.png"/></div></div></figure></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="1da7" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">应用程序容器</h1><p id="5dfe" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们选择的随机React应用程序是<a class="ae lq" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>。我们将其命名为<code class="fe mx my mz na b">App Container</code>，并修改了代码，使其具有以下路线:</p><ul class=""><li id="2dab" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe mx my mz na b">http://localhost:3000</code>:默认路由有两种选择——<code class="fe mx my mz na b">Home</code>和<code class="fe mx my mz na b">Micro Frontend</code></li><li id="cc0d" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mx my mz na b">http://localhost:3000/home</code>:<code class="fe mx my mz na b">Home</code>路线显示了一个普通组件，它是<code class="fe mx my mz na b">App Container</code>的一部分</li><li id="ee0f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mx my mz na b">http://localhost:3000/createreactapp</code>:<code class="fe mx my mz na b">Micro Frontend</code>路线显示微前端应用</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/023e8c2d205384642780c1da24011a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRDXVs616u1rJZv1mOvOwQ.png"/></div></div></figure></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="f2f3" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">微前端应用</h1><p id="dac4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">微前端app也是由Create React App衍生而来。我们将其命名为<code class="fe mx my mz na b">Micro Frontend App</code>，并遵循我们的五个步骤，使其成为一个微前端应用程序。它运行在<code class="fe mx my mz na b">http://localhost:4000</code>上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/01e11db6d3f5d91e89cd2ff419524e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwR9HSfORcT-cl6q0ucOPw.png"/></div></div></figure></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="46ff" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">1.将文件“MicroFrontend.js”复制到“src”目录中</h1><p id="937f" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">卡姆·杰克逊的核心作品是<code class="fe mx my mz na b"><a class="ae lq" href="https://github.com/micro-frontends-demo/container/blob/master/src/MicroFrontend.js" rel="noopener ugc nofollow" target="_blank">MicroFrontend.js</a></code>。</p><p id="67a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它从正在运行的应用程序中获取一个清单文件<a class="ae lq" href="https://github.com/facebook/create-react-app/issues/6436" rel="noopener ugc nofollow" target="_blank">并通过一个脚本标签启动该应用程序。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cf1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将Cam Jackson的<code class="fe mx my mz na b">MicroFrontend.js</code>复制到我们的<code class="fe mx my mz na b">src</code>目录中，并在第19行做了小小的修改。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="5a4f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">2.配置您的<code class="fe mx my mz na b">.env</code>文件，为每个微前端应用程序设置一个主机</h1><p id="7c6a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在<code class="fe mx my mz na b">.env</code>文件中，我们需要为每个微前端应用程序设置一个主机。对于我们的微前端app，Create React App，我们将端口设置为<code class="fe mx my mz na b">4000</code>。它必须与运行Create React App的真实端口相匹配。</p><pre class="kj kk kl km gt ns na nt nu aw nv bi"><span id="be3d" class="nw mb it na b gy nx ny l nz oa">REACT_APP_CREATEREACTAPP_HOST=http://localhost:4000</span></pre></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="e2a4" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">3.对于每个微前端应用程序，创建一个微前端组件，并使用路由来调用它</h1><p id="c3b5" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">下面是微前端容器的修改后的<code class="fe mx my mz na b">src</code> / <code class="fe mx my mz na b">App.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6fa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第7-13行生成一个微前端组件<code class="fe mx my mz na b">CreateReactApp</code>。</p><p id="763c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">app容器如何启动这个微前端应用？容器通过路由的组件启动它(见第64行)。</p><p id="35b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么是<a class="ae lq" href="https://knowbody.github.io/react-router-docs/api/RouteComponents.html" rel="noopener ugc nofollow" target="_blank">路线的组成部分</a>？它是一个组件，当该路径与URL匹配时就会呈现出来。路由器会在渲染时给这类组件注入道具，包括<code class="fe mx my mz na b">history</code>、<code class="fe mx my mz na b">location</code>、<code class="fe mx my mz na b">params</code>、<code class="fe mx my mz na b">route</code>、<code class="fe mx my mz na b">routeParams</code>。</p><p id="83d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么我们调用微前端作为路由的组件？这是因为微前端需要一个路由组件可用的道具，比如<code class="fe mx my mz na b">history</code>。</p><p id="58a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个，我们创建了一个可以启动微前端的app容器。在下面的截图中，Create React App作为微前端启动，用红框标出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/944ff01041c858826ac48240141abd2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZ01lkhPvxKwp8iCuZ0STA.png"/></div></div></figure></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="9e15" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">代码库</h1><p id="cc0c" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">这个例子有两个代码库:</p><ul class=""><li id="82cc" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><strong class="kw iu">app容器:</strong>三步转换后的应用容器位于<a class="ae lq" href="https://github.com/JenniferFuBook/app-container" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><pre class="kj kk kl km gt ns na nt nu aw nv bi"><span id="90ac" class="nw mb it na b gy nx ny l nz oa">git clone https://github.com/JenniferFuBook/app-container.git<br/>npm i<br/>npm start</span></pre><ul class=""><li id="8752" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><strong class="kw iu">微前端app: </strong>五步转换的微前端应用位于<a class="ae lq" href="https://github.com/JenniferFuBook/micro-frontend" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><pre class="kj kk kl km gt ns na nt nu aw nv bi"><span id="4409" class="nw mb it na b gy nx ny l nz oa">git clone https://github.com/JenniferFuBook/micro-frontend.git<br/>npm i<br/>npm start</span></pre><h2 id="0e34" class="nw mb it bd mc oc od dn mg oe of dp mk ld og oh mm lh oi oj mo ll ok ol mq om bi translated">发射命令</h2><p id="51a7" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们到每个存储库去<code class="fe mx my mz na b">npm start</code>应用容器和微前端应用。应用程序容器只有在所有微前端应用程序启动并运行后才能正常工作。</p><p id="dc96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有一种更好的方法来以特定的顺序启动多个应用程序。利用<code class="fe mx my mz na b"><a class="ae lq" href="http://micro front-end" rel="noopener ugc nofollow" target="_blank">concurrently</a></code>命令在一个命令中启动整个应用程序。假设这两个库在您的<code class="fe mx my mz na b">home</code>目录中。在Bash配置文件中设置以下别名:</p><pre class="kj kk kl km gt ns na nt nu aw nv bi"><span id="3560" class="nw mb it na b gy nx ny l nz oa">alias runBoth='cd ~/app-container; concurrently "npm start --prefix ~/micro-frontend" "npm start"'</span></pre><p id="385b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mx my mz na b">runBoth</code>将同时启动app容器和微前端app。这样，我们可以运行多个应用程序，但感觉就像只有一个应用程序。</p><p id="0304" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不是很好吗？</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="c6e7" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论</h1><p id="f9f2" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们用一个应用程序容器和一个微前端应用程序构建了一个示例。为微前端世界的进一步探索提供了基础。</p><p id="8f72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这项工作的一部分是由乔纳森马贡献。</p><p id="40e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。我希望这有所帮助。</p><p id="c8ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个关于微前端的系列。以下是其他文章的列表:</p><ul class=""><li id="b9df" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">"<a class="ae lq" href="https://medium.com/better-programming/5-steps-to-turn-a-random-react-application-into-a-micro-frontend-946718c147e7" rel="noopener">将随机React应用转变为微前端的5个步骤</a>"</li><li id="2fba" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">"<a class="ae lq" href="https://medium.com/better-programming/build-your-own-micro-frontend-ecosystem-a05128c74f99" rel="noopener">打造自己的微前端生态系统</a>"</li><li id="f790" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">"<a class="ae lq" href="https://medium.com/better-programming/you-dont-have-to-lose-optimization-for-micro-frontends-60a63d5f94fe" rel="noopener">您不必失去对微前端的优化</a>"</li><li id="8f0a" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">"<a class="ae lq" href="https://medium.com/better-programming/10-decision-points-for-micro-frontends-approach-4ebb4b59f40" rel="noopener">微前端方法的10个决策点</a>"</li><li id="3eb5" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">"<a class="ae lq" href="https://medium.com/better-programming/6-steps-to-create-a-multi-version-react-application-1c3e5b5df7e9" rel="noopener">创建多版本React应用程序的6个步骤</a>"</li><li id="de5f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">"<a class="ae lq" href="https://medium.com/better-programming/micro-frontends-using-webpack-5-module-federation-3b97ffb22a0d" rel="noopener">使用Webpack 5模块联盟的微前端</a>"</li></ul></div></div>    
</body>
</html>