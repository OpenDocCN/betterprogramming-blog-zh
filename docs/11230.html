<html>
<head>
<title>Theme Picker Animation in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack Compose中的主题选择器动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/theme-picker-animation-in-jetpack-compose-9351a8f50969?source=collection_archive---------17-----------------------#2022-02-28">https://betterprogramming.pub/theme-picker-animation-in-jetpack-compose-9351a8f50969?source=collection_archive---------17-----------------------#2022-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="289d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为你的用户提供定制的Android主题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/940925cce870568e26705e4071cbd04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojDcbzzylldZ-SiuUwAtbw.jpeg"/></div></div></figure><p id="babb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jetpack Compose改进了我们在Android中处理主题的旧方法。它提供了很大的灵活性，这让我们在定义UI外观时有了更多的可能性。与此同时，compose中的动画系统使我们能够轻松地创建更具雄心和愉悦的UI动画。在本教程中，我将结合这两者来创建一个切换主题的动画。最终结果将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/79b4733c80b3418a2cd47d5a062a27e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dyZuaSnIzxN4I6Bb.gif"/></div></div></figure><p id="63e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用<code class="fe ln lo lp lq b">AnimatedContent</code>来实现这个动画。这是一个可组合的对象，它接受任何对象作为状态和内容来显示。每当该状态改变时，它就使用新的状态从以前的内容变成新的内容。</p><p id="69ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要定义一个对象作为包含所有当前主题数据的状态来传递。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="851b" class="lv lw iq lq b gy lx ly l lz ma">data class CustomTheme(  <br/>    val primaryColor: Color,  <br/>    val background: Color,  <br/>    val textColor: Color,  <br/>    val image: Int,  <br/>)  <br/>  <br/>val darkTheme = CustomTheme(  <br/>    primaryColor = Color(0xFFE9B518),  <br/>    background = Color(0xFF111111),  <br/>    textColor = Color(0xffFFFFFF),  <br/>    image = R.drawable.dark,  <br/>)  <br/>  <br/>val lightTheme = CustomTheme(  <br/>    primaryColor = Color(0xFF2CB6DA),  <br/>    background = Color(0xFFF1F1F1),  <br/>    textColor = Color(0xff000000),  <br/>    image = R.drawable.light,  <br/>)  <br/>  <br/>val pinkTheme = CustomTheme(  <br/>    primaryColor = Color(0xFFF01EE5),  <br/>    background = Color(0xFF110910),  <br/>    textColor = Color(0xFFEE8CE1),  <br/>    image = R.drawable.pink,  <br/>)</span></pre><p id="aa34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我定义了一个数据类和三个具有独特颜色的主题。</p><p id="3bb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以实现<code class="fe ln lo lp lq b">AnimatedContent</code>并使用这个对象作为状态。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="27a4" class="lv lw iq lq b gy lx ly l lz ma"><a class="ae mb" href="http://twitter.com/ExperimentalAnimatio" rel="noopener ugc nofollow" target="_blank">@ExperimentalAnimatio</a>nApi  <br/><a class="ae mb" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a>  <br/>fun App() {  <br/>    var theme by remember { mutableStateOf(lightTheme) }  <br/>    AnimatedContent(  <br/>        targetState = theme,  <br/>        modifier = Modifier  <br/>            .background(Color.Black)  <br/>            .fillMaxSize(),  <br/>    ) { currentTheme -&gt;  <br/>        Surface(  <br/>            modifier = Modifier  <br/>                 .fillMaxSize(),  <br/>            color = currentTheme.background  <br/> ) {  <br/>            Box {  <br/>                Box(  <br/>                    modifier = Modifier  <br/>                        .fillMaxWidth()  <br/>                        .height(300.dp)  <br/>                ) {  <br/>                    Image(  <br/>                        painter = painterResource(id = currentTheme.image),  <br/>                        contentDescription = "headerImage",  <br/>                        contentScale = ContentScale.Crop,  <br/>                    )  <br/>                    Box(  <br/>                        modifier = Modifier  <br/>                            .fillMaxSize()  <br/>                            .background(  <br/>                                brush = Brush.verticalGradient(  <br/>                                    colors = listOf(  <br/>                                        Color.Transparent,  currentTheme.background.copy(alpha = .2f),  <br/>                                        currentTheme.background  <br/>                                    )  <br/>                                )  <br/>                            )  <br/>                    )  <br/>                }  <br/>  <br/>                Row(  <br/>                    modifier = Modifier  <br/>                        .align(Alignment.Center),  <br/>                    horizontalArrangement = Arrangement.Center,  <br/>                    verticalAlignment = Alignment.CenterVertically,  <br/>                ) {  <br/>  <br/>                    ThemeButton(  <br/>                        theme = lightTheme,  <br/>                        currentTheme = currentTheme,  <br/>                        text = "Light",  <br/>                    ) {  <br/>                        theme = lightTheme  <br/>                    }  <br/>  <br/>                    ThemeButton(  <br/>                        theme = darkTheme,  <br/>                        currentTheme = currentTheme,  <br/>                        text = "Dark",  <br/>                    ) {  <br/>                        theme = darkTheme  <br/>                    }  <br/>  <br/>                    ThemeButton(  <br/>                        theme = pinkTheme,  <br/>                        currentTheme = currentTheme,  <br/>                        text = "Pink",  <br/>                    ) {  <br/>                        theme = pinkTheme  <br/>                    }  <br/>                }  <br/>            }  <br/>        }  <br/>    }  <br/>}</span></pre><p id="5b80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">状态<code class="fe ln lo lp lq b">theme</code>已经被初始化并传递给<code class="fe ln lo lp lq b">AnimatedContent</code>。在内容中，<code class="fe ln lo lp lq b">currentTheme</code>被传入用于主题化我们的用户界面。</p><p id="5b74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们应该使用这个而不是<code class="fe ln lo lp lq b">theme</code>，这样当状态改变时，先前的内容不会立即切换到新的主题。</p><p id="c1b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有一个简单的UI，定义了一个标题图像和三个按钮，可以在可用的主题之间切换。在这一点上，我们将有一个动画看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/58b29cc956ceee7fdeff8c1646312f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ErS20zJxoOCo825xcAMvww.gif"/></div></div></figure><p id="c8cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是<code class="fe ln lo lp lq b">AnimatedContent</code>自带的默认动画。</p><p id="84b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没关系，但我们需要改变这一点，以便在最终动画中实现圆形显示动画。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="3f46" class="lv lw iq lq b gy lx ly l lz ma">transitionSpec = {  <br/>    fadeIn(  <br/>        initialAlpha = 0f,  <br/>        animationSpec = tween(100)  <br/>    ) with fadeOut(  <br/>        targetAlpha = .9f,  <br/>        animationSpec = tween(800)  <br/>    ) + scaleOut(  <br/>        targetScale = .95f,  <br/>        animationSpec = tween(800)  <br/>    )  <br/>}</span></pre><p id="2862" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们需要传入<code class="fe ln lo lp lq b">AnimatedContent</code>的自定义动画。新内容几乎会立即淡入，而旧内容会在较长时间内发生微妙的淡入和缩放。新的内容有一个快速淡入，这样我们就可以立即开始显示动画。当在<code class="fe ln lo lp lq b">AnimatedContent</code>中改变状态时，新的内容是一个新的可组合内容，因此它触发自己的<code class="fe ln lo lp lq b">LaunchedEffect</code>。我们将从这里开始播放动画，并使用该值在新内容上播放一个循环剪辑。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="0327" class="lv lw iq lq b gy lx ly l lz ma">...<br/>var theme by remember { mutableStateOf(pinkTheme) }  <br/>var animationOffset by remember { mutableStateOf(Offset(0f, 0f)) }<br/>AnimatedContent(  <br/>    ...<br/>) { currentTheme -&gt;</span><span id="a789" class="lv lw iq lq b gy mc ly l lz ma">val revealSize = remember { Animatable(1f) }  <br/>    LaunchedEffect(key1 = "reveal", block = {  <br/>        if (animationOffset.x &gt; 0f) {  <br/>            revealSize.snapTo(0f)  <br/>            revealSize.animateTo(1f, animationSpec = tween(800))  <br/>        } else {  <br/>            revealSize.snapTo(1f)  <br/>        }  <br/>    })  <br/> <br/>    Box(  <br/>        modifier = Modifier  <br/>   .fillMaxSize()  <br/>            .clip(CirclePath(revealSize.value, animationOffset))  <br/>    ) {  <br/>        Surface(<br/>...</span></pre><p id="4090" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">animationOffset</code>状态定义了圆动画的原点在哪里。这将稍后在<code class="fe ln lo lp lq b">ThemeButton</code>中设置。<code class="fe ln lo lp lq b">revealSize</code>制作剪辑新内容的圆圈的动画。</p><p id="981f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">LaunchedEffect</code>中，如果我们有一个有效的原点，我们开始圆形剪辑动画。如果没有，这意味着这是我们刚打开这个屏幕时的第一次重组，所以我们只是将动画捕捉到结尾。</p><p id="d420" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们用一个盒子把<code class="fe ln lo lp lq b">Surface</code>包起来。</p><p id="3674" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，所使用的形状是自定义的。原因是默认的<code class="fe ln lo lp lq b">CircleShape</code>只是一个半径很大的圆角矩形，我不能用它来达到我想要的效果。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="576f" class="lv lw iq lq b gy lx ly l lz ma">class CirclePath(private val progress: Float, private val origin: Offset = Offset(0f, 0f)) : Shape {  <br/>    override fun createOutline(  <br/>        size: Size,  <br/>        layoutDirection: LayoutDirection,  <br/>        density: Density  <br/> ): Outline {  <br/>  <br/>        val center = Offset(  <br/>            x = size.center.x - ((size.center.x - origin.x) * (1f - progress)),  <br/>            y = size.center.y - ((size.center.y - origin.y) * (1f - progress)),  <br/>        )  <br/>        val radius = (sqrt(  <br/>            size.height * size.height + size.width * size.width  <br/>        ) * .5f) * progress  <br/>  <br/>  return Outline.Generic(  <br/>            Path().apply {  <br/>                addOval(  <br/>                    Rect(  <br/>                        center = center,  <br/>                        radius = radius,  <br/>                    )  <br/>                )  <br/>            }  <br/>        )  <br/>    }  <br/>}</span></pre><p id="c7a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">形状<code class="fe ln lo lp lq b">CirclePath</code>接受一个浮点，它定义了目前为止的进度和动画的原点。</p><p id="a2c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两者和大小用于创建覆盖整个内容的圆形显示动画。</p><p id="6339" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后要做的事情是定义单击按钮时动画的原点。这个值在<code class="fe ln lo lp lq b">ThemeButton</code>中，当点击一个按钮时被传递。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="bed9" class="lv lw iq lq b gy lx ly l lz ma"><a class="ae mb" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a>  <br/>fun ThemeButton(  <br/>    theme: CustomTheme,  <br/>    currentTheme: CustomTheme,  <br/>    text: String,  <br/>    onClick: (Offset) -&gt; Unit,  <br/>) {  <br/>    val isSelected = theme == currentTheme  <br/> var offset: Offset = remember { Offset(0f, 0f) }  <br/>    Column(  <br/>        horizontalAlignment = Alignment.CenterHorizontally  <br/> ) {  <br/>        Box(  <br/>            modifier = Modifier  <br/>    .onGloballyPositioned {  <br/>                    offset = Offset(  <br/>                        x = it.positionInWindow().x + it.size.width / 2,  <br/>                        y = it.positionInWindow().y + it.size.height / 2  <br/>     )  <br/>                }  <br/>                .size(110.dp)  <br/>                .border(  <br/>                    4.dp,  <br/>                    color = if (isSelected) theme.primaryColor else Color.Transparent,  <br/>                    shape = CircleShape  <br/>    )  <br/>                .padding(8.dp)  <br/>                .background(color = theme.primaryColor, shape = CircleShape)  <br/>                .clip(CircleShape)  <br/>                .clickable {  <br/>                    onClick(offset)  <br/>                }  <br/>        ) {  <br/>            Image(  <br/>                modifier = Modifier.fillMaxSize(),  <br/>                painter = painterResource(id = theme.image),  <br/>                contentDescription = "themeImage",  <br/>                contentScale = ContentScale.Crop,  <br/>            )  <br/>        }  <br/>  <br/>        Text(  <br/>            text = text.uppercase(),  <br/>            modifier = Modifier  <br/>                .alpha(if (isSelected) 1f else .5f)  <br/>                .padding(2.dp),  <br/>            color = currentTheme.textColor,  <br/>            fontWeight = FontWeight.Bold,  <br/>            fontSize = 20.sp  <br/>        )  <br/>    }  <br/>}</span></pre><p id="b489" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里是<code class="fe ln lo lp lq b">ThemButton</code>的定义。如您所见，单击按钮时会发送按钮的中心偏移量。</p><p id="0ae3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以将它设置为圆显示动画的原点，如下所示:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="24f9" class="lv lw iq lq b gy lx ly l lz ma">ThemeButton(  <br/>    ...  <br/>) {  <br/>    animationOffset = it  <br/>    theme = lightTheme  <br/>}  <br/>  <br/>ThemeButton(  <br/>    ...<br/>) {  <br/>    animationOffset = it  <br/>    theme = darkTheme  <br/>}  <br/>  <br/>ThemeButton(  <br/>    ... <br/>) {  <br/>    animationOffset = it  <br/>    theme = pinkTheme  <br/>}</span></pre><p id="8652" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仅此而已。我们现在有一个自定义的主题选择器动画，肯定会让我们的用户高兴。完整的源代码可以在<a class="ae mb" href="https://github.com/sinasamaki/ThemeChooser/tree/master" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="c49f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读，祝你好运！</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="99a3" class="lv lw iq lq b gy lx ly l lz ma"><strong class="lq ir">Want to Connect?</strong></span><span id="f17d" class="lv lw iq lq b gy mc ly l lz ma">Originally published at <a class="ae mb" href="https://sinasamaki.com/post/2022-02-28-theme-picker/" rel="noopener ugc nofollow" target="_blank">https://sinasamaki.com</a>.</span></pre></div></div>    
</body>
</html>