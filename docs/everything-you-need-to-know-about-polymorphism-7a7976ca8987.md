# 关于多态性你需要知道的一切

> 原文：<https://betterprogramming.pub/everything-you-need-to-know-about-polymorphism-7a7976ca8987>

## 多元主义的用途和好处

![](img/0f38508eda00b68fe27ccb18fd1071b3.png)

在 [Unsplash](https://unsplash.com/s/photos/shapes?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由 [Delila Ziebart](https://unsplash.com/@delilaziebart?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

在这篇文章中，我们将看看你需要知道的关于多态性的一切。这个名字可能会让你觉得它很难，但事实上，多态性很容易理解。

多态确实需要对继承的理解，这篇文章的代码样本是用 C++写的，所以如果你不确定什么是继承，那么等你熟悉了之后再回来阅读这篇文章。

对于那些听说过这个概念但需要复习的人，我将在进入多态之前提供一个快速回顾。

# 快速夺回遗产

继承是一个允许我们通过 is-a 关系重用代码的概念。我们有一个类`Soldier`，它有特定的行为和状态。它可能有健康、耐力和行为，如行走、逃跑和射击。一个类可以从基类`Soldier`继承这些行为，同时也包含自己的行为。我们可以拥有一个继承自`Soldier`的`JetpackSoldier`类。`JetpackSoldier`能做`Soldier`能做的一切，除了有自己的行为，比如会飞。

可以覆盖基类中定义的行为。例如，如果我们希望一个 jetpack 士兵从玩家身边飞走，而不是像一个普通士兵那样逃跑，我们可以通过重写 jetpack soldier 类中的 fly 方法来实现这一点。

如果这仍然没有多大意义，在继续本文之前，您可能需要对继承进行更多的研究。慢慢来；你回来的时候这篇文章还会在这里。

# 什么是多态性？

多态性描述了有多种形式的事物。在计算机科学中，这指的是具有多种形式的功能和对象。

## 功能多态性

使用**重载**实现函数多态性。重载允许函数共享相同的名称，同时传入不同的类型和/或不同数量的参数。一个函数有多种形式。

例如，考虑一个对两个数求和的函数。我们可以有一个接受两个整数并返回一个 int 的 sum 函数，以及另一个接受两个 float 作为参数并返回一个 float 的 sum 函数。当我们调用 sum 传递两个数字时，编译器会根据我们传递的参数计算出实际需要调用哪个方法。在这两种情况下，当调用共享相同名称的方法时，根据我们传递的参数，我们可以获得不同的行为。

## 对象多态性

关于对象的多态性略有不同。这就是继承发挥作用的地方。对于任何有基类的对象，比如我们的`JetpackSoldier`类，它的基类是`Soldier`，我们可以把它当作一个`Soldier`。任何处理与`Soldier`对象相关的代码也可以处理`JetpackSoldier`对象。有一个例子可以很好地说明这些好处:

如果我们假设我们的游戏中有车辆，并且我们有一个`Jeep`类，我们希望在这个类中存储一个对驾驶这辆车的士兵的引用。假设我们的 jeep 最多存储四个人；我们如何在代码中做到这一点？多态很容易处理这个问题。

处理这个问题的一个简单方法是为吉普车中的每个座位引用`Soldier`，两个在前，两个在后。因为多态性使我们能够将对象视为其他对象，将`JetpackSoldier`视为`Soldier`，所以我们可以将`JetpackSoldier`和`Soldier`对象都添加到`Jeep`类中。如果我们在游戏中加入更多的士兵，只要他们继承了`Soldier`的血统，他们也可以被加入到吉普职业中。

继续前面的例子，如果我们想要存储不同的士兵类型，我们必须添加额外的成员变量和方法来支持它。我们还需要更多的检查才能把一个士兵放进吉普车。

正如你可能已经猜到的，随着我们的游戏变得越来越复杂，我们有许多`Soldier`的变体，当我们试图支持所有不同的士兵进入车辆时，`Jeep`职业将变得越来越复杂。

# 多态性的好处

从上一节中，我们可以看到多态性的一个优点是它允许我们重用现有的代码，这可以使事情更容易阅读和维护。

然而，另一个我们只简单提到的大优势是，多态允许我们“通过一个公共接口与一组不同的类交互来隐藏实现细节。”这意味着我们可以拥有一个与许多对象交互的类，这些对象通过这些对象共享的方法继承自同一个基类。共享的方法被称为接口。

更好的是，仅仅因为我们在所有的`Soldier`对象上调用相同的方法，并不意味着它们都做相同的事情。回想一下，当对类型为`JetpackSoldier`的对象调用 escape 时，它们将通过飞走而不是奔跑来逃离，因为它们覆盖了基类 Soldier 中的方法。

使用共享接口与对象交互的好处是我们已经讨论过的所有事情，同时也限制了我们的类之间的耦合量。耦合是指我们的代码可以紧密地链接在一起，这使得在不破坏内容的情况下很难进行更改。如果我们在游戏中增加了额外的士兵，只要士兵类型共享相同的界面，我们的指挥官职业就不需要改变。

注意:如果我们增加或减少接口，依赖于该接口的类如 SquadCommander 需要改变，要么适应新的行为，要么删除不再需要的行为。重要的是，我们可以添加额外的士兵类型，而不必改变任何东西。

# 多态性和性能

然而，尽管多态性如此美妙，但也有一个缺点，那就是它对性能的潜在影响。

到目前为止，我们已经讨论了多态如何允许我们通过一个接口调用所有从某个基类继承的对象，同时还允许我们调用特定于该类的方法。如果我们在类型为`Soldier`的变量中存储了一个`JetpackSolider`类，并调用`Flee()`，士兵仍然会飞走而不是逃跑，即使它被存储为`Soldier`。

允许这种行为的同样的事情也会导致我们代码的性能问题。

我不会详细讨论多态在 C++中是如何实现的。我在这篇文章的底部留下了几个链接，如果有人感兴趣，可以很好地解释。

对于我们的目的，您需要知道的是多态行为在 C++中是通过使用一种叫做虚拟表的东西来实现的。虚拟表是一个数组，它存储一个类的所有虚函数的地址。当对虚拟函数进行调用时，代码必须导航到虚拟表，查找要调用的函数，然后转到地址并调用该函数。对于一个普通的非虚函数，我们只需访问函数的地址。在计算机已经在做大量工作的某些情况下，这些额外的步骤会降低速度。

当我说在某些情况下，我的意思是在某些情况下。一般来说，使用多态性可能引起的性能问题不会引起关注。但我认为这是值得一提的；为了完全理解多态性，理解任何优点和缺点是很重要的。为了性能而失去对象多态性带来的灵活性是不值得的，除非你知道这会引起问题。最好拥抱多态性，只有当它成为问题时才考虑移除它。这是通过剖析表现出来的，而不仅仅是通过思考

# 摘要

多态性本来就好。它指的是有多种形式的东西，既指对象，也指方法。多态性允许您对接口进行编码，减少耦合，增加可重用性，并使您的代码更容易阅读。在某些情况下，使用多态性可能会降低性能，但这并不意味着我们应该避免它。

# 进一步阅读

*   [https://en . Wikipedia . org/wiki/Polymorphism _(computer _ science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
*   [https://www . ians wer 4u . com/2017/09/oops-polymorphism-advantages . html](https://www.ianswer4u.com/2017/09/oops-polymorphism-advantages.html)
*   【https://en.wikipedia.org/wiki/Virtual_method_table 
*   [https://www . learn CPP . com/CPP-tutorial/125-the-virtual-table/](https://www.learncpp.com/cpp-tutorial/125-the-virtual-table/)