# C# 10 中有什么新内容？

> 原文：<https://betterprogramming.pub/upcoming-features-in-c-10-f4471203dacc>

## 文件范围的命名空间、记录结构等等

![](img/2abaeeb7d2eb0dc890c961d90ba53870.png)

[Bermix 工作室](https://unsplash.com/@bermixstudio?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

十多年前，C#是一种 Windows 编程语言。你用它在你的 Windows 机器上制作“Windowsey”的东西。自从微软[决定开源。NET 2014 年](https://devblogs.microsoft.com/dotnet/net-core-is-open-source/)，该语言及其生态系统已经走过了漫长的道路。

今天，C#是一种非常适合几乎任何软件项目的语言，从半低级代码到成熟的 Web 应用程序。NET 生态系统是全世界许多开发人员的首选。

C# 的前一版本带来了几个主要的新特性，但是与诸如 Go，甚至 TypeScript 这样的语言相比，C#仍然有点冗长。

虽然运行一个最小的 Hello World 程序所需的代码量在过去已经减少了，但是任何真实世界的程序仍然包含大量的 using 指令、命名空间声明和编译器所需的其他程序。

在 C# 10 即将发布的版本中，语言团队希望减少所需的强制仪式代码的数量。虽然与 C# 9 相比，这一次这些特性可能看起来不那么重要，但它们为语言引入了一些急需的简洁。

如果你觉得这篇文章很有趣，并且想跟踪这种语言的发展，它的提议，草案，规范和所有关于 C#的东西，请前往[CSharpLang 库](https://github.com/dotnet/csharplang/tree/main/proposals)。它包含了所有的细节。

在我们深入研究这些特性之前，请记住，这些都不是最终结果。这里的一些特性甚至被认为可以进入 C# 9，但是最终没有通过。在这篇文章和 C# 10 的实际发布之间，事情可能会发生变化。

现在，说点好的。

# 全局使用指令

每一个 C#源文件都以同样古老的仪式开始:使用指令。它们告诉编译器应该在哪里寻找代码中使用的类型。

使用指令有两个问题:它们非常重复，并且大多是自动管理的，要么通过 IntelliSense，要么通过第三方扩展。

这是我几天前写的一段代码，包含了一个非常简单的 100 SLOC 程序的用法:

前六种极为常见。如果我不得不尝试一下，我使用的大约 90%的源文件都会用到它们。其他一些在我的应用程序中很常见。一定有更好的方法。

从 C# 10 开始，这些可以用全局 using 指令来表示:

这些命名空间随后会在项目的每个源文件中使用。这允许您将源文件中的 using 指令缩小到特定于该段代码的指令，以及在全局名称空间不适合该单独的源文件时的类型别名。

有趣的是，编译器会自动选取这些全局 using 指令。不像 C++的头文件系统，它需要一个 include:`#include <Precompiled.hpp>`——这样 C#优雅地避免了命名空间和头文件的常见问题，比如循环包含。

# 文件范围的命名空间

C#的另一个产物是名称空间声明。与 C++不同，为类型声明命名空间是强制性的。这意味着每个文件都从两级缩进开始:一级用于命名空间，另一级用于类型定义:

类似于以前版本中对`using`语句的处理，C# 10 允许您放弃缩进，只为每个文件声明一个名称空间:

没什么大不了的，编译后的代码看起来完全一样，使用文件范围的名称空间完全是可选的；您之前的所有代码仍然可以很好地编译。虽然我已经习惯了 C#类的形式，但是消除语言中不必要的缩进是一件好事。

# 记录和构建改进

在下一个版本的 C#中，`record`和`struct`类型都有很多变化和改进。因为这些是高度相关的(就像，其中一些不能没有其他的存在)，我将在这一节中对它们进行总结。

## 记录结构

在以前的 C#版本中，`record`介绍了类型。记录是具有引用类型行为的类型，但是是值类型比较。简单地说，这意味着它们仍然在堆上分配，但是相等性是由它们的值决定的，而不是由引用决定的。

从设计角度来看，`record`类型通常用于表示成员，其值代表特定时间点的对象。因此，与常规类相反，记录的值不会被更新——相反，记录的新副本是用更新后的值创建的。

这是通过使用`with`关键字完成的，例如:

```
var e = someEvent with { CorrelationId = Guid.NewGuid(); }
```

这将创建记录的副本，并设置更新后的`CorrelationId`属性。原始记录保持不变。

有时，拥有这些“随时间变化”的语义是可取的，但拥有引用类型语义是不可取的——例如，如果您的记录只包装值类型。为了填补这一空白，`record struct`将在 C# 10 中得到支持，为您带来两全其美。

## 无参数结构构造函数

为了给`record struct`类型铺平道路，在 C# 10 中，`struct`可以包含一个公共的无参数构造函数。这适用于所有结构类型:

*   `struct`
*   `record struct`
*   `ref struct`
*   `readonly struct`

此外，也可以为结构指定字段初始值设定项。任何没有被构造函数显式设置的字段都将被初始化为默认值。任何没有初始值设定项的值都将被归零。

没什么太刺激的。

# 通用属性

引进于。NET 2.0 中，现代代码中经常使用属性来修饰属性或类型，以便为这些成员提供元数据。您可能熟悉的一个属性是在`Newtonsoft.Json`和`System.Text`中都可以找到的`JsonConverterAttribute`。它用于指示属性和类型的自定义序列化行为。

考虑以下转换器，[由提供。网络文档](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-5-0):

目前，如果您想将这个转换器应用到您的类中的一个属性，您必须按照以下方式做一些事情:

这并不理想。主要是因为被传递的类型是不受约束的——你可以传递一个有效的转换器，但也可能只是`typeof(string)`。

这导致代码的总体可设计性差，因为属性的作者不能有意义地约束被传递的类型。使用静态代码分析检测该错误是有问题的。

因为阻止实现`Attribute`类型的运行时限制随着。NET 核心运行时，属性在技术上可以是泛型的。C# 10 将为这一特性带来语言支持。

这意味着在 C# 10 中，上面的例子可以表示为:

当传递一个不是真正的`JsonConverter`类型时，提供编译时错误，并产生稍微简洁的代码。

# 荣誉奖

有一堆更小的改进和优化，并没有真正保证他们自己的一节。

不过，把它们排除在外是不对的，所以在这里它们没有特定的顺序:

## 常量插值字符串

在 C#中，任何`const`值都必须是编译时常数。对于字符串，这意味着它们必须是文字字符串，即`string.Format`和插值字符串是不可能的——即使格式化或插值字符串中的所有成分都是常数！

考虑以下字符串:

```
const string Foo = $"Foo";
```

目前，该语言不允许将该表达式用作`const`值。在 C# 10 中，这个限制被取消了，只要一个字符串的所有组成部分在编译时都是可解析的，插值后的字符串就可以用作`const`值。

这意味着在 C# 10 中，以下代码可以编译:

```
public class C
{
    const string S1 = "Hello world";
    const string S2 = "Hello" + " " + "World";
    const string S3 = S1 + " Kevin, welcome to the team!";
}
```

## 解构赋值和声明

当使用解构时，你可以赋值或者声明你要解构的变量。这意味着这两种解构目前都可以编译:

```
// Assign variables through deconstruction
int x = 0;
int y = 0;
(x, y) = point;// Declare variables through deconstruction
(int x, int y) = point;
```

但是，不允许将它们混合使用。如果其中一个变量之前已经在代码中声明过，而另一个变量是通过解构获得的，这可能会有问题。

这个限制在 C# 10 中被取消了，允许你在解构时混合声明和赋值:

```
int x = 10;
(x, int y) = point;
```

你知道，万一你遇到了这个非常特殊的问题。

# 结论

C# 9 引入了许多新特性，而 C# 10 即将发布的版本看起来更像是一个维护版本。详细阐述前面介绍的功能，同时主要关注减少代码中的强制噪声。

那很好。在过去的几年里，C#作为一种语言一直在快速发展。在过去的几个主要版本中，趋势是每个主要特性版本都被一个主要关注改进的版本所替代。这次发布的肯定是后者。

本文中列出的特性并不是决定性的。正如本文开头所提到的，C# 10 的组成仍然在不断变化。我主要关注那些或多或少能保证成功的特性。如果有更多的补充，我会更新文章。

感谢阅读！