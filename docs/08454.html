<html>
<head>
<title>TypeScript: A Gentle Introduction to Mapped Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:映射类型的简明介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598?source=collection_archive---------4-----------------------#2021-05-03">https://betterprogramming.pub/typescript-a-gentle-introduction-to-mapped-types-f65e45fa2598?source=collection_archive---------4-----------------------#2021-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习构建自己的一套TypeScript工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e835c0262218bf14c3320c47adeaaea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p5BopZE16sB1vFJu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="8023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射类型是TypeScript语言中迄今为止最好的特性。它们允许您基于现有类型和您定义的一些规则创建新的类型。这确实会产生可读性和声明性更强的代码库。</p><p id="cb40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持代码干燥是您应该遵循的原则之一，映射类型可以帮助您做到这一点。你会发现有大量的样板文件减少。您必须编写更少的代码，因为您可以重用更多的代码。</p><p id="8682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，映射类型是一个有点可怕的特性。尤其是有知识差距的情况下。因此，在直接进入之前，我们将重温一些关键特性，它们是映射类型的基础。</p><p id="6f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望通过缩小知识差距，它将看起来不那么势不可挡。当学习新功能时，我认为循序渐进是成功的关键。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2663" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建类型的5个关键TypeScript功能</h1><h2 id="3cec" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated"><strong class="ak"> <em class="ng"> 1。操作员</em>的按键</strong></h2><p id="a83c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><code class="fe nm nn no np b">keyof</code>是非常重要的工具。它允许您以联合格式获取所有类型属性。让我们检查一下文档:</p><blockquote class="nq"><p id="7b29" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">"<code class="fe nm nn no np b">keyof</code>操作符接受一个对象类型，并产生其键的字符串或数字联合."— <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html" rel="noopener ugc nofollow" target="_blank">打字稿文件</a></p></blockquote><p id="7029" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">让我们来看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们已经将所有的<code class="fe nm nn no np b">Person</code>键提取为<code class="fe nm nn no np b">PersonKeys</code>类型。</p><h2 id="beb8" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">2.访问TypeScript类型/接口变量</h2><p id="0712" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">众所周知，您可以使用一种非常熟悉的JavaScript语法来访问类型属性:方括号。这在以后会非常重要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你知道了语法，使用起来就会变得非常简单和直观。</p><p id="3b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有没有一种方法可以迭代类型/接口属性？是的，这是来自JavaScript世界的非常熟悉的语法:</p><pre class="kj kk kl km gt oh np oi oj aw ok bi"><span id="1405" class="mu md it np b gy ol om l on oo">[P in keyof T]: T[P]</span></pre><p id="0352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以结合之前看到的<code class="fe nm nn no np b">keyof</code>来首先提取所有的属性，然后使用<code class="fe nm nn no np b">in</code>来遍历每个属性。</p><h2 id="c830" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">3.条件打字</h2><p id="e422" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">什么是条件类型？它只是一个表达式，用于根据表示为类型关系的条件从两个可能的类型中选择一个。</p><pre class="kj kk kl km gt oh np oi oj aw ok bi"><span id="c4a8" class="mu md it np b gy ol om l on oo">T extends U ? X : Y</span></pre><p id="d67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个虚拟的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe nm nn no np b">ConditionalType</code>将等于<code class="fe nm nn no np b">boolean</code>，因为条件<code class="fe nm nn no np b">string extends boolean</code>为假。</p><h2 id="b001" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">4.never和infer关键字</h2><p id="bd60" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">使用<code class="fe nm nn no np b">infer</code>关键字就像告诉Typescript，“我想把你推断在这个位置的任何东西赋值给一个新的类型变量。”</p><p id="2194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe nm nn no np b">never</code>类型表示从不出现的值的类型。</p><p id="7415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="aa3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，随着<code class="fe nm nn no np b">array</code>扩展<code class="fe nm nn no np b">infer U[]</code>，变量<code class="fe nm nn no np b">X</code>将等于一个<code class="fe nm nn no np b">Number</code>。如果目标不是一个数组，它将等于<code class="fe nm nn no np b">never</code>。</p><h2 id="2048" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">5.无商标消费品</h2><p id="e082" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">让我们的方法/API可重用的最好方法是什么？仿制药！这是大多数类型化语言中的一个特性。它让我们以更通用的方式表达类型。这将增强我们的类和类型。</p><p id="451c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说一个基本的例子。让我们创建一个向数组添加任何已定义类型的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="93d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想为一个<code class="fe nm nn no np b">int</code>类型创建相同的实用程序呢？要不要重做同样的方法？通过简单地使用泛型，我们可以重用代码，而不是添加更多的样板文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="932a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们通过强制扩展<code class="fe nm nn no np b">boolean</code>或<code class="fe nm nn no np b">string</code>来限制<code class="fe nm nn no np b">T</code>的类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7db3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">TypeScript实用程序如何在幕后工作</h1><p id="e1e2" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">既然我们已经获得了重要的Typescript知识，我们就可以开始学习映射类型了。不过，在创建我们自己的实用程序之前，让我们看看已经内置了什么。</p><p id="c5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript附带了许多作为实用工具的映射类型。我们来看一些最常见的:<code class="fe nm nn no np b">Omit</code>、<code class="fe nm nn no np b">Partial</code>、<code class="fe nm nn no np b">Readonly</code>、<code class="fe nm nn no np b">Readonly</code>、<code class="fe nm nn no np b">Exclude</code>、<code class="fe nm nn no np b">Extract</code>、<code class="fe nm nn no np b">NonNullable</code>、<code class="fe nm nn no np b">ReturnType</code>。您可以在任何时候通过将鼠标悬停在有能力的编辑器或TypeScript运动场中的它们上来检查它们。</p><p id="a707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将检查它们是如何构建的，以获得更多关于如何在未来构建我们自己的系统的见解和想法。</p><h2 id="b7a5" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated"><strong class="ak"> 1。部分映射类型</strong></h2><p id="7be0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这是一个映射类型，它通过使用一个<code class="fe nm nn no np b">undefined</code>联合将您的类型属性转换为可选的，并使您的类型可为空。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/836ffe7a1a26cb928acf03d0aab403ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mg655JGL5bbV-8GETRM7Gg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查看Typescript映射类型实现的示例</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是如何工作的？</p><ul class=""><li id="a3cf" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated">它使用一个泛型来传递目标接口<code class="fe nm nn no np b">T</code>。</li><li id="bb9d" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">它使用<code class="fe nm nn no np b">keyof T</code>获得<code class="fe nm nn no np b">T</code>的所有密钥。</li><li id="9afe" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">它通过使用<code class="fe nm nn no np b">[P in ...</code>访问并循环所有拉出的键。</li><li id="42f2" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">它通过添加<code class="fe nm nn no np b">?</code>符号使按键可选。</li><li id="17bd" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">它通过使用联合<code class="fe nm nn no np b">T[P] | undefined</code>使键类型可为空。</li></ul><p id="11cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经介绍了所有的基础知识，看起来就更容易理解了。现在很容易弄清楚任何映射类型的幕后发生了什么。</p><h2 id="c728" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated"><strong class="ak"> 2。排除映射类型</strong></h2><p id="8e54" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这是一种映射类型，允许您有选择地从类型中移除属性。定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是如何工作的？</p><ul class=""><li id="88f4" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated">它从<code class="fe nm nn no np b">T</code>中排除了那些通过使用条件类型化并在被排除的属性上返回<code class="fe nm nn no np b">never</code>可分配给<code class="fe nm nn no np b">U</code>的类型。这怎么可能呢？条件类型的分配性使得它。</li></ul><blockquote class="nq"><p id="484d" class="nr ns it bd nt nu pe pf pg ph pi lu dk translated">被检查类型为裸类型参数的条件类型被称为<em class="ng">分布式条件类型</em>。分布式条件类型在实例化期间自动分布在联合类型上— <a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener ugc nofollow" target="_blank">类型脚本文档</a></p></blockquote><figure class="pj pk pl pm pn kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a8a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以观察到上面我们是如何通过使用<code class="fe nm nn no np b">Exclude</code>将<code class="fe nm nn no np b">crocodile</code>从联管节中移除的。</p><p id="ebd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备开始构建我们自己的映射类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="607a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建您自己的TypeScript映射类型</h1><p id="9199" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们现在准备构建我们自己的TypeScript映射类型。假设我们想要创建一个映射类型，它只使我们选择的<code class="fe nm nn no np b">keys</code>成为可选的——不像<code class="fe nm nn no np b">Partial</code>，它使所有的键都是可选的和可空的。</p><p id="e566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">Partial</code>映射类型本身可以作为我们的起点。我们能做的是:</p><ul class=""><li id="76c9" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated">将整个类型转换为<code class="fe nm nn no np b">Partial</code>。</li><li id="049d" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">从新类型中只选择我们希望成为可选的属性。</li><li id="ba06" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">用排除的属性联接原始类型。</li></ul><p id="207c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们使用<code class="fe nm nn no np b">K extends keyof T</code>来确保我们只传递属于类型/接口的属性。否则，TypeScript将在编译时引发错误。</p><p id="fc9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射类型的一个优点是它们的可组合性:您可以组合它们来创建新的映射类型。这有多酷，多有用？</p><p id="2eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他方法可以实现这种行为。您可以决定不使用任何映射类型实用程序，全部手动完成。这感觉有点像重新发明轮子，但可以为了好玩而做。让我们在不使用任何其他映射类型的情况下重新创建<code class="fe nm nn no np b">Optional</code>映射类型实用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="fd8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码只是结合了两种类型:</p><ul class=""><li id="c871" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated">第一种类型通过使用<code class="fe nm nn no np b">?</code>修改器使<code class="fe nm nn no np b">T</code>的所有<code class="fe nm nn no np b">K</code>键可选。</li><li id="db34" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated">通过使用<code class="fe nm nn no np b">Excluse&lt;keyof T,K&gt;</code>，第二种类型是获取剩余的密钥。</li></ul><p id="d66c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个例子不实用，可读性差。这只是为了证明你可以用映射类型完成任何事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="346e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="2185" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这就是你对映射类型所能做的一切吗？当然不是。这只是一个介绍，让你开始和好奇。您可以做各种新奇的事情，有了最新的TypeScript版本，您现在可以递归地使用它们。另一个很棒的新特性是能够重命名属性。查看我下面关于4.1版本的相关文章，了解更多信息。</p><p id="483b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射类型是一个很棒的工具，但是它们需要一些关于TypeScript特性的知识。如果这是你首先想到的，它可能是一个压倒性的特征。然而，随着时间和耐心，它们将成为你日常发展中不可或缺的工具。</p><p id="6b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将能够为您的特定需求构建一些特定的工具。你可以在以后使用它们，像乐高积木一样组合它们。</p><p id="1548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保在全局<code class="fe nm nn no np b">tsd.d.ts</code>中定义这些映射类型，这样它们就可以在整个代码库中使用，而不需要任何导入/导出。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aedd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">有关系的</h1><div class="po pp gp gr pq pr"><a rel="noopener  ugc nofollow" target="_blank" href="/typescript-4-1s-advanced-mapped-types-eba9a2ba7a9"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">TypeScript 4.1的高级映射类型</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">看看递归条件类型、模板文字类型等等</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">better编程. pub</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf ks pr"/></div></div></a></div><div class="po pp gp gr pq pr"><a rel="noopener  ugc nofollow" target="_blank" href="/top-5-typescript-features-you-should-master-2358db9ab3d5"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">您应该掌握的五大打字稿功能</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">使用这些必须知道的特性来提高您的打字稿知识</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">better编程. pub</p></div></div><div class="qa l"><div class="qg l qc qd qe qa qf ks pr"/></div></div></a></div><div class="po pp gp gr pq pr"><a rel="noopener  ugc nofollow" target="_blank" href="/master-typescripts-type-guards-1fd5436bc6f2"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">Master TypeScript的类型保护</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">在TypeScript的type guards中从初学者到专业人员</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">better编程. pub</p></div></div><div class="qa l"><div class="qh l qc qd qe qa qf ks pr"/></div></div></a></div></div></div>    
</body>
</html>