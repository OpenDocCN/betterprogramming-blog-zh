<html>
<head>
<title>An Introduction to Web Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络工作者简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-web-workers-6ba4385e983e?source=collection_archive---------15-----------------------#2020-02-13">https://betterprogramming.pub/introduction-to-web-workers-6ba4385e983e?source=collection_archive---------15-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91cc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">怎样才能在后台运行长时间运行的任务而不影响性能？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc6c1af2cc58e97a1cdf166e7241989a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GADYHpW3H3UKKuaoGNRbIQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@thematthoward?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马特·霍华德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/long?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="487c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行需要很长时间才能完成的任务，我们需要一种在后台运行它们的方法。</p><p id="6d93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络工作者是实现这一目标的途径。它们存在于浏览器中自己的上下文中。因此，它们没有访问DOM的权限，只有自己的全局变量<code class="fe lv lw lx ly b">self</code>。</p><p id="e655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">web worker不能访问<code class="fe lv lw lx ly b">window</code>对象，但是我们仍然使用许多属于它的东西，比如<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank"> WebSockets </a>和<a class="ae ky" href="https://developer.mozilla.org/en/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB </a>。</p><p id="015c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何创建一个基本的web worker，它可以在worker和其他脚本之间发送消息。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d206" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">网络工作者的特征</h1><p id="d032" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">网络工作者允许我们在他们和其他脚本之间发送消息。非工作脚本可以通过附加消息处理程序来侦听工作脚本发出的消息。</p><p id="e28a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要发送消息，我们使用<code class="fe lv lw lx ly b">postMessage()</code>方法。可以通过<code class="fe lv lw lx ly b">Message</code>事件的数据属性访问该消息。<code class="fe lv lw lx ly b">Message</code>事件对象被传递到<code class="fe lv lw lx ly b">onmessage</code>处理程序的事件处理程序中。</p><p id="9b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作线程可以产生新的工作线程，只要它们与父页面驻留在同一原点。工作者也可以使用<code class="fe lv lw lx ly b">XmlHttpRequest</code>进行网络I.O，除了<code class="fe lv lw lx ly b">XMLHttpRequest</code>上的<code class="fe lv lw lx ly b">responseXML</code>和<code class="fe lv lw lx ly b">channel</code>属性总是返回<code class="fe lv lw lx ly b">null</code>。</p><p id="4e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了敬业的员工，还有其他类型的员工:</p><ul class=""><li id="9a9c" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">共享工作者是可以被不同窗口、IFrames等中的多个脚本使用的工作者，只要它们与工作者在同一个域中。它们比专用工作器更复杂，因为脚本必须通过活动端口进行通信。</li><li id="232f" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">服务工作者充当web应用程序、浏览器和网络之间的代理服务。它们旨在创造有效的离线体验。它们拦截网络请求，并根据网络是否可用采取适当的行动。</li><li id="5028" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">Chrome workers是一种Firefox专用的worker类型，我们可以在开发附加组件时使用，并希望在扩展中使用worker。</li><li id="fa82" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">音频工作者提供了在web工作者上下文中指导脚本化音频处理的能力。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/9d236a6dc9340940bcfefaa397ccb551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uuQ96y4xtIRKl2Oz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dsiglin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·西格林</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7031" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建一个简单的专用工人</h1><p id="415f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以通过创建一个简单的worker脚本来创建一个专用的worker，然后让其他脚本与之通信。</p><p id="3004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以创建一个专门的worker，它从两个输入中获取值，然后通过将它们相加并将其发送回屏幕来计算结果。</p><p id="9add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们创建HTML来获取输入值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe lv lw lx ly b">main.js</code>中，我们将<code class="fe lv lw lx ly b">keyup</code>事件处理程序添加到输入中，以将值发送给我们的专用工作器，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="25c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还添加了<code class="fe lv lw lx ly b">onmessage</code>事件处理程序来接收来自worker的消息，在下面的代码中，我们将把它添加到<code class="fe lv lw lx ly b">worker.js</code>中来从它那里获取消息:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="705e" class="ny mh it ly b gy nz oa l ob oc">worker.onmessage = e =&gt; {<br/>  result.textContent = e.data;<br/>};</span></pre><p id="b52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在<code class="fe lv lw lx ly b">worker.js</code>中创建工人代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="59e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码从<code class="fe lv lw lx ly b">main.js</code>获取消息，我们在这里调用了<code class="fe lv lw lx ly b">postMessage</code>。我们传递给<code class="fe lv lw lx ly b">postMessage</code>的任何东西都将在<code class="fe lv lw lx ly b">e</code>参数中，我们可以从那里获得数据。</p><p id="294e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在这个文件中，我们在函数的第一行用<code class="fe lv lw lx ly b">data</code>属性得到我们传入的两个数字。</p><p id="7fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们检查两个数字是否都是数字，如果是，我们将它们相加，然后在计算总和并将结果放入<code class="fe lv lw lx ly b">workerResult</code>字符串后，用<code class="fe lv lw lx ly b">postMessage</code>将总和发送回<code class="fe lv lw lx ly b">main.js</code>。</p><p id="7e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们应该会得到如下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2c4c2e7b87705d042e5fc8a5d933a400.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*mz762j6EX2uTzmnrrk1sxg.png"/></div></figure><p id="5c71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要专用的worker脚本与我们的其他脚本在同一个域中，它就会运行。</p><p id="880d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Worker</code>构造函数还接受一个选项对象，该对象包含以下选项:</p><ul class=""><li id="b081" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">type</code>:指定要创建的工作者类型的字符串。该值可以是<code class="fe lv lw lx ly b">classic</code>或<code class="fe lv lw lx ly b">module</code>，默认为<code class="fe lv lw lx ly b">classic</code>。</li><li id="1285" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">credentials</code>:指定工作者使用的凭证类型的字符串。该值可以是<code class="fe lv lw lx ly b">omit</code>(不需要凭证)、<code class="fe lv lw lx ly b">same-origin</code>或<code class="fe lv lw lx ly b">include</code>。如果没有指定，<code class="fe lv lw lx ly b">type</code>为<code class="fe lv lw lx ly b">class</code>，则默认为<code class="fe lv lw lx ly b">omit</code>。</li><li id="f296" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">name</code>:指定<code class="fe lv lw lx ly b">DedicatedWorkerGlobalScope</code>的标识名的字符串，代表工作器的范围。主要用于调试。</li></ul><p id="6b99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不允许启动workers，比如URL无效或者违反了同源策略，构造函数将抛出一个<code class="fe lv lw lx ly b">SecurityError</code>。</p><ul class=""><li id="cf64" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">如果工作脚本的MIME类型不正确，将引发<code class="fe lv lw lx ly b">NetworkError</code>。</li><li id="6c6f" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">SyntaxError</code>引发的是工作者的URL无法解析。</li></ul><p id="f21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">培养敬业的员工很简单。他们让我们运行后台任务。workers和其他脚本之间的通信是通过来回发送消息来实现的。</p><p id="bb5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web工作者有他们自己的上下文，所以他们不能使用<code class="fe lv lw lx ly b">window</code>对象或访问DOM。</p></div></div>    
</body>
</html>