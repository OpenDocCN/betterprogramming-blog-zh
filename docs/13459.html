<html>
<head>
<title>Getting Started With Testing Types in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始在TypeScript中测试类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-testing-types-in-typescript-f64306ec16b?source=collection_archive---------11-----------------------#2022-08-29">https://betterprogramming.pub/getting-started-testing-types-in-typescript-f64306ec16b?source=collection_archive---------11-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a46a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于在TypeScript中测试高级类型(如泛型或条件类型)的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/24831e3f2c5b032df49c301ebc9fa117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zaVQgYpZO5yUjkR_uZflQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/DuHKoV44prg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5e77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你开始编写更高级的类型，比如G <a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>或<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">条件类型</a>在<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>中，那么检查你的类型是否如你所愿，这应该成为关键的一步。测试类型与编写普通的单元测试有一点不同，因为我们测试的是未经测试的代码。</p><p id="dc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试类型有三个主要选项:使用类似<a class="ae kv" href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint" rel="noopener ugc nofollow" target="_blank"> dtslint </a>、<a class="ae kv" href="https://github.com/SamVerschueren/tsd" rel="noopener ugc nofollow" target="_blank"> tsd </a>的工具，或者使用<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#-ts-expect-error-comments" rel="noopener ugc nofollow" target="_blank"> @ts-expect-error </a>注释。我将介绍<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#-ts-expect-error-comments" rel="noopener ugc nofollow" target="_blank"> @ts-expect-erro </a> r，因为这是最简单的入门方式，并且不需要额外的工具。</p><p id="3576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用两个注释<code class="fe ls lt lu lv b"><a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#-ts-expect-error-comments" rel="noopener ugc nofollow" target="_blank">@ts-expect-error</a></code>和<code class="fe ls lt lu lv b">@ts-expect-no-error</code>。<br/> @ts-expect-no-error纯粹是描述性的，因为它除了表明我们期望下一行<strong class="ky ir">而不是</strong>抛出错误之外没有其他功能。</p><p id="d385" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中的所有代码都可以在这里找到:【https://github.com/nic-jennings/testing-types-in-typescript T21】</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4518" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">测试拨片<type keys=""/></h1><p id="a984" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">让我们从测试内置类型<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys" rel="noopener ugc nofollow" target="_blank">开始，选择&lt;类型，选择&gt;键</a>。如果我们创建这个类型，我们会希望确保它返回我们选择的类型，或者当原始类型上不存在键时，从不返回。</p><p id="a793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用以下类型编写本文中的所有测试:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="8edb" class="ne me iq lv b gy nf ng l nh ni">type MainObject = {<br/>   id: string;<br/>   name: string;<br/>   nested: {<br/>        id: string;<br/>        name: string;<br/>   };<br/>   nestedArray: MainObject["nested"][];<br/>};</span></pre><p id="a100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试将以下列格式编写:</p><ul class=""><li id="36c4" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">创建一个<code class="fe ls lt lu lv b">let</code>变量，它被约束到我们的类型，并按照预期的结果命名。</li><li id="5e55" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">在<code class="fe ls lt lu lv b">@ts-expect-error</code>或<code class="fe ls lt lu lv b">@ts-expect-no-error</code>下面，给变量赋值以确保我们的类型创建了我们期望的约束。</li></ul><p id="2bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要测试是否有可能基于我们从<code class="fe ls lt lu lv b">MainObject</code>得到的<code class="fe ls lt lu lv b">Pick</code>类型来约束一个变量。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="5904" class="ne me iq lv b gy nf ng l nh ni">let PickSelected: Pick&lt;MainObject, "id"&gt;;</span><span id="56cd" class="ne me iq lv b gy nx ng l nh ni">// @ts-expect-no-error<br/>PickSelected = { id: "someString" };</span><span id="b8e9" class="ne me iq lv b gy nx ng l nh ni">// @ts-expect-error<br/>PickSelected = { name: "someString" };</span></pre><p id="1553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的测试阐明了将一个变量约束到所选择的类型是可能的，但是这又引出了一个问题:它将类型约束到一个对象类型了吗？</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="2f03" class="ne me iq lv b gy nf ng l nh ni">let PickObjectType: Pick&lt;MainObject, "nested"&gt;;<br/>// @ts-expect-no-error<br/>PickObjectType = { <br/>    nested: { id: "someString", name: "something" } <br/>};<br/>// @ts-expect-error<br/>PickNestedObject = { id: "someString" };<br/>// @ts-expect-error<br/>PickObjectType = { nested: { id: "someString"} }</span></pre><p id="b2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以约束一种类型的对象，但它必须匹配整个对象。最后的测试是断言不可能<code class="fe ls lt lu lv b">Pick</code>一个不在我们<code class="fe ls lt lu lv b">MainObject</code>中的项目。一条简单的线证明了这一点:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="da04" class="ne me iq lv b gy nf ng l nh ni">// @ts-expect-error<br/>let PickItemNotInObject: Pick&lt;MainObject, "bla"&gt;;</span></pre><p id="bf78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子演示了一个相当简单的高级类型来测试，但是如果我们有更复杂的东西呢？</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="5a0f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">测试自定义类型</h1><p id="2534" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了使文章的这一部分更加清晰，我想创建一个类型，它允许我创建其他类型的子集，同时显式地只返回两个类型的交集。为了实现这一点，我需要创建两种类型。</p><p id="d17b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ny">请注意:</em> </strong> <em class="ny">此类型为进行中的工作，但以下为当前设置:</em></p><h2 id="faa2" class="ne me iq bd mf nz oa dn mj ob oc dp mn lf od oe mp lj of og mr ln oh oi mt oj bi translated"><strong class="ak">提取按键</strong></h2><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="5267" class="ne me iq lv b gy nf ng l nh ni">/** <br/>* Extract the intersecting Keys from two Objects. <br/>* Right Object is the source of truth. <br/>*/<br/>export type ExtractKeys&lt;T, Obj&gt; = Extract&lt;keyof T, keyof Obj&gt;;</span></pre><h2 id="766b" class="ne me iq bd mf nz oa dn mj ob oc dp mn lf od oe mp lj of og mr ln oh oi mt oj bi translated"><strong class="ak">子集&lt; T，Obj&gt;T22】</strong></h2><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="f970" class="ne me iq lv b gy nf ng l nh ni">/**<br/> * Returns a new Type where Two Objects recursively intersect.<br/> * Right Object is the source of truth.<br/> */<br/>export type SubSet&lt;T, Obj&gt; = ExtractKeys&lt;T, Obj&gt; extends never<br/>  ? never<br/>  : {<br/>      [Key in ExtractKeys&lt;T, Obj&gt;]: Obj[Key] extends object<br/>        ? Obj[Key] extends Array&lt;object&gt;<br/>          ? number extends keyof Obj[Key] &amp; keyof T[Key]<br/>            ? SubSet&lt;T[Key][number], Obj[Key][number]&gt;[]<br/>            : never<br/>          : SubSet&lt;T[Key], Obj[Key]&gt;<br/>        : Obj[Key] | undefined extends T[Key]<br/>        ? Obj[Key] | undefined<br/>        : Obj[Key] extends T[Key]<br/>        ? Obj[Key]<br/>        : never;<br/>    };</span></pre><p id="0288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将需要两个测试，一个是确保<code class="fe ls lt lu lv b">ExtractKeys</code> infact返回两种类型的交叉键，另一个是<code class="fe ls lt lu lv b">SubSet</code>从两种类型的交集创建一个新类型，作为<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>。</p><p id="4f6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ls lt lu lv b">ExtractKeys</code>，我编写了以下测试:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="b3ff" class="ne me iq lv b gy nf ng l nh ni">let NoKeys: ExtractKeys&lt;{}, MainObject&gt;;<br/>// @ts-expect-error<br/>NoKeys = "";</span><span id="5b16" class="ne me iq lv b gy nx ng l nh ni">let MainOnlyKey: ExtractKeys&lt;{ id: string }, MainObject&gt;;<br/>// @ts-expect-no-error<br/>MainOnlyKey = "id";<br/>// @ts-expect-error<br/>MainOnlyKey = "name";</span><span id="d23d" class="ne me iq lv b gy nx ng l nh ni">let KeyNotInMainObject: ExtractKeys&lt;MainObject, MainObject&gt;;<br/>// @ts-expect-no-error<br/>KeyNotInMainObject = "id";<br/>// @ts-expect-error<br/>KeyNotInMainObject = "bla";</span><span id="fbb1" class="ne me iq lv b gy nx ng l nh ni">let RequestedKeyNotInMainObject: ExtractKeys&lt;MainObject &amp; { bla: string }, MainObject&gt;;<br/>// @ts-expect-no-error<br/>RequestedKeyNotInMainObject = "id";<br/>// @ts-expect-error<br/>RequestedKeyNotInMainObject = "bla";</span></pre><p id="29ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我看到我只得到预期的相交键，所以我可以继续测试<code class="fe ls lt lu lv b">SubSet</code>类型测试。</p><p id="2d4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个测试，我创建了下面的对象，它匹配原始类型，因为我发现我在测试中复制了非常相似的代码。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="f36c" class="ne me iq lv b gy nf ng l nh ni">const MainObjectValue: MainObject = {<br/>   id: "bla",<br/>   name: "bla",<br/>   nested: {<br/>     id: "bla",<br/>     name: "bla",<br/>   },<br/>   nestedArray: [<br/>     {<br/>       id: "bla",<br/>       name: "bla",<br/>     },<br/>   ],<br/> };</span></pre><p id="0942" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从下面的测试中，我知道,<code class="fe ls lt lu lv b">SubSet</code>类型返回两个<code class="fe ls lt lu lv b">Types</code>的递归交集，并将变量约束为我们创建的新类型。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="c66c" class="ne me iq lv b gy nf ng l nh ni">/**<br/> * Describe: SubSet<br/> */<br/>let SubSetNoKeys: SubSet&lt;{ bla: unknown }, MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetNoKeys = {};<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetNoKeys = { id: "bla" };</span><span id="1bce" class="ne me iq lv b gy nx ng l nh ni">let SubSetMainOnlyKey: SubSet&lt;{ id: string }, MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>SubSetMainOnlyKey = { id: "bla" };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetMainOnlyKey = { name: "bla" };</span><span id="4fd6" class="ne me iq lv b gy nx ng l nh ni">let SubSetKeyOptional: SubSet&lt;{ id?: string; name: string }, MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>SubSetKeyOptional = { id: "bla", name: "bla" };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>SubSetKeyOptional = { id: undefined, name: "bla" };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetKeyOptional = { name: "bla" };</span><span id="243c" class="ne me iq lv b gy nx ng l nh ni">let SubSetMisMatchType: SubSet&lt;{ id: number }, { id: string }&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetMisMatchType = { id: "bla" };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetMisMatchType = { id: 1 };</span><span id="1427" class="ne me iq lv b gy nx ng l nh ni">let SubSetKeyNotInMainObject: SubSet&lt;MainObject, MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>SubSetKeyNotInMainObject = MainObjectValue;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetKeyNotInMainObject = { id: "bla" };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetKeyNotInMainObject = { bla: "bla" };</span><span id="d06a" class="ne me iq lv b gy nx ng l nh ni">let SubSetRequestedKeyNotInMainObject: SubSet&lt;<br/>  MainObject &amp; { bla: string }, MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>SubSetKeyNotInMainObject = MainObjectValue;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetRequestedKeyNotInMainObject = { id: "bla" };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>SubSetRequestedKeyNotInMainObject = { ...MainObjectValue, bla: "bla" };</span><span id="ad69" class="ne me iq lv b gy nx ng l nh ni">let NestedSubSetKeyInMainObject: SubSet&lt;<br/>  {<br/>    nested: {<br/>      id: string;<br/>    };<br/>  },  MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>NestedSubSetKeyInMainObject = MainObjectValue;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>NestedSubSetKeyInMainObject = { nested: { id: "bla" } };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>NestedSubSetKeyInMainObject = { nested: { name: "bla" } };</span><span id="b0ed" class="ne me iq lv b gy nx ng l nh ni">let NestedSubSetKeyNotInMainObject: SubSet&lt;<br/>  {<br/>    nested: {<br/>      bla: string;<br/>    };<br/>  },<br/>  MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>NestedSubSetKeyNotInMainObject = { nested: null as never };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>NestedSubSetKeyNotInMainObject = MainObjectValue;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>NestedSubSetKeyNotInMainObject = { nested: { id: "bla" } };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>NestedSubSetKeyNotInMainObject = { nested: { name: "bla" } };</span><span id="e970" class="ne me iq lv b gy nx ng l nh ni">let NestedArraySubSetKeyNotInMainObject: SubSet&lt;<br/>  {<br/>    nestedArray: {<br/>      id: string;<br/>    }[];<br/>  },<br/>  MainObject&gt;;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>NestedArraySubSetKeyNotInMainObject = MainObjectValue;<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-no-error<br/>NestedArraySubSetKeyNotInMainObject = { nestedArray: [{ id: "bla" }] };<br/>// <a class="ae kv" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-expect-error<br/>NestedArraySubSetKeyNotInMainObject = { nestedArray: [{ name: "bla" }] };</span></pre><p id="1e56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是重构<code class="fe ls lt lu lv b">SubSet</code>类型的时候，因为我们已经在测试中包装了我们需要的功能，所以我们可以确保当我们进行改进和更改时，我们的类型仍然像预期的那样工作。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7db3" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="fa50" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在我看来，这种测试方式的美妙之处在于它允许你使用TDD(红/绿测试)来编写你的类型。它还将帮助您了解当您开始创建高级类型时实际发生了什么，最后它让其他软件工程师/开发人员清楚您的类型正在做什么，并确保它不会在没有适当的关注和考虑的情况下被功能性地更改。</p><p id="a5cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我个人不建议为简单的类型定义编写类型测试，比如在一个<a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>组件上的参数，但是一旦在读取一个类型时有任何歧义或者认知负荷，那么测试就是至关重要的。</p><p id="0b0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您花时间阅读我的文章。我希望你已经发现它的知识性和趣味性。我将围绕Typescript、Node、React、Vue、GraphQL、Performance、Go等等写更多的文章。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b661" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">其他考虑</h1><p id="e2d2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果你使用的是<a class="ae kv" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> eslint </a>，我相信我们大多数人都是这样，那么你可能需要禁用文件顶部的以下规则:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="fc21" class="ne me iq lv b gy nf ng l nh ni">/* eslint-disable prefer-const */<br/>/* eslint-disable @typescript-eslint/no-unused-vars */<br/>/* eslint-disable @typescript-eslint/ban-ts-comment */</span></pre></div></div>    
</body>
</html>