<html>
<head>
<title>An Example of a Scalable iOS Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个可扩展iOS项目的例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-example-of-a-scalable-ios-project-dce56a256106?source=collection_archive---------4-----------------------#2019-08-16">https://betterprogramming.pub/an-example-of-a-scalable-ios-project-dce56a256106?source=collection_archive---------4-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d927b040aa6749bff89256a90a8fb5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VdV9r78QO0t2ocvScfXDw.jpeg"/></div></div></figure><h2 id="2819" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">可扩展iOS应用架构的组成部分</h2><div class=""/><div class=""><h2 id="0df7" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">DemoApp项目(DAP)和一些最佳实践(第1部分，共2部分)</h2></div><p id="6ab1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在我的文章《<a class="ae ly" href="https://medium.com/@sven.korset/the-perfect-ios-app-architecture-24259417843f" rel="noopener">完美的iOS app架构</a>》中，我介绍了自己的架构，解释了<em class="lz">场景的概念。</em>我已经在一个更复杂的示例项目的基础上解释了架构的各个参与者。</p><p id="8df1" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">本文是关于这个更复杂的示例项目:<a class="ae ly" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank">GitHub上的demo app-Project</a>。我还解释了一些与基于该体系结构的一般项目设置相关的最佳实践，但也有更广泛的适用性。</p><p id="0921" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">顺便说一句，这是一篇来自可扩展的iOS应用架构系列的文章。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="4554" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">下载演示应用程序项目(DAP)</h1><p id="a6a1" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">为了让这篇文章有意义，我强烈推荐把这个项目放在你面前。所以请先从GitHub 下载<a class="ae ly" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目。😉</a></p><p id="e9e2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">该项目通过“DemoApp”文件夹中的“DemoApp.xcworkspace”打开。因为所有必需的pod都已签入，以确保所有依赖项始终可用，所以无需再做什么了。顺便说一下，这已经是我的第一个推荐了:</p><blockquote class="ne"><p id="0e22" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">始终将所有pod和其他依赖项签入存储库。</p></blockquote><p id="aa68" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">pod是项目的依赖项。如果一个依赖项不再存在，例如，因为一个pod项目被删除了，那么您自己的项目就被破坏了。除了豆荚被保存在仓库里。回购中的几兆字节并没有真正推高成本。事实上，<strong class="le jo">全面失败的风险远大于预防的成本</strong>。</p><p id="9f03" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，接下来您应该处理一个pod故障，并迅速寻找替代品，但至少您仍然可以使用当前状态。拥有这种当前状态通常是有用的，因为客户当然想要一个关键的应用程序更新，只需昨天做一个小的文本更改，并且不理解为什么现在要花一周的时间。🙄</p><p id="0185" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在DAP中，我使用<em class="lz"> CocoaPods </em>，因为它简单且普遍。我喜欢简单的！😁</p><p id="4dcb" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当然，你应该经常质疑现状，如果有必要的话，让它适应团队和项目。例如，<a class="ae ly" href="https://jobs.zalando.com/tech/blog/how-the-zalando-ios-app-abandoned-cocoapods-and-reduced-build-time/?gh_src=4n3gxh1" rel="noopener ugc nofollow" target="_blank"> Zalando使用手动解决方案</a>，因为这对他们来说效果更好。我不确定用自己的脚本从头开始创建依赖管理器是否真的更好，但这是每个团队必须自己决定的事情。</p><p id="c1a3" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">总之，正如<a class="nt nu ep" href="https://medium.com/u/c988d69d31ca?source=post_page-----dce56a256106--------------------------------" rel="noopener" target="_blank">诺亚·特鲁平</a>所描述的，Swift 中存在一个“<a class="ae ly" href="https://medium.com/@ntrupin/pods-carthage-and-spm-swifts-package-management-dilemma-7da4ec87a20c" rel="noopener">包管理困境”。然而，随着<em class="lz"> Swift包管理器</em>越来越好地集成到Xcode 11中，这会成为新的<em class="lz"> CocoaPods </em>吗？🤔</a></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="46f7" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">文件夹结构</h1><p id="1785" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">如果你在Xcode中打开项目，你会发现底层的主要模块，像app项目本身，Unit和UITest文件夹，扩展，框架等。在这些模块中，组和文件的树进一步构建了项目。需要注意的是:</p><blockquote class="ne"><p id="303e" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">HD上的文件夹应该与Xcode中的组相匹配。</p></blockquote><p id="f526" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">诚然，这并不真的那么重要，因为它不能防止任何合并冲突或类似的事情，但是如果你保持你的文件系统<strong class="le jo">整洁</strong>，这就是专业的证明。甚至苹果在WWDC19上的“<a class="ae ly" href="https://developer.apple.com/videos/play/wwdc2019/239/" rel="noopener ugc nofollow" target="_blank">伟大的开发者习惯</a>”中也明确推荐了这一点。😎</p><p id="7a11" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在任何情况下，您都应该将代码组织成组。几乎没有什么比把1000个文件都放在一个文件夹里更糟糕的了。谁想每次都滚动浏览每个文件来找到自己需要的东西呢？😖</p><p id="ac01" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果您打开“DemoApp”文件夹，您会发现这些组:</p><ul class=""><li id="d88b" class="nv nw je le b lf lg li lj ll nx lp ny lt nz lx oa ob oc od bi translated"><strong class="le jo"> AppStart </strong>:这里是AppDelegate和start storyboard。</li><li id="4596" class="nv nw je le b lf oe li of ll og lp oh lt oi lx oa ob oc od bi translated"><strong class="le jo">生成的</strong>:由脚本和工具自动创建的一切。</li><li id="e7eb" class="nv nw je le b lf oe li of ll og lp oh lt oi lx oa ob oc od bi translated"><strong class="le jo"> Globals </strong>:一些基类，app专用扩展，全局文本，特殊app类型，不在框架外包工。</li><li id="1b9c" class="nv nw je le b lf oe li of ll og lp oh lt oi lx oa ob oc od bi translated"><strong class="le jo">资源</strong> : AppIcon，App专用图片，Info.plist，权限，配置文件。</li><li id="e06b" class="nv nw je le b lf oe li of ll og lp oh lt oi lx oa ob oc od bi translated"><strong class="le jo">场景</strong>:所有的行为和场景。不，我们不是在剧院，这也与SceneKit或iOS 13中引入的新SceneDelegate无关。😜</li></ul><p id="e5b8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在“场景”中，您可以找到文件夹“Act1”及其子文件夹“场景0”和“场景1”，以及“Act2”及其子文件夹“场景2”。</p><p id="7179" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一幕由几个场景组成。然而，这里的分组标准是某些依赖关系，这些依赖关系只能通过时间来解决。大多数情况下，这可以映射到一个特殊的应用程序阶段。</p><p id="325b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">例如，这里的“Act1”可以重命名为“Onboarding ”,以表示用户尚未完全设置好应用程序的阶段。“场景0”将被称为“飞溅”，“场景1”将被称为“登录”。</p><p id="2e12" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">成功登录后，用户应该已经登录，这样用户对象就可用了，并且可以作为后续场景的另一个依赖项进行解析。这个阶段可以称为“登录”而不是“第二步”，但这当然只是一个例子。</p><p id="bec2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在DAP中，这是用用户对象绘制的。在我的文章“<a class="ae ly" href="https://medium.com/@sven.korset/resolving-dependencies-easily-in-swift-ee0f8f2dfbe3" rel="noopener">在Swift </a>中手动完成的依赖性管理”中解释了更详细的方法和背景。🤓</p><p id="47dd" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我的文章“<a class="ae ly" href="https://medium.com/@sven.korset/the-perfect-ios-app-architecture-24259417843f" rel="noopener">完美的iOS应用架构</a>”中描述了一个场景是如何构建的。值得一提的是:</p><blockquote class="ne"><p id="5c35" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">所有<em class="oj">场景相关的</em>依赖应该在Xcode中关闭。</p></blockquote><p id="7a7a" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">我经常看到按类型组织的文件，也就是一个“VC”文件夹，所有的<em class="lz">视图控制器</em>都在这里。一个“视图”文件夹用于所有视图，一个文件夹用于所有单元格，等等。然而，这种结构的结果是，您必须不断地在Xcode中跳过整个项目树。</p><p id="ad84" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当在<em class="lz"> ViewController </em>上工作时，你经常会编辑相关的视图、单元格等。如果所有这些属于<em class="lz"> ViewController </em>的类都在同一个文件夹或子文件夹中，那就更有意义了。这样你就有了更好的概览和更短的导航所需的一切。</p><p id="30ce" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="lz">场景</em>遵循这个原则。只属于这个<em class="lz">场景</em>的所有东西都在<em class="lz">场景</em>文件夹或子文件夹中。如果你不在这个<em class="lz">场景</em>工作，你就不需要打开这个文件夹。按抑制概述！😋</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cf83" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">Xcode模板</h1><p id="5d61" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">如果你经常创建新的<em class="lz">场景</em>，那么手动创建每个文件，一遍又一遍地写所有的骨架代码，会很烦。如果能只做一次，然后自动化就更好了。</p><p id="bbc9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这就是为什么在带有Xcode模板的repo中有一个“Templates”文件夹。附带的<em class="lz">自述文件</em>解释了如何在Xcode中安装和使用模板。</p><blockquote class="ne"><p id="30f8" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">当设置自动化和维护它的时候，总是自动化工作，花费比它节省的时间要少。</p></blockquote><p id="4ab9" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">棘手的是，你得估算一下要花多少时间，能省多少时间。<strong class="le jo">经验</strong>和好的时间追踪在这里有帮助。🧐</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ae95" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">开发工具</h1><p id="7dc9" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">“自动化”建议还包括某些命令行工具，如“<a class="ae ly" href="https://github.com/mac-cain13/R.swift" rel="noopener ugc nofollow" target="_blank"> R-swift </a>”(或“<a class="ae ly" href="https://github.com/SwiftGen/SwiftGen" rel="noopener ugc nofollow" target="_blank"> SwiftGen </a>”)、<a class="ae ly" href="https://github.com/nicklockwood/SwiftFormat" rel="noopener ugc nofollow" target="_blank"> SwiftFormat </a>和“<a class="ae ly" href="https://github.com/realm/SwiftLint" rel="noopener ugc nofollow" target="_blank"> SwiftLint </a>”。在DAP中，这些通过<em class="lz">协同包</em>集成，并在<em class="lz">目标</em>的相应<em class="lz">构建阶段</em>中配置。</p><p id="8845" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一旦正确配置，工具将总是在您编译代码时运行。然后，它们会自动创建特定代码，格式化所有Swift文件以符合编码指南，并执行额外检查以发现特定漏洞和代码气味。</p><p id="c958" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">那就是一下子三个要点！😳</p><blockquote class="ne"><p id="a311" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">使用强类型引用，自动设置代码格式并修复任何警告。</p></blockquote><p id="ca0d" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">强类型是安全的。格式化代码只是<strong class="le jo">更漂亮</strong>。谁喜欢他们脸上的黄色警告？修复警告并使代码更加健壮。😅</p><p id="35c8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">使用R-swift，您只需调用<code class="fe ok ol om on b">R.string.scene0.title()</code>从<code class="fe ok ol om on b">Scene0.strings</code>文件中获取带有关键字<code class="fe ok ol om on b">Title</code>的本地化字符串。不安全的是像<code class="fe ok ol om on b">NSLocalizedString("Title", tableName: "Scene0", comment: "")</code>这样的调用，你可能会拼错关键字“Title”或“Scene0”。尝试在任何地方使用强类型引用，从本地化字符串到图像、颜色和任何常量值。</p><p id="fc99" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">为什么要自动格式化代码？因为我们都是人，并不总是100%地执行指南，即使我们尽了最大努力，其他人也做了代码审查。此外，一台机器做它最擅长的事情——那么，为什么要自己做呢？😌</p><p id="777d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">编译器和linter警告指出了可能的问题。也许这还不是一个问题，但这些是你应该改进的地方，这样它们就不会在某一天变成问题。</p><p id="12b0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在<em class="lz">构建设置中，</em>你也可以设置<em class="lz">警告</em>作为<em class="lz">错误</em>处理，但是我觉得那太尖锐了。如果你正在开发某个东西，它还不干净，但是你仍然希望能够运行代码。然而，你应该最迟在特征完成后消除<strong class="le jo">所有的</strong>警告。</p><p id="66a0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一般来说，只要把代码做的漂漂亮亮，写出你明天依然热爱的代码就行了！😍</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="02e2" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">模块化</h1><p id="b4e6" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">DAP表明您可以很好地使用嵌入式框架来模块化代码。正如我的文章“<a class="ae ly" href="https://medium.com/@sven.korset/the-perfect-ios-app-architecture-24259417843f" rel="noopener">完美的iOS应用架构</a>”，<strong class="le jo">模块化</strong>是合理架构的关键。所以，这是关于将代码分割成更小的单元，将它们结构化，并使它们更易于<strong class="le jo">维护</strong>。</p><blockquote class="ne"><p id="3a0d" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">分而治之！</p></blockquote><p id="89d6" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">正如我在博客文章“<a class="ae ly" href="https://medium.com/@sven.korset/structure-constants-in-ios-with-enums-5ca2135dcab0" rel="noopener">中所描述的那样，带有枚举</a>的iOS中的结构常量“<em class="lz">枚举</em>可以以名称空间的形式使用，以结构化代码。然而，使用框架甚至更进一步。嵌入式框架的优势经常被低估。🤨</p><p id="8e71" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你外包给嵌入式框架的代码会自动得到一个更好的界面，因为你不得不考虑它。框架也可以在其他目标中使用，并且通常被大量封装。</p><p id="53af" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">此外，部分<em class="lz">单元测试</em>可以外包给框架。现在在框架中的代码可以在那里进行测试。只有当框架中的代码发生变化时，才需要运行框架测试，而不是每次都要运行。</p><p id="bc06" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">有了嵌入式框架，心理压力就被简单地外包了。😎</p><p id="5ee0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">顺便提一下，Xcode 11刚刚引入了一种使用<em class="lz"> Swift包管理器的更好的集成方式，</em>所以这可能会成为嵌入式框架的替代方案。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="741b" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">配置</h1><p id="8da0" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">在一个项目中，人们经常在不同的环境中开发。例如，所有的服务器请求都是针对开发服务器的，有时是临时服务器，后来是实时服务器。或者应该使用不同的测试场景，例如，应该在每次应用启动时删除数据库，然后用测试数据填充。为此，您不希望一直更改代码。😫</p><p id="2bca" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于这些环境，如果您不需要更改任何代码，只需要加载一个不同的配置文件就可以了。这可以通过不同的方式完成，一种是在Xcode中使用配置文件，如我的文章“<a class="ae ly" href="https://medium.com/better-programming/how-to-create-development-staging-and-production-configs-in-xcode-ec58b2cc1df4" rel="noopener">Xcode中的Dev/Staging/Prod配置</a>”中所述。😌</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5896" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">证明文件</h1><p id="7fa2" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">你打开一个项目，发现没有<em class="lz"> Readme </em>的粗略概述或一些细节。代码缺少任何注释。这个方法是做什么的，这个参数是做什么的，那个神秘的行是什么意思？现在你问自己:“我到底在那里做了什么？”😭</p><blockquote class="ne"><p id="7a2f" class="nf ng je bd nh ni nj nk nl nm nn lx dk translated">总是记下上下文，使用简单的英语。</p></blockquote><p id="6a61" class="pw-post-body-paragraph lc ld je le b lf no ko lh li np kr lk ll nq ln lo lp nr lr ls lt ns lv lw lx im bi translated">我知道还有其他的观点，像布莱恩·诺兰德(T1)和T2()宣称“<a class="ae ly" href="https://blog.usejournal.com/stop-writing-code-comments-28fef5272752" rel="noopener ugc nofollow" target="_blank">停止编写代码注释(T4)”，因为每个程序员都应该编写足够有表现力的代码，所以注释变得没有必要。他提出了很好的论点，甚至我们的圣罗伯特·c·马丁也喜欢编写不带注释的代码。</a></p><p id="c71a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，另一方面，你也有像<a class="nt nu ep" href="https://medium.com/u/760ed5351ab7?source=post_page-----dce56a256106--------------------------------" rel="noopener" target="_blank"> Christopher Laine </a>这样的人，她解释了为什么“<a class="ae ly" href="https://medium.com/it-dead-inside/self-documenting-code-is-mostly-nonsense-1de5f593810f" rel="noopener">自文档化代码(大部分)是无意义的</a>”和<a class="nt nu ep" href="https://medium.com/u/3c84828eca46?source=post_page-----dce56a256106--------------------------------" rel="noopener" target="_blank"> Cindy S. Cheung </a>，她在她的文章“<a class="ae ly" href="https://medium.com/@cindyscheung/pleeeeaase-explain-your-code-e1fdfdf19566" rel="noopener">please Explain Your Code</a>”中更详细地阐述了注释的好处。我相信你已经猜到了，我更倾向于后者的观点。😆</p><p id="3f3c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">代码注释只是帮助阐明代码做什么。对于名为“title”的参数，只写注释“the title”显然是没有帮助的。这就是为什么你应该写<strong class="le jo">上下文，而不仅仅是文本</strong>，例如“显示在视图顶部的标题文本”。我真的不想给参数取名<code class="fe ok ol om on b">titleTextShownAtTopOfView</code>。</p><p id="994b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">描述后续代码块功能的行内注释也是如此。你不再需要阅读和理解每一行代码。只需浏览一下评论就可以了。</p><p id="17ce" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">评论只是比写评论节省了更多的时间。写注释不仅通常很容易，而且对以后阅读你的代码的人(包括你)来说也很容易。评论只写一次(可能会更新几次)，但经常被阅读。它们通常会加快速度，尤其是对于不熟悉您的代码的人。</p><p id="3036" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">不相信我？然后简单地浏览一下我的<a class="ae ly" href="https://github.com/indieSoftware/DemoArchitecture" rel="noopener ugc nofollow" target="_blank"> DemoApp项目</a>的代码。我相信你不需要阅读任何评论就能明白它是如何工作的，但是阅读它们肯定会更快。😉</p><p id="0c42" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">长话短说，请总是评论你的代码！🙏</p><p id="6131" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这同样适用于<em class="lz"> Readmes </em>或其他类型的文件。花一天时间研究一份文件，解释项目的大致结构、任何关键决策、概念和具体的依赖关系，比花几周时间进行逆向工程要好。</p><p id="9ec5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">别说这永远不会发生。你知道墨菲定律！😣</p><p id="9a22" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">文档基本上应该用容易理解的英语编写。这通常是不言自明的。英语只是世界上大多数人理解的一种语言。</p><p id="45db" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你永远不知道公司和项目是如何变化的，也不知道谁最终必须维护这个项目。如果文档是用一种未知的语言编写的，它可能会完全丢失。即使英语不好也比没有帮助好。😤</p><p id="5775" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于依赖关系的文档，有一些关于如何使用markdown文件的有趣建议。文章“<a class="ae ly" href="http://blog.mazur.me/DEPENDENCIES.md/" rel="noopener ugc nofollow" target="_blank">用DEPENDENCIES.md </a>跟踪依赖关系”提供了一个我为DAP采用的很好的解决方案。</p><p id="9c1b" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">然而，我发现在单独的文件中记录pod容易出错。所有的pod依赖项都已经在<em class="lz">pod文件</em>中列出来了，那么为什么不在那里记录它们呢？保留一个额外的文件只会导致它不被维护，而不被维护的文件会随着时间的推移而腐烂。</p><p id="7fa5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，<em class="lz"> Podfile </em>是记录任何pod的地方，而<em class="lz"> DEPENDENCIES.md </em>文件是记录任何其他依赖关系的地方。只是在添加非pod依赖项时不要忘记记录它们！(我打赌你会的)😜</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d796" class="mh mi je bd mj mk ml mm mn mo mp mq mr kt ms ku mt kw mu kx mv kz mw la mx my bi translated">这个应用到底在做什么？</h1><p id="9688" class="pw-post-body-paragraph lc ld je le b lf mz ko lh li na kr lk ll nb ln lo lp nc lr ls lt nd lv lw lx im bi translated">没什么——至少没什么有用的。🤣</p><p id="2ae8" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">该项目的存在只是为了展示架构的某些方面和常见问题的具体解决方案。我将在第2部分中对此进行探讨。</p><div class="is it gp gr iu oo"><a href="https://medium.com/@sven.korset/an-example-of-a-scalable-ios-project-part-2-5c703d41f585" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd jo gy z fp ot fr fs ou fu fw jn bi translated">一个可伸缩iOS项目的例子，第2部分</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">演示项目(DAP)场景说明</h3></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ja oo"/></div></div></a></div></div></div>    
</body>
</html>