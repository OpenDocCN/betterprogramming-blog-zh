<html>
<head>
<title>Let’s Synchronize Threads in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们在Python中同步线程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/synchronization-primitives-in-python-564f89fee732?source=collection_archive---------1-----------------------#2017-08-13">https://betterprogramming.pub/synchronization-primitives-in-python-564f89fee732?source=collection_archive---------1-----------------------#2017-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="207b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">因为同步就是和谐</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/898eca9f057998ebadaadd4660c8c8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2eZh-l0RR1FhE9REPxze3Q.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">在Python的众多特性中，这种语言支持多种同步原语。图片来源:Heroku的Python俳句艺术</p></figure><p id="3b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那是一声神奇的“啊哈！”我第一次了解多线程的时刻。事实上，我可以让我的计算机以并行方式执行操作，这让我很高兴(尽管这里应该注意的是，在单核计算机上，事情不会以并行方式精确地发生。更重要的是，在Python中，由于语言的全局解释器锁，它们不能精确地并行执行。多线程为计算开辟了新的空间。但是权力带来了责任。</p><p id="06c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们可以想象多线程有明显的麻烦——许多试图访问同一数据的线程会导致问题——比如使数据不一致或得到混乱的输出(比如在控制台上用<code class="fe ls lt lu lv b">HWeolrldo</code>代替<code class="fe ls lt lu lv b">Hello World</code>)。当我们不告诉计算机如何以有组织的方式管理线程时，就会出现这样的问题。</p><p id="34b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们如何“告诉”计算机保持我们程序的线程同步呢？我们通过使用<em class="lw">同步原语来做到这一点。</em>这些是简单的软件机制，确保您的线程以和谐的方式运行。</p><p id="15d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章展示了Python中一些最流行的同步原语，这些原语是在其标准的<code class="fe ls lt lu lv b">threading.py</code>模块中定义的。这些原语的大多数阻塞方法(即在满足某些条件之前阻塞特定线程执行的方法)都提供了可选的超时功能，但为了简单起见，我没有在这里包括它。同样，为了简单起见，我只包括了这些对象的主要功能。这篇文章假设你有使用Python实现多线程的基本知识。</p><p id="46f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将学习<code class="fe ls lt lu lv b">Locks</code>、<code class="fe ls lt lu lv b">RLocks</code>、<code class="fe ls lt lu lv b">Semaphores</code>、<code class="fe ls lt lu lv b">Events</code>、<code class="fe ls lt lu lv b">Conditions</code>和<code class="fe ls lt lu lv b">Barriers</code>。当然，您可以通过对这些类进行子类化来构建您自己的定制同步原语。我们将从<code class="fe ls lt lu lv b">Locks</code>开始，因为它们是最简单的原语，然后我们将逐渐转向越来越复杂的原语。</p><h1 id="1d79" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">锁</h1><p id="329b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">可能是Python中最简单的同步原语。一个<code class="fe ls lt lu lv b">Lock</code>只有两种状态——锁定和(意外)解锁。它是在解锁状态下创建的，有两个主要方法— <code class="fe ls lt lu lv b">acquire()</code>和<code class="fe ls lt lu lv b">release()</code>。<code class="fe ls lt lu lv b">acquire()</code>方法锁定<code class="fe ls lt lu lv b">Lock</code>并阻止执行，直到其他协程中的<code class="fe ls lt lu lv b">release()</code>方法将其设置为解锁。然后它再次锁定<code class="fe ls lt lu lv b">Lock</code>并返回<code class="fe ls lt lu lv b">True</code>。<code class="fe ls lt lu lv b">release()</code>方法只能在锁定状态下调用，它将状态设置为解锁并立即返回。如果<code class="fe ls lt lu lv b">release()</code>在解锁状态下被调用，则<code class="fe ls lt lu lv b">RunTimeError</code>被引发。</p><p id="1008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是使用<code class="fe ls lt lu lv b">Lock</code>原语安全访问共享变量的代码:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d9c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这仅仅给出了3的输出，但是现在我们确信这两个函数没有同时改变全局变量<code class="fe ls lt lu lv b">g</code>的值，尽管它们运行在两个不同的线程上。因此，<code class="fe ls lt lu lv b">Lock</code> s可用于通过一次只允许一个线程修改数据来避免不一致的输出。</p><h1 id="8638" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">RLocks</h1><p id="3aa1" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">标准<code class="fe ls lt lu lv b">Lock</code>不知道哪个线程当前持有<br/>锁。如果锁被持有，任何试图获取它的线程都会<br/>阻塞，即使同一个线程本身已经持有锁。<br/>在这种情况下，使用<code class="fe ls lt lu lv b">RLock</code>(重入锁)。您可以通过添加输出语句来扩展下面代码片段中的代码，以演示<code class="fe ls lt lu lv b">RLock</code>如何防止不必要的阻塞。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个很好的用例是递归，当一个函数的父调用阻塞了它的嵌套调用时。因此，<code class="fe ls lt lu lv b">RLock</code> s的主要用途是嵌套访问共享资源。</p><h1 id="1c1b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">信号灯</h1><p id="4f36" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">信号量只是高级计数器。对信号量的<code class="fe ls lt lu lv b">acquire()</code>调用只有在大量线程<code class="fe ls lt lu lv b">acquire()</code>调用后才会被阻塞。相关的计数器在每次<code class="fe ls lt lu lv b">acquire()</code>呼叫时减少，在每次<code class="fe ls lt lu lv b">release()</code>呼叫时增加。如果<code class="fe ls lt lu lv b">release()</code>调用试图将计数器增加到超过其分配的最大值(这是在阻塞发生之前能够<code class="fe ls lt lu lv b">acquire()</code>信号量的线程数量)，就会发生<code class="fe ls lt lu lv b">ValueError</code>。下面的代码演示了在一个简单的生产者-消费者问题中信号量的使用:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mw"><img src="../Images/a371bd9e8ef2509c564753672ef6df38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-BjV8tcNk4TzprX-5NJnhg.gif"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">semaphore_tut.py在运行</p></figure><p id="8709" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">threading</code>模块也提供了简单的<code class="fe ls lt lu lv b">Semaphore</code>类。一个<code class="fe ls lt lu lv b">Semaphore</code>提供了一个非有界的计数器，它允许你调用<code class="fe ls lt lu lv b">release()</code>任意次来递增。然而，为了避免编程错误，使用<code class="fe ls lt lu lv b">BoundedSemaphore</code>通常是一个正确的选择，如果<code class="fe ls lt lu lv b">release()</code>调用试图将计数器增加到超过其最大值，就会引发错误。</p><p id="804a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">信号量通常用于限制资源，例如限制服务器一次只能处理10个客户端。在这种情况下，多个线程连接竞争一个有限的资源(在我们的例子中，是服务器)。</p><h1 id="f16f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">事件</h1><p id="4180" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Event</code>同步原语充当线程间的简单通信器。它们基于内部标志，线程可以<code class="fe ls lt lu lv b">set()</code>或<code class="fe ls lt lu lv b">clear()</code>。其他线程可以<code class="fe ls lt lu lv b">wait()</code>将内部标志设为<code class="fe ls lt lu lv b">set()</code>。<code class="fe ls lt lu lv b">wait()</code>方法阻塞，直到标志变为真。下面的代码片段演示了如何使用<code class="fe ls lt lu lv b">Event</code>来触发动作。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mw"><img src="../Images/7bda867507a96fea0b1579d7705254e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tv4dRrJZTwJYw_B9zIubcA.gif"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">event_tut.py的执行</p></figure><h1 id="8f18" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">情况</h1><p id="1f6b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">一个<code class="fe ls lt lu lv b">Condition</code>对象只是一个更高级版本的<code class="fe ls lt lu lv b">Event</code>对象。它也充当线程间的通信器，可以用来<code class="fe ls lt lu lv b">notify()</code>其他线程关于程序状态的变化。例如，它可以用来表示可供消费的资源的可用性。在满足条件之前，其他线程也必须<code class="fe ls lt lu lv b">acquire()</code>该条件(及其相关的锁)<code class="fe ls lt lu lv b">wait()</code>。此外，一旦线程完成了相关的动作，它就应该<code class="fe ls lt lu lv b">release()</code> a <code class="fe ls lt lu lv b">Condition</code>，这样其他线程就可以为它们的目的获取条件。下面的代码借助于<code class="fe ls lt lu lv b">Condition</code>对象演示了另一个简单的生产者-消费者问题的实现:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mw"><img src="../Images/97c4a97c3e56843898c2395c713c8cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tTYcI9yP6XrnZcFSRGA_vw.gif"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">condition_tut.py的输出</p></figure><p id="a08d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有其他使用<code class="fe ls lt lu lv b">Condition</code>的方法。我认为当你需要开发一个流API来通知一个等待中的客户端有数据可用时，它们会很有用。</p><h1 id="dc95" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">障碍</h1><p id="c2fa" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">屏障是一个简单的同步原语，不同的线程可以使用它来相互等待。每个线程都试图通过调用<code class="fe ls lt lu lv b">wait()</code>方法来通过一个障碍，这个方法会一直阻塞，直到所有的线程都进行了那个调用。一旦发生这种情况，线程就会被同时释放。下面的代码片段演示了<code class="fe ls lt lu lv b">Barrier</code>的用法。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mw"><img src="../Images/92045c35b5a4654fb3f3b888f715d799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CYnUEjVV8Ztq1dwwQ9EnHA.gif"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">下面是barrier_tut.py的输出</p></figure><p id="7bca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">屏障可以有许多用途；其中之一是同步一个服务器和一个<br/>客户端——因为服务器在初始化自己之后必须等待客户端。</p><p id="da6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，我们已经结束了对Python中同步原语的讨论。我写这篇文章是作为Wesley Chun所著的《核心Python应用程序编程》一书中一个练习的<a class="ae mx" href="https://github.com/schedutron/CPAP/blob/master/Chap4/sync_prim.md" rel="noopener ugc nofollow" target="_blank">解决方案。</a></p><p id="9827" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来源:<a class="ae mx" href="http://effbot.org/zone/thread-synchronization.htm" rel="noopener ugc nofollow" target="_blank">effbot.org</a>、<a class="ae mx" href="http://www.bogotobogo.com/python/Multithread/" rel="noopener ugc nofollow" target="_blank">bogotobogo.com</a>、<a class="ae mx" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="379c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我是博客新手，所以建设性的批评不仅受欢迎，而且非常受欢迎！</p></div></div>    
</body>
</html>