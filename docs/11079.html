<html>
<head>
<title>The Single Responsibility Principle Explained in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python解释的单一责任原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-single-responsibility-principle-explained-in-python-622e2d996d86?source=collection_archive---------8-----------------------#2022-02-16">https://betterprogramming.pub/the-single-responsibility-principle-explained-in-python-622e2d996d86?source=collection_archive---------8-----------------------#2022-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4655" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">高内聚、低耦合和高质量软件的标志。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ef4263f9ffee5f122718b32821f19fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jX73Oc3lBbh0AfXGj-luLg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由多雷尔·蒂布斯 / <a class="ae ky" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将着眼于第一个<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的</a>原则。SOLID是五个软件设计原则的首字母缩写，这五个原则有助于使软件健壮和可维护。理解并应用这五个原则是优秀软件工程的标志。因此，对于任何有抱负的软件工程师来说，熟悉它们是至关重要的。</p><p id="7518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入研究这个原则之前，必须解释与软件工程相关的两个概念。即<em class="lv">内聚</em>和<em class="lv">耦合</em>。</p><p id="138b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内聚是指一个类中函数之间的<em class="lv">互连</em>。而耦合是指类之间的<em class="lv">相互依赖</em>。来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">【1】</a></p><p id="cf55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是开发高内聚、低耦合的软件。</p><h1 id="5589" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">高内聚力:</h1><p id="d62f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这意味着我们希望一个类中的函数执行彼此相关的任务。让我们设想一些软件的总体任务是生成一个报告并发送它。将所有函数放在一个类中是低内聚的一个例子，因为设计报告和发送报告是两个不同的子任务。相反，我们希望负责设计报告样式和插入内容的函数是一个类的一部分，而负责发送的函数是另一个类的一部分。</p><h1 id="8103" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">低耦合:</h1><p id="bfc4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">另一方面，我们希望低耦合。这意味着类不应该过于依赖彼此。因此，负责发送报告的班级不应该太关心报告的格式、风格或长度。应该是松耦合的。如果我们更改了设计报告样式或设置格式的函数，负责发送报告的函数应该仍然可以正常工作。你可以想象，如果耦合度很高，就会有很多依赖关系，这意味着如果一个类中的某个东西发生了变化，那么这个变化就会传播到依赖它的其他类，它们也必须发生变化。这不仅会引入错误，还会使代码维护和未来的开发成为一场噩梦。</p><p id="c2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单一责任原则帮助我们实现高内聚和低耦合的目标。这里有一张图片说明了这个概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/a225f18fc884d07c491db64e8a392cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Aw8K0U8apSkaFWTR.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.coursera.org/lecture/object-oriented-design/1-3-1-coupling-and-cohesion-q8wGt" rel="noopener ugc nofollow" target="_blank"> Coursera </a>。内聚与耦合</p></figure><p id="daa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！既然已经解决了这个问题，让我们来看一个例子😊</p><h1 id="ce2e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">原则</h1><p id="88fe" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">S代表单一责任原则:</p><blockquote class="mu mv mw"><p id="5539" class="kz la lv lb b lc ld ju le lf lg jx lh mx lj lk ll my ln lo lp mz lr ls lt lu im bi translated">"一个类的改变不应该有一个以上的原因."换句话说，每个类应该只有一个责任。<br/>来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">Wikipedia.org</a></p></blockquote><p id="a2ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上一个类应该只有一个目的。如果类的功能需要改变，应该有这样做的理由。</p><h1 id="1646" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">密码</h1><p id="8e2a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们想象一个汽车经销商销售3种类型的汽车。用户可以:</p><ul class=""><li id="cd94" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">请求一辆汽车</li><li id="3045" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">试驾汽车</li><li id="32de" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">买辆车</li></ul><p id="2520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果请求的汽车不可用，用户会得到一个错误。汽车的价格是从价目表中检索出来的。最后，用户可以试驾汽车，也可以购买汽车。只有提供全款才有可能买车。</p><p id="7413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你注意到了，<code class="fe nq nr ns nt b">Car</code>类有多重职责——它需要处理汽车信息以及购买汽车的财务信息。因此，它违反了单一责任原则。</p><p id="03bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种看待它的方式是使用上述原理的定义。也就是说，一个类的改变应该只有一个原因。</p><p id="dd7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们假设汽车经销商想要做出两项改变:</p><ul class=""><li id="71fd" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">开始向客户提供分期付款，而不是预付全款</li><li id="1bf2" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">改变汽车的价格</li></ul><p id="6cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在有两个 原因导致<code class="fe nq nr ns nt b">Car</code>类改变。一个类的改变必定只有一个<strong class="lb iu"> <em class="lv">单一的</em> </strong>原因，所以违反了原则。</p><p id="78f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过创建一个名为<code class="fe nq nr ns nt b">Financials</code>的独立类并实现上面列出的更改来轻松解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果你现在注意到，每个类——</strong><code class="fe nq nr ns nt b"><strong class="lb iu">Car</strong></code><strong class="lb iu"/><code class="fe nq nr ns nt b"><strong class="lb iu">Financials</strong></code><strong class="lb iu">只有一个改变的理由。</strong></p><p id="f8aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果预付至少三分之二的金额，现在可以分期付款。这个在<code class="fe nq nr ns nt b">Financials</code>班更新了。其次，一辆<code class="fe nq nr ns nt b">BMW</code>的价格从10万变成了20万。这是在<code class="fe nq nr ns nt b">Car</code>类中更新的。</p><p id="35a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精彩！</p><h1 id="afe3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="4e10" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">很难理解为什么在同一个类中同时拥有汽车交易和金融功能会是一个大问题。然而，这在拥有许多类和依赖项的大中型组织代码库中变得非常明显。</p><p id="c8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可能已经注意到代码现在比以前更加松散，因为我们已经将它分成了两个类。此外，由于每个单独的类现在都有一个清晰明确的任务，因此有了更多的凝聚力。<code class="fe nq nr ns nt b">Car</code>类只关心汽车本身，而<code class="fe nq nr ns nt b">Financials</code>类只处理财务。</p><p id="3070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢这篇文章！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="1cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">原载于</em><a class="ae ky" href="https://haseebkamal.com/the-single-responsibility-principle-in-software-engineering/" rel="noopener ugc nofollow" target="_blank"><em class="lv">https:haseebkamal . com .</em></a></p></div></div>    
</body>
</html>