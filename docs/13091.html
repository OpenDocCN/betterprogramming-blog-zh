<html>
<head>
<title>Triggering Repeatable Animations From the Server in LiveView and Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在LiveView和Elixir中从服务器触发可重复的动画</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/triggering-repeatable-animations-from-the-server-in-liveview-and-elixir-970961085f12?source=collection_archive---------8-----------------------#2022-07-27">https://betterprogramming.pub/triggering-repeatable-animations-from-the-server-in-liveview-and-elixir-970961085f12?source=collection_archive---------8-----------------------#2022-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d09c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">灵药开发者指南(以及你为什么想这么做)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/deeccc9366c8e1953355dcbb0651d030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5yzIxuRv3Cvk6EvQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@janjakubnanista?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹·雅各布·纳尼斯塔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="efb6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">凤凰城实时景观</h1><p id="b239" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Phoenix LiveView是我目前最喜欢的创建web应用程序的方式——花瓣堆栈使用起来非常有趣，并且(在我看来)很快就会成为web开发人员的主流堆栈选择，他们希望创建实时应用程序，而不必担心当今最流行的工具所带来的客户端问题。</p><p id="3b7a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Chris McCord在他的关于LiveView如何成为的<a class="ae kv" href="https://fly.io/blog/liveview-its-alive/" rel="noopener ugc nofollow" target="_blank">fly . io博客文章中雄辩地描述了你获得的力量以及能够几乎忘记大约90%的客户端代码的天赋——强烈推荐阅读。</a></p><p id="c5e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我已经开发了一些LiveView应用程序(我认为自己足够幸运，能够在工作中使用它)，包括:</p><ul class=""><li id="fc75" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">一款受wordle启发的网页游戏</li><li id="503e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://niceice.io/" rel="noopener ugc nofollow" target="_blank">nicice . io</a>——一项SaaS服务，用于尽可能容易地获取用户的反馈</li></ul><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4ea8" class="ni kx iq ne b gy nj nk l nl nm">Petal Stack?<br/>Phoenix, Elixir, Tailwind, Alpine &amp; LiveView.</span></pre><h1 id="6425" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么要从后端触发前端动画？</h1><p id="ca5f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">LiveView在构建实时应用程序方面非常出色——当我说实时时，我指的是对当前浏览该网站的所有用户的即时反应。</p><p id="7016" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我目前正在开发一个平台，可以在网上分享用户创造的虚构故事，当我试图给生活带来一个新的功能时，我偶然发现了为什么需要这个教程的基础。</p><p id="a1bf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">作为我的新平台的一部分，用户可以提交故事和章节，并制作内容供用户阅读。想要给我的应用程序添加更多的活力——我觉得在我的网站首页上有一个实时的全球统计组件会很酷，这样用户可以实时看到网站有多活跃！</p><h1 id="1c0e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">所以我做了一个简单的LiveView组件</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/879810757087c8df5be9adfe201c8276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e8nIj9bdM13fl7nq.png"/></div></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="eaa8" class="ni kx iq ne b gy nj nk l nl nm">def mount(_params, _session, socket) do<br/>    socket =<br/>      socket<br/>      |&gt; assign(:story_count, total_story_count())<br/>      |&gt; assign(:word_count, total_word_count())<br/>      |&gt; assign(:chapter_count, total_chapter_count())</span><span id="e0d9" class="ni kx iq ne b gy no nk l nl nm">    {:ok, socket}<br/>  end<br/>    <br/>  def render(assigns) do<br/>    ~H"""<br/>     &lt;p&gt;&lt;span id="stories-count"&gt;&lt;%= @stories_count %&gt;&lt;/span&gt; stories submitted&lt;/p&gt;<br/>     &lt;p&gt;&lt;span id="chapters-count"&gt;&lt;%= @chapters_count %&gt;&lt;/span&gt; chapters published&lt;/p&gt;<br/>     &lt;p&gt;&lt;span id="word-count"&gt;&lt;%= @word_count %&gt;&lt;/span&gt; words written&lt;/p&gt;<br/>    """<br/>  end</span></pre><p id="7183" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这很酷——我有一个组件，每当用户访问页面时，它就会更新，但这不是很实时，不是吗？</p><p id="541a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">目前信息只在<code class="fe np nq nr ne b">mount</code>更新——让我们用默认情况下Phoenix附带的<code class="fe np nq nr ne b">Phoenix.PubSub</code>模块的魔力来改变它。</p><p id="72c7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为此，我们需要为我们的PubSub创建一个要订阅的主题(并在我的应用主管树中启用PubSub):</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0a79" class="ni kx iq ne b gy nj nk l nl nm"># MyApplication.Submissions</span><span id="1c85" class="ni kx iq ne b gy no nk l nl nm">  @topic inspect(__MODULE__)</span><span id="6128" class="ni kx iq ne b gy no nk l nl nm">  def subscribe do<br/>    PubSub.subscribe(MyApplication.PubSub, @topic)<br/>  end</span><span id="bf28" class="ni kx iq ne b gy no nk l nl nm">  defp notify_subscribers({:ok, result}, event) do<br/>    PubSub.broadcast(MyApplication.PubSub, @topic, {__MODULE__, event, result})<br/>    {:ok, result}<br/>  end</span></pre><p id="322b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，每当我想提醒订阅了我感兴趣的更新的内容时，我就可以使用这个<code class="fe np nq nr ne b">notify_subscribers/2</code>功能，如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="64d3" class="ni kx iq ne b gy nj nk l nl nm">def update_story(%Story{} = story, attrs) do<br/>    story<br/>    |&gt; Story.update_changeset(attrs)<br/>    |&gt; Repo.update() <br/>    |&gt; notify_subscribers([:story, :updated]) # ⬅️ the interesting bit<br/>  end</span></pre><p id="ac4f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后我们需要确保当我们的<code class="fe np nq nr ne b">live_component</code>挂载并连接到WebSocket时，它订阅了主题。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e52b" class="ni kx iq ne b gy nj nk l nl nm">def mount(_params, _session, socket) do<br/>    if connected?(socket) do<br/>        MyApplication.Submissions.subscribe()<br/>    end<br/>    <br/>    # and add an event listener to ensure our LiveView knows to react when it receives a message from our subscribed topic<br/>    def handle_info({MyApplication.Submissions, [:story, _], _}, socket) do<br/>        socket =<br/>            socket<br/>            |&gt; assign(:story_count, total_story_count())</span><span id="3794" class="ni kx iq ne b gy no nk l nl nm">        {:noreply, socket}<br/>    end<br/>  end</span></pre><p id="315a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，当我们更新我们的故事时——<em class="ns">注意，我忽略了第二个atom，所以每当发生任何故事变化时，我都会调用我的新任务</em>——我们的前端将为所有用户更新！</p><p id="6c39" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不过，我们有个问题。</p><p id="a6db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">没有动画！这对于用户来说可能很不和谐，所以让我们进入这篇文章的真正要点；从后端触发动画来真正取悦我们的读者。</p><h1 id="0ef9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动画时间</h1><p id="cffe" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于我的例子，我使用顺风(耶，花瓣🌸stack ),但只要动画和关键帧属性设置正确，这将适用于任何CSS类。</p><p id="5181" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，让我们在CSS中定义我们的动画(在我们的<code class="fe np nq nr ne b">tailwind.config.js</code>):</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0c4f" class="ni kx iq ne b gy nj nk l nl nm">theme: {<br/>    extend: {<br/>      keyframes: {<br/>        wiggle: {<br/>          '0%': { transform: 'translateY(0px) scale(1,1)' },<br/>          '25%': { transform: 'translateY(-4px) scale(1.05,1.05)', background: 'aquamarine' },<br/>          '100%': { transform: 'translateY(0px) scale(1,1)' },<br/>        }<br/>      },<br/>      animation: {<br/>        wiggle: 'wiggle 0.5s linear 1 forwards',<br/>      }<br/>    },<br/>  },</span></pre><p id="a219" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们所做的只是让它跳一点点。让我们继续整合这个。</p><h1 id="6266" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">第一次尝试</h1><p id="e7d7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">起初，我认为我可以简单地使用<code class="fe np nq nr ne b">LiveView.JS</code>库从后端向有问题的元素添加一个类，并将其传递到前端，如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1ec4" class="ni kx iq ne b gy nj nk l nl nm">def do_animation do<br/>    JS.add_class("animate-wiggle", to: "#word-count")<br/>  end</span></pre><p id="51ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">记住，我也是用一个带有点击处理程序<code class="fe np nq nr ne b">phx-click={do_animation}</code>的简单按钮来测试的，这样就不用每次都触发后端事件了——所以我用的是phx-click...</p><p id="3315" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这增加了类，动画做了一点跳跃——太棒了。</p><p id="8244" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我又点了一下，什么也没发生，不太好。</p><p id="9d1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是因为类依赖于元素，所以再次添加它意味着什么也不会发生——我的动画是不可重复的。哎呦。</p><h1 id="ae58" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">第二次尝试</h1><p id="249e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">添加完类后，让我们删除该类。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4847" class="ni kx iq ne b gy nj nk l nl nm">def do_animation do<br/>    JS.add_class("animate-wiggle", to: "#word-count")<br/>    send(self(), JS.remove_class("animate-wiggle", to: "#word-count"))<br/>  end</span></pre><p id="ffa6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这不起作用，因为该类在添加的同时被删除。我本来可以增加一个暂停，但这似乎太不礼貌了。</p><h1 id="db59" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">第三次尝试</h1><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="14ca" class="ni kx iq ne b gy nj nk l nl nm">def animate_wiggle(element_id) do<br/>    JS.transition(%JS{}, "animate-wiggle", to: element_id, time: 500)<br/>  end</span></pre><p id="864b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe np nq nr ne b">JS.transition/2</code>来救援了！LiveView团队构建了一个特定的功能来重复触发转换。</p><p id="4f39" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是有一个问题——<code class="fe np nq nr ne b">LiveView.JS</code>函数只是生成JavaScript，所以它们必须在页面中呈现！</p><p id="105a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那我们该怎么办？</p><p id="a2cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://hexdocs.pm/phoenix_live_view/js-interop.html#handling-server-pushed-events" rel="noopener ugc nofollow" target="_blank"> RTFM </a>当然！向前！</p><h1 id="93e3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">第四次尝试</h1><p id="9894" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我必须将事件推送到浏览器，以便一些JavaScript可以为我执行wiggle动画——所以流程是这样的:</p><ul class=""><li id="a3c0" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">发布订阅广播事件</li><li id="d997" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">每个订阅的LiveView进程都会监听该事件，并向其客户端触发一个事件</li><li id="77af" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">客户端有一个JavaScript事件监听器来获取<code class="fe np nq nr ne b">phx</code>事件并对其做出反应</li><li id="c064" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">JavaScript向客户端发出一个调用来触发动画</li><li id="a0ea" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><code class="fe np nq nr ne b">JS.transition/2</code>火灾</li><li id="e9a1" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">摆动摆动</li></ul><p id="71de" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们在<code class="fe np nq nr ne b">App.js</code>中添加JS事件监听器:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4b88" class="ni kx iq ne b gy nj nk l nl nm">window.addEventListener(`phx:wiggle`, (e) =&gt; {<br/>  let el = document.getElementById(e.detail.id)<br/>  if(el) {<br/>    liveSocket.execJS(el, el.getAttribute("data-wiggle"))<br/>  }<br/>})</span></pre><p id="d500" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们更新事件处理程序，确定何时将事件推送到客户端:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="52aa" class="ni kx iq ne b gy nj nk l nl nm">def handle_info({MyApplication.Submissions, [:story, _], _}, socket) do<br/>    socket =<br/>        socket<br/>        |&gt; assign(:story_count, total_story_count())<br/>        |&gt; push_event("wiggle", %{id: "stories-count"}) # ⬅️ the new addition<br/>            <br/>    {:noreply, socket}<br/>end</span></pre><p id="a2d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还需要确保向想要摆动的元素添加id和数据属性，以便JavaScript可以找到它并知道如何处理它:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7a4d" class="ni kx iq ne b gy nj nk l nl nm">&lt;p&gt;&lt;span id="stories-count" data-wiggle={animate_wiggle("#stories-count")}&gt;&lt;%= @stories_count %&gt;&lt;/span&gt; stories submitted&lt;/p&gt;</span></pre><h1 id="4245" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结果</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8b521bf3f3fedf057a568bce3717f287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*etTWF8ClTZja6FUL.gif"/></div></figure><p id="9186" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你看不到的是我有另一个窗口来触发上述事件。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="723b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们完了！</p><p id="4c7e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们已经用最少的代码(实际上只有6行JavaScript)成功地触发了来自应用程序其他用户的实时事件的可重复前端动画。</p><p id="556a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我爱<code class="fe np nq nr ne b">LiveView</code>，我希望这篇文章能让你知道为什么。</p><p id="7f10" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://twitter.com/codestirring" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a> &amp; <a class="ae kv" href="https://chrisgregori.substack.com/" rel="noopener ugc nofollow" target="_blank">订阅我的Substack </a>获取更多LiveView、Elixir和一般编程教程和技巧。</p></div></div>    
</body>
</html>