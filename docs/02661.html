<html>
<head>
<title>How To Use GIFs With ARKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在ARKit上使用gif</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-gifs-with-arkit-tutorial-610e4c1602da?source=collection_archive---------16-----------------------#2019-12-15">https://betterprogramming.pub/how-to-use-gifs-with-arkit-tutorial-610e4c1602da?source=collection_archive---------16-----------------------#2019-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">3D得到了很多人的喜爱，但是在ARKit中使用2D怎么样呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8f51050f5b017057f02571642b50811b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CSNPvKtRuH2aF7Yo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">帕特里克·施耐德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a83d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我注意到在苹果的ARKit平台上实现gif的教程明显不足。我认为这是因为人们对AR的3D方面比对2D方面更感兴趣，但我相信2D有一些有趣的使用案例。</p><p id="afed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ARKit实现gif的关键是什么？不幸的是，这并不像在节点上应用GIF文件作为材质那么简单，因为动画不会播放。幸运的是，有人为UIImage创建了一个扩展，您可以简单地将它添加到您的项目中，以便播放gif。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="1df0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从在Xcode中创建新项目开始。有些人更喜欢从单视图应用程序开始，但这里我们将创建一个增强现实应用程序。确保内容技术设置为SceneKit。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/30a6e75bc42374ca25de722c93f0df26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWKQlUsIhhUz3izyQzIuRw.png"/></div></div></figure><p id="6c56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您从增强现实模板开始，<strong class="ky ir"> info.plist </strong>将自动填写隐私-相机使用描述。这很重要，因为所有新的ARKit项目都需要用户的许可才能使用手机的摄像头。现在我们需要UIImage扩展。iOS开发中心的人创建了一个很棒的扩展，可以很好地与ARKit兼容。只需在您的项目中创建一个新的Swift文件，并将代码放入其中:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="36bf" class="mf mg iq mb b gy mh mi l mj mk">//<br/>//  iOSDevCenters+GIF.swift<br/>//  GIF-Swift<br/>//<br/>//  Created by iOSDevCenters on 11/12/15.<br/>//  Copyright © 2016 iOSDevCenters. All rights reserved.<br/>//<br/>import UIKit<br/>import ImageIO<br/>// FIXME: comparison operators with optionals were removed from the Swift Standard Libary.<br/>// Consider refactoring the code to use the non-optional operators.<br/>fileprivate func &lt; &lt;T : Comparable&gt;(lhs: T?, rhs: T?) -&gt; Bool {<br/>  switch (lhs, rhs) {<br/>  case let (l?, r?):<br/>    return l &lt; r<br/>  case (nil, _?):<br/>    return true<br/>  default:<br/>    return false<br/>  }<br/>}<br/><br/><br/><br/>extension UIImage {<br/>    <br/>    public class func gifImageWithData(_ data: Data) -&gt; UIImage? {<br/>        guard let source = CGImageSourceCreateWithData(data as CFData, nil) else {<br/>            print("image doesn't exist")<br/>            return nil<br/>        }<br/>        <br/>        return UIImage.animatedImageWithSource(source)<br/>    }<br/>    <br/>    public class func gifImageWithURL(_ gifUrl:String) -&gt; UIImage? {<br/>        guard let bundleURL:URL? = URL(string: gifUrl)<br/>            else {<br/>                print("image named \"\(gifUrl)\" doesn't exist")<br/>                return nil<br/>        }<br/>        guard let imageData = try? Data(contentsOf: bundleURL!) else {<br/>            print("image named \"\(gifUrl)\" into NSData")<br/>            return nil<br/>        }<br/>        <br/>        return gifImageWithData(imageData)<br/>    }<br/>    <br/>    public class func gifImageWithName(_ name: String) -&gt; UIImage? {<br/>        guard let bundleURL = Bundle.main<br/>            .url(forResource: name, withExtension: "gif") else {<br/>                print("SwiftGif: This image named \"\(name)\" does not exist")<br/>                return nil<br/>        }<br/>        guard let imageData = try? Data(contentsOf: bundleURL) else {<br/>            print("SwiftGif: Cannot turn image named \"\(name)\" into NSData")<br/>            return nil<br/>        }<br/>        <br/>        return gifImageWithData(imageData)<br/>    }<br/>    <br/>    class func delayForImageAtIndex(_ index: Int, source: CGImageSource!) -&gt; Double {<br/>        var delay = 0.1<br/>        <br/>        let cfProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil)<br/>        let gifProperties: CFDictionary = unsafeBitCast(<br/>            CFDictionaryGetValue(cfProperties,<br/>                Unmanaged.passUnretained(kCGImagePropertyGIFDictionary).toOpaque()),<br/>            to: CFDictionary.self)<br/>        <br/>        var delayObject: AnyObject = unsafeBitCast(<br/>            CFDictionaryGetValue(gifProperties,<br/>                Unmanaged.passUnretained(kCGImagePropertyGIFUnclampedDelayTime).toOpaque()),<br/>            to: AnyObject.self)<br/>        if delayObject.doubleValue == 0 {<br/>            delayObject = unsafeBitCast(CFDictionaryGetValue(gifProperties,<br/>                Unmanaged.passUnretained(kCGImagePropertyGIFDelayTime).toOpaque()), to: AnyObject.self)<br/>        }<br/>        <br/>        delay = delayObject as! Double<br/>        <br/>        if delay &lt; 0.1 {<br/>            delay = 0.1<br/>        }<br/>        <br/>        return delay<br/>    }<br/>    <br/>    class func gcdForPair(_ a: Int?, _ b: Int?) -&gt; Int {<br/>        var a = a<br/>        var b = b<br/>        if b == nil || a == nil {<br/>            if b != nil {<br/>                return b!<br/>            } else if a != nil {<br/>                return a!<br/>            } else {<br/>                return 0<br/>            }<br/>        }<br/>        <br/>        if a &lt; b {<br/>            let c = a<br/>            a = b<br/>            b = c<br/>        }<br/>        <br/>        var rest: Int<br/>        while true {<br/>            rest = a! % b!<br/>            <br/>            if rest == 0 {<br/>                return b!<br/>            } else {<br/>                a = b<br/>                b = rest<br/>            }<br/>        }<br/>    }<br/>    <br/>    class func gcdForArray(_ array: Array&lt;Int&gt;) -&gt; Int {<br/>        if array.isEmpty {<br/>            return 1<br/>        }<br/>        <br/>        var gcd = array[0]<br/>        <br/>        for val in array {<br/>            gcd = UIImage.gcdForPair(val, gcd)<br/>        }<br/>        <br/>        return gcd<br/>    }<br/>    <br/>    class func animatedImageWithSource(_ source: CGImageSource) -&gt; UIImage? {<br/>        let count = CGImageSourceGetCount(source)<br/>        var images = [CGImage]()<br/>        var delays = [Int]()<br/>        <br/>        for i in 0..&lt;count {<br/>            if let image = CGImageSourceCreateImageAtIndex(source, i, nil) {<br/>                images.append(image)<br/>            }<br/>            <br/>            let delaySeconds = UIImage.delayForImageAtIndex(Int(i),<br/>                source: source)<br/>            delays.append(Int(delaySeconds * 1000.0)) // Seconds to ms<br/>        }<br/>        <br/>        let duration: Int = {<br/>            var sum = 0<br/>            <br/>            for val: Int in delays {<br/>                sum += val<br/>            }<br/>            <br/>            return sum<br/>        }()<br/>        <br/>        let gcd = gcdForArray(delays)<br/>        var frames = [UIImage]()<br/>        <br/>        var frame: UIImage<br/>        var frameCount: Int<br/>        for i in 0..&lt;count {<br/>            frame = UIImage(cgImage: images[Int(i)])<br/>            frameCount = Int(delays[Int(i)] / gcd)<br/>            <br/>            for _ in 0..&lt;frameCount {<br/>                frames.append(frame)<br/>            }<br/>        }<br/>        <br/>        let animation = UIImage.animatedImage(with: frames,<br/>            duration: Double(duration) / 1000.0)<br/>        <br/>        return animation<br/>    }<br/>}</span></pre><p id="3395" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，找到您选择的GIF并将其拖到您的项目中(确保它在根文件夹中，而不是在Assets.xcassets文件夹中)。出现提示时，确保选中“根据需要复制项目”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/09e07e4d354d888a23e3c0529aa67e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8Nb-DzL3i13ybywydHhVw.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7112" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备进行一些编码。在<code class="fe ml mm mn mb b">viewDidLoad()</code>中，将所有ARKit模板开始时的默认场景(名为“art . scna sets/ship . SCN”)替换为:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="a76f" class="mf mg iq mb b gy mh mi l mj mk">let scene = SCNScene()</span></pre><p id="845a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，创建一个名为<code class="fe ml mm mn mb b">addGif()</code>的函数，该函数接受一个字符串作为您添加到项目中的GIF的名称，并将返回一个<code class="fe ml mm mn mb b">SCNNode</code>。</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="5bce" class="mf mg iq mb b gy mh mi l mj mk">func addGIF(name: String) -&gt; SCNNode {<br/>  let gifNode = SCNNode()<br/> <br/>  return gifNode<br/>}</span></pre><p id="2aab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为该函数期望返回一个<code class="fe ml mm mn mb b">SCNNode</code>，我们创建了一个名为<code class="fe ml mm mn mb b">gifNode</code>的节点，并在函数结束时返回。现在，我们将借助之前导入的UIImage扩展对它应用GIF:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="1f3b" class="mf mg iq mb b gy mh mi l mj mk">func addGIF(name: String) -&gt; SCNNode {<br/>  let gifNode = SCNNode()</span><span id="7031" class="mf mg iq mb b gy mo mi l mj mk">  let gifPlane = SCNPlane(width: 1, height: 1)  <br/>  let gifImage = UIImage.gifImageWithName(name)<br/>  let gifImageView = UIImageView(image: gifImage)    <br/>  gifPlane.firstMaterial?.diffuse.contents = gifImageView</span><span id="1f8d" class="mf mg iq mb b gy mo mi l mj mk">  gifNode.geometry = gifPlane<br/>  gifNode.position = SCNVector3(0, 0, -1)<br/>  <br/>  return gifNode<br/>}</span></pre><p id="b266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生了什么事？首先，我们创建一个宽度和高度为1米的<code class="fe ml mm mn mb b">SCNPlane</code>(ARKit使用米)。接下来，我们用GIF的名字创建一个<code class="fe ml mm mn mb b">UIImage</code>，然后提供给<code class="fe ml mm mn mb b">gifImageView</code>。然后我们将<code class="fe ml mm mn mb b">gifImageView</code>作为一种材料应用于<code class="fe ml mm mn mb b">gifPlane</code>。反过来，我们将<code class="fe ml mm mn mb b">gifNode</code> <em class="mp">的</em>几何指定为<code class="fe ml mm mn mb b">gifPlane</code>的几何。最后，我们将it -1定位在Z轴上:距离我们第一次打开应用程序的地方一米。ARKit轴超出了本教程的范围——我推荐阅读<a class="ae kv" href="https://www.raywenderlich.com/378-augmented-reality-and-arkit-tutorial" rel="noopener ugc nofollow" target="_blank">这篇文章</a>以更好地了解它是如何工作的。</p><p id="e74f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要做一件事，才能看到我们的GIF在运行:用我们的<code class="fe ml mm mn mb b">viewDidLoad()</code>方法调用它。</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="d00a" class="mf mg iq mb b gy mh mi l mj mk">override func viewDidLoad() {<br/>  super.viewDidLoad()<br/>  . . .<br/>  sceneView.scene = scene</span><span id="ac3a" class="mf mg iq mb b gy mo mi l mj mk">  sceneView.scene.rootNode.addChildNode(addGIF(name: "giraffe"))<br/>}</span></pre><p id="0c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译您的代码并运行您的应用。厉害！您刚刚创建了第一个带有gif的ARKit应用程序(希望如此！)</p><p id="337c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随意检查<a class="ae kv" href="https://github.com/modium/ARKit-GIF-tutorial" rel="noopener ugc nofollow" target="_blank">完成代码</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这是我把这个工作流程和ARKit 2的图像检测结合起来做的</p></figure></div></div>    
</body>
</html>