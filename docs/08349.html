<html>
<head>
<title>Up Your React Game With Compound Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用复合组件增强您的React游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/up-your-react-game-with-compound-components-67560746671f?source=collection_archive---------9-----------------------#2021-04-20">https://betterprogramming.pub/up-your-react-game-with-compound-components-67560746671f?source=collection_archive---------9-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的React应用程序中构建出色的用户界面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/922ccfbf4afb23afd7d1a5b1872e8ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a1N0hcVa8PKdHWdn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@nahakiole?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Robin Glauser </a>拍摄的照片。</p></figure><p id="8255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名UI开发人员，最大的挑战之一是让您的代码可重用，同时保持它的整洁和可维护性。我相信这种模式很熟悉:</p><ul class=""><li id="6889" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您得到了您构建、测试和部署的组件的一些设计。一切看起来都很好。</li><li id="ffd7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个具有相似(但略有不同)功能的新特性出现了。您向组件添加一个道具或一些条件逻辑来处理这个新的用例，这是可行的，但是事情开始变得有点混乱。</li><li id="d557" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您构建组件的原始特性现在有了一些新的需求，您需要更新代码。但是您担心破坏组件的其他实例，并且编写覆盖所有逻辑的测试变得越来越困难。</li></ul><p id="7ad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况(或类似情况)经常发生。那么，我们能做些什么来避免陷入困境呢？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0ad1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">复合组件</h1><p id="4d8a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">复合组件是许多子组件以共享的状态一起工作来做一些有用的事情。这有点拗口，所以让我们看一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="764f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个简单的模态组件，它带有一个<code class="fe np nq nr ns b">header</code>、<code class="fe np nq nr ns b">body</code>和一个<code class="fe np nq nr ns b">onClose</code>道具。在这一点上，模态工作得很好，但不是特别灵活。如果出现了添加一个“确认”按钮或者能够传递JSX以呈现在主体中的需求，这将开始引起问题。您可以添加一些额外的逻辑来检查传递的内容，但是随着复杂性的增加，组件将变得不可维护:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f1ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们不得不进行一些检查，以便正确地呈现组件，随着需求的增长，这只会变得更加混乱。</p><p id="8d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看如何使用复合组件实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="28f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们已经将模型的每个部分设置为它自己的组件，使用<code class="fe np nq nr ns b">children</code>。然后，我们将每个组件作为静态属性分配给<code class="fe np nq nr ns b">Modal</code>组件。这部分是完全可选的，但是我喜欢这种模式，因为它显示了组件是显式链接的。</p><p id="5eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="752e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用点符号(例如<code class="fe np nq nr ns b">Modal.Header</code>)来访问子组件，现在我们可以将我们想要的任何功能作为子组件传递下去。这意味着我们的模态组件要灵活得多——所有的样式和格式都在内部处理，其他任何逻辑都作为子代传递——但是实际的模态代码也大大简化了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f299" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">更进一步</h1><p id="bc5a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我之前对复合组件的部分定义是“许多子组件在一个共享的状态下一起工作来做一些有用的事情。”模态示例已经很有用了，它将所有的样式抽象到一个地方，但是允许我们灵活地传递给它什么，但是子组件(例如<code class="fe np nq nr ns b">Modal.Header</code>或<code class="fe np nq nr ns b">Modal.Actions</code>)之间不共享任何状态。</p><p id="351c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何在子组件之间隐式共享状态呢？让我们看另一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了很多事情，让我们来分析一下。我们正在构建一个选择列表，它应该以类似于HTML <code class="fe np nq nr ns b">select</code>的方式工作:</p><ul class=""><li id="cefd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">首先，我们使用<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React的</a> <code class="fe np nq nr ns b"><a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">createContext</a></code>创建一个上下文。这就是我们在子组件之间共享状态的方式。</li><li id="2d70" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后我们设置我们的<code class="fe np nq nr ns b">SelectList</code>组件，它创建一个上下文提供者并将<code class="fe np nq nr ns b">isOpen</code>状态传递给提供者的值。我们现在可以在<code class="fe np nq nr ns b">SelectList</code>提供者的所有消费者中访问这个状态(和<code class="fe np nq nr ns b">setIsOpen</code>状态设置器)。</li><li id="baa7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们创建了一个<code class="fe np nq nr ns b">useSelectListContext</code>钩子，这样我们就不必重复调用<code class="fe np nq nr ns b">useContext(SelectListContext)</code>。</li><li id="4dfd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后，我们设置每个子组件(<code class="fe np nq nr ns b">SelectListToggle</code>、<code class="fe np nq nr ns b">SelectListDropdown</code>和<code class="fe np nq nr ns b">SelectListItem</code>)，它们呈现选项并处理打开、关闭和选择项目。</li><li id="e2f9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，我们将每个组件作为静态属性分配给<code class="fe np nq nr ns b">SelectList</code>组件，这样当我们使用它时，就可以使用点符号来访问它们。</li></ul><p id="0634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在映射我们的列表<code class="fe np nq nr ns b">options</code>，并将它们呈现为一个<code class="fe np nq nr ns b">SelectList.Item</code>。最棒的是，我们可以把小时候的任何东西传给我们的选项列表(例如图标或更全面的JSX)。对于在<code class="fe np nq nr ns b">SelectList</code>中呈现什么，我们有完全的灵活性，但是我们不必担心处理它的“打开”状态。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="94b0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="1e0f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">复合组件是一种非常强大的方法，可以使代码更加整洁，更加可重用。这种模式通常用在UI库中(例如<a class="ae ky" href="https://reach.tech/" rel="noopener ugc nofollow" target="_blank"> Reach UI </a>)，因为它给了开发人员在组件中呈现内容的完全灵活性，同时抽象出了所有重复的逻辑。</p><p id="90c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您会发现它在您自己的项目中很有用，并避免在新需求出现时陷入大家都很熟悉的重构地狱模式！</p></div></div>    
</body>
</html>