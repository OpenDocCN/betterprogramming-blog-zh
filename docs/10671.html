<html>
<head>
<title>Too Many Dependencies in iOS? Use the Composition Root Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中依赖太多？使用复合根模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-architecture-is-not-mvc-mvvm-m-5b34a04beb98?source=collection_archive---------1-----------------------#2022-01-21">https://betterprogramming.pub/ios-architecture-is-not-mvc-mvvm-m-5b34a04beb98?source=collection_archive---------1-----------------------#2022-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c18e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">iOS架构不仅仅是MVC、MVVM、M*</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7107eed4a3d893776be3348d73145533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wth2lmsP5bxG5cSHr0gLaA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:Undraw</p></figure><p id="0b50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你问一个iOS工程师，“你会用哪种架构来设计X应用？”，通常他们用MVC，MVVM，MVP等来回应。</p><p id="2843" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章将解释为什么这些流行的缩略语不能完全回答这个问题，并将展示一个替代的解决方案。</p><p id="1582" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MVC、MVVM、MVP是UI层设计或UI架构，而不是系统架构。</p><p id="3cf4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它们描述了UI层中的数据流和职责分离。它不回答任何关于导航、网络、缓存、业务逻辑等的问题。</p><p id="056f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将这些职责添加到UI层会创建具有大量依赖图的整体应用程序。这导致了重写，不可测试的代码，以及变更的高成本。</p><p id="c2df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">解决方案是将整体分解成模块化组件，并在“组合根<strong class="kx ir">”</strong>处将它们组合在一起。例如，您想要创建一个类似于Instagram的图片feed应用程序。</p><p id="56d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个常见的UI架构可能是这样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/29951daaec33b172cc73550403231c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5qxgl_SLJ4GrOY9q"/></div></div></figure><p id="8509" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用户选择一个<code class="fe ls lt lu lv b">FeedImageCell</code>并期望导航到一个<code class="fe ls lt lu lv b">FeedDetailedViewController</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/672ad34661b229884e5ed0e41b6be04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CP99qmyqEPpTp7-t"/></div></div></figure><p id="019a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码是一个常见的策略，它要求视图控制器负责导航和创建其子视图控制器。</p><p id="889f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，假设您的需求发生了变化，您现在需要实现日志功能，从远程或本地存储库中检索资源，并支持旧的操作系统。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/2404a6504a8a61e1bce70178a29f8539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8M9PAlKXClySwI7-"/></div></div></figure><p id="f75c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您使用<code class="fe ls lt lu lv b">URLSession</code>并在<code class="fe ls lt lu lv b">viewDidLoad</code>加载数据，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/d771fbc966735c24c47f1aed70873dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FIc5dfw8ieX8YgBt"/></div></div></figure><p id="2d28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当用户选择一个项目时，您检查以确定导航到哪个控制器并记录它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/98cf27ebaa8a20e82389db815ddf38a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s0dR2WhuNzQdOWXg"/></div></div></figure><p id="479e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些微小的变化需要开发者修改<code class="fe ls lt lu lv b">FeedViewController</code>。这违反了打开/关闭原则，因为可能的导航路径在编译时很早就确定了。</p><p id="6cf6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使我们通过构造注入注入依赖来延迟<code class="fe ls lt lu lv b">FeedViewController</code>的行为，我们仍然需要注入它创建的任何子视图控制器的依赖。</p><p id="df65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果子视图控制器有子视图控制器，我们就必须在根视图控制器中注入这些职责，并向下级联它们。这可能会在大型复杂的应用程序中无限期地持续下去，并给大量的依赖图带来严重的问题。</p><p id="8ac4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过将<code class="fe ls lt lu lv b">FeedViewController</code>与<code class="fe ls lt lu lv b">LoggingFramework</code>和<code class="fe ls lt lu lv b">URLSession</code>耦合，您已经可以看到在<code class="fe ls lt lu lv b">FeedViewController</code>周围形成的依赖网络。它的孩子拥有的任何依赖也将是它的依赖。</p><h1 id="9aa9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">满足构图根</strong>模式<strong class="ak">模式</strong></h1><p id="c137" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">复合根模式延迟了关于组件如何交互的决策，并允许我们拦截和修改行为。</p><p id="ea4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它存在于<code class="fe ls lt lu lv b">Main</code>模块中，这个概念对于大多数iOS工程师来说是陌生的。</p><p id="b562" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看如何在主模块中组成组件，以及如何分解这个整体。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/8a44f101995a9112326df4ad2c623b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MgCB0QB9gLnmwPLE"/></div></div></figure><p id="6244" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，<code class="fe ls lt lu lv b">FeedViewController</code>不再负责其子节点的创建和导航。</p><p id="ecf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">FeedComposer</code>组成了<code class="fe ls lt lu lv b">FeedViewController</code>，并把它和它所有的依赖项组装在一起。使用闭包，我们可以注入行为，而无需将UI模块组件与<code class="fe ls lt lu lv b">Networking</code>或<code class="fe ls lt lu lv b">Logging</code>模块耦合。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9e86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">FeedNavigation</code>处理路由，并通过其代表通知<code class="fe ls lt lu lv b">Logging</code>模块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7a7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意依赖关系的流动。主模块依赖于所有其他模块，而没有模块知道彼此。</p><p id="01a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过创建模块化代码并在组合根上将组件组合在一起，我们创建了模块之间的虚拟边界。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/a694bee0b8d539a60f7110ede99f44c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6E5wMLyD8teaPE3F"/></div></div></figure><p id="cc71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们希望我们的Feed应用程序在Apple Watch或Mac OS上运行。最初的方法是将UI层中的所有东西耦合起来，并将其命名为MVC/MVVM/M*，这需要完全重写。</p><p id="7123" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用我们的新方法，我们只需要重写<code class="fe ls lt lu lv b">FeedUI</code>模块，并在Main中的组合根处连接组件。所有的业务逻辑、网络、日志都将被重用。这就是模块化设计的力量。</p><p id="4bd1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读。完整的源代码可以在GitHub库中找到<a class="ae na" href="https://github.com/eak65/MediumCompositionPost" rel="noopener ugc nofollow" target="_blank"/></p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="0b7b" class="nf ma iq lv b gy ng nh l ni nj"><strong class="lv ir">Want to Connect?</strong></span><span id="090a" class="nf ma iq lv b gy nk nh l ni nj">You can reach out to me on <a class="ae na" href="https://twitter.com/itsEthanKeiser" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>