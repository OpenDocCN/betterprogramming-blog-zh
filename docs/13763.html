<html>
<head>
<title>Building and Managing an AWS Lambda Function That Sends Hourly Twitter Trends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建和管理AWS Lambda函数，该函数每小时发送Twitter趋势</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-and-managing-an-aws-lambda-function-that-sends-hourly-twitter-trends-962e55f57efa?source=collection_archive---------3-----------------------#2022-09-25">https://betterprogramming.pub/building-and-managing-an-aws-lambda-function-that-sends-hourly-twitter-trends-962e55f57efa?source=collection_archive---------3-----------------------#2022-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3b1c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于构建、部署和管理无服务器云功能的深入分析。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9b8e2901cac517c46868d0dc3ce80c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ais8sFPQegUGBIVZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰瑞米·贝赞格在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3193" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经有一个推特账户很长时间了。我用它来关注我喜欢的人，获取他们的更新，并与他们要说的话保持同步。如果我使用的一些服务关闭，比如说Reddit，我也会收到推文通知。</p><p id="c7ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我开始更加热衷于关注Twitter的趋势，这让我想到，“与其时不时地手动查看趋势，不如每小时更新一下Twitter的主要趋势？”。经过一番反复，我最终决定建立一个电报机器人，它每小时向我发送一条电报消息(一个我比Twitter更常用的平台)，其中包含Twitter的热门趋势。</p><p id="f586" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，是的，我很确定有一个更简单的方法来做到这一点，如果已经有一个电报机器人做到这一点，我不会感到惊讶。但是我喜欢自己构建东西，在整篇文章中，我相信您会找到许多不同的方法来完成我在这里尝试做的事情。</p><p id="521e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您将看到的，我选择了一种不那么直接的方法，尤其是在为这样一个简单的项目分配基础设施时。我可以很容易地启动AWS EC2实例，并放入代码来获取趋势，向其发送消息，并使用cronjob调度运行，但我没有这样做。为什么？</p><p id="5764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我是AWS新手，我想探索它的各种选项。基本上，我试图建立一个机器人，以及做一点探索AWS的无数服务。现在我已经完成了机器人的构建，我对自己的发现非常满意。事实上，我如此高兴，以至于我想写我的第一篇关于它的媒体文章！</p><h1 id="49ce" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码</h1><p id="6084" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，我需要至少有两个API才能工作:我使用Twitter API v1.1获取一个地方的趋势，使用Telegram API发送电报消息。我使用Python 3.10编写所有代码，并将<a class="ae kv" href="https://www.tweepy.org" rel="noopener ugc nofollow" target="_blank"> tweepy </a>模块作为Twitter API的包装器。</p><p id="8f58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还没有为电报API使用包装器，因为我唯一要做的事情就是向<code class="fe mp mq mr ms b"><a class="ae kv" href="https://core.telegram.org/bots/api#sendmessage" rel="noopener ugc nofollow" target="_blank">sendMessage</a></code>方法发出POST请求，令人惊讶的是，这个方法用于发送电报消息。</p><p id="a7a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用我的Twitter开发者账户创建了一个名为<code class="fe mp mq mr ms b">Trendagram</code>的Twitter开发者项目和一个名为<code class="fe mp mq mr ms b">TrendagramApp</code>的应用程序。这相当简单，Twitter有大量相关文档。我还为此创建了一个电报机器人，并将其命名为TrendagramBot。这可以通过与<a class="ae kv" href="https://t.me/BotFather" rel="noopener ugc nofollow" target="_blank">父亲</a>交谈来完成。</p><p id="d409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与使用任何API一样，我必须保护一些敏感的细节，比如应用程序令牌、密钥等。，基本上是我不想放入版本控制的任何东西。我喜欢的方法是把所有这些东西放入命名整齐的环境变量中。</p><p id="7a00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在部署过程中特别有用，因为可以针对不同的场景(生产、开发等)轻松定义和更改环境变量。我需要三个环境变量来运行代码。它们是:</p><ol class=""><li id="466e" class="mt mu iq ky b kz la lc ld lf mv lj mw ln mx lr my mz na nb bi translated"><code class="fe mp mq mr ms b">CHAT_ID</code>:这是我和机器人对话对应的电报聊天ID。当我向Telegram API发出请求时，这是必需的，这样机器人就知道向哪个会话发送消息。</li><li id="8c48" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe mp mq mr ms b">TRENDAGRAM_TELEGRAM_TOKEN</code>:这是唯一标识电报机器人的电报令牌。我在创建机器人时从机器人父亲那里得到了这个令牌。</li><li id="f44f" class="mt mu iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated"><code class="fe mp mq mr ms b">TRENDAGRAM_TWITTER_BEARER_TOKEN</code>:这是我用来授权我对Twitter API的请求的Twitter不记名令牌。我已经使用了<a class="ae kv" href="https://docs.tweepy.org/en/stable/authentication.html#oauth-2-0-bearer-token-app-only" rel="noopener ugc nofollow" target="_blank"> Tweepy的OAuth2功能</a>来初始化API。</li></ol><p id="3503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在所有这些都准备好了，我准备开始编写代码向Twitter API发出请求。第一段代码是授权。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6f50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我获得了承载令牌的环境变量的值，并使用它来初始化API。然而，我还能做更多的事情。Python使用了一种<a class="ae kv" href="https://docs.python.org/3/glossary.html#term-EAFP" rel="noopener ugc nofollow" target="_blank"> EAFP编码风格</a>，所以让我们把它封装在一个try-except块中来记录一个错误，以防我的环境变量中没有设置无记名令牌。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="61de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将它封装在一个函数中，如果没有抛出错误，这个函数将返回<code class="fe mp mq mr ms b">api</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="87f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加另一个函数，该函数调用<code class="fe mp mq mr ms b">get_api</code>函数并调用<code class="fe mp mq mr ms b"><a class="ae kv" href="https://docs.tweepy.org/en/stable/api.html#tweepy.API.get_place_trends" rel="noopener ugc nofollow" target="_blank">get_place_trends</a></code>方法来返回该位置的前50个趋势。位置是由一个非常过时的数字系统指定的，出于某种原因，Twitter仍在使用这个系统，称为<a class="ae kv" href="https://en.wikipedia.org/wiki/WOEID" rel="noopener ugc nofollow" target="_blank"> WOEID </a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码将在AWS Lambda函数中执行，因此我创建了另一个名为<code class="fe mp mq mr ms b">app.py</code>的模块，它具有Lambda <code class="fe mp mq mr ms b">handler</code>函数。</p><p id="45ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我得到了与电报相关的环境变量，如果可以，就调用上面给出的<code class="fe mp mq mr ms b">get_trends</code>函数。然后，我迭代趋势，生成必须发送的消息内容。</p><p id="8d12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我使用<a class="ae kv" href="https://docs.python-requests.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> requests </a>库向Telegram API发出POST请求，将消息作为TrendagramBot发送给我与Bot的转换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3a4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Lambda函数的日志以日志流的形式通过Lambda的默认执行角色进入AWS CloudWatch，在AWS领域，仅仅打印到标准输出被认为是可以的。</p><p id="981a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还对应用程序文件进行了Docker化，这样Lambda函数将在Docker容器中运行。为此，我编写了如下docker文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="52a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS为少数几种语言提供Docker镜像，作为你Docker化应用的基础，Python就是其中之一。在docker文件的第一行，我从AWS获取了基于Python的Lambdas的最新图像。我为构建Python映像设置了一些推荐的环境变量，并使用pip在<code class="fe mp mq mr ms b">requirements.txt</code>中安装包。我还将Python模块<code class="fe mp mq mr ms b">trends.py</code>和<code class="fe mp mq mr ms b">app.py</code>复制到由环境变量<code class="fe mp mq mr ms b">LAMBDA_TASK_ROOT</code>描述的目录中，该环境变量是由AWS提供的基础映像中的<a class="ae kv" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime" rel="noopener ugc nofollow" target="_blank">定义的。</a></p><p id="9b1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当容器运行时，被调用的函数是<code class="fe mp mq mr ms b">app.py</code>中的处理函数，这在Dockerfile文件的最后一行提到。</p><p id="f389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我可以轻松地部署这个应用程序，而根本不用Dockerizing，因为Lambda本身就支持Python语言，但是我故意让Lambda函数作为Docker容器运行。这不是必须的，但老实说，我这么做只是为了学习一两件关于运行Lambda容器的事情。</p><p id="4c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在按照本文的思路做一些事情，您可以创建一个Lambda函数，选择Python语言，使用这段代码，然后就到此为止。但是，这有什么意思呢？😉</p><h1 id="507a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基础设施</h1><p id="07e9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这一点上，我有了可以作为Lambda容器运行的功能代码(实际上，我可以运行带有作为<code class="fe mp mq mr ms b">None</code>的<code class="fe mp mq mr ms b">event</code>和<code class="fe mp mq mr ms b">context</code>参数的<code class="fe mp mq mr ms b">app.handler</code>函数，代码的行为与Lamba触发器相同)。所有代码都可以在<a class="ae kv" href="https://github.com/advaithhl/Trendagram" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得，git是版本控制的选择，GitHub是远程存储库主机的选择。</p><h1 id="7e7c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摘要</h1><p id="08e5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">主要思想是让AWS构建代码，或者更具体地说，在每次推送GitHub时构建Docker映像。这个构建的图像是我的Lambda函数的基础。一旦这个Lambda函数使用基于最新代码构建的映像进行了更新，就应该每小时使用一次cronjob来触发它。就是这样！不完全是。让我们详细看看每个步骤。</p><h1 id="f79d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">构建代码</h1><p id="8c2b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了构建代码，我使用AWS CodeBuild和作为GitHub的源代码提供者，并将所有其他选项保留为默认选项。这样，每次推送GitHub存储库时，都会自动触发AWS CodeBuild作业。但是AWS如何知道如何构建代码呢？默认情况下，CodeBuild会查找一个<code class="fe mp mq mr ms b">buildspec.yml</code>文件，并根据那里提供的配置编译代码。</p><p id="f853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS <a class="ae kv" href="https://docs.aws.amazon.com/codebuild/latest/userguide/sample-docker.html#sample-docker-files" rel="noopener ugc nofollow" target="_blank">为</a>提供一个整洁的<code class="fe mp mq mr ms b">buildspec.yml</code>文件来构建docker映像，并将构建好的代码推送到AWS弹性容器注册表(ECR)中，标签为<code class="fe mp mq mr ms b">latest</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/ae77a9eab6056501ad00ec6a5fb90c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zn1pUtcwbxdOLmhDQJ__ug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">已经创建了CodeBuild项目，用于构建映像并将其推送到ECR。</p></figure><p id="7a58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我还创建了一个发送SNS通知的通知规则。这可以通过点击“通知”&gt;“创建通知规则”，并填写表格来完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/f95dc2866a823ae29840a6b5d434b38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUIgy_Ugw2wFReA0FnVyyg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">成功完成构建时会触发此通知。</p></figure><p id="0ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我创建了一个新的SNS主题来推送通知。这可以通过到目标，点击“创建目标”按钮，选择“SNS话题”，并选择一个名称(我命名为我的<code class="fe mp mq mr ms b">codestar-notifications-trendagram-codebuildsuccess</code>)来完成。是的，我知道，这个名字很乏味)。</p><p id="08b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，这个主题没有订阅者(消息不会被任何服务监听)，但是我马上会谈到这一点。</p><p id="8386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我已经有了构建代码并将其推送到AWS ECR的基础设施。让我们从那开始更进一步。</p><h2 id="0600" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">Lambda部署者</h2><p id="7886" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在摘要部分，我已经提到一旦Lambda函数“用最新代码构建的映像更新”，我就可以每小时触发它。为了更新Lambda函数，我需要另一个Lambda函数，从现在开始我将把它称为“部署者”，原生运行在Python上。</p><p id="3673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您可能想知道为什么我需要一个部署者函数来更新这个函数。这是因为据我所知，如果代码后端基于容器映像，AWS Lambda函数不会自动更新它们的代码后端。</p><p id="6a36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">deployer函数使用AWS Python SDK的<code class="fe mp mq mr ms b">update_function_code</code> <a class="ae kv" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/lambda.html#Lambda.Client.update_function_code" rel="noopener ugc nofollow" target="_blank">方法</a>(<a class="ae kv" href="https://aws.amazon.com/sdk-for-python/" rel="noopener ugc nofollow" target="_blank">boto 3</a>)，将容器的基础映像更新为最近构建并由CodeBuild推送到ECR的映像。一旦我有了正确的环境变量，这就很容易完成了(正如我们之前看到的，这只是为了确保敏感内容远离代码，而不是将配置与逻辑混淆)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="db79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦被触发，<code class="fe mp mq mr ms b">lambda_handler</code>将被调用，并且<code class="fe mp mq mr ms b">update_function_code</code>所需的参数将从环境变量中加载。</p><p id="45e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">FUNCTION_NAME</code>对应于我想要更新的函数的函数<a class="ae kv" href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" rel="noopener ugc nofollow" target="_blank"> ARN </a>(在本例中是Trendagram函数)。<code class="fe mp mq mr ms b">IMAGE_URI</code>对应ECR图像(最近建立的图像)的ARN，<code class="fe mp mq mr ms b">PUBLISH</code>对应环境变量<code class="fe mp mq mr ms b">PUBLISH_ON_DONE</code>的值。这个变量可以是<code class="fe mp mq mr ms b">True</code>或<code class="fe mp mq mr ms b">False</code>，这取决于我是否想立即发布<code class="fe mp mq mr ms b">FUNCTION_NAME</code>。</p><p id="5fa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我给了它一个回退值<code class="fe mp mq mr ms b">True</code>。一旦完成，就会调用实际的函数来更新代码，并将响应打印到标准输出中。</p><p id="c530" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经为部署器添加了一个触发器，这样在来自<code class="fe mp mq mr ms b">codestar-notifications-trendagram-codebuildsuccess</code>的每条消息上(再次，抱歉用了这个名字)，部署器都会运行。这很好，因为只有在代码成功构建后，消息才会通过这个SNS主题(这正是我想要部署Trendagram的时候)。</p><p id="40a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还创建了另一个名为<code class="fe mp mq mr ms b">trendagram_codedeploysuccess</code>的SNS主题，并将其设置为部署者的“目的地”。这将在每次成功运行deployer函数时通过SNS主题推送一条消息。</p><p id="7681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在SNS主题页面中，我添加了一个订阅，协议为<code class="fe mp mq mr ms b">EMAIL</code>，端点为我的电子邮件ID，这样我就可以在每次成功部署时收到一封电子邮件。这封邮件确实有点“难看”，因为它是直接来自SNS主题的原始JSON，但我认为这没什么，因为我真的只需要确认到目前为止一切顺利。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/d0aa2b5bf24d772b0be0d936bb6d2735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmy-GQPPS79_DkCea3FWhw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">部署者功能同<code class="fe mp mq mr ms b">codebuildsuccess as the trigger and codedeploysuccess as the destination.</code></p></figure><h2 id="ecd6" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">趋势图触发器</h2><p id="c85b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">此时，正在运行的Trendagram函数基于最新的代码。但是我还没有给它添加任何触发器。就像我之前说的，我需要每小时跑一次。为此，我使用AWS EventBridge(以前的CloudWatch Events)通过在“Schedule expression”字段中提供一个cron表达式来触发该函数。AWS在这里提供了进度表达式格式<a class="ae kv" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html" rel="noopener ugc nofollow" target="_blank">的详细信息。所有cron表达式都用UTC计算。</a></p><p id="a077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将我的时区转换为UTC，并发现我需要该函数在UTC的3:30到15:30之间每小时触发一次，因为当我居住的地方是晚上时，我不需要通知。对应的cron表达式竟然是<code class="fe mp mq mr ms b">30 3-15 * * ? *</code>。这样，AWS EventBridge将按照我定义的cron表达式触发Trendagram函数。</p><h1 id="a74d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="787d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这篇文章中，我描述了如何使用服务组合来获取最新的Twitter趋势，并通过Telegram发送给我。我用git做版本控制，用GitHub存储代码，用AWS CodeBuild构建代码，用AWS Elastic Container Registry将构建好的代码存储为Docker映像，用AWS Cloudwatch记录一切，用AWS Lambda将构建好的代码部署并运行为Docker容器。</p><p id="68a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该代码支持主要的Lambda函数，该函数使用Twitter API获取趋势，并使用Telegram bot API发送趋势。按照给定的cron表达式，主Lambda函数由AWS EventBridge触发。</p><p id="ab16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还可以做更多的事情来进一步扩展这一点。我可以使用<a class="ae kv" href="https://docs.tweepy.org/en/stable/authentication.html#legged-oauth" rel="noopener ugc nofollow" target="_blank">三脚OAuth </a>来验证其他用户，也许可以得到他们的个性化趋势，而不是位置趋势。我可以通过其他平台发送趋势，比如<a class="ae kv" href="https://docs.python.org/3/library/email.html" rel="noopener ugc nofollow" target="_blank">电子邮件</a>。我可以添加一个<a class="ae kv" href="https://docs.aws.amazon.com/apigateway/index.html" rel="noopener ugc nofollow" target="_blank"> AWS API Gateway </a>触发器，或者利用Lambda最新的<a class="ae kv" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-urls.html" rel="noopener ugc nofollow" target="_blank">函数URL </a>特性，作为随时显式触发Trendagram的方式。</p><p id="a230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">归根结底，可能性几乎是无穷无尽的，我很高兴这些技术的存在，而且经常是免费的！</p><p id="6947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你怎么想呢?请在评论区告诉我你对此和整篇文章的想法。感谢你阅读我的文章，我希望你有一个伟大的一天！</p></div></div>    
</body>
</html>