<html>
<head>
<title>Build a Dominoes Game in SwiftUI (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中构建多米诺骨牌游戏(第3部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-dominoes-game-in-swiftui-part-3-c96e29b8101e?source=collection_archive---------26-----------------------#2020-04-20">https://betterprogramming.pub/build-a-dominoes-game-in-swiftui-part-3-c96e29b8101e?source=collection_archive---------26-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">网络版</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a82cb3a96e88aabef0a64b9f484e2997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBf6MbhKU7Fx6P_nnbrenw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tata186?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">塔蒂亚娜·罗德里格兹</a>在<a class="ae ky" href="https://unsplash.com/s/photos/domino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/better-programming/build-a-dominoes-game-in-swiftui-part-2-188b825cc35a" rel="noopener">的前一篇文章</a>中，我浏览了一桶模板代码，这些代码是使网络运行起来所需要的。我创建了一个非常简单的服务器/客户端应用程序。然后我修改了界面，开始使用新的界面构建多米诺骨牌II。</p><p id="4ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我计划从我们停止的地方继续。我们有相当多的事情要做。这是我整理的任务清单。我们基本上完成了其中的第一个项目，然后遇到了一些困难。我稍微改变了一下规则，因为这是电子骨牌。</p><ul class=""><li id="396b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">你在局域网上宣传一款游戏。你的朋友运行搜索，看到你，选择你，并加入游戏。</li><li id="3174" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您发回一条包含所选domino对的消息。这个想法是同步你的设置。</li><li id="8c34" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您将一个牌放入游戏中，并将其ID和新位置发送给他们。你的朋友也一样。你们继续轮流玩，直到用完牌或不能玩为止。</li><li id="4dd2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果你选择了一个多米诺骨牌，不能添加到任何一端，那么你就失去了这个回合。另一个玩家走了，尽管你翻过的牌仍然是你的。</li><li id="02f2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">游戏的赢家将是没有剩余牌的人，假设不再有任何牌可以翻转，并且他们已经将所有的牌放置在游戏中。然而，有可能游戏结束时你们都还剩下一两张牌，所以我们不能把这作为终止条件。</li></ul><p id="17ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我确实认真考虑过在我的UDP守护进程旁边运行一个TCP守护进程，但是后来我想到了一个更简单的方法。我需要创建一个新的combine publisher，通过用特定的消息触发它来让应用程序改变页面，下面的代码就是这样做的。那么，我要对<code class="fe mj mk ml mm b">ContentView.swift</code>做两处改动。</p><p id="37c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<strong class="lb iu">但是打住，现在不要改这两个文件</strong>。我这次把一些mega gists的改动都贴在文末了。)</p><p id="6676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一块发送游戏邀请。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="cf9c" class="mr ms it mm b gy mt mu l mv mw">Button("Play") {<br/>  self.udpCode.bonjourToUDP(self.name)<br/>  self.env.currentPage = .SecondPage<br/>  DispatchQueue.main.asyncAfter(deadline: .now() + 2, execute: {<br/>    self.udpCode.sendUDP("@ComePlay:" + UIDevice.current.name)<br/>  })<br/>}</span></pre><p id="799a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个作用于它。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="984e" class="mr ms it mm b gy mt mu l mv mw">let nextPagePublisher = PassthroughSubject&lt;String, Never&gt;()</span><span id="0219" class="mr ms it mm b gy mx mu l mv mw">...</span><span id="365a" class="mr ms it mm b gy mx mu l mv mw">.onReceive(nextPagePublisher) { ( clientName ) in<br/>  self.udpCode.bonjourToUDP(clientName)<br/>  self.env.currentPage = .SecondPage<br/>}</span></pre><p id="18c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，有一小部分被添加到<code class="fe mj mk ml mm b">UDPNetwork.swift</code>文件中来接收和操作这个方法。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="f566" class="mr ms it mm b gy mt mu l mv mw">if backToString.contains("@ComePlay:") {<br/>  let clientName = backToString.replacingOccurrences(of: "@ComePlay:", with: "")<br/>  nextPagePublisher.send(clientName)<br/>}</span></pre><p id="0d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的下一步是打开<code class="fe mj mk ml mm b">Dominoes.swift</code>项目，并将它的<code class="fe mj mk ml mm b">contentView.swift</code>复制粘贴到一个新文件中，我将用与我现有项目相同的名称来命名它。</p><p id="c801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将刚刚复制粘贴到当前构建中的原始<code class="fe mj mk ml mm b">Dominoes.swift</code>项目中的<code class="fe mj mk ml mm b">ContentView.swift</code>重命名。现在我们开始工作了，尽管我们还需要一些新的功能。我们谈到了第二个需求，即需要将选定的多米诺骨牌与我们的两个玩家同步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/5402411abfbe3ac64f5c84816ae63bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcNQrSDZ1bVqAVICZ3koPg.png"/></div></div></figure><p id="f36a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切换到(我制作的多米诺骨牌的)第二页将会展示棋盘和多米诺骨牌，但是他们有自己的一套。我们需要发送第二个命令。</p><p id="5683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下现有的代码。方法<code class="fe mj mk ml mm b">allocateViews</code>返回一个结构，其中充满了图像。它们将与我在第二个客户端中的图像相同，发送这些图像毫无意义。我们只需要发送它配对的多米诺骨牌列表。</p><p id="0e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将该功能一分为二，并引入第三个命令，我从第一个设备的第二页发送该命令，在它出现后有一个短暂的延迟(4秒)。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="628d" class="mr ms it mm b gy mt mu l mv mw">if prime {<br/>  DispatchQueue.main.asyncAfter(deadline: .now() + Double(4)) {<br/>    let string2send = tiles.joined(separator: ",")<br/>    debugPrint("Sending DominoesSet ",string2send)<br/>    self.env.udpCode.sendUDP("@DominoesSet:" + string2send)<br/>  }<br/>}</span></pre><p id="e4ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此处显示的主要变量是在建议初始链接时设置的。这是为了确保我们不会以循环结束，玩家A发送他们的集合，然后玩家B发送回相同的集合。</p><p id="6424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Bug</strong>——但是等等，我被我在<a class="ae ky" href="https://medium.com/better-programming/build-a-dominoes-game-in-swiftui-part-2-188b825cc35a" rel="noopener">第二部</a>中犯的一个错误岔开了，一个在方法<code class="fe mj mk ml mm b">received8192</code>和初始<code class="fe mj mk ml mm b">ContentView</code>上的愚蠢错误。我警告过你不要犯这个错误。在<code class="fe mj mk ml mm b">ContentView</code>中，我用这个发送了来玩的邀请:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="9fde" class="mr ms it mm b gy mt mu l mv mw">self.env.udpCode.sendUDP("@ComePlay:" + UIDevice.current.name)</span></pre><p id="c81a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">UDPNetwork</code>中，我用8192版本的<code class="fe mj mk ml mm b">receive</code>方法接收并处理它，其中有一个严重错误:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="f068" class="mr ms it mm b gy mt mu l mv mw">if connection.state == .ready &amp;&amp; isComplete == false &amp;&amp; recursive {<br/>  print("re-running")<br/>  self.receive8192(on: connection, recursive: true)<br/>}</span></pre><p id="6412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能发现它吗？当然，这是可以使用的正确版本。它成功了，返回了我发给它的数据，然后运行上面那行代码。问题出在<code class="fe mj mk ml mm b">isComplete variable</code>上。通过使用<code class="fe mj mk ml mm b">send</code>假设数据包大小小于8192，它会将<code class="fe mj mk ml mm b">isComplete</code>标记为<code class="fe mj mk ml mm b">true</code>。</p><p id="9809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个版本，我能够发送一个初始包并读取它，但仅此而已。因为该包小于8192字节，并且<code class="fe mj mk ml mm b">isComplete</code>被设置为<code class="fe mj mk ml mm b">true</code>，所以该方法退出。</p><p id="2904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在要点里，我把它改成了<code class="fe mj mk ml mm b">true</code>，和这个项目一起工作。但是要注意:如果你一次发送超过8192字节，它会再次中断。我认为事实是，您需要以不同的方式使用这个标志，而不是在它重新运行<code class="fe mj mk ml mm b">receive8192</code>方法时进行管理。或者至少做好退出的准备。</p><p id="8b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个小时后(是的，我花了很长时间才发现那个愚蠢的错误)，我让它工作了。现在已经让两个玩家在同一页上，我需要一种方法来标记谁玩了什么。</p><p id="8a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是别说了。那是什么意思？我不能删除它们。玩家A和玩家B共用一组牌，所以他们需要知道所有的牌。但是我们需要对某种形式的所有权进行编码。</p><p id="74c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我首先想到的是把它添加到我创建的结构中，但是没有。我不能这么容易地改变结构中的值。</p><p id="864d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一站，看起来是一个有希望的候选人。它已经包含了多米诺骨牌在棋盘上的位置及其方向。我在<code class="fe mj mk ml mm b">DominoWrapper</code>中为domino片段所有权和枚举创建了一个状态。我把它设为可选，这样我就有三种状态:玩家A，玩家B，或者没有玩家。</p><p id="2605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着记下更多的规则，因为我已经迷路了。</p><ul class=""><li id="e2e0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当你触摸多米诺骨牌时，所有权将被分配。</li><li id="38f3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">你不能与其他玩家的多米诺骨牌互动。这不仅仅是一个“禁止接触”的政策，而是一个“绝不”的政策。</li><li id="df04" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当其他玩家将多米诺骨牌放在棋盘上时，你只能看到他们的多米诺骨牌。发行的和从未发行的那堆中取出的仍然是秘密的，不可选择的。</li><li id="6c00" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">你不能偷看其他的多米诺骨牌，当轮到你的时候你只能选择一个。你没有第二口苹果。</li><li id="38ed" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">拿走一张多米诺骨牌并不意味着把它放在场上。它只是把它加到你所拥有的、你需要摆脱的东西上。</li><li id="3f90" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们需要一些方法来指示是轮到你走，还是其他玩家走。</li></ul><p id="9fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这又是一个又长又令人生畏的清单，我们还没有完成第一个。唷。</p><p id="7250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们需要一个全局变量，并将其设置为该设备的播放器。我们将它设置在<code class="fe mj mk ml mm b">ContentView</code>，随后设置在<code class="fe mj mk ml mm b">UDPNetwork</code>。顺便说一句，我不认为最终将所有这些自定义代码添加到网络方法中是一件好事。也许我们需要在某个时候重新审视这个结构。</p><p id="4054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个完美的地方来分配会员资格，也就是当你翻开多米诺骨牌的时候。我也需要一个全局变量来表示该轮到谁了。一号玩家开始游戏。</p><p id="31ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想自动化轮流。毕竟，我们正在使用网络，所以两个玩家很可能在同一个房间里，老实说，我们最不需要的就是游戏因为愚蠢的接口错过了一个UDP包而陷入僵局。</p><p id="b87f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在界面上添加一个按钮来控制轮到谁。下面是我添加的代码，以使轮流工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽可能保持简单，我也把这个加到了<code class="fe mj mk ml mm b">UDPNetwork</code>:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="9b7e" class="mr ms it mm b gy mt mu l mv mw">if backToString.contains("@YourTurn:") {<br/>  turn = player<br/>  turnPublisher.send()<br/>}</span></pre><p id="b75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的工作方式是，最初的一会儿，两条消息都以绿色背景出现。当第二个设备从第一个设备加载domino set时，它会变成红色。我也需要换这一小块。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="3a65" class="mr ms it mm b gy mt mu l mv mw">.onReceive(redoDominoes) { ( data ) in<br/>(self.novelleViews.nouViews, tiles) = redoImages(tileString: data)<br/>  turnPublisher.send()<br/>}</span></pre><p id="9116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要我邀请的第二台设备也连接到我。我们需要另一条自定义消息。我需要这样做来发送我最后一次移动的坐标。您应该还记得上一篇文章，UDP网络不是双向通道。</p><p id="41dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当界面中注册了“拖动结束”状态时，我可以在已建立的通道上发送的坐标。我需要在该消息中标识我移动了哪个多米诺骨牌，以及它的坐标。</p><p id="5693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是发送移动数据比看起来要复杂一些。我无法通过网络链接发送未编码的数据。我的数据需要采用不会给系统带来混乱的格式。我需要把它编码。字符串没问题，但是数字，需要编码。</p><p id="1eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift的一个简单选项，也是一个国际标准，是JSON。让我们对坐标进行编码，并在JSON包中嵌入一个ID。第一步是定义一个存储它的结构，使它可以编码和解码。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="a7e0" class="mr ms it mm b gy mt mu l mv mw">struct moverNshaker: Encodable, Decodable {<br/>  var dragID: Int!<br/>  var dragOffset: CGSize!<br/>  var dragAccumulated: CGSize!<br/>}</span></pre><p id="2ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是对它进行编码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="57a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，在接收端，我们需要解码JSON。下面是我用来做这件事的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fabd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用另一个发布者向<code class="fe mj mk ml mm b">DominoWrapper</code>类发送消息，通知它这个移动。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="4567" class="mr ms it mm b gy mt mu l mv mw">.onReceive(movePublisher, perform: { ( cords ) in<br/>  if cords.dragID == self.column {<br/>    withAnimation {<br/>    self.dragOffset = cords.dragOffset<br/>    self.accumulated = cords.dragAccumulated<br/>  }<br/>}<br/>})</span></pre><p id="a68e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这里有一些移动的可能性。我们没有坚持让他们翻过多米诺骨牌，即使一号玩家翻过，二号玩家仍然只能看到骨牌的背面。我们需要在2号玩家的多米诺骨牌移动后翻转它。我们还需要发送它的方位。我很想简单地把它添加到我们定义的<code class="fe mj mk ml mm b">moverNShaker</code>结构中，但是它是视图中的一个状态变量，是视图的一个子视图，拖动也是附加的。</p><p id="494b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做和刚才移动时一样的工作，但是用<code class="fe mj mk ml mm b">longPressGesture</code>和<code class="fe mj mk ml mm b">doubleTapGesture</code>。我没有时间解释我是如何做到的，但是基本的方法和我刚刚概述的是一样的。我必须承认，我确实很难让背景远程扭曲，所以我作弊，只是让它看不见。</p><p id="5cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要实现多米诺骨牌的自动翻转，这样只要我远程将多米诺骨牌放入游戏，它就会翻转过来。我们可以很容易地通过创建一个<code class="fe mj mk ml mm b">autoTurnPublisher</code>，将它链接到启动转动机制，并设置为与<code class="fe mj mk ml mm b">movePublisher</code>一起发射。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="9d32" class="mr ms it mm b gy mt mu l mv mw">.onReceive(autoTurnPublisher) { ( domino ) in<br/>  if domino == self.$column.wrappedValue {<br/>    withAnimation(Animation.linear(duration: 2.0).delay(0)) {<br/>      self.spin = 180<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="684c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从功能上讲，此时我们已经有90%的代码就位。多米诺骨牌的网络游戏是可能的。我想写更多，但在2000+字，我已经达到了文章的限制。这里有一个当前应用程序和我在文章开头提到的mega gists的快速截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/0f59c6a5e5918f684265e5a064f9fd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Xg33cf7xnBH5zh4rBemyA.png"/></div></div></figure><p id="cafa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们重新制作的<code class="fe mj mk ml mm b">UDPNetwork.swift</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="016c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有我们重新制作的<code class="fe mj mk ml mm b">ContentView.swift</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有我们重新制作的<code class="fe mj mk ml mm b">Dominoes.swift</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您已经阅读了第二部分，那么您已经拥有了<code class="fe mj mk ml mm b">BonjourBrowser.swift</code>，这是您将这篇文章变得生动所需要的唯一的另一个类。非常欢迎你更进一步。以下是我的待办事项清单中最重要的事情:</p><ul class=""><li id="1b1a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我从不宣布赢家。我让玩家自己决定。</li><li id="2763" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我不阻止你玩其他玩家的多米诺骨牌，尽管我怀疑这是一个相当容易的解决办法。</li><li id="4817" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">你可以想看多少张多米诺骨牌就看多少张，但是当你这样做的时候，它会把所有权分配给你——你拥有的多米诺骨牌越多，你就越需要扔掉。</li><li id="8f79" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后一个偷看多米诺骨牌的人成为主人，这意味着，在现实中，这是一场比赛，为了获胜，你要在你的伙伴之前翻转尽可能多的多米诺骨牌。这一方面听起来不错，但另一方面，如果你知道这条规则，而你的伴侣却不知道，那就非常不公平了。</li><li id="5b95" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果有某种迹象表明谁最终拥有棋盘上的什么，那就更好了。事实上，我认为这不是可有可无的，这是停止之前行为的必要条件。</li></ul><p id="0cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可能会做第四部分，我会试着解决所有这些待办事项，也许还会再做一些。我们走着瞧。</p></div></div>    
</body>
</html>