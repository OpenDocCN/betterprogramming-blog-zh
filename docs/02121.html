<html>
<head>
<title>CRUD Operations With Core Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核心数据的CRUD操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-persist-data-with-core-data-9085b7943f42?source=collection_archive---------6-----------------------#2019-11-07">https://betterprogramming.pub/how-to-persist-data-with-core-data-9085b7943f42?source=collection_archive---------6-----------------------#2019-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1d80" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">IOS编程指南</h2><div class=""/><div class=""><h2 id="aa98" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">有时候本地存储是一个应用程序所需要的</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9c54dd5b039156a57962a8559b801829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wN5t9ILU0fpnhbMX2vtng.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.pexels.com/photo/abstract-art-blur-bright-373543/" rel="noopener ugc nofollow" target="_blank">像素上的照片</a></p></figure><p id="edcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在的移动应用程序大部分时间都使用某种远程存储，但有时你可能会遇到需要在本地保存数据的特殊情况。它可以用来确保您的应用程序脱机工作。建立连接后，您可以将数据同步回远程服务器。在iOS中有多种方法可以实现这一点。可以用SQLite，iCloud，Firebase等。，但是我们将看看如何使用核心数据来实现这一点。</p><p id="60b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简而言之，去<a class="ae lh" href="https://github.com/Petey509/myToDoList" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载我们将在学习使用核心数据的整个过程中使用的启动项目。喝杯咖啡或茶，或者任何你喜欢的饮料；我会等的。</p><p id="5302" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">准备好了吗？让我们开始吧。我们将添加、检索、删除和更新我们的本地存储。但首先，什么是核心数据？</p><p id="23df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">核心数据用于保存应用程序的永久数据以供离线使用，缓存临时数据，以及在单个设备上为应用程序添加撤销功能。</p><p id="e9cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更多信息，请访问苹果的<a class="ae lh" href="https://developer.apple.com/documentation/coredata" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="9559" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的启动项目是一个简单的表格视图，能够添加、编辑和删除任务，因此得名myToDoList。构建并运行项目。添加一些记录，关闭并重新打开模拟器。你会发现你的数据不见了。我们的应用程序还没有持久化数据。我们将修改它来解决这个问题。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="0102" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">保存数据</h2><p id="f274" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">为了保存数据，我们需要创建核心数据模型。它将用于执行CRUD(创建/读取/更新/删除)操作。先说车型。</p><p id="5583" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">点击<code class="fe ni nj nk nl b">MyToDoList.xcdatamodeld</code> &gt;添加实体。双击实体，将其重命名为Task。单击属性部分下方的+号。命名属性id并选择字符串作为类型。再次单击+号，将属性重命名为name，并选择String作为类型。选择id和name属性，并取消选中可选复选框。我们完成了模型。那不是超级简单吗？您的屏幕应该是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/d1cab187fd9082b251313d36407cdffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Guq7tej4xDo6LXy-9xFUjw.png"/></div></div></figure><p id="60bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们需要修改代码来使用模型保存我们的任务。我们需要首先构建以生成模型。按Command + B来构建。一旦构建成功，打开<code class="fe ni nj nk nl b">MyToDoTableViewController.swift</code>文件。有时，由于某种原因，模型无法生成。为了确保我们不会遇到这种情况，请完全关闭Xcode并重新打开项目。应该会为您生成一个类名任务。</p><p id="2291" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在导入UIKit后添加导入核心数据。</p><p id="7c2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们使用了一个字符串，现在使用了一个对象，所以我们会得到一些错误。我们需要先修复它们，然后才能开始使用核心数据。</p><p id="a2fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">进行以下更改。</p><pre class="ks kt ku kv gt nn nl no np aw nq bi"><span id="06fb" class="ml mm it nl b gy nr ns l nt nu">//replace<br/>var taskNames : [String] = []<br/>//with<br/>var taskNames : [Task] = []<br/>let appDelegate = UIApplication.shared.delegate as! AppDelegatelet <br/>let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext</span><span id="dcba" class="ml mm it nl b gy nv ns l nt nu">//replace<br/>textField.text = self.taskNames[self.selectedIndex]<br/>//with<br/>textField.text = self.taskNames[self.selectedIndex].name</span><span id="e41d" class="ml mm it nl b gy nv ns l nt nu">//replace <br/>addTask(taskName: self.taskName.text!)<br/>//with<br/>let _task = Task(context: self.context)<br/>_task.name = self.taskName.text!<br/>_task.id = UUID().uuidString<br/>addTask(task: _task)</span><span id="1a45" class="ml mm it nl b gy nv ns l nt nu">//change the method signature from<br/>func addTask(taskName:String)<br/>//to<br/>func addTask(task:Task)</span><span id="4057" class="ml mm it nl b gy nv ns l nt nu">//replace<br/>self.taskNames.append(taskName)<br/>//with<br/>self.taskNames.append(task)</span><span id="ea1f" class="ml mm it nl b gy nv ns l nt nu">//replace<br/>self.taskNames[self.selectedIndex] = taskName<br/>//with<br/>self.taskNames[self.selectedIndex].name = taskName</span><span id="a582" class="ml mm it nl b gy nv ns l nt nu">//replace <br/>cell.textLabel?.text = self.taskNames[indexPath.row]<br/>//with<br/>cell.textLabel?.text = self.taskNames[indexPath.row].name</span></pre><p id="55c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在应该能够构建和运行我们的项目了。继续点击构建按钮，然后点击运行按钮。您应该能够添加、删除和编辑。要编辑，请选择一个单元格，弹出窗口应该会显示出来。</p><p id="5eb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，我们所做的只是让我们的项目使用我们之前创建的核心数据模型。我们现在来看一下代码。</p><p id="a0d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ni nj nk nl b">taskNames</code>是我们用来存储数据的集合。</p><p id="cd7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ni nj nk nl b">context</code>是我们保存数据所需要的。</p><p id="0523" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们不打算报道<code class="fe ni nj nk nl b">viewContext</code>,因为苹果在这个主题上有很好的文档。我们只打算用它。知道它允许访问本地存储。如果你想了解更多，请访问苹果的文档。</p><p id="e5a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要保存任务，转到<code class="fe ni nj nk nl b">addTask</code>方法并在最后一行后添加这一行代码。</p><pre class="ks kt ku kv gt nn nl no np aw nq bi"><span id="2c64" class="ml mm it nl b gy nr ns l nt nu">self.appDelegate.saveContext()</span></pre><p id="5b05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你的<code class="fe ni nj nk nl b">addTask</code>方法应该是这样的:</p><pre class="ks kt ku kv gt nn nl no np aw nq bi"><span id="002b" class="ml mm it nl b gy nr ns l nt nu">func addTask(task:Task){<br/>   //insert taskname in collection<br/>   self.taskNames.append(task)</span><span id="41e6" class="ml mm it nl b gy nv ns l nt nu">//this index is needed since we're using zero-base index<br/>   let index = self.taskNames.count - 1</span><span id="2fd4" class="ml mm it nl b gy nv ns l nt nu">//index path informs the table view of which section and index to add the new value</span><span id="a2fe" class="ml mm it nl b gy nv ns l nt nu">let indexPath = IndexPath(item: index, section: 0)</span><span id="438d" class="ml mm it nl b gy nv ns l nt nu">//insert value in table view<br/>   self.tableView?.insertRows(at: [indexPath], with: .automatic)<br/>   self.appDelegate.saveContext()</span><span id="5840" class="ml mm it nl b gy nv ns l nt nu">}</span></pre><p id="1bbd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有办法验证任务是否被正确保存，但是相信我，它成功了。我们将通过检索我们保存的数据来证明这一点。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="c9cc" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">检索数据</h2><p id="3f39" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">打开<code class="fe ni nj nk nl b">AppDelegate.swift</code>文件。我们将添加一个新方法<code class="fe ni nj nk nl b">callretrieveTasks</code>。</p><pre class="ks kt ku kv gt nn nl no np aw nq bi"><span id="84a5" class="ml mm it nl b gy nr ns l nt nu">func retrieveTasks()-&gt; [Task]{</span><span id="77fb" class="ml mm it nl b gy nv ns l nt nu">//creating list and initialize it<br/>    var _tasks : [Task] = []</span><span id="a542" class="ml mm it nl b gy nv ns l nt nu">//get context<br/>   let context = persistentContainer.viewContext</span><span id="0508" class="ml mm it nl b gy nv ns l nt nu">//create request wiht entity Task<br/>   let taskFetchRequest = NSFetchRequest&lt;NSFetchRequestResult&gt;(entityName: "Task")</span><span id="0345" class="ml mm it nl b gy nv ns l nt nu">do{<br/>       //fetch all tasks from local storage<br/>       let tasks = try context.fetch(taskFetchRequest) as! [Task]<br/>       if(tasks.count &gt; 0 ){<br/>           _tasks = tasks<br/>       }</span><span id="51d1" class="ml mm it nl b gy nv ns l nt nu">}catch{<br/>        print("Something happened while trying to retrieve tasks...")</span><span id="eec1" class="ml mm it nl b gy nv ns l nt nu">}<br/>     return _tasks<br/>}</span></pre><p id="bebb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">选择<code class="fe ni nj nk nl b">MyToDoTableViewController.swift</code>文件。我们还将使用覆盖方法之一，<code class="fe ni nj nk nl b">viewWillAppear</code>。我们将集合设置为从call <code class="fe ni nj nk nl b">retrieveTasks</code>返回的任何数据，并重新加载表。</p><p id="3f5b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将这段代码添加到<code class="fe ni nj nk nl b">viewDidLoad</code>方法之后:</p><pre class="ks kt ku kv gt nn nl no np aw nq bi"><span id="04a5" class="ml mm it nl b gy nr ns l nt nu">override func viewWillAppear(_ animated: Bool) {<br/>    self.taskNames = appDelegate.retrieveTasks()<br/>    self.tableView.reloadData()  <br/>}</span></pre><p id="137d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">构建并运行应用程序，瞧。在我们实现要检索的代码之前，您保存的记录现在应该显示在表视图中。让我们继续更新任务。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="6033" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">更新数据</h2><p id="976b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">要更新任务，我们只需要保存上下文中的更改。我们的<code class="fe ni nj nk nl b">updateTask</code>方法将被修改为更新一个任务，重新加载表视图，然后更新本地存储。用下面的代码替换您的<code class="fe ni nj nk nl b">updateTask</code>:</p><pre class="ks kt ku kv gt nn nl no np aw nq bi"><span id="aafb" class="ml mm it nl b gy nr ns l nt nu">func updateTask(taskName:String){<br/>     //just update the collect, then refresh the tableview<br/>     self.taskNames[self.selectedIndex].name = taskName</span><span id="617d" class="ml mm it nl b gy nv ns l nt nu">do{<br/>          //needed to fetch request<br/>          let fetchRequest = NSFetchRequest&lt;NSFetchRequestResult&gt;(entityName: "Task")</span><span id="2c66" class="ml mm it nl b gy nv ns l nt nu">//predicate to match task on id<br/>          let predicate = NSPredicate(format: "id = %@", self.taskNames[self.selectedIndex].id!)</span><span id="edc2" class="ml mm it nl b gy nv ns l nt nu">//setting request predicate<br/>       fetchRequest.predicate = predicate</span><span id="0930" class="ml mm it nl b gy nv ns l nt nu">//look for task<br/>       let foundTasks = try context.fetch(fetchRequest) as! [Task]</span><span id="3444" class="ml mm it nl b gy nv ns l nt nu">//update found task<br/>       foundTasks.first?.name = taskName</span><span id="e8d1" class="ml mm it nl b gy nv ns l nt nu">//reload table<br/>       self.tableView.reloadData()</span><span id="e177" class="ml mm it nl b gy nv ns l nt nu">//save update<br/>       try self.context.save()</span><span id="d002" class="ml mm it nl b gy nv ns l nt nu">}catch{<br/>        print("Something happen while trying to update a task")<br/>    }</span><span id="2f45" class="ml mm it nl b gy nv ns l nt nu">}</span></pre><p id="cdf9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们快到了。现在我们可以添加、检索和更新了，剩下唯一要做的就是实现删除</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="2aa2" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">删除数据</h2><p id="9c63" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">删除类似于编辑。两者使用相同的谓词。我们将在<code class="fe ni nj nk nl b">commit editingStyle</code>委托方法中实现这个行为。用以下代码替换整个方法:</p><pre class="ks kt ku kv gt nn nl no np aw nq bi"><span id="f999" class="ml mm it nl b gy nr ns l nt nu">override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {</span><span id="385e" class="ml mm it nl b gy nv ns l nt nu">if editingStyle == .delete {<br/>    let _task = self.taskNames[indexPath.row]<br/>    let context = appDelegate.persistentContainer.viewContext;</span><span id="7c22" class="ml mm it nl b gy nv ns l nt nu">let taskFetchRequest = NSFetchRequest&lt;NSFetchRequestResult&gt;(entityName: "Task")</span><span id="83c7" class="ml mm it nl b gy nv ns l nt nu">let predicate = NSPredicate(format: "id = %@", _task.id!)</span><span id="3e7d" class="ml mm it nl b gy nv ns l nt nu">taskFetchRequest.predicate = predicate</span><span id="94a2" class="ml mm it nl b gy nv ns l nt nu">do{</span><span id="1f97" class="ml mm it nl b gy nv ns l nt nu">let foundTaskts = try context.fetch(taskFetchRequest) as! [Task]</span><span id="3450" class="ml mm it nl b gy nv ns l nt nu">context.delete(foundTaskts.first!</span><span id="664a" class="ml mm it nl b gy nv ns l nt nu">// delete the record from collection</span><span id="5323" class="ml mm it nl b gy nv ns l nt nu">self.taskNames.remove(at: indexPath.row)</span><span id="e18b" class="ml mm it nl b gy nv ns l nt nu">//delete row from tableview<br/>          tableView.deleteRows(at: [indexPath], with: .fade)</span><span id="0fcb" class="ml mm it nl b gy nv ns l nt nu">//refresh tableview<br/>          tableView.reloadData()</span><span id="5f24" class="ml mm it nl b gy nv ns l nt nu">//saving delete in context<br/>           try context.save()</span><span id="bf51" class="ml mm it nl b gy nv ns l nt nu">}catch{<br/>         print("Something happened while trying to delete task...")<br/>    }<br/>}</span><span id="623f" class="ml mm it nl b gy nv ns l nt nu">}</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="9fc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就是这样。我们刚刚使用核心数据创建了一个具有本地存储的出色应用程序。谢谢你跟随我。直到下一次…</p><p id="78aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你在项目运作中遇到了问题，不要担心。完成的项目可以从<a class="ae lh" href="https://github.com/Petey509/CoreDataDemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载。</p></div></div>    
</body>
</html>