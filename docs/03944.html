<html>
<head>
<title>Pass by Value and Pass by Reference in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的按值传递和按引用传递</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pass-by-value-and-reference-in-go-94423b6accf1?source=collection_archive---------4-----------------------#2020-03-15">https://betterprogramming.pub/pass-by-value-and-reference-in-go-94423b6accf1?source=collection_archive---------4-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3716" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解两者的区别，这样你就不会犯代价高昂的错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5f9bdac7a2bcfed490cc7523ab9ff6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_kn4hRcJCqa6bR2-N6RUw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/patterns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</p></figure><h1 id="881e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9808" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">许多编程语言支持通过值和/或引用传递参数。在本文中，我们将学习Go的函数如何处理传递的参数。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5847" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">什么是按值传递？</h1><p id="4e35" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Go中，当一个参数通过值传递给一个函数时，意味着这个参数被复制到内存的另一个位置。当访问或修改函数中的变量时，只会访问或修改副本，而不会修改原始值。Go中的所有原语/基本类型(int及其变体、float及其变体、boolean、string、array和struct)都是通过值传递的。按值传递通常是将值传递给函数的方式。让我们看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fe98" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">如果您运行上面的示例，您可以确认传递给函数的变量值在函数调用前后保持不变。简而言之，变量是通过值传递的。</p><p id="a180" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">现在，让我们探索Go函数处理参数的另一种方式——按引用传递。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7b48" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">什么是按引用传递？</h1><p id="0864" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于Go复合类型是否通过引用传递给函数有一种理解/争论。具体来说，Go不支持“按引用传递”语义。原因很简单；Go不像C++等其他编程语言那样支持引用变量。从概念上讲，在Map的情况下，当您创建一种类型的Map，然后将它传递给一个函数时，如果该函数修改了参数，其效果也会影响原始变量。这看起来好像Map变量是通过引用传递的，但这是不正确的。当您使用“make()”创建Map类型的变量时，它调用makemap()，后者返回*hmap(这是一个指针)。因此，将变量传递给函数是一种指针传递，而不是引用传递。同样的概念也适用于渠道。虽然，Slice的数据结构相对不同(一个struct有三种类型；指向底层数组的指针、切片的长度以及切片的容量)。但是，它也被视为传递指针。</p><p id="da48" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在我们继续讨论Go函数如何处理复合类型(切片、映射)、通道、指针和函数的一些示例之前，让我们先来看看这个代码片段，它确认Go复合类型不是按引用传递的:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="59f4" class="nl la it nh b gy nm nn l no np">package main</span><span id="7ec6" class="nl la it nh b gy nq nn l no np">import "fmt"<br/></span><span id="be07" class="nl la it nh b gy nq nn l no np">func myMap(v map[int]int) {<br/>    v = make(map[int]int) // make() declares and initializes v to 0</span><span id="10dc" class="nl la it nh b gy nq nn l no np">}</span><span id="b9b6" class="nl la it nh b gy nq nn l no np"><br/>func myInt(v []int) {<br/>    v = make([]int) // make() declares and initializes v to 0</span><span id="fc10" class="nl la it nh b gy nq nn l no np">}</span><span id="9fec" class="nl la it nh b gy nq nn l no np">func main() {<br/>    <br/>   //v is declared but NOT initialized, which means its value is nil<br/>     var v map[int]int</span><span id="499c" class="nl la it nh b gy nq nn l no np">     myMap(v)   <br/>     fmt.Println(v == nil) // true</span><span id="ddf6" class="nl la it nh b gy nq nn l no np">   //i is declared but NOT initialized, which means its value is nil<br/>     var i []int</span><span id="c691" class="nl la it nh b gy nq nn l no np">     myInt(i)<br/>     fmt.Println(i == nil) // true</span><span id="4613" class="nl la it nh b gy nq nn l no np">}</span></pre><p id="ea57" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">看上面的例子，我们可以看出，即使在声明了变量“V”之后，调用myF()将它初始化为0。最终，当我们在调用后测试它的值时，它的结果是“true”。这意味着myF()没有将“v”视为按引用传递(因为Go不支持这种语义)。如果我们尝试切片和通道，会得到相同的结果。你可以在戴夫·切尼的博客中读到更多关于这个话题的内容。</p><p id="d8e0" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">下面是在Go中传递复合类型和其他类型(除了上面讨论的原始类型)的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1ce7" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">浏览上面的例子，我们可以看到向函数传递参数的效果。例如，在<code class="fe nr ns nt nh b">slice</code>中，我们可以确认变量<code class="fe nr ns nt nh b">coffeeBox</code>的值在传递给函数<code class="fe nr ns nt nh b">modifySlice</code>时被修改了。<code class="fe nr ns nt nh b">map</code>、<code class="fe nr ns nt nh b">pointer</code>、<code class="fe nr ns nt nh b">function</code>、<code class="fe nr ns nt nh b">channel</code>也是如此。</p><p id="7b11" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">如果您发现自己需要修改基本类型(int、float、bool等)的值，只需将变量的内存地址传递给函数(换句话说，将参数视为指针)。指针部分清楚地说明了这种情况。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ebb5" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">摘要</h1><p id="d316" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Go支持按值传递语义；当参数通过值传递时，函数接收每个参数的副本，对副本的修改不会影响调用方。另一方面，它不支持按引用传递。但是，它支持按指针传递，可以用来修改底层参数的值。</p><p id="8f08" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在这篇短文中，我们探讨了Go处理传递给函数的参数的两种方式。了解这个概念很重要，这样可以避免错误的期望。</p><p id="85bb" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">直到下一篇文章，继续走下去！</p></div></div>    
</body>
</html>