# 递归的简单指南

> 原文：<https://betterprogramming.pub/recursion-a-simple-guide-cfe88bfd517e>

## 在代码中实现阶乘

![](img/4924002fa40a059bf3a275fa60ad6088.png)

照片由[马克西姆·勒布伦](https://unsplash.com/@flub?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

*递归*是方法调用自身的时候。当一个方法以这种方式运行时，它被称为*递归方法。*

在处理递归序列时，递归在数学中使用得相当多。如果你不熟悉*递归序列*，它们只是一个序列中的下一项使用前一项。我确信对于你们中的一些人来说，阶乘或者斐波那契递归序列可能会出现在脑海中。

递归不仅仅在数学中使用。它甚至存在于自然界。一个例子是螺旋楼梯，像上面的图片，它模仿鹦鹉螺壳。再比如向日葵。

![](img/d662ebd0a9e9c31e778fa299d18670a3.png)

卡罗琳·贝斯纳德在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

如果你仔细观察向日葵，它看起来就像是在其他圆里面的圆。不过，既然这和发展有关，我就尽量不要太被自然冲昏头脑。我将用一个典型的 for 循环实现阶乘序列，然后递归地执行它。

# 阶乘

阶乘是一个整数和它下面所有整数的乘积。安！用来表示它。例如 1 x 2 x 3 x 4 x 5 可以写成 5！。0!= 1.这可以实现为一个简单的循环，并假设只使用正整数。

```
public static int factorial(int number){
    if ( number <= 1){
        return 1;
    } int sum = 1; for(int i = 2; i < number + 1; i ++ ){
        sum *= i;
    } return sum;
}
```

如果你用 5 调用这个方法，你会得到 120。

# 复发性依赖

如果你足够幸运，上过一些算法课，找到递归公式可以简单地通过找到递归依赖来完成。

*循环依赖*是一个模式开始出现的点——在此之前的任何事情都需要单独处理。为了在这里找到它，我们只需要手动找到一些数字的阶乘，直到我们看到它。

```
0! => 1
1! => 1 => 1x1 => 1x0!
2! => 2x1 => 2x1!
3! => 3x2x1 => 3x2!
4! => 4x3x2x1 => 4x3!
5! => 5x4x3x2x1 => 5x4!
6! => 6x5x4x3x2x1 => 6x5!
```

此时，我们可以看到循环依赖从 2 开始。

1 和 0 是特例，都等于 1。

6!= 6x5！也可以写成 6x(6–1)！。如果我们用 *n* 代替常数，我们得到 *n* ( *n* -1)！。

现在让我们用它来递归地实现同样的功能。

```
public static int **factorial**(int number){
    if ( number <= 1){
        return 1;
    } return **number** * factorial(**number** -1);
}
```

`if`条件处理两种特殊情况。对于任何等于或小于 1 的值，都返回 1。

记住一个循环总是需要一个突破条件。递归依赖从 2 开始，所以当数值达到 1 时，方法将停止调用自己。

# 结论

递归一开始可能很难理解，但它真的很简单。

你需要用看待循环的方式来看待它。唯一的区别是，在周期性依赖开始出现之前，几乎总会有一些特殊情况。这些情况将是你的突破条件，而你的公式是用来递归调用你的方法的——正如我们在前面的例子中看到的。