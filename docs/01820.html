<html>
<head>
<title>Part 2: Kotlin Coroutines for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:面向初学者的Kotlin协程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-coroutines-for-beginners-4ba32909b509?source=collection_archive---------15-----------------------#2019-10-15">https://betterprogramming.pub/kotlin-coroutines-for-beginners-4ba32909b509?source=collection_archive---------15-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8678" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"># 100日代码的第28天</h2><div class=""/><div class=""><h2 id="9e3f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过实践代码学习</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6a9685b6f2f2192e2cf71e956598cfd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-aIFH0qMFFbcPcMJovHkA.png"/></div></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="c82c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">请务必查看之前关于下面的<a class="ae mb" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>协程的故事，我们将在这个故事中继续学习。</p><div class="mc md gp gr me mf"><a href="https://medium.com/@devDeeJay/kotlin-coroutines-for-beginners-a54d7fedb206" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd jd gy z fp mk fr fs ml fu fw jc bi translated">面向初学者的Kotlin协同程序</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">管理后台线程的新方法|第1部分</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt lb mf"/></div></div></a></div><p id="9052" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在Kotlin中，所有的协程都在我们称之为协程的作用域内运行。</p><ul class=""><li id="3438" class="mu mv it lh b li lj ll lm lo mw ls mx lw my ma mz na nb nc bi translated">协程作用域通过它的<a class="ae mb" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" rel="noopener ugc nofollow" target="_blank">作业</a>控制协程的生命周期。当您取消一个作用域的作业时，它会取消在该作用域中运行的所有协程。这在用户离开当前屏幕的情况下会很有帮助。</li><li id="ee9f" class="mu mv it lh b li nd ll ne lo nf ls ng lw nh ma mz na nb nc bi translated">它还允许您指定默认的调度程序。Dispatcher控制哪个线程运行协程。</li></ul><p id="bd21" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们来谈谈代码。我们将在我们的<code class="fe ni nj nk nl b">ViewModel</code>中定义协程，因为它处理所有耗时的操作，如联网或读写数据库。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="e3af" class="nq nr it nl b gy ns nt l nu nv">private val viewModelJob = <em class="nw">Job</em>()<br/>private val uiScope = <em class="nw">CoroutineScope</em>(Dispatchers.Main + viewModelJob</span></pre><p id="dc63" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这里，我们首先创建一个<code class="fe ni nj nk nl b">viewModelJob</code>,这是我们想要完成的一些工作。工作是可取消的。</p><p id="bdc1" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然后我们定义一个名为<code class="fe ni nj nk nl b">uiScope</code>的协程上下文。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="3ba2" class="oe nr it bd of og oh oi oj ok ol om on ki oo kj op kl oq km or ko os kp ot ou bi translated">验光仪</h1><p id="3b5d" class="pw-post-body-paragraph lf lg it lh b li ov kd lk ll ow kg ln lo ox lq lr ls oy lu lv lw oz ly lz ma im bi translated">协程上下文是配置协程的一组属性。我们可以定义线程策略、异常处理程序等。</p><p id="1e7d" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这里，我们提到添加了两个作用域，<code class="fe ni nj nk nl b">Dispatcher.Main</code>是主线程，而<code class="fe ni nj nk nl b">job</code>是我们刚刚定义的。因此，最终的协程上下文是两者的组合。</p><p id="0c60" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">由于我们已经在<code class="fe ni nj nk nl b">viewModel</code>中定义了作业，如果视图模型被破坏，那么取消作业是一个好的做法。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="24b3" class="nq nr it nl b gy ns nt l nu nv">override fun onCleared() {<br/>    super.onCleared()<br/>    viewModelJob.cancel()<br/>}</span></pre><p id="176f" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">由于<code class="fe ni nj nk nl b">viewModelJob</code>是我们定义的协程作用域<code class="fe ni nj nk nl b">uiScope</code>的一部分，当<code class="fe ni nj nk nl b">viewModelJob</code>被取消时，每个由<code class="fe ni nj nk nl b">uiScope</code>启动的协程也将被取消。</p><p id="352f" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">一个好的做法是取消任何不再需要的协程，以避免不必要的工作或内存泄漏。</p><p id="d709" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果我们不通过作业和<code class="fe ni nj nk nl b">Dispatchers.Main</code>协程作用域:</p><ul class=""><li id="42a8" class="mu mv it lh b li lj ll lm lo mw ls mx lw my ma mz na nb nc bi translated">该范围将隐式创建一个作业，您可以使用<code class="fe ni nj nk nl b">uiScope.coroutineContext.cancel()</code>取消该作业。</li><li id="dd82" class="mu mv it lh b li nd ll ne lo nf ls ng lw nh ma mz na nb nc bi translated">作用域将一直运行到应用程序终止，这是我们作为负责任的开发人员不希望看到的。</li></ul></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="38cb" class="oe nr it bd of og oh oi oj ok ol om on ki oo kj op kl oq km or ko os kp ot ou bi translated">ViewModel中的协同作用域</h1><p id="e231" class="pw-post-body-paragraph lf lg it lh b li ov kd lk ll ow kg ln lo ox lq lr ls oy lu lv lw oz ly lz ma im bi translated">定义范围的一种方法是通过上面的样板代码。我说的是样板代码，所以你可以预期接下来会发生什么。</p><p id="b68c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">你可以使用<a class="ae mb" href="https://developer.android.com/jetpack/androidx" rel="noopener ugc nofollow" target="_blank"> AndroidX </a>依赖<code class="fe ni nj nk nl b">lifecycle-viewmodel-ktx</code> <strong class="lh jd"> <em class="nw"> </em> </strong>库，其中有一个<code class="fe ni nj nk nl b">viewModelScope</code>作为扩展函数。该库将负责为您设置和清除范围。</p><p id="482c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">因此，在所有的视图模型类中，这就少了一件你需要担心的事情。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa le l"/></div></figure></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="6776" class="oe nr it bd of og oh oi oj ok ol om on ki oo kj op kl oq km or ko os kp ot ou bi translated">代码示例1</h1><p id="9fa4" class="pw-post-body-paragraph lf lg it lh b li ov kd lk ll ow kg ln lo ox lq lr ls oy lu lv lw oz ly lz ma im bi translated">让我们将简单的线程代码转换成协程。假设我们的代码在3000毫秒后更新了一个<code class="fe ni nj nk nl b">LiveData</code>变量。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa le l"/></div></figure><p id="379f" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">将此转换为协程:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa le l"/></div></figure><p id="48f0" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">所以，有什么区别吗，达南杰？</p><ul class=""><li id="0bcd" class="mu mv it lh b li lj ll lm lo mw ls mx lw my ma mz na nb nc bi translated">如果用户离开活动，前一段代码中的任务仍然会完成，从而导致内存泄漏。然而，在协程中，一切都将被取消，并由您的<code class="fe ni nj nk nl b">ViewModel</code>来清理。</li><li id="4c52" class="mu mv it lh b li nd ll ne lo nf ls ng lw nh ma mz na nb nc bi translated">我们的协程运行在主线程上，而不是其他线程上。</li><li id="d5a1" class="mu mv it lh b li nd ll ne lo nf ls ng lw nh ma mz na nb nc bi translated">由于我们的代码运行在主线程上，<code class="fe ni nj nk nl b">delay()</code>不会阻塞我们的主线程，调度程序会在3000毫秒后恢复它。<code class="fe ni nj nk nl b">delay()</code>是一个挂起函数，我们不能用<code class="fe ni nj nk nl b">Thread.sleep()</code>来强制主线程休眠。</li></ul></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="fe63" class="oe nr it bd of og oh oi oj ok ol om on ki oo kj op kl oq km or ko os kp ot ou bi translated">SuspendCouroutine</h1><p id="60dd" class="pw-post-body-paragraph lf lg it lh b li ov kd lk ll ow kg ln lo ox lq lr ls oy lu lv lw oz ly lz ma im bi translated"><code class="fe ni nj nk nl b">SuspendCoroutine</code>还有延续。Kotlin为您提供了一个名为<code class="fe ni nj nk nl b">suspendCoroutine</code>的东西，它可以立即挂起当前的协程，并为您提供一个continuation对象，您可以使用它在将来恢复挂起的协程。</p><p id="1fb6" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">该延续对象保存延续/恢复挂起的协同例程所需的上下文。</p><p id="a27c" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><code class="fe ni nj nk nl b">suspendCoroutine</code>的延续提供了两个功能，resume和<code class="fe ni nj nk nl b">resumeWithException</code>。调用其中任何一个都将导致挂起的协程立即恢复。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="85f0" class="oe nr it bd of og oh oi oj ok ol om on ki oo kj op kl oq km or ko os kp ot ou bi translated">SuspendCancellableCoroutine</h1><p id="b8d3" class="pw-post-body-paragraph lf lg it lh b li ov kd lk ll ow kg ln lo ox lq lr ls oy lu lv lw oz ly lz ma im bi translated"><code class="fe ni nj nk nl b">SuspendCoroutine</code>当你不需要取消支持的时候是一个很好的选择。如果您需要取消，您可以使用<code class="fe ni nj nk nl b">SuspendCancellableCoroutine</code>将取消传播到您的库，这些库支持基于回调的API的取消。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="7af5" class="oe nr it bd of og oh oi oj ok ol om on ki oo kj op kl oq km or ko os kp ot ou bi translated">代码示例2</h1><p id="7710" class="pw-post-body-paragraph lf lg it lh b li ov kd lk ll ow kg ln lo ox lq lr ls oy lu lv lw oz ly lz ma im bi translated">首先，尝试自己阅读和理解代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa le l"/></div></figure><p id="5984" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在这个例子中，我们从互联网上获取一些数据。我们使用<code class="fe ni nj nk nl b">onStateChangeCallback</code>来管理三种状态之一:<code class="fe ni nj nk nl b">Loading</code>、<code class="fe ni nj nk nl b">NetworkSuccess</code>、<code class="fe ni nj nk nl b">NetworkError</code>。</p><p id="9284" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果我们得到一个<code class="fe ni nj nk nl b">NetworkSuccess</code>，那么我们将响应保存到数据库，这是在<code class="fe ni nj nk nl b">BACKGROUND</code>线程中完成的另一个异步操作。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="4f74" class="oe nr it bd of og oh oi oj ok ol om on ki oo kj op kl oq km or ko os kp ot ou bi translated"><strong class="ak">让我们转换成协程</strong></h1><p id="dc8b" class="pw-post-body-paragraph lf lg it lh b li ov kd lk ll ow kg ln lo ox lq lr ls oy lu lv lw oz ly lz ma im bi translated">我们将使用<code class="fe ni nj nk nl b">suspendCoroutines</code> <strong class="lh jd"> </strong>把回调转换成协程。我们将调用<code class="fe ni nj nk nl b">suspendCoroutine</code>来暂停该功能，同时等待回调。</p><p id="62f2" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果我们有一个<code class="fe ni nj nk nl b">SUCCESS</code>回调，我们将调用resume。如果我们得到一个<code class="fe ni nj nk nl b">ERROR</code>回调，我们将调用<code class="fe ni nj nk nl b">resumeWithException</code>。</p><p id="84cb" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们为名为<code class="fe ni nj nk nl b">await()</code>的<code class="fe ni nj nk nl b">NetworkResponse</code>类定义了一个扩展函数。这个函数实际上负责挂起和恢复协程。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa le l"/></div></figure><p id="eb66" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">所以，现在，你可以简单地从call对象中调用<code class="fe ni nj nk nl b">await()</code>函数，就像我们在上面的回调中所做的那样。但这一次，没有回调。</p><p id="19d9" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将一个名为<code class="fe ni nj nk nl b">await()</code>的<code class="fe ni nj nk nl b">suspend</code>函数添加到一个最初不是为协程构建的类中。(开闭原则的完美应用。)</p><p id="cb40" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这种方法可以用来更新基于回调的API以支持协程，而无需更改实现。</p><p id="70c2" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">最后，我们有了更干净的代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pa le l"/></div></figure><p id="6432" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">今天到此为止，协程中还有很多内容需要探索，敬请关注。</p><p id="900a" class="pw-post-body-paragraph lf lg it lh b li lj kd lk ll lm kg ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">感谢阅读，保持敬畏！</p></div></div>    
</body>
</html>