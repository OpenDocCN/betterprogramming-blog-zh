<html>
<head>
<title>Implementing Zoom and Pan in Just 69 Lines of Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅用69行Javascript代码实现缩放和平移</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementation-of-zoom-and-pan-in-69-lines-of-javascript-8b0cb5f221c1?source=collection_archive---------0-----------------------#2019-10-18">https://betterprogramming.pub/implementation-of-zoom-and-pan-in-69-lines-of-javascript-8b0cb5f221c1?source=collection_archive---------0-----------------------#2019-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="45b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻量级，可扩展，易于使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6a8d785076db16b2ec3929409eecb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHbN74xHw2StAHOlCZng4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@twinsfisch" rel="noopener ugc nofollow" target="_blank"> twinsfisch </a>在<a class="ae ky" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="776c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最近的一个工作项目中，我必须添加缩放和平移包含多个不同元素的工作空间的功能。我决定分享我的实现，因为它是轻量级的，可扩展的，简单易用的，并且只需要普通的JavaScript。</p><p id="d9b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我本可以在许多已经编写好的库中进行选择，但是所有的库都有比我真正需要的更多的特性和代码。除此之外，自己写东西总是一个很好的挑战和乐趣(一旦你找到了一路上遇到的所有问题的解决方案)。</p><p id="7ce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将提出我最终的解决方案。不要再说了，让我们言归正传。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b22" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">图书馆的特点</h1><h2 id="915e" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">简单易用</h2><p id="c01d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我选择的一个假设是我的实现必须简单易用。我创建了一个演示程序，其中包含一个带有容器区域的HTML文件。我们将在其中操作一些样本元素。容器是一个有一个孩子的根，一个工作区。根放在所有页面上，因为将添加事件(以允许操作工作区)，这些事件必须在站点的任何地方工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在样式表文件(<code class="fe nn no np nq b">index.css</code> ) <em class="nr"> </em>中，我通过将主体的<code class="fe nn no np nq b">overflow</code>设置为<code class="fe nn no np nq b">hidden</code>来关闭滚动，使用<code class="fe nn no np nq b">area</code>类来设置标记操作区域的边框:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d40a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">circle</code>、<code class="fe nn no np nq b">rectangle</code>和<code class="fe nn no np nq b">text-area</code>是仅为演示目的而定义的职业，所以请不要关注它们(纳瓦霍白色没有帮助)。</p><p id="99fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样出于演示目的，我创建了一个带有鼠标事件监听器的<code class="fe nn no np nq b">index.js</code>文件，它将与包含所有库实现的<code class="fe nn no np nq b">renderer</code>模块通信。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想实现库的易用性，所以我创建了一个<code class="fe nn no np nq b">renderer</code>的实例，并通过了基本配置，如最小比例、最大比例、将被操作的元素和可选的比例敏感度。</p><h2 id="c98d" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">轻量级且可扩展</h2><p id="1072" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">该库还必须是轻量级的。最终，它只是69行普通的JavaScript代码。它可能会更少，但我不想失去可读性。此外，你可以使用我的<a class="ae ky" href="https://github.com/kwdowik/zoom-pan" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上的缩小版。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="729c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在模块外部导出的主函数是<code class="fe nn no np nq b">renderer</code>，它有一个状态，描述转换并通过对象组合用可用的特性来修饰它。前缀为<code class="fe nn no np nq b">can</code>的函数能够接受参数状态，根据特性改变被操作的元素。所有的元素转换都由<code class="fe nn no np nq b">state.transformation</code>对象描述。我选择了组合而不是继承，以使新特性的扩展变得非常容易。组合保证了从<code class="fe nn no np nq b">renderer</code>对象中分离特性(每个方法负责每个特性),使得测试易于编写。您可以通过从<code class="fe nn no np nq b">Object.assign(…)</code>中删除一个负责功能的方法(<code class="fe nn no np nq b">canZoom(),</code> <code class="fe nn no np nq b">canPan()</code>)来测试解耦特性。如果你想学习更多关于写作和JavaScript的知识，我强烈推荐MPJ和他的频道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nm l"/></div></figure><h2 id="8c34" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">平移功能</h2><p id="71a6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在这两种情况下，库都使用CSS <code class="fe nn no np nq b">matrix</code>函数来更改<code class="fe nn no np nq b">style.transform</code> <em class="nr"> </em>并操作元素。<code class="fe nn no np nq b">Matrix</code>以下列方式组合所有2D变换方法<code class="fe nn no np nq b">matrix(scaleX()</code>、<code class="fe nn no np nq b">skewY()</code>、<code class="fe nn no np nq b">skewX()</code>、<code class="fe nn no np nq b">scaleY()</code>、<code class="fe nn no np nq b">translateX()</code>和<code class="fe nn no np nq b">translateY())</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我实现了两个函数，<code class="fe nn no np nq b">panBy()</code>和<code class="fe nn no np nq b">panTo()</code>。两者都只是使用了<code class="fe nn no np nq b">pan()</code>函数，但是<code class="fe nn no np nq b">panTo()</code>也设置了一个新的<code class="fe nn no np nq b">scale</code>并传递了<code class="fe nn no np nq b">originX</code>和<code class="fe nn no np nq b">originY</code>，减去了当前的<code class="fe nn no np nq b">transformation.translateX</code>和<code class="fe nn no np nq b">transformation.translateY</code>值。这是因为元素需要绝对值移动。<code class="fe nn no np nq b">pan()</code>功能的实现非常简单。通过<code class="fe nn no np nq b">originX</code>和<code class="fe nn no np nq b">originY</code>增加属性<code class="fe nn no np nq b">transformation.translateX</code>和<code class="fe nn no np nq b">transformation.translateY</code>；从<code class="fe nn no np nq b">getMatrix()</code>功能生成的新<code class="fe nn no np nq b">matrix</code>值被分配给<code class="fe nn no np nq b">style.transform</code>。</p><p id="bea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe nn no np nq b">matrix</code>的<em class="nr"> </em>函数只返回一个模板字符串，其中包含一个带有传递参数的矩阵。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="726e" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">缩放</h2><p id="d527" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">除了<code class="fe nn no np nq b">style.transform</code> <em class="nr"> </em>之外，缩放还使用<code class="fe nn no np nq b">style.transformOrigin</code>来校正放大和缩小期间的元素位置。注释掉第14行，看看会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="80b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，<code class="fe nn no np nq b">zoom()</code>方法需要一个当前的和新的<code class="fe nn no np nq b">scale</code>，并通过<code class="fe nn no np nq b">getScale()</code>方法获得它们。这是基于当前的<code class="fe nn no np nq b">scale</code>、<code class="fe nn no np nq b">deltaScale</code>和<code class="fe nn no np nq b">scaleSensitivity</code>。保持范围(第3行)将返回当前和新计算的<code class="fe nn no np nq b">scale</code>值作为一个元组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="37c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将根据传递的坐标(<code class="fe nn no np nq b">x</code>、<code class="fe nn no np nq b">y</code>)和元素位置<code class="fe nn no np nq b">newOriginX</code>和<code class="fe nn no np nq b">newOriginY</code>，通过将<code class="fe nn no np nq b">originX</code>和<code class="fe nn no np nq b">originY</code>除以<code class="fe nn no np nq b">scale</code>来计算<code class="fe nn no np nq b">originX</code>和<code class="fe nn no np nq b">originY</code>。接下来，它通过调用高阶函数<code class="fe nn no np nq b">getTranslate()</code>计算<code class="fe nn no np nq b">translateX</code>和<code class="fe nn no np nq b">translateY</code>，该函数返回用<code class="fe nn no np nq b">minScale</code>、<code class="fe nn no np nq b">maxScale</code>和<code class="fe nn no np nq b">scale</code>参数化的函数，并将它们分配给<code class="fe nn no np nq b">translate</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后调用位置为<code class="fe nn no np nq b">originX/originY</code>的<code class="fe nn no np nq b">translate</code>和之前的位置<code class="fe nn no np nq b">transformation.originX/transformation.originY</code>，并平移<code class="fe nn no np nq b">transformation.translateX/transformation.translateY</code>。基于这些值，它检查<code class="fe nn no np nq b">scale</code>是否在最小值和最大值之间，以及位置是否已经改变。如果有，它通过将最后一个<code class="fe nn no np nq b">translate</code>和其先前和当前位置之差乘以<code class="fe nn no np nq b">scale</code>因子的结果相加来计算新的<code class="fe nn no np nq b">translate</code>值；否则，它只返回最后一个<code class="fe nn no np nq b">translate</code>。</p><p id="ae64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nn no np nq b">zoom()</code>函数将计算值赋给<code class="fe nn no np nq b">style.transformOrigin</code>和<code class="fe nn no np nq b">style.transform</code>，并将一个新对象赋给<code class="fe nn no np nq b">state.transformation</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="95b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">工作示例</h1><p id="5b8f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">要更改工作区(虚线边框)的缩放，您必须使用鼠标滚轮或触摸板并按下“Ctrl”键。您可以通过将<code class="fe nn no np nq b">scaleSensivity</code>属性传递给<code class="fe nn no np nq b">renderer</code>实例来更改缩放敏感度。要更改平移区域，您必须在按下“Shift”键的情况下移动鼠标/触摸板。双击将恢复默认视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nm l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="28a7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">测试</strong></h1><p id="620a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我为实现的特性创建了一些样本测试。在每次测试之前，我用默认值创建了一个<code class="fe nn no np nq b">_element</code>对象。下面你可以看到对<code class="fe nn no np nq b">panBy()</code>函数的测试。出于测试目的，我喜欢用<a class="ae ky" href="https://www.npmjs.com/package/mocha" rel="noopener ugc nofollow" target="_blank">摩卡</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">潘比试验</p></figure><p id="fde2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我在<code class="fe nn no np nq b">it(...)</code>块中编写测试逻辑，并将所有测试参数扩展到一个单独的文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ba08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的队友向我展示了这些参数化的测试，我非常喜欢它们。它们对我的情况特别有帮助，我的测试只是在它们的值上有所不同。在我看来，这种方法使测试更具可读性，更易于维护。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1253" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="4df2" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我希望这个实现易于理解和使用。欢迎任何想法和评论。</p><p id="8640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推特:<a class="ae ky" href="https://twitter.com/k_wdowik" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> k_wdowik </em> </a></p></div></div>    
</body>
</html>