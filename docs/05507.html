<html>
<head>
<title>Layout in SwiftUI With Alignment Guides</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中带有对齐参考线的布局</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/layout-in-swiftui-with-alignment-guides-fef821e7e06e?source=collection_archive---------9-----------------------#2020-07-14">https://betterprogramming.pub/layout-in-swiftui-with-alignment-guides-fef821e7e06e?source=collection_archive---------9-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看新的布局机制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae023f7121b64081bcc85eab0e1b9a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Oa80Blvd6WpqXTX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@olga_o?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olga O </a>拍摄的照片。</p></figure><p id="2646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我必须说出SwiftUI开发中最初让我困惑的一个方面，那就是对齐指南。因此，我决定写这篇文章，试图揭开它们的神秘面纱，指出你如何与它们合作，并让它们为你工作。</p><p id="d538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI中的对齐参考线类似于UIKit中的约束。不，我收回那句话。它们是SwiftUI中的约束——只是它们不是微观管理你的屏幕，而是宏观管理它。如今，你需要对屏幕进行宏观管理，因为它们有各种形状和大小。然而，就像约束一样，对齐参考线并不总是那么容易使用。</p><p id="4166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您需要理解SwiftUI中布局机制背后的语义。了解这一点的最好地方是<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2019/237" rel="noopener ugc nofollow" target="_blank">戴夫·亚伯拉罕和约翰·哈珀在2019年WWDC关于这一主题的演讲</a>。在书中，他们概述了布局的三条黄金法则:</p><ul class=""><li id="2876" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">家长为孩子建议一个尺码。</li><li id="9339" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">孩子用建议来决定自己的尺寸。</li><li id="ddf9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">父母使用儿童选择尺寸来定位所述儿童。</li></ul><p id="24d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"这和对齐参考线有什么关系？"你可能会问。绝对是一切。要在SwiftUI中布局/管理空间，可以使用容器(ZStack、VStack和HStack)。容器是上面语义中的父容器，容器将使用所述规则组织它们的兄弟容器。您可以使用对齐参考线来影响这些规则。但是等等，有一个障碍。通常，布局语义确保布局指南不起作用(至少对于框架来说是这样)。我知道这很疯狂，但这就是默认语义的工作方式。</p><p id="2bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。我在一个视图中添加了一个形状(一个圆)。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太大了，不是吗？是那些布局语义在作怪。你看，你要了一个圆，没有给它一个尺寸，它尽可能的占了空间。不，我们需要一些规则。添加一个ZStack和一个框架。</p><p id="ab95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好，但你不想把它放在中间。您希望它位于顶部，所以您查看了文档，向框架添加了对齐参考线，然后重试。什么都没发生。</p><p id="4e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到图片，看看红色的框架。圆点已经在它的顶端了。实际上，它也在底部，也在前沿和后沿。当然，你可以给它一个更大的框架，但这样你的圈子就会再次占据整个空间。这是一个第二十二条军规。</p><p id="a109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要的是两个框架。将第二个ZStack和一个框架添加到混音中，第二个框架上带有对齐参考线。</p><p id="36bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个超级简单的原则，你可以应用它来让你选择的任何布局工作。你只需要开始考虑框架。苹果已经定义了九种你可能想要的最常见的布局。将您使用的对齐方式更改为状态变量，并查看您的选项。这里有一个动画GIF来说明这一点。当我们改变框架尺寸时，这个舞动的圆点围绕着框架对齐的所有选项。仔细观察，你会发现其中的规律。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/e3a8580fc24b78cec920a3657161e2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nCGcYf3NPgqDpi8S4A7Njw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI圆在变化的框架尺寸内对齐。</p></figure><p id="fcfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我看着它变异时，感觉有点像那个著名的生命游戏。这是一个开始，但为项目中的每个对象定义框架和对齐参考线…不，我们需要更多。这是这个跳舞机器人背后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码背后的跳舞点GIF显示。</p></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="a1af" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">自定义对齐</h1><p id="615f" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">自定义对齐允许您相对于彼此布置视图。要定义它们，首先需要定义一些对齐id。这是模板代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="844e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">垂直对齐的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这件作品最终将已经展示的两件作品联系在一起:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="a512" class="nv mu it nr b gy nw nx l ny nz">extension Alignment {<br/>  static let theAlignment = Alignment(horizontal:   .theHorizontalAlignment, vertical: .theVerticalAlignment)<br/>}</span></pre><p id="a6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们将使用新的对齐id和<code class="fe oa ob oc nr b">alignmentGuide</code>视图修改器来对齐帧内的两个视图。最终结果看起来像这样——几个跳舞的机器人:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/2c6dfe0bec3657881f1e881b8e3a5690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jRmSAjhAtvG5P3j_R5SXlw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">围绕中心的两个视图的自定义对齐的SwiftUI动画。</p></figure><p id="f38f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在看什么？嗯，自定义对齐规定您需要从中心开始，然后添加相对于它和彼此的视图。因此，两个圆圈将保持居中，但随机围绕彼此的前缘/后缘、顶部/底部边缘跳舞。与另一个例子一样，我们正在改变它们所在的框架的大小，以帮助您理解正在发生的事情。注意，这里的对齐ID已经链接到堆栈<code class="fe oa ob oc nr b">viewModifier</code>——而不是第一种情况中的框架。</p><p id="c8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建这个夹具的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">舞动的双点背后的代码。</p></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="0f0d" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">更多自定义视图</h1><p id="70b3" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">我们还没有完全完成。你看，还有第二个版本的<code class="fe oa ob oc nr b">alignmentGroup</code>视图修改器，它不是基于如上所示的下标，而是基于计算值:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="2603" class="nv mu it nr b gy nw nx l ny nz">.alignmentGuide(.myHorizontalAlignment, computeValue: {d in viewW})<br/>.alignmentGuide(.theVerticalAlignment, computeValue: {d in viewH})</span></pre><p id="db7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你在上面一行看到的<code class="fe oa ob oc nr b">viewW</code>的值是相对于它正在修改的视图的宽度的值，<code class="fe oa ob oc nr b">viewH</code>的值是相对于正在修改的视图的高度的值。这里有一个动画GIF，试图把这句话变成现实。在其中，我们改变了-64和96之间的<code class="fe oa ob oc nr b">viewW</code>和<code class="fe oa ob oc nr b">viewH</code>对齐。在我们的例子中，圆的值的倍数是32。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/27e58d3504ce633cb9fdf6269b49141b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LYTPGvQCsZD6nGUg6jvwQw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跳舞机器人在堆栈视图上使用SwiftUI对齐指南，而不是在帧上。</p></figure><p id="8a4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，圆圈实际上在整个广场上随机地——疯狂地——移动。这里没有放置前导、尾随、顶部或底部。都是坐标。请注意，对齐修改器再次出现在堆栈和对齐视图修改器上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义计算对齐方式背后的代码。</p></figure><p id="50d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我想到了这篇文章的结尾。我希望在这个过程中，我成功地揭开了排列的神秘面纱。继续编码，保持冷静。</p></div></div>    
</body>
</html>