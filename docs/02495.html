<html>
<head>
<title>Modern Dependency Injection in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的现代依赖注入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-dependency-injection-in-swift-952286b308be?source=collection_archive---------3-----------------------#2019-12-04">https://betterprogramming.pub/modern-dependency-injection-in-swift-952286b308be?source=collection_archive---------3-----------------------#2019-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在iOS应用程序中充分利用依赖注入系统的技巧、技术和策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8062d6e2a980d932589d39542de602e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukbBSHBasON1UXDx2moOvg.png"/></div></div></figure><p id="8b48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">MVVM。MVP。毒蛇。干净。在现代的iOS应用程序中，我们经常使用特定的架构或设计模式<em class="lq"> </em>来将我们的软件分解成易于阅读和理解并且易于测试的独立组件。</p><p id="7576" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是将应用程序分解成单独的组件会产生问题。我们如何将我们的应用程序重新组装起来呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/52a144dd4ab8bdcfd508a46aee0527fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45js1ucZ5NhnNmy55aRn1w.png"/></div></div></figure><p id="fa21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ViewController <em class="lq"> x </em>是如何发现ViewModel <em class="lq"> m </em>的，就此而言，ViewModel <em class="lq"> m </em>又是如何获得完成工作所需的一切的呢？</p><p id="5668" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题有几种可能的解决方案，但是今天我们将研究一些基于依赖注入和使用专用依赖注入系统的高级技术。</p><p id="ca10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经以某种方式、形式或形式在做这件事，但是在本文中，我们将深入探讨一些我希望在第一个应用程序中使用依赖注入系统之前就已经知道的技术。</p><p id="549b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用<a class="ae ls" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank">解析器</a>来演示这些技术，这是一个现代的依赖注入系统。但是不用担心。我们将要讨论的技巧和策略可以用于其他DI系统——从Dip到Swinject。</p><p id="5009" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文并不打算成为依赖注入或依赖注入系统的完整指南。如果您以前从未使用过，或者如果您只是想温习一下基础知识，那么在继续下一步之前，您可能希望阅读“<a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Introduction.md" rel="noopener ugc nofollow" target="_blank">依赖注入的简明介绍</a>”。</p><p id="2d04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文章末尾列出了其他资源。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="9192" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">注入服务，而不是数据</h1><p id="2657" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">首先要弄清楚的一件事是，依赖注入的唯一关注点在于构造服务图。用英语来说，这意味着依赖注入系统创建并连接管理应用程序数据的服务和对象。</p><p id="b377" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">它既不注入也不管理数据本身</strong></p><p id="435f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种区别很微妙但很重要。再看一下我们的初始对象图，其中视图控制器与视图模型通信，视图模型与数据存储库通信，存储库向API发出请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/dc14a1843753512c5673885fa5e49948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sko9FBZM_6KXkAO_hdlX2Q.png"/></div></div></figure><p id="4de2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">依赖注入系统的职责是创建视图模型、存储库实例和API实例，然后将这些组件连接到视图控制器。</p><p id="17e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦这个过程完成，依赖注入系统的工作就完成了，这些组件就可以自由地在它们之间来回传递消息和数据。</p><p id="7ee6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者换句话说，依赖注入注入代码:<em class="lq">服务</em>或<em class="lq">组件</em>，它们具有对象所依赖的<em class="lq">行为</em>。(因此有了依赖注入这个术语。)</p><p id="322c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">数据——</em>结构和其他值参数——通常<em class="lq">没有</em>相关联的行为。数据在<em class="lq">运行时</em>被创建和操作，并使用对象的方法和函数从一个对象传递到相关对象。</p><p id="5edb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据<em class="lq">从未</em>注入。</p><p id="a03e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果这还不清楚，我强烈推荐阅读《依赖注入:原则、实践和模式》一书的合著者之一史蒂文·范·杜森的《T21依赖注入代码气味:将运行时数据注入组件》。文章代码是用C#写的，但是概念足够简单。</p><p id="d6f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">准备好了吗？让我们看一个例子。</p><h2 id="756e" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">用户列表示例</h2><p id="18f8" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">假设我们正在呈现一个用户列表。视图控制器从视图模型中获取数据，并在表格视图中显示这些数据。该用户列表来自拥有用户数据的存储库。反过来，存储库与API通信以请求和更新数据。</p><p id="3fba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而我们的<code class="fe nj nk nl nm b">UserListViewController</code>，并不关心幕后发生的事情。它只是向注入系统请求一个<code class="fe nj nk nl nm b">UserListViewModel</code>，注入系统创建并交付这个T1以供使用。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="8f4b" class="mx mb it nm b gy nr ns l nt nu">class UserListViewController: UIViewController {</span><span id="326f" class="mx mb it nm b gy nv ns l nt nu">    @Injected private var viewModel: UserListViewModel</span><span id="051c" class="mx mb it nm b gy nv ns l nt nu">    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        setupViewModelSubscriptions()<br/>        viewModel.loadData()<br/>    }</span><span id="8314" class="mx mb it nm b gy nv ns l nt nu">    func setupViewModelSubscriptions() {<br/>        ...<br/>    }   <br/>}</span></pre><h2 id="5510" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">用户详细信息示例</h2><p id="68d4" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">现在，假设从列表中选择了一个用户，我们希望看到一些细节。在这种情况下，用户数据被传递到我们在<code class="fe nj nk nl nm b">prepareForSegue</code>的新视图控制器。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="c0bf" class="mx mb it nm b gy nr ns l nt nu">override func prepare(for segue: UIStoryboardSegue, sender: Any?) {<br/>    super.prepare(for: segue, sender: sender)<br/>    if let vc = segue.destination as? UserDetailsViewController {<br/>        vc.user = viewModel.selectedUser()<br/>    }<br/>}</span></pre><p id="f113" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们的新视图控制器也需要它自己的视图模型，以及它自己对共享存储库和API层的访问。你猜怎么着？依赖注入系统也提供这些服务。</p><p id="53aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这给了我们一个类似于下图的对象图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/04c184516d560876bbc424bcd2a7eb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKR5iqu6i2ZhkGXu17or9w.png"/></div></div></figure><p id="82c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们的<code class="fe nj nk nl nm b">UserDetailsViewController</code>的相关代码可能如下所示:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="5c1e" class="mx mb it nm b gy nr ns l nt nu">class UserDetailsViewController: UIViewController {</span><span id="5012" class="mx mb it nm b gy nv ns l nt nu">    var user: User?</span><span id="5129" class="mx mb it nm b gy nv ns l nt nu">    @Injected private var viewModel: UserDetailsViewModel</span><span id="e593" class="mx mb it nm b gy nv ns l nt nu">    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        setupViewModelSubscriptions()<br/>        viewModel.loadDetails(for: user)<br/>    }</span><span id="abb0" class="mx mb it nm b gy nv ns l nt nu">    func setupViewModelSubscriptions() {<br/>        ...<br/>    }   <br/>}</span></pre><p id="5f87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们的用户数据是由前面的视图控制器<em class="lq">、</em>传递到我们的细节视图控制器中的，但是我们的<code class="fe nj nk nl nm b">UserDetailsViewModel</code>是由依赖注入系统创建和注入的。</p><p id="7949" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当被要求在对<code class="fe nj nk nl nm b">viewModel.loadDetails(for: user</code> <em class="lq"> ) </em>的调用中加载该信息时，<code class="fe nj nk nl nm b">UserDetailsViewModel</code>本身仅了解所选用户。</p><p id="7e0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一般来说，您不会在<code class="fe nj nk nl nm b">UserListViewController</code>中向依赖注入系统注册所选用户，然后在<code class="fe nj nk nl nm b">UserDetailsViewModel</code> <em class="lq">中注入该用户。</em></p><p id="1baf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注入服务，而不是数据。</p><p id="d934" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦理解了这种区别，应用程序中各种对象和服务的角色将会更加清晰，您将能够充分利用您的依赖注入系统。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="62e4" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">注释</h1><p id="6a59" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">执行依赖注入有五种主要方式:</p><ol class=""><li id="246d" class="nx ny it kw b kx ky la lb ld nz lh oa ll ob lp oc od oe of bi translated"><a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Injection.md#interface" rel="noopener ugc nofollow" target="_blank">接口注射</a></li><li id="b716" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Injection.md#property" rel="noopener ugc nofollow" target="_blank">属性注入</a></li><li id="d7fe" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Injection.md#constructor" rel="noopener ugc nofollow" target="_blank">构造函数注入</a></li><li id="6702" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Injection.md#method" rel="noopener ugc nofollow" target="_blank">方法注射</a></li><li id="5904" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Injection.md#locator" rel="noopener ugc nofollow" target="_blank">服务定位器</a></li></ol><p id="52eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些名称和数字来自控制反转设计模式。更详细的讨论，请看马丁·福勒的经典文章。</p><p id="2428" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构造函数注入是实现依赖注入容器时最常用的技术，但这可能会在复杂的视图模型中导致大量讨厌的样板初始化代码:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="5c3a" class="mx mb it nm b gy nr ns l nt nu">class MyViewModel {</span><span id="66a5" class="mx mb it nm b gy nv ns l nt nu">    var userStateMachine: UserStateMachine<br/>    var keyValueStore: KeyValueStore<br/>    var bundle: BundleProviding<br/>    var touchIdService: TouchIDManaging<br/>    var status: SystemStatusProviding?</span><span id="23c6" class="mx mb it nm b gy nv ns l nt nu">    init(userStateMachine: UserStateMachine,<br/>         bundle: BundleProviding,<br/>         touchID: TouchIDManaging,<br/>         status: SystemStatusProviding?,<br/>         keyValueStore: KeyValueStore) {</span><span id="5f49" class="mx mb it nm b gy nv ns l nt nu">        self.userStateMachine = userStateMachine<br/>        self.bundle = bundle<br/>        self.touchIdService = touchID<br/>        self.status = status<br/>        self.keyValueStore = keyValueStore</span><span id="69b4" class="mx mb it nm b gy nv ns l nt nu">    }<br/>    ...<br/>}</span></pre><p id="16ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">…以及我们的注册功能:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="d91f" class="mx mb it nm b gy nr ns l nt nu">register { <br/>    MyViewModel(<br/>        userStateMachine: resolve(),<br/>        bundle: resolve(),<br/>        touchID: resolve(),<br/>        status: resolve()?,<br/>        keyValueStore: resolve()<br/>    )<br/>}</span></pre><p id="9b01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了缓解这一问题，最新版本的Resolver增加了第六种方法，Swift 5.1使之成为可能</p><p id="03aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>本文假设您理解对象注册过程，并且上面注册函数中显示的自动<a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/develop/Documentation/Types.md" rel="noopener ugc nofollow" target="_blank">类型推断</a>行为是有意义的。如果没有，那么在继续下一步之前，请阅读“<a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Introduction.md" rel="noopener ugc nofollow" target="_blank">依赖注入的简明介绍</a>”。</p><h2 id="ed2f" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">方法6:注释</h2><p id="1554" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">注释使用注释或其他元数据来指示需要依赖注入。注释在Android上的Dagger 2等工具中很常见，从Swift 5.1开始，我们现在可以使用属性包装器在iOS上执行我们自己版本的注释。</p><p id="8ab2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了注释属性包装器，上面的<code class="fe nj nk nl nm b">MyViewModel</code>代码现在可以用更简洁的方式编写:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="47b3" class="mx mb it nm b gy nr ns l nt nu">class MyViewModel {<br/>    @Injected var userStateMachine: UserStateMachine<br/>    @Injected var keyValueStore: KeyValueStore<br/>    @Injected var bundle: BundleProviding<br/>    @Injected var touchIdService: TouchIDManaging<br/>    @Injected var status: SystemStatusProviding?<br/>    ...<br/>}</span></pre><p id="38cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的初始化函数和所有相关的样板代码都不见了，我们的注册函数也只剩下一行代码。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="af6a" class="mx mb it nm b gy nr ns l nt nu">register { MyViewModel() }</span></pre><p id="7068" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果这看起来很熟悉，可能是因为我们在例子中使用了注释模式。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="d069" class="mx mb it nm b gy nr ns l nt nu">class UserDetailsViewController: UIViewController {<br/>    @Injected private var viewModel: UserDetailsViewModel<br/>}</span></pre><p id="894b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl nm b">@Injected</code>属性包装器是特定于Resolver的，但是人们可以很容易地在任何DI系统周围制作这样的包装器。要深入了解这是如何实现的，请阅读我的文章“<a class="ae ls" href="https://medium.com/better-programming/taking-swift-dependency-injection-to-the-next-level-b71114c6a9c6" rel="noopener"> Swift 5.1将依赖注入提升到下一个层次</a>”</p><p id="33e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要注意，与SwiftUI和Combine不同，属性包装器不需要iOS 13，因此在早期版本的iOS中使用是安全的。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="72ea" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">领域</h1><p id="b02b" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">范围用于控制给定对象实例的生命周期。它们是您的依赖注入工具包中非常强大的工具，Resolver内置了其中的五个:</p><ul class=""><li id="ee49" class="nx ny it kw b kx ky la lb ld nz lh oa ll ob lp ol od oe of bi translated"><code class="fe nj nk nl nm b">Application</code></li><li id="37a9" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><code class="fe nj nk nl nm b">Cached</code></li><li id="9010" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><code class="fe nj nk nl nm b">Graph</code>(默认)</li><li id="1401" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><code class="fe nj nk nl nm b">Shared</code></li><li id="b163" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><code class="fe nj nk nl nm b">Unique</code></li></ul><p id="5d32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了<code class="fe nj nk nl nm b">unique</code>之外，所有的作用域基本上都是缓存，这些缓存用于跟踪它们创建的对象。</p><p id="5056" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">多久了？那要看范围了。</p><h2 id="632a" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">适用范围</h2><p id="0c32" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">例如，在应用程序范围内创建一个对象，实际上就创建了一个单例。</p><p id="ba06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">依赖注入系统第一次解析应用程序范围内的对象时，它被返回，但是对该对象的引用也被保存在缓存中。下一次我们试图解析相同的对象签名时，将返回对原始对象的引用。</p><p id="1fb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Resolver中的对象注册过程中，您可以使用<code class="fe nj nk nl nm b">scope</code> <em class="lq"> </em>构建器属性来指示所创建的对象应该被放置在特定的范围内。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="1ecd" class="mx mb it nm b gy nr ns l nt nu">register { MyWebService() }.scope(application)</span></pre><p id="599c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在类上使用静态共享变量来实现这一点，但这将打开一个完整的蠕虫罐，包括违反单一责任原则、使您的代码依赖于全局状态、将您的代码与静态共享变量紧密耦合，等等。</p><p id="0420" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于为什么自己创建和使用单例是个坏主意，请阅读Vojtech Ruzicka的“<a class="ae ls" href="https://www.vojtechruzicka.com/singleton-pattern-pitfalls/" rel="noopener ugc nofollow" target="_blank">单例模式陷阱</a>”。</p><p id="cb92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，使用带注释的依赖注入，您只需标记想要注入的对象，系统会处理其余的。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="c0a5" class="mx mb it nm b gy nr ns l nt nu">class UserDetailsViewModel {<br/>    @Injected private var service: MyWebService<br/>}</span></pre><p id="3d91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，使用<code class="fe nj nk nl nm b">MyWebService</code>的视图模型不知道它是单例的，也不应该关心。从它的角度来看，<code class="fe nj nk nl nm b">MyWebService</code> <em class="lq"> </em>与它需要的任何其他服务没有什么不同，它以同样的方式获得它。</p><h2 id="0387" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">在依赖注入中实施单例</h2><p id="9d91" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">如果出于某种原因，您需要的不仅仅是单例行为，并且希望绝对确保其他人不能创建<code class="fe nj nk nl nm b">MyWebService</code>的实例，那么只需将以下内容添加到您的<code class="fe nj nk nl nm b">MyWebService.swift</code>文件中:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="1168" class="mx mb it nm b gy nr ns l nt nu">public struct MyWebService {<br/>    fileprivate init() { }<br/>    ...<br/>}</span><span id="8925" class="mx mb it nm b gy nv ns l nt nu">extension Resolver {<br/>    static func registerMyWebService() { <br/>        register { MyWebService() }.scope(application) <br/>    }<br/>}</span></pre><p id="c41d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从您为解析器创建的应用程序的<a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/develop/Documentation/Registration.md" rel="noopener ugc nofollow" target="_blank"> registerAllServices </a>函数中调用<code class="fe nj nk nl nm b">registerMyWebService</code>。现在，您的应用程序获得对您的singleton的访问的唯一方法是从注入系统请求它，注入系统将确保创建并返回一个且只有一个副本。</p><h2 id="4ceb" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">缓存范围</h2><p id="7370" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">与应用程序范围一样，该范围存储对已解析实例的强引用。创建后，每个后续的解析该对象类型的调用都将返回相同的实例。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="3cbe" class="mx mb it nm b gy nr ns l nt nu">register { MyViewModel() }.scope(cached)</span></pre><p id="3c35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与应用程序作用域不同，缓存的作用域可以被重置，释放它们的缓存对象。一旦重置，我们基本上是从零开始，任何后续的解析请求都将创建一个新的实例，该实例将再次被缓存。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="13e8" class="mx mb it nm b gy nr ns l nt nu">Resolver.cached.reset()</span></pre><p id="0317" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以将自己的自定义缓存添加到Resolver中，并像内置在系统中一样使用它们。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="ee2e" class="mx mb it nm b gy nr ns l nt nu">Resolver.session = ResolverScopeCache()<br/>register { MySessionManager() }.scope(session)</span></pre><p id="cf04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果您需要一个会话级的作用域来缓存特定的信息，直到用户注销，这是非常有用的。</p><h2 id="11d4" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">独特的范围</h2><p id="3902" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我在上面提到过<code class="fe nj nk nl nm b">unique</code>范围是独一无二的——的确如此。解析一个唯一的依赖项，解析器每次都会为所请求的对象创建一个新的实例。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="f369" class="mx mb it nm b gy nr ns l nt nu">register { MyViewModel() }.scope(unique)</span></pre><p id="38a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">奇怪的是，每次简单地创建一个新对象并不是默认范围。</p><h2 id="d936" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">图表范围</h2><p id="eb62" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated"><code class="fe nj nk nl nm b">graph</code>是默认范围，当在对象注册期间没有指定附加范围时会出现这种情况。在DI中，<code class="fe nj nk nl nm b">graph</code>将重用在给定的解析周期中解析的任何对象实例。</p><p id="a73c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再翻译一下，假设<em class="lq"> a </em>依赖于<em class="lq"> b </em>和<em class="lq"> c </em>并且<em class="lq"> b </em>和<em class="lq"> c </em>都依赖于<em class="lq"> d. </em>那么我们做如下:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="0dc2" class="mx mb it nm b gy nr ns l nt nu">@Injected private var a: A</span></pre><p id="9775" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解析器将尝试解析<em class="lq"> a </em>，在这个过程中，它发现<em class="lq"> a </em>需要一个<em class="lq"> b </em>并且<em class="lq"> b </em>需要一个<em class="lq"> d </em>。它每样做一个，然后把它们连在一起。</p><p id="992d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后解析器发现<em class="lq"> a </em>也需要一个<em class="lq"> c </em>并且<em class="lq"> c </em>也需要一个<em class="lq"> d </em>。解析器知道它已经做了一个<em class="lq"> d，</em>所以它给出了一个对<em class="lq"> c. </em>的现有引用的副本。现在<em class="lq"> a </em>有了它的<em class="lq"> b </em>和<em class="lq"> c </em>，这两个引用了<em class="lq"> d </em>的同一个实例。最后，我们归还我们的<em class="lq">一个</em>，准备使用。</p><p id="f415" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，<code class="fe nj nk nl nm b">graph</code>取决于您可能希望<em class="lq"> b </em>和<em class="lq"> c </em>共享<em class="lq"> d </em>的想法，因为它们都是在同一个解析周期中生成的，因此看起来彼此关联。</p><p id="2d52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您不想要这种行为，您可以将<em class="lq">d’</em>s的依赖项标记为unique。如果您不想要这种行为，您可以简单地将Resolver的默认范围更改为<code class="fe nj nk nl nm b">unique</code>。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="2f43" class="mx mb it nm b gy nr ns l nt nu">Resolver.defaultScope = Resolver.unique</span></pre><p id="7ca2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在来看看我们的另一个电动工具。</p><h2 id="7913" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">共享范围</h2><p id="8ce6" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">此范围存储对已解析实例的弱引用。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="e90d" class="mx mb it nm b gy nr ns l nt nu">register { MyViewModel() }.scope(shared)</span></pre><p id="de69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然存在对已解析实例的强引用，但任何后续的解析调用都将返回同一个实例。</p><p id="1ae2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，一旦所有的强引用被释放，缓存的实例也被释放，下一次调用解析服务将产生一个新的实例。</p><p id="c173" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这在主/细节视图控制器的情况下很有用，在这种情况下，<code class="fe nj nk nl nm b">MasterViewController</code>和<code class="fe nj nk nl nm b">DetailViewController</code>可能想要共享特定视图模型的同一个实例，或者，他们的视图模型可能需要共享一些公共的状态。</p><p id="067b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，我们在上面的user-list/user-details示例中看到了这一点，其中两个视图模型都需要访问当前用户存储库中的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/04c184516d560876bbc424bcd2a7eb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKR5iqu6i2ZhkGXu17or9w.png"/></div></div></figure><p id="d029" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">…存储库和相关的API是这样注册的:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="be21" class="mx mb it nm b gy nr ns l nt nu">register { UserRepository() as UserRepositoryType }.scope(shared)<br/>register { UserService() as UserServiceType }</span></pre><p id="01a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当我们的细节视图控制器被推送时，并且当它的视图模型请求一个<code class="fe nj nk nl nm b">UserRepositiory</code>、<em class="lq">、</em>时，它获得一个对已经创建并提供给列表视图控制器的视图模型的存储库的引用。</p><p id="47de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这允许两个视图模型共享同一个存储库，因此共享相同的同步状态和数据。</p><p id="e97b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在再看一下上面的注册码。到目前为止，<code class="fe nj nk nl nm b">.scope(shared)</code>方法应该是有意义的，但是<code class="fe nj nk nl nm b">as</code>类型的添加可能看起来有点奇怪。为什么要将对象注册为不同的类型？</p><p id="6ba9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个很好的问题，它的答案将我们带到了下一个话题。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="8e00" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">面向协议的编程</h1><p id="e0ac" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">协议定义了适合特定任务或功能的方法和属性。有了它，我们就定义了这些特性的接口。</p><p id="316b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实现实现接口的对象，并且可以将该对象传递给任何其他想要使用该接口的对象。而传递对象是依赖注入的核心和灵魂。</p><h2 id="f3e6" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">模仿<em class="om">用户存储库</em></h2><p id="5db7" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们可以用协议做的一件大事就是用它们来模拟测试数据。在我们的第一个例子中，我们展示了一个依赖于一个<code class="fe nj nk nl nm b">UserListViewModel</code>的<code class="fe nj nk nl nm b">UserListViewController</code>。反过来，这种视图模型依赖于<code class="fe nj nk nl nm b">UserRepository</code>来实际管理其数据。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="646f" class="mx mb it nm b gy nr ns l nt nu">class UserListViewModel {<br/>    @Injected var repository: UserRepositoryType<br/>    ...<br/>}</span></pre><p id="f386" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是请注意，我们的变量类型实际上是<code class="fe nj nk nl nm b">UserRepositoryType</code>，一个看起来像这样的协议。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="2838" class="mx mb it nm b gy nr ns l nt nu">protocol UserRepositoryType {<br/>    var users: CurrentValueSubject&lt;[User], Never&gt; { get }<br/>    var error: CurrentValueSubject&lt;String?, Never&gt; { get }<br/>    func load()<br/>    func save(user: User)<br/>}</span></pre><p id="67da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的标准<code class="fe nj nk nl nm b">UserRepository</code>使用API层来处理数据请求，但是使用我们的协议，我们也可以创建一个模拟版本来返回测试数据:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="7ad9" class="mx mb it nm b gy nr ns l nt nu">class MockUserRepository: UserRepositoryType {<br/>    let users = CurrentValueSubject&lt;[User], Never&gt;([])<br/>    let error = CurrentValueSubject&lt;String?, Never&gt;(nil)</span><span id="f6d6" class="mx mb it nm b gy nv ns l nt nu">    func load() {<br/>        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {<br/>        self.users.send([User(name: "Michael Long")])<br/>        }<br/>    }</span><span id="8324" class="mx mb it nm b gy nv ns l nt nu">    func save(user: User) {<br/>        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {<br/>        var list = self.users.value<br/>        if let index = list.firstIndex(where: {$0.id == user.id}) {<br/>            list[index] = user<br/>        } else {<br/>            list.append(user)<br/>        }<br/>        self.users.send(list)<br/>        }<br/>    }<br/>}</span></pre><p id="29d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，当我们有新数据或错误时，我们使用组合发布器来通知，我们甚至使用延迟调度队列来模拟数据请求中的延迟。</p><p id="4f8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们有我们的协议，我们的模拟数据，我们也有一个想要使用它的对象。我们如何使用依赖注入来连接东西？</p><h2 id="72c2" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">注入模拟数据</h2><p id="be0a" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">事实上，在为运行您的应用程序进行数据模拟以及对视图模型和其他对象进行单元测试时，有许多方法可以使用Resolver将模拟对象替换为真实对象。这里有一个最简单的。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="b9b2" class="mx mb it nm b gy nr ns l nt nu">extension Resolver: ResolverRegistering {<br/>    static public func registerAllServices() {<br/>        #if MOCK<br/>        register { MockUserRepository() as UserRepositoryType }<br/>            .scope(shared)<br/>        #else<br/>        register { UserRepository() as UserRepositoryType }<br/>            .scope(shared)<br/>        #endif<br/>    }<br/>}</span></pre><p id="2dd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的注册文件中，我们将检查一个由当前Xcode方案控制的编译器变量。如果<code class="fe nj nk nl nm b">MOCK</code>为真，我们将<code class="fe nj nk nl nm b">MockUserRepository</code>注册为<code class="fe nj nk nl nm b">UserRepositoryType</code>。如果为假，我们将<code class="fe nj nk nl nm b">UserRepository</code>注册为<code class="fe nj nk nl nm b">UserRepositoryType</code>。</p><p id="a066" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们构建app时，正确的注册码被编译，当app运行时，我们的<code class="fe nj nk nl nm b">UserViewModel</code>会得到相应的资源库。</p><h2 id="ffdf" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">用命名服务模仿</h2><p id="0ef6" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">让我们尝试另一种方法。考虑下面一组服务注册。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="4a71" class="mx mb it nm b gy nr ns l nt nu">register { <br/>    let mode = Bundle.main.infoDictionary!["mode"] as! String<br/>    return resolve(name: mode) as <!-- -->UserRepositoryType<br/>}<br/>register(name: "data") { <br/>    <!-- -->UserRepository<!-- -->() as <!-- -->UserRepositoryType<br/>}<br/>register(name: "mock") { <br/>    <!-- -->MockUserRepository<!-- -->() as <!-- -->UserRepositoryType<br/>}</span></pre><p id="cf2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经注册了<code class="fe nj nk nl nm b">XYZServiceType</code>三次:一次没有名字，一次有名字<code class="fe nj nk nl nm b">data</code>，然后又一次有名字<code class="fe nj nk nl nm b">mock</code>。</p><p id="ba35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看客户是如何使用它的。</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="15de" class="mx mb it nm b gy nr ns l nt nu">@Injected var service: XYZServiceType</span></pre><p id="2b13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">客户端只是向解析器请求一个<code class="fe nj nk nl nm b">XYZServiceType</code>的服务。由于未指定名称，解析程序将尝试使用未命名的服务注册来解析服务。</p><p id="cd65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该注册函数从应用程序的<code class="fe nj nk nl nm b">info.plist</code>中获取一个字符串，然后递归地要求Resolver解析另一个具有相同类型但也具有检索到的名称的实例。</p><p id="3f5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，根据应用程序的编译方式和应用程序plist中模式值的设置方式，一个版本将获得实际数据，而另一个版本将获得模拟数据。</p><p id="5eed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要两个服务都符合<em class="lq"> </em> <code class="fe nj nk nl nm b">XYZServiceType</code>协议，客户端就不会在意。</p><p id="5a5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也不应该。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="833d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">完成块</h1><p id="9a75" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">依赖注入是软件开发工具箱中的一个强大工具，我希望这篇文章仅仅展示了在您自己的应用程序中成功使用它的几种方法。</p><p id="1e45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，还有更多，其中最大的一个是依赖注入不仅可以帮助您简化应用程序代码，还可以帮助您简化单元测试和集成测试代码。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="264e" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">工厂</h1><p id="d8db" class="pw-post-body-paragraph ku kv it kw b kx ms ju kz la mt jx lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">请注意，截至2022年6月，我推荐使用Factory，这是我新的编译时安全依赖注入系统，也是Resolver的替代品。</p><p id="324a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在Medium上阅读<a class="ae ls" href="https://medium.com/better-programming/factory-swift-dependency-injection-14da9b2b5d09" rel="noopener">Factory:Swift Dependency Injection</a>，该项目可在GitHub <a class="ae ls" href="https://github.com/hmlongco/Factory" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="8cd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要担心，您在这里读到的所有内容在使用Factory时都是一样的。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h2 id="d1b5" class="mx mb it bd mc my mz dn mg na nb dp mk ld nc nd mm lh ne nf mo ll ng nh mq ni bi translated">额外资源</h2><ul class=""><li id="49a0" class="nx ny it kw b kx ms la mt ld on lh oo ll op lp ol od oe of bi translated"><a class="ae ls" href="https://medium.com/p/365ce5038ef7/edit" rel="noopener">Swift依赖注入系列</a>。</li><li id="a7b7" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><a class="ae ls" href="https://medium.com/better-programming/factory-swift-dependency-injection-14da9b2b5d09" rel="noopener">工厂:Swift依赖注入</a></li><li id="5dc3" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><a class="ae ls" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank"> Resolver:一个Swift超轻依赖注入框架</a></li><li id="923e" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><a class="ae ls" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Introduction.md" rel="noopener ugc nofollow" target="_blank">“依赖注入的简明介绍</a>”</li><li id="dd72" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><a class="ae ls" href="https://medium.com/better-programming/taking-swift-dependency-injection-to-the-next-level-b71114c6a9c6" rel="noopener">“Swift 5.1将依赖注入提升到了一个新的高度</a></li><li id="2924" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp ol od oe of bi translated"><a class="ae ls" href="https://martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">“控制容器的反转和依赖注入模式</a></li></ul></div></div>    
</body>
</html>