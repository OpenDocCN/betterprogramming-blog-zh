<html>
<head>
<title>Handle Concurrency With a Loader Indicator Service in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular中的加载器指示器服务处理并发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-concurrency-with-loader-indicator-service-in-angular-d531f06ea67?source=collection_archive---------2-----------------------#2020-07-17">https://betterprogramming.pub/handling-concurrency-with-loader-indicator-service-in-angular-d531f06ea67?source=collection_archive---------2-----------------------#2020-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="992d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写一个容忍并发的角度加载器服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b949789d1ee7fb010234a4266e92177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FB7EVNQhT4PrCfbR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="daf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当web应用程序执行一个异步任务时，比如一个HTTP请求或动画页面转换，添加一个加载器动画是一个好主意，可以通过设置用户期望来提高UX(比如说，“我正忙着执行一个请求”)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="542b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">简单案例</h1><p id="50d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因此，我们可以编写一个简单的“加载器”服务，在一个简单的角度/离子应用程序中完成这项工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cb03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个组件需要一个加载指示器来显示时，我们会通过依赖注入(DI)将这个服务导入到这样的组件中，我们会根据需要调用它，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这适用于简单的应用程序，但随着应用程序变得越来越大，就变得非常混乱，因为对于每个潜在需要“加载微调器”UX的函数，我们都需要在代码中处理显示/隐藏逻辑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3257" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">拦截器和路由器</h1><p id="51b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了避免混乱的代码，一种方法是在我们应用的大多数异步功能的核心实现显示/隐藏处理:<a class="ae ky" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank"> HTTP拦截器</a>和<a class="ae ky" href="https://angular.io/api/router" rel="noopener ugc nofollow" target="_blank">路由器</a>。向拦截器和路由器添加逻辑将确保对于每个网络请求和页面转换，我们得到一个负载指示器。</p><p id="8355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在应用程序的头部实现一个简单的非阻塞的小型旋转器动画(例如<a class="ae ky" href="https://ionicframework.com/docs/api/spinner" rel="noopener ugc nofollow" target="_blank"> ion-spinner </a>),而不是沉重的“阻塞”(带背景)加载spinner。但是出于本文的考虑，我们将考虑重的情况——我们使用异步构造的<a class="ae ky" href="https://ionicframework.com/docs/api/loading" rel="noopener ugc nofollow" target="_blank"> Ionic的加载控制器</a>。</p><p id="8848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何向拦截器添加隐藏/显示加载器逻辑，方法是导入我们的加载器服务，并在每次请求开始时调用<code class="fe nb nc nd ne b">.showLoader()</code>，使用<a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/operators/utility/finalize" rel="noopener ugc nofollow" target="_blank"> finalize RXJS操作符</a>调用<code class="fe nb nc nd ne b">.hideLoader()</code>，确保在请求完成后调用<code class="fe nb nc nd ne b">hideLoader()</code>(无论成功还是出错):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何为路由器做同样的事情，我们将订阅<a class="ae ky" href="https://angular.io/api/router/RouterEvent" rel="noopener ugc nofollow" target="_blank">路由器事件</a>，过滤它们以只关注<code class="fe nb nc nd ne b">NavigationStart</code>和<code class="fe nb nc nd ne b">NavigationEnd</code>事件，并调用我们的加载器服务来相应地显示和隐藏加载器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="48d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在已经实现了逻辑，但是一旦我们开始测试我们的应用程序，我们就会意识到有许多可能导致错误的“竞争”条件:</p><ul class=""><li id="3543" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">如果有两个以上的API请求并行运行。</li><li id="048f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果有一个API请求正在运行，我们的用户转换到另一个页面。</li><li id="03c5" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果API请求的页面转换发生得太快，并且在创建离子加载时，我们已经对它调用了“解除”。</li></ul><p id="e33a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们使用简单的负载指示器，我们也可以观察到它在上述情况下闪烁。所有这些意味着我们当前的解决方案不能容忍并发请求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c685" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">处理并发性</h1><p id="170e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">那么，我们如何战胜并发性并避免竞争情况呢？一个流行的解决方案是实施“反制”策略。我们可以通过递增一个反映请求数量的计数器来显示加载指示器，而不是立即创建一个加载器组件。这种方法仍然不能处理并发性，因为在很多情况下，这种计数器会从某个数值快速下降到零(尽管它确实部分地改善了这种情况)。</p><p id="e14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现的最好的解决方案是利用<a class="ae ky" href="https://www.learnrxjs.io/" rel="noopener ugc nofollow" target="_blank"> RXJS </a>的力量，因为它在Angular中得到本地支持，并且因为它是用来处理事件流的，并且具有处理并发性的工具。</p><h2 id="ff0e" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated">第一步</h2><p id="3003" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们重构我们的加载器服务，将对<code class="fe nb nc nd ne b">showLoader</code> / <code class="fe nb nc nd ne b">hideLoader</code>的请求从实际的“创建加载器”和“解除加载器”逻辑中分离出来，这样我们就不必在<code class="fe nb nc nd ne b">Interceptor</code>和<code class="fe nb nc nd ne b">Router</code>的基础服务中更改我们的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="887f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用<a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/subjects/subject" rel="noopener ugc nofollow" target="_blank"> RXJS Subject </a>，它一旦被订阅，将启用一系列<code class="fe nb nc nd ne b">false</code>和<code class="fe nb nc nd ne b">true</code>值，这些值将反映我们的应用程序中隐藏或显示加载指示器的请求:</p><ul class=""><li id="755c" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们使用so-loading<code class="fe nb nc nd ne b">RequestsStream$.next(value)</code>这样的主语来传递请求的动作。</li><li id="15d5" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们将初始化转移到一个单独的方法中，<code class="fe nb nc nd ne b">initValues()</code>，<strong class="lb iu"> </strong>，并从构造函数中调用它(它将在应用程序启动时调用一次)。</li><li id="62f4" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">在<code class="fe nb nc nd ne b">initValues()</code>中，我们简单地订阅了<code class="fe nb nc nd ne b">Subject</code>,并基于它随时间接收的值，我们调用创建加载器或解除加载器。</li></ul><p id="fc0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在当我运行应用程序时，它有点工作，但并发仍然是一个大问题。以上只是为我们提供了实际操作的“管道代码”。</p><h2 id="0f52" class="nt md it bd me nu nv dn mi nw nx dp mm li ny nz mo lm oa ob mq lq oc od ms oe bi translated"><strong class="ak">第二步</strong></h2><p id="ed71" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">处理并发性将要求我们确保请求流是序列化的。我们可能还希望消除一个接一个的相同请求，保持流的独特性:</p><p id="6a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前流可以是:</p><p id="c11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b"><strong class="lb iu"><em class="of">true&gt;true&gt;false&gt;false&gt;true&gt;false&gt;true&gt;true&gt;false&gt;false…</em></strong></code></p><p id="3030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要的是:</p><p id="1ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b"><strong class="lb iu"><em class="of">true&gt;&gt;&gt;&gt;false&gt;&gt;&gt;&gt;true&gt;false&gt;true&gt;&gt;&gt;&gt;&gt;false&gt;&gt;&gt;…</em></strong></code></p><p id="81a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将在管道中导入并使用<code class="fe nb nc nd ne b"><a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/operators/filtering/distinctuntilchanged" rel="noopener ugc nofollow" target="_blank">DistinctUntilChanged</a></code> RXJS操作符:</p><pre class="kj kk kl km gt og ne oh oi aw oj bi"><span id="ea85" class="nt md it ne b gy ok ol l om on">this.loadingRequestsStream$.pipe(</span><span id="e49d" class="nt md it ne b gy oo ol l om on">    distinctUntilChanged(),</span><span id="8df2" class="nt md it ne b gy oo ol l om on">).subscribe();</span></pre><p id="406c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的加载器指示器是一个简单的离子旋转器，我们可能已经有了一个闪烁的指示器，它根据API和路由器请求的活动来开关。在我们的例子中，我们正在处理的事实是，Ionic的加载控制器异步旋转加载指示器。因此，我们需要一些东西来确保在之前创建或解散加载程序的承诺完成之前，不会发生新的此类操作。</p><p id="b006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/concatmap" rel="noopener ugc nofollow" target="_blank"> RXJS ContactMap </a>操作符确切地告诉我们，它会一直等待每个请求完成，然后再开始新的请求。实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以用许多请求来轰炸我们的服务，它可以很好地容忍它！现在的问题是，当我们有多个请求在彼此之间很快发生时，我们仍然会看到我们的负载指示器显示/隐藏几次，而不是在这种紧密间隔的请求的持续时间内显示指示器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee25" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">进一步改进它</h1><p id="d91b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这最后一章，我们将解决多个请求间隔很近的问题。</p><p id="c16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是确保在我们收到对<code class="fe nb nc nd ne b">hideLoader</code>的请求后，我们不会马上拒绝它，而是引入一个计时器，它会在一定时间后触发<code class="fe nb nc nd ne b">dismiss()</code>方法，在我的例子中，我选择了700毫秒(这是我们的用户观察loader的最小时间)。我们这个定时器<code class="fe nb nc nd ne b">lazyDismissTimer</code>，我们在我们的代码中检查它的状态，当定时器被清零时，我们就使它无效。现在我们只需要记住，我们的<code class="fe nb nc nd ne b">createLoader</code>和<code class="fe nb nc nd ne b">dismissLoader</code>方法应该总是返回一个<code class="fe nb nc nd ne b">Promise</code>，以确保<code class="fe nb nc nd ne b">concatMap</code>可以基于它的排序和步调。服务的完整和最终实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d219" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="250e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">加载指示器是UX的重要组成部分，我最初很天真，认为实现这样的加载器服务是微不足道的，特别是如果你使用异步加载器组件，比如Ionic的离子加载。好消息是RXJS提供了许多有用的操作符，使得这样的实现成为可能。</p><p id="c92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方法，我们还可以让我们的大多数组件没有显示/隐藏请求代码，并避免跨所有组件导入<code class="fe nb nc nd ne b">loader.service.ts</code>的需要，只关注那些真正需要它的组件。</p><p id="e64e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>