<html>
<head>
<title>Java Stream Collectors Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java流收集器解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/java-stream-collectors-explained-6209a67a4c29?source=collection_archive---------3-----------------------#2020-01-02">https://betterprogramming.pub/java-stream-collectors-explained-6209a67a4c29?source=collection_archive---------3-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bdda" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">收集器是如何工作的——我们如何建立自己的收集器？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9ed34555910745698c927e4599f99af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAxy2utKZAtimPkAJe-peQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae ky" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java 8带来了Java最伟大的附加功能之一:流API。它使处理数据流变得非常方便，因为它允许我们将操作缓慢地链接在一起，并通过终端操作结束流畅的呼叫来执行实际的数据处理。</p><p id="f958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener ugc nofollow" target="_blank">java.util.Stream</a></code>提供了两个不同的名为<code class="fe lv lw lx ly b">collect(...)</code>的终端操作，它们将执行可变归约:</p><blockquote class="lz ma mb"><p id="2144" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">可变归约操作在处理流中的元素时，将输入元素累积到可变结果容器中，如集合或StringBuilder。— <a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#MutableReduction" rel="noopener ugc nofollow" target="_blank">甲骨文</a></p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b68e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">含电池</h1><p id="ae0e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Java 8在<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" rel="noopener ugc nofollow" target="_blank">java.util.stream.Collectors</a></code>类中为我们提供了37个不同的收集器，这些收集器大致可以分为三个独立的组:</p><ul class=""><li id="fa2a" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><strong class="lb iu">减少/汇总成一个值或集合类型<br/> </strong>从用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#joining--" rel="noopener ugc nofollow" target="_blank">joining()</a></code>连接字符串到用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toSet--" rel="noopener ugc nofollow" target="_blank">toSet()</a></code>创建新的集合，甚至利用新的特性，比如用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#summarizingInt-java.util.function.ToIntFunction-" rel="noopener ugc nofollow" target="_blank">summarizingInt(...)</a> </code> — <code class="fe lv lw lx ly b"> </code>汇总数字流等等。</li><li id="46ed" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">分组<br/> </strong>三种不同的方式使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">#groupingBy(...)</a></code>和另外三种进行并发/并行处理。</li><li id="4df0" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">分区有<br/>和</strong>两种<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#partitioningBy-java.util.function.Predicate-" rel="noopener ugc nofollow" target="_blank">#partitionBy(...)</a></code>方法可用。</li></ul><p id="8f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最棒的是:我们不局限于所提供的收集者。如果我们需要一些更独特的处理，我们总是可以创建自己的。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="97eb" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">收集器<t a="" r=""/></h1><p id="7d50" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果你曾经检查过一些<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">流API </a>的源代码，你会发现许多泛型和许多不容易阅读或理解的代码。</p><p id="e39d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这源于Java本身，因为不改变其核心或语言本身，实现函数式编程特性是不容易的。但是他们设法添加了这些伟大的新特性，而没有通过一些看起来吓人的代码来损害向后兼容性——至少乍一看是这样。</p><p id="370d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个收集器都必须实现接口<code class="fe lv lw lx ly b">Collector&lt;T, A, R&gt;</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d2eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们稍微剖析一下界面，以便更好地理解发生了什么。</p><h2 id="4dd0" class="oa mo it bd mp ob oc dn mt od oe dp mx li of og mz lm oh oi nb lq oj ok nd ol bi translated">泛型类型</h2><p id="b28d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">该接口由三种通用类型组成:</p><ul class=""><li id="8501" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><strong class="lb iu">T</strong><em class="mc">–</em>将<em class="mc">类型的</em>输入元素进行归约操作</li><li id="e56e" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">A</strong>–可变<em class="mc">累加</em>类型的归约运算。<br/>用于在收集过程中保留部分结果的累加器对象类型。</li><li id="6b15" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">R</strong>–<em class="mc">T32<em class="mc">结果</em>归约操作的类型。收款流程的实际返回类型。</em></li></ul><h2 id="db1b" class="oa mo it bd mp ob oc dn mt od oe dp mx li of og mz lm oh oi nb lq oj ok nd ol bi translated">方法</h2><p id="cdce" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">知道泛型类型代表什么，这些方法更有意义:</p><ul class=""><li id="11c7" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><code class="fe lv lw lx ly b">supplier()</code> <br/>提供了一个<code class="fe lv lw lx ly b">Supplier&lt;A&gt;</code>，用于创建累加器对象的新实例。</li><li id="6233" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe lv lw lx ly b">accumulator()<br/></code><code class="fe lv lw lx ly b">Collector</code>的核心，包括一个<code class="fe lv lw lx ly b"> BiConsumer&lt;A, T&gt;</code>，负责将<code class="fe lv lw lx ly b">T</code>类型的流元素累加到一个累加器对象中。</li><li id="04c1" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe lv lw lx ly b">combiner()</code> <br/>在<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--" rel="noopener ugc nofollow" target="_blank">并行处理一个流</a>的情况下，<code class="fe lv lw lx ly b">Collector</code>可能会创建多个累加器对象。组合器提供了合并结果的功能。</li><li id="d1c1" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe lv lw lx ly b">finisher()<br/></code>通过将累加器对象转换为返回类型<code class="fe lv lw lx ly b">R</code>来完成收集过程。</li><li id="f1ca" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe lv lw lx ly b">characteristics()<br/></code>形容<code class="fe lv lw lx ly b">Collector</code>的特点。</li></ul><h2 id="aae1" class="oa mo it bd mp ob oc dn mt od oe dp mx li of og mz lm oh oi nb lq oj ok nd ol bi translated">收集器特性</h2><p id="4be2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">Collector</code>的特性可用于优化归约操作的实施。这三个特征的任何组合都是可能的:</p><ul class=""><li id="e431" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#CONCURRENT" rel="noopener ugc nofollow" target="_blank">Collector.Characteristics.CONCURRENT</a><br/></code>表示累加器对象支持并行或并发处理。</li><li id="9f2a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#IDENTITY_FINISH" rel="noopener ugc nofollow" target="_blank">Collector.Characteristics.IDENTITY_FINISH</a><br/></code>表示完成器函数是恒等函数，因此累加器可以直接转换为结果类型。</li><li id="e8a2" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#UNORDERED" rel="noopener ugc nofollow" target="_blank">Collector.Characteristics.UNORDERED</a><br/></code>表示流中元素的顺序不一定保持不变。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c61f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">示例:连接字符串</h1><p id="a99a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Java已经提供了一个用分隔符连接字符串的<code class="fe lv lw lx ly b">Collector</code>，但是它为我们自己实现提供了一个很好的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="687b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单——但是仍然是功能很少，代码很多。</p><p id="6521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口<code class="fe lv lw lx ly b">Collector</code>提供了静态方法<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html#of-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BinaryOperator-java.util.function.Function-java.util.stream.Collector.Characteristics...-" rel="noopener ugc nofollow" target="_blank">of(...)</a></code>以一种更具功能性的方式创建<code class="fe lv lw lx ly b">Collector</code>，帮助我们减少对额外类的需求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a8d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在一个接口或不可实例化的类中组合我们的自定义<code class="fe lv lw lx ly b">Collector</code> creator方法——就像Java对<code class="fe lv lw lx ly b">java.util.Collectors</code>所做的那样，使用起来更加简单。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b195" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">reduce(…)呢？</h1><p id="480a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">代替<code class="fe lv lw lx ly b">Collector</code>，我们也可以使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Reduction" rel="noopener ugc nofollow" target="_blank">Stream#reduce(...)</a></code>来实现类似的结果。两者的区别更微妙。reduce操作通过以不可变的方式组合两个值来创建一个新值。</p><p id="2bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，collect操作以可变的方式处理accumulate对象，并使用finisher来获得最终结果。</p><p id="2fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该选择哪一种取决于您的需求—考虑实际的预期目的、性能考虑等。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0030" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="4021" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一旦你理解了它们背后的一般概念，创建一个定制<code class="fe lv lw lx ly b">Collector</code>并不复杂。</p><p id="09e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过像Java那样结合我们的定制<code class="fe lv lw lx ly b">Collector</code> creator方法，我们可以在整个项目中使用和共享我们的收集器。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4689" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><ul class=""><li id="7217" class="nk nl it lb b lc nf lf ng li om lm on lq oo lu np nq nr ns bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/stream/package-summary . html</a></li><li id="46bf" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/stream/collectors . html</a></li><li id="db44" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><a class="ae ky" href="https://www.oracle.com/technical-resources/articles/java/ma14-java-se-8-streams.html" rel="noopener ugc nofollow" target="_blank">https://www . Oracle . com/technical-resources/articles/Java/ma14-Java-se-8-streams . html</a></li></ul><div class="op oq gp gr or os"><a href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">Java函数式编程:流</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">最佳实践概述</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>