<html>
<head>
<title>Solving the Most Common Tech Interview Question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决最常见的技术面试问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-the-most-common-tech-interview-question-798a2e3d1db7?source=collection_archive---------5-----------------------#2019-10-16">https://betterprogramming.pub/solving-the-most-common-tech-interview-question-798a2e3d1db7?source=collection_archive---------5-----------------------#2019-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa23" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">示例Python代码的三种算法方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e57856c03001fc8436ab633c85eba4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LaoCJyA4j1rbq4hI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查尔斯·🇵🇭在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="84d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在做技术面试，那么在某些时候你肯定会遇到<a class="ae ky" href="https://leetcode.com/problems/two-sum/" rel="noopener ugc nofollow" target="_blank">两个总和</a>的问题。</p><p id="ecee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是技术面试中最常见的算法问题之一。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="116f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题陈述</h1><p id="4ad5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">给定一个整数数组，返回两个数的<strong class="lb iu"> </strong>索引，使这两个数相加成为一个特定的目标数。</p><p id="cbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这是一个看似简单的问题，但有多种方法可供选择，每种方法都有各自的优缺点。</p><p id="a441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解这些方法并能够解释它们的不同之处向你的面试官表明你已经很好地掌握了CS的基础知识。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5bc6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法1:简单的方法</h1><p id="a9ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一种方法是最简单的，这可能是您最初解决问题的方法，而不需要花时间考虑优化。</p><p id="09c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您只需遍历所有可能的数字对，并返回第一对相加得到您想要的总和的数字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f082647ecb3caed4ed0e7d3d3e09ab1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*TiWc7rjx2_Gf9YzcvlL3Ng.png"/></div></figure><p id="a103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法在O(n)时间和O(1)空间中运行，其中n是<code class="fe na nb nc nd b">arr</code>的长度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="49f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法2:时间优化</h1><p id="d289" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下一种方法通过使用额外的空间来改善时间复杂度。</p><p id="d25f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先初始化一个空map，它将用于存储以前看到的元素及其索引。</p><p id="57cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，对于列表中的每个元素，您首先通过检查它是否在您的map的键集中来检查您以前是否见过<code class="fe na nb nc nd b">sum_val - current_element</code>。如果是这样，那么你已经找到了你想要的一对，因为<code class="fe na nb nc nd b">current_element + (sum_val - current_element) == sum_val</code>。</p><p id="39cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，将<code class="fe na nb nc nd b">current_element</code>添加到地图中，并继续下一个元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/fb71c034d5dd22a94c461957eda3e016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*PzHuPEWwZBD3DUvA-mxvQA.png"/></div></figure><p id="32e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法在O(n)时间和O(n)空间中运行。在映射是散列映射的情况下，我们假设映射查找是O(1)运算。</p><p id="6ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们只访问每个数组元素一次，因为我们缓存了之前在地图中看到的元素及其索引。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4121" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法3:优化空间</h1><p id="ba0b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后一种方法在不使用额外空间的情况下改善了时间复杂度，但是仍然比方法2使用更多的时间。</p><p id="6d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个方法中，我们将首先对数组进行排序，并使用排序后的数组的属性来提高我们的时间复杂度，而不需要使用辅助空间。</p><p id="68be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用双指针方法。我们在第一个元素开始一个指针，在最后一个元素开始第二个指针。然后我们检查由这些指针指向的两个元素的总和。</p><p id="dd3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果总和太高，则我们递减第二个指针，这减少总和，如果总和太低，则我们递增第一个指针，这增加总和。</p><p id="792a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只能使用这种方法，因为数组是排序的，所以我们可以保证数组是非递减的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/9084446efe75904a762b31e6bf2e823a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5HrDESCNAP91GpbZ3oPEQ.png"/></div></div></figure><p id="fa27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法在O(n * log(n))时间和O(1)空间中运行。这里假设我们使用一种运行时间为O(n * log(n))时间，空间为O(1)的排序方法，比如heapsort。</p><p id="d689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，该方法运行时的主要因素来自于<code class="fe na nb nc nd b">sort</code>操作。之后只进行O(n)次比较，因为指针每次移动1，并且只移动到它们重叠为止。</p><p id="1f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们改进了简单解决方案的时间复杂度，而不需要像方法2那样使用额外的存储。我们能够利用数组被排序的事实来最小化我们必须进行的比较的数量。</p></div></div>    
</body>
</html>