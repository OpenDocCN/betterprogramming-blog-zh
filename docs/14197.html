<html>
<head>
<title>Understanding Gradle Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解梯度任务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-gradle-tasks-417d6f5e13f4?source=collection_archive---------3-----------------------#2022-11-16">https://betterprogramming.pub/understanding-gradle-tasks-417d6f5e13f4?source=collection_archive---------3-----------------------#2022-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2728" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习如何创建、使用和查看任务的结果，等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5e892197899f201270c5ac83d1c43d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Sk_dy578AQcFPlWhrXgzA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="bdef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能很少处理Gradle任务，大多数时候，新的<code class="fe lr ls lt lu b">Task</code>要么作为插件的一部分添加，要么作为从库的“如何开始”指南中复制粘贴的一段代码添加。不了解任务是如何工作的，它们的结构，以及它们的生命周期，使得开发人员更有可能远离对那些任务添加任何改变，即使有改进的空间。</p><p id="6e0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，让我们试着了解一下<strong class="kx ir"> <em class="lv"> </em> </strong>什么是梯度任务，它们是如何创建和使用的，以及它们可以采取什么形式。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="b6e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于<code class="fe lr ls lt lu b">Task</code>你应该知道的基本事情:</p><ul class=""><li id="8656" class="md me iq kx b ky kz lb lc le mf li mg lm mh lq mi mj mk ml bi translated"><code class="fe lr ls lt lu b">Task</code>是一段包含一系列动作的可执行代码。</li><li id="6bed" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq mi mj mk ml bi translated">动作通过<code class="fe lr ls lt lu b">doFirst{}</code>和<code class="fe lr ls lt lu b">doLast{}</code>闭包添加到<code class="fe lr ls lt lu b">Task</code>中。</li><li id="0a41" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq mi mj mk ml bi translated">通过执行<code class="fe lr ls lt lu b">./gradlew tasks</code>可以访问可用任务列表。</li></ul><p id="9379" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了更好地理解Gradle项目实体之间的结构、语法和关系，请看我之前的文章。</p><p id="a571" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，假设您正在测试Android项目或任何其他包含Gradle wrapper的项目中的代码，执行任务X意味着在Mac上运行<code class="fe lr ls lt lu b">./gradlew X</code>或在Windows上运行<code class="fe lr ls lt lu b">gradlew.bat X</code>。</p><h1 id="fe22" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">任务是什么样子的？</h1><p id="16ba" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">您可能已经知道，在Gradle中，事情有许多不同的形式，任务也不例外。任务定义可以通过许多不同的方式来完成，最常见的方式如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码片段#1</p></figure><p id="926f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面运行<code class="fe lr ls lt lu b"> taskName1</code>时，输出并不明显:</p><pre class="kg kh ki kj gt nr lu ns bn nt nu bi"><span id="f8af" class="nv mt iq lu b be nw nx l ny nz">&gt; Configure project :app<br/>Why is this printed first?</span></pre><pre class="oa nr lu ns bn nt nu bi"><span id="921e" class="nv mt iq lu b be nw nx l ny nz">&gt; Task :app:taskName<br/>First?<br/>Last?</span></pre><p id="4ada" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是等等，事情变得更混乱了。让我们为同一任务添加一个更明确的替代形式，只是名称不同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码片段#2</p></figure><p id="cce0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码更具描述性，不言自明。正如你所看到的，我们正在项目的<a class="ae mr" href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskContainer.html" rel="noopener ugc nofollow" target="_blank">任务容器</a>对象<code class="fe lr ls lt lu b">tasks</code>上调用<code class="fe lr ls lt lu b">create()</code>，之后我们配置了新创建的<code class="fe lr ls lt lu b">Task</code>的组属性并将动作添加到列表中。</p><p id="77dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们再次执行我们的<code class="fe lr ls lt lu b">taskName1</code>,看看输出:</p><pre class="kg kh ki kj gt nr lu ns bn nt nu bi"><span id="b6df" class="nv mt iq lu b be nw nx l ny nz">&gt; Configure project :app<br/>Why is this printed first?<br/>Why is this printed first?</span></pre><pre class="oa nr lu ns bn nt nu bi"><span id="bbda" class="nv mt iq lu b be nw nx l ny nz">&gt; Task :app:taskName<br/>First?<br/>Last?</span></pre><p id="8b79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，“为什么先打印这个？”被打印两次。那么它为什么会发生，又是从哪里来的呢？</p><h2 id="b00a" class="ob mt iq bd mu oc od dn my oe of dp nc le og oh ne li oi oj ng lm ok ol ni om bi translated">构建生命周期和阶段</h2><p id="d933" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">与上面声明的任务不同，大多数任务相互依赖。要执行一项任务，Gradle必须了解项目中可用的任务以及该任务有哪些依赖关系。为此，Gradle创建了一个有向无环依赖图，并根据它执行任务。</p><p id="2fec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不要对有向无环依赖图这个术语感到震惊。它的意思是:</p><ul class=""><li id="47dc" class="md me iq kx b ky kz lb lc le mf li mg lm mh lq mi mj mk ml bi translated">任务和它们的依赖关系组成一个图结构，其中节点代表任务，顶点/线代表依赖关系。</li><li id="2844" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq mi mj mk ml bi translated">顶点的方向表示一个任务如何依赖于其他任务。</li><li id="4e8d" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq mi mj mk ml bi translated">非循环意味着不存在这样的任务A和B，其中两者直接或过渡地相互依赖。</li></ul><h2 id="ad2b" class="ob mt iq bd mu oc od dn my oe of dp nc le og oh ne li oi oj ng lm ok ol ni om bi translated">有三个构建阶段:</h2><ul class=""><li id="3e3f" class="md me iq kx b ky nk lb nl le on li oo lm op lq mi mj mk ml bi translated">初始化——从根据<code class="fe lr ls lt lu b">settings.gradle</code>文件创建一个<code class="fe lr ls lt lu b">Settings</code>对象开始，构建Gradle项目中包含的子项目(在Android Studio中称为模块)的层次结构。</li><li id="c00f" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq mi mj mk ml bi translated">配置——配置在初始化阶段发现的每个项目，然后转到各自的<code class="fe lr ls lt lu b">build.gradle</code>文件并配置<code class="fe lr ls lt lu b">Project</code>实例，构建目标任务直接或间接依赖的任务图。</li><li id="5476" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq mi mj mk ml bi translated">执行—执行一个任务，并且所有任务都依赖于所执行的任务，这在配置阶段是已知的。</li></ul><p id="aea4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">了解了构建阶段，我们现在可以理解，尽管我们不直接执行<code class="fe lr ls lt lu b">taskName2</code>，但是<code class="fe lr ls lt lu b">configure{}</code>闭包内的代码仍然在配置阶段执行，这导致了<code class="fe lr ls lt lu b">Why is this printed first?</code>出现两次。</p><h2 id="d9c8" class="ob mt iq bd mu oc od dn my oe of dp nc le og oh ne li oi oj ng lm ok ol ni om bi translated">这能避免吗？</h2><p id="79ac" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">是的，为此，Gradle有<a class="ae mr" href="https://docs.gradle.org/current/userguide/task_configuration_avoidance.html" rel="noopener ugc nofollow" target="_blank">配置避免API </a>。这是创建任务的推荐方法，通过避免直接使用<code class="fe lr ls lt lu b">Task</code>实例，而是使用<code class="fe lr ls lt lu b">TaskProvider</code>并创建对<code class="fe lr ls lt lu b">Task</code>的引用来帮助减少配置时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码被剪切#3</p></figure><p id="864e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe lr ls lt lu b">TaskContainer.register()</code>将阻止任务被包括在配置阶段，除非注册的任务被直接执行或者被包括在正在执行的任务的依赖图中。</p><p id="d409" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尝试再次运行<code class="fe lr ls lt lu b">taskName1</code>，并查看输出是否与添加<code class="fe lr ls lt lu b">taskName3</code>之前相同。同时，运行<code class="fe lr ls lt lu b">taskName3</code>向日志的配置部分增加了一行，因为现在它与<code class="fe lr ls lt lu b">taskName2</code>和<code class="fe lr ls lt lu b">taskName1</code>一起包含在配置阶段</p><pre class="kg kh ki kj gt nr lu ns bn nt nu bi"><span id="7ec8" class="nv mt iq lu b be nw nx l ny nz">&gt; Configure project :app<br/>Why is this printed first?<br/>Why is this printed first?<br/>Why is this printed first?</span></pre><pre class="oa nr lu ns bn nt nu bi"><span id="8c25" class="nv mt iq lu b be nw nx l ny nz">&gt; Task :app:taskName<br/>First?<br/>Last?</span></pre><h2 id="248c" class="ob mt iq bd mu oc od dn my oe of dp nc le og oh ne li oi oj ng lm ok ol ni om bi translated">为什么我们有<code class="fe lr ls lt lu b">doFirst</code>和doLast？</h2><p id="36bf" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">为什么仅仅把动作按正确的顺序执行是不够的，为什么我们需要<code class="fe lr ls lt lu b">doFirst{}</code>和<code class="fe lr ls lt lu b">doLast{}</code>？</p><p id="918b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">暂且把这些闭包看作是在X前后执行的东西，那么X是什么呢？</p><p id="5e2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了回答这个问题，让我们定义一个简单的任务类并运行新创建的任务类的任务，演示定义任务的另一种方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码片段#4</p></figure><p id="d6fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将日志中与配置相关的部分放在一边，新定义类型的两个任务的输出将是:</p><pre class="kg kh ki kj gt nr lu ns bn nt nu bi"><span id="0463" class="nv mt iq lu b be nw nx l ny nz">&gt; Task :app:taskName5<br/>First?<br/>Before and after actions annotated with @TaskAction<br/>Last?</span></pre><p id="4061" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，提供给<code class="fe lr ls lt lu b">doFirst{}</code>和<code class="fe lr ls lt lu b">doLast{}</code>的动作在用<code class="fe lr ls lt lu b">@TaskAction</code>标注的动作之前和之后执行。</p><p id="0b31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在代码片段#4中看到的，<code class="fe lr ls lt lu b"> CustomTaskType</code>扩展了<code class="fe lr ls lt lu b">DefaultTask</code>类，这是一个基本类，您可以扩展它来实现定制的任务类。Gradle有几个有用的、现成的任务类型，你可以<a class="ae mr" href="https://github.com/gradle/gradle/tree/master/subprojects/core/src/main/java/org/gradle/api/tasks" rel="noopener ugc nofollow" target="_blank">在Gradle的Github </a>中找到。</p><h2 id="aaeb" class="ob mt iq bd mu oc od dn my oe of dp nc le og oh ne li oi oj ng lm ok ol ni om bi translated">关于Gradle任务还有什么要知道的？</h2><p id="d5ee" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Task</code>结果表明在构建过程中任务发生了什么。凭直觉，您可能会猜测一个任务可能有三种结果——不执行、使用缓存的结果执行和只是执行。</p><p id="4426" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Gradle中，有五种任务结果:</p><ol class=""><li id="c93f" class="md me iq kx b ky kz lb lc le mf li mg lm mh lq oq mj mk ml bi translated"><code class="fe lr ls lt lu b">NO-SOURCE </code> —任务未执行，因为未找到执行任务所需的输入数据。输入的一个例子可以是注释有<code class="fe lr ls lt lu b">@InputFiles</code> <code class="fe lr ls lt lu b">@SkipWhenEmpty</code>和<code class="fe lr ls lt lu b">@Incremental</code>的文件，其未能由先前的任务产生。</li><li id="7d5c" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq oq mj mk ml bi translated"><code class="fe lr ls lt lu b">SKIPPED</code> —由于某种原因被跳过。这种原因可以是——在任务体中标记为<code class="fe lr ls lt lu b">enabled = false</code>的任务，或者通过命令行参数<code class="fe lr ls lt lu b">-x</code>和一些其他参数从执行过程中排除的任务。</li><li id="3f15" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq oq mj mk ml bi translated"><code class="fe lr ls lt lu b">UP-TO-DATE</code> —自上次构建以来，任务结果未发生变化，可以重复使用。这是<a class="ae mr" href="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:up_to_date_checks" rel="noopener ugc nofollow" target="_blank">增量构建</a>特性的一部分。</li><li id="d6b1" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq oq mj mk ml bi translated"><code class="fe lr ls lt lu b">FROM-CACHE </code> —任务可以从以前的构建中获取。它使用了一个叫做<a class="ae mr" href="https://docs.gradle.org/current/userguide/build_cache.html#sec:task_output_caching" rel="noopener ugc nofollow" target="_blank">任务输出缓存</a>的特性。这是在<code class="fe lr ls lt lu b">UP-TO-DATE</code>中使用的增量构建的一个进步，因为它可以通过从CI获取远程缓存来重用它们。除非您在<code class="fe lr ls lt lu b">gradle.properties</code>中有<code class="fe lr ls lt lu b">org.gradle.caching=true</code>或者您在执行任务时使用<code class="fe lr ls lt lu b">--build-cache</code>标志，否则这不会应用到您的构建中。对于一个可捕捉的任务，它应该被注释为<code class="fe lr ls lt lu b">@CacheableTask</code>。</li><li id="6bcb" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq oq mj mk ml bi translated"><code class="fe lr ls lt lu b">EXECUTED</code> —任务执行成功。该标签不会显示在日志中。</li></ol><p id="6b66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让这些结果可见，使用一个标志<code class="fe lr ls lt lu b">--console=plain</code>，例如，在一个Android项目中，你可以在<code class="fe lr ls lt lu b">assembleDebug</code>上使用它:</p><pre class="kg kh ki kj gt nr lu ns bn nt nu bi"><span id="eb4b" class="nv mt iq lu b be nw nx l ny nz">./gradlew assembleDebug --console=plain</span></pre><p id="7c8c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理想情况下，一个构建应该有尽可能多的<code class="fe lr ls lt lu b">UP-TO-DATE</code>和<code class="fe lr ls lt lu b">FROM-CACHE</code>以获得更快的执行时间。</p><h2 id="4272" class="ob mt iq bd mu oc od dn my oe of dp nc le og oh ne li oi oj ng lm ok ol ni om bi translated">任务排序和相关性</h2><p id="963e" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">已经提到过一个<code class="fe lr ls lt lu b">Task</code>可以依赖于其他任务，但是在代码中是什么样子的呢？以下这些指标表示任务相互依赖:</p><p id="25de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">明确定义两个任务之间的关系:</p><ul class=""><li id="e91d" class="md me iq kx b ky kz lb lc le mf li mg lm mh lq mi mj mk ml bi translated"><code class="fe lr ls lt lu b">dependsOn</code> — <code class="fe lr ls lt lu b">task X { dependsOn Y }</code>，任务X的执行需要任务Y，如果Y执行失败，X的执行将不会发生。</li><li id="ff8a" class="md me iq kx b ky mm lb mn le mo li mp lm mq lq mi mj mk ml bi translated"><code class="fe lr ls lt lu b">finalizedBy</code> — <code class="fe lr ls lt lu b">task X { finalizedBy Y }</code>任务Y将在任务X之后执行，即使任务X未能执行或被跳过。</li></ul><p id="177b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输入和输出注释:</p><ul class=""><li id="9fe0" class="md me iq kx b ky kz lb lc le mf li mg lm mh lq mi mj mk ml bi translated"><code class="fe lr ls lt lu b">@OutputFile</code>和<code class="fe lr ls lt lu b">@InputFile</code> —是通过注释任务的输入和输出来创建依赖关系的隐式方法。这种方法需要配置具有匹配输入和输出的任务。</li></ul><h1 id="f165" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="27a5" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">任务可以用多种方式定义，但并不是所有的都一样好。对于配置时间，使用配置避免API并使用<code class="fe lr ls lt lu b">TaskContainer.register()</code>注册任务。</p><p id="0bc5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理解<code class="fe lr ls lt lu b">Task</code>结果以识别构建的弱点，并通过适当地构建任务之间的依赖关系并使增量构建和任务输出缓存机制发挥作用，尽可能地缓存任务执行结果，这是很好的做法。</p><pre class="kg kh ki kj gt nr lu ns bn nt nu bi"><span id="9ee1" class="nv mt iq lu b be nw nx l or nz"><strong class="lu ir">Want to Connect?</strong><br/><br/>Connect with me on <a class="ae mr" href="https://twitter.com/leonov_dmitrii" rel="noopener ugc nofollow" target="_blank">Twitter</a> and <a class="ae mr" href="https://www.linkedin.com/in/dmitrii-leonov/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>