# 那些雨燕子串是怎么回事？

> 原文：<https://betterprogramming.pub/whats-going-on-with-those-swift-substrings-83c58cedf596>

## 看看当你分解一根弦时会发生什么

![](img/98a6ce056b4efadd716fb06952d015ed.png)

[亲教会媒体](https://unsplash.com/@prochurchmedia?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/cut-paper?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

# 笔记

尽管我们认为字符串切片是软件开发中的一项常见任务，但许多 Swift 开发人员发现`substring`很复杂，令人沮丧。

# 比较其他语言中的子字符串

让我们看看 substring 在其他计算机语言中是如何工作的:

```
C++: str.substr(2,8)
Java: str.substring(2,8)
Python: str[2,8]
Objective-C: [str substringWithRange:NSMakeRange(2,6)]
```

现在让我们看看 substring 在 Swift 中是如何工作的:

```
var startIndex = str.index(str.startIndex, offsetBy: 2)
var endIndex    =   str.index(startIndex, offsetBy: 6)
var substring = str[startIndex..<endIndex]
```

# 问题的根源——UTF-8

为了理解字符串是如何工作的，我们需要回到基础——Unicode 和 UTF-8。

当我们处理字符串时，我们感觉我们在处理一个纯文本，只是一系列符号和数字，但这是一个谎言。过去是这样的，当时计算机使用的是一种叫做 ASCII 的东西。

ASCII 是一种将所有重要字符(字母、数字、符号)表示为 32 到 127 之间的数字的方式，所以每个字符占用一个字节的内存。

而 127 到 255 呢？每个开发人员都可以用它做他们想做的任何事情，所以你可以想象当计算机离开美国到非英语国家时我们有多混乱。

这就是 Unicode 发挥作用的地方——在世界上几乎每种语言中，Unicode 都是表示你能想到的每个字母和数字的方式，不仅如此，Unicode 还非常适合表示表情符号。

因此，Unicode 字符映射表是一个四字节的映射表，由于我们输入的大多数字符是英文字母和数字，为每个字符分配四个字节是非常低效的，而在大多数情况下，一个字节就足够了。

这是矩阵的最后一块->编码，在这种情况下，UTF-8。

UTF-8 是一种将 Unicode 字符串编码成更小数据块的方法，因此效率更高。

# UTF-8 是如何在引擎盖下工作的？

你可以在网上找到大量关于文本编码的材料，所以我不会在这篇文章中深入探讨，但我至少会试着解释一下基础知识。

Unicode 保存四个字节的字符映射数据。前 127 个字符是传统的 ASCII，接下来的 1920 个字符是拉丁语言、阿拉伯语、希伯来语等。之后，我们可以找到中文、日文和韩文，等等。

所以，根据上面的内容，你可以理解，比如在处理英语的时候，在大多数情况下我们不需要利用所有的四个字节，我们可以只使用映射的第一个字节。

那么，编码是如何工作的呢？我们如何知道每个字符使用了多少字节？我们使用数据的第一位来通知编码器我们为这个字符分配了多少字节。

理解这一点的最好方法是通过例子。让我们试着代表 UTF 8 中的字符。

“←”的 Unicode 十六进制值是 U+20A4，这意味着它将占用三个字节的内存。20A4 的二进制值是0010 0000 1010 0100。

现在，我们要宣布我们将使用三个字节的内存，所以我们从三位 1 开始，然后是 0:

1110

然后，为了完成第一个字节，我们将取 20A4 的前四位，并完成 UTF-8 值的第一个字节:

1110–0010

对于第二个字节，我们从 10 开始，之后是 20A4 的下六位:

1110–0010 1000–0010

对于第三个字节，我们也要这样做—从 10 开始，然后是 20A4 的剩余 6 位:

1110–0010 1000–0010 1010–0100

而这就是我们在 UTF-8 和世界上几乎每一个符号中代表“←”的方式。

# UTF 8 比 UTF 16 好，对吧？

是的。我的意思是，不。嗯，这很复杂…这取决于你用它做什么。

例如，如果大部分符号位于 ASCII 区域(英语和数字)，UTF-8 可能非常有效。但是如果你用中文书写或者使用很多表情符号，那么 UTF-16 可能更适合这种情况。

就像上一部分一样，我要用一个例子来说明。

UTF-8 中的字符串“AB”将是“41 42”，而在 UTF-16 中是“41 00 42 00”。

但是中文字符串“いろは”在 UTF-8 中将是“E3 81 84 E3 82 8D E3 81 AF ”,在 UTF-16 中将是“44 30 8d 30 6f 30”——占了一半的空间。

# Swift 中编码与子字符串有什么关系？

想象下一个字符串:

```
let str = “I have a friend called 摩西, nice name 😀, ha?”
```

上面的字符串有 43 个字符，但是它占用了 50 个字节的空间。由于前面对 UTF-8 工作原理的解释，你已经理解了字符数和字节数的区别。

For example, the name “摩西”, which holds two characters, takes six bytes of space, and the single emoji “😀” takes four bytes of space (!).

让我们看看当我们试图打印字符串的长度时会发生什么:

```
print(str.count) // print 43
print(str.utf8.count) //print 50
```

如果，理论上，你可以做`str[10]`，你会期望编译器到达变量中的第 10 位并返回`f`。但要做到这一点，编译器需要了解字符串中第 10 个元素的内存地址是什么。

如果每个字符总是占用一个字节，这将非常容易，但由于它的大小未知，编译器需要从字符串的开头迭代，直到它到达第 10 个元素，正因为如此，这是一个 O(n)操作，只是为了访问单个变量。

所以，当你试图做类似于`str[10…15]`的事情时，你需要迭代字符串两次来得到一个子串。

# 遇见弦。索引

为了有效地进行字符串操作，我们使用了`String.Index`。`String.Index`是表示字符串中计算位置的结构。

因为我们不想为了得到一个子串而迭代字符串两次，所以可以用`String.Index`只迭代一次。

我们迭代到第一个索引，然后从第一个索引迭代到第二个索引。

使用索引的好处是它已经被计算过了。您可以保存它，传递它，并重用它，而不是让编译器在每次您想要访问特定位置时迭代该字符串。

# 更多字符串效率技巧

Swift 中的字符串除了`String.Index`还有更多效率招数。

例如，您是否知道当您对一个字符串进行子字符串化时，您不会为该子字符串获得一个新分配的空间？它只是对原始字符串的内存部分的引用，因此字符串及其子字符串共享它们的存储，这在内存和性能方面都是高效的。

这意味着子字符串是一个临时变量，如果您想继续使用字符串片段，您需要将其转换为字符串。

Swift 的另一个巧妙技巧是 COW(写时复制)。COW 的意思是当你复制一个变量(集合类型和字符串)时，它会共享同一个存储空间，直到你修改了新的副本才会分配新的内存。这是懒惰的内存分配。

# 字符串扩展

如果您仍然想做类似于`str[5..<10]`的事情来获得子串，那么您可以添加一个字符串扩展来实现这一目的:

但是记住这不是最有效的方法，如果你想让你的程序运行得更快，推荐使用`String.Index`。

# 摘要

一个字符串不是一个简单的数组，它是一个复杂而不同的野兽。Swift 语言开发人员选择了性能和内存效率的方法，而不是可读性。

幸运的是，我们可以通过添加一个字符串扩展在可读性和效率之间进行选择(就像在其他开发领域一样),这和许多其他情况一样，使我们作为开发人员的生活变得更加容易。