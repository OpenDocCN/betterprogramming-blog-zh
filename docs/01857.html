<html>
<head>
<title>Little-Known Facts About Exports and module.exports in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中关于导出和module.exports的鲜为人知的事实</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unknown-facts-about-exports-and-module-exports-in-node-js-d06b65a8057d?source=collection_archive---------14-----------------------#2019-10-17">https://betterprogramming.pub/unknown-facts-about-exports-and-module-exports-in-node-js-d06b65a8057d?source=collection_archive---------14-----------------------#2019-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ec3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习导出和模块导出的更好方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7cacf4a40d262b772a6e69dd176edee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvK5MJFSWagYb_EC8V3-QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导出和模块导出</p></figure><p id="8874" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们在Node.js中编写代码时，我们以模块化的方式编写代码。我们将代码写入不同的文件，并通过使用<code class="fe lu lv lw lx b">exports</code>和<code class="fe lu lv lw lx b">module.exports</code>来公开这个文件。</p><p id="5389" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Node.js为我们在每个文件中编写的每段代码创建了一个函数包装器。它还提供对该文件中一些全局对象的访问— <strong class="la iu"> </strong> <code class="fe lu lv lw lx b">Object</code> <strong class="la iu"> </strong>就是其中之一。</p><p id="fbd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块<code class="fe lu lv lw lx b">object</code>包含并导出属性。但是，在这个名单中，还有一个<code class="fe lu lv lw lx b">exports.global</code>。同时拥有<code class="fe lu lv lw lx b">exports.global</code>和<code class="fe lu lv lw lx b">object</code>模块可能会令人困惑。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h2 id="8205" class="mf mg it bd mh mi mj dn mk ml mm dp mn lh mo mp mq ll mr ms mt lp mu mv mw mx bi translated">为什么它们令人困惑？</h2><p id="d2c4" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">假设我们从一个模块中导出几个东西，其中一个是函数:<code class="fe lu lv lw lx b">myFunction()</code>。</p><p id="65ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以在另一个模块中要求它，如下所示:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="4cb7" class="mf mg it lx b gy nh ni l nj nk">require(‘./file.js’).myFunction();</span></pre><p id="f9b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想使用<code class="fe lu lv lw lx b">module.exports</code>将其导出，您可以这样做:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="d1e8" class="mf mg it lx b gy nh ni l nj nk">module.exports.myFunction=function(){<br/> console.log(“Its myFunction()”);<br/>}</span></pre><p id="c657" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码运行良好。</p><p id="fb06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你也可以用<code class="fe lu lv lw lx b">exports</code>全局变量做同样的事情:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="5da3" class="mf mg it lx b gy nh ni l nj nk">exports.myFunction() = function(){<br/> console.log(“its myFunction()”);<br/>}</span></pre><p id="953b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个它也很好用。所以以上两个代码都没有问题。</p><p id="5e41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么问题出在哪里呢？我们在哪里感到困惑？</p><p id="389b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比方说，我正试图<code class="fe lu lv lw lx b">exports</code>从模块中取出一个函数，我们将在使用此代码的其他模块中使用该函数:</p><p id="cbcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">require(‘./file.js’)();</code></p><p id="da9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们给函数赋值<code class="fe lu lv lw lx b">module.exports</code>,如下所示:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="9ffe" class="mf mg it lx b gy nh ni l nj nk">module.exports=function myFunction(){<br/> console.log(“Hello World”);<br/>}</span></pre><p id="aefe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很好。但是当我们试图用<code class="fe lu lv lw lx b">exports</code>变量这样做时，我们得到一个错误:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="4aec" class="mf mg it lx b gy nh ni l nj nk">exports= function(){<br/>   console.log(“Hello World”);<br/>}</span></pre><p id="9e54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里出了什么问题？</p><p id="467a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我们从任何其他模块内部使用任何一个模块时，我们都会得到一个对module对象上的<code class="fe lu lv lw lx b">exports</code>属性的引用，node使该对象在该模块内部可用。</p><p id="3a34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，任何其他模块可以从这个模块访问的唯一东西就是<code class="fe lu lv lw lx b">module.exports</code>所指向的东西，它是一个空的JavaScript对象。</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="74fb" class="mf mg it lx b gy nh ni l nj nk">module={<br/>       exports:{}<br/>}</span></pre><p id="3316" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看这段代码:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="8b12" class="mf mg it lx b gy nh ni l nj nk">module.exports.key1=10</span></pre><p id="6013" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者这里:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="8fab" class="mf mg it lx b gy nh ni l nj nk">module.exports.key2 = {<br/>                        key3:10<br/>}</span></pre><p id="de8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只是给<code class="fe lu lv lw lx b">module.exports</code>对象添加关键点:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="7dcc" class="mf mg it lx b gy nh ni l nj nk">module.exports={<br/>                key1:10,<br/>                key2:{<br/>                       key3:10 <br/>                }<br/>}</span></pre><p id="3b5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些键(<code class="fe lu lv lw lx b">key1</code>、<code class="fe lu lv lw lx b">key2</code>、<code class="fe lu lv lw lx b">key3</code>)将在<code class="fe lu lv lw lx b">module.exports</code>对象与其他文件一起暴露时被导出，如果我们将<code class="fe lu lv lw lx b">module.exports</code>的引用分配给一个函数，如下所示:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="6021" class="mf mg it lx b gy nh ni l nj nk">module.exports=function(){<br/>         console.log(“”Hello World);<br/>}</span></pre><p id="ce6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当节点与所需文件共享<code class="fe lu lv lw lx b">module.exports</code>时，也应该公开该引用。</p><p id="dc86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">exports.global</code>变量是对将被导出的<code class="fe lu lv lw lx b">module.exports</code>对象的引用。</p><p id="56bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果我们向<code class="fe lu lv lw lx b">exports</code>添加属性，我们实际上是向<code class="fe lu lv lw lx b">module.exports</code>对象添加属性，如下所示:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="ed5a" class="mf mg it lx b gy nh ni l nj nk">exports.key1=10;<br/>exports.key2={key3:10};</span></pre><p id="5c84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和这个一样:</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="cefd" class="mf mg it lx b gy nh ni l nj nk">module.exports={<br/>      key1:10,<br/>      key2:{key3:10}<br/>}</span></pre><p id="c998" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些将按预期导出。</p><p id="ee05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当我们想要导出一个函数并将<code class="fe lu lv lw lx b">export</code>变量赋给该函数时，像这样怎么办呢？：</p><pre class="kj kk kl km gt nd lx ne nf aw ng bi"><span id="9aa4" class="mf mg it lx b gy nh ni l nj nk">exports= function myOtherFunction(){<br/>    console.log(“Hello , I am lost”);<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/8ea0e2d0d8276f70342ed2d4a8cd3df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKZey3e6Plewu_c47M0JLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd nn">导出一个函数并分配导出变量</strong></p></figure><p id="0694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们丢失了对<code class="fe lu lv lw lx b">module.exports</code>对象的引用，现在我们的<code class="fe lu lv lw lx b">exports</code>指向一个函数，如下所示:</p><p id="7da1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">IMG:丢失了对<strong class="la iu">模块的引用。导出</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7cacf4a40d262b772a6e69dd176edee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvK5MJFSWagYb_EC8V3-QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丢失了对<strong class="bd nn">模块的引用。导出</strong></p></figure><p id="89db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在node.js中，<code class="fe lu lv lw lx b">module.exports</code>对象总是暴露的，对<code class="fe lu lv lw lx b">myOtherFunction()</code> <strong class="la iu"> </strong>函数一无所知。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="dd2d" class="no mg it bd mh np nq nr mk ns nt nu mn jz nv ka mq kc nw kd mt kf nx kg mw ny bi translated">结论</h1><p id="a022" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">结论是<code class="fe lu lv lw lx b">module.exports</code>的引用将总是在节点模块中导出，而<code class="fe lu lv lw lx b">exports</code>只是<code class="fe lu lv lw lx b">module.exports</code>的别名，我们使用它来使我们的暴露变得容易。</p><p id="3eca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还确保没有改变<code class="fe lu lv lw lx b">module.exports</code>的参考值。如果因为任何原因我们改变了参考，我们就失去了<code class="fe lu lv lw lx b">exports</code>的目的。</p><p id="4214" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nl">如果你对node.js感兴趣，那么这些文章会很有帮助:</em></p><ul class=""><li id="33cc" class="nz oa it la b lb lc le lf lh ob ll oc lp od lt oe of og oh bi translated"><a class="ae oi" href="https://medium.com/@svsh227/create-a-flame-graph-for-your-node-app-profiling-nodejs-app-e0a91e5ed585" rel="noopener">为你的node app | Profiling nodeJS app创建火焰图</a></li><li id="f1f5" class="nz oa it la b lb oj le ok lh ol ll om lp on lt oe of og oh bi translated"><a class="ae oi" href="https://medium.com/swlh/profiling-node-app-detect-the-memory-leak-in-your-node-app-3663f61cb02f" rel="noopener">检测您的节点应用程序|分析节点应用程序中的内存泄漏</a></li><li id="d76d" class="nz oa it la b lb oj le ok lh ol ll om lp on lt oe of og oh bi translated"><a class="ae oi" href="https://medium.com/@svsh227/profiling-nodejs-application-detect-the-memory-uses-of-node-app-use-of-inspect-d3f6a723c513" rel="noopener">检测节点app的内存使用情况</a></li><li id="08e2" class="nz oa it la b lb oj le ok lh ol ll om lp on lt oe of og oh bi translated"><a class="ae oi" href="https://medium.com/better-programming/make-a-dump-of-the-v8-heap-and-inspect-for-your-node-app-b69f7b68c162" rel="noopener">创建V8堆的转储，并为您的节点应用程序检查它</a></li><li id="4dc6" class="nz oa it la b lb oj le ok lh ol ll om lp on lt oe of og oh bi translated"><a class="ae oi" href="https://medium.com/@svsh227/create-your-own-error-handler-library-and-its-response-model-for-your-node-app-5422db5658e1" rel="noopener">为您的节点应用程序</a>创建您自己的错误处理程序库及其响应模型</li></ul><p id="1a25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nl">感谢阅读！</em></p></div></div>    
</body>
</html>