<html>
<head>
<title>A Modern JavaScript Production Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript生产设置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/vue2-typescript3-production-set-up-92622933c690?source=collection_archive---------17-----------------------#2020-03-03">https://betterprogramming.pub/vue2-typescript3-production-set-up-92622933c690?source=collection_archive---------17-----------------------#2020-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4542" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何让Vue.js2、TypeScript、webpack、ESLint、VSC协同工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2e0552c65d1cd5ca22cbf9d03d80e946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qb5DHami242fuENDPcuTfQ.png"/></div></div></figure><h1 id="b35a" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="fbe7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">普通JavaScript开发人员在一个新项目的设置上投入了多少时间？大约，永远。这就是为什么我认为让您了解我们的工具带实际上是如何工作的非常重要。在本文中，我将介绍一个用<a class="ae mf" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js2 </a>和<a class="ae mf" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>构建的客户端应用程序的典型设置。采用的工具将是:</p><ul class=""><li id="cb29" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">ESLint+beauty+林挺样式Lint +格式</li><li id="ee47" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">我们构建过程的webpack +依赖项</li><li id="ca03" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">摩卡+ <a class="ae mf" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a> + <a class="ae mf" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank">西农</a>进行测试</li></ul><p id="b022" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">如果你不同意我的一些选择，我很高兴听到你的想法，并可能更新这篇文章。</p><h2 id="f5d7" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">先决条件</h2><p id="4d29" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">本指南假设您具备以下条件:</p><ul class=""><li id="11e5" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">Node.js已安装(<a class="ae mf" href="https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-18-04" rel="noopener ugc nofollow" target="_blank">节点安装说明</a>)</li><li id="fc93" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">Visual Studio代码已安装(<a class="ae mf" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank">此处下载</a>)</li><li id="9a3a" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">Git已安装(<a class="ae mf" href="https://www.linode.com/docs/development/version-control/how-to-install-git-on-linux-mac-and-windows/" rel="noopener ugc nofollow" target="_blank"> Git安装说明</a>)</li></ul></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="2fe9" class="kr ks iq bd kt ku ns kw kx ky nt la lb jw nu jx ld jz nv ka lf kc nw kd lh li bi translated">初始化项目</h1><p id="785c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我将描述我在创建一个新项目时所经历的各个步骤。如果你正在寻找关于某个特定主题的输入，直接跳到前面。</p><p id="399d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">TL；DR: </strong>你也可以克隆这个<a class="ae mf" href="https://github.com/MarcRoemmelt/Vue2-TypeScript3-Production-Set-Up" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><h2 id="edac" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">Visual Studio代码</h2><p id="86a7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们从设置VS代码开始。创建一个项目文件夹，并在VS代码中打开它。然后，将其作为工作空间保存在该文件夹中(文件&gt;工作空间另存为&gt;…)。这将产生一个<code class="fe nx ny nz oa b">xx.code-workspace</code>文件，允许我们为这个工作区指定配置。打开这个文件也将在VS代码中打开您的工作区。</p><p id="d2e5" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们最终的工作区配置将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d1eb" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">接下来，我们将安装一些(我几乎可以说是<em class="od">基本</em>)扩展:</p><ul class=""><li id="827a" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><a class="ae mf" href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir"> ESLint </strong> </a>会将我们的林挺集成到我们的代码编辑器中，当你违反代码的风格规则或犯下更严重的暴行时，它会通知你</li><li id="59dd" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><a class="ae mf" href="https://marketplace.visualstudio.com/items?itemName=stylelint.vscode-stylelint" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir">stylelint</strong></a><strong class="ll ir"/>将样式文件的林挺集成到编辑器中，并支持自动修复</li><li id="9f4e" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><a class="ae mf" href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir">Git lens</strong></a><strong class="ll ir"/>集成Git版本控制。它允许您做Git能做的大多数令人惊奇的事情——但是直接在您的代码编辑器中。</li><li id="5639" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><a class="ae mf" href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir">Vetur</strong></a><strong class="ll ir"/>带来了很多Vue特有的工具，从语法高亮到代码片段</li><li id="f7d8" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><a class="ae mf" href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir">Chrome调试器</strong> </a> <strong class="ll ir"> </strong>允许我们在Chrome中运行应用时，在VS代码中调试应用源代码</li></ul><h2 id="93cb" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">。编辑器配置</h2><p id="ef95" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这个简短的配置文件用于在不同的编辑器之间交流基本的编辑器样式选择，例如<code class="fe nx ny nz oa b">tab-size</code>。你可以在这里阅读更多关于它的<a class="ae mf" href="http://editorconfig.org" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9597" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我通常对每种文件类型都使用相同的设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="d6e8" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">。nvmrc</h2><p id="d0a1" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这几乎是微不足道的，但是如果您碰巧在您的项目中使用不同版本的Node.js，这就非常方便了。根目录中有一个<code class="fe nx ny nz oa b">.nvmrc</code>文件允许您锁定正在使用的Node.js版本。它包含一行版本号，例如<code class="fe nx ny nz oa b">12.14.1</code>。这里的<a class="ae mf" href="https://github.com/nvm-sh/nvm#nvmrc" rel="noopener ugc nofollow" target="_blank">见</a>。</p><h2 id="881f" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated"><strong class="ak"> package.json </strong></h2><p id="3f37" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">接下来，我们将创建项目的<code class="fe nx ny nz oa b"><a class="ae mf" href="https://docs.npmjs.com/files/package.json" rel="noopener ugc nofollow" target="_blank">package.json</a></code>文件。该文件属于节点包管理器(npm)生态系统。它包含一些关于您的项目的配置，用于管理您的应用程序使用的第三方代码(依赖项)，并允许您定义简单的脚本，这些脚本通常用于触发带有正确选项的命令行工具。</p><p id="53e3" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">它通常由<code class="fe nx ny nz oa b">npm init</code>命令创建——但是您也可以手动创建client/ <code class="fe nx ny nz oa b">package.json</code>文件。如果您使用了<code class="fe nx ny nz oa b">npm init</code>并接受了所有默认设置，您的文件将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2c61" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们将逐步更新这个文件——现在我们可以保持不变。我鼓励你在这里了解更多关于它的信息<a class="ae mf" href="https://docs.npmjs.com/files/package.json" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="f429" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated"><strong class="ak"> Git </strong></h2><p id="87bc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果您从未听说过它，那么<a class="ae mf" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>是使用最广泛的版本控制系统(而且是遥遥领先)。简单地说，Git允许您复制、粘贴、恢复和合并代码。它帮助开发人员在相同的代码基础上工作，而不会干扰彼此的工作(大多数情况下)，同时提供整个项目的详细变更历史。只能说相当牛逼。</p><p id="0557" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们用命令<code class="fe nx ny nz oa b">git init</code>创建一个新的Git存储库。</p><p id="8c3d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">如果你想共享你的代码，在你的项目中添加一个远程存储库是很有帮助的(例如，在<a class="ae mf" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上)。它允许你把你的代码<code class="fe nx ny nz oa b">push</code>到一个公共可访问的服务器上。您可以使用以下命令添加远程存储库:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="082f" class="mz ks iq oa b gy oi oj l ok ol">git remote add &lt;remoteName&gt; &lt;remoteURL&gt;</span></pre><p id="afc8" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">不要忘记，您可以通过将文件添加到一个<code class="fe nx ny nz oa b">.gitignore</code>文件中来排除文件被Git跟踪。此文件包含也将被忽略的文件模式。应该跟踪<code class="fe nx ny nz oa b">.gitignore</code>文件本身。点击阅读更多<a class="ae mf" href="https://git-scm.com/docs/gitignore" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="04c7" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">打字稿</h2><p id="2e95" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">TypeScript是JavaScript的一个超集(它包含JavaScript的所有功能，但在其上添加了一些功能— <a class="ae mf" href="https://hackernoon.com/i-finally-understand-static-vs-dynamic-typing-and-you-will-too-ad0c2bd0acc7" rel="noopener ugc nofollow" target="_blank">如静态类型化</a>)。它在用JavaScript构建生产应用程序时变得非常流行，并且很快会成为编写JavaScript的默认方式。如果你想了解打字稿的优势(劣势)，我推荐这篇文章。</p><p id="4939" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">要运行TypeScript，我们只需安装一个全局npm包:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="5af9" class="mz ks iq oa b gy oi oj l ok ol">npm install -g typescript</span></pre><p id="5997" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">这个包使我们能够用<code class="fe nx ny nz oa b">tsc</code>命令将<code class="fe nx ny nz oa b">.ts</code>文件编译成<code class="fe nx ny nz oa b">.js</code>——例如，<code class="fe nx ny nz oa b">tsc index.ts</code>这个命令将在与原始<code class="fe nx ny nz oa b">.ts</code>文件相同的文件夹中创建一个同名的<code class="fe nx ny nz oa b">.js</code>文件。(我们不会使用这个命令，因为我们使用webpack。)</p><p id="0467" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">下一次运行根文件夹(<code class="fe nx ny nz oa b">Client</code>)中的<code class="fe nx ny nz oa b">tsc --init</code>。这将创建一个<code class="fe nx ny nz oa b">tsconfig.json</code>文件，其中充满了可用编译器选项的简洁摘要(这对于像我这样记忆力不好的人来说非常好)。</p><p id="7f01" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们；我将向它添加更多的配置—请看一看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0049" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">你可以在<a class="ae mf" href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" rel="noopener ugc nofollow" target="_blank">官方打字稿网站</a>上阅读所有选项的更全面的解释。</p><h2 id="3d21" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated"><strong class="ak">林挺/格式化</strong></h2><p id="9044" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">干净的代码看起来像是由一个人写的。Linters允许我们执行特定的规则，使我们的代码整体上更具可读性。通常，linters由两种类型的规则组成，以确保一致的编码风格:格式规则(例如，行不能超过100个字符)和代码质量规则(例如，避免使用<code class="fe nx ny nz oa b">let</code>而使用<code class="fe nx ny nz oa b">const</code>)。</p><p id="6f96" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">JavaScript中最常用的linter是<a class="ae mf" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>。我们将使用它，它令人惊叹的社区已经创建了几个有用的插件——例如，一个为单个文件组件应用Vue特定样式的插件。</p><p id="e3ca" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">注:</strong>在<code class="fe nx ny nz oa b">typescript-eslint</code>发布之前，你还得依靠TSLint来Lint打字脚本代码。然而，不可能在ESLint生态系统中使用TSLint的附加工具。这就是为什么我推荐大家使用<code class="fe nx ny nz oa b">typescript-eslint</code>，尽管它的配置稍微复杂一些。</p><p id="44c5" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">让我们安装所有必需的依赖项:</p><ul class=""><li id="55ae" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">eslint</code>:基础ESLint包</li><li id="03ee" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">vue-eslint-parser</code>:自定义解析器，允许ESLint解析<code class="fe nx ny nz oa b">.vue</code>文件。这个解析器的输出将是一个<code class="fe nx ny nz oa b">.js</code>文件，它具有代表文件块的导入依赖关系(例如<code class="fe nx ny nz oa b">&lt;template&gt;</code>或<code class="fe nx ny nz oa b">&lt;style&gt;</code>)。</li><li id="4d97" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">@typescript-eslint/parser:</code>我们将告诉<code class="fe nx ny nz oa b">vue-eslint-parser</code>使用这个解析器来解释写在<code class="fe nx ny nz oa b">.vue</code>文件中的<code class="fe nx ny nz oa b">&lt;script&gt;</code>块</li><li id="975d" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">@typescript-eslint/eslint-plugin</code>:ESLint插件，应用特定于类型脚本的规则</li><li id="bff6" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">eslint-plugin-vue</code>:将特定于Vue的林挺规则应用于单个文件组件，例如组件选项或元素属性的排序</li><li id="50e8" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">这些软件包可以让你和ESLint一起使用beautiful。漂亮的是一个强大的代码格式化程序，具有强大的自动修复能力。</li></ul><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="09cd" class="mz ks iq oa b gy oi oj l ok ol">npm i -D eslint vue-eslint-parser @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-vue prettier eslint-config-pretter eslint-plugin-prettier</span></pre><p id="5d1d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">为了将所有这些位放在一起，我们必须定义包含ESLint配置的<code class="fe nx ny nz oa b">.eslintrc</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ede0" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">当然，你可以根据自己的喜好改变规则——唯一重要的是坚持一套规则。你可以在这里阅读更多关于ESLint <a class="ae mf" href="https://eslint.org/docs/user-guide/getting-started" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="369c" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">注意</strong>:我们还在一个<code class="fe nx ny nz oa b">.prettierrc</code>文件中添加了更漂亮的配置。</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="e6e8" class="mz ks iq oa b gy oi oj l ok ol">{<br/>  "arrowParens": "always",<br/>  "trailingComma": "all",<br/>  "singleQuote": true,<br/>  "printWidth": 120,<br/>  "tabWidth": 2<br/>}</span></pre><p id="52bf" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">棉线</strong></p><p id="795b" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">您可能已经猜到了— <a class="ae mf" href="https://stylelint.io/" rel="noopener ugc nofollow" target="_blank"> stylelint </a>允许您对各种样式文件实施规则。它远没有JavaScript林挺重要；然而，我喜欢我的文件整洁。</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="357a" class="mz ks iq oa b gy oi oj l ok ol">npm i -D stylelint <!-- -->stylelint-webpack-plugin <!-- -->stylelint-config-sass-guidelines stylelint-config-standard</span></pre><p id="3a2f" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">将一个<code class="fe nx ny nz oa b">.stylelintrc</code>文件添加到您的根文件夹，并添加您的配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e83b" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">注意:</strong>使用<code class="fe nx ny nz oa b">no-empty-source</code>规则——否则stylelint会对没有样式块的<code class="fe nx ny nz oa b">.vue</code>文件抛出错误。</p><p id="8368" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">自动修复</strong></p><p id="32e3" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">ESLint、Prettier和stylelint的一个重要特性是通过运行带有<code class="fe nx ny nz oa b">--fix</code>标志的命令来自动修复常见问题。更好的是:我们之前安装的VS代码扩展为我们的代码编辑器提供了自动修复功能。负责的配置在我们上面创建的工作区配置(<code class="fe nx ny nz oa b">&lt;projectname&gt;.code-workspace)</code>)中。</p><p id="529a" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">注意:记住禁用编辑器拥有的代码格式化程序以避免冲突。</p><p id="1b40" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">饭桶挂钩</strong></p><p id="dcdf" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">此时，我还想向您介绍一些工具。<a class="ae mf" href="https://www.npmjs.com/package/husky" rel="noopener ugc nofollow" target="_blank"> Husky </a>库为我们提供了一种设置Git挂钩的简单方法，允许您在每次调度Git动作时运行一些代码(例如<code class="fe nx ny nz oa b">commit</code>)。</p><p id="800f" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">负责任的代码位于我们的<code class="fe nx ny nz oa b">package.json</code>文件的根级别。我们使用<code class="fe nx ny nz oa b">pre-commit</code>钩子来检查我们的项目的林挺错误，并运行我们的单元测试。如果ESLint报告错误，提交将中止。</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="ea3c" class="mz ks iq oa b gy oi oj l ok ol">“husky”: {<br/>  “hooks”: {<br/>    “pre-commit”: “npm run lint &amp;&amp; npm run test”<br/>  }<br/>},</span></pre><p id="b998" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><a class="ae mf" href="https://www.npmjs.com/package/husky" rel="noopener ugc nofollow" target="_blank">阅读更多关于哈士奇的内容</a>。</p><h2 id="169d" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">网络包4</h2><p id="343f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Webpack 是一个开源的JavaScript模块捆绑器，同样适用于TypeScript。webpack允许我们做的基本上是遍历我们项目的所有文件，并将它们组合成一个输出文件(或多个输出文件)，并在我们处理这些文件时处理所有的文件。因此，webpack是整个工具世界的入口点。您可以:</p><ul class=""><li id="4290" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">使用最新的ES2020特性编写代码，并自动将其传输到每个烤面包机都能理解的ES5</li><li id="d346" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">自动最小化您的代码以节省文件大小</li><li id="e680" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">轻松集成CSS预处理程序，如SASS</li><li id="8d09" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">在必要的地方自动应用CSS前缀和PostCSS</li><li id="57d2" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">使用大量的工具来分析你的代码</li><li id="6486" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">轻松应用代码分割</li></ul><p id="5d3e" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">不幸的是，丰富的特性和插件使得webpack对于新开发人员来说很难安装。但是坦白地说，一旦你阅读了文档，它实际上是非常合理的。</p><p id="8280" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">在我们深入配置文件之前，让我们安装所有的依赖项:</p><ul class=""><li id="4299" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">webpack</code>:基础包</li><li id="fe5e" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">webpack-cli</code>:命令行界面(我们将它与npm脚本一起使用)</li><li id="3bb4" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">webpack-dev-server</code>:一个开发服务器，允许热重载文件的变化，并在开发模式下为我们的应用服务</li><li id="3e19" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">clean-webpack-plugin</code>:用于清理/移除我们的输出文件夹</li><li id="69c1" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">html-webpack-plugin</code>:创建一个HTML文件来服务我们的应用捆绑包。它动态地插入带有相应哈希值的链接标签，并与其他插件一起支持合理的预加载策略。</li><li id="0059" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">copy-webpack-plugin</code>:将单个文件或整个目录复制到构建文件夹中</li><li id="d790" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">optimize-css-assets-webpack-plugin</code>:优化/最小化CSS资产</li><li id="667b" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">mini-css-extract-plugin</code>:将单个文件组件的CSS加载到单独的文件中</li><li id="9418" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">terser-webpack-plugin</code>:用于缩小JavaScript</li><li id="63d6" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">critters-webpack-plugin</code>:用于内联关键CSS，惰性加载其余的(文档<a class="ae mf" href="https://github.com/GoogleChromeLabs/critters" rel="noopener ugc nofollow" target="_blank">此处</a>)</li><li id="f475" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">stylelint-webpack-plugin</code>:允许我们将风格林挺集成到我们的构建过程中</li><li id="76d5" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">webpack-node-externals</code>:允许我们很容易地告诉webpack它不应该在我们的包中包含<code class="fe nx ny nz oa b">node_modules</code>。我们将在单元测试中使用它——不需要在那里包含它们。</li></ul><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="872c" class="mz ks iq oa b gy oi oj l ok ol">npm install -D webpack webpack-cli webpack-dev-server clean-webpack-plugin html-webpack-plugin copy-webpack-plugin optimize-css-assets-webpack-plugin mini-css-extract-plugin terser-webpack-plugin critters-webpack-plugin stylelint-webpack-plugin webpack-node-externals</span></pre><p id="cff7" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">webpack在所谓的<em class="od">加载器</em>的帮助下转换所有文件。</p><p id="6c53" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">简单来说，这些是webpack为每个符合定义条件的文件调用的函数。然后，加载程序解析/解释/转换文件，并将其传递给下一个加载程序或返回给webpack。然后，webpack将文件写入其输出文件夹。</p><p id="201a" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们将使用一整套加载器(和一些依赖项)。让我们安装它们:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="d4ec" class="mz ks iq oa b gy oi oj l ok ol">npm install -D vue-loader vue-template-compiler url-loader ts-loader style-loader sass-loader node-sass raw-loader file-loader css-loader postcss-loader autoprefixer babel-loader @babel/core @babel/preset-env core-js thread-loader cache-loader eslint-loader</span></pre><ul class=""><li id="e3fd" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated">言行一致</li><li id="5056" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">ts-loader</code>:web pack的类型脚本加载器</li><li id="7247" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">style-loader</code>:用<code class="fe nx ny nz oa b">&lt;style&gt;</code>标签将CSS注入DOM/HTML</li><li id="4bf2" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">vue-loader &amp;&amp; vue-template-compiler</code>:加载<code class="fe nx ny nz oa b">.vue</code>文件，允许我们对所有模块(包括自定义模块)使用单独的加载器。预编译HTML模板需要模板编译器。</li><li id="803b" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">sass-loader &amp;&amp; node-sass</code>:加载Sass/SCSS并编译成CSS。<strong class="ll ir">注意:</strong>如果你在你的项目中使用Sass，你还需要安装<code class="fe nx ny nz oa b">node-sass</code>，它可以让node理解Sass ( <a class="ae mf" href="https://github.com/sass/node-sass" rel="noopener ugc nofollow" target="_blank">阅读更多</a>)。</li><li id="5c90" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">raw-loader</code>:允许我们以字符串形式导入文件</li><li id="26f3" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">file-loader</code>:将导入的文件解析为URL(用于图像等文件)</li><li id="e1e3" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">css-loader</code>:解释并解析CSS的导入</li><li id="27e7" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">postcss-loader &amp;&amp; autoprefixer</code>:用<a class="ae mf" href="https://postcss.org/" rel="noopener ugc nofollow" target="_blank"> PostCSS </a>处理你的CSS的加载器。<code class="fe nx ny nz oa b">autoprefixer</code>是PostCSS使用的一个模块，它给你的CSS加前缀，以确保跨浏览器的兼容性。您可以在您的webpack配置或一个单独的<code class="fe nx ny nz oa b">postcss.config.js</code>文件中配置PostCSS(以使用<code class="fe nx ny nz oa b">autoprefixer</code>)。</li></ul><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="5257" class="mz ks iq oa b gy oi oj l ok ol">module.exports = {<br/>  plugins: [<br/>    require(‘autoprefixer’),<br/>  ],<br/>}</span></pre><ul class=""><li id="f7a0" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">babel-loader &amp;&amp; @babel/core &amp;&amp; @babel/preset-env &amp;&amp; core-js</code>:允许我们将<a class="ae mf" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>与webpack一起使用。Babel将<code class="fe nx ny nz oa b">ts-loader</code>的JavaScript输出转换为早期版本的JavaScript，并添加了<code class="fe nx ny nz oa b">core-js</code>polyfill以确保浏览器兼容性。</li></ul><p id="38f8" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">巴别塔需要一些基本的配置才能运行。在项目根目录下创建一个包含以下内容的<code class="fe nx ny nz oa b">.babelrc</code>文件:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="700d" class="mz ks iq oa b gy oi oj l ok ol">{<br/>  “presets”: [<br/>    [<br/>      “<a class="ae mf" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a>”,<br/>      {<br/>        “targets”: {<br/>          “ie”: “11”<br/>        },<br/>        “useBuiltIns”: “usage”,<br/>        “corejs”: “3”<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><p id="3ae3" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们简单地告诉Babel使用<code class="fe nx ny nz oa b">preset-env</code>配置，将我们的JavaScript传输到目标Internet Explorer 11，并使用core-js@3传输polyfil。</p><ul class=""><li id="47c4" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">thread-loader</code>:允许该加载器链中的以下加载器使用多线程。这将加速像<code class="fe nx ny nz oa b">babel-loader</code>这样的重型装载机。</li><li id="28e6" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">cache-loader</code>:缓存加载器的输出，这加快了连续构建的速度</li><li id="cb99" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">eslint-loader</code>:允许我们在处理所有文件之前对其进行Lint处理</li></ul><p id="8828" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">最后，让我们加入另一个插件来分析我们的应用程序的包大小:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="cd63" class="mz ks iq oa b gy oi oj l ok ol">npm install -D webpack-bundle-analyzer</span></pre><p id="683d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">将所有内容组合在一起的配置如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="67f0" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">这个配置也将作为我们对<code class="fe nx ny nz oa b">webpack-dev-server</code>的配置，这是一个在开发过程中为我们的应用服务并提供热模块重载的便捷工具。为了运行和构建我们的应用程序，我们使用上面定义的<code class="fe nx ny nz oa b">npm scripts</code>:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="0589" class="mz ks iq oa b gy oi oj l ok ol">// Client/package.json</span><span id="b3aa" class="mz ks iq oa b gy om oj l ok ol">{<br/>  ...<br/>  "scripts": {<br/>    "start": "webpack-dev-server --host 0.0.0.0 --hot",<br/>    "build": "webpack -p --progress",<br/>    ...<br/>  },<br/>  ...<br/>}</span></pre><p id="f123" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><code class="fe nx ny nz oa b">--hot</code>标志启用热重装，<code class="fe nx ny nz oa b">-p</code>将<code class="fe nx ny nz oa b">env.mode</code>设置为<code class="fe nx ny nz oa b">production</code>，并且<code class="fe nx ny nz oa b">--progress</code>告诉webpack以百分比显示构建进度。</p><h2 id="5c20" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">测试(摩卡、兴农、柴)</h2><p id="071e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我不知道你是怎么想的，但是每次我通过为一个新特性编写测试来开始它的时候，它就工作了。此外，测试驱动开发(TDD)是每份简历上的热门词汇。所以我们开始吧。</p><p id="0fd6" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们在Mocha周围使用一个包装器库来运行我们对Mochapack的测试。它允许我们首先用webpack构建我们的项目，然后用我们构建的项目运行我们的单元测试。</p><p id="a0b4" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">让我们安装所有的依赖项:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="ee40" class="mz ks iq oa b gy oi oj l ok ol">npm install -D mocha mochapack jsdom jsdom-global @types/mocha chai @types/chai sinon @types/sinon @vue/test-utils</span></pre><ul class=""><li id="f84e" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">mocha &amp;&amp; @types/mocha:</code>我们的测试运行者(我们的测试运行的过程)</li><li id="4c76" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">moochapack</code>:Mocha的包装器，这样我们可以在运行测试之前用webpack构建我们的项目</li><li id="d380" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">chai &amp;&amp; @types/chai</code>:断言库。它为我们提供了帮助函数，以一种很好的语法方式来比较值。</li><li id="8c48" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">sinon &amp;&amp; @types/sinon:</code>一个stubbing库。它使我们能够轻松地替换对象的属性/方法，并附带了许多有用的帮助函数来测试它们的行为。</li><li id="2ce8" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">@vue/test-utils</code>:测试Vue组件的实用功能</li><li id="0f2b" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">jsdom &amp;&amp; jsdom-global</code>:许多web标准(html 5/Web API)的JavaScript实现，通常用于模仿浏览器行为。<code class="fe nx ny nz oa b">jsdom-global</code>将这个DOM实现注入到节点运行时。</li></ul><p id="f009" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">通常，您将在您的<code class="fe nx ny nz oa b">client/tests</code>文件夹中创建一个<code class="fe nx ny nz oa b">setup.ts</code>文件，您可以在其中初始化运行您的测试可能需要的环境。在基本设置中，这可能只是<code class="fe nx ny nz oa b">jsdom</code>:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="b661" class="mz ks iq oa b gy oi oj l ok ol">// client/tests/setup.ts<br/>require('jsdom-global')();</span></pre><p id="4287" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">现在，我们可以简单地创建我们的单元测试——如何测试Vue被他们的团队很好地<a class="ae mf" href="https://vue-test-utils.vuejs.org/" rel="noopener ugc nofollow" target="_blank">记录了下来</a>。</p><p id="db14" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">最后，让我们设置一个<code class="fe nx ny nz oa b">npm script</code>来运行它们:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="7ee1" class="mz ks iq oa b gy oi oj l ok ol">"scripts": {<br/>  ...<br/>  “test”: “mochapack”,<br/>  “test:watch”: “mochapack --watch”<br/>}</span></pre><p id="d245" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><code class="fe nx ny nz oa b">--watch</code>标志告诉Mocha不要退出过程，而是观察文件的变化，并在变化的文件中重新运行测试(方便开发)。</p><p id="694c" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">执行时，<code class="fe nx ny nz oa b">mochapack</code>会自动在您的<code class="fe nx ny nz oa b">package.json</code>文件夹中寻找一个<code class="fe nx ny nz oa b">mochapack.opts</code>文件。我们使用这个文件来定义一些命令行选项:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="75b4" class="mz ks iq oa b gy oi oj l ok ol">// mochapack.opts</span><span id="33f2" class="mz ks iq oa b gy om oj l ok ol">--colors<br/>--webpack-config webpack.config.js<br/>--webpack-env test<br/>--require test/unit/setup.ts<br/>--recursive<br/>'test/**/*.spec.{js,ts}'</span></pre><ul class=""><li id="8165" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">--colors</code>:强制Mocha在其终端输出中使用颜色</li><li id="735b" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">--webpack-config</code>:指定我们想要使用的webpack配置</li><li id="6ce8" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">--webpack-env</code>:指定webpack环境。如果您查看我们的webpack配置，您会注意到我们的测试模式有稍微不同的行为</li><li id="86c2" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">--require</code>:告诉Mocha在运行测试之前运行并执行一个文件</li><li id="3d16" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">--recursive</code>:在子目录中查找测试</li><li id="d3ef" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><code class="fe nx ny nz oa b">’test/**/*.spec.{js,ts}'</code>:匹配应该包含的文件的glob，由webpack捆绑，由Mocha运行。在这种情况下，我们所有的单元测试都位于一个<code class="fe nx ny nz oa b">test</code>目录中，并以<code class="fe nx ny nz oa b">.spec.ts</code>或<code class="fe nx ny nz oa b">.spec.js</code>结束。</li></ul><p id="8839" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">提示:我通常不太担心完整的测试覆盖，因为我只测试那些看起来可能会在未来引起问题的代码。然而，如果你这样做了，我建议你看看测试覆盖工具<a class="ae mf" href="https://istanbul.js.org/" rel="noopener ugc nofollow" target="_blank">伊斯坦布尔</a>——更准确地说，他们的CLI工具<code class="fe nx ny nz oa b">nyc</code> ( <a class="ae mf" href="https://github.com/istanbuljs/nyc" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><h2 id="2088" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">排除故障</h2><p id="131c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">幸运的是，在VS代码中调试非常简单。只需添加一个<code class="fe nx ny nz oa b">Client/.vscode</code>文件夹，并在其中创建一个<code class="fe nx ny nz oa b">launch.json</code>文件。</p><p id="d444" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们将为我们的应用程序配置三种启动配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0c2b" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">我们的第一个配置允许我们调试我们的单元测试。只需设置断点，选择此配置，并启动调试器(F5)。</p><p id="270d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">第二个配置使用了一个名为Chrome 的<a class="ae mf" href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" rel="noopener ugc nofollow" target="_blank">调试器的VS代码扩展。它允许我们在Chrome中运行应用程序，同时在源代码中使用断点。简单地设置断点(例如，在一个<code class="fe nx ny nz oa b">mounted()</code>钩子中)，运行您的应用程序(<code class="fe nx ny nz oa b">npm run start</code>，然后通过选择配置并按F5启动调试器。</a></p><h2 id="d593" class="mz ks iq bd kt na nb dn kx nc nd dp lb ls ne nf ld lw ng nh lf ma ni nj lh nk bi translated">设置Vue</h2><p id="9e05" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">最后，现在是时候开始你的实际项目了！我假设每个人都已经熟悉了Vue本身(他们也有很棒的<a class="ae mf" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank">文档</a>)。因此，我将只提及使用TypeScript时的一些常见问题，并列举一些我用于特定用例的优秀模块。</p><p id="776d" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><code class="fe nx ny nz oa b"><a class="ae mf" href="https://github.com/kaorun343/vue-property-decorator" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir">vue-property-decorator</strong></a></code></p><p id="7b54" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">用TypeScript编写Vue组件最简单的方法是基于类的语法。这个语法需要几个<a class="ae mf" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank">类型脚本修饰器</a>才能工作。在这种情况下，你可能听说过<code class="fe nx ny nz oa b">vue-class-component</code>。然而，这个库旨在支持TypeScript用户旁边的Babel用户——Babel与<code class="fe nx ny nz oa b">vue-property-decorator</code>中包含的一些装饰器冲突。</p><p id="f9b3" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">因为我们用TypeScript编译了所有的decorators，所以我们可以毫无问题地使用这个库。更多关于这个<a class="ae mf" href="https://github.com/vuejs/vue-class-component/issues/50" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>。</p><p id="3d5f" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">声明*。vue模块</strong></p><p id="83d8" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">为了让TypeScript能够导入<code class="fe nx ny nz oa b">*.vue</code>文件，我们必须将它们声明为模块。CLI在一个包含以下内容的<code class="fe nx ny nz oa b">shims.vue.d.ts</code>文件中执行此操作:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="7ef7" class="mz ks iq oa b gy oi oj l ok ol">declare module ‘*.vue’ {<br/>  import Vue from ‘vue’;<br/>  export default Vue;<br/>}</span></pre><p id="7959" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">如果你想增加Vue的接口，我建议你在项目的根层创建一个<code class="fe nx ny nz oa b">types</code>文件夹。在该文件夹中，您可以创建包含<code class="fe nx ny nz oa b">index.d.ts</code>文件的子文件夹。在这些文件中，您可以导入想要扩充的模块。例如:</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="4535" class="mz ks iq oa b gy oi oj l ok ol">// client/types/vue/index.d.ts</span><span id="c1b5" class="mz ks iq oa b gy om oj l ok ol">import Vue from ‘vue’;</span><span id="2e48" class="mz ks iq oa b gy om oj l ok ol">declare module ‘vue/types/vue’ {<br/>  interface Vue {<br/>    $myProp: string; // allows this.$myProp or vm.$myProp<br/>  }<br/>}</span></pre><p id="2504" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">你可以在这里找到更多关于如何增加Vue类型<a class="ae mf" href="https://vuejs.org/v2/guide/typescript.html#Augmenting-Types-for-Use-with-Plugins" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="2a83" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">为了告诉TypeScript它应该包含我们在<code class="fe nx ny nz oa b">types/*</code>中的类型定义，我们已经在<code class="fe nx ny nz oa b">tsconfig.json</code>中包含了下面一行。</p><pre class="kg kh ki kj gt oe oa of og aw oh bi"><span id="d4c2" class="mz ks iq oa b gy oi oj l ok ol">“typeRoots”: [“./types”, “./node_modules/@types”]</span></pre><p id="c47e" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated"><strong class="ll ir">注意:</strong>务必将<code class="fe nx ny nz oa b">"./types"</code>放在<code class="fe nx ny nz oa b">"./node_module/@types"</code>之前。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="2b36" class="kr ks iq bd kt ku ns kw kx ky nt la lb jw nu jx ld jz nv ka lf kc nw kd lh li bi translated">最后的想法</h1><p id="2fe7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">以下是我强烈推荐的一些模块和插件:</p><ul class=""><li id="9d78" class="mg mh iq ll b lm mi lp mj ls mk lw ml ma mm me mn mo mp mq bi translated"><strong class="ll ir">状态管理</strong> : <code class="fe nx ny nz oa b">vuex</code>为vue提供状态管理，灵感来自Redux。提示:对于类型化的商店使用<code class="fe nx ny nz oa b">vuex-smart-module</code>。更多信息<a class="ae mf" href="https://github.com/ktsn/vuex-smart-module" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</li><li id="cb53" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">URL操作 : <code class="fe nx ny nz oa b">vue-router</code>是一个允许我们管理Vue应用程序URL的模块。堪比React路由器。</li><li id="6d0f" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">页面元数据信息: <code class="fe nx ny nz oa b"><a class="ae mf" href="https://github.com/nuxt/vue-meta" rel="noopener ugc nofollow" target="_blank">vue-meta</a></code>是一个小的库，允许我们用组件选项(标题、元标签等)设置页面元数据。)</li><li id="f696" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><strong class="ll ir">翻译</strong> : <code class="fe nx ny nz oa b">vue-i18n</code>让您轻松地将所有文本翻译成不同的语言</li><li id="8703" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">WebWorker是一个很棒的小型库(1.1Kb)，它包装了你的web worker，并允许你像普通的导入模块一样访问它们</li><li id="dfe4" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><strong class="ll ir"> IndexedDB </strong> : <code class="fe nx ny nz oa b">Dexie</code>是围绕IndexedDB的恐怖API的一个小包装器(18Kb gzipped)。它的性能很好，并且有一个简单明了的API。</li><li id="9f92" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated"><strong class="ll ir"> AJAX </strong>:老实说，我更喜欢用原生的<code class="fe nx ny nz oa b">fetch</code>。但是<code class="fe nx ny nz oa b"><a class="ae mf" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank">axios</a></code>和<code class="fe nx ny nz oa b"><a class="ae mf" href="https://github.com/vuejs/vue-apollo" rel="noopener ugc nofollow" target="_blank">vue-apollo</a></code>分别是很好的REST/GraphQL获取库。</li><li id="3a11" class="mg mh iq ll b lm mr lp ms ls mt lw mu ma mv me mn mo mp mq bi translated">SSR :使用SSR和VueJS最简单的方法无疑是NuxtJS。然而，它对你应该如何构建你的项目非常固执己见。</li></ul><p id="67b9" class="pw-post-body-paragraph lj lk iq ll b lm mi jr lo lp mj ju lr ls mw lu lv lw mx ly lz ma my mc md me ij bi translated">好了，感谢阅读！希望这篇文章对某人有所帮助。</p></div></div>    
</body>
</html>