<html>
<head>
<title>Relating With Docker and Kubernetes As Developers — An Analogue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与作为开发者的Docker和Kubernetes相关联——一个类比</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/relating-with-docker-and-kubernetes-as-developers-an-analogue-5e662b1f817b?source=collection_archive---------9-----------------------#2021-10-25">https://betterprogramming.pub/relating-with-docker-and-kubernetes-as-developers-an-analogue-5e662b1f817b?source=collection_archive---------9-----------------------#2021-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="246e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我在任何地方都找不到有趣的K8s速成班，所以我做了一个</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/284300dbb89b9f26605d0dc7a4633059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*01cAC1aIMhqUlBFj"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的气候现实项目<a class="ae kv" href="https://unsplash.com/@climatereality?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="264f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些还没有机会，但希望得到一个关于<strong class="ky ir"> K </strong> (ubernete)(8) <strong class="ky ir"> s </strong>的好主意，和/或想亲自动手的开发人员。</p><p id="4d68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为软件行业的新人，Kubernetes对我来说是陌生的。这与我所做的软件开发没有直接关系，或者说我是这样认为的。进入这个行业一年后，我对它有了初步的了解，但我仍然没有太多的互动。当然，理论上我知道Kubernetes的基本知识，但不知何故，我读的所有文章都太难懂，课程太长。</p><p id="b37b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Kubernetes有了更多的互动，现在我发现它与我作为开发人员的经历非常相似。我在任何地方都找不到吸引人的、有关联的课程，所以我做了一个。</p><h1 id="1aa6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">旅程开始了！</h1><p id="88d5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是一个冒险的新生第一天上班的故事。这也是一篇关于K8s的文章，大家多多包涵。</p><h2 id="9af1" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">应用程序:向涉众提供预定义服务的开发人员</h2><blockquote class="nb nc nd"><p id="232c" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">应用程序(简称为app或应用程序)是一种计算机程序，设计用于执行通常由最终用户使用的特定任务。</p></blockquote><p id="2bc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某种程度上，他们与执行任务来开发软件以满足最终用户需求的开发人员有关。</p><h1 id="429c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们如何让每一个开发者独立而有效？</h1><h2 id="7638" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">容器:开发人员的便携式工作空间工具包</h2><p id="5acb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">容器是操作系统虚拟化的一种形式。它们是软件可执行单元，其中应用程序代码及其依赖关系和配置以可以在任何环境下运行的方式打包。</p><p id="e807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们提供了进程隔离并优化了资源利用。它们不包含操作系统映像。因此，它们更轻、更便携、开销更少。</p><blockquote class="nb nc nd"><p id="7d39" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">想想像工作机器/笔记本电脑这样的容器，它们可以使员工独立工作并有效地提供服务。它们是便携式的，使员工能够在家或办公室工作，并拥有员工完成任务所需的所有资源。它们也是隔离的，因此员工不会受到其他人在他们的机器上运行的内容的影响。</p></blockquote><h1 id="4e72" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">它始于一件事…入职指南</h1><h2 id="318c" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">图片:使用工作区套件的入门指南/蓝图</h2><p id="e670" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了理解Kubernetes是如何工作的，我们必须熟悉图像。</p><blockquote class="nb nc nd"><p id="a0b2" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">这些图像是一组用于构建容器的可执行命令集。它们是不可变的文件，是容器的快照，使它们成为容器的指南或模板。</p></blockquote><p id="836e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图像是其他图像的层，每个图像都源自前一层，但在某些方面有所不同。当您启动一个映像时，您实际上正在运行它的一个容器。同一个图像可以有多个运行的容器。</p><p id="4aa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图像可以与用于启动工作机器的指南或手册相关联。或者，把它想象成最初创建工作机器的蓝图:)。</p><h1 id="e012" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Docker图像和容器入门</h1><p id="8581" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Docker是一个众所周知的运行时环境，用于在容器内创建和构建应用程序。它使用Docker映像在不同的环境中部署容器化的应用程序或软件，从开发到测试和生产。</p><h2 id="6817" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">创建一个样例Go应用程序</h2><p id="6847" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们创建一个基本的Go应用程序，我们将使用它部署在我们的<code class="fe ni nj nk nl b">minikube</code>集群上。</p><p id="b952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个目录my-app，其中包含下面的main.go文件。从命令行运行以下命令:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="928e" class="mp lt iq nl b gy nq nr l ns nt">go mod init <br/>go mod tidy</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">main.go</p></figure><h2 id="66db" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">为Go应用程序创建docker文件</h2><p id="6ce3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了给我们的应用程序创建dockerfile，我们将参考<a class="ae kv" href="https://docs.docker.com/language/golang/build-images/" rel="noopener ugc nofollow" target="_blank">这个</a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Dockerfile文件</p></figure><h2 id="da4d" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">构建docker映像并运行容器</h2><p id="0c24" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要构建docker映像，请在终端中运行以下命令:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="848a" class="mp lt iq nl b gy nq nr l ns nt">docker build --tag myapp .<br/>docker images</span></pre><p id="3050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该能够在列表中看到新创建的<code class="fe ni nj nk nl b">myapp</code>图像。</p><p id="08e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们尝试<a class="ae kv" href="https://docs.docker.com/language/golang/run-containers/" rel="noopener ugc nofollow" target="_blank">将图像作为容器</a>运行。因为容器是独立运行的，所以我们需要将容器内部的端口暴露给我们的主机端口。</p><blockquote class="nb nc nd"><p id="be18" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">为了发布容器的端口，我们将在docker run命令中使用<code class="fe ni nj nk nl b">--publish</code>标志(简称为<code class="fe ni nj nk nl b">-p</code>)。<code class="fe ni nj nk nl b">--publish</code>命令的格式是<code class="fe ni nj nk nl b">[host_port]:[container_port]</code>。因此，如果我们想将容器内部的端口<code class="fe ni nj nk nl b">8080</code>暴露给容器外部的端口<code class="fe ni nj nk nl b">3000</code>，我们可以将<code class="fe ni nj nk nl b">3000:8080</code>传递给<code class="fe ni nj nk nl b">--publish</code>标志。</p></blockquote><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="9f2a" class="mp lt iq nl b gy nq nr l ns nt">docker run -d -p 8080:10000 myapp</span></pre><p id="0c28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在终端中打开localhost:8080；它应该说</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="3d73" class="mp lt iq nl b gy nq nr l ns nt">Welcome to myapp!</span></pre><p id="8164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们对docker容器和生成它们的模板(即图像)有了一个概念。我们来看看容器调度器，这就是K8s。</p><h1 id="817d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么我们需要容器调度程序？为什么K8s胜过集装箱/码头工人？</h1><p id="f3f4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们看到了容器对于在任何环境下以隔离的方式运行应用程序是多么有用。然而，在生产中，可能需要成百上千个不同的容器。</p><p id="b96c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像Docker这样的容器运行时系统受益于使用额外的技术来编排或管理所有使用中的容器。</p><h1 id="aef6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们如何指导所有开发人员同步工作以提供最终产品？</h1><h2 id="ccb3" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">Kubernetes:工程经理</h2><blockquote class="nb nc nd"><p id="1472" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">Kubernetes是一个开源的容器管理和部署平台。它协调虚拟机集群，并根据可用的计算资源和容器的资源需求，调度容器在这些虚拟机上运行。他们可能与经理有关，经理计划和协调开发人员交付项目，并确保他们拥有完成项目所需的所有资源。</p></blockquote><p id="a96c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用K8s来部署我们的服务，在不停机的情况下推出新的版本，以及扩展这些服务。它是可移植的、可扩展的、自我修复的和高度可用的。</p><h2 id="d463" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">什么是豆荚？</h2><blockquote class="nb nc nd"><p id="6b9c" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">Kubernetes <a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> pod </em> </a>是一组一个或多个容器，为了管理和联网的目的而连接在一起。</p></blockquote><p id="9c74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的工作区类比中，pods可以是一对高级和初级开发人员，他们一起完成相关的任务。它也可以是一个开发人员，他熟悉这个系统，并且习惯于独自处理任务。</p><h2 id="25fb" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">节点和集群:为开发人员提供资源的工作站</h2><p id="3877" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">考虑上面员工工作区的例子。每位员工都需要显示器、椅子、桌子等资源。，才能正常工作。经理需要给每个员工分配这些资源。</p><blockquote class="nb nc nd"><p id="1403" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">一个节点可以被认为是提供这些资源的工作站，以及将这些工作站分配给员工的管理器kubernetes。</p></blockquote><p id="74ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Kubernetes中，节点是一台工作计算机，可以是虚拟的，也可以是物理的。一个节点可以有许多pod，Kubernetes自动处理集群节点之间的pod调度。节点是计算的最小单位。为了建立集群，节点共享它们的资源。</p><h1 id="11a7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Kubectl和Minikube入门</h1><p id="5d24" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Kubectl是Kubernetes的CLI，用于与Kubernetes API交互来创建和管理集群。要安装kubectl，请运行以下命令:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="7c5e" class="mp lt iq nl b gy nq nr l ns nt">brew install kubectl</span></pre><h2 id="1faa" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">Minikube是什么？</h2><blockquote class="nb nc nd"><p id="b4dd" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">Minikube是一个让你在本地尝试Kubernetes的工具。它是本地机器上的单节点K8s集群，用于开发或试用K8s。Minikube工具包括一组内置的<a class="ae kv" href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" rel="noopener ugc nofollow" target="_blank">插件</a>，可以在本地Kubernetes环境中启用、禁用和打开。</p></blockquote><p id="024f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<a class="ae kv" href="https://formulae.brew.sh/formula/minikube" rel="noopener ugc nofollow" target="_blank">安装minikube </a>并在MacOS上启动，运行以下命令:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="6e35" class="mp lt iq nl b gy nq nr l ns nt">brew install minikube<br/>minikube start</span></pre><h1 id="e243" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">向Kubernetes部署您的服务</h1><p id="7fad" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，使用以下命令将您构建的本地docker映像推入minikube缓存:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="019a" class="mp lt iq nl b gy nq nr l ns nt">minikube cache add myapp:latest</span></pre><h2 id="7014" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">部署:年初定义的团队目标和结构</h2><p id="7ec7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个<em class="ne">部署</em>为<a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank">pod</a>和<a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" rel="noopener ugc nofollow" target="_blank">复制集</a>提供声明性更新。</p><blockquote class="nb nc nd"><p id="f4cf" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">在部署中，我们定义一个期望的状态，部署控制器逐渐将当前状态转换为期望的状态。部署可用于构建新的副本集或删除当前部署并用新部署替换它们。</p></blockquote><p id="a17f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看下面的部署文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">部署. yaml</p></figure><p id="4931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的部署文件就像是pods和<code class="fe ni nj nk nl b">replicasets</code>的声明性模板。上面的部署在<code class="fe ni nj nk nl b">{metadata.name}</code>中命名为<code class="fe ni nj nk nl b">myapp</code>，创建一个<code class="fe ni nj nk nl b">replicaset</code>来调出两个<code class="fe ni nj nk nl b">myapp</code>吊舱。现在,{spec.containers.image}给出了要提取的图像，以运行由<code class="fe ni nj nk nl b">{template.metadata.labels}</code> <code class="fe ni nj nk nl b">app:myapp</code>给出的pod中的容器。部署通过<code class="fe ni nj nk nl b">{spec.selector.matchlabels} app:myapp</code>知道要管理哪些pod。</p><h2 id="e8e3" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">什么是复制集？</h2><p id="7bc8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">副本集的目标是始终保持一组一致的副本盒运行。因此，它经常被用来确保一定数量的相同豆荚的可用性。</p><h2 id="5d99" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">通用部署策略</h2><p id="dfd6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">重新创建:终止所有现有的pod，然后生成新的pod</p><p id="c8f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">滚动:单元是以滚动的方式创建的，慢慢增加直到所有新单元都在运行</p><h2 id="a54f" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">创建K8s部署</h2><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="fe6d" class="mp lt iq nl b gy nq nr l ns nt">kubectl apply -f deployment.yaml</span></pre><h2 id="5c01" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">检查minikube集群中的跑步记录</h2><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="d572" class="mp lt iq nl b gy nq nr l ns nt">kubectl get pods</span></pre><p id="d0e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在尝试进入pod并检查应用程序是否正在运行:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="851a" class="mp lt iq nl b gy nq nr l ns nt">kubectl exec -it &lt;pod-name&gt; sh<br/>apk update<br/>apk add curl<br/>curl localhost:10000</span></pre><h2 id="0086" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">检查Kubernetes的自愈能力</h2><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="910c" class="mp lt iq nl b gy nq nr l ns nt">kubectl delete pod &lt;pod-name&gt;<br/>kubectl get pods</span></pre><p id="8bd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该能看到两个舱还在运行。由于我们删除了一个pod，<code class="fe ni nj nk nl b">replicaset</code>控制器检测到它并启动另一个pod以保持两个pod的期望状态。</p><h1 id="b5e9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">外部团队如何相互沟通？</h1><h2 id="7717" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">Kubernetes服务:将相关的外部通信路由到开发人员的SPOC团队</h2><p id="2443" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">豆荚是短暂的资源。部署可以动态生成和销毁吊舱。因为pod是不稳定的、短暂的和易变的，我们不能相信应用程序总是可以通过pod的IP到达。</p><p id="177c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一个永久的地址，这个地址会将请求发送到当时活动的任何pod。</p><blockquote class="nb nc nd"><p id="003f" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">在Kubernetes中，服务是一种抽象，它定义了一组逻辑单元和访问它们的策略。服务所针对的pod集合通常由一个<a class="ae kv" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">选择器</a>决定。Kubernetes服务提供地址，通过这些地址可以访问相关的pod。</p></blockquote><p id="c5f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看下面的service.yaml文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">service.yaml</p></figure><p id="cb52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这指定了以标签为<code class="fe ni nj nk nl b">app:myapp</code>的pod的端口10000为目标的服务。</p><h1 id="a9d0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建Kubernetes服务</h1><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="edff" class="mp lt iq nl b gy nq nr l ns nt">kubectl apply -f service.yaml</span></pre><p id="a536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ni nj nk nl b">minikube</code> tunnel命令可用于公开负载平衡器服务。要保持负载平衡器处于活动状态，它必须在单独的终端窗口中运行。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="a7e6" class="mp lt iq nl b gy nq nr l ns nt">minikube tunnel </span></pre><p id="3b10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ni nj nk nl b">minikube</code>隧道作为主机上的一个进程运行，并使用群集的IP地址作为网关，创建一个到群集的服务CIDR的网络路由。tunnel命令允许主机操作系统上的任何应用程序立即访问外部IP地址。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="c36c" class="mp lt iq nl b gy nq nr l ns nt">kubectl get service myapp</span></pre><p id="7080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该能看到外部IP；早些时候它会一直悬而未决。</p><p id="1749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以使用此ip在浏览器中打开服务:</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="0374" class="mp lt iq nl b gy nq nr l ns nt">minikube service --url myapp</span></pre><p id="82f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该能够在您的浏览器中查看它。</p><pre class="kg kh ki kj gt nm nl nn no aw np bi"><span id="9e14" class="mp lt iq nl b gy nq nr l ns nt">Welcome to myapp!</span></pre><blockquote class="nb nc nd"><p id="9857" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">如果没有与开发人员生活的类比，关于服务的部分是不完整的。想象一个外部团队不确定或者困惑于如何使用开发团队开发的特性。解决问题的一个方法是直接联系已知的开发人员。当然，这是可行的，但是万一开发人员已经转移到不同的团队并且丢失了上下文呢？在这种情况下，团队SPOC来帮忙在团队内部路由查询。</p></blockquote><h1 id="1816" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">这是一篇很长的文章…我希望下次能告诉你更多！</h1><p id="0a71" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">说到这里，我们就到了关于K8s和新生第一天的冒险的文章的结尾。然而，还有更多的东西要学习，更多的冒险要跟随，所以请保持关注！</p><h1 id="42ae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><ul class=""><li id="30b7" class="nw nx iq ky b kz mk lc ml lf ny lj nz ln oa lr ob oc od oe bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务</a></li><li id="8da9" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> Kubernetes部署</a></li><li id="507c" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/overview/components/" rel="noopener ugc nofollow" target="_blank">关于Kubernetes组件的读取模式</a></li><li id="944a" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><a class="ae kv" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">码头集装箱</a></li></ul></div></div>    
</body>
</html>