# 忽略遗留代码？这是潜在的学习金矿

> 原文：<https://betterprogramming.pub/legacy-code-potential-gold-mine-of-learning-a59fdcb14804>

## 学习编程的地方和方法非常多，我们只需要知道去哪里找就可以了。然而，我们经常忽略遗留代码。

![](img/f6e91b33383898e093ba93ac811b0381.png)

马修·费尼在 [Unsplash](https://unsplash.com/) 上的照片

*你即将进入另一个维度。不仅是视觉和听觉的维度，也是思维的维度。一次奇妙的想象之旅。下一站:遗留代码。*

对于那些没有认出它，或者没有看这部剧的人来说，这是《暮光之城》一集的(修改过的)介绍。这是一部狂热的科幻/恐怖电视节目。每一集都讲述了一个独立的故事，故事中的人物发现他们自己在处理经常令人不安或不寻常的事件，导致了令人惊讶的结局。

我们穿越遗留代码的旅程有时会感觉非常相似。但就像在《暮光之城》中一样，在每一个遗留代码之谜中，都有一个教训需要吸取。

# **借来的知识**

编程可以通过多种方式学习。但是不管我们怎么做，都不是靠我们自己。在我们的旅程中，有许多书籍、在线课程和文档。在浏览这些材料时，我们无意中发现了一堆关于如何做事和应该避免什么的建议。所有这些建议都是编写这些材料的人以及在他们之前分享他们经验的许多人的经验积累。

这就是我喜欢称之为借来的知识。这不是我们的知识，我们是在“借用”它。我们以某种方式做事，但这并不保证我们明白自己在做什么。

*-我们做的是微服务架构。
——为什么？我们试图解决什么问题？有什么好处？缺点是什么？我们是真的在做微服务架构还是在做分布式 monolith？我们需要微服务吗？*

这可能是最简单的例子。微服务最近像咒语一样被使用。它被认为是我们所有问题的最终解决方案。不要误会，微服务架构是一种很美的模式，但它有自己的位置。

在我们知道那个地方是什么之前，微服务不是我们的知识。这是别人叫我们做的事。推荐它就像推荐一部我们没看过的电影。我们相信别人对电影的品味。我们是在“借用”它。

这未必是一件坏事。考虑到我们是为了生活而工作，而不是为了工作而生活。所以知道一切并不是我们应该努力的最终目标。这就是为什么我们有固执己见的技术和编码标准。为我们指明道路，并消除以艰难的方式学习的需要。我们不需要被车撞了才学会过马路时朝两边看。

拥有一个项目的结构、一个工具或者一个模式，我们可以简单地“插入”到我们的解决方案中，而不需要太多的麻烦，这是非常好的。但是我们明确的目标应该是理解我们在做什么，为什么，以及什么时候我们不应该这样做。

# **遗留代码**

遗留代码如何适应这个故事？要了解我们为什么应该或不应该做某件事，有什么比看到它的实际行动更好的方法呢？有时代码只是时间或环境的牺牲品，但在大多数情况下，遗留代码是错误决策的结果。

一开始很难注意到那些糟糕的决定。当我们开始一个新项目时，我们主要关注的是需要做什么。久而久之和软件被使用，糟糕的决策开始浮出水面。没有比糟糕的决定更好的老师了。

在软件开发中，我们应该尽可能避免紧密耦合。但是我们真的明白为什么吗？我们如何实现这一目标？有时，如果我们知道自己在做什么，将事情紧密结合起来是可以的。

例如，如果我们使用某个 ORM，可以直接在业务逻辑中使用它…如果我们确定不会改变它。如果我们不确定，那么我们应该通过使用存储库、数据访问对象或类似的东西，在业务逻辑和数据访问层之间建立一个抽象层。

如果我们曾经使用过一个不再受支持的 ORM，一个不再满足我们需求的定制解决方案，或者大多数员工不知道如何使用它(并且没有好的文档)，那么我们肯定理解为什么我们需要那个级别的抽象。改变 ORM 将是一场噩梦，停留在现有的 ORM 上限制了我们的能力。这是一个双输的局面。

另一个遗留代码的典型例子是代码复制。我们都(应该)同意代码重复是一件坏事。然而，仍有如此多的开发人员重复代码。有时甚至是大规模的。我们中的任何人都曾经修复过一些 bug，并且在产品中仍然有错误的行为，因为有两个、三个或更多的包含 bug 的相同代码的副本，知道为什么我们不应该复制代码。

在一个新的代码库中，我们可能会侥幸成功，因为仍然没有那么多代码，我们仍然记得我们需要改变的每一个地方，但这并没有减少错误。

# **吸取的教训**

所有这些都说得很好，但太抽象了，无法展示我真正在说什么。所以让我描述一下我在遗留代码方面的一个经历。

在我职业生涯的早期，我参与了一个项目。当时版本 2 已经开发了 4 年。这是一个涵盖多种功能的 MVC 项目，有大量的代码。它有 100 多个表，其中一半以上的实体需要能够有附件。这个特性(附件)是我想在本节中介绍的一个特性。

为了加速开发，最初的团队使用通用控制器和代码生成。除此之外，他们为大多数实体的 CRUD 操作生成视图。这些视图将被生成，然后根据需求进行修改。大多数实体都需要附件。为了解决这个问题，他们在视图模板中添加了处理显示、上传和修改附件的代码。

```
Lesson: Duplicated code is hard to maintain and should be avoided
```

由于超过 70 个实体需要附件，与该特性相关的逻辑在超过 70 个地方生成。有一个系统支持上传的格式列表。当需要一种新的格式时，我需要遍历所有 70 多个地方来更新业务逻辑。

一旦我这样做了，新的格式就得到支持。但是过了一段时间，用户抱怨说它不工作了。我花了一些时间才发现我忘了更新视图样板。更改后生成的下一个视图不包含新支持的格式。这是一个愚蠢的错误，但我要为自己辩解的是，当时我还是个新手。

```
Lesson: If you generate code do not generate duplicated code. Or, if you do, make sure that you can later regenerate it to reflect new logic.
```

老实说，这不全是我的错。视图模板不应包含附件的视图部分。该代码不是代码生成的候选。它应该是一个单独的构件，仅在视图中被引用。虽然是生成的代码，但是重复的代码还是重复的代码。

如果可以通过生成新版本的视图来覆盖视图，就不会有任何问题。新生成的版本将包含变更，一切都将按预期运行。但是视图是用手工编写的逻辑修改的，所以这不是选项。

```
Lesson: Generics are great. Use it when you can, but do not force it.
```

我决定为附件创建组件。替换所有重复的代码可能不会马上实现，但是我可以在新代码中使用它。这样我就不会在以后开始改变事情的时候给自己创造更多的工作。

在那之前，我从事使用泛型的项目，但是我个人从来没有写过一行泛型代码。即使我知道什么是泛型，我也不了解它们的全部潜力。

组件背后的最初想法是拥有一个统一的视图部件。但是当我开始使用它时，我意识到每次我在视图中引用它时，我也在控制器中复制代码。那么将获取逻辑推到组件内部可能是个好主意。

这让我大开眼界。在反射和泛型的帮助下，我设法创建了一个封装的组件来处理附件的获取、显示和授权操作。

但是有些页面需要有一个特定的附件列表，这些附件不仅仅与特定的实体相关。我试着把这个推进组件，它很快就变得凌乱了。所以我决定拆分组件的视图和逻辑部分，只使用视图部分。业务部分每次都是手工编写的，因为它不符合通用逻辑。

```
Lesson: Know the tools you are using and what your code is doing under the hood
```

在某个时候，用户开始抱怨某个页面的性能。同样，为了加速初始开发，最初的开发团队决定在页面加载时获取所有数据。分页、过滤和排序是在客户端完成的。

随着时间的推移，行数增加了 5000 多行。它本身并不是问题。真正扼杀表现的是依恋。

看起来好像有人得出结论(就像我在提取组件时得出的结论一样),在获取附件时有很多代码重复。

为了防止这种重复，启用了快速加载。对于每个实体，ORM 会默认加载它的所有附件。实体和附件之间的关系是一对多的，所以 ORM 不能在同一个查询中获取这些附件。这意味着对于每个条目(行), ORM 都会向数据库发出一个额外的请求。

因为最初的请求需要获取两个实体来显示视图中的数据，所以 5000 行的结果是页面加载时对数据库的请求超过 10 000 次。在这个页面上甚至没有使用附件。

我不能简单地关闭渴望加载，因为它被用在太多的地方，我不能 100%确定我覆盖了所有的地方。最后，“解决方案”是浏览所有显示列表的页面，并手动关闭附件的紧急加载。

# **结论**

维护遗留代码通常令人沮丧。在处理一大堆别人(或你)的错误决策时，保持事情正常运转很快就会令人沮丧。我们收到的每一封邮件、每一个电话或每一条信息都意味着有东西坏了，我们需要修复它。很难不受其影响。

但是使用遗留代码并不一定是一场噩梦。我们可以把它看作是提高我们技能的机会。每个代码都是为解决某个问题而做出的一系列决策的最终产物。通过了解事情何时、为什么以及如何出错，我们可以学到很多关于软件开发的知识。也许我们留下的代码会比我们继承的代码更好。