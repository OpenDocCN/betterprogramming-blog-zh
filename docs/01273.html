<html>
<head>
<title>Async Programming in Flutter With Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用流进行Flutter中的异步编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-programming-in-flutter-with-streams-c949f74c9cf9?source=collection_archive---------7-----------------------#2019-08-28">https://betterprogramming.pub/async-programming-in-flutter-with-streams-c949f74c9cf9?source=collection_archive---------7-----------------------#2019-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4fa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">部分代码的独立工作流</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/59cd3f60fcca517ac54f09124a9b9e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fbvd3_SnWIgU1cTZprOz9w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一语双关|照片由亨德里克·科内里森在<a class="ae kv" href="https://unsplash.com/search/photos/stream?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="502d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步编程的原则是允许一部分程序运行，同时等待应用程序线程中的其他活动发生。它允许部分代码独立于主工作流运行。</p><p id="c737" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步进程的几个例子是:从网络上获取数据，或者在一些非常大的数据块上循环。</p><p id="0d93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在flutter中，有一系列方法可以编写异步代码。一些流行的方法有:</p><ul class=""><li id="2c11" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">未来。</li><li id="afd5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">异步/等待。</li><li id="00f8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">溪流。</li></ul><p id="d7ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章的目的是让你开始在你的flutter应用程序中使用streams，我希望你有编写flutter应用程序的先验知识，让我们开始吧！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="8056" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">什么是反应式编程？</h1><p id="4608" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">据<a class="ae kv" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="nk nl nm"><p id="f4e1" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated"><em class="iq">反应式编程是一种</em> <a class="ae kv" href="https://en.wikipedia.org/wiki/Programming_paradigm" rel="noopener ugc nofollow" target="_blank"> <em class="iq">编程范式</em> </a> <em class="iq">面向围绕</em> <a class="ae kv" href="https://en.wikipedia.org/wiki/Dataflow_programming" rel="noopener ugc nofollow" target="_blank"> <em class="iq">数据流</em> </a> <em class="iq">而变化的传播。这意味着应该可以用所使用的编程语言轻松地表达静态或动态数据流，并且底层执行模型将自动通过数据流传播更改。</em></p></blockquote><p id="963a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在反应式编程中，数据在由您使用的语言、框架或库设置的结构中流动，当<em class="nn">数据</em>在一端被传入结构<em class="nn">时，如果该<em class="nn">数据的值改变</em>，输出将总是<em class="nn">更新自身</em>。</em></p><p id="d689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这正是流所做的。流是异步事件的流动，将其视为包含液体的管道。你从管子的一端注入液体，液体从另一端流出。</p><p id="fa4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">流可以携带和处理不同类型的数据，比如对象、函数、地图、列表，甚至是流的流。很酷吧？</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c196" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">现在，代码示例</h1><p id="8206" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">第一个示例创建了一个简单的流，它接收一个字符串，并在完成后将其打印出来:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="8a57" class="nw mo iq ns b gy nx ny l nz oa"><strong class="ns ir"><em class="nn">@override</em></strong></span><span id="2fa3" class="nw mo iq ns b gy ob ny l nz oa"><strong class="ns ir"><em class="nn">void</em></strong><em class="nn"> initState() {</em></span><span id="8f91" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">super.initState();</em></span><span id="1de4" class="nw mo iq ns b gy ob ny l nz oa"><strong class="ns ir"><em class="nn">Stream</em></strong><em class="nn">&lt;String&gt; stream = new </em><strong class="ns ir"><em class="nn">Stream</em></strong><em class="nn">.fromFuture(inputData());</em></span><span id="3682" class="nw mo iq ns b gy ob ny l nz oa"><strong class="ns ir"><em class="nn">stream</em></strong><em class="nn">.listen((data) {</em></span><span id="3253" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">print("Our data: " + data);</em></span><span id="3e0b" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">}, onDone: () {</em></span><span id="e970" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">print("Done");</em></span><span id="7809" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">}, onError: (error) {</em></span><span id="626b" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">print("Error returned");</em></span><span id="be89" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">});</em></span><span id="afc4" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">}</em></span><span id="378e" class="nw mo iq ns b gy ob ny l nz oa"><strong class="ns ir"><em class="nn">Future</em></strong><em class="nn">&lt;String&gt; inputData() </em><strong class="ns ir"><em class="nn">async</em></strong><em class="nn"> {</em></span><span id="cde3" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">print("Fetching Data...");</em></span><span id="1dea" class="nw mo iq ns b gy ob ny l nz oa"><strong class="ns ir"><em class="nn">return</em></strong><em class="nn"> "Let's Use Streams!";</em></span><span id="ba21" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">}</em></span></pre><h2 id="5d7d" class="nw mo iq bd mp oc od dn mt oe of dp mx lf og oh mz lj oi oj nb ln ok ol nd om bi translated">输出</h2><p id="866d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">获取数据… <br/>我们的数据:让我们使用流！完成了</p><p id="4cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，流从返回文本<code class="fe on oo op ns b">“Let’s use streams!”</code> <strong class="ky ir"> <em class="nn">的<code class="fe on oo op ns b">inputData()</code>函数获取数据。</em> </strong>然后<strong class="ky ir"> <em class="nn"> </em> </strong>我们<strong class="ky ir"> <em class="nn"> </em> </strong>使用<code class="fe on oo op ns b">stream.listen()</code> <strong class="ky ir"> <em class="nn"> </em> </strong>对进入数据流的数据进行处理。在这里我们有一个<strong class="ky ir"><em class="nn"/></strong><code class="fe on oo op ns b">onDone()</code><strong class="ky ir"><em class="nn"/></strong><strong class="ky ir"><em class="nn"/></strong><code class="fe on oo op ns b">onError()</code><strong class="ky ir"><em class="nn"/></strong>的方法。<code class="fe on oo op ns b">onDone()</code>在流程完成时使用数据，如果有错误可以用<code class="fe on oo op ns b">onError()</code>抛出。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2ac1" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">第二个例子</h1><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="8eba" class="nw mo iq ns b gy nx ny l nz oa">final <strong class="ns ir">StreamController</strong> controller= <strong class="ns ir">StreamController</strong>();</span><span id="2dc3" class="nw mo iq ns b gy ob ny l nz oa">controller.stream.<strong class="ns ir">listen</strong>((data) {</span><span id="e7ce" class="nw mo iq ns b gy ob ny l nz oa">print("received data: $<em class="nn">data</em>");</span><span id="78a4" class="nw mo iq ns b gy ob ny l nz oa">}, <strong class="ns ir"><em class="nn">onDone</em></strong>: () {</span><span id="80e1" class="nw mo iq ns b gy ob ny l nz oa">print("Stream done");</span><span id="59d2" class="nw mo iq ns b gy ob ny l nz oa">}, <strong class="ns ir"><em class="nn">onError</em></strong>: () {</span><span id="33af" class="nw mo iq ns b gy ob ny l nz oa">print("Error occured");</span><span id="5a49" class="nw mo iq ns b gy ob ny l nz oa">});</span><span id="614c" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">// data flowing into the stream</em></span><span id="798c" class="nw mo iq ns b gy ob ny l nz oa">controller.sink.<strong class="ns ir">add</strong>('stream controllers are awesome');</span><span id="02df" class="nw mo iq ns b gy ob ny l nz oa">controller.sink.<strong class="ns ir">add</strong>("Because You can do more");</span><span id="5e0e" class="nw mo iq ns b gy ob ny l nz oa">controller.sink.<strong class="ns ir">add</strong>('random string');</span><span id="fe84" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">// Close the StreamController when done to avoid memory leaks</em></span><span id="e9d4" class="nw mo iq ns b gy ob ny l nz oa">controller.<strong class="ns ir"><em class="nn">close</em></strong>();</span></pre><h2 id="4c35" class="nw mo iq bd mp oc od dn mt oe of dp mx lf og oh mz lj oi oj nb ln ok ol nd om bi translated">输出</h2><p id="f8d2" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">接收数据:流控制器很棒<br/>接收数据:因为你可以做更多<br/>接收数据:随机串<br/>流完成</p><p id="56af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe on oo op ns b">StreamController</code> <strong class="ky ir"> </strong>类为任何创建的流创建一个控制器。使您更容易使用多个侦听器(我们很快会谈到这一点)。这里我们使用<code class="fe on oo op ns b"><a class="ae kv" href="https://api.flutter.dev/flutter/dart-async/StreamSink-class.html" rel="noopener ugc nofollow" target="_blank">sink</a>.add()</code> <strong class="ky ir">，</strong>添加数据，这是一个接受输入到流中的数据的对象。还有，你应该在使用完控制器后<em class="nn">关闭</em> <strong class="ky ir"> </strong>，以防止<a class="ae kv" href="https://en.wikipedia.org/wiki/Memory_leak" rel="noopener ugc nofollow" target="_blank">内存泄露</a>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e6fd" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">广播流</h1><p id="6c9a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这种类型的流允许您使用多个侦听器。我们之前创建的流只能有一个侦听器；他们被称为<em class="nn">单一订阅流。</em></p><h2 id="482a" class="nw mo iq bd mp oc od dn mt oe of dp mx lf og oh mz lj oi oj nb ln ok ol nd om bi translated">代码示例</h2><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="c545" class="nw mo iq ns b gy nx ny l nz oa"><strong class="ns ir"><em class="nn">@override</em></strong></span><span id="9283" class="nw mo iq ns b gy ob ny l nz oa">void initState() {</span><span id="410b" class="nw mo iq ns b gy ob ny l nz oa">super.initState();</span><span id="a32e" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">stream</em>();</span><span id="24bc" class="nw mo iq ns b gy ob ny l nz oa">}</span><span id="5b03" class="nw mo iq ns b gy ob ny l nz oa">final <strong class="ns ir">StreamController</strong> <em class="nn">controller</em> = <strong class="ns ir">StreamController</strong>.broadcast(); <em class="nn">//add a .broadcast() </em></span><span id="923b" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">stream</em>() {</span><span id="cd08" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">controller</em>.stream.<em class="nn">where</em>((data) =&gt; (data is <strong class="ns ir">String</strong>)).<em class="nn">listen</em>((data) {</span><span id="5342" class="nw mo iq ns b gy ob ny l nz oa">print("DataReceived: " + data);</span><span id="77c8" class="nw mo iq ns b gy ob ny l nz oa">}, onDone: () {</span><span id="5595" class="nw mo iq ns b gy ob ny l nz oa">print("Task 1 Done");</span><span id="39b5" class="nw mo iq ns b gy ob ny l nz oa">}, onError: (error) {</span><span id="fa9d" class="nw mo iq ns b gy ob ny l nz oa">print("Some Error");</span><span id="6d1f" class="nw mo iq ns b gy ob ny l nz oa">});</span><span id="919f" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">controller</em>.stream.where((data) =&gt; (data is <strong class="ns ir">int</strong>)).listen((data) {</span><span id="a24f" class="nw mo iq ns b gy ob ny l nz oa">print("DataReceived: " + data.toString());</span><span id="754d" class="nw mo iq ns b gy ob ny l nz oa">}, onDone: () {</span><span id="1680" class="nw mo iq ns b gy ob ny l nz oa">print("Task 2 Done");</span><span id="7d60" class="nw mo iq ns b gy ob ny l nz oa">});</span><span id="c669" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">controller</em>.stream.where((data) =&gt; (data is <strong class="ns ir">Map</strong>)).listen((data) {</span><span id="02fc" class="nw mo iq ns b gy ob ny l nz oa">print(data);</span><span id="53fa" class="nw mo iq ns b gy ob ny l nz oa">}, onDone: () {</span><span id="5428" class="nw mo iq ns b gy ob ny l nz oa">print("Task 3 Done");</span><span id="12ee" class="nw mo iq ns b gy ob ny l nz oa">});<br/></span><span id="b032" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">controller</em>.sink.add('random string');</span><span id="2ffb" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">controller</em>.sink.add(1234);</span><span id="8e89" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">controller</em>.sink.add({'key 1': 'value A', 'key 2': 'value B'});</span><span id="9477" class="nw mo iq ns b gy ob ny l nz oa"><em class="nn">controller</em>.close();</span><span id="f2e3" class="nw mo iq ns b gy ob ny l nz oa">}</span></pre><h2 id="ae48" class="nw mo iq bd mp oc od dn mt oe of dp mx lf og oh mz lj oi oj nb ln ok ol nd om bi translated">输出</h2><blockquote class="nk nl nm"><p id="b0fe" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">接收的数据:随机字符串</p><p id="64dc" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">接收数据:1234</p><p id="f1f4" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">{关键字1:值A，关键字2:值B}</p><p id="7d68" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">任务1完成</p><p id="d9ba" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">任务2完成</p><p id="05d8" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">任务3完成</p></blockquote><p id="554e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们用<code class="fe on oo op ns b">.broadcast()</code> <strong class="ky ir"> <em class="nn"> </em> </strong>初始化一个<code class="fe on oo op ns b">StreamController</code> <strong class="ky ir"> </strong>然后，我们听三次不同的流。注意我们在监听之前使用了一个<code class="fe on oo op ns b">.where()</code> <strong class="ky ir"> <em class="nn"> </em> </strong>方法，这有助于我只监听流中满足给定条件的数据。首先，我们只打印字符串，然后是整数，然后是映射。</p><p id="be5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道如何创建和使用一个流了。我会写一篇单独的文章，在那里我们可以使用流在我们的屏幕上用一个真正的工作应用程序来绘制小部件！</p><p id="3a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在推特上找到我。</p></div></div>    
</body>
</html>