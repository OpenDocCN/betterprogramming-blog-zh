<html>
<head>
<title>6 Alternatives to Classes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中类的6种替代方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-alternatives-to-classes-in-python-6ecb7206377?source=collection_archive---------0-----------------------#2021-03-04">https://betterprogramming.pub/6-alternatives-to-classes-in-python-6ecb7206377?source=collection_archive---------0-----------------------#2021-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="014c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开发速度、执行时间、(反)序列化和可维护性都在让您的代码熠熠生辉中扮演着重要角色</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c4a83ce013604487a16d5a952d3bdfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESvqnwbq8Lj4VNkVMWI9JA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="0d95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为开发人员，我们到处扔很多数据。数据的表示非常重要，我们需要能够跟踪哪些变量代表哪些属性。配置是复杂数据的一个典型例子。</p><p id="d6e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的文章中，我将使用位置作为例子。它必须有经度、纬度，并且可以有地址。在C语言中，你可以用一个<code class="fe lu lv lw lx b">struct</code>来做这件事。在Java中，你可以简单地创建一个类。在Python中，有六种选择。让我们来探讨一下它们各自的优缺点吧！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="ebcd" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">普通班级</h1><p id="869c" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">普通类是标准库提供的组织数据的默认方式。你可以(也应该！)<a class="ae nc" href="https://medium.com/analytics-vidhya/type-annotations-in-python-3-8-3b401384403d" rel="noopener">使用类型注释</a>，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="92e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到我们如何需要编写一个样板构造函数<code class="fe lu lv lw lx b">__init__</code>。构造函数的代码并不总是看起来那么简单，但是在很多情况下，它确实很简单。</p><p id="dcb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到使用位置参数或关键字参数是可能的。如果在构造函数中定义了默认值，当从类创建对象时，也可以不考虑这些值。这发生在<code class="fe lu lv lw lx b">pos2</code>身上，那里的<code class="fe lu lv lw lx b">address</code>没有给构造者。</p><p id="a46e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以看到,<code class="fe lu lv lw lx b">get_distance</code>函数的注释看起来非常干净。意思很清楚。</p><p id="c937" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">工具支持非常好，因为每个编辑器都必须支持普通类，所有重要信息都在那里。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="9de0" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.元组</h1><p id="937f" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">元组是一种本地数据类型。它们的内存开销非常低，所以我们可以很快地通过索引来寻址这些元素。元组的问题是没有成员属性的名称。你必须记住每个指数代表什么。元组总是不可变的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f1dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">get_distance</code>的注释看起来很乱。人类应该被告知<code class="fe lu lv lw lx b">p1</code>代表一个位置——而不是这个位置包含两个浮点数和一个可选的字符串。那是编辑应该为你做的工作。</p><p id="7338" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编辑的支持取决于你注释的彻底程度。在上面的例子中，你也可以只写<code class="fe lu lv lw lx b">Tuple</code>而不指定元组包含什么。由于人们懒惰，我会说编辑支持不好。这不是编辑的错，但往往不能给予很好的支持。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="a7e2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.字典</h1><p id="3d2f" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">字典是一种本地数据类型<strong class="la iu"> </strong>，可能是Python中最常见的数据处理方式。与元组相比，字典有更大的内存开销，因为你必须把名字存储在某个地方，但是它们仍然可以。按索引访问元素是<em class="nf">快</em>。字典总是可变的，但是有第三方包<a class="ae nc" href="https://pypi.org/project/frozendict/" rel="noopener ugc nofollow" target="_blank"> frozendict </a>来解决这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3d99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实践中的注解确实不好。几乎总是在最好的情况下。通常，没有注释。</p><p id="3745" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nc" href="https://medium.com/analytics-vidhya/type-annotations-in-python-3-8-3b401384403d" rel="noopener">typed dict</a>(<a class="ae nc" href="https://www.python.org/dev/peps/pep-0589/" rel="noopener ugc nofollow" target="_blank">PEP 589</a>)从Python 3.8开始就有了，但我从未在任何更大的代码库中见过。<a class="ae nc" href="https://python.plainenglish.io/killer-features-by-python-version-c84ca12dba8" rel="noopener ugc nofollow" target="_blank"> TypedDict是一个杀手级特性</a>，但这无关紧要，因为我们想要支持遗留的Python版本。</p><p id="2cb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这些原因，编辑器的支持甚至不如元组。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="eb77" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.命名元组</h1><p id="fc73" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated"><a class="ae nc" href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noopener ugc nofollow" target="_blank">命名元组</a>被添加到Python 2.6中，所以它们已经存在了相当一段时间。它们实际上是元组，但是它们有一个名称和一个接受关键字参数的构造函数。大多数人使用工厂函数<code class="fe lu lv lw lx b">collections.namedtuple</code>来生成命名元组类，但我更喜欢从<code class="fe lu lv lw lx b">typing.NamedTuple</code>继承，并使用继承结合类型注释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="878b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">NamedTuples</code>解决注释变得难以阅读的问题。因此，它们也解决了我前面提到的编辑器支持问题。</p><p id="1355" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是，<code class="fe lu lv lw lx b">NamedTuples</code>并不<em class="nf">知道类型:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="6726" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.属性</h1><p id="df2e" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">attrs是一个减少样板代码的第三方库。开发人员可以通过在类上方添加<code class="fe lu lv lw lx b">@attrs.s</code>装饰器来使用它。属性被赋予<code class="fe lu lv lw lx b">attr.ib()</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0bfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过将装饰器更改为<code class="fe lu lv lw lx b"><a class="ae nc" href="https://www.attrs.org/en/stable/api.html" rel="noopener ugc nofollow" target="_blank">@attr.s(frozen=True)</a></code>来使其不可变。</p><p id="baea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以在构造函数的输入上自动运行代码。这被称为“转换器”，文档<a class="ae nc" href="https://www.attrs.org/en/stable/examples.html#conversion" rel="noopener ugc nofollow" target="_blank">展示了一个很好的例子:</a></p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="9bed" class="nk mg it lx b gy nl nm l nn no"><strong class="lx iu">&gt;&gt;&gt; @attr</strong>.s<br/><strong class="lx iu">... class</strong> <strong class="lx iu">C</strong>(object):<br/><strong class="lx iu">... </strong>    x = attr.ib(converter=int)<br/><strong class="lx iu">&gt;&gt;&gt; </strong>o = C("1")<br/><strong class="lx iu">&gt;&gt;&gt; </strong>o.x</span></pre><p id="b428" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nc" href="https://towardsdatascience.com/visual-studio-code-python-editors-in-review-e5e4f269b4e4" rel="noopener" target="_blank"> Visual Studio代码</a>不喜欢类型注释。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="27ce" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.数据类</h1><p id="8601" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">数据类是在Python 3.7中用<a class="ae nc" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank"> PEP 557 </a>添加的。它们类似于attrs，但是在标准库中。特别重要的是要注意，dataclasses“只是”普通的类，碰巧其中有很多数据。</p><p id="daf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与attrs相反，数据类使用类型注释而不是<code class="fe lu lv lw lx b">attr.ib()</code>符号。我认为这大大增加了可读性。此外，编辑器支持更好了，因为您现在必须注释属性。</p><p id="b2ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过将装饰器改为<code class="fe lu lv lw lx b">@dataclass(frozen=True)</code>，可以很容易地使它成为不可变的——就像attrs一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="df34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里缺少的一部分是属性验证。我可以用<code class="fe lu lv lw lx b">__post_init__(self)</code>来做建筑；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="115b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以将数据类与属性结合起来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7dbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我不太喜欢那样。它又是超级冗长的，并且去掉了许多数据类的魅力。如果您需要类型没有涵盖的验证，那么使用Pydantic。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="6f1b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">6.Pydantic</h1><p id="e29e" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated"><a class="ae nc" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Pydantic </a>是一个专注于数据验证和设置管理的第三方库。您可以从<code class="fe lu lv lw lx b">pydantic.BaseModel</code>继承或者用Pydantic创建一个dataclass:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e67b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍一看，这与标准的<code class="fe lu lv lw lx b">@dataclass</code>完全相同——除了您从Pydantic获得了<code class="fe lu lv lw lx b">dataclass</code>装饰器。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="bdc8" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">可变性和可散列性</h1><p id="d0eb" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我不倾向于有意识地考虑可变性，但是在很多情况下，我希望我的类是不可变的。最大的例外是数据库模型，但它们本身是一个完整的故事。</p><p id="367e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以选择将类标记为冻结，以使它们的对象不可变，这非常好。</p><p id="9a4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为可变对象实现<code class="fe lu lv lw lx b">__hash__</code>是有问题的，因为当对象改变时，散列可能会改变。这意味着如果对象在字典中，字典需要知道对象的散列已经改变，并将它存储在不同的位置。因此，dataclasses和Pydantic在默认情况下都阻止可变类的散列。不过他们有<code class="fe lu lv lw lx b">unsafe_hash</code>。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="deec" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">默认字符串表示</h1><p id="8fcf" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">拥有一个合理的字符串表示非常有帮助(例如，对于日志记录)。老实说:很多人都在做<code class="fe lu lv lw lx b">print</code>调试。</p><p id="d2a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们从上面的例子中打印出<code class="fe lu lv lw lx b">pos1</code>，下面是我们将得到的结果。添加换行符和对齐方式是为了保持可读性。原始结果在一行中:</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="0de5" class="nk mg it lx b gy nl nm l nn no">&gt;&gt;&gt; print(pos1)</span><span id="5a43" class="nk mg it lx b gy np nm l nn no">Plain class   : &lt;__main__.Position object at 0x7f1562750640&gt;<br/># 1 Tuples    : (49.0127913, 8.4231381, 'Parkstraße 17')<br/># 2 Dicts     : {'longitude': 49.0127913,<br/>                 'latitude': 8.4231381,<br/>                 'address': 'Parkstraße 17'}<br/># 3 NamedTuple: Position(longitude=49.0127913,<br/>                         latitude=8.4231381,<br/>                         address='Parkstraße 17')<br/># 4 attrs     : Position(longitude=49.0127913,<br/>                         latitude=8.4231381,<br/>                         address='Parkstraße 17')<br/># 5 dataclass : Position(longitude=49.0127913,<br/>                         latitude=8.4231381,<br/>                         address='Parkstraße 17')</span></pre><p id="6dd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以看出，从普通类创建的对象的字符串表示是没有用的。元组更好，但是没有指明哪个索引代表哪个属性。所有剩下的表现都很棒。它们很容易理解，甚至可以用来重新创建对象！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="717c" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">数据有效性</h1><p id="5f89" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">您已经看到了如何为普通类、属性、数据类和Pydantic实现数据验证。您没有看到的是错误消息的样子。</p><p id="358a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面，我将尝试创建<code class="fe lu lv lw lx b">Position(1234, 567)</code>。所以经度和纬度都不对。以下是由此触发的错误消息:</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="55f6" class="nk mg it lx b gy nl nm l nn no"># Plain Class<br/>ValueError: Longitude was 11111, but has to be in [-180, 180]</span><span id="0095" class="nk mg it lx b gy np nm l nn no"># 4: attr<br/>ValueError: Longitude was 1234, but must be in [-180, +180]</span><span id="9ed5" class="nk mg it lx b gy np nm l nn no"># 5: dataclasses<br/>(same as plain classes is possible)</span><span id="228e" class="nk mg it lx b gy np nm l nn no"># 6: Pydantic<br/>pydantic.error_wrappers.ValidationError: 2 validation errors for Position<br/>longitude<br/>  Longitude was 1234.0, but must be in [-180, +180] (type=value_error)<br/>latitude<br/>  Latitude was 567.0, but must be in [-90, +90] (type=value_error)</span></pre><p id="a501" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我想说的观点:Pydantic以一种非常清晰的方式给你所有的错误。普通类和属性只是给你第一个错误。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f58a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">序列化到JSON</h1><p id="251a" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">JSON是在网络上交换数据的方式。GitLab API也不例外。假设我们想让Python对象序列化为JSON，然后<a class="ae nc" href="https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr" rel="noopener ugc nofollow" target="_blank">得到一个MR </a>。在Pydantic中，就是这么简单(为了可读性，去掉了很多属性):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b04d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这给了你:</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="aaf8" class="nk mg it lx b gy nl nm l nn no">{"id": 1, "squash": true, "web_url": "<a class="ae nc" href="http://foo" rel="noopener ugc nofollow" target="_blank">http://foo</a>", "title": "title", "author": {"id": 42, "username": "Joe"}}</span></pre><p id="eec2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于数据类，<code class="fe lu lv lw lx b"><a class="ae nc" href="https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict" rel="noopener ugc nofollow" target="_blank">dataclasses.asdict</a></code>大有帮助。然后，您可能能够直接将字典序列化为JSON。有了<code class="fe lu lv lw lx b">DateTime</code>或<a class="ae nc" href="https://docs.python.org/3/library/decimal.html" rel="noopener ugc nofollow" target="_blank">十进制</a>对象就变得有趣了。对于attrs，类似的事情也是可能的。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f8a3" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">从JSON取消序列化</h1><p id="f298" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">用Pydantic将JSON字符串中的嵌套类用户化是微不足道的。使用上面的示例，您可以编写:</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="002f" class="nk mg it lx b gy nl nm l nn no">mr = GitlabMr.parse_raw(json_str)</span></pre><p id="8fc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一些非常肮脏的黑客用数据类做类似的事情。反序列化的<a class="ae nc" href="https://stackoverflow.com/q/44801927/562769" rel="noopener ugc nofollow" target="_blank"> attrs方式看起来更好，但我猜它也很难处理嵌套结构。当谈到<code class="fe lu lv lw lx b">DateTime</code>或小数时，我很确定两者都比小数显示出更多的问题。序列化、反序列化和验证是Pydantic的亮点。</a></p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="6c1e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">记忆</h1><p id="151d" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在<code class="fe lu lv lw lx b">pos1</code>上使用这个<code class="fe lu lv lw lx b"><a class="ae nc" href="https://stackoverflow.com/a/30316760/562769" rel="noopener ugc nofollow" target="_blank">getsize</a></code>实现，我得到:</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="17d4" class="nk mg it lx b gy nl nm l nn no">Raw float    :   8 B ("double")<br/>Raw string   :   1 B per char =&gt; 13B<br/>Raw data     :  29 B = 8B + 8B + 13B</span><span id="1748" class="nk mg it lx b gy np nm l nn no">Float object :  24 B<br/>Str object   :  86 B<br/>3 objects    : 134 B = 24B + 24B + 86B</span><span id="3614" class="nk mg it lx b gy np nm l nn no">Native class : 286 B<br/>#1 Tuple     : 198 B<br/>#2 Dict      : 366 B<br/>#3 NamedTuple: 198 B<br/>#4 attrs     : 286 B<br/>#5 dataclass : 286 B<br/>#6 pydantic  : 442 B (the "dataclass" version)<br/>#6 pydantic  : 801 B (the "BaseModel" version)</span></pre><p id="b2ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pydantic基本模型有相当大的开销，但是你必须始终保持正确的观点。你会创建多少这样的对象？让我们假设你大概有100个。他们中的每一个人都可能比更高效的替代品多消耗5000亿英镑。那将是50kB。引用唐纳德·克努特的话:</p><blockquote class="nq"><p id="1112" class="nr ns it bd nt nu nv nw nx ny nz lt dk translated">"过早优化是万恶之源."</p></blockquote><p id="54ba" class="pw-post-body-paragraph ky kz it la b lb oa ju ld le ob jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">如果内存出现问题，那么就不能从Pydantic切换到dataclasses或attrs。你将切换到更结构化的东西，比如NumPy数组或者熊猫<code class="fe lu lv lw lx b">DataFrames</code>。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="803e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">执行时间</h1><p id="adb5" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在这个上下文中,“执行时间”有多种含义:</p><ul class=""><li id="1ba9" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated">带或不带验证或转换的对象创建时间</li><li id="8508" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">来自JSON的解析时间</li><li id="7d42" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">从字典中解析时间</li></ul><p id="a34a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我确信JSON的解析时间决定了其余的时间。Python中有多种可用的JSON解析器:</p><div class="ot ou gp gr ov ow"><a href="https://levelup.gitconnected.com/json-encoding-decoding-with-python-62a2cae63a6a" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">用Python进行JSON编码/解码</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">从速度、成熟度和操作安全性方面比较库</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="2118" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">那我什么时候用什么？</h1><p id="5822" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">使用您需要的东西:</p><ul class=""><li id="8949" class="of og it la b lb lc le lf lh oh ll oi lp oj lt ok ol om on bi translated"><code class="fe lu lv lw lx b">Dict</code>当你事先不知道会有什么补充的时候。请注意，您可以使用<code class="fe lu lv lw lx b">dict</code>混合所有其他选项，反之亦然。所以如果你知道数据结构的一部分是什么样子，那么就用不同的东西。我认为<code class="fe lu lv lw lx b">dict</code>是最后的手段。</li><li id="47a9" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated"><code class="fe lu lv lw lx b">NamedTuple</code>当你需要一种快速的方法对数据进行分组并且不需要可变性时。当你可以不知道类型的时候。</li><li id="6781" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">当您需要可变性、希望能够识别类型或者希望能够从创建的数据类继承时，可以使用。</li><li id="33da" class="of og it la b lb oo le op lh oq ll or lp os lt ok ol om on bi translated">当你需要反序列化数据时。</li></ul><p id="8442" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我没有提到tuple和attrs。我只是找不到一个有效的用例，在这个用例中，你会更喜欢新代码而不是其他选择。如果我错过了，请让我知道。</p><p id="70c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我也没提平原班。无论如何，如果我想覆盖<code class="fe lu lv lw lx b">__init__</code>、<code class="fe lu lv lw lx b">__eq__</code>、<code class="fe lu lv lw lx b">__str__</code>、<code class="fe lu lv lw lx b">__repr__</code>和<code class="fe lu lv lw lx b">__hash__</code>，我想我只会使用普通类。或者我是否必须支持旧的Python版本。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="2a2a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">资源</h1><ul class=""><li id="f4df" class="of og it la b lb mx le my lh pl ll pm lp pn lt ok ol om on bi translated">raymond Hettinger:"<a class="ae nc" href="https://www.youtube.com/watch?v=T-TwcmT6Rcw" rel="noopener ugc nofollow" target="_blank">data classes:结束所有代码生成器的代码生成器</a>"在PyCon 2018上，在YouTube上。</li></ul></div></div>    
</body>
</html>