<html>
<head>
<title>5 Complex Algorithms Simplified Using Swift’s Higher-Order Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift的高阶函数简化了5种复杂算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-complex-algorithms-simplified-using-swifts-higher-order-functions-fa94a32a72c3?source=collection_archive---------6-----------------------#2021-07-08">https://betterprogramming.pub/5-complex-algorithms-simplified-using-swifts-higher-order-functions-fa94a32a72c3?source=collection_archive---------6-----------------------#2021-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">映射、减少、过滤等的真实示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/99a03ee6fcd3f5fec23aed1adc6af0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IAIe9QD2N8XR7xTO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Clark Van Der Beken 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="a5c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，我们经常需要处理复杂的算法，这些算法需要几个小时甚至几天才能开发出来。感谢Swift的高阶函数如<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">reduce</code>、<code class="fe lv lw lx ly b">filter</code>等。，其中一些复杂的算法现在只需几行代码就可以轻松解决。</p><p id="aec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示五种算法，这些算法过去很难实现，但由于Swift中的高阶函数，现在变得非常容易实现。</p><p id="8d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我将使用下面的<code class="fe lv lw lx ly b">students</code>数组作为模型对象，这样您可以更好地了解这些高阶函数是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧！</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="5c90" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">1.根据条件对数组元素进行分组</h1><p id="821e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">假设我们想按学生名字的第一个字母对他们进行分组。传统上，我们必须手动遍历数组中的每个元素，并相应地对它们进行分组。</p><p id="3e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在<code class="fe lv lw lx ly b">Dictionary(grouping:by:)</code>初始化器的帮助下，我们不需要使用<code class="fe lv lw lx ly b">for-in</code>循环就可以实现。方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="eb70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的示例代码中可以看出，初始化器将生成一个类型为<code class="fe lv lw lx ly b">[KeyType: Student]</code>的字典。如果我们想按标准对学生分组并在多部分表格视图中显示他们，这尤其有用。</p><p id="4970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用Swift中的简写参数名称或关键路径语法来进一步简化该代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="39dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">想知道如何通过自定义对象对数组元素进行分组？查看我以前的文章“</em> <a class="ae ky" href="https://swiftsenpai.com/swift/group-array-elements-with-dictionary/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">在Swift </em> </a> <em class="nf">中用字典对数组元素分组。”</em></p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="5063" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">2.计算数组元素的出现次数</h1><p id="d9d9" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">计算一个数组中元素的总数很容易，但是如果我们想根据某些标准计算元素的出现次数呢？例如，假设我们想知道<code class="fe lv lw lx ly b">students</code>数组中有多少男女学生。</p><p id="f7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是使用我们刚刚看到的<code class="fe lv lw lx ly b">Dictionary(grouping:by:)</code>初始化器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="50aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的方法可能会给我们想要的结果。但是，它确实有一些内存开销。如你所见，初始化器将生成我们并不真正需要的男女学生数组。我们需要的只是男女学生的发生。</p><p id="ec33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服内存开销，我们可以利用数组的<code class="fe lv lw lx ly b">reduce(into:)</code>函数。让我们来看看下面的示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个示例代码的作用是将<code class="fe lv lw lx ly b">students</code>数组简化成一个<code class="fe lv lw lx ly b">[Gender: Int]</code>类型的字典。在闭包内，我们通过计算男女学生的出现次数来累积填充最终的字典。</p><p id="6a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经理解了如何使用<code class="fe lv lw lx ly b">reduce(into:)</code>函数来计算出现次数，让我们通过给<code class="fe lv lw lx ly b">result</code>字典一个默认值<code class="fe lv lw lx ly b">0</code>来进一步简化示例代码，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们避免了内存开销，同时保持了代码的简单和整洁。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="24df" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">3.获取数组的和</h1><p id="e2a2" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">接下来，我将向你展示如何用一行代码得到一个数组的和。假设我们想得到学生年龄的总和。为此，我们可以像这样使用数组的<code class="fe lv lw lx ly b">reduce(_:_:)</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可能已经猜到的，我们可以通过使用简写的参数名称来进一步改进示例代码:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="01a4" class="nk mj it ly b gy nl nm l nn no">let sum = students.reduce(0, { $0 + $1.age })</span></pre><p id="c881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于数组元素类型支持加法运算符(<code class="fe lv lw lx ly b">+</code>)的情况，我们可以通过省略简写参数名称来进一步简化它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="9034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷，不是吗？</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e07e" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">4.通过ID访问数组元素</h1><p id="9e6b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在处理数组时，我们需要执行的最常见的操作之一是使用对象ID查找特定的数组元素。最直接的方法是使用一个<code class="fe lv lw lx ly b">for-in</code>循环或者数组的<code class="fe lv lw lx ly b">filter(_:)</code>函数来遍历每个数组元素。</p><p id="f517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数情况，这两种方法都足够好了。然而，它们都有<em class="nf"> O(n) </em>的时间复杂度，这意味着当数组变大时，它们将花费更多的时间来找到特定的元素。对于追求速度和响应的应用程序，这些方法肯定会造成性能瓶颈。</p><p id="57a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使这个操作具有<em class="nf"> O(1) </em>的复杂性，我们可以将<code class="fe lv lw lx ly b">students</code>数组转换成一个字典，其中键是学生ID，值是<code class="fe lv lw lx ly b">Student</code>对象。</p><p id="3963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将首先利用数组的<code class="fe lv lw lx ly b">map(_:)</code>函数将数组转换为包含学生ID和<code class="fe lv lw lx ly b">Student</code>对象的元组数组。之后，我们将使用<code class="fe lv lw lx ly b">Dictionary(uniqueKeysWithValues:)</code>初始化器将元组数组转换成字典。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="46c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，将数组转换为字典的过程仍然是一个<em class="nf"> O(n) </em>操作。然而，我们只需要做一次。一旦字典准备就绪，对字典执行的任何读取操作都是一个<em class="nf"> O(1) </em>操作。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="e0d9" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">5.从数组中获取多个随机元素</h1><p id="7784" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">最后这个例子不涉及任何高阶函数，但我觉得还是值得分享的。从数组中获取大量随机元素曾经是一个很难实现的算法，因为我们需要处理各种各样的边缘情况。</p><p id="cc10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在Swift数组中的<code class="fe lv lw lx ly b">shuffled()</code>和<code class="fe lv lw lx ly b">prefix(_:)</code>函数的帮助下，这个操作变得非常容易实现。</p><p id="6c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何从<code class="fe lv lw lx ly b">students</code>数组中随机挑选三名学生:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b5fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个好处是，即使我们试图获取的元素数量大于数组的总元素数量，它也不会触发“索引超出范围”异常。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1b53" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">包扎</h1><p id="b27d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">上面显示的所有例子都可以通过使用传统的<code class="fe lv lw lx ly b">for-in</code>循环来解决。然而，这需要我们手动处理各种边缘情况。所以极易出错。</p><p id="ea7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用高阶函数，我们可以大大降低代码的复杂性，从而减少出错的可能性。最重要的是，它使我们的代码更容易维护。</p><p id="e3bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何看待利用Swift的高阶函数降低代码复杂度？你还有其他的例子可以分享吗？</p><p id="dc30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><p id="fca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">本文原载于2021年7月6日https://swiftsenpai.com</em><a class="ae ky" href="https://swiftsenpai.com/swift/5-complex-algorithms-simplified/" rel="noopener ugc nofollow" target="_blank"><em class="nf"/></a><em class="nf">。</em></p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="3e69" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">进一步阅读</h1><ul class=""><li id="7298" class="np nq it lb b lc na lf nb li nr lm ns lq nt lu nu nv nw nx bi translated"><a class="ae ky" href="https://swiftsenpai.com/swift/group-array-elements-with-dictionary/" rel="noopener ugc nofollow" target="_blank">用Swift中的字典对数组元素进行分组</a></li><li id="1088" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://www.skoumal.com/en/performance-of-built-in-higher-order-functions-map-filter-reduce-and-flatmap-vs-for-in-loop-in-swift/" rel="noopener ugc nofollow" target="_blank">Swift中Map、Filter、Reduce和flatMap与for-in循环的性能对比</a></li><li id="09f5" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">46%的人认为这个Swift代码有错误，显然，它没有！</li><li id="8e3d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://swiftsenpai.com/swift/can-you-answer-this-simple-swift-question-correctly/" rel="noopener ugc nofollow" target="_blank">你能正确回答这个简单快捷的问题吗？</a></li></ul></div></div>    
</body>
</html>