<html>
<head>
<title>How to Implement the Drag-and-Drop of Files in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中实现文件的拖放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-files-drag-and-drop-in-react-22cf42b7a7ef?source=collection_archive---------1-----------------------#2020-01-30">https://betterprogramming.pub/how-to-implement-files-drag-and-drop-in-react-22cf42b7a7ef?source=collection_archive---------1-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0afa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建自定义和可重复使用的区域来拖放文件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d76724affdffa026771ec175894ae7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*globUlbh1tGjy7cg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@claudelrheault?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Claudel Rheault </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，极客们！</p><p id="1790" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说到上传文件，我们当然可以用默认的<code class="fe ls lt lu lv b">&lt;input type='file'/&gt;</code>轻松处理。但是我很确定大多数人会同意将你的文件拖放到网页中比在文件对话框中搜索要舒服得多。</p><p id="4cba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们弄清楚如何在React中轻松创建一个用于拖放文件的区域。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e0a3" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">处理文件上传</h1><p id="5a54" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">首先，让我们创建一个基本的项目结构和样式。</p><h2 id="49a8" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">App.js</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="9641" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">FilesDragAndDrop.js</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="7587" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">FilesDragAndDrop.scss</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="228d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们目前掌握的情况。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8d2e87ace092ec1c679fee0613e11a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*EJsZ3hppAyX5i2spoQzTsw.png"/></div></figure><p id="0bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们添加一些逻辑。</p><p id="ed6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为拖放区创建一个<code class="fe ls lt lu lv b">ref</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="79ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为<code class="fe ls lt lu lv b">drop</code>和<code class="fe ls lt lu lv b">dragover</code>事件添加监听器，并阻止它们的默认行为(打开放下的文件):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e9fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，为了让事情正常工作，我们只需要检查拖放的元素是否包含文件，并将它们传递给我们的父组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">万岁！我们的拖放组件正在工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/7d182ced103ca0b6e17ec7e985a75521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BgZy3wcMd0qG3SE_FdlwUw.gif"/></div></div></figure><p id="b576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们在父组件中收到丢弃的文件时，我们可以对它们做任何我们需要的事情(例如，将它们传递给某个API端点)。</p><p id="62e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这绝对不是我们想要的拖放组件的工作方式。所以我们来做一些本质上的改进。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="553d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">自定义内容</h1><p id="b841" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">React的主要最佳实践之一是组件的可重用性。</p><p id="7c06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么最好从父组件中为拖放区提供内容。我们的拖放组件将作为一个包装器，我们将能够在任何地方重用它。</p><p id="f737" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们将在组件中呈现<code class="fe ls lt lu lv b">children</code>道具，而不是一些硬编码的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用组件时，我们需要将它包装在一些自定义内容周围:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="5473" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">验证文件格式并计数</h1><p id="7622" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">像任何其他输入一样(无论是数字、日期还是文件)，我们可能需要验证输入的数据。在某些情况下，我们应该只允许上传某些文件格式。在其他情况下，我们需要限制一次可以上传的文件数量。</p><p id="89a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而在默认的<code class="fe ls lt lu lv b">&lt;input type="file"/&gt;</code>中，我们可以使用<code class="fe ls lt lu lv b">accept</code>参数验证格式，使用<code class="fe ls lt lu lv b">multiple</code>参数验证文件数量。在我们的定制组件中，我们需要手动处理验证。</p><p id="b56c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现它，让我们给组件添加新的<code class="fe ls lt lu lv b">count</code>和<code class="fe ls lt lu lv b">formats</code>道具，并在<code class="fe ls lt lu lv b">handleDrop</code>函数中处理它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5d5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！现在，我们的组件将阻止上传格式或数量不正确的文件。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="798b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">最后但同样重要的是——UI/UX</h1><h2 id="5c99" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">叠加打开<code class="fe ls lt lu lv b">dragover</code></h2><p id="4576" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">当用户与系统交互时，他们总是希望得到一些反馈——也就是说，当文件被拖动到拖放区域时，最好显示一个覆盖图，上面显示一条消息，确认用户正在做正确的事情。</p><p id="d6c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要处理区域上的拖动，我们需要做以下事情:向状态添加一个<code class="fe ls lt lu lv b">dragging</code>参数，并处理<code class="fe ls lt lu lv b">dragenter</code>和<code class="fe ls lt lu lv b">dragleave</code>事件(当一个被拖动的文件进入该区域时启用<code class="fe ls lt lu lv b">dragging</code>，当它离开该区域时禁用):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ed8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果启用了拖动，则在区域上方显示覆盖图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1fc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你实现它的时候，你可能会注意到一些错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/523b33795c7e0982c67c62287e36b649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*f0lnzjyKm7AKisQtqzPSYQ.gif"/></div></div></figure><p id="b20f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为一旦触发了<code class="fe ls lt lu lv b">dragenter</code>事件，我们就会在内容上方显示覆盖图。因此，内容失去拖动并触发<code class="fe ls lt lu lv b">dragleave</code>事件，而覆盖捕捉到拖动并触发<code class="fe ls lt lu lv b">dragenter</code>事件。这导致了<code class="fe ls lt lu lv b">dragging</code>标志的不断变化。</p><p id="725e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这很容易解决。我们只需要检查事件是否是从覆盖图中触发的。如果<code class="fe ls lt lu lv b">dragenter</code>事件不是从覆盖图中触发的，我们需要显示它，如果<code class="fe ls lt lu lv b">dragleave</code>事件是从覆盖图中触发的，我们需要隐藏它。</p><p id="dc82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为叠加添加<code class="fe ls lt lu lv b">ref</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fc8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后检查事件目标是否等于覆盖图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，不要忘记重置拖放上的<code class="fe ls lt lu lv b">dragging</code>标志，这样它就不会影响下一个拖动文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/066f9bf6c3c66b9553926964a0aa5ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2VtvOpd43GlLFgvtw7FuTA.gif"/></div></div></figure><h2 id="b370" class="na me iq bd mf nb nc dn mj nd ne dp mn lf nf ng mp lj nh ni mr ln nj nk mt nl bi translated">关于成功上传或验证错误的消息</h2><p id="84a2" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们需要实现的最后一件事是当文件成功上传或没有通过验证时的信息消息。</p><p id="edbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将<code class="fe ls lt lu lv b">message</code>参数添加到我们的状态和将处理它的函数中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a1c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在渲染过程中，如果需要，我们将检查<code class="fe ls lt lu lv b">message</code>参数并显示适当的消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，我们可以在任何需要的地方调用<code class="fe ls lt lu lv b">showMessage</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4735" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们创造的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/ecebe300fa1cf5d032bc11533802bd07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CYegXJBPxOVeAo7jv6qxxg.gif"/></div></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9f43" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="267e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在你开始实现你自己的拖放之前，我想和你分享一些好消息。</p><p id="408e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用更酷的东西为这个组件创建了<a class="ae kv" href="https://www.npmjs.com/package/@yelysei/react-files-drag-and-drop" rel="noopener ugc nofollow" target="_blank"> npm包</a>，比如TypeScript、点击时的文件对话窗口、文本和样式定制等等。</p></div></div>    
</body>
</html>