<html>
<head>
<title>Server-Side Rendering vs. Static Site Generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端呈现与静态站点生成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/server-side-rendering-vs-static-site-generation-53a34872728c?source=collection_archive---------0-----------------------#2020-09-16">https://betterprogramming.pub/server-side-rendering-vs-static-site-generation-53a34872728c?source=collection_archive---------0-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f9a2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">炒作什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52f676c9a988e058e02a258a83062278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VyLGg5nipjcgHaF_dEuJfg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·西兰特夫在<a class="ae ky" href="https://unsplash.com/s/photos/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cafb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多流行词汇在科技领域被抛来抛去。其中两个是静态站点生成(SSG)和服务器端呈现(SSR)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/45f7b56343731044fb538624433ddb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdaVRmxXO5F_zJkzTgBNRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="c260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将试图揭开SSR和SSG的神秘面纱，并了解它们能在哪些方面真正帮助我们。我们将从一点历史开始，然后进入一些真实世界的例子和技术，如Next.js和Gatsby。</p><p id="ed05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是一个有趣的故事，因为我们将通过这些技术和方法进行一次完整的往返旅行。我们将回到未来，然后回到我们的起源。我们开始吧！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e834" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">开始的时候…</h1><p id="c8d6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一开始，只有静态网页。没有动态。纯静态的HTML文档被发送到客户端。</p><p id="acde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们访问一个网站时，一个简单的HTTP请求被发送到服务器，服务器用浏览器在屏幕上显示的实际HTML来响应。简单。</p><p id="0e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，动态渲染和模板引擎出现了。PHP和朋友们好！</p><p id="b6f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些服务器端技术让我们能够动态构建发送给客户端的HTML。来自客户端的每个HTTP请求都要经过应用服务器。这将添加一些小的动态内容，比如我们的用户名、当前日期、数据库中的数据等等。</p><p id="2051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是传统的<em class="na">服务器端渲染</em>。客户端(我们的浏览器)将获取实际的HTML来显示。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0249" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">AJAX和前端混乱的开始</h1><p id="a6d5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有了AJAX，我们突然能够异步获取数据，而不需要刷新整个页面。</p><p id="f407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很大的用户体验改进——不再有烦人的屏幕闪烁。但是让我们考虑一下这个问题…</p><p id="1e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步数据，新数据，新页面，新前端组件。前端现在负责生成它需要渲染的HTML。您好，<em class="na">客户端渲染！</em></p><p id="17ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于需要呈现可视标记客户端，各种库和框架开始涌现。其中最臭名昭著的当然是jQuery。如今，我们主要使用更现代的技术，如React、Vue和Angular。</p><p id="cec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所谓的<em class="na">前端疲劳</em>开始变得真实，到处都是新的库和框架。幸运的是，很明显有几个赢家，即React和Vue，它们非常受欢迎。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1497" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">单页应用程序及一些问题</h1><p id="ceac" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有了轻松生成可视化标记客户端的可能性，我们不知何故完全放弃了我们心爱的服务器来进行渲染。</p><p id="54ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的HTML现在都是在客户端生成的。服务器将通过AJAX向浏览器发送一个空的HTML和一些JSON或XML格式的数据，我们将使用我们首选的库/框架用有意义的标签和样式填充页面。当然，通过客户端JavaScript，这是可能的。</p><p id="e56e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">单页面应用</strong> (SPAs)开始弹出——完全客户端渲染的页面，不需要任何到服务器的往返，只需要通过AJAX获取数据。</p><p id="ac05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在客户端呈现整个网页也带来了一系列潜在的问题。首先，人们开始关注SEO——搜索引擎优化。</p><p id="d3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着谷歌的网络爬虫读取和索引网站(这样你的网页就可以在谷歌上列出)，我们担心这些“机器人”不会拾取尚未呈现的HTML。我们担心，谷歌或其他<em class="na"> &lt;在这里插入搜索引擎名称&gt; </em>，将只看到我们的根HTML标签，其中我们<em class="na">将</em> <em class="na">最终</em>通过JavaScript呈现所有内容。基本上，爬虫会看到一个空的网页。</p><p id="c134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在稍微放松了一些，因为大多数网络爬虫和索引器都在执行客户端渲染所需的JavaScript。</p><p id="d5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个潜在的问题是性能。由于在浏览器中需要执行大量的JavaScript来呈现页面，因此速度可能会变慢，因为很大一部分网络冲浪发生在CPU能力较弱的移动设备上。</p><p id="97d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我们想:让我们使用服务器。又来了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/f8824fa1266194785d0556a6b81ded93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o6WsX888JzZ-7LFp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tvick?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰勒·维克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2f7b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">回到我们的起源</h1><p id="498a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">服务器端渲染又开始流行了。</p><p id="f382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不会使用模板引擎或服务器端编程语言来生成标记，我们会使用<em class="na">现代JavaScript库和框架</em>，比如React。这种方法与客户端呈现(如在SPAs中)的区别在于，标记生成不会在客户端设备上运行，而是在我们的服务器上运行。</p><p id="26e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该是更快，但它也旨在解决潜在的搜索引擎优化问题。每当一个网络爬虫请求我们的页面时，它会得到完整的呈现——不再需要客户端JavaScript执行来呈现。服务器为每个页面请求做这一切。</p><p id="c78d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们谈论<strong class="lb iu">服务器端渲染</strong>时，我们指的就是这个场景。使用现代JavaScript库和框架，在服务器端为每个网络请求生成一个网页。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5db6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">服务器端渲染(SSR)</h1><p id="f7fd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">理解这一点至关重要，为了在服务器端呈现UI，<em class="na">我们必须有一台服务器</em>。</p><p id="ac8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，这是客户端渲染(即spa)不需要的<em class="na"/>。这些项目可以在cdn(内容交付网络)上进行缓存和廉价存储。你不应该运行虚拟机或Kubernetes pods来托管你的<em class="na">完全客户端渲染的</em>前端项目。不过，你<em class="na">在SSR中确实需要这个。</em></p><p id="5793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是服务器端渲染的一个潜在的负面影响，因为服务器会变得非常昂贵。</p><p id="b07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下。SSR是这样工作的:</p><ol class=""><li id="c4a6" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">用户代理(浏览器)请求一个页面</li><li id="c3f3" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">服务器生成页面的HTML输出并将其发送回去</li><li id="97c0" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">浏览器呈现HTML</li></ol><p id="96bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必须问一个极其重要的问题。如果服务器对一个页面的输出总是相同的，为什么每次请求都要生成输出呢？</p><p id="ef67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很棒的问题！这实际上是服务器端呈现和静态站点生成之间的区别。</p><h2 id="a010" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">SSR中的动态内容</h2><p id="8cb0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果生成的页面包含动态部分，比如用户特定的内容，那么使用服务器端呈现并为每个用户(每个请求)重新生成web页面是有意义的。</p><p id="7afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果输出总是相同的(例如，想象一个“<em class="na"> About us </em>”页面)，那么总是重新生成输出是没有意义的。这可以存储(读取:<em class="na">缓存</em>)在CDN上的某个地方，作为一个<em class="na">静态</em>(不变)资源，在世界上的任何地方快速提供服务。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9058" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">静态网站</h1><p id="c2bd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们回到了我们旅程开始的地方！</p><p id="a9e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供静态网页是web世界中的第一种方法。以“<em class="na">原样”</em>的方式存储在服务器上，并在请求时返回给客户端。</p><p id="bcf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与静态站点生成背后的想法完全相同。然而，我们没有使用普通的HTML和CSS，而是使用React、Vue和Angular等现代工具，这些工具在HTML、JSX、CSS、JavaScript、transpilers、bundlers等工具的帮助下生成一个静态输出。</p><p id="ee77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当您缺少需要对每个用户都是唯一的高度动态的数据时，您应该选择静态站点生成。</p><p id="2817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是建立静态网页的流程:</p><ol class=""><li id="f67f" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">从您最喜欢的前端库中获取静态构建输出，比如React与Next.js或Gatsby配对。这将包含所有静态资产。</li><li id="b5f9" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">将其托管在CDN上(不需要昂贵的服务器)</li><li id="758f" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">你有一个快速灵活的前端。你可以走了！</li></ol><p id="121b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，想象一个你很少更新的文件夹，比如一个餐馆的网页或者一个博客。</p><p id="a2e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，假设它是一个博客。你当然需要添加博客文章。所以，是<em class="na">动态</em>吧？服务器端渲染拯救世界！</p><p id="ff89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，别这么快。</p><p id="a2aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着现代技术的发展，静态网页可以很容易地被重建和重新部署。这是现代<em class="na">静态站点生成的核心原理。</em></p><h2 id="6ac5" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">现代静态网站</h2><p id="688d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">随着尖端技术的使用，我们的静态网站现在不再是<em class="na">那样静态了。他们可以有充满活力的一面。</em></p><p id="b8a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一领域的先驱是像Vercel(前Zeit)和Next.js、NuxtJS(面向Vue粉丝)、Netlify、Gatsby、Jekyll和Hugo这样的公司。</p><p id="a351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用像Next.js或Gatsby这样的框架，你可以在React中编写一个web应用程序，在构建时为网站<em class="na">获取所有需要的数据。</em></p><p id="aa08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强调这一点很重要:你<em class="na">可以</em>从多个来源获取任何数据(比如电子商务网站的产品、博客帖子等。)但这些仅在构建时被获取<strong class="lb iu"> </strong> <em class="na">(即当你在CDN上部署或托管应用时)。</em></p><p id="869f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接的结果是，静态站点向用户显示的数据就是您在部署/构建应用程序时获取的数据。每当要显示的信息发生变化时(比如你在你的酷博客上添加了一篇新的博客文章)，那么你<em class="na">必须重建</em>这个项目。</p><p id="701e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很复杂，但实际上并不复杂。现代工具让我们非常容易做到这一点。</p><h2 id="897a" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">Jamstack</h2><p id="1ef7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">又一个流行词，指的是技术和网络开发的运动。然而，它其实真的很酷！</p><p id="b282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jamstack中的jam代表JavaScript，API，Markup。</p><p id="6a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这一运动鼓励人们使用根本不使用服务器的静态网站，使主机更便宜，应用程序更有弹性，没有停机时间。在构建时获取数据以呈现页面是Jamstack站点的基本特征。</p><p id="6730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些伟大的技术使Jamstack变得可行。</p><p id="15ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无头CMS开始大受欢迎。基本上，这些内容管理系统帮助您在构建时存储和获取数据。Netlify CMS和Contentful就是两个无头CMS的例子。</p><p id="3c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，每当您通过headless CMS提交一篇新的博客文章时，就会触发一个新的前端静态项目构建。整洁！你仍然不需要为任何服务器付费，你的应用程序显示的数据是准动态的。</p><p id="0f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以托管你的静态网站，并且是Jamstack先驱的平台，像Netlify和Vercel，使得无头CMS和你的实际静态网站之间的集成无缝。</p><p id="ac18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需按下一个按钮添加一篇博客文章，瞧，你的静态网站已经重新生成，并准备好以全新的内容访问。通过CDN，它仍然快得惊人。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="256e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">服务器端呈现与静态站点生成</h1><p id="1352" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">那是许多信息！</p><p id="4a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们什么时候应该使用SSR，什么时候应该使用SSG呢？我们来看看几个利弊。</p><h2 id="b31c" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">服务器端渲染</h2><p id="c867" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">优点:</p><ul class=""><li id="c2f0" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu oc ni nj nk bi translated">所有显示的数据总是最新的。</li><li id="ae72" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu oc ni nj nk bi translated">您可以显示经常变化的用户特定的动态数据。</li></ul><p id="6985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:</p><ul class=""><li id="a163" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu oc ni nj nk bi translated">您需要一台服务器来运行渲染，这可能会非常昂贵。</li><li id="97dc" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu oc ni nj nk bi translated">你不能使用cdn来帮助你的应用加载得更快(你<em class="na">可以</em>在你的SSR应用前面放一个缓存层，但那样你就有显示陈旧数据的风险)。</li></ul><h2 id="df21" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">静态站点生成</h2><p id="ee2a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">优点:</p><ul class=""><li id="b872" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu oc ni nj nk bi translated">你会得到一个非常快速的网站(因为它可以部署到CDN)。</li><li id="e079" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu oc ni nj nk bi translated">不需要等待服务器端逻辑。</li><li id="d73c" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu oc ni nj nk bi translated">如果服务器停机也没关系(因为我们不需要它！)</li></ul><p id="290e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺点:</p><ul class=""><li id="a974" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu oc ni nj nk bi translated">如果内容是高度动态的或特定于用户的，则不理想。</li><li id="3433" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu oc ni nj nk bi translated">当我们想要显示不同的或新的数据时，需要重建。</li></ul><h2 id="f60f" class="nq me it bd mf nr ns dn mj nt nu dp mn li nv nw mp lm nx ny mr lq nz oa mt ob bi translated">苹果之间的比较？</h2><p id="c07d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">理解SSR和SSG不是直接竞争对手是至关重要的。当一个或另一个更合适时，您将有特定的用例。</p><p id="602e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个个人网站还是一个品牌的网站，有一个博客和一些很少改变的数据？使用静态站点生成可能会更好。</p><p id="43ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个拥有个人数据的用户独有的网站，dashboard？也许服务器端渲染是更好的选择。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ed3a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">混合方法</h1><p id="cc03" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通常，对于较大的产品，您会发现某些页面确实可以静态呈现，而其他页面最好使用服务器端呈现。</p><p id="e451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好——next . js和类似的技术自动静态地呈现需要构建时数据(或者根本不需要数据)的页面和需要每个请求的<em class="na">数据的服务器端呈现页面。</em></p><p id="5cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，使用这两种方法，客户端数据获取仍然是一件事。</p><p id="46ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以选择只做一个简单的AJAX请求来重新提取可能过时的数据，但除此之外还有一个静态网站。让你的创造力和背景来驱动你的决定。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e5a8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最后</h1><p id="0830" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">感谢您花时间从头到尾阅读这篇文章——您真棒！</p><p id="6a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你学到了一些有价值的信息。</p><p id="fd03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持创意！</p></div></div>    
</body>
</html>