<html>
<head>
<title>How To Create a Caching Service for Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Angular创建缓存服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-caching-service-for-angular-bfad6cbe82b0?source=collection_archive---------0-----------------------#2019-09-25">https://betterprogramming.pub/how-to-create-a-caching-service-for-angular-bfad6cbe82b0?source=collection_archive---------0-----------------------#2019-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释使用Angular和RxJS缓存HTTP调用的正确方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/659126a16e16b35195395b3e07f79aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDu4SPHYSOIunz8bLvsuMQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谢尔盖·佐尔金在<a class="ae ky" href="https://unsplash.com/s/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TL；DR:你需要缓存从<code class="fe lv lw lx ly b">HttpClient</code>返回的可观测值，并与<code class="fe lv lw lx ly b">shareReplay</code>和<code class="fe lv lw lx ly b">catchError</code>结合。</p><p id="3337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很多情况下，我们需要一遍又一遍地问服务器同样的问题。典型的例子是要求对术语进行翻译，或者使用位于服务器上的词汇表解析一些代码。</p><p id="7bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不想太麻烦服务器，所以我们使用缓存。在本文中，我将尝试解释使用Angular和<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>缓存HTTP调用的正确方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7cf6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不缓存</h1><p id="a983" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">因此，假设我们有一个服务器可以返回某些产品的营养信息。让我们使用<a class="ae ky" href="https://world.openfoodfacts.org/api/v0/product/7613034626844.json" rel="noopener ugc nofollow" target="_blank">开放食品事实API </a>来实现这一点。</p><p id="69a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给它产品的代码(例如<code class="fe lv lw lx ly b">"7613034626844"</code>)，它返回给我一个包含所有必要信息的对象(例如<code class="fe lv lw lx ly b">{name: "Ovomaltine milk powder"}</code>)。让我们为此绘制一个角度服务(参见<a class="ae ky" href="https://stackblitz.com/edit/angular-non-caching-service?file=src%2Fapp%2Fproduct.service.ts" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0101" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该服务获取代码，并将其作为参数传递给API。我们将创建一个超级简单的<code class="fe lv lw lx ly b">ProductComponent</code>并在构造函数中调用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们像在<code class="fe lv lw lx ly b">AppComponent</code>中那样使用<code class="fe lv lw lx ly b">ProductComponent</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">果然，我们将看到该请求被执行了三次，尽管我们总是询问相同的信息。现在，让我们使用缓存来提高速度。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f811" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">值的简单缓存</h1><p id="3c40" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">缓存的第一个想法是实际缓存返回的术语，就像我在这里做的那样(参见<a class="ae ky" href="https://stackblitz.com/edit/angular-non-caching-service-naive?file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论上，我们的服务检查给定的术语是否存在于缓存中，如果存在，则返回它。如果产品代码是新的，它会要求HTTP服务调用它。当服务器向我们发送响应时，我们使用<code class="fe lv lw lx ly b">tap</code>操作符将其放入缓存。</p><p id="2013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，用户点击一个按钮来查看关于代码<code class="fe lv lw lx ly b">"7613034626844"</code>的信息，我们的服务将执行对服务器的调用。</p><p id="7aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户下次单击按钮来解析相同的术语时，我们的服务将不会启动HTTP调用，而是使用缓存的值。乍一看，一切正常。</p><h2 id="fb64" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">天真方法的问题</h2><p id="855f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">但是，有一个警告:我们将值异步放入缓存，所有异步代码都将在同步代码之后执行。</p><p id="3b61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在一个<code class="fe lv lw lx ly b">for</code>循环中或者在<code class="fe lv lw lx ly b">*ngFor</code>中调用<code class="fe lv lw lx ly b">resolve</code>函数，或者只是让几个组件在同一个模板中使用它，会怎么样？结果是我们的缓存没有完成它的工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/67d5c69220431f02a3d6d01ae6ccdcf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ySzOv6-JEGP_wNd0E6crg.png"/></div></div></figure><p id="ba45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">突然，在网络选项卡中，我们看到许多相同的HTTP请求，所以很明显，缓存跟不上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/520f85349b6374fc6ecde467fdb6260c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RY5EKTST4DyVh9P0ZJEcPA.png"/></div></div></figure><p id="8efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是对HTTP调用的反应只有在所有这些HTTP调用被执行之后才会发生，因为每个异步代码都发生在事件循环中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1e7a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">不那么天真的版本——缓存可观察对象本身</h1><p id="f3b3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以很容易地解决这个问题。我们可以缓存Angular <code class="fe lv lw lx ly b">HttpClient</code>服务返回的可观察值，而不是缓存来自服务器的返回值。</p><p id="9a51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，函数调用和缓存将是同步的。惟一的技巧是我们必须使用<code class="fe lv lw lx ly b">shareReplay</code>操作符，它将允许订户查看HTTP调用的结果。</p><p id="37e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有<code class="fe lv lw lx ly b">shareReplay</code>，请求后可观察对象将保持在<code class="fe lv lw lx ly b">FINISHED</code>状态，新订户将无法获得其值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">network选项卡中的结果与我们计划的完全一样，我们只有一个HTTP调用。现在，剩下的就是管理异常。</p><h2 id="5bed" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">处理异常</h2><p id="0198" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们的服务器停机几秒钟，而我们要求它解决一个术语，会发生什么？错误HTTP代码将在可观察对象中引发一个错误。</p><p id="8373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在可观测性出错或结束后，我们无法重启它——这是可观测性的契约。</p><p id="2338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们目前的方法，这意味着我们正在缓存错误，这是不合理的:服务器最终将开始工作，我们希望向它发送一个HTTP请求。</p><p id="9d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们可以使用<code class="fe lv lw lx ly b">catchError</code>操作符从缓存中删除一个可观察对象，这样，下一次，服务器将被调用。</p><p id="a2bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以为此使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete" rel="noopener ugc nofollow" target="_blank">delete</a></code>操作符，或者如果您更关心性能而不是可读性，可以将<code class="fe lv lw lx ly b">false</code>分配给缓存中的那个键。</p><p id="1304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:现在我们只调用API一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/f71717e56e323670f9ee8b456a1e2dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPH-dY7iBz4RVioqJ2qelA.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1305" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">分析</h1><p id="ccfb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这种特殊的缓存方法被称为<em class="nu">记忆化</em>，它将在以下情况下很好地为您服务:</p><ul class=""><li id="bee0" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">用户多次询问相同的信息。</li><li id="d6f8" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">服务器上的这些信息本质上是稳定的。将它用于词汇、翻译和查找服务。</li><li id="eb64" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">您的应用程序不应该在不重新加载的情况下运行很多天。</li></ul><p id="e114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存化的所有缺点都有一个共同的原因，那就是我们从来没有清理过我们缓存的值。考虑到这一点，这里有一些限制:</p><ul class=""><li id="a51e" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><em class="nu">不要使用这种缓存方法来检查实时信息:股票价格、天气、Twitter feed等。这根本行不通。</em></li><li id="2dc9" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">如果您希望您的应用程序运行几个月甚至几年而不需要重新加载，不要使用这种缓存方法，因为缓存大小会变得非常大，并且您会有内存泄漏。</li></ul></div></div>    
</body>
</html>