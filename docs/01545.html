<html>
<head>
<title>Handling Observable Streams with RxJS Observables, Subscribers and Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS可观察对象、订户和运营商处理可观察流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-observable-streams-with-rxjs-observables-subscribers-and-operators-6111b71a9925?source=collection_archive---------4-----------------------#2019-09-23">https://betterprogramming.pub/handling-observable-streams-with-rxjs-observables-subscribers-and-operators-6111b71a9925?source=collection_archive---------4-----------------------#2019-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b2e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">RxJS概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08e37baf7ce84aa5388351c68a4b8d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7dJlq9pkW7SARiRraj-7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Karim Sakhibgareev 在<a class="ae ky" href="https://unsplash.com/s/photos/stream?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="67e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发工业优势系统时，我们在构建时考虑性能是至关重要的。异步非阻塞处理已经成为JavaScript生态系统中不可或缺的一部分，无论是在服务器端还是客户端应用程序中。因此，存在许多工具来帮助开发经过微调的应用程序，以处理异步任务或事件，如回调、承诺、async/await和RxJS。</p><p id="dab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将在一个高层次上探索RxJS，并考虑用它处理异步事件所需的基本组件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d0f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RxJS到底是什么？</h1><p id="24d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">RxJS是“Javascript反应式扩展”的首字母缩写。简而言之，它是一个为反应式编程构建的库，带有支持异步代码合成的组件。它提供了一个<code class="fe mz na nb nc b">Observable</code>类型的实现。</p><h2 id="f2c8" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">看得见的</h2><p id="1348" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可观察对象是<code class="fe mz na nb nc b">Observable</code>类型的一个实例。它支持在应用程序中发布消息(事件)和订阅这些消息。换句话说，一个<em class="np">可观察的</em>对一系列事件建模。持有可观察对象订阅的对象被称为<em class="np">观察者</em>。</p><h2 id="a92d" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">观察者</h2><p id="1a08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些都是可以观察到的物体。订阅者侦听由observables发出的消息，并通过对收到的消息执行声明的转换来对这些消息做出“反应”。</p><p id="83de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式支持高效处理并发操作，因为观察器<em class="np">在等待来自观察器的消息时不会阻塞线程</em>。</p><h2 id="4261" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">经营者</h2><p id="d0eb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些函数使我们能够对observables发出的事件执行特定的操作。有许多可观察的算子。它们通常根据对可观察对象的影响进行分类——例如，产生可观察对象的算子<code class="fe mz na nb nc b">(from()</code>、<code class="fe mz na nb nc b">create()</code>、<code class="fe mz na nb nc b">start())</code>、转换可观察对象的算子<code class="fe mz na nb nc b">(map()</code>、<code class="fe mz na nb nc b"> scan()</code>、<code class="fe mz na nb nc b">flatMap())</code>以及过滤可观察对象的算子<code class="fe mz na nb nc b">(debounce()</code>、<code class="fe mz na nb nc b">filter()</code>、<code class="fe mz na nb nc b">sample()</code>、<code class="fe mz na nb nc b">take())</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e863" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一个简单的可观察用例</h1><p id="3238" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您在NoSQL数据库中有一个<code class="fe mz na nb nc b">users</code>集合，您想从其中加载数据并检查数据是否满足给定的标准。如果满足条件，那么您希望对数据执行转换，并将数据存储在目标集合中。这个问题可以用同步和异步策略来解决。</p><h2 id="c214" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">同步方法</h2><p id="d80c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是一些伪代码，展示了如何使用同步策略来完成上述任务:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="66ef" class="nd md it nc b gy nu nv l nw nx">read users from DB collection<br/>for each user in users<br/>	check criteria<br/>	if user meets critetia<br/>		perform transformation<br/>		store transformed data in target collection.<br/>	end<br/>end</span></pre><p id="bb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图描述了事件处理的顺序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/3e43e6201c463e2abf2a85548a3e9784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JuGuGAGfVg42HDZmAVzw4Q.jpeg"/></div></div></figure><p id="c3aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不相互依赖的任务被一个接一个地执行，直到完成。这种方法有利有弊。一些显著的优点是:</p><ul class=""><li id="ceff" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">同步流程中算法的实现通常没有相应的异步解决方案复杂。</li><li id="4c70" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">同步流程实现起来通常比异步流程耗时更少。</li></ul><p id="6620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面也有缺点:</p><ul class=""><li id="1b6e" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">同步代码由定义<code class="fe mz na nb nc b">blocks</code>程序执行，直到正在执行的任务完成。在上图中，用户二要完成的任务是不同的，并且独立于用户一的任务。然而，在用户一的任务完成之前，用户二的任务不能运行。这显然不是最有效的方法。更糟糕的是，如果在用户一执行任务的过程中出现错误，程序将被终止，而用户二和用户三的操作不会执行。</li><li id="495f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">在许多情况下，这种形式的程序不能很好地利用资源，程序性能会受到严重影响。</li></ul><h2 id="8149" class="nd md it bd me ne nf dn mi ng nh dp mm li ni nj mo lm nk nl mq lq nm nn ms no bi translated">异步方法</h2><p id="77e5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一种异步、非阻塞的方法涉及所需任务的并发执行，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/22aac97545bce5cff45746dc23a932bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sn7JE7teqVBg8pn4NRMlJA.jpeg"/></div></div></figure><p id="0e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图描述了可观察流中的事件处理:</p><ul class=""><li id="5cdd" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">上面的水平线是可观测的时间线，时间从左向右流动。</li><li id="079f" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">与可观察时间线相交的形状是由可观察物体发出的项目。</li><li id="2cfc" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">与可观察时间线相切的垂直线表示可观察已经成功完成。</li><li id="367c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">矩形框描述了在发射的对象上执行的变换。这些对象由订户接收并通过管道进行转换。</li><li id="9a7c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">底部的水平线是转换的可观察结果。</li></ul><p id="9b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种异步方法中，用户对象的操作和转换按顺序同时发生。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经看到了Observables如何工作的一些背景，让我们看看如何在RxJS中利用它们。考虑这个程序:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="b797" class="nd md it nc b gy nu nv l nw nx">const data = [];<br/><br/>for (let i = 0; i &lt; 10; i++) {<br/>    data.push(i)<br/>}<br/><br/>const values: Array&lt;number&gt; = data<br/>    .map(value =&gt; value * 3)<br/>    .filter(value =&gt; value % 4 === 0);</span></pre><p id="eff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码创建了一个数组，并将0到9的整数插入到数组中，然后将数组中的所有元素乘以系数3。最后，它只将能被4整除的值过滤到一个名为“值”的新数组中。当我们将数组值记录到标准系统输出中时，我们看到我们的结果是[0，12，24]。</p><p id="387c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用RxJS和observables实现完全相同的一组动作。我们的第一个行动是创建一个生产者，它产生我们的程序将观察并最终“反应”的值。这很容易实现:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="0e27" class="nd md it nc b gy nu nv l nw nx">import { Observable } from "rxjs";<br/>import { filter, map } from 'rxjs/operators';<br/><br/>const observable: Observable&lt;number&gt; = new Observable((subscriber) =&gt; {<br/>    for (let i = 0; i &lt; 10; i++) {<br/>        subscriber.next(i);<br/>    }<br/>    subscriber.complete();<br/>});</span></pre><p id="2352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第四行，我们创建了一个新的可观察实例。我们向订阅者(或观察者)传递构造函数的唯一参数。一个观察者有三个重要的基本功能:<code class="fe mz na nb nc b">next()</code>、<code class="fe mz na nb nc b">error()</code>和<code class="fe mz na nb nc b">complete()</code>。<code class="fe mz na nb nc b">next()</code>用于向观察实体发出消息。<code class="fe mz na nb nc b">error()</code>用来提醒观察者在过程中发生的错误。最后，<code class="fe mz na nb nc b">complete()</code>通知观察者成功完成。</p><p id="5fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这些方法，就很容易理解这个程序实现了什么。我们已经创建了一个可观察对象，它向订阅了它的观察者发送1到9的数字流。当然，在创建了一个可观察对象之后，我们必须创建其对应的订户:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="4835" class="nd md it nc b gy nu nv l nw nx">observable<br/>    .pipe(<br/>        map(value =&gt; value * 3),<br/>        filter(value =&gt; value % 4 === 0)<br/>    ).subscribe(result =&gt; console.log(result));</span></pre><p id="9c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在订阅可观察对象之前，使用<code class="fe mz na nb nc b">map</code>和<code class="fe mz na nb nc b">filter</code>运算符。<code class="fe mz na nb nc b">map</code> <strong class="lb iu"> </strong>通过对可观察对象应用函数来转换它们发出的项目。<code class="fe mz na nb nc b">filter</code>删除可观察流中不需要的元素，只发出通过谓词测试的元素。</p><p id="67c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们使用了一种我们可观察到的<code class="fe mz na nb nc b">pipe</code>方法。<code class="fe mz na nb nc b">pipe</code>用于无功运算符的合成。这在对数据流进行复杂转换时非常方便！</p><p id="efbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">pipe()</code>函数返回一个观察值，我们最终订阅该观察值以获得我们的结果。将发出的数据记录到控制台，我们得到0、10、24。这正是我们使用第一种方法时得到的结果！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e0c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8bb4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这篇文章中，我们用RxJS探索了Node.js中反应式编程的关键基础。不管怎样，在ReactiveX的世界里，总会有新的发现。如果您有兴趣深入研究ReactiveX和RxJS，这里有一些很好的文章可以帮助您:</p><ul class=""><li id="6094" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/rxjs-and-node-8f4e0acebc7c/" rel="noopener ugc nofollow" target="_blank">node . js中的反应式编程和可观察序列</a></li><li id="e65d" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="http://reactivex.io/documentation/observable.html" rel="noopener ugc nofollow" target="_blank">react vex文档</a></li><li id="9e27" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://ultimatecourses.com/blog/rxjs-observables-observers-operators" rel="noopener ugc nofollow" target="_blank"> RxJS:可观测量、观测器和操作器介绍</a></li></ul></div></div>    
</body>
</html>