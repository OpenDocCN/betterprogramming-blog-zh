<html>
<head>
<title>Yew vs VueJS + WebAssembly: Which is Better for Building a Rust App?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Yew vs VueJS + WebAssembly:搭建Rust App哪个好？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/yew-vs-vuejs-webassembly-which-is-better-for-building-a-rust-app-8fa6c45c879f?source=collection_archive---------6-----------------------#2022-09-05">https://betterprogramming.pub/yew-vs-vuejs-webassembly-which-is-better-for-building-a-rust-app-8fa6c45c879f?source=collection_archive---------6-----------------------#2022-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="041d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对利弊的讨论</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d523f370735583ea0abc2b614c628edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYxUuwXe3LSpOAB83ClnSg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=5291766" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kv" href="https://pixabay.com/users/pixxlteufel-117549/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=5291766" rel="noopener ugc nofollow" target="_blank"> Micha </a></p></figure><p id="47b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事展示了使用Rust开发一个计算工作量大的网站的两种不同方法的比较:(a)使用<a class="ae kv" href="https://yew.rs/" rel="noopener ugc nofollow" target="_blank"> Yew </a>全力以赴使用Rust(和WebAssembly)或者(b)使用<a class="ae kv" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> VueJS </a>框架和WebAssembly。</p><p id="82ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的经验是后者。它是高性能的，使用全面的工具，并且设置和完成工作相当简单。但是开发人员的体验受到代码库分成VueJS和Rust部分的影响。</p><p id="2f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事是对之前没有经验的Yew的一个实验，以评估开发人员的体验是否得到了改善，并发现可能的折衷。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="a49a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中开发和展示的源代码可以在<a class="ae kv" href="https://github.com/juliendecharentenay/yew-investigation" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。https://www.charentenay.me/yew_investigation/index.html<a class="ae kv" href="https://www.charentenay.me/yew_investigation/index.html" rel="noopener ugc nofollow" target="_blank">有现场版。</a></p><p id="c798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Yew和VueJS之间的比较基于Fibonacci序列的第40项的计算的实现，如<a class="ae kv" href="https://fazlurnu.com/2020/09/18/python-vs-julia-speed-test-on-fibonacci-sequence/" rel="noopener ugc nofollow" target="_blank">https://fazlurnu . com/2020/09/18/python-vs-Julia-speed-test-on-Fibonacci-sequence/</a>中所述。</p><p id="4ce5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给出了三个实现:(a)普通VueJS——我想比较WebAssembly和JavaScript的执行速度，(b) VueJS + WebAssembly，以及(b) Yew。使用<a class="ae kv" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> tailwindcss </a>框架。不是为了它的外观和感觉，而是为了研究不使用NodeJS生态系统的缺点。</p><p id="3e32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比较着眼于以下标准:</p><ul class=""><li id="09ca" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">开发者体验——这是一个主观标准，这个测试项目非常简单</li><li id="e019" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">碳足迹——使用<a class="ae kv" href="https://www.websitecarbon.com/" rel="noopener ugc nofollow" target="_blank">网站碳计算器</a>测量</li><li id="1d1d" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">首次渲染和下载大小的时间——使用<a class="ae kv" href="https://www.webpagetest.org/" rel="noopener ugc nofollow" target="_blank">网页测试</a>测量</li><li id="8865" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">执行速度—计算斐波那契数列第40项的处理时间</li></ul><h1 id="39f4" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">VueJS和VueJS + WebAssembly</h1><p id="f36f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">实现普通的VueJS/JavaScript和VueJS + WebAssembly网页相当简单，因为我以前有过使用该框架的经验。</p><p id="86cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从开发者的经验来看，VueJS + WebAssembly实现的难点在于设置VueJS和Rust/WebAssembly的边界。在当前的上下文中，计算斐波那契数列的函数调用处有一个自然边界。这种分离将实现分为在VueJS中实现的UI端和在Rust中实现的计算端。</p><h1 id="a647" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">紫杉</h1><p id="c538" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我开始按照<a class="ae kv" href="https://yew.rs/docs/tutorial" rel="noopener ugc nofollow" target="_blank">红豆杉教程</a>和<a class="ae kv" href="https://yew.rs/docs/getting-started/build-a-sample-app" rel="noopener ugc nofollow" target="_blank">红豆杉样本应用</a>撰写。评估斐波那契数列第40项的页面实现相当简单，因为页面功能非常基本。</p><p id="6f49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这足以表明紫杉框架需要一些时间来调整。在我看来，一个缺点在于如何编写应用程序的HTML部分。它需要一些操作——没有挑战性，但是有一些认知超载——这使它不同于编写普通的HTML。例如，需要添加<code class="fe nk nl nm nn b">{ "..." }</code>来声明纯文本。“hello world”教程采用以下形式:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="ffa3" class="ns mo iq nn b gy nt nu l nv nw">&lt;p&gt;{ "hello world!" }&lt;/p&gt;</span></pre><p id="5c34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺风CSS的设置如文章<a class="ae kv" href="https://dev.to/arctic_hen7/how-to-set-up-tailwind-css-with-yew-and-trunk-il9" rel="noopener ugc nofollow" target="_blank">如何用紫杉和树干设置顺风CSS</a>中所述。这允许将顺风CSS编译成单个CSS文件，该文件仅包括项目中使用的顺风CSS元素，从而减小CSS文件的大小。</p><p id="0685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个过程必须在Yew实现中手工完成，而它是在VueJS设置中构建的。一种更简单的替代方法是将<code class="fe nk nl nm nn b">index.html</code>链接到tailwind CSS CDN，但代价是导入整个tailwind CSS库，增加下载文件的大小，以及第一次渲染的时间变慢。</p><p id="fa0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在使用Yew时遇到了以下限制——但是请考虑这是基于在这个项目中获得的非常有限的经验，一个更有经验的人可能知道如何解决这些问题。</p><h1 id="9296" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">测试</h1><p id="9347" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">测试铁锈很简单。但是我还不知道如何对HTML逻辑进行单元测试——我承认<a class="ae kv" href="https://yew.rs/docs/more/testing" rel="noopener ugc nofollow" target="_blank">文档</a>声明，“我们正在努力使组件测试变得容易，但是这是目前正在进行的工作。”https://github.com/yewstack/yew/issues/1413的<a class="ae kv" href="https://github.com/yewstack/yew/issues/1413" rel="noopener ugc nofollow" target="_blank">中已经强调了对这一功能的需求。</a></p><h1 id="34ec" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">多页</h1><p id="ff09" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我不太喜欢单页应用程序。Yew为单页应用程序提供了一个路由器，但没有提供从一个板条箱生成多页的“开箱即用”选项。https://github.com/yewstack/yew/issues/1060的<a class="ae kv" href="https://github.com/yewstack/yew/issues/1060" rel="noopener ugc nofollow" target="_blank">中描述了一些选项，将每一页分割成一个单独的板条箱，或者使用cargo的功能。</a></p><h1 id="7de5" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">比较</h1><p id="e7a2" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">斐波纳契数列第40项的计算实现使用以下指标进行比较:</p><ul class=""><li id="1555" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">开发人员体验——与我对在该框架中开发所获得的快乐和满足感的感受相关——这是非常主观的，需要有所保留</li><li id="2bbd" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">speed-报告计算斐波那契数列第40项的执行速度。在所有实现中，执行速度都是使用web <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Performance" rel="noopener ugc nofollow" target="_blank">性能API </a>的全局实例来计算的</li><li id="0f7e" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">开始渲染和大小—使用<a class="ae kv" href="https://www.webpagetest.org/" rel="noopener ugc nofollow" target="_blank"> WebPageTest </a>站点性能测试进行评估，配置如下:位于美国弗吉尼亚州的带电缆连接的台式机</li><li id="f015" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">CO2 —估算与单页视图相关的碳排放量。这个估算是使用<a class="ae kv" href="https://www.websitecarbon.com/" rel="noopener ugc nofollow" target="_blank">网站碳计算器</a>完成的。</li></ul><p id="f046" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下表显示了在<a class="ae kv" href="https://www.charentenay.me/yew_investigation/index.html" rel="noopener ugc nofollow" target="_blank">https://www.charentenay.me/yew_investigation/index.html</a>部署的三个实施选项的比较——由AWS S3托管并通过CloudFront提供服务:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="d32d" class="ns mo iq nn b gy nt nu l nv nw">+----------------+-----------+--------------+----------+<br/>  |   Option       |   VueJs   |  VueJs/Wasm  |    Yew   |<br/>  +----------------+-----------+--------------+----------+ <br/>  |  Experience    |     +     |       =      |     +    |<br/>  +----------------+-----------+--------------+----------+<br/>  |  CO2           |   0.02g   |     0.02g    |   0.10g  |<br/>  +----------------+-----------+--------------+----------+<br/>  |  Start Render  |    0.5s   |      0.6s    |    0.9s  |<br/>  +----------------+-----------+--------------+----------+<br/>  |  Size          |     87kB  |       90kB   |    279kB |<br/>  +----------------+-----------+--------------+----------+<br/>  |  Speed         |    3.8s   |       0.9s   |    0.9s  |<br/>  +----------------+-----------+--------------+----------+</span></pre><h1 id="3310" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">我的感知</h1><p id="6a5d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我的开发者体验偏向于纯VueJS实现，因为它感觉舒适和简单。使用Yew框架在pure Rust中开发的体验是令人满意的——但它目前有点落后，因为该框架尚未达到NodeJS生态系统和VueJS提供的成熟度。</p><p id="0f20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我对开发VueJS/WebAssembly网页的看法不太满意，因为它需要在JavaScript和Rust语言之间切换，这增加了一些认知负荷/上下文切换。</p><p id="d5f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从性能角度来看，当算法编译到WebAssembly时，Fibonacci序列第40项的计算速度明显加快，而Yew和VueJS/WebAssembly之间没有明显差异。</p><p id="ec08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从页面呈现的角度来看，VueJS和VueJS/WebAssembly实现的得分与Yew实现相似，但略好于后者。与这两种VueJS实现相比，Yew实现在渲染方面确实显示了轻微的滞后。</p><p id="8a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，使用紫杉有好处，我可能会迁移一些项目。但是有些方面，即缺乏测试HTML逻辑的能力，无法利用NodeJS生态系统，以及渲染时间稍慢，可能会让我暂时坚持使用VueJS/WebAssembly组合来完成更大的项目。</p><h1 id="e162" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">其他可能感兴趣的项目</h1><p id="fcb1" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">从AWS S3/CloudFront服务WebAssembly:在这个练习中，以下问题变得很明显。WebAssembly <code class="fe nk nl nm nn b">wasm</code>文件被上传到S3，MIME类型为<code class="fe nk nl nm nn b">octet/binary-stream</code>——在之前的<a class="ae kv" href="https://julien-decharentenay.medium.com/vuejs-rust-webassembly-webworker-hosted-on-aws-s3-an-example-7e917ff5edd2" rel="noopener">故事</a>中已经讨论过。本练习使用CloudFront函数来更改MIME类型，而不是更改S3对象的MIME类型，从而解决了这个问题。</p><p id="7af6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用tailwind CSS CDN:我最初使用tailwind CSS CDN来实现Yew。这增加了渲染时间，直到它变得显而易见——特别是与其他实现相比，并且考虑到页面的简单性。当使用tailwind CLI生成特定于项目的CSS文件时，这个问题不太明显。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="694c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nx">感谢阅读！敬请关注更多内容。</em></p></div></div>    
</body>
</html>