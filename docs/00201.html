<html>
<head>
<title>Angular Performance — 8 Considerations for Production and Runtime Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度性能—生产和运行时优化的8个考虑因素</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-preformance-considerations-12c909ac923b?source=collection_archive---------0-----------------------#2018-09-30">https://betterprogramming.pub/angular-preformance-considerations-12c909ac923b?source=collection_archive---------0-----------------------#2018-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fde3099401e42dc330c36acea3d83ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fj2bO3GbeLBw6lcbigpLoA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@joaosilas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔·塞拉斯</a>在<a class="ae kf" href="https://unsplash.com/search/photos/optimize-production?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="29b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发人员面临的最重要的问题之一是应用程序的大捆绑包和低性能，尤其是当应用程序变大时。</p><p id="87ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发人员认为低性能与框架本身有关，但这是不正确的。这是由于缺乏他们必须知道的考虑因素的知识。</p><p id="2142" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我试图整合我和我的团队在处理大量有角度的大规模应用时所面临的问题</p><p id="2f44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是生产和运行时优化的八个注意事项:</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="c45d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak"> 1。使用</strong> <code class="fe mj mk ml mm b"><strong class="ak">enableProdMode</strong></code></h1><p id="fa2c" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在dev模式下，Angular框架执行开箱即用的额外检查，用于调试目的。它还具有变化检测机制，因此，当启用生产模式时，我们不需要它。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="ce9f" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2.超前编译</h1><p id="4be6" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">AOT是一种非常强大的编译模式，Angular团队采用它来提高运行时性能。它通过树抖动和在构建过程中执行计算来减少渲染应用程序所需的计算量。</p><p id="ae38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种编译模式是JIT (Just In Time ),它构建包的速度更快，而应用程序的渲染速度更慢，所以我强烈建议使用AOT来加速应用程序初始化的渲染过程。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f63c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3.网络工作者</h1><p id="49de" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Web工作者就像线程。众所周知，JS是单线程的。</p><p id="1338" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Web workers部分去除了JS是单线程的限制，因为它使JS在浏览器的线程中运行，而不会阻塞事件循环，也不会中断浏览器的主UI线程。</p><p id="f54f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到网络工作者的角度。角度变化检测每秒需要执行数百万次检查。</p><p id="0eb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于Angular的平台不可知论以及它与DOM架构的解耦，可以在web worker中运行我们的整个应用程序(包括变化检测),让主UI线程只负责渲染。</p><p id="09e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，更改检测机制将在浏览器的后台以单独的线程运行。</p><p id="6fdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular与web workers的参考资料:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="my mx l"/></div></figure><div class="mz na gp gr nb nc"><a href="https://github.com/angular/angular/tree/master/modules/playground/src/web_workers" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">角度/角度</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">一个框架。移动和桌面。在GitHub上创建一个帐户，为angle/angle开发做贡献。</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq jz nc"/></div></div></a></div></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="73ec" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4.角度通用和服务器端渲染</h1><p id="824f" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">任何单页面应用程序(不仅仅是Angular)的一个大挑战是，在呈现所需的JS可用之前，整个应用程序无法呈现，这导致了两个问题:</p><ol class=""><li id="8f31" class="nr ns it ki b kj kk kn ko kr nt kv nu kz nv ld nw nx ny nz bi translated">搜索引擎优化(SEO)在这些应用程序中无法正常工作，因为它们无法索引应用程序的动态内容。(模板绑定如<code class="fe mj mk ml mm b">ngModel={content}</code>中的内容。)</li><li id="74ab" class="nr ns it ki b kj oa kn ob kr oc kv od kz oe ld nw nx ny nz bi translated">糟糕的用户体验，因为用户将有一个空白页，直到应用程序被渲染。</li></ol><p id="a782" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务器端呈现(SSR)通过在服务器上预先呈现所请求的页面并在初始页面加载期间提供所呈现页面的标记来解决这个问题。</p><p id="9fc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考资料:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="my mx l"/></div></figure><div class="mz na gp gr nb nc"><a href="https://angular.io/guide/universal" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">角度文档</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">编辑描述</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">angular.io</p></div></div></div></a></div></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0c07" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">5.指定变更检测机制</h1><p id="9bad" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">默认情况下，Angular在整个组件树上执行变化检测，这导致复杂应用程序中的大量计算，尤其是在计算正在进行时。</p><h2 id="bcf8" class="of lm it bd ln og oh dn lr oi oj dp lv kr ok ol lz kv om on md kz oo op mh oq bi translated"><code class="fe mj mk ml mm b">ChangeDetectionStrategy.OnPush</code></h2><p id="74e3" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><code class="fe mj mk ml mm b">OnPush</code>变更检测策略允许我们禁用组件树的子树的变更检测机制。</p><p id="6447" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将任何组件的变化检测策略设置为值<code class="fe mj mk ml mm b">ChangeDetectionStrategy.OnPush</code>，我们将使变化检测仅在组件接收到不同输入时执行。</p><p id="56f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular将输入与之前的参考输入进行比较时，认为输入不同，参考检查的结果为<code class="fe mj mk ml mm b">false</code>。它是使用<a class="ae kf" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank">不可变数据结构</a>执行的。</p><p id="8611" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你来自一个<a class="ae kf" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>的背景，那就像<code class="fe mj mk ml mm b"><a class="ae kf" href="https://lucybain.com/blog/2018/react-js-pure-component/" rel="noopener ugc nofollow" target="_blank">PureComponents</a></code>。或者，像用特定的标准实现<code class="fe mj mk ml mm b"><a class="ae kf" href="https://developmentarc.gitbooks.io/react-indepth/content/life_cycle/update/using_should_component_update.html" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate()</a></code>。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="2f4e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">6.缓存查找和配置</h1><p id="aa42" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">observables最强大的特性之一是可以缓存一个HTTP请求，正如我们所知，Angular的默认HTTP请求不返回observables。</p><p id="49df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在应用程序中有大量的配置和查找，这将非常有效。</p><p id="36de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用两种链接方法实现可观测量中的缓存:</p><ul class=""><li id="4971" class="nr ns it ki b kj kk kn ko kr nt kv nu kz nv ld or nx ny nz bi translated"><code class="fe mj mk ml mm b">PublishReply()</code></li><li id="6942" class="nr ns it ki b kj oa kn ob kr oc kv od kz oe ld or nx ny nz bi translated">和<code class="fe mj mk ml mm b">RefCoun()</code></li></ul><p id="b126" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例<em class="os"> : </em></p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c75c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:缓存生存期是应用程序的生命周期，因此，当您刷新应用程序时，它将发出一个新的HTTP请求，产生一个新的响应实例。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="43bd" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">7.使用纯管道(缓存过滤值)</h1><p id="9d85" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><code class="fe mj mk ml mm b">pure</code>标志表示管道不依赖于任何全局状态，并且不会产生副作用。</p><p id="df99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着当使用相同的输入进行调用时，管道将返回相同的输出。这样，Angular可以缓存调用管道的所有输入参数的输出，并重用它们，而不必在每次评估时重新计算它们。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="63f9" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">8.使用*ngFor指令的trackBy选项</h1><p id="6e58" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">参考资料:</p><div class="mz na gp gr nb nc"><a href="https://medium.com/better-programming/improving-angular-ngfor-performance-through-trackby-ae4cf943b878" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">通过trackBy提高Angular *ngFor性能</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">了解和使用*ngFor</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="ot l nn no np nl nq jz nc"/></div></div></a></div></div></div>    
</body>
</html>