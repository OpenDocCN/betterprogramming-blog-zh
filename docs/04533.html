<html>
<head>
<title>How Fluent Interfaces Can Lead to More Meaningful Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流畅的界面如何能产生更有意义的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-fluent-interfaces-can-lead-to-more-meaningful-code-cb6d947d77bb?source=collection_archive---------11-----------------------#2020-04-20">https://betterprogramming.pub/how-fluent-interfaces-can-lead-to-more-meaningful-code-cb6d947d77bb?source=collection_archive---------11-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f95a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更简单、更安全的对象创建工作流程等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b8747464fb4d55c83344950330982f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v67IcWM5zweThGkn-zX14Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@danist07?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贝莉儿 DANIST</a> on <a class="ae ky" href="https://unsplash.com/s/photos/build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="5007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.martinfowler.com/aboutMe.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a>，他在15年前创造了术语<a class="ae ky" href="https://martinfowler.com/bliki/FluentInterface.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">流畅的界面</em> </a>，在他的著作<a class="ae ky" href="https://martinfowler.com/books/refactoring.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">重构:改进现有代码</em> </a>中写道:</p><blockquote class="lw"><p id="be2d" class="lx ly it bd lz ma mb mc md me mf lu dk translated"><em class="mg">“任何傻瓜都能写出计算机能理解的代码。优秀的程序员会写出人类能理解的代码。”</em></p></blockquote><p id="c840" class="pw-post-body-paragraph kz la it lb b lc mh ju le lf mi jx lh li mj lk ll lm mk lo lp lq ml ls lt lu im bi translated">软件开发是关于沟通的。最终的接收者可能是一个编译器或解释器，以一系列1和0的形式运行我们的代码。计算机不关心源代码的可读性，但是交流中的其他参与者关心:<em class="lv">人类</em>。</p><p id="9497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个开发者与另一个开发者的交流。或者在将来，当我们的代码看起来像是别人写的时候，我们自己也会这样。</p><p id="780a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我以前写过代码可视化表示的重要性，这篇文章将强调流畅界面的概念，以及我们如何将它整合到实例创建的代码库中。但是它也将展示使用这种特殊API风格的缺点。</p><p id="e1ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有代码示例都将使用Java或参考Java框架。但是流畅界面的一般原则也适用于任何其他语言。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="a552" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">流畅的界面</h1><p id="9b86" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">与许多其他设计模式一样，核心概念可以用一句话来概括:</p><p id="5be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fluent接口被设计成通过高度依赖方法链来模仿特定领域语言(DSL)。</p><p id="4f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在面向对象编程中，方法链是一种连续调用多个方法的方式。这允许我们以一种更流畅、更直接的方式编写代码，并减少视觉噪音。</p><p id="4c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现实际使用方法链接的能力，方法不能返回<code class="fe nq nr ns nt b">void</code>或其他任意值。它们必须为给定的上下文返回最符合逻辑的值。</p><p id="2bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三种方法可以让我们的代码更加流畅。</p><h2 id="fcc7" class="nu mu it bd mv nv nw dn mz nx ny dp nd li nz oa nf lm ob oc nh lq od oe nj of bi translated">可变的方式</h2><p id="0697" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">实例的每个setter或相关方法都会变异实例本身并返回<code class="fe nq nr ns nt b">this</code>。</p><p id="6414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种流畅的方式不适合实例创建，至少在我看来是这样。我们获得了方法链，但仅此而已。它应该保留给非POJO类型，例如工作流的流畅接口。</p><h2 id="7c40" class="nu mu it bd mv nv nw dn mz nx ny dp nd li nz oa nf lm ob oc nh lq od oe nj of bi translated">不可改变的方式</h2><p id="9a71" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">不是返回实例本身，而是返回表示变异状态的新实例。这种行为的一个典型例子是<code class="fe nq nr ns nt b"><a class="ae ky" href="https://www.oracle.com/technical-resources/articles/java/jf14-date-time.html" rel="noopener ugc nofollow" target="_blank">java.time</a></code> <a class="ae ky" href="https://www.oracle.com/technical-resources/articles/java/jf14-date-time.html" rel="noopener ugc nofollow" target="_blank"> API </a>，或<code class="fe nq nr ns nt b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html" rel="noopener ugc nofollow" target="_blank">java.math.BigDecimal</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="1bd7" class="nu mu it bd mv nv nw dn mz nx ny dp nd li nz oa nf lm ob oc nh lq od oe nj of bi translated">使用中介构建器</h2><p id="26cc" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">类型本身不一定要通顺。我们可以使用额外的fluent辅助类型来创建实例，例如fluent <a class="ae ky" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank"> builder </a>。</p><p id="0e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java中，我们可以使用构建器来解决缺少命名参数的问题。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="2fe5" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">如何创建一个流畅的生成器</h1><p id="1a9d" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">我们从描述开发人员的类型开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的POJO，只是存储一些数据，没有任何额外的功能。</p><h2 id="7ad8" class="nu mu it bd mv nv nw dn mz nx ny dp nd li nz oa nf lm ob oc nh lq od oe nj of bi translated">创建简单的构建器</h2><p id="a9ba" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">为了改进实例创建，我们需要一个额外的构建器类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="15b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">构建器模式</a>，我们仍然拥有简单的POJO类型，但是现在实例创建也可以在准备构建器和创建实际实例时进行验证。</p><h2 id="6fd3" class="nu mu it bd mv nv nw dn mz nx ny dp nd li nz oa nf lm ob oc nh lq od oe nj of bi translated">使用构建器</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="865c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fluent builder将构造和表示的代码分开。</p><p id="9197" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获得了一种更容易理解的创建实例的方法，在构建过程中有额外的控制，比如验证。特别复杂的类型可以用构建器来改进。</p><p id="a0f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以改进我们的构建器，以及相应的类型，甚至更多。</p><h2 id="fcc0" class="nu mu it bd mv nv nw dn mz nx ny dp nd li nz oa nf lm ob oc nh lq od oe nj of bi translated">用不变性改进构建器</h2><p id="9187" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">一种常用的设计是使构建器成为其对应类型的嵌套类。这也意味着放弃一个纯粹的POJO，而是获得一个不可变的类型，在我看来这是一个非常划算的交易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns nt b">Developer</code>类型现在是完全不可变的，并且只能<em class="lv">通过使用构建器</em>来创建。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="a185" class="nu mu it bd mv nv nw dn mz nx ny dp nd li nz oa nf lm ob oc nh lq od oe nj of bi translated">不可变生成器生成</h2><p id="64e2" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">老实说，这仍然需要很多额外的代码。我们需要为每一种类似POJO的类型编写它。</p><p id="1dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用像<a class="ae ky" href="https://immutables.github.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">不可变</em> </a>这样的框架，而不是自己去做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html" rel="noopener ugc nofollow" target="_blank">注释处理</a>，我们的构建器被生成以供使用，包括验证、更多的构建器方法、容易复制，以及比我们自己能做的更多的<a class="ae ky" href="https://immutables.github.io/immutable.html#features" rel="noopener ugc nofollow" target="_blank">特性</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="4b43" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">流畅的工作流界面</h1><p id="5c81" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">尽管本文主要是关于流畅的构建者，但这并不是使用流畅界面的唯一方式。它们被广泛用于任何类型的多步骤工作流。</p><p id="3fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流畅API设计的一个很好的例子是<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noopener ugc nofollow" target="_blank"> Java Streams API </a>。我们可以通过将与流相关的调用方法链接在一起，而不是使用迭代集合的“传统”方法，来减少很多冗长的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1b83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们收集了大量代码，用于获取2020年前五位科幻小说作者的名字。</p><p id="9991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用streams流畅地打这个电话:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们包括格式和括号，我们设法将20行代码减少到大约10行。</p><p id="2bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">减少杂乱是伟大的，但在我看来，更重要的是提高可理解性。流操作的简洁名称清楚地传达了它们的意图。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="d295" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结论</h1><p id="1efc" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">流畅的界面很适合消费，但不适合创作。</p><p id="c608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个更像DSL的API有助于开发人员使用更简洁、更容易理解的代码。</p><p id="b873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以更好地控制如何创建一个对象，甚至可以将它分成多个步骤。验证可以集成在每一步中。这有助于将用于创建的代码从实际的表示中分离出来。</p><p id="a5a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是创建一个令人愉快、流畅的API并不是一件容易的事情。我们需要额外的辅助类型，这意味着大量额外的、经常重复的代码。</p><p id="b519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个缺点是可能产生更多的运行时错误。如果我们的类型需要构造函数中所有需要的参数，我们会直接看到需要什么。对于构建器，我们可能会错过它们，直到运行时才会意识到。</p><p id="9b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的IDE不支持链中不同点的断点，调试也会更加困难。这通常可以通过将链分成多行来解决，这同时也提高了可读性。</p><p id="7926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的公司，我们去年开始使用fluent builder，这要感谢<em class="lv"> Immutables </em>框架。我们开始只对新类型使用它，但随着时间的推移，如果合适的话，也会替换旧类型。</p><p id="a98a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，将不可变类型集成到现有代码中并不容易，但这给了我们一个重新评估我们的API设计并对其进行改进的机会。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="333d" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">资源</h1><ul class=""><li id="cbfe" class="oi oj it lb b lc nl lf nm li ok lm ol lq om lu on oo op oq bi translated">流体界面(马丁·福勒)</li><li id="0add" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank">流畅的界面</a>(维基百科)</li><li id="d26d" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://immutables.github.io/" rel="noopener ugc nofollow" target="_blank">一成不变的框架</a></li><li id="9b0d" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://www.vogella.com/tutorials/DesignPatternBuilder/article.html" rel="noopener ugc nofollow" target="_blank">在Java 8中实现构建器模式</a> (Vogella)</li><li id="171d" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">【Java函数式编程:不变性</li><li id="341d" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">【Java函数式编程:流</li><li id="f254" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://codeburst.io/signal-to-noise-ratio-a45ae45c3545" rel="noopener" target="_blank">信噪比:突发码</a></li></ul></div></div>    
</body>
</html>