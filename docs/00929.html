<html>
<head>
<title>Integration Tests in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的集成测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/integration-tests-in-node-js-f44a389a4144?source=collection_archive---------3-----------------------#2019-07-29">https://betterprogramming.pub/integration-tests-in-node-js-f44a389a4144?source=collection_archive---------3-----------------------#2019-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ab2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">讨论Mocha运行集成测试的基本设置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a58687f12bee288f723ccd6eca267ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*hhdKNu0Kx5pHA_7f.png"/></div></figure><p id="5ba0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在上一篇文章中，我写了单元测试的重要性以及它如何改进我们的代码库。</p><p id="d5c7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是，如果您想获得更多的安全性，并在一个<a class="ae lm" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>应用程序中编写集成测试，该怎么办呢？在这篇文章中，我将讨论<a class="ae lm" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>运行集成测试的基本设置。</p><p id="98d5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在创作这个作品的例子时，我把注意力集中在我的一个项目中的问题上。在这个项目中，我们有一个很大的REST API应用程序，它几乎没有任何测试。</p><p id="327a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，有一个重要的界面，之前的一个开发人员认为测试它很重要，因为这对客户的公司不倒闭至关重要。</p><p id="bcb1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果发生其他事故，我们并不太担心，但这次事故几乎是世界末日。</p><p id="2d67" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的测试设置远非完美。问题是测试在真实的数据库上运行，并在其上创建真实的项目。这些项目需要通过清理过程移除。</p><p id="2f36" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">清理经常失败，然后这个产品因为违反约束而在下一次测试运行中崩溃。我们需要手动删除该产品。</p><p id="9ff6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦测试项以某种方式在生产数据库上被创建，并且每天被复制到测试环境中，我们就不能删除它，因为我们不能访问它。</p><p id="8f0d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最终，我们感到无聊，并在挂钩前添加了清理功能。这是非常不必要的，在测试运行之间，我们仍然在数据库中有测试项。</p><p id="8e7c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为我的同事说句公道话，当我试图在Node.js中查找关于集成测试的信息时，几乎所有人都在谈论在工作的服务器应用程序上调用API路由并断言结果。</p><p id="85de" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这很好，但是从我的经验来看，这些测试很难维护，因为它们测试整个路线，这可能相当复杂。此外，它们运行在真实的数据库上，因此，如果您有静态数据集，它们就会过时，无论是在测试中还是在数据库中。</p><p id="da6a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">也很容易忘记它们，然后你突然意识到，在发布前两天，一半的测试失败了，因为开发人员没有通过长期运行的集成测试来运行一个小的bug修复。</p><p id="c6df" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在解决这个问题时，我们还考虑了一个单独的测试数据库实例，它包含静态数据或者位于内存数据库中。我们把那些想法扔进了垃圾箱，因为维护数据是不可能的。</p><p id="beb3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，在这一点上，我们放弃了创建更好的测试套件的所有机会。界面非常复杂，而且没有考虑到测试。</p><p id="12d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不过，不要担心。这篇文章不是关于我们对完整测试范围失去的希望。</p><p id="b827" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我开始一个不同的项目时，我被要求编写一些关于DAOs(数据访问对象)的集成测试。测试配置已经创建，所以我只写了一些测试用例和断言。</p><p id="f843" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我开始测试时，我惊讶地发现在每个测试用例之后，测试框架都回滚了整个事务。当我检查数据库时，我发现没有任何测试数据真正写在那里。</p><p id="c9d1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我的思绪被吹走了。如此简单而优雅的解决方案。您可以使用最新的数据在任何处于最新状态的数据库上运行测试。我很好奇在Node.js中实现这样的解决方案会有多难。</p><p id="c5ae" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以，我用<a class="ae lm" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>创建了一个示例项目。</p><p id="54f2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是一个存储书籍的简单应用程序。每本书都有名字和标题。API通过图书模型路由访问数据，图书模型有一些基本的查询来创建或返回数据。</p><p id="ee79" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">数据存储在一个<a class="ae lm" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>数据库中，可以通过MySQL <a class="ae lm" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>包访问该数据库。如果您使用不同的数据库或软件包，您可能需要调整这个解决方案。</p><p id="5e20" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">废话够多了，我们来编码吧！</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="1129" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">编码</h1><p id="a46f" class="pw-post-body-paragraph kq kr it ks b kt mm ju kv kw mn jx ky kz mo lb lc ld mp lf lg lh mq lj lk ll im bi translated">首先，我们需要一个<code class="fe mr ms mt mu b">util</code>类来与数据库通信。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4392" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如你所见，我们有两种方法。一个用于连接数据库，另一个用于运行查询。我们通过构造函数发送连接配置。</p><p id="e6ba" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在<code class="fe mr ms mt mu b">connect</code>中，我们连接到数据库并遍历原型中的所有方法。我们用<code class="fe mr ms mt mu b">util.promisify</code>包装它们，这样我们就可以使用<code class="fe mr ms mt mu b">async</code><code class="fe mr ms mt mu b">await</code>(MySQL包支持回调，我不想经历那个地狱)。</p><p id="100b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">查询方法连接到<code class="fe mr ms mt mu b">db</code>(如果它尚未连接)并在其上运行查询。</p><p id="9fbe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以，当我们有了数据库接口，我们就可以开始写模型了。如你所见，那里没有什么有趣的东西。唯一要提到的是，我特意创建了<code class="fe mr ms mt mu b">createAll</code>方法，因此它在一个事务中运行多个查询。</p><p id="0560" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这个方法中，我们将尝试演示测试在一个事务中运行多个查询的方法的可能性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="47c8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还需要知道数据库的初始状态。我在表<em class="mx"> books </em>中创建了两本书，如下表所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0bf6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们拥有一切—我们可以测试！</p><p id="5e44" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为测试跑者，我选择了摩卡，但它会与其他跑者相似。这些是我的测试案例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2a64" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我知道这些测试测试不多，在现实世界中，您可能还会测试返回的数据。</p><p id="cab8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是，这个测试用例测试的正是我们想要的——<code class="fe mr ms mt mu b">db</code>的初始状态对于每个测试都应该是相同的。</p><p id="338d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您按照这个顺序运行这些测试用例，您可以看到，在第一次测试运行之后，将会有三本书，在删除一本之后，将会有两本。然后，有了两本新书，就变成了四本，最后又变成了四本。</p><p id="878c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你把它和断言比较，你会发现我们期望不同的值。</p><p id="2ead" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您以前做过一些测试，您就会知道我们需要稍微改变一下数据库连接器。如果您查看MySQL的文档，您会发现运行事务非常简单。</p><p id="e4c7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在创建连接之后，您需要在连接上调用<code class="fe mr ms mt mu b">beginTransaction</code>,这样就完成了。</p><p id="94eb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我们需要这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ecb2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你没有看过<code class="fe mr ms mt mu b">method.call(this, …)</code>，你可以在<a class="ae lm" href="https://www.w3schools.com/js/js_function_call.asp" rel="noopener ugc nofollow" target="_blank"> w3schools </a>了解更多。简而言之，它为给定的函数调用设置上下文。</p><p id="a10c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以，我们在这里做的是调用一个父方法(原始实现)，并说这被设置为一个<code class="fe mr ms mt mu b">mockedDb</code>的实例。</p><p id="4742" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mr ms mt mu b">MockedDb</code>将所有数据库通信设置在一个事务中。然后，我们可以添加在每次运行后回滚事务的<code class="fe mr ms mt mu b">afterEach</code>钩子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="08b4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就是这样！开个玩笑……如果你仔细读过，你会记得我们有使用事务和调用的<code class="fe mr ms mt mu b">createdAll</code>。</p><p id="910e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将导致<code class="fe mr ms mt mu b">“should return 4 books in create many tries to create 2 books”</code>，这将真正提交事务，它将破坏我们数据库中的数据。</p><p id="99b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了让这种痛苦消失，我们需要在连接上存根<code class="fe mr ms mt mu b">commit</code>方法、<code class="fe mr ms mt mu b">rollback</code>方法和<code class="fe mr ms mt mu b">beginTransaction</code>。</p><p id="c80a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这就是当我们在实现中调用这些方法时，数据库上不会发生任何事情的原因。</p><p id="d65b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的<code class="fe mr ms mt mu b">MockedDb</code>类将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="388a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您需要测试<code class="fe mr ms mt mu b">commit</code>或<code class="fe mr ms mt mu b">rollback</code>，您可以使用<a class="ae lm" href="https://sinonjs.org" rel="noopener ugc nofollow" target="_blank"> Sinon </a>来存根该方法，然后在它被调用时断言它。您可能还需要在回滚时断言它，或者拥有在提交或回滚事务时创建新事务的方法。</p><p id="ae6b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个精确的解决方案不会减轻您的头痛，您将需要调整这些存根来满足您的要求。然而，如果你有一个简单的模型，你可以很容易地接受这个设置，并且知道不会有任何东西写入数据库。</p><p id="5132" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可以在我的<a class="ae lm" href="https://github.com/rochus222/integration-tests-nodejs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到整个项目。</p><p id="7ba7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我希望你喜欢这篇文章。</p><p id="4ec6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">干杯！</p></div></div>    
</body>
</html>