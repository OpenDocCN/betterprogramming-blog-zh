<html>
<head>
<title>Refactoring PyPDF2’s Transformation Interface</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构PyPDF2的转换接口</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/refactoring-pypdf2s-transformation-interface-34db1c1c2fae?source=collection_archive---------9-----------------------#2022-06-21">https://betterprogramming.pub/refactoring-pypdf2s-transformation-interface-34db1c1c2fae?source=collection_archive---------9-----------------------#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a5e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个更容易维护的系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/95085a2f965bea94267a24a5406c0dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEUBi6bJERHeHX-9GD9Z4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Internal_hub_3_speed_Shimano.jpg" rel="noopener ugc nofollow" target="_blank">维基共享</a>(西尔斯体育中心，公共领域)</p></figure><p id="f7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢写好的软件。可靠的、用户直观理解的、易于维护的软件。学习和教授好的软件是什么样子是超级辛苦的，但我希望用这篇文章植入一些想法。</p><p id="751a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读完这篇文章后，你将会学到好软件的两个方面以及一个设计模式。</p><h1 id="3d80" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">PyPDF是什么？</h1><p id="dc6a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">PyPDF2是一个免费的开源纯python PDF库，能够拆分、合并、裁剪和转换PDF文件的页面。它还可以向PDF文件添加自定义数据、查看选项和密码。PyPDF2也可以从PDF中检索文本和元数据。</p><p id="8872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2011-2016年积极研制。它适用于许多用例，因此Python社区仍然大量使用该库——尽管它直到2022年才得到任何更新。2022年4月，我成为PyPDF2的维护者。</p><p id="6ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyPDF2是PyPDF的一个分支——一个更老的项目。PyPDF2的开发者总是希望保持向后兼容性。我不觉得有这个必要。如果我认为破坏兼容性对整个项目有利，我会这样做。</p><h1 id="a68f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对稳定界面的需求</h1><p id="2163" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接口是系统的边界。它允许用户与之互动。这些用户本身可能就是开发人员。用户不应该需要了解系统的内部机制。</p><p id="2425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">汽车修理工可以成为司机——但你不一定要成为一名机械师才能开车。公共接口是方向盘、油门踏板、刹车和其他一些东西。专用接口是用于汽车电子元件的内部CAN总线，以及定义使用哪些档位的标准。</p><blockquote class="ms"><p id="6832" class="mt mu it bd mv mw mx my mz na nb lu dk translated">用户期望界面保持稳定——或者当它们改变时至少有一个明确的声明。</p></blockquote><p id="615f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这意味着你可能需要支持你几年前做出的次优决定。在某些情况下，很多年——想想Python 2或者美国仍然使用英制单位的事实。</p><h1 id="ba53" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对小界面的需求</h1><p id="4ecb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">维护者想要小接口:公共接口越大，开发者需要支持的就越多。它更容易出现错误和不一致。</p><p id="569c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是用户也从小界面中获益:发现的东西更少，而且希望只有一种方法可以做他们想做的事情。消除重复使得使用同一个库的代码更加一致。</p><h1 id="edec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">界面蠕变</h1><p id="b932" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">任何开发人员都很难对一个特性请求说“不”，尤其是当它很容易实现的时候。我们想让人们快乐。只是在这里添加一个参数或者在那里添加一个新的方便函数/类/方法不会有什么坏处，对吗？</p><p id="1d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你如何得到臃肿的界面。我已经简要地指出了为什么你想要小界面。如果软件使用定义良好的接口，您可以猜测函数名和参数的名称/顺序。你可以看到用来设计它的模式。</p><h1 id="ee74" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">PDF转换</h1><p id="67a8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">考虑您可能想要对PDF页面进行的转换。旋转，移动，缩放，裁剪，将一个PDF叠加到另一个PDF上。你能想到的可能还有很多，但这五个是我们目前关注的。</p><p id="1b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyPDF2 <code class="fe nh ni nj nk b">PageObject</code>类有以下方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="eaad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下这八种方法中我们不喜欢的地方:</p><ol class=""><li id="8bde" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">不符合PEP-8:我首先想到的是不遵循预期的命名方案。可能是我最不在乎的一个，但也是最明显的一个。</li><li id="56bf" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">提供不止一种方式:<code class="fe nh ni nj nk b">mergeRotatedTranslatedPage</code>可以旋转和平移——那么我们为什么需要<code class="fe nh ni nj nk b">mergeRotatedPage</code>？<code class="fe nh ni nj nk b">mergeRotatedScaledTranslatedPage</code>似乎能做所有的变换。我们还需要其他人吗？</li><li id="a668" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">结果的不确定性:假设你想做两个操作。(a)您想要将图像旋转90度,( b)将其向右移动10厘米。先做(a)再做(b)与反过来不同，假设旋转中心是相对于画布的。</li></ol><h1 id="3c1f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">想法1:使用带有多个参数的单一方法</h1><p id="257f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我可以只用<code class="fe nh ni nj nk b">mergeRotatedScaledTranslatedPage</code>,其他的都弃用。</p><p id="420b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有一个很大的缺点:操作的顺序很重要！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/06d3da2019fd59b4faac38ff78804af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*giDMgUJk1hhnhGz_b315Jg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运算的顺序很重要:如果坐标系的中心在红点，你(1)将页面上的图形向右移动(2)旋转180度，你会得到不同的结果。图片由马丁·托马斯提供。</p></figure><h1 id="538b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">想法2:拆分、合并和转换</h1><p id="2c2f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上面提到的方法有一个非常明显的缺点:如果你想只做其中一个操作而不与另一个页面合并，你就做不到。因此，有三个方法直接在页面上操作，一个方法进行合并是有意义的:</p><pre class="kj kk kl km gt oc nk od oe aw of bi"><span id="e19b" class="og lw it nk b gy oh oi l oj ok">class PageObject:<br/>    def merge_page(self, page2, expand=True): ...</span><span id="5e04" class="og lw it nk b gy ol oi l oj ok">    def scale(self, scale, expand=True): ...<br/>    def rotate(self, rotation, expand=True): ...<br/>    def translate(self, tx, ty, expand=True): ...</span></pre><p id="cc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可以独立地应用操作和合并，以任何你想要的顺序。</p><h1 id="71d0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">想法3:创建一个转换构建器</h1><p id="bf52" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果合并两个有许多页面的文档，您可能会反复执行相同的操作。所有这三种操作都用矩阵来表示。一个接一个地执行它们是一个矩阵乘法。因此，当你有100页，你做一个旋转，缩放操作，和一个转换，这将做100 x 3矩阵乘法或300矩阵乘法。</p><p id="01eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你第一次把组合运算表示成一个矩阵时，你需要做两次矩阵乘法。之后，你有100个矩阵乘法。总共102次矩阵乘法。</p><p id="5064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想法二的另一个特性是，你不能有一个流畅的界面:这些操作应该就地发生，因为复制一个页面可能是一个相当繁重的操作。所以<code class="fe nh ni nj nk b">page.scale</code>操作应该返回<code class="fe nh ni nj nk b">None</code>。这意味着你不能做<code class="fe nh ni nj nk b">page.scale(2).rotate(180)</code>。</p><p id="9db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了消除这个缺点，我们添加了一个转换对象:</p><pre class="kj kk kl km gt oc nk od oe aw of bi"><span id="8bd6" class="og lw it nk b gy oh oi l oj ok">class Transformation:<br/>    def scale(self, sx, sy) -&gt; Transformation: ...<br/>    def rotate(self, degree) -&gt; Transformation: ...<br/>    def translate(self, tx, ty) -&gt; Transformation: ...</span><span id="c694" class="og lw it nk b gy ol oi l oj ok">class PageObject:<br/>    def merge_page(self, page2, expand=True): ...<br/>    def transform(self, transformation): ...</span></pre><p id="36a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是构建器模式:<code class="fe nh ni nj nk b"><a class="ae ky" href="https://pypdf2.readthedocs.io/en/latest/modules/Transformation.html" rel="noopener ugc nofollow" target="_blank">Transformation</a></code>类封装了用户想要应用的<code class="fe nh ni nj nk b">transformation</code>，并帮助他们创建矩阵。<code class="fe nh ni nj nk b">transformation</code>矩阵是PDF格式和PyPDF2实际需要的，但是对PyPDF2用户是隐藏的。用户只需使用<code class="fe nh ni nj nk b">Transformation</code>构建器类:</p><pre class="kj kk kl km gt oc nk od oe aw of bi"><span id="1e73" class="og lw it nk b gy oh oi l oj ok">transformation = Transformation().scale(2).rotate(180)</span></pre><p id="b737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe nh ni nj nk b">transformation</code>类保存的数据很少，我们可以使它不可变，并且总是返回一个副本。这使得流畅的界面成为可能。具有自动完成功能的现代ide现在可以告诉用户他们可以做哪些操作。由于<code class="fe nh ni nj nk b">PageObject</code>的方法更少，所以更容易测试，用户也更容易发现他们需要什么。</p><h1 id="cc7f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="bfeb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您已经看到了如何应用builder模式来实现流畅的界面，并将核心对象的公共方法从八个减少到两个。同时，用户变得更加灵活，测试变得更加容易。</p><p id="527f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您已经注意到，可维护性和用户需求有时是密切相关的。小巧且定义良好的界面只是让每个人的生活更轻松。</p></div></div>    
</body>
</html>