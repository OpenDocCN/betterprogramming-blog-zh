<html>
<head>
<title>Generator Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的生成器函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/generator-functions-in-javascript-571ba4cda69e?source=collection_archive---------16-----------------------#2020-03-31">https://betterprogramming.pub/generator-functions-in-javascript-571ba4cda69e?source=collection_archive---------16-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f98c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一直等到准备好继续的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f4c3a28637520f3c4d6d2a8fe20104a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-HFCdKSrA6dhlyN66g1uw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马修·费尼在<a class="ae ky" href="https://unsplash.com/s/photos/wait?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c8a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES6中，EcmaScript发布了一种处理函数的新方法。在本文中，我们将看看它们，以及如何以及在什么地方使用它们</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="13a9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">什么是发电机功能？</strong></h1><p id="14ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">生成器函数是一种特殊类型的函数，允许您暂停它们的执行，以便以后随时恢复它们。</p><p id="34e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们也简化了迭代器的创建，但是我们将在后面讨论。让我们先简单地通过一些例子来了解它们是什么。</p><p id="a097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个生成器函数很简单。<code class="fe mz na nb nc b">function*</code>声明(<code class="fe mz na nb nc b">function</code>关键字后跟一个星号)定义了一个生成器函数。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="337e" class="nh md it nc b gy ni nj l nk nl">function* generatorFunction() {<br/>   yield 1;<br/>}</span></pre><p id="9095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在生成器函数中，我们不使用返回语句，而是使用一个<code class="fe mz na nb nc b">yield</code>来指定从迭代器返回的值。现在，在上面的例子中，它将返回值1。</p><p id="e741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们像普通的ES6函数一样调用生成器函数时，它并不直接执行函数，而是返回一个<code class="fe mz na nb nc b">Generator</code>对象。</p><p id="2607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Generator</code>对象包含<code class="fe mz na nb nc b">next()</code>、<code class="fe mz na nb nc b">return</code>和<code class="fe mz na nb nc b">throw</code>，它们可以用来与我们的生成器函数进行交互。它的工作原理与<code class="fe mz na nb nc b">iterator</code>类似，但你对它有更多的控制权。</p><p id="afd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过一个例子来看看如何使用<code class="fe mz na nb nc b">generatorFunction</code>。现在，正如我之前告诉你的，我们得到了<code class="fe mz na nb nc b">next()</code>。</p><p id="2b83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">next()</code>方法返回一个具有两个属性的对象，<code class="fe mz na nb nc b">done</code>和<code class="fe mz na nb nc b">value</code>。您还可以向<code class="fe mz na nb nc b">next</code>方法提供一个参数，以便向生成器发送一个值。让我们看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/139000783e78782bcfdfa1e3abae28ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*CuDQhYcZ3xLZKvFTosFFrg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对生成器函数调用next后的输出</p></figure><p id="2004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，正如我前面所说的，我们也可以通过<code class="fe mz na nb nc b">next</code>将值传递给生成器函数，该值可以在<code class="fe mz na nb nc b">generator</code>函数中使用。让我们看看另一个例子是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e539d32320d6410ae68fe4b1785b758d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*ywIGvmfO_r3j0rTdccplEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过next将值传递给生成器函数</p></figure><p id="be60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，当您获得生成器时，您没有可以将值推送到的<code class="fe mz na nb nc b">yield</code>。所以，首先你必须通过调用生成器上的next来达到一个收益。它会一直返回<code class="fe mz na nb nc b">null</code>。</p><p id="30b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以传递参数或者不传递参数，这都没有关系，它总是会返回<code class="fe mz na nb nc b">null</code>。一旦你这样做了，你就有了一个<code class="fe mz na nb nc b">yield</code>，你可以通过<code class="fe mz na nb nc b">iterator.next()</code>推送你的值，这将有效地用通过<code class="fe mz na nb nc b">next</code>传递的输入代替<code class="fe mz na nb nc b">yield null</code>。</p><p id="60fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当它找到另一个<code class="fe mz na nb nc b">yield</code>时，它返回给生成器的消费者，也就是我们这里的<code class="fe mz na nb nc b">iterator</code>。</p><p id="1c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们来简单谈谈<code class="fe mz na nb nc b">yield</code>关键词。它看起来像return一样工作，但却很强大，因为return只是在函数被调用后从函数中返回一个值。</p><p id="a724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它也不允许你在普通函数中的<code class="fe mz na nb nc b">return</code>关键字之后做任何事情，但是在我们的例子中，<code class="fe mz na nb nc b">yield</code>做的远不止这些。它返回一个值，但是当你再次调用它时，它将移动到下一个<code class="fe mz na nb nc b">yield</code>语句。</p><p id="cc1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">yield</code>关键字用于暂停和恢复发生器功能。<code class="fe mz na nb nc b">yield</code>返回一个对象，它包含一个<code class="fe mz na nb nc b">value</code>和<code class="fe mz na nb nc b">done</code>。</p><p id="3938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">value</code>是对生成器函数求值的结果，<code class="fe mz na nb nc b">done</code>表示我们的生成器函数是否已经完全完成，其值可以是<code class="fe mz na nb nc b">true</code>或<code class="fe mz na nb nc b">false</code>。</p><p id="9c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在生成器函数中使用<code class="fe mz na nb nc b">return</code>关键字，它将返回相同的对象，但不会再进一步，并且永远不会到达<code class="fe mz na nb nc b">return</code>之后的代码，即使在那之后有六个<code class="fe mz na nb nc b">yield</code>。</p><p id="64ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，使用<code class="fe mz na nb nc b">return</code>时你需要非常小心，并且只有在你确定发生器功能的工作已经完成时才能使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="195e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成器功能的使用</h1><p id="65d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，生成器函数可以非常容易地简化迭代器的创建、递归的实现和更好的异步功能。让我们看一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/795e416f4c4cd40bcdf5c96123e2d3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVzFY7yj2GwKBQUKbnhkug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计数无穷大示例</p></figure><p id="5af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，这是一个无限循环，但是它只会被执行我们在迭代器上调用<code class="fe mz na nb nc b">next</code>的次数，因为它保留了它继续计数的函数的先前状态。</p><p id="b28a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个非常基本的例子，说明了如何使用它，但我们可以在生成器函数中使用更复杂的逻辑，从而提供更多的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/423be2f72f97bac60ca38884506e052a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOMv0GIOFyRWOqhFMSxgMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斐波那契数列示例</p></figure><p id="def9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们实现了一个没有任何递归的斐波那契数列。生成器功能真的很强大，只是受限于你自己的想象。</p><p id="69b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器函数的另一个很大的优势是它们确实是内存高效的。我们创造所需的价值。</p><p id="26a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个普通函数的例子中，我们生成了很多值，甚至不知道我们是否会用到它们。然而，对于生成器函数，我们可以推迟计算，只在需要的时候使用它。</p><p id="a692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用生成器功能之前，请记住一些事情。如果已经访问了某个值，则不能再次访问该值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="19b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="dfff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">迭代器函数是在JavaScript中做很多事情的一种非常好且有效的方式。使用生成器函数还有许多其他可能的方法。</p><p id="b106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，使用异步操作可以变得容易。由于生成函数可以随着时间的推移发出许多值，所以它也可以用作可观测值。</p><p id="eea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助你了解一些关于<code class="fe mz na nb nc b">generator</code>函数的知识，并让我知道你还能用<code class="fe mz na nb nc b">generator</code>函数做些什么。</p></div></div>    
</body>
</html>