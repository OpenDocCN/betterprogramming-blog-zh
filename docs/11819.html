<html>
<head>
<title>5 Anti Patterns to Avoid When Writing Code in a Functional Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用函数式编程语言编写代码时要避免的5种反模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-anti-patterns-to-avoid-when-writing-code-in-a-functional-programming-language-a354418b1844?source=collection_archive---------15-----------------------#2022-04-19">https://betterprogramming.pub/5-anti-patterns-to-avoid-when-writing-code-in-a-functional-programming-language-a354418b1844?source=collection_archive---------15-----------------------#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6828" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Scala的用例示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/addb76f63dbd7d044eab38583df1e7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WTTnvvr2meiLZy87"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几年里，函数式编程语言获得了极大的发展。</p><p id="4486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多人可以看到编写包含诸如作为一等公民的功能的代码的好处。他们在并发环境中拥抱不变性，运行繁重的计算任务而不用担心一些并发问题，并且喜欢编写尽可能简洁的通用代码。</p><p id="f7c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这是函数式编程语言再次成为主流的好迹象。然而，用函数式编程语言编写代码的难点之一是它的设计模式和反模式，它们不同于常规的编程语言。</p><p id="3ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我经常看到工程师编写大型代码库，我将他们归类为反模式。当我最初用函数式编程语言编写生产就绪的应用程序时，我也致力于这些反模式。从那以后，我阅读了许多关于函数式编程设计模式的书籍，这些书籍帮助我创建了更易维护的代码。</p><h1 id="0fb8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">过度嵌套的匿名回调函数。</h1><p id="1541" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">匿名函数有利于代码的可重用性。然而，过多的匿名功能会伤害那些想要扩展功能的工程师的眼睛。尽管DRY是一条可行之路，但有时候复制比错误的抽象要好。</p><p id="34e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我接触过代码库，在那里工程师将编写一个非常简洁和抽象的方法。代码是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">能告诉我<code class="fe mu mv mw mx b">buildRunner</code>的定义是什么吗？</p><p id="154e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，这个<code class="fe mu mv mw mx b">buildRunner</code>用于支付处理器中的所有动作操作，如授权、捕获和作废。我看了它两天，终于明白它想做什么。</p><p id="afa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得你写的所有函数的摘要尽可能的干巴巴。然而，对于普通的工程师来说，拥有一个嵌套的匿名回调来构建一个新的特性或者维护它是很困难的。大多数工程师需要几天的时间来理解<code class="fe mu mv mw mx b">buildRunner</code>试图做什么。</p><p id="e0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程的好处是，你可以查看函数签名，并立即知道它试图做什么。然而，这个函数并没有解释它是做什么的。这让试图改变代码库的工程师更加困惑。</p><p id="2c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，一个好的经验法则是不使用匿名函数是可能的。相反，使用高阶函数。</p><p id="a6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想使用匿名功能，请在顶部加一个<code class="fe mu mv mw mx b">type</code>以便于阅读。http4s 通过包装其类型输入<code class="fe mu mv mw mx b">Kleisli</code>在内部完成这项工作。<code class="fe mu mv mw mx b">Kleisli</code>本身就是一个匿名函数，也就是<code class="fe mu mv mw mx b">A =&gt; F[B]</code>。然而，用<code class="fe mu mv mw mx b">type</code>定义包装匿名函数有助于代码库的可读性。</p><h1 id="9612" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模式匹配到极致</h1><p id="431f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">关于在函数式编程中编写代码的好处，我们首先了解到的是模式匹配特性——它消除了我们在通用编程语言中经常使用的难看的if-else语句。</p><p id="5b38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只有一个短代码，模式匹配是很好的。当你有两层以上的<a class="ae ky" href="https://www.bmc.com/blogs/callback-hell/" rel="noopener ugc nofollow" target="_blank">模式匹配</a>时，事情变得更像一个回调地狱。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，不熟悉使用函数式编程语言编写代码的工程师不知道该语言提供了多少内置的高阶函数。因此，它们通过模式匹配和递归函数来默认它们的函数实现。</p><p id="9410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数实现中使用嵌套的case表达式和递归实现会导致代码难以阅读和理解。在PR注释中花费很长时间，如果实现中有bug的话，就更难找到了。</p><p id="5b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写嵌套模式匹配case语句的一个解决方案是只关心成功案例，而将错误场景留在函数实现之外。此外，如果可能，使用库或语言提供的内置高阶函数、<code class="fe mu mv mw mx b">map</code>和<code class="fe mu mv mw mx b">flatMap</code>。它为您的代码库提供了更好的人机工程学，并且您可以立即识别出错误在哪里被处理。</p><p id="08cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数定义中表达类型的美妙之处在于，函数实现不再需要处理所有的错误情况——类型系统可以将这些错误情况传播给调用者——强制函数在堆栈中处理这些错误。</p><h1 id="e471" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在界面上使用Monad转换器</h1><p id="2216" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">遇到嵌套效果时使用Monad Transformer非常有用。在上面的场景中，Monad Transformer是解决严重嵌套效果的另一个解决方案——它有助于使您的API可组合。然而，我们不应该将Monad Transformer暴露在接口上，因为这会使我们的API与特定的Monad Transformer紧密相关。</p><p id="e8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来举一个更具体的例子。下面的界面可以是<code class="fe mu mv mw mx b">Future[Either[Throwable, String]]</code>而不是<code class="fe mu mv mw mx b">EitherT[Future, Throwable, String]</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有想要使用<code class="fe mu mv mw mx b">someFunction</code>作为API的函数也需要使用<code class="fe mu mv mw mx b">EitherT</code>。</p><p id="290e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它是一系列函数，并且我们看到一些函数返回一个<code class="fe mu mv mw mx b">OptionT</code>呢？</p><p id="ad6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将需要调用几次<code class="fe mu mv mw mx b">value</code>来返回到我们的效果<code class="fe mu mv mw mx b">Future</code>，不必要的包装。</p><p id="c5bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们应该让<code class="fe mu mv mw mx b">someFunction</code>返回一个<code class="fe mu mv mw mx b">Future[Either[Throwable, String]]</code>，并让effect检测您在程序中需要什么约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，拥有最纯粹的效果形式比monad转换器更好，因为它不会锁定使用API的服务来使用monad转换器。</p><h1 id="9805" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在API上返回布尔值</h1><p id="90af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">许多API可能会返回一个布尔值来表示一种逻辑或另一种逻辑。取自Scala 中<a class="ae ky" href="https://www.google.com/search?q=parctical+fp&amp;%0Aoq=parctical+fp&amp;aqs=chrome..69i57j0i13j46i13j0i13l5j0i22i30l2.4661j1j1&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank">实用Fp的经典例子是<code class="fe mu mv mw mx b">filter</code>函数。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一下函数定义,‘filter’实际上是做什么的？</p><p id="0ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果谓词评估为<code class="fe mu mv mw mx b">true</code>，它将丢弃列表中的元素。另一方面，这也意味着如果谓词的计算结果为<code class="fe mu mv mw mx b">true</code>，它将保留列表中的元素。</p><p id="dd28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是模糊的。</p><p id="d89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala中还有<code class="fe mu mv mw mx b">filterNot</code>，函数定义相同，但名称不同。我经常看到许多错误发生在这两个函数中，因为工程师们关注这两个函数之间的差异。</p><p id="eec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过用有意义的值包装谓词的ADT(代数数据类型)来改进这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4c56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个ADT帮助我们创建一个更具体的函数签名，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ff97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论谁使用这个函数，都会知道他们是想保留这个元素还是丢弃它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决filter类的这个问题，你可以从scala List trait中创建一个扩展方法<code class="fe mu mv mw mx b">filterBy</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免布尔值混淆的关键是使用ADT给出有意义的值，并用ADT扩展这些函数。尽管如此，这会导致更多的样板文件，但是您在构建应用程序时会遇到更少的混乱和错误。</p><p id="b930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用ADT包装所有返回的布尔型API可能有些过分。因此，您可以在关键组件中用ADT包装布尔返回的API，并在应用程序的其余部分中保持灵活性。这是与你的团队成员达成一致的问题。</p><h1 id="95a6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在你的特性中使用通用数据结构</h1><p id="306a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这种说法可能会引起争议，因为在常规的软件工程实践中，接口应该尽可能地通用，以便可扩展。这在理论上听起来很棒，但在实践中却不行。</p><p id="4731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是<code class="fe mu mv mw mx b">Seq</code>——Scala标准库中定义的通用表示。很一般的是<code class="fe mu mv mw mx b">List</code>、<code class="fe mu mv mw mx b">Vector</code>、<code class="fe mu mv mw mx b">Stream</code>都是从<code class="fe mu mv mw mx b">Seq</code>延伸出来的。这是一个问题，因为这些数据结构的行为各不相同。</p><p id="7524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们有一个返回<code class="fe mu mv mw mx b">Future[Seq[String]]</code>的特征:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些工程师会调用函数<code class="fe mu mv mw mx b">fetchAll</code>，用<code class="fe mu mv mw mx b">toList</code>函数把<code class="fe mu mv mw mx b">Seq</code>转换成<code class="fe mu mv mw mx b">List</code>。</p><p id="c34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么知道打<code class="fe mu mv mw mx b">toList</code>是安全的？解释器可能将<code class="fe mu mv mw mx b">Seq</code>定义为<code class="fe mu mv mw mx b">Stream</code>，在这种情况下，它将具有不同的语义，并且可能在调用者端抛出异常。</p><p id="598f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了减少调用者方面的惊喜，最好根据应用程序的目标和性能定义一个更具体的类型，比如<code class="fe mu mv mw mx b">List</code>、<code class="fe mu mv mw mx b">Vector</code>、<code class="fe mu mv mw mx b">Stream</code>。</p><h1 id="83dd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="4ec4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这些反模式的问题在于，它不是泛型编程语言中的反模式。</p><p id="ef45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们被教导写抽象是好的，它让你的代码库保持干燥。然而，过度嵌套的匿名回调函数可能很难阅读。解决这个问题的最好方法是复制代码以增加可读性。返回布尔值的API可能不是问题，它存在于许多API设计和应用程序中。然而，实现一个返回布尔值的API并不能清楚地说明这些布尔值是什么意思。此外，人的思维经常会忽略文档中的小细节，这可能会导致实现中的错误。</p><p id="e422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式匹配是函数式编程语言中的一个强大特性，但它过于一般化。如果你能找到一个更好的高阶函数来实现这个函数，你应该用它来代替。</p><p id="871d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过于通用的数据结构会增加API使用的模糊性。因此，最好创建一个更具体的类型，并使函数声明对调用方尽可能清晰。</p><p id="58e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您在用函数式编程语言编写代码时避免这种反模式。你认为这些是反模式吗？在用函数式编程语言编写代码时，你能想到的另一个反模式是什么？请在下面评论它们，这样我也可以向它们学习！</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="b3f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nf">最初发表于</em><a class="ae ky" href="https://edward-huang.com/scala/functional-programming/2022/04/18/5-anti-pattern-for-writing-code-in-a-functional-programming-language/" rel="noopener ugc nofollow" target="_blank"><em class="nf">【https://edward-huang.com】</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>