<html>
<head>
<title>StopPropagation vs. StopImmediatePropagation in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的StopPropagation与StopImmediatePropagation</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stoppropagation-vs-stopimmediatepropagation-in-javascript-27b9f8ce79b5?source=collection_archive---------6-----------------------#2020-09-14">https://betterprogramming.pub/stoppropagation-vs-stopimmediatepropagation-in-javascript-27b9f8ce79b5?source=collection_archive---------6-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8435" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理事件传播的两种重要方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/898932de7afc833b1f09c39f93946fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oN4oDcYYAIhZ4iT9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@supersonnytje?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sonny Ravesteijn </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的一个同事已经开始实现一个聊天应用程序，作为视频流服务的Chrome扩展的第三方库。不过，她已经陷入了许多问题，把我们其他人也拖了进来。我带来了一个我认为足够好的版本，可以与其他JavaScript开发人员分享。</p><p id="c64f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将讨论<code class="fe lv lw lx ly b">EventTarget</code>对象中的两个方法，<code class="fe lv lw lx ly b">stopPropagation</code>和<code class="fe lv lw lx ly b">stopImmediatePropagation</code>，这两个方法你们很多人都知道但不知道如何正确使用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2ed8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">放弃</h1><p id="4626" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">本文只讨论普通JavaScript，不涉及React或任何其他JavaScript框架的使用。因此，事件的实现可能在其他地方以不同的方式工作，因为React以自己的方式工作，例如，使用称为<code class="fe lv lw lx ly b">SyntheticEvent</code>系统的事件系统。</p><p id="9e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，为了更好地理解本文，您应该知道什么是事件冒泡和捕获。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4351" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是element.addEventListener？</h1><p id="862e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你是一名JavaScript开发人员，我敢肯定你知道这是什么以及它是如何工作的，但是让我们确保我们每个人都知道同样的事情。</p><p id="f5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当JavaScript添加一个事件时，它的工作原理如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当类型、回调、包含它的应该被捕获的选项(或类似的东西)是相同的时候，它才会在事件句柄列表中设置一个新事件。否则，它忽略来自上下文的添加请求。</p><p id="dd05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果连续添加几个不同的事件会怎么样？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将三种不同的事件类型注册到窗口对象，但是内部事件侦听器将事件保存如下。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="0153" class="nj mh it ly b gy nk nl l nm nn">[event_listener_list]<br/>index  type    callback      ...<br/>  0    click   (anonymous)<br/>  1    keydown (anonymous)<br/>  2    dbclick (anonymous)</span></pre><p id="197f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您双击窗口时，它会为双击运行回调，而不会给你任何错误。事件侦听器列表中的内容看起来有点混乱，但没关系:它通过从第一个索引开始查找来为您找到正确的内容。</p><p id="5478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那这个怎么样？</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="6e59" class="nj mh it ly b gy nk nl l nm nn">window.addEventListener('click', () =&gt; log(1));<br/>window.addEventListener('click', () =&gt; log(2));<br/>window.addEventListener('click', () =&gt; log(3));</span></pre><p id="c8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你认为它会向你展示什么？正确，它显示了1，2，3。它们看起来一样，但是每个回调都是匿名函数，所以JavaScript认为它们是不同的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e2b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这段代码不会打印三次日志，因为回调不是匿名的。它有内存地址，因此JavaScript认为它们都是相同的请求，所以它只接受第一个请求，忽略其他的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c21f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是停止传播？</h1><p id="79e1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在跳入<code class="fe lv lw lx ly b">stopImmediatePropagation</code>之前，我们先来考察一下<code class="fe lv lw lx ly b">stopPropagation</code>是什么。在JavaScript事件系统中，有两个事件阶段——冒泡和捕获。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/018cd3e9dbbec898796f2133f7f0bc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0S0kU5wZY-BeXekdAI6QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://www.w3.org/TR/uievents/#event-flow" rel="noopener ugc nofollow" target="_blank"> W3C </a></p></figure><p id="c460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是每个DOM事件都支持冒泡和捕获，但是大多数都支持，尽管基本上DOM事件是从最顶层的元素——窗口对象开始的。无论您在网页上的什么地方单击元素，只要事件在捕获步骤是可服务的，DOM元素总是从窗口对象触发事件。</p><p id="11bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它一直向下到实际触发click事件的实际元素。这个元素被称为<code class="fe lv lw lx ly b">target</code>事件。此时执行回调。并且通过访问每个祖先，它一直向上到达根元素。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="afd5" class="nj mh it ly b gy nk nl l nm nn">window.addEventListener('click', log);</span></pre><p id="4051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，如果您添加事件，JavaScript会使回调在捕获阶段无法被找到，如上面的示例所示。要在下一步查看它，您应该将第三个参数传递给<code class="fe lv lw lx ly b">addEventListener</code>。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="3170" class="nj mh it ly b gy nk nl l nm nn">window.addEventListener('click', log, true);<br/>// or<br/>window.addEventListener('click', log, {<br/>  capture: true<br/>});</span></pre><p id="423d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请记住:添加能够在捕获步骤捕获事件的回调，并不意味着它将在已经注册的其他回调之前执行。这是因为JavaScript管理事件侦听器列表中的事件，事件侦听器列表是一个类似数组的类型对象，它按照事件处理程序进来的顺序取出并调用事件处理程序。当然，带有<code class="fe lv lw lx ly b">capture: true</code>的事件处理程序在其它带有<code class="fe lv lw lx ly b">capture: false</code>的处理程序之前先被执行。</p><p id="d133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个概念的重要性在于，当你想切断让事件在当前阶段后下降或上升的桥梁时。</p><p id="bec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要知道<code class="fe lv lw lx ly b">target</code>和<code class="fe lv lw lx ly b">currentTarget</code>是不一样的。<code class="fe lv lw lx ly b">target</code>是您的事件侦听器所附加的实际DOM元素，而<code class="fe lv lw lx ly b">currentTarget</code>则是此时捕获事件侦听器的DOM元素。例如，如果您单击最底部的元素，<code class="fe lv lw lx ly b">target</code>始终是元素本身，但是当事件冒泡到最顶部的元素时，<code class="fe lv lw lx ly b">currentTarget</code>会发生变化。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="df5b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用stopPropagation时应该注意什么？</h1><p id="c41c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">每当你不想错过运行事件回调的机会时，就该使用<code class="fe lv lw lx ly b">stopPropagation</code>了。</p><p id="71d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有太多关于<code class="fe lv lw lx ly b">stopPropagation</code>的好例子，所以我将更多地关注你在使用<code class="fe lv lw lx ly b">stopPropagation</code>时应该注意的地方。假设您在一个文件中编写JavaScript代码和HTML标记，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个功能直接附加在这个元素上。现在它被视为一种老派技能，但它仍然工作良好。如果您使用<code class="fe lv lw lx ly b">addEventListener</code>向<code class="fe lv lw lx ly b">parent</code>对象添加另一个回调，您将永远无法阻止流执行内联回调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="972a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">父对象的内联回调不被调用的唯一方法是要么从元素中删除它，要么触发另一个元素(父元素或子元素)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/d792c5fb5cc90aca381ee056d26b28eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slw2Bi9E7NP_625x7R9q3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="3726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当单击父元素时，在捕获阶段首先触发“app”元素的回调，因为它的一个回调有<code class="fe lv lw lx ly b">capture: true</code>。然后它内部不调用<code class="fe lv lw lx ly b">stopPropagation</code>，转到“parent”元素。“parent”元素有内联回调，所以它将首先被执行，打印“parent inline”然后使用<code class="fe lv lw lx ly b">capture: false</code>的回调在使用<code class="fe lv lw lx ly b">capture: true</code>的回调之前执行，这可能看起来很奇怪。</p><p id="2634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，捕获或冒泡阶段意味着它在不同的DOM级别捕获事件。如果你点击这个元素，它有两个回调函数<code class="fe lv lw lx ly b">capture: true</code>和<code class="fe lv lw lx ly b">capture: false</code>，那么这些事件将按照它们被注册的顺序执行。</p><p id="90e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而“parent”的最后一次回调调用的是<code class="fe lv lw lx ly b">stopPropagation</code>函数，所以不会再有事件向上冒泡。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="787d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是stopImmediatePropagation？</h1><p id="9349" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">好了，现在我很有信心，我对<code class="fe lv lw lx ly b">addEventListener</code>的了解至少在你自己的知识范围之内。现在说下一个话题，<code class="fe lv lw lx ly b">stopImmediatePropagation</code>。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="16ff" class="nj mh it ly b gy nk nl l nm nn">window.addEventListener('click', () =&gt; log(1));<br/>window.addEventListener('click', () =&gt; log(2));<br/>window.addEventListener('click', () =&gt; log(3));</span><span id="401b" class="nj mh it ly b gy nr nl l nm nn">// print 1 2 3</span></pre><p id="bffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">window对象有三个事件监听器回调，分别输出1、2和3。但我不希望最后一个被处决。我该怎么做呢？</p><p id="60da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">stopImmediatePropagation</code>防止JavaScript放弃调用下一个回调函数。</p><p id="fa1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，请记住<code class="fe lv lw lx ly b">stopImmediatePropagation</code>，一旦它完成运行，不仅停止将事件传播到同一级别的其他事件，也不会传播到更低级别的其他事件。就像一个以自我为中心，只关心自己的小男孩。</p><p id="eafe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦回调结束运行，它就完全结束了事件流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/cc3304de92f4e7b6049557e28320380b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQNm94ZabMTx6q-5p1OxSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="b15a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在当前元素的事件阶段调用<code class="fe lv lw lx ly b">stopImmediatePropagation</code>，它不会让上下文传递给下一个等待的元素。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4bb3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么时候应该使用stopImmediatePropagation？</h1><p id="02b4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通常，我猜你甚至不需要考虑是否应该调用<code class="fe lv lw lx ly b">stopImmediatePropagation</code>,因为大多数时候，你不希望在相同的事件级别阻塞事件传播流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/1c3e97952f6a95ef4302f39b04f35139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ToEYdPp7Co5A0FtzWFL-KA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="8053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设组件A已经为窗口对象的点击设置了事件监听器— <code class="fe lv lw lx ly b">window.addEventListener('click', cb_A)</code>。</p><p id="0dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您目前正在处理组件B，并且您还注册了对窗口对象的回调— <code class="fe lv lw lx ly b">window.addEventListener('click', cb_B)</code>。但是<code class="fe lv lw lx ly b">cb_B</code>总是在<code class="fe lv lw lx ly b">cb_A</code>被调用之后被调用，因为事件监听器列表按照事件处理程序进来的顺序保存它们。解决方法是将组件B的回调放在捕获阶段。</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="0c1f" class="nj mh it ly b gy nk nl l nm nn">window.addEventListener('click', cb_B, true);<br/>// or<br/>window.addEventListener('click', cb_B, { <br/>  capture: true <br/>});</span></pre><p id="dd09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于捕获选项默认为<code class="fe lv lw lx ly b">false</code>，组件A的<code class="fe lv lw lx ly b">cb_A</code>处于冒泡阶段。这样做的目的是将等待上下文转折放在更靠前的位置，然后调用<code class="fe lv lw lx ly b">stopImmediatePropagation</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="1e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe lv lw lx ly b">stopImmediatePropagation</code>的演示。它们都向窗口对象注册了事件侦听器，并且都被调用。如果您让组件B在设置为<code class="fe lv lw lx ly b">capture: true</code>的回调中调用<code class="fe lv lw lx ly b">stopImmediatePropagation</code>，它将不允许在下一个捕获阶段或冒泡阶段执行下一个回调。</p><p id="a4cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果事件处理程序是在您实际单击的DOM元素中注册的，而不是在您单击的实际元素的父元素中注册的，那么这种方式就不起作用。即使您试图通过将事件注册为捕获事件来控制事件传播的流程，如果事件处理程序列表中存在现有的事件处理程序，它们也将总是首先执行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0f87" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="e05b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">stopPropagation</code>和<code class="fe lv lw lx ly b">stopImmediatePropagation</code>是不同的功能方法，使用时要小心。<code class="fe lv lw lx ly b">stopPropagation</code>防止事件向上冒泡或向下捕捉到下一个元素，<code class="fe lv lw lx ly b">stopImmediatePropgation</code>防止事件在当前事件运行结束后被执行。</p><p id="20f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当元素上有事件作为内联回调时，您不能用<code class="fe lv lw lx ly b">stopPropagation</code>来阻止它们调用。然而，如果内联回调点中的语句不是函数表达式(这意味着它类似于<code class="fe lv lw lx ly b">console.log('hello')</code>)而不是调用其他函数，它可能会被<code class="fe lv lw lx ly b">stopPropagation</code>停止，即使JavaScript用匿名函数体包装它。但这已经成为多年前的老一套了，所以你可能不需要再关心它了。</p><p id="5400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要记住，其他JavaScript框架(如React)的工作方式可能与纯JavaScript不同，因为它们可能有自己的事件系统。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c9a3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><ul class=""><li id="0948" class="nu nv it lb b lc my lf mz li nw lm nx lq ny lu nz oa ob oc bi translated"><a class="ae ky" href="https://dom.spec.whatwg.org/#stop-immediate-propagation-flag" rel="noopener ugc nofollow" target="_blank">https://DOM . spec . whatwg . org/# stop-immediate-propagation-flag</a></li><li id="d006" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://dom.spec.whatwg.org/#add-an-event-listener" rel="noopener ugc nofollow" target="_blank">https://dom.spec.whatwg.org/#add-an-event-listener</a></li><li id="9409" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.w3.org/TR/uievents/#event-flow" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/uievents/#event-flow</a></li></ul></div></div>    
</body>
</html>