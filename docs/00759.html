<html>
<head>
<title>Docker-Powered Web Development Utilizing HTTPS and Local Domain Names</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用HTTPS和本地域名的Docker驱动的Web开发</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-powered-web-development-utilizing-https-and-local-domain-names-a57f129e1c4d?source=collection_archive---------6-----------------------#2019-07-10">https://betterprogramming.pub/docker-powered-web-development-utilizing-https-and-local-domain-names-a57f129e1c4d?source=collection_archive---------6-----------------------#2019-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f59f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">适用于Linux、macOS和Windows的独立于平台的解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b20a371586476427c3b5bacd461cdc05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ql72N4ymDN2QU59ylAhmQ.png"/></div></div></figure><p id="7a64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您是否正在寻找一个利用HTTPS交通、本地域名和灵活的服务基础设施的本地开发环境？本文概述了一个独立于平台的解决方案。</p><p id="0b71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现代web应用程序开发中最大的挑战之一是传输层安全性。</p><p id="3dc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，在公共web服务器上，这个问题很快就解决了——只需使用<a class="ae ln" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>或任何其他认证机构。</p><p id="5924" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果您想在本地开发网络中实现HTTPS，这仍然是复杂和耗时的。</p><p id="57cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个挑战是实现尽可能接近生产服务器条件的本地开发环境。如果这还不够，几个项目之后，开发人员必须处理一大堆web服务器和数据库——以及它们的各种版本。</p><p id="ff28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">项目A需要<a class="ae ln" href="https://www.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache </a>和<a class="ae ln" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>，而项目B运行的是<a class="ae ln" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> NGINX </a>和<a class="ae ln" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>。一个较老的项目C也需要MongoDB，但是与其最新版本不兼容。</p><p id="f6db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，作为开发人员，我们需要一个由本地服务器、数据库和运行时环境组成的网络，所有这些都通过HTTPS进行通信，并且可以通过本地域名到达。</p><p id="8ad6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们希望有一种简单、快速、灵活的方式在几种这样的环境之间进行切换。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="e5d5" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">具有<strong class="ak"> Docker </strong>的灵活</strong>环境</h1><p id="f113" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">输入<a class="ae ln" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>:</p><blockquote class="ms"><p id="72b4" class="mt mu iq bd mv mw mx my mz na nb lm dk translated">操作系统级别的虚拟化开发和交付叫做容器的软件包(维基百科)。</p></blockquote><p id="9a2c" class="pw-post-body-paragraph kr ks iq kt b ku nd jr kw kx ne ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">有了Docker，在所谓的容器中启动服务变得非常容易——并且在切换到另一个项目时快速停止它们。</p><p id="47bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任何项目都可以由几个容器组成，Docker和一些第三方项目为我们提供了编排这些容器的工具。</p><p id="ed1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这不是对Docker的介绍。为此，我参考了全面的<a class="ae ln" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>。</p><p id="d5c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这也不是对HTTPS或SSL的介绍。为此，我建议您去Google或当地的书店，因为您不仅需要介绍，还需要大量的文档来在您的特定系统中实现它。</p><p id="9242" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，如果你想要一个快速的解决方案，请继续阅读。</p><p id="1b93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个关于如何实现本地web开发环境的介绍，在本地web开发环境中，服务器和客户端通过HTTPS进行通信，并且服务器和运行时环境很容易设置。</p><p id="7f68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为奖励，我们将在我们的服务中应用本地域名，如<code class="fe ni nj nk nl b">my-cool-app.localhost</code>。</p><p id="7726" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我会尽可能保持设置的通用性。如果我们想开发一个运行在Apache/MySQL上的<a class="ae ln" href="http://wordpress.org" rel="noopener ugc nofollow" target="_blank"> WordPress </a>网站，或者为一个<a class="ae ln" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt </a> / <a class="ae ln" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>客户端开发一个<a class="ae ln" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> API，这都没有关系。</p><p id="79a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">概念基本上是相同的，我将用一个简单的例子来说明整个过程。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="0d84" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">一个关键概念:反向代理</strong></h1><p id="565a" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在许多现代web应用程序中，一个关键概念是<em class="nm">反向代理</em>。</p><p id="9091" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">反向代理从客户端获取请求，并将其传输到内部网络中的服务器。因此，服务器对客户端是隐藏的。</p><p id="0527" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的web服务运行在内部网络中，而通信通过反向代理进行。代理管理一切，还建立HTTPS端点。</p><p id="992b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是Docker的闪光点:它不仅是一个启动我们的服务器和数据库的工具，也是管理它们之间的网络的工具。</p><p id="b5b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有Docker容器可用，不仅适用于几乎任何类型的服务器或数据库，也适用于我们的反向代理。我们只需要稍微配置一下。我保证，真的就一会儿。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9a34" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">先决条件</strong></h1><ol class=""><li id="e3cc" class="nn no iq kt b ku mn kx mo la np le nq li nr lm ns nt nu nv bi translated">安装Docker。你可能想要社区版。关于如何在Linux、macOS或Windows上安装Docker，参见<a class="ae ln" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。<br/>我们还将使用Docker Compose来配置我们的多容器应用程序。在macOs和Windows上，很可能已经安装了Docker。对于Linux <a class="ae ln" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">请参见文档</a>。</li><li id="6cd7" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">安装<a class="ae ln" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>。创建自签名证书需要此工具。OpenSSL几乎适用于所有操作系统。</li></ol></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="b3e0" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">我们的第一个集装箱栈</strong></h1><p id="3b5f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">一个流行的反向代理是Jason Wilder的<a class="ae ln" href="https://github.com/jwilder/nginx-proxy" rel="noopener ugc nofollow" target="_blank"> nginx-proxy </a>，这是一个预配置的Docker容器，可以自动完成很多配置。</p><p id="df05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在任何运行Docker的系统上用一个命令启动它:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="1465" class="of lw iq nl b gy og oh l oi oj">$ docker run -d -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy</span></pre><p id="b6f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后启动附加服务，如下所示:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="a4f6" class="of lw iq nl b gy og oh l oi oj">$ docker run -e VIRTUAL_HOST=my-funny-project.dev …</span></pre><p id="247e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Nginx-proxy会自动创建一个虚拟主机域<code class="fe ni nj nk nl b">my-cool-app.localhost</code>并通过反向代理连接我们的服务。这再简单不过了。</p><p id="20fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果我们使用Docker Compose，多容器应用程序的配置和启动将会更加简单。</p><p id="6f5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务及其所有设置都在一个名为<code class="fe ni nj nk nl b">docker-compose.yml</code>的文件中进行配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="c909" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用以下命令在该文件夹中启动Docker Compose:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="2c1a" class="of lw iq nl b gy og oh l oi oj">docker-compose up</span></pre><p id="0c84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有需要的Docker映像都被自动下载，从这些映像构建容器，然后启动。</p><p id="5860" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的第一个多容器应用程序已经启动并运行——太神奇了。</p><p id="81cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是在我们使用它之前，让我们来看看docker-compose配置文件的细节(上面的<code class="fe ni nj nk nl b">docker-compose.yml</code>)。</p><p id="c793" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个服务都在它自己的部分中定义。在本例中，这些服务是web服务器和ningx-proxy。对于每个服务，我们配置Docker映像、环境变量、端口、挂载的卷等。<a class="ae ln" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">参见文档</a>了解所有选项。</p><p id="769e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代理只需要对主机系统的Docker套接字进行只读访问，以及关于它应该监听的端口的信息。该示例使用标准web端口80，因此我们可以使用任何浏览器并打开<code class="fe ni nj nk nl b">my-cool-app.localhost</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/b91e91b933115dee303b4d9a793a40fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*joiL34oo7gUMD9V8ythURQ.png"/></div></div></figure><p id="85df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回应来自我们新的网络服务器。在这个例子中，我们使用Jason Wilder的非常基本的web服务器WhoAmI，它只返回运行它的Docker容器的ID；服务已启动并正在运行的简单指示。</p><p id="5bfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以继续复制web服务器部分，将其命名为<em class="nm"> webserver2 </em>，并给它一个不同的本地域。</p><p id="b1ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重启Docker Compose后，两台服务器都应该可以通过nginx-proxy使用。从现在开始，这只是向更复杂的具有真实服务的应用程序迈出的一小步，其中我们可以通过每个服务自己的本地域来访问每个服务。</p><p id="3926" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，截图已经指向了我们的下一个挑战:URL旁边是一个感叹号，表示浏览器不信任该连接(其他浏览器可能会有其他信号来警告)。</p><p id="bdf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出现警告的原因是该页面是通过HTTP提供的，没有加密。因此，让我们让HTTPS为我们的服务。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="8688" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">本地SSL加密</strong></h1><p id="9acd" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">如果您喜欢上一节中本地域的简单配置，您会更喜欢这一部分。</p><p id="8500" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要启用HTTPS，我们只需在配置文件中添加两行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="1ff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些行配置了额外的端口443(HTTPS的标准)和一个名为<code class="fe ni nj nk nl b">.certs</code>的文件夹的安装，我们的SSL证书就在这个文件夹中。</p><p id="29e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果证书名称中包含虚拟主机域，nginx-proxy会自动配置每个连接使用相关的证书，并通过HTTPS提供服务——神奇！</p><p id="080e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">唯一的问题是:我们很可能不拥有像<code class="fe ni nj nk nl b">my-cool-app.localhost</code>这样的本地域的有效证书。但是我们可以创造一个。</p><p id="ab81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在最后一部分，我们创建了一个<em class="nm">自签名证书</em>。我们成为自己的根证书颁发机构。这很酷——我们通过这样做学到了一些东西。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="3b66" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">自签名证书的创建</strong></h1><p id="ca99" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们可以在文件夹<code class="fe ni nj nk nl b">.certs</code>中执行所有后续步骤，也就是nginx-proxy也用于HTTPS配置的那个文件夹。</p><p id="6833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">流程如下:</p><ol class=""><li id="b68e" class="nn no iq kt b ku kv kx ky la on le oo li op lm ns nt nu nv bi translated">首先，我们将创建一个<em class="nm">根SSL证书</em>，也称为<em class="nm"> CA证书</em>或简称为<em class="nm">根CA </em>。这必须只做一次。</li><li id="56f5" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated">然后，我们将为每个本地域生成一个证书，并用这个根CA进行签名。我写了一个<a class="ae ln" href="https://gist.github.com/OnnoGeorg/f717192ed92bf55725337358f4af5ab2" rel="noopener ugc nofollow" target="_blank"> bash脚本</a>来自动化这个过程，但是现在，我们将一步一步地完成整个过程。</li></ol><h2 id="639c" class="of lw iq bd lx oq or dn mb os ot dp mf la ou ov mh le ow ox mj li oy oz ml pa bi translated"><strong class="ak"> 1。根CA的创建</strong></h2><p id="fb5c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">首先，我们为根CA生成一个私钥，一个名为<code class="fe ni nj nk nl b">rootCA.key</code>的文件:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="1e1c" class="of lw iq nl b gy og oh l oi oj">$ openssl genrsa -out rootCA.key 4096</span></pre><p id="d7e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个密钥是<em class="nm">而不是</em>密码保护的(如果我们在命令中添加参数<code class="fe ni nj nk nl b">-des3</code>就可能是这样)。</p><p id="9bf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这里描述的过程只是针对您的本地开发环境。不要在生产中使用它！</p><p id="fa1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们通过回答一些关于我们的问题对生成的密钥进行自签名:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="6ee4" class="of lw iq nl b gy og oh l oi oj">$ openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt</span><span id="5f2d" class="of lw iq nl b gy pb oh l oi oj">You are about to be asked to enter information that will be incorporated into your certificate request.<br/>What you are about to enter is what is called a Distinguished Name or a DN.<br/>There are quite a few fields but you can leave some blank.<br/>For some fields, there will be a default value, If you enter '.', the field will be left blank.<br/>-----<br/>Country Name (2 letter code) [AU]:DE<br/>State or Province Name (full name) [Some-State]:Berlin<br/>Locality Name (eg, city) []:Berlin<br/>Organization Name (eg, company) [Internet Widgits Pty Ltd]:My-Company<br/>Organizational Unit Name (eg, section) []:Development<br/>Common Name (e.g. server FQDN or YOUR name) []:My-Company<br/>Email Address []:xxx@yyyy.zz</span></pre><p id="5713" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里输入什么并不重要。<code class="fe ni nj nk nl b">Common Name</code>稍后会出现在我们的可信机构列表中，所以我们应该选择一个容易识别的名称。</p><p id="4a91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们拥有了成为我们自己的认证中心的一切。至少对于我们自己的目的来说是这样，因为世界上还没有浏览器知道我们的CA。</p><p id="be28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让浏览器熟悉我们的根CA，我们必须导入它。</p><ul class=""><li id="f9e0" class="nn no iq kt b ku kv kx ky la on le oo li op lm pc nt nu nv bi translated">在macOS上，我们可以将根CA添加到钥匙串中。</li><li id="10de" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm pc nt nu nv bi translated">在Linux或Windows上，我们可以将根CA导入到浏览器中的可信机构。</li></ul><p id="c6af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个浏览器都有不同的设置页面，所以请查看您的浏览器文档(或者搜索“在chrome/firefox/edge/”中导入根ca)。</p><h2 id="1460" class="of lw iq bd lx oq or dn mb os ot dp mf la ou ov mh le ow ox mj li oy oz ml pa bi translated"><strong class="ak"> 2。为每个域创建一个证书</strong></h2><p id="296f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">下一步是为本地域创建证书，例如为<code class="fe ni nj nk nl b">my-cool-app.localhost</code>。</p><p id="7764" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，我们首先创建一个私钥:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="a902" class="of lw iq nl b gy og oh l oi oj">$ openssl genrsa -out my-cool-app.localhost.key 2048</span></pre><p id="8fae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们为这个密钥创建一个签名请求:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="e9f5" class="of lw iq nl b gy og oh l oi oj">$ openssl req -new -sha256 -key my-cool-app.localhost.key -out my-cool-app.localhost.csr</span></pre><p id="4c75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将再次被问到一些问题。重要的是关于通用名称的:这个<em class="nm">必须等于我们的本地域</em>(例如<code class="fe ni nj nk nl b">my-cool-app.localhost</code>)。</p><p id="f82a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一步是用根CA签署您的证书。</p><p id="1cd8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们需要一个名为<code class="fe ni nj nk nl b">my-cool-app.localhost.v3.ext</code>的小配置文件:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="ffb4" class="of lw iq nl b gy og oh l oi oj">authorityKeyIdentifier=keyid,issuer<br/>basicConstraints=CA:FALSE<br/>keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment<br/>subjectAltName = @alt_names<br/>[alt_names]<br/>DNS.1 = my-cool-app.localhost</span></pre><p id="6d6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里重要的是最后一行，它也包含本地域。</p><p id="819a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这个域，我们现在可以用根CA签署证书:</p><pre class="kg kh ki kj gt ob nl oc od aw oe bi"><span id="676a" class="of lw iq nl b gy og oh l oi oj">$ openssl x509 -req -in my-cool-app.localhost.csr -CA my-cool-app.localhost.crt -CAkey my-cool-app.localhost.key -CAcreateserial -out my-cool-app.localhost.crt -days 1024 -sha256 -extfile my-cool-app.localhost.v3.ext</span></pre><p id="2658" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这最终创建了我们的证书:<code class="fe ni nj nk nl b">my-cool-app.localhost.crt</code>。</p><p id="b81b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ni nj nk nl b">.certs</code>文件夹现在应该包含<code class="fe ni nj nk nl b">my-cool-app.localhost</code>的密钥和证书。</p><p id="8eac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重启Docker Compose，nginx-proxy现在应该可以通过HTTPS为我们的演示应用提供服务了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3a888c34153cc3df26314a3d948ee55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*o3Mbo6KLzy9hcI6W7mF-Aw.png"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="dc4f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">结论</strong></h1><p id="fff4" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们已经用Docker Compose为多容器web应用程序建立了基本的框架。</p><p id="88a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">服务运行在反向代理的后面，该代理不仅组织所有服务和客户端之间的通信，还为每个服务设置本地域名和通过HTTPS的SSL传输。</p><p id="d4d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个开发环境可以很容易地用我们需要的任何服务来扩展。</p></div></div>    
</body>
</html>