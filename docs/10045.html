<html>
<head>
<title>How To Prevent Unnecessary React State Update Re-renders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何防止不必要的反应状态更新重新呈现</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-prevent-unnecessary-react-state-update-re-renders-49cf4301b423?source=collection_archive---------7-----------------------#2021-11-17">https://betterprogramming.pub/how-to-prevent-unnecessary-react-state-update-re-renders-49cf4301b423?source=collection_archive---------7-----------------------#2021-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f8d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及你需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a68ac8174211c4bde6327c0c3a5f241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*axjVwmEXzrxq68JQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@freegraphictoday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">absolute vision</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9eb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React开发中最常用的钩子是<code class="fe lv lw lx ly b">useState</code>。无论React应用程序有多小或多大，您都会使用它。这是在React web应用程序中实现交互性、逻辑和状态的关键。如果没有所有这些，我们的web应用程序将与静态网页没有什么不同。</p><p id="8f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">支持所有这些因素的关键特性是状态更新:根据网络请求、用户交互、用户输入等等更新内部状态。反过来，这些状态更新将触发对用户界面、信息服务或任何反映最终用户体验的东西的更新。</p><p id="daaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，并不是每个<code class="fe lv lw lx ly b">setState</code>调用都会导致状态更新重新呈现。状态更新将触发组件以及所有子组件的重新呈现。对于浏览器来说，这可能是昂贵的，并且会大大降低React应用程序的速度，从而对用户体验产生负面影响。</p><p id="1e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在某些情况下，知道如何防止状态更新重新呈现是很重要的。本文将介绍几种防止状态更新或重新呈现的方法。我们不仅要研究实现，还要研究它们的差异和使用案例。这些信息将为您提供这个主题的坚实基础，并允许您将它应用到自己的React代码中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dd90" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">避免状态更新</h1><p id="7930" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">防止状态更新重新呈现的最直接的方法是完全避免状态更新。这意味着确保不调用<code class="fe lv lw lx ly b">setState</code>函数，除非绝对必要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="018b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的主要问题是，它要求您事先验证状态本身。这意味着您必须依赖原始状态定义中的状态对象。这在从内部钩子触发状态更新时尤其重要，比如<code class="fe lv lw lx ly b">useCallback</code>或<code class="fe lv lw lx ly b">useEffect</code>。</p><p id="a97c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着钩子现在必须依赖于其作用域之外的变量。在某些情况下，这可能会导致争用情况，即在达到实际状态更新之前，状态尚未正确更新。除此之外，这还需要将状态添加到钩子的依赖列表中。</p><p id="0498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在很多情况下，这两个因素不会产生重大影响，也无关紧要。但是在某些情况下，这可能会导致不希望的行为，因为钩子将比期望的更频繁地被触发，或者状态更新是用过时的信息触发的。</p><h1 id="7022" class="mg mh it bd mi mj nf ml mm mn ng mp mq jz nh ka ms kc ni kd mu kf nj kg mw mx bi translated">用相同的状态更新</h1><p id="5756" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一种防止状态更新重新呈现的方法不太为人所知。它利用了<code class="fe lv lw lx ly b">useState</code> React钩子的内部构件,在之前和当前的状态值之间进行比较。根据<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#description" rel="noopener ugc nofollow" target="_blank">Object.is</a></code>比较算法，如果两个值相同，那么React将保释你的组件，并确保没有重新渲染发生。</p><p id="0c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当试图避免状态更新重新呈现时，这是一个非常方便的机制。不幸的是，如果您使用React的时间更长，您可能不会意识到这一点。当React开发仍然主要使用类组件时，<code class="fe lv lw lx ly b">setState</code>调用总是会触发重新渲染。因此，防止重新渲染的最合理的解决方案是完全避免状态更新。但是现在，这已经没有必要了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，您将做一件与完全避免状态更新非常相似的事情。但是您将在状态更新调用本身内部执行它们，而不是在状态更新之前验证状态。这要求您使用函数作为状态更新器，而不是值。</p><p id="f13c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">state updater函数接收当前的状态值，并应该返回您想要的新值。在函数内部，您可以使用当前状态值来检查状态是否应该实际更改。如果是这样，该函数应该返回适当的值。如果没有，该函数可以返回当前状态值，并如前所述退出重新渲染。</p><p id="4548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于比较算法的工作方式，基于原始数据类型的状态更新将总是被优化。在这些场景中，没有必要担心当前的状态对象引用，使用具体的值就可以了。但是当处理更复杂的数据结构，如数组和对象时，当试图防止状态更新中的重新呈现时，有必要重用当前的状态对象。</p><p id="97db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个主要好处是不再需要状态对象作为定制钩子的依赖项。这有利于提高性能，并避免创建更多的实体或执行更多不必要的代码。最重要的是，当您使用状态更新函数引用状态值时，还可以保证使用最新的状态值。这些因素一起将导致更优化的React代码和更少的意外行为。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6a8c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的想法</h1><p id="5670" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">陈述当今任何React web应用程序中最重要的事情。<code class="fe lv lw lx ly b">useState</code>钩子允许我们进行简单的状态管理和状态更新。但是，并不是每个状态更新都会导致重新渲染。不必要的重新渲染对于浏览器来说是昂贵的，并且对最终用户的体验有负面影响。</p><p id="9c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助您做到这一点，本文介绍了两种防止状态更新重新呈现的方法。这些包括完全避免状态更新，以及通过用相同的现有状态触发状态更新来防止重新渲染。我们不仅研究了实现，还研究了用例、注意事项、缺点和好处。这些信息将为您提供这个主题的坚实基础，并允许您将它应用到自己的React代码中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="750e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，可以考虑看看<a class="ae ky" href="https://www.getrevue.co/profile/chakshunyu" rel="noopener ugc nofollow" target="_blank">不凡反应</a>时事通讯和我的<a class="ae ky" href="https://twitter.com/keraito" rel="noopener ugc nofollow" target="_blank">推特</a>中的其他条目，以便将来更新。</p></div></div>    
</body>
</html>