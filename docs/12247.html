<html>
<head>
<title>React v18: Why useEffect Suddenly Got Crazy?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React v18:为什么useEffect突然疯了？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-v18-why-useeffect-suddenly-go-crazy-db1b42eb2730?source=collection_archive---------0-----------------------#2022-05-22">https://betterprogramming.pub/react-v18-why-useeffect-suddenly-go-crazy-db1b42eb2730?source=collection_archive---------0-----------------------#2022-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b608" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">双挂载在react useEffect()钩子上</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/379163937f7d560766e51c4751147aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzN0cglEc5c0DbjTsHh72Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">双挂载在react useEffect()钩子上</strong></p></figure><p id="6a4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React版本18为核心带来了一些非常明显的变化。其中一个苦乐参半的变化是以严格模式加载组件的<strong class="ky ir">挂载- &gt;卸载- &gt;重新挂载</strong>模式。如果您还没有亲身体验过，请做好准备，因为乍一看，这似乎是您快乐工作的应用程序中的某种黑魔法。我们潜水吧。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1287" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题</h1><p id="f385" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们以这个相当简单的代码为例。从<code class="fe mw mx my mz b">useEffect</code>中的空依赖数组来判断，我们可以期望“应用程序加载”在我们的控制台中打印一次，然后就完成了。</p><p id="9389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对这个<strong class="ky ir"> </strong> <code class="fe mw mx my mz b"><a class="ae na" href="https://sameer-kumar-1612.medium.com/console-log-and-his-ninja-pals-4fc0863ad5f4" rel="noopener"><strong class="ky ir">console.count</strong></a></code>方法的用法感到困惑，请阅读这里:<a class="ae na" href="https://sameer-kumar-1612.medium.com/console-log-and-his-ninja-pals-4fc0863ad5f4" rel="noopener">牛逼的控制台方法</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在不带清理功能的react中使用Effect挂钩。</p></figure><p id="5e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令人惊讶的是，我们看到这条消息被打印了两次。这就提出了一个问题，是我们做错了什么，还是React今天喝醉了？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/2e3d5b304752fd69275e90a19faf725c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-kV-3vo6A7keUrYCMfWmg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">双控制台登录react useEffect。</strong></p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a5ec" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">背景</h1><p id="172d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了理解这一切，让我们首先讨论纯函数和幂等性的概念。下图不言自明，我们可以看到，在相同的条件下，一个函数应该产生相同的输出。然而，幂等性意味着即使一个函数运行多次，结果应该是相同的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/233e19269825a7d138b6f79ef5aa9065.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*KzkeD6AfVwyK-JAZxTF-lQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">纯函数</strong></p></figure><p id="e982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你一定想知道这和我们手头的react问题有什么关系。举一个实际的例子，我们打算订阅来自某个服务器的通知流，我们保持它的使用效果，希望它在用户打开我们的网站时订阅，为此使用空的依赖数组。但是，正如在我们的小演示中所确定的，在useEffect中编写的代码运行了两次，因此我们的订阅也运行了两次。可能的结果有:</p><ul class=""><li id="10c0" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">根据组件呈现的次数，我们会显示两个或更多的通知。<em class="no">【应用级纯行为不再出现，有时显示1个通知，有时显示83个。】</em></li><li id="434c" class="nf ng iq ky b kz np lc nq lf nr lj ns ln nt lr nk nl nm nn bi translated">我们的订阅服务器可能会抛出一个错误:“您已经订阅了”。<em class="no">【等幂在角落里哭。】</em></li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6a00" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决办法</h1><p id="e084" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">今天的数学已经讲得够多了，让我们来看看解决办法。“修复”本质上是坚持最佳实践。我找了很多网上资源，建议用自定义钩子代替<code class="fe mw mx my mz b">useEffect</code>用ref什么的黑掉。</p><p id="b14b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">框架往往通过抽象决策让我们的生活变得更容易，我们发起了全面的战斗来寻找溜出去的方法。Effect总是提供一个清理功能，该功能应该用于清理在效果运行期间所做的工作。</p><p id="c15f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们假设的例子中，它可以用于取消订阅。看我们之前的例子，应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在与清理函数反应中使用有效挂钩，</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/df0c5be9778686cbb8e63ca1f712574a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jbN-6thY4mpZk3QK7m9r1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd kv">挂载—卸载—挂载</strong></p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="45d0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="209b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">react团队决定将严格模式引入这些挂钩，以便在开发阶段建立最佳编程实践。就像我们的<code class="fe mw mx my mz b">useEffect</code>的情况一样，这种双重安装使我们避免了许多看不见的问题，这些问题可能会在以后的生产中出现，就像我们在订阅示例中看到的那样。</p><p id="6578" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，请注意，React在实际的生产构建中不执行这种挂载—卸载—挂载循环，它是一种开发模式特性，通过使用<code class="fe mw mx my mz b">index.tsx</code>中的<code class="fe mw mx my mz b"><a class="ae na" href="https://reactjs.org/docs/strict-mode.html" rel="noopener ugc nofollow" target="_blank">StrictMode</a></code>标记来提供，唯一目的是实施最佳实践。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">react中的StrictMode。</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><pre class="kg kh ki kj gt nv mz nw nx aw ny bi"><span id="bd04" class="nz ma iq mz b gy oa ob l oc od"><strong class="mz ir">Want To Connect?</strong></span><span id="7e65" class="nz ma iq mz b gy oe ob l oc od">🏭 LinkedIn: <a class="ae na" href="https://www.linkedin.com/in/sameerkumar1612/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/sameerkumar1612</a></span></pre></div></div>    
</body>
</html>