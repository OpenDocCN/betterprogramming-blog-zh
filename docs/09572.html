<html>
<head>
<title>4 Anti-Patterns in Python (And How to Avoid Them)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的4种反模式(以及如何避免它们)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-anti-patterns-in-python-a6d5023c8473?source=collection_archive---------1-----------------------#2021-09-13">https://betterprogramming.pub/4-anti-patterns-in-python-a6d5023c8473?source=collection_archive---------1-----------------------#2021-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Python习惯用法及其替代方法</h2></div><p id="6269" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">变更日志:<br/>2022年12月31日—使用Medium的新代码块突出显示语法<br/>2022年1月5日—修复打字错误并提高清晰度</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/76298ee9158a2a37bccea5b086d180ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7pbp4ksWPkDqsc33W5hsA.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@serge_k?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">谢尔盖·库图佐夫</a>在<a class="ae lv" href="https://unsplash.com/s/photos/awkward?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="0398" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python在IEEE 2021顶级编程语言中排名第一，是最容易掌握的语言之一，在机器学习社区中非常受欢迎。</p><p id="3c22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，有一些常见的习惯用法和模式稍微偏离了良好的软件工程实践:可读代码、ETC(更容易更改)原则、DRY(不要重复自己)原则，以及防止程序员自己的意外错误。</p><p id="6af7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将分享Python中我认为是反模式的4个习惯用法，为什么我们应该避免它们，以及我们如何改进它们的一些建议。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="40c1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">1.文档字符串</h1><p id="e22e" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">Docstrings重复了很多知识，明显违反了DRY原则。docstring重复的内容:</p><ol class=""><li id="d922" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated">参数及其Python类型的描述，以及函数返回的内容-如果包含类型注释，这已经包含在函数签名中</li><li id="f5d6" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">函数作用的总结——这已经包含在函数名和函数体中</li><li id="2873" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">函数引发的异常——这已经在函数体中了</li></ol><p id="813a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">功能在很大程度上应该是自文档化和自解释的。如果你发现你必须做很多解释，你可能需要重构你的代码。</p><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="83fd" class="nt me it np b be nu nv l nw nx">def preprocess_sentence(text):<br/>    """<br/>    Preprocess sentence to remove line breaks and <br/>    special characters.<br/>    <br/>    &gt;&gt;&gt; preprocess_sentence("Hello world!")<br/>    <br/>    Args:<br/>        text (str): text to preprocess<br/>        <br/>    Raises:<br/>        ValueError: If text is an empty string<br/>        <br/>    Returns:<br/>        str: preprocessed text<br/>    """<br/>    pass</span></pre><p id="3aff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然文档字符串可能有一些好处(比如给出函数的快速摘要，尽管仍然有争议)，但是应该避免使用它们，因为:</p><ul class=""><li id="d8fd" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld ny ng nh ni bi translated">知识的重复(解释和代码)可能会导致不一致，如果您忘记了将docstring和代码一起更改的话。</li><li id="7157" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">它允许开发人员通过编写文档字符串来弥补糟糕的代码。</li><li id="4b11" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">docstring中的一些描述看起来像是为了编写它而存在的(只是因为docstring需要它)，就像解释它返回的内容——duh这是一个预处理文本，我们不需要知道这些。</li></ul><h2 id="a8ce" class="nz me it bd mf oa ob dn mj oc od dp mn kr oe of mp kv og oh mr kz oi oj mt ok bi translated">我们能做些什么呢？</h2><ul class=""><li id="bb72" class="na nb it kk b kl mv ko mw kr ol kv om kz on ld ny ng nh ni bi translated">如果您认为docstring没有提供任何价值，请将其完全删除。</li><li id="11ba" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">引入渐进类型—类型注释参数并返回类型。使用类型别名。</li><li id="7773" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">仅在docstring中显示输入和输出。这尤其有助于数据转换，这在机器学习中很常见。</li></ul><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="db7f" class="nt me it np b be nu nv l nw nx">def remove_special_chars(text: str) -&gt; str:<br/>    """<br/>    ["hello world!\n"] -&gt; ["hello world"]<br/>    """<br/>    pass</span></pre><p id="aad0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> ⚠️例外:库、包和框架</strong></p><p id="4d22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，文档字符串在库、包或框架中是必要的。为什么没事？</p><p id="fcee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个库有两种不同类型的受众— (1)代码贡献者，以及(2)使用他们库的其他开发人员。</p><p id="802f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的项目的代码库只有前者——您和您的团队成员都是贡献者。</p><p id="0b75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二组——使用他们的库的开发人员——对代码和某些东西是如何实现的不感兴趣，因为他们只对如何使用它感兴趣。这就是文档字符串有用的地方。</p><p id="3fb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">于是，维护文档和代码一致性的额外开销的责任就落在了贡献者身上。库通常在它们的CI/CD管道中检查文档是否与代码一致。这些包括精细的单元测试，如果有代码示例就运行它们(scikit-learn)，以及在集成新的更改之前在代码评审中进行手动检查(可能有多个评审员)。</p><p id="c2a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，除非你正在编写一个库或框架，否则不要编写docstrings。</p><h1 id="d1ad" class="md me it bd mf mg oo mi mj mk op mm mn jz oq ka mp kc or kd mr kf os kg mt mu bi translated">2.只读数据字典</h1><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="fee5" class="nt me it np b be nu nv l nw nx">person = {}<br/><br/>person["name"] = "Fandi"<br/>person["age"] = 25<br/>person["country"] = "Singapore"</span></pre><p id="871d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python字典不是存储只读键值数据(例如配置)的好选择。它们不提供安全性，因为它们:</p><ol class=""><li id="960d" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated">可变——我们可能会意外地在代码中的任何地方覆盖或添加新数据，并且</li><li id="8f88" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">通过字符串类型的键访问，这可能会被拼错，从而导致KeyError异常。</li></ol><p id="28bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们这里所说的“安全”指的是数据在被读取时的可靠性和准确性。这意味着这个物体(包含我们的数据)在它被创建后不应该是<em class="le">变异的</em>，而且只要它还活着，就永远不会是。不小心这样做会引发一个异常(而不是悄悄地继续程序)。</p><h2 id="41f2" class="nz me it bd mf oa ob dn mj oc od dp mn kr oe of mp kv og oh mr kz oi oj mt ok bi translated">我们能做些什么呢？</h2><p id="8f5d" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">使用<a class="ae lv" href="https://docs.python.org/3/library/dataclasses.html#frozen-instances" rel="noopener ugc nofollow" target="_blank">冻结数据类</a> (Python 3.7)，静态类型检查器(例如<a class="ae lv" href="https://mypy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> mypy </a>)和linters。</p><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="c791" class="nt me it np b be nu nv l nw nx">from dataclasses import dataclass<br/><br/>@dataclass(frozen=True)<br/>class Person:<br/>    name: str<br/>    age: int<br/>    country: str</span></pre><p id="64db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就创建了一个名为<code class="fe ot ou ov np b">Person</code>的类。<code class="fe ot ou ov np b">frozen=True</code>防止我们意外覆盖数据(由mypy引发)。甚至没有机会访问拼写错误的属性。我们还受益于常见ide中类属性的自动完成。</p><p id="6aa6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他替代方法，尽管我不推荐它们:<a class="ae lv" href="https://docs.python.org/3/library/collections.html#collections.UserDict" rel="noopener ugc nofollow" target="_blank"> UserDict </a>(大量样板代码)，一个带有自定义设置器的类(大量样板代码)，以及<code class="fe ot ou ov np b"><a class="ae lv" href="https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields" rel="noopener ugc nofollow" target="_blank">namedtuple</a></code>(看起来不像dataclass那样直观)。</p><ul class=""><li id="8ce0" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld ny ng nh ni bi translated">请注意，虽然这里的重点是使用字典来存储键值数据，但是我们也可以将相同的原理应用于顺序数据的列表。</li></ul><h1 id="e135" class="md me it bd mf mg oo mi mj mk op mm mn jz oq ka mp kc or kd mr kf os kg mt mu bi translated">3.字符串而不是枚举</h1><p id="51c7" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">对于只接受一个可能选项列表中的一个选项的函数参数来说，字符串类型是一个糟糕的选择。以下是一些原因:</p><ol class=""><li id="1c79" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated">拼写错误的风险。</li><li id="374f" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">逃避棉绒的耗尽检查。如果您忘记添加一个选项，mypy可以为您检测出来(见下文)。</li><li id="f3b3" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">代码重复。例如，如果您想要重用if-else分支检查，您可能需要重复if-else语句。</li></ol><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="4c30" class="nt me it np b be nu nv l nw nx">def fit(solver="lbfgs"):<br/><br/>    if solver == "lbfgs":<br/>        pass<br/>    elif solver == "saga":<br/>        pass<br/>    elif solver == "sag":<br/>        pass<br/>    else:<br/>        raise ValueError</span></pre><p id="e7f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这种模式在机器学习库中非常常见，原因很明显——快速原型。如1中所述。Docstrings部分，这些库比我们有更多的检查。</p><h2 id="ea5f" class="nz me it bd mf oa ob dn mj oc od dp mn kr oe of mp kv og oh mr kz oi oj mt ok bi translated">我们能做些什么呢？</h2><p id="b1c8" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">使用<a class="ae lv" href="https://docs.python.org/3/library/enum.html#creating-an-enum" rel="noopener ugc nofollow" target="_blank">enum</a>和棉绒。枚举准确地抓住了我们的意图——实例是一个仅来自定义的可能值列表的值。为了安全起见，稍微多写一些代码。</p><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="63ce" class="nt me it np b be nu nv l nw nx">from enum import Enum<br/><br/>class SolverAlgorithm(Enum):<br/>    LBFGS = 0<br/>    SAGA = 1<br/>    SAG = 2<br/>    <br/>def fit(solver: SolverAlgorithm = SolverAlgorithm.LBFGS):<br/>    <br/>    if solver == SolverAlgorithm.LBFGS:<br/>        pass<br/>    elif solver == SolverAlgorithm.SAGA:<br/>        pass<br/>    elif solver == SolverAlgorithm.SAG:<br/>        pass<br/>    else:<br/>        raise ValueError</span></pre><p id="6b75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，mypy的穷举检查只能通过编写更多的代码来实现。见<a class="ae lv" href="https://hakibenita.com/python-mypy-exhaustive-checking#exhaustiveness-checking" rel="noopener ugc nofollow" target="_blank">此处</a>(上一次我这么试的时候，mypy还是没有给我任何警告)。</p><h1 id="8c60" class="md me it bd mf mg oo mi mj mk op mm mn jz oq ka mp kc or kd mr kf os kg mt mu bi translated">4.列出跨多行的理解</h1><p id="b4c9" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">虽然理解(如此命名是为了包括列表、字典和生成器理解)相当简洁，但是如果代码有以下一种以上的情况，它们会变得非常难以阅读:</p><ul class=""><li id="95b8" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld ny ng nh ni bi translated">if-else子句</li><li id="60d6" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">多行</li><li id="c991" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">嵌套理解</li></ul><p id="8226" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可读性大打折扣，尤其是对于那些喜欢顺序阅读代码的人。</p><p id="9c5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这看起来不错:</p><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="d497" class="nt me it np b be nu nv l nw nx">document = [<br/>    preprocess(sentence)<br/>    if len(sentence) &gt; 20 else sentence + "\n"<br/>    for sentence in sentences<br/>]</span></pre><p id="701b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，这仍然很好，尽管读起来有点挑战性，因为你的眼睛需要从中间的<code class="fe ot ou ov np b">for</code>开始，然后去寻找下一个<code class="fe ot ou ov np b">for</code>，然后去第一个<code class="fe ot ou ov np b">x</code>。</p><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="e1a8" class="nt me it np b be nu nv l nw nx">nested_list = [[1,2,3],[4,5,6],[7,8,9]]<br/><br/>new_list = [<br/>    x for sub_list in nested_list for x in sub_list<br/>]</span></pre><p id="66cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是最糟糕的。简洁？不，谢谢你。</p><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="6008" class="nt me it np b be nu nv l nw nx">nested_list = [[1,2,3],[4,5,6],[7,8,9]]<br/><br/>new_list = [<br/>    x if x &gt; 4 else -1 <br/>    for sub_list in nested_list <br/>    for x in sub_list<br/>    if sum(sub_list) &gt; 6<br/>]<br/>view raw</span></pre><h2 id="cfca" class="nz me it bd mf oa ob dn mj oc od dp mn kr oe of mp kv og oh mr kz oi oj mt ok bi translated">我们能做些什么呢？</h2><ul class=""><li id="3c62" class="na nb it kk b kl mv ko mw kr ol kv om kz on ld ny ng nh ni bi translated">缩进理解，并适当地将从句分成不同的行。</li><li id="a4c7" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">使用可读性更强的变量名。</li><li id="be14" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld ny ng nh ni bi translated">请改用for循环，尤其是对于嵌套的理解。牺牲一点速度和简洁来获得更高的可读性。</li></ul><pre class="lg lh li lj gt no np nq bn nr ns bi"><span id="16bc" class="nt me it np b be nu nv l nw nx">nested_list = [[1,2,3],[4,5,6],[7,8,9]]<br/><br/>new_list = []<br/>for sub_list in nested_list:<br/>    if sum(sub_list) &lt;= 6:<br/>        continue<br/>    for x in sub_list:<br/>        item = x if x &gt; 4 else -1<br/>        new_list.append(item)</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="7e2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">暂时就这样吧！感谢阅读。</p><h1 id="3aef" class="md me it bd mf mg oo mi mj mk op mm mn jz oq ka mp kc or kd mr kf os kg mt mu bi translated">参考</h1><p id="9b62" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated"><a class="ae lv" href="https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/" rel="noopener ugc nofollow" target="_blank">务实的程序员</a></p><p id="2e79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">感谢</em> <a class="ow ox ep" href="https://medium.com/u/f392dd76f846?source=post_page-----a6d5023c8473--------------------------------" rel="noopener" target="_blank"> <em class="le">钟大伟</em> </a> <em class="le">和</em> <a class="ow ox ep" href="https://medium.com/u/1d3591a5a4b4?source=post_page-----a6d5023c8473--------------------------------" rel="noopener" target="_blank"> <em class="le">梁齐威</em> </a> <em class="le">审阅本文！</em></p></div></div>    
</body>
</html>