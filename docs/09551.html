<html>
<head>
<title>How Dynamic Importing Helps Increase the Performance of JavaScript Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态导入如何帮助提高JavaScript应用程序的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/master-dynamic-imports-in-under-5-minutes-a0a06a4f43ae?source=collection_archive---------5-----------------------#2021-09-08">https://betterprogramming.pub/master-dynamic-imports-in-under-5-minutes-a0a06a4f43ae?source=collection_archive---------5-----------------------#2021-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6453" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">掌握动态导入以提高应用程序的速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/43576ab196188b955625012867843907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLWvXJvxpNBR2GUjZ_NIDg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com/s/photos/programmer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3e9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经开发过大型React应用程序，您会知道动态呈现组件和/或库的能力可以让您的应用程序获得更好的性能。随着您的小应用程序变得越来越大，它的JavaScript包也会变得越来越大，这会导致很长的加载时间。</p><p id="af8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的应用程序加载的时间越长，人们就越不可能等到它完成后再转向另一个应用程序。这就失去了潜在的客户，这反过来会导致更少的转换，让你少赚钱。</p><p id="846e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，随着代码的积累，我如何确保我的应用程序快速加载呢？</p><p id="cb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然是通过代码分解。</p><p id="aeab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在React中引入代码分割的最常见方式之一是通过动态导入。代码分割更多的是高级主题的中间，但是我在这里解释它是如何工作的，除了混乱。</p><p id="a3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入React中的动态导入之前，我们必须首先熟悉什么是代码分割，以及为什么它对我们很重要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="44f2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码分割</h1><p id="d848" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">代码分割是将应用程序的JS包“分割”成更小的包的行为，这些包在加载时动态呈现。一旦我们开始一个新的React应用程序，我们所有的代码都被累积成一个包。从这里开始，我们添加到应用程序中的特性越多，添加到捆绑包中的代码就越多。</p><p id="7258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何React应用程序的包大小应该只有500KB。这可能看起来很小，特别是对于较大的应用程序，但这是一个很好的基准，可以确保我们的应用程序为用户加载得足够快。</p><p id="434d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以这样看待代码分解:假设你的任务是用手推车在工地上搬运1000块砖。如果你真的想的话，你可以试着把所有的1000块砖都装进手推车里——假设的话——然后在一次旅行中把它们都运走。这种方法的缺点是，考虑到这些砖块不会很轻，它可能会花费你很长时间。好处是你只需要做一次旅行，而不是多次。</p><p id="981e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">负荷越大，你就会越慢。</p><p id="f240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，你可以用100块砖头或任何其他组合进行10次单独的旅行。这种方法的缺点是您必须进行多次旅行，但优点是您可以比第一种方法更快地让它们穿过工地。</p><p id="c48a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于速度和效率是软件游戏的名称，第二种方法对这种情况最有意义。在拆分我们的JS包时也可以这么说。</p><p id="7f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们如何着手对未来的应用程序进行代码拆分呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb6d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态导入</h1><p id="87be" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您熟悉React，那么您应该知道将代码分割引入应用程序的一个简单方法是使用动态导入语法。</p><p id="9dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看两个稍微不同的例子，它们完成了同样的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">静态导入</p></figure><p id="903b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子演示了我们如何在React中使用静态导入。这里我们从我们的<code class="fe nb nc nd ne b">Math</code>库中静态导入<code class="fe nb nc nd ne b">multiply()</code>方法。</p><p id="8549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而下面的例子展示了我们如何通过在<code class="fe nb nc nd ne b">handleMultiplication()</code>中动态导入<code class="fe nb nc nd ne b">multiply()</code>方法来实现相同的功能。每次我们单击按钮，两个随机数的乘积就会被记录到控制台。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">动态导入</p></figure><p id="7006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么哪个选项更好呢？</p><p id="11d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人惊讶的是，这是第一个选项。即使我们在第二个例子中动态地导入我们的方法，这种方式也不比第一个更有效。老实说，可能会更糟。</p><p id="9e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但我记得你说过动态导入库会带来更好的性能？</p><p id="9f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们有机会在应用程序中的任何地方使用动态导入，但这并不意味着我们应该这样做。</p><p id="3414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个更有用的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="51d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的应用程序有几个页面，<code class="fe nb nc nd ne b">Home</code>和<code class="fe nb nc nd ne b">Settings</code>。当我们的应用程序加载时，用户会看到主页，并可以通过单击<code class="fe nb nc nd ne b">Change Page</code>按钮切换他们想要显示的页面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="33bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意home和settings组件几乎是彼此的精确副本。</p><p id="6ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个组件都动态导入我们的<code class="fe nb nc nd ne b">pageData()</code>方法，为了简单起见，该方法返回当前显示的页面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="74a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在页面之间切换时，我们可以看到，随着每个组件的呈现，我们的输出会根据所显示的页面而变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/977f6750c61b99e6638737e0f670ac94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*iCpf9K7VdqRwXFM-tzTaEA.png"/></div></figure><p id="48bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这和静态导入<code class="fe nb nc nd ne b">pageData()</code>有什么不同？</p><p id="04e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设用户很少导航到设置页面。如果这个页面从来没有被访问过，那么我们就没有必要加载随之而来的数据。当我们在<code class="fe nb nc nd ne b">useEffect()</code>中动态导入我们的方法时，我们实际上是在“延迟加载”我们的数据，从长远来看，这最终为我们节省了一些性能。</p><p id="4164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，我们避免了加载用户可能不需要的冗余代码。这反过来又减少了应用程序初始加载时所需的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8b2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="67d0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们的应用程序中实现更好的性能可能是一项艰巨的任务，但却是值得的。像代码分割这样的编程方法是提高应用程序性能的有效方法。关于如何分割JavaScript包，有各种各样的主题，但是这个主题是最简单的。</p><p id="4946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们刚刚看到的，有些时候使用动态导入是最好的，也可以增加冗余。所以我们必须明智地使用它，不要随便用它。</p><p id="a1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这能让您有所了解，并为您未来或现有的应用程序增加一些性能。</p><p id="ebc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。下一集见。</p></div></div>    
</body>
</html>