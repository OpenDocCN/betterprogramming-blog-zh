<html>
<head>
<title>Traffic Mirroring in Kubernetes Using Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Istio在Kubernetes中进行流量镜像</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/traffic-mirroring-in-kubernetes-using-istio-dad0976b4e1?source=collection_archive---------5-----------------------#2020-05-22">https://betterprogramming.pub/traffic-mirroring-in-kubernetes-using-istio-dad0976b4e1?source=collection_archive---------5-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c52c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何为您的Kubernetes微服务运行可靠的运行验收测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c6cba627098e3d5c3b83e7fd12a0816c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOg4ZlvI8cwy93rnnLVXMw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ashim D'Silva 在<a class="ae ky" href="https://unsplash.com/s/photos/mirror?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让应用程序的多个版本同时运行给了您相当大的灵活性。它使您能够根据需要在不同版本之间切换和转回流量。它允许您进行canary发布、A/B测试以及受控的生产推广。</p><p id="cbcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着微服务和容器编排平台的出现，如<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>来支持它，它已经成为新的规范。借助<a class="ae ky" href="https://istio.io" rel="noopener ugc nofollow" target="_blank"> Istio </a>，您可以通过流量镜像创建一个健壮的部署和发布策略。</p><p id="89db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是"<a class="ae ky" href="https://medium.com/better-programming/kubernetes-services-over-https-with-istios-secure-gateways-210b2ce91b71" rel="noopener"> Kubernetes通过Istio的安全网关在HTTPS提供服务的后续文章。</a>“今天我们来讨论一下<em class="lv">流量镜像。</em></p><p id="9af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流量镜像，也称为阴影，是一个强大的概念，近年来越来越受欢迎。这是在生产环境中测试您的版本的无风险方法，不会影响您的最终用户。</p><p id="bc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数传统企业都有一个生产前环境，它过去是生产的复制品。运营团队将版本部署到预生产环境中，测试人员在其中创建模拟真实环境的合成流量。</p><p id="c346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得团队能够理解代码在生产环境中的行为，以及代码在功能上和非功能上是否准备好部署到生产环境中。</p><p id="3d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们使用预生产环境对其应用程序进行性能测试、容量测试和操作验收测试。</p><p id="b95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这一切听起来不错，但也不是没有问题。在传统的基础设施中，您在创建静态测试环境上花费了大量的金钱和资源。你付钱给工程师来维护产品的复制品。</p><p id="b601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数合成流量不同于实时流量，因为实时流量是当前的用户交互，而人工流量依赖于历史数据。错过那里的许多场景也不是一个例外。</p><p id="9016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流量镜像允许您实施类似的操作验收测试设置。它允许您在不影响最终用户的情况下使用实时流量进行测试。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d53f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">流量镜像的工作原理</h1><p id="7033" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">流量镜像使用以下步骤工作:</p><ol class=""><li id="db6d" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">您部署了新版本的应用程序，并打开了流量镜像。</li><li id="b5c0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">旧版本像以前一样响应请求，但也向新版本发送异步副本。</li><li id="44a9" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">新版本处理流量，但不响应用户。</li><li id="eff4" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">运营团队监控新版本，并向开发团队报告任何问题。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8cd6c1e4186bfa57ed273b22f87224c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*P_c0Vlpur7QjfM_N8kstEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流量镜像</p></figure><p id="bc53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应用程序处理实时流量时，它可以帮助团队发现他们在预生产环境中通常不会发现的问题。您可以使用监控工具，如<a class="ae ky" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>和<a class="ae ky" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>来记录和监控您的测试结果。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cdfb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">先决条件</h1><p id="9861" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我将演示如何使用Istio在Kubernetes集群上进行流量镜像。要熟悉Istio，请查看“<a class="ae ky" href="https://medium.com/better-programming/how-to-manage-microservices-on-kubernetes-with-istio-c25e97a60a59" rel="noopener">如何使用Istio管理Kubernetes上的微服务</a>”</p><p id="7004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要有一个正在运行的Kubernetes集群来遵循实际操作指南。在本练习中，您可以使用一个托管的Kubernetes集群，比如Google Kubernetes引擎。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="35c7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">部署Nginx应用程序</h1><p id="172c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">按照“<a class="ae ky" href="https://medium.com/better-programming/getting-started-with-istio-on-kubernetes-e582800121ea" rel="noopener">Kubernetes上的Istio入门</a>”指南，在您的Kubernetes集群中安装Istio。对于此演示，您不需要安装图书信息应用程序。</p><p id="2599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes上部署<a class="ae ky" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>的两个版本(<code class="fe np nq nr ns b">v1</code>和<code class="fe np nq nr ns b">v2</code>)。</p><p id="6038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署<code class="fe np nq nr ns b">nginx:v1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">展开<code class="fe np nq nr ns b">nginx:v2</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过服务公开Nginx应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署睡眠微服务，向应用程序发送流量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="018b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去拿豆荚看看是否准备好了。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="4336" class="nz me it ns b gy oa ob l oc od">$ kubectl get pod<br/>NAME                        READY   STATUS    RESTARTS   AGE<br/>nginx-v1-5ff9f64978-bwtqh   2/2     Running   0          3m36s<br/>nginx-v2-596ffd86d7-89n99   2/2     Running   0          19s<br/>sleep-674f75ff4d-cmt7p      2/2     Running   0          2m25s</span></pre><p id="0513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们向Nginx服务发送一些流量。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="6e45" class="nz me it ns b gy oa ob l oc od">$ export SLEEP_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})<br/>$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 1<br/>$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 2<br/>$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 2</span></pre><p id="7efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe np nq nr ns b">nginx:v1</code>和<code class="fe np nq nr ns b">nginx:v2</code>之间的交通流量相等。检查两个版本的日志。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="1bd3" class="nz me it ns b gy oa ob l oc od">$ export V1_POD=$(kubectl get pod -l app=nginx,version=v1 -o jsonpath={.items..metadata.name})<br/>$ kubectl logs $V1_POD -c nginx<br/>127.0.0.1 - - [13/May/2020:23:05:11 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"<br/>$ export V2_POD=$(kubectl get pod -l app=nginx,version=v2 -o jsonpath={.items..metadata.name})<br/>$ kubectl logs $V2_POD -c nginx<br/>127.0.0.1 - - [13/May/2020:23:05:12 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"<br/>127.0.0.1 - - [13/May/2020:23:05:13 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"</span></pre><p id="c407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在两个豆荚上都看到了日志，这证实了我们的发现。让我们删除pod以清除日志。Kubernetes用新鲜的豆荚替换被删除的豆荚。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="d589" class="nz me it ns b gy oa ob l oc od">$ kubectl delete pod $V1_POD<br/>pod "nginx-v1-5ff9f64978-bwtqh" deleted<br/>$ kubectl delete pod $V2_POD<br/>pod "nginx-v2-596ffd86d7-89n99" deleted<br/>$ kubectl get pod<br/>NAME                        READY   STATUS    RESTARTS   AGE<br/>nginx-v1-5ff9f64978-9vzhm   2/2     Running   0          46s<br/>nginx-v2-7cb4b5c868-86s5m   2/2     Running   0          34s<br/>sleep-674f75ff4d-cmt7p      2/2     Running   0          30m</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5acf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建虚拟服务和目标规则</h1><p id="d38c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在让我们创建一个destinations规则来定义到两个版本的路由，并创建一个虚拟服务来将所有流量路由到<code class="fe np nq nr ns b">nginx:v1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="994e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们产生一些流量，看看它去哪里。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="a038" class="nz me it ns b gy oa ob l oc od">$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 1<br/>$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 1<br/>$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 1</span></pre><p id="20d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们收到了来自<code class="fe np nq nr ns b">nginx:v1</code>的所有回复。查询两个版本的日志。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="8a26" class="nz me it ns b gy oa ob l oc od">$ export V1_POD=$(kubectl get pod -l app=nginx,version=v1 -o jsonpath={.items..metadata.name})<br/>$ kubectl logs $V1_POD -c nginx<br/>127.0.0.1 - - [13/May/2020:23:08:11 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"<br/>$ export V2_POD=$(kubectl get pod -l app=nginx,version=v2 -o jsonpath={.items..metadata.name})<br/>$ kubectl logs $V2_POD -c nginx<br/>&lt;none&gt;</span></pre><p id="ffe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有记录<code class="fe np nq nr ns b">nginx:v2</code>的日志。不出所料，没有流量流向<code class="fe np nq nr ns b">v2</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3f4b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">镜像流量</h1><p id="88fe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">核心部分来了。让我们将流量镜像到<code class="fe np nq nr ns b">nginx:v2</code>，并通过应用下面的YAML来亲眼看看发生了什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果观察YAML，航线仍然以<code class="fe np nq nr ns b">nginx:v1</code>为目的地；但是，它包括一个镜像部分，将100%的流量镜像到<code class="fe np nq nr ns b">nginx:v2</code>。因此，<code class="fe np nq nr ns b">nginx:v1</code>主动响应请求，<code class="fe np nq nr ns b">nginx:v2</code>异步接收流量。请记住，请求是一劳永逸的:<code class="fe np nq nr ns b">nginx:v2</code>不会响应请求者。</p><p id="c736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个设置中，我们将<code class="fe np nq nr ns b">mirror_percent</code>设置为100，这意味着我们将整个流量镜像到<code class="fe np nq nr ns b">nginx:v2</code>。您可以将其更改为更适合您的用例的值。如果不包括<code class="fe np nq nr ns b">mirror_percent</code>字段，Istio会将所有流量镜像到<code class="fe np nq nr ns b">nginx:v2</code>。</p><p id="1d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们发送流量三次，看看我们得到了什么。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="9b03" class="nz me it ns b gy oa ob l oc od">$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 1<br/>$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 1<br/>$ kubectl exec -it $SLEEP_POD -c sleep -- sh -c 'curl  <a class="ae ky" href="http://nginx:8000'" rel="noopener ugc nofollow" target="_blank">http://nginx:8000'</a><br/>This is version 1</span></pre><p id="956b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次发送请求时，我们都会得到“这是版本1”。让我们检查两个服务的日志。</p><pre class="kj kk kl km gt nv ns nw nx aw ny bi"><span id="2ff9" class="nz me it ns b gy oa ob l oc od">$ kubectl logs $V1_POD -c nginx<br/>127.0.0.1 - - [13/May/2020:23:08:11 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"<br/>127.0.0.1 - - [13/May/2020:23:15:27 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"<br/>127.0.0.1 - - [13/May/2020:23:15:31 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"<br/>127.0.0.1 - - [13/May/2020:23:15:33 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "-"</span><span id="038a" class="nz me it ns b gy oe ob l oc od">$ kubectl logs $V2_POD -c nginx<br/>127.0.0.1 - - [13/May/2020:23:15:27 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "10.4.2.9"<br/>127.0.0.1 - - [13/May/2020:23:15:31 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "10.4.2.9"<br/>127.0.0.1 - - [13/May/2020:23:15:33 +0000] "GET / HTTP/1.1" 200 18 "-" "curl/7.35.0" "10.4.2.9"</span></pre><p id="ef74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生了什么事？我们得到了来自<code class="fe np nq nr ns b">nginx:v1</code>的所有响应，但是我们也看到了来自<code class="fe np nq nr ns b">v2 </code>的日志。如果您查看日志时间戳，在<code class="fe np nq nr ns b">v2</code>的日志与在<code class="fe np nq nr ns b">v1</code>的日志相匹配，并且它们是同时发生的。这表明流量镜像工作正常。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="759a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="d096" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章</p><p id="c1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流量镜像可以帮助团队发现使用传统基础设施通常无法发现的错误。这是对您的发布进行操作验收测试的最有效的方法之一。这为您省去许多麻烦，并有助于避免客户事故。</p><p id="1bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个故事是“<a class="ae ky" href="https://medium.com/better-programming/locality-based-load-balancing-in-kubernetes-using-istio-a4a9defa05d3" rel="noopener">使用Istio </a>在Kubernetes中实现基于位置的负载平衡”，所以我们在那里见！</p></div></div>    
</body>
</html>