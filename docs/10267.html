<html>
<head>
<title>How to Turn an Array of Observable Into an Observable of Array in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将一个可观测数组转化为一个角度可观测数组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-turn-an-array-of-observable-into-an-observable-of-array-in-angular-d6cfe42a72d4?source=collection_archive---------1-----------------------#2021-12-20">https://betterprogramming.pub/how-to-turn-an-array-of-observable-into-an-observable-of-array-in-angular-d6cfe42a72d4?source=collection_archive---------1-----------------------#2021-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1935" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">把可观察的<object> []变成可观察的<object/></object></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8afd8c557d0cb6d62d81316a2935cd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JvjskQhsWbwu6DideKnIKw.png"/></div></div></figure><p id="5fbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在角度应用中，拥有一组可观测数据很容易。如果处理不当，可能会导致一些可怕的代码。</p><p id="5cba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个发生这种问题的真实例子。考虑以下服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="b1ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有一个通过HTTP GET获取用户的方法。另一个方法也使用HTTP GET获取所有用户的订单，但这次使用用户的id作为参数。</p><p id="8589" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们需要设置一个组件来显示所有用户以及每个用户的所有订单。</p><h1 id="9249" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">丑陋的解决方案:链接订阅</h1><p id="04cd" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">让我们来看看最糟糕的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="2f1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始讨论这个解决方案之前，让我们澄清一件事，这个解决方案非常适合我们需要做的事情。我知道我可能应该取消订阅，我可以创建一个更好的“用户/订单”数据模型。但是除此之外，我们可以在模板中使用<code class="fe mp mq mr ms b">orders</code> <em class="mt"> </em>和<code class="fe mp mq mr ms b">users</code>对象，这样就可以了。</p><h2 id="7e70" class="mu lt it bd lu mv mw dn ly mx my dp mc ld mz na me lh nb nc mg ll nd ne mi nf bi translated">那么，它有什么问题呢？</h2><ol class=""><li id="1d29" class="ng nh it kw b kx mk la ml ld ni lh nj ll nk lp nl nm nn no bi translated">很难读。对象在不同的地方被定义和编辑。随着我们的组件变得越来越大，这可能会导致混乱。</li><li id="1c6c" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">使用subscribe使得无法使用异步管道</li><li id="7fb5" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">这很难维护，想象一下，如果我们需要为每个<code class="fe mp mq mr ms b">order</code>添加另一个请求，或者需要从用户那里获取更多的数据。有可能，但是有很多工作要做。</li></ol><h1 id="3976" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">一个更好的解决方案:结合可观察的</h1><p id="2527" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">下一个解决方案是使用一种更具反应性的方法，更接近RxJS和Angular最佳实践。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们定义了一个“结果”可观察对象<code class="fe mp mq mr ms b">usersWithOrders$</code>，它意味着包含最终数据。</p><p id="3349" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了获得这些数据，我们通过管道传输以下操作:</p><ol class=""><li id="12af" class="ng nh it kw b kx ky la lb ld nu lh nv ll nw lp nl nm nn no bi translated">获取所有用户。</li><li id="6ac9" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">将每个用户转换成一个可观察对象，该对象将检索他的订单并将用户和他的订单存储在一个对象中。</li><li id="7e34" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">我们使用<code class="fe mp mq mr ms b">forkJoin</code> ( <code class="fe mp mq mr ms b">combineLatest</code>在这种情况下也能很好地工作)将可观察的数组转化为可观察的数组。</li><li id="e6ef" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">最后，我们只需要使用<code class="fe mp mq mr ms b">switchMap</code>来订阅下一个可观察对象并发送订单请求。</li></ol><h2 id="cee5" class="mu lt it bd lu mv mw dn ly mx my dp mc ld mz na me lh nb nc mg ll nd ne mi nf bi translated">这个解决方案怎么样比较好？</h2><ol class=""><li id="b859" class="ng nh it kw b kx mk la ml ld ni lh nj ll nk lp nl nm nn no bi translated">更容易阅读。好吧，也许不是，如果你是新的角度。但除此之外，我们的IDE可以很容易地理解管道中每一步的类型，使代码可读和可理解。</li><li id="8f0c" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">因为我们没有订阅，所以它与异步管道兼容。</li><li id="0225" class="ng nh it kw b kx np la nq ld nr lh ns ll nt lp nl nm nn no bi translated">我们可以在不完全重构的情况下向它添加特性。我们可以简单地在管道中添加另一个步骤。</li></ol><h1 id="b9ca" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">另一种解决方案:重构后端</h1><p id="56a4" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在您复制粘贴这些代码并继续您的生活之前，还有最后一件事需要考虑。</p><p id="1ead" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在本文中使用的例子是非常现实的。在微服务时代，弄个<code class="fe mp mq mr ms b">UserService</code>再弄个<code class="fe mp mq mr ms b">OrderService</code>其实并不了解对方是很常见的。然而，如果每个用户总是被他的订单所获取，那么将结果和两者结合起来直接发送回去可能是一个好主意。</p><p id="d4e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非常感谢你把这篇文章看完！如果你喜欢这篇文章，请考虑订阅更多像这样的内容。</p><h1 id="756c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="70be" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">要将一个可观察的数组转换成一个数组的可观察对象，使用一个组合运算符，如<code class="fe mp mq mr ms b">forkJoin</code>或<code class="fe mp mq mr ms b">combineLatest</code></p><p id="5b17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完整源代码:<a class="ae nx" href="https://stackblitz.com/edit/rxjs-array-of-observables-to-observable" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/edit/rxjs-array-of-observables-to-observable</a></p></div></div>    
</body>
</html>