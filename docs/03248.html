<html>
<head>
<title>Introduction to TypeScript Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本类简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-typescript-classes-definition-and-inheritance-238a44c52dc4?source=collection_archive---------16-----------------------#2020-01-29">https://betterprogramming.pub/introduction-to-typescript-classes-definition-and-inheritance-238a44c52dc4?source=collection_archive---------16-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2936" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义和继承</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f834f584627f73b9f36053a00c761868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GEdOO3SLxLAy0nLpzvWHg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">里卡多·戈麦斯·安吉尔在<a class="ae ky" href="https://unsplash.com/s/photos/patterns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与JavaScript一样，TypeScript中的类是其原型继承模型的特殊语法，这与基于类的面向对象语言中的继承类似。类只是添加到ES6中的特殊函数，用来模仿其他语言中的关键字<code class="fe lv lw lx ly b">class</code>。</p><p id="620d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以有<code class="fe lv lw lx ly b">class</code>声明和<code class="fe lv lw lx ly b">class</code>表达式，因为它们只是函数。所以，像所有其他函数一样，有函数声明和函数表达式。TypeScript也是如此。类充当创建新对象的模板。TypeScript扩展了JavaScript类的语法，然后添加了自己的变体。</p><p id="0f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何定义TypeScript类以及它们如何相互继承。除了我们可以向方法的成员和参数添加类型指定之外，这个主题与JavaScript基本相同。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0b63" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">定义类别</h1><p id="508d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了声明一个类，我们使用了<code class="fe lv lw lx ly b">class</code>关键字。例如，要声明一个简单的类，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类声明没有被提升，所以在代码中定义之前不能使用它们TypeScript编译器不会自动将它们提升到顶部。另外，请注意，我们向成员添加了一些类型，以确保我们为每个成员分配了所需类型的值。因此，在代码中定义之前，上面的类不会工作，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们将得到一个<code class="fe lv lw lx ly b">ReferenceError</code>。</p><p id="0891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以通过一个类表达式来定义一个类，这是另一种语法。它们可以是命名的，也可以是未命名的。我们也可以像处理函数一样，给变量分配一个类。如果我们这样做了，我们可以通过它的名字来引用这个类。例如，我们可以定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得上面未命名的类的名称，我们可以用<code class="fe lv lw lx ly b">name</code>属性获得名称，如下所示:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="41a1" class="nj mh it ly b gy nk nl l nm nn">console.log(Person.name);</span></pre><p id="90c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以像这样定义一个命名类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得类名，我们可以再次使用<code class="fe lv lw lx ly b">name</code>属性。</p><p id="86a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果我们写<code class="fe lv lw lx ly b">console.log(Person.name)</code>，我们会记录<code class="fe lv lw lx ly b">Person2</code>。</p><p id="64a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类体是用花括号定义的。我们在括号内定义类成员。类的主体在严格模式下执行。在严格模式下定义的一切都适用于类的定义，所以我们不能像<code class="fe lv lw lx ly b">var</code>、<code class="fe lv lw lx ly b">let</code>或<code class="fe lv lw lx ly b">const</code>那样定义前面没有关键字的变量。当您定义一个类时，许多其他规则也适用。</p><p id="f0d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript中的类也有一个<code class="fe lv lw lx ly b">constructor</code>方法，让我们在用<code class="fe lv lw lx ly b">class</code>实例化对象时设置字段。每个类中只能有一个<code class="fe lv lw lx ly b">constructor</code>方法。如果不止一个，就会抛出一个<code class="fe lv lw lx ly b">SyntaxError</code>。如果类扩展了父类，那么<code class="fe lv lw lx ly b">constructor</code>也可以调用<code class="fe lv lw lx ly b">super</code>方法来调用<code class="fe lv lw lx ly b">super</code>类的<code class="fe lv lw lx ly b">constructor</code>。</p><p id="a1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">未声明的方法<code class="fe lv lw lx ly b">static</code>构成了该类的原型方法。它们在使用<code class="fe lv lw lx ly b">new</code>关键字创建一个对象后被调用。例如，下面的类只有原型方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f2f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的<code class="fe lv lw lx ly b">Person</code>类中，<code class="fe lv lw lx ly b">fullName</code>和<code class="fe lv lw lx ly b">sayHi</code>是原型方法。它们被这样称呼:</p><pre class="kj kk kl km gt nf ly ng nh aw ni bi"><span id="c663" class="nj mh it ly b gy nk nl l nm nn">const person = new Person('Jane', 'Smith');<br/>person.fullName() // 'Jane Smith'</span></pre><p id="0cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态方法是不用使用<code class="fe lv lw lx ly b">new</code>关键字从类中创建对象就可以调用的方法。例如，我们可以有这样的东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以调用<code class="fe lv lw lx ly b">personCount</code>函数而不使用<code class="fe lv lw lx ly b">new</code>关键字来创建类的实例。所以，如果我们写<code class="fe lv lw lx ly b">Person.personCount</code>，我们会得到<code class="fe lv lw lx ly b">3</code>的返回。</p><p id="d67f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原型方法中的<code class="fe lv lw lx ly b">this</code>值将是对象的值。对于静态方法，<code class="fe lv lw lx ly b">this</code>的值将静态方法所在的类作为值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6c4c52023e8cbdd836ff2affca2d730b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3DL_v778tKMCrL0u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹妮弗·哈奈特-亨德森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1785" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">类型脚本继承</h1><p id="f836" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在TypeScript中，我们可以创建一些类，这些类的属性可以包含在子类的属性中。它的工作方式与JavaScript相同。</p><p id="c3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以有一个包含所有子类共有的属性的高级类，并且子类可以有自己的特殊属性，这些属性不在任何其他类中。</p><p id="fcd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个具有公共属性和方法的<code class="fe lv lw lx ly b">Animal</code>类，比如<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">eat</code>方法，那么<code class="fe lv lw lx ly b">Bird</code>类可以继承<code class="fe lv lw lx ly b">Animal</code>类中的公共属性。它们不必在<code class="fe lv lw lx ly b">Bird</code>类中再次定义。</p><p id="6e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以编写以下代码来实现TypeScript中的继承:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有父类<code class="fe lv lw lx ly b">Animal</code>，它有<code class="fe lv lw lx ly b">eat</code>方法，来自<code class="fe lv lw lx ly b">Animal</code>的<code class="fe lv lw lx ly b">extends</code>的所有类都会有，所以它们不必再定义<code class="fe lv lw lx ly b">eat</code>。</p><p id="3567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有扩展了<code class="fe lv lw lx ly b">Animal</code>类的<code class="fe lv lw lx ly b">Bird</code>类。注意，在<code class="fe lv lw lx ly b">Bird</code>类的<code class="fe lv lw lx ly b">constructor</code>中，<code class="fe lv lw lx ly b">super()</code>函数调用父类的构造函数，填充父类和子类的属性。</p><p id="b2a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类不能扩展常规对象，常规对象不能用关键字<code class="fe lv lw lx ly b">new</code>构造。如果我们想从一个常规对象继承，我们必须使用<code class="fe lv lw lx ly b">Object.setPrototypeOf</code>函数来设置一个从常规对象继承的类。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="347b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们可以看到<code class="fe lv lw lx ly b">Bob eats</code>和<code class="fe lv lw lx ly b">Joe eats</code>被记录——因为我们已经从<code class="fe lv lw lx ly b">Animal</code>对象继承了<code class="fe lv lw lx ly b">eat</code>函数。正如您所看到的，我们必须放弃TypeScript的类型检查特性，通过一个类继承一个对象。如果我们决定采用TypeScript，我们可能应该避免使用它。</p><p id="5e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类充当创建新对象的模板。TypeScript扩展了JavaScript类的语法，然后添加了自己的变体。TypeScript中定义类的方式与JavaScript相同。此外，TypeScript类之间在如何相互继承或如何从类创建新对象方面没有区别。</p></div></div>    
</body>
</html>