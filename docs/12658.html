<html>
<head>
<title>The Power of the Visitor Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中访问者设计模式的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-the-visitor-design-pattern-in-javascript-ca68a654a5df?source=collection_archive---------14-----------------------#2022-06-20">https://betterprogramming.pub/the-power-of-the-visitor-design-pattern-in-javascript-ca68a654a5df?source=collection_archive---------14-----------------------#2022-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3fef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让JavaScript访问者有宾至如归的感觉</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cf0084d2316e8c75635b95426cac1dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*wm11fyJmRombMcmV.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><em class="ku">照片由帕拉丝·卡特瓦尔拍摄:</em><a class="ae kv" href="https://www.pexels.com/photo/computer-with-code-4218883/" rel="noopener ugc nofollow" target="_blank"><em class="ku">https://www.pexels.com/photo/computer-with-code-4218883/</em></a></p></figure><p id="739d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在开发web应用程序时，一个非常有价值的强大策略是访问者设计模式。这篇文章将回顾JavaScript中的访问者模式，并删除一些重要的概念和技术，这些是每个JavaScript开发人员在使用<code class="fe ls lt lu lv b">Visitor</code>时必须知道的。</p><p id="8d67" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">根据我的经验，<code class="fe ls lt lu lv b">Visitor</code>是最难理解的模式之一，无论是从代码角度还是从视觉角度来看都是如此，但是一旦你掌握了其中的窍门，它实际上并不是那么糟糕。</p><p id="8657" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们大多发现访问者是在库或框架中实现的，所以如果你没有使用过很多库或框架，你可能还没有使用过访问者。当库作者寻求可扩展性时，它们最有用。</p><p id="b81f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">完成访问者模式需要两个主要参与者(不包括客户机代码):</p><ol class=""><li id="b22f" class="lw lx it ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">具有<code class="fe ls lt lu lv b">accept</code>方法的元素(按照惯例，我们将该方法命名为<code class="fe ls lt lu lv b">"accept"</code></li><li id="dc40" class="lw lx it ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">定义<code class="fe ls lt lu lv b">visit</code>方法的访问者。这是他们在感兴趣的元素上运行逻辑的地方。</li></ol><p id="3407" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">实现<code class="fe ls lt lu lv b">visit</code>方法的对象将正在讨论的<code class="fe ls lt lu lv b">element</code>(或者更正式的说法是节点)作为参数。正是在这个时候，访问者可以对他们感兴趣的对象执行他们想要的逻辑。</p><p id="c84d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果我们正在创作一个库，并且我们提供了一个在遍历(或一些循环操作)过程中调用其方法的<code class="fe ls lt lu lv b">Visitor</code>，那么我们可以通过这个调用轻松地为客户端实现某种形式的可扩展性。</p><p id="2387" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">例如，假设我们有这样一个元素集合(表示<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank"> DOM </a>节点，但不是实际的DOM节点):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4be8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">假设我们正在构建一个小而简单的JavaScript库，它允许代码的消费者提供任何元素集合，并让他们能够轻松地提供自己的函数，这些函数可以根据他们的意愿转换他们的键/值。</p><p id="6c0e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们可以提供一个API来遍历DOM树中的每个元素，并允许它们将自己的函数作为转换器来传递，以操作它们感兴趣的节点。</p><p id="2535" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">首先，我们将定义我们的基类<code class="fe ls lt lu lv b">Node</code>，它接收<code class="fe ls lt lu lv b">element</code>并将其存储在内部:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a626" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们的<code class="fe ls lt lu lv b">Node</code>类定义了通过访问者的<code class="fe ls lt lu lv b">visit</code>方法调用访问者的<code class="fe ls lt lu lv b">accept</code>方法。此外，它通过<code class="fe ls lt lu lv b">this</code>将自己作为参数传递，因此访问者能够自由地操纵原始元素。</p><p id="db06" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">接下来，我们将有一个基础<code class="fe ls lt lu lv b">Visitor</code>类，所有未来的访问者都将从该类派生:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="2a1f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">有了这些，我们现在就可以开始创建访问者了。</p><p id="b7d9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">先说一个<code class="fe ls lt lu lv b">SelectOptionsVisitor</code>访客。这个<code class="fe ls lt lu lv b">visitor</code>将对选择元素感兴趣，并让客户设置自定义选项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="eaaf" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们作为客户端，创建它的一个实例。我们将使我们的<code class="fe ls lt lu lv b">visitor</code>将所有选择选项设置为<code class="fe ls lt lu lv b">"Monday"</code>、<code class="fe ls lt lu lv b">"Tuesday"</code>、<code class="fe ls lt lu lv b">"Wednesday"</code>、<code class="fe ls lt lu lv b">"Thursday"</code>、<code class="fe ls lt lu lv b">"Friday"</code>、<code class="fe ls lt lu lv b">"Saturday"</code>和<code class="fe ls lt lu lv b">"Sunday"</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e779" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在我们需要一些方法让回调在循环操作中到达每个元素。像<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> babel </a>这样的库提供了一个名为<a class="ae kv" href="https://babeljs.io/docs/en/babel-traverse" rel="noopener ugc nofollow" target="_blank"> traverse </a>的工具来做这件事。</p><p id="c2b5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们用我们自己的简单遍历器来演示，它将迭代每个节点并调用它们的<code class="fe ls lt lu lv b">accept</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="18ff" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在，让我们使用新的<code class="fe ls lt lu lv b">traverse</code>函数，并将我们在第一个代码片段中的元素列表传递给它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d568" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在，如果我们查看我们的select元素，我们会注意到它被转换为包含一周的七天，如<code class="fe ls lt lu lv b">options</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/116e217cc1f95064aafff5a7d1a34373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PLBOagc3MVHIE5oN.png"/></div></div></figure><p id="aa14" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果你像我一样，你可能会有一个奇怪的习惯，将不同的图案与不同的水果联系起来。是的，像苹果和香蕉这样的水果。我将<code class="fe ls lt lu lv b">Visitor</code>模式与苹果联系在一起，因为就像苹果一样，它们提供许多好处，例如:</p><ol class=""><li id="fa6a" class="lw lx it ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><a class="ae kv" href="https://stackify.com/solid-design-open-closed-principle/" rel="noopener ugc nofollow" target="_blank">开/闭原则</a>——罗伯特·马丁认为，这个原则是“面向对象设计最重要的原则”访问者允许开发人员引入新的行为，他们可以在不改变实现的情况下处理不同类的不同对象。</li><li id="0893" class="lw lx it ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任</a> —您可以将同一行为的多个版本移动到同一类中。由于访问者在一个不能从外部直接访问的块中实现他们的逻辑，很容易让他们专注于一个目标。</li><li id="aa89" class="lw lx it ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">当处理各种对象时，访问者可以收集非常有用的信息，这在处理复杂的树结构时会变得非常方便。<a class="ae kv" href="https://eemeli.org/yaml/#modifying-nodes" rel="noopener ugc nofollow" target="_blank"> YAML </a> JavaScript库通过异步支持更进一步。</li></ol><h2 id="591e" class="mr ms it bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">需要注意的事项</h2><ul class=""><li id="03b8" class="lw lx it ky b kz nk lc nl lf nm lj nn ln no lr np mc md me bi translated">每当访问者删除或添加新的节点到树中，他们必须更新所有的访问者，否则他们将导致错误。</li><li id="48d3" class="lw lx it ky b kz mf lc mg lf mh lj mi ln mj lr np mc md me bi translated">如果处理树的类没有实现<code class="fe ls lt lu lv b">accept</code>操作，那么访问者将不再为它们工作。</li><li id="b782" class="lw lx it ky b kz mf lc mg lf mh lj mi ln mj lr np mc md me bi translated">大多数库没有将这些节点实现为不可变的对象，所以要注意会产生任何副作用！</li><li id="7dcb" class="lw lx it ky b kz mf lc mg lf mh lj mi ln mj lr np mc md me bi translated">访问者不应该知道节点的树结构。应该允许元素在它的任何底层元素(例如子元素)上调用访问者。</li></ul><h1 id="135d" class="nq ms it bd mt nr ns nt mw nu nv nw mz jz nx ka nc kc ny kd nf kf nz kg ni oa bi translated">与其他模式的比较</h1><h2 id="76e3" class="mr ms it bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">命令设计模式</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ob"><img src="../Images/4a31b299fb30aa317b95b0615c2b792e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zl7yasNnt5RPXkYw.jpg"/></div></div></figure><p id="5914" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">由于访问者可以在他们感兴趣的某些对象上运行操作，因此可以将它们视为根据对象或类触发的调度“命令”。</p><h2 id="438b" class="mr ms it bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">复合设计模式</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/87cb037c01a41b8544255ef514d90bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*_hgP2Hjo9-G8Pet8.jpg"/></div></figure><p id="e780" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">当使用树结构时(例如像<a class="ae kv" href="https://babeljs.io/docs/en/babel-parser" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>),它们通常被实现为复合结构，这样客户端代码可以使用所有对象。访问者模式有着相似的目标，所以将访问者和复合模式结合在一起是一个强大的实践。</p><h2 id="7d49" class="mr ms it bd mt mu mv dn mw mx my dp mz lf na nb nc lj nd ne nf ln ng nh ni nj bi translated">迭代器设计模式</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi od"><img src="../Images/f4d165c6d305117420409ad95927ba13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JmCGcZPfyRdLESnR.png"/></div></div></figure><p id="57eb" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">另一个强大的组合是迭代器和访问者模式。使用迭代器模式，通常有一个接口暴露给客户机，以注入它们自己的算法来迭代每个对象。这种方法有一些限制，比如能够深度访问任何子树的子树。</p><p id="f9a4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated"><code class="fe ls lt lu lv b">visitor</code>模式可以帮助用递归来填补这个空白，所以它非常强大。点击<a class="ae kv" href="https://medium.com/better-programming/the-power-of-iterator-design-pattern-in-javascript-e8a9ec703fb5" rel="noopener">此处</a>查看示例。</p><h1 id="c4ef" class="nq ms it bd mt nr ns nt mw nu nv nw mz jz nx ka nc kc ny kd nf kf nz kg ni oa bi translated">结论</h1><p id="15e7" class="pw-post-body-paragraph kw kx it ky b kz nk ju lb lc nl jx le lf oe lh li lj of ll lm ln og lp lq lr im bi translated">我希望你发现这是有价值的。以后多多关照！</p></div></div>    
</body>
</html>