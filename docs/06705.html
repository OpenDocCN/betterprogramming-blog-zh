<html>
<head>
<title>How to Secure iOS App Secret Data With Hashicorp Vault</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Hashicorp Vault保护iOS应用程序机密数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-secure-ios-app-secret-data-with-hashicorp-vault-c27ec17ef5fd?source=collection_archive---------8-----------------------#2020-10-27">https://betterprogramming.pub/how-to-secure-ios-app-secret-data-with-hashicorp-vault-c27ec17ef5fd?source=collection_archive---------8-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f7e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">与iOS应用程序集成保管库的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c9a38981eb7bcfc9b9bd5ffc4706057f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRL91xXOHudF68fBMIBubw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://stockfresh.com/" rel="noopener ugc nofollow" target="_blank"> Stockfresh </a>上<a class="ae kv" href="https://stockfresh.com/image/241034/bank-vault" rel="noopener ugc nofollow" target="_blank"> kjpargeter </a>拍摄的照片。</p></figure><p id="f1fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开发移动应用程序时，我们无时无刻不在与API进行交互。为了连接到这些API，我们使用API键。这些API键非常重要，因为它们将我们映射/标识为我们试图集成的系统的唯一用户。我们总是需要确保这些API键不会被非预期的用户访问。速率限制、配额控制和安全性是API提供者拥有API密钥的部分原因。</p><p id="314f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">良好的安全实践之一是不要将秘密和API密匙保存为源代码的一部分。但是如果我们不把它们放在源代码中，我们的代码将如何知道它们并消费它们呢？这个问题的答案是使用一种叫做“保险库”的安全工具有各种存储库选项来存储机密。我们将谈论<a class="ae kv" href="https://learn.hashicorp.com/collections/vault/getting-started" rel="noopener ugc nofollow" target="_blank">哈希公司的金库系统</a>。在本文中，我将带您了解如何将vault与iOS应用程序集成。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0d82" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">先决条件</h1><ol class=""><li id="fc14" class="mr ms iq ky b kz mt lc mu lf mv lj mw ln mx lr my mz na nb bi translated">按照这些说明设置您的保险库。</li><li id="87f3" class="mr ms iq ky b kz nc lc nd lf ne lj nf ln ng lr my mz na nb bi translated">确保<a class="ae kv" href="https://learn.hashicorp.com/tutorials/vault/getting-started-first-secret?in=vault/getting-started" rel="noopener ugc nofollow" target="_blank">您已经编写了</a>您的iOS应用程序将使用的秘密。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4927" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">与iOS应用集成</strong></h1><p id="1218" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">保管库可用于读取和写入API密钥等应用程序机密。让我们深入了解我们将如何将保险库与我们的iOS应用程序实际集成的细节。</p><h2 id="beb9" class="nk ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">验证到保管库</h2><p id="f5a3" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">为了与我们的保险库对话，我们需要首先验证我们自己。我们将使用我们在vault实现中支持的认证方法之一。这将取决于您在先决条件中的选择。一旦你通过认证，你会得到一个令牌，用来读取你的秘密。</p><h2 id="4eeb" class="nk ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">预构建脚本</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/51924ec69f6630c815453df7156ec7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rRE32G0H9El3lD00QUmpHw.png"/></div></div></figure><p id="44c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Xcode中添加预构建的脚本。这将在构建您的应用程序代码之前从保险库中提取秘密。我们将使用上一步中检索到的令牌进行身份验证。假设你在你的vault服务器的<em class="nx"> </em> <code class="fe ny nz oa ob b">/v1/secret/foo</code> <em class="nx"> </em>路径上写了一个秘密。您可以通过API调用来读取它，如下所示:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="7e70" class="nk ma iq ob b gy og oh l oi oj">curl -H "X-Vault-Token: {token}" -X GET http://{yourserver}/v1/secret/foo</span></pre><p id="9afe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将得到一个JSON响应，其中包含存储在该路径中的秘密。例如:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="fe66" class="nk ma iq ob b gy og oh l oi oj">{   <br/>"tool1Apikey": "tool1ApiKey",<br/>"tool2Apikey": "tool2ApiKey"<br/>"tool3Apikey": "tool3ApiKey"<br/>}</span></pre><p id="4824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将JSON输出保存为一个文件，并随意命名。比如我准备给它取名<code class="fe ny nz oa ob b">secretData.json</code>。这个文件将是项目目录的一部分，这样就可以从我们的应用程序代码中本地引用它。</p><h2 id="b4a4" class="nk ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated"><strong class="ak">读取秘密数据JSON </strong></h2><p id="4651" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">当我们的应用程序加载时，第三方库通常需要立即初始化。为了正确地初始化它们，我们需要API键。所以我们必须在AppDelegate中首先读取这个秘密文件。我们可以通过创建一个单例类(例如<code class="fe ny nz oa ob b">VaultManager</code>)来轻松地限制整个责任，该类将读取<code class="fe ny nz oa ob b">secretData</code> JSON，并使用我们可以在应用程序中使用的方便的getters来公开这些值。<code class="fe ny nz oa ob b">VaultManager.swift</code>的代码应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4fc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，singleton <code class="fe ny nz oa ob b">VaultManager</code>将负责读取这个秘密，并使它可以在应用程序中任何需要的地方使用。</p><h2 id="0d79" class="nk ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated"><strong class="ak">访问读取的秘密</strong></h2><p id="17a5" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">上面代码片段中的vault manager公开了一个方法调用:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="c7a8" class="nk ma iq ob b gy og oh l oi oj">func getSecretKey(withKeyName:SecretKey) -&gt;String?</span></pre><p id="0185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们需要在应用程序中的任何地方获取密钥，我们所要做的就是调用此方法并传递密钥名称。例如:</p><pre class="kg kh ki kj gt oc ob od oe aw of bi"><span id="149b" class="nk ma iq ob b gy og oh l oi oj">let keyValue = VaultManager.sharedInstance.getSecretKey(withKeyName: .tool1Apikey)</span></pre><p id="fb40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，我们完全消除了API密匙成为源代码一部分的需求。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4fbf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="38b5" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">作为一个良好的安全实践，我们不应该在代码库中存储像API密匙这样的应用秘密。它们应该与应用程序动态打包。保管库是保护您的应用程序机密的绝佳工具。</p><p id="a6e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您正在使用哪种保险存储解决方案？请在下面的评论中告诉我你的经历。</p></div></div>    
</body>
</html>