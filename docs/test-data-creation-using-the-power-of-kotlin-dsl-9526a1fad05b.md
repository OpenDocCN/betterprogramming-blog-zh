# 使用 Kotlin DSL 的强大功能创建测试数据

> 原文：<https://betterprogramming.pub/test-data-creation-using-the-power-of-kotlin-dsl-9526a1fad05b>

## 让测试代码再次变得简单

![](img/4fc2f9906f061bbd37571c60237f0abe.png)

图片来源:作者

如果您发现自己有一个需要测试的复杂的领域模型，这可能是一件痛苦的事情。仅仅为了构建测试数据，测试就可能变成几百行，导致一堆无意识的测试数据的复制粘贴，在你知道之前，一个小的模型变化就是几个小时的工作来修正测试数据。如果有软件开发地狱的话，我确信那将是其中之一。

我们在我的公司遇到了这个问题。我们有一个嵌套的域模型，为了测试简单的功能，我们必须构建一组复杂的对象来使它正确显示。当然，这很费力，而且更容易的是从另一个测试中复制，只填写与您相关的字段，潜在地将对象置于无效状态。有趣的时光…幸运的是我们使用科特林。Kotlin 的(许多)好特性之一是它支持构建 DSL(领域特定语言)，这使得它非常适合用于构造对象。

通过将 DSL 与一些创建模式相结合，我们可以减少测试数据创建的麻烦，并且更容易维护。该解决方案的基础是 builder 模式，它通常用于创建测试数据，但是它很容易变得冗长和难以阅读。然而，如果我们应用 Kotlin 的 DSL 功能，情况就不同了。为了防止复制，我们可以使用对象母模式在一个地方收集标准的测试数据实例，并从那里获取它们。同样，DSL 功能可以使这种模式更加强大。

让我们开始吧！

# 目标母模式

对象母模式是一种用于创建测试数据的创建模式。您可以将所有这些对象保存在“对象母亲”中，而不是为您构建的每个测试创建非常相似的测试数据。现在，您不太可能在许多测试中复制和粘贴相同的测试数据，因为您可以只使用来自对象母亲的数据。[1]

因此，使用 shipping 域中的一个 shipping 示例，您可以创建一些默认的 shipping 数据。你可以从任何需要一个盒子的测试中调用它，你只需要调用这个方法。

对于一般的测试来说，这是一个非常有用的模式，因为它使你的单元测试变得很小，并且很容易获得所有可用测试数据的概览。然而，如果您想对其中一个属性做一个小的改变，您可能会复制非常相似的测试数据来使测试工作，或者您只是完全忽略对象母。

这是我们可以用 Kotlin 解决的问题，但在此之前，我们需要讨论一下构建器模式。

# 构建器模式

构建器模式是一种创造性的设计模式，你猜对了，用来构建对象。这对于具有许多属性和嵌套类的复杂对象尤其有用。这是构建测试数据的常用方法，因为您可以设置默认值，并在必要时覆盖它们。

因此，如果我们以上面的例子为例，并使用 builder 模式，装运的创建将如下所示:

*我们使用构建器类来设置对象的属性，然后通过调用* `*build*` *返回最终版本。在上面的例子中，我们使用三个不同的构建器来创建完整的 shipment 对象，这看起来很冗长，也很难理解。然而，如果我们要添加更多的属性，我们可以很容易地为它们设置默认值，即使 Shipment 类改变了，这个方法也不会改变。*

使用 Kotlin DSL，在保留设置默认值选项的同时，也可以去掉冗长。所以不再调侃，让我们进入 DSL 吧！

# 科特林 DSL

特定于领域的语言专注于领域或特定的任务，忽略了所有不重要的东西。因此，DSL 并没有试图囊括一切，而是提供了一套精简的功能。这使得代码更简洁，更易于阅读。另一个好处是 DSL 更倾向于声明性，这意味着您可以描述期望的结果，并将实现细节留给 DSL 的实现者。因此，描述如何构建测试数据是 DSL 的一个很好的用例。

Kotlin 有一些很好的语言结构，允许我们创建简洁易读的 DSL。我将讨论 lambdas，如果你需要复习这些[，这是一个很好的资源](https://www.baeldung.com/kotlin/lambda-receiver)。[2]

允许我们创建 DSL 的一个构造是一个名为 *lambda 和接收器*的概念。它允许你调用 lambda 的一个参数作为接收者。这意味着您不必指定任何限定符，但是您可以直接调用它的方法或参数。

对于接收器，lambda 充当了`StringBuilder`的扩展函数，它提供了对 lambda 内部的`StringBuilder`的访问。如果你问我，我会觉得很酷。

使用带有接收器的 lambdas 将允许我们直接访问测试构建器类的属性，而不是必须从限定符中访问它们。这使得我们的测试数据创建不那么冗长。

以上面构建器模式部分的例子为例，这将是带有接收器的 lambda 替代方案:

确定什么属性属于哪个父类要简洁和容易得多。当然，实际构建对象的实现隐藏在这里，所以让我们看看它是什么样子的。

`buildShipment`函数是 lambda 的入口点，它创建一个发货测试数据构建器，然后在构建器上调用 lambda。然后，这个 lambda 可以填充构建器上的属性，并将构建好的装运返回。

因为我们也有一个嵌套盒子的列表，我们需要用 shipment builder 中的 receiver 做一个类似的 lambda 来将盒子添加到`boxes`属性中。

你可以看看随附的 [GitHub 回购](https://github.com/JohanneA/kotlin-test-data-builder-dsl-example)的完整例子。

既然我们已经处理了数据创建的冗长部分，我们可以继续复制部分。object mother 部分解决了这个问题，但是我们可以用 DSL 使它变得更好。我们想要为我们的测试创建定义一个预制测试数据的列表。但是我们仍然希望能够覆盖这些默认值，这样我们就不会复制具有几乎相同属性值的对象母代码。

为了避免过度复制，我们可以构建一个覆盖函数来覆盖对象母体上的特定值，但保留其余的值。这是它看起来的样子

我们没有像在 build 函数中那样创建一个新的 shipment builder，而是将 lambda 应用到我们想要覆盖其值的现有 builder 上。

这意味着在母对象中我们必须返回 ShipmentTestDataBuilder 而不是 Shipment。因此，当您获得测试数据时，您必须在测试中调用`build`方法。您也可以在 shipment builder 中添加这一点，但是您必须维护更多的映射逻辑。

由于我们有嵌套的构建器，我们还需要确保它们被正确地覆盖。由于列表中的嵌套对象，这使得事情变得复杂。我们希望覆盖特定的对象，并让它们保持现有的属性值，而不是只暴露类的属性来覆盖。

这需要一些逻辑来将构建器合并在一起。

为了用特定的 id 覆盖这个盒子，我们需要首先创建一个新的盒子构建器，用现有盒子中的属性填充它。

然后，我们需要在列表中找到现有的框，并将框中的属性“合并”到框生成器中。

使用与我们想要覆盖的盒子具有相同属性的盒子构建器，我们可以对它调用 lambda 函数，并提供对盒子属性的访问。

之后，我们从列表中删除旧的框，并添加新覆盖的框。

完整代码见 [Github repo](https://github.com/JohanneA/kotlin-test-data-builder-dsl-example) 。

# 把所有的放在一起

Kotlin DSL 并不是这些问题的唯一解决方案，它也有自己的缺点。每当一个新的属性被添加到您想要测试的模型中时，您必须手动地将属性添加到测试数据构建器中，这意味着测试构建器可能会过时。如果您想全力以赴，您可以构建一个小程序，它将基于类为您创建 DSL，但是如果您没有时间构建它，这可能是不可行的。

另一个缺点是 lambdas，它不是一件容易理解的事情，如果出现问题或行为异常，它会更难调试。

但是，也有很多好处。你使你的单元测试变得更小，更具声明性，重用母对象更加容易和安全，而不需要到处复制构建器。另外，以我的经验来看，它只是让编写单元测试不那么耗时，而且更令人满意。

下面是没有 DSL 时的样子:

如果你想稍微修改一下 `*getShipmentWithOneBox()*` *，你必须做很多样板文件，把数据复制到你的测试中并在那里修改它可能会更容易。您必须指定所有的属性，并且每次添加更多的属性时，您都必须更改这个测试。*

这是测试数据 DSL:

有了 DSL，测试数据占用的空间更少，你不必每次添加属性时都改变测试，而且读起来更好。

就是这样！我希望这篇文章能帮助你更好地理解 Kotlin DSL，以及如何使用它进行测试。你可以自己尝试一下，或者在下一次单元测试重构时记住它，因为我们都知道会有一个单元测试重构；)

如果您有任何反馈或建议，请在此评论或在 [Twitter](https://twitter.com/Johanne_01) 上联系。感谢您的阅读。

**参考文献:**

[1][https://martinfowler.com/bliki/ObjectMother.html](https://martinfowler.com/bliki/ObjectMother.html)

[https://www.baeldung.com/kotlin/lambda-receiver](https://www.baeldung.com/kotlin/lambda-receiver)

[3][https://github . com/JohanneA/kot Lin-test-data-builder-DSL-example](https://github.com/JohanneA/kotlin-test-data-builder-dsl-example)