<html>
<head>
<title>Exploring MapKit on iOS 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS 13上探索地图工具包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-mapkit-on-ios-13-1a7a1439e3b6?source=collection_archive---------8-----------------------#2019-11-12">https://betterprogramming.pub/exploring-mapkit-on-ios-13-1a7a1439e3b6?source=collection_archive---------8-----------------------#2019-11-12</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b74e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">除SwiftUI之外，优化的覆盖图、兴趣点等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c7115bb173f89613f297612b9c0e51a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0idAmCrZlJyMvdRMuA1Hg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1130732" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kz" href="https://pixabay.com/users/DariuszSankowski-1441456/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1130732" rel="noopener ugc nofollow" target="_blank"> Dariusz Sankowski </a>。iOS 13地图工具包中引入了其中的大部分功能</p></figure><p id="30ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">地图一直是苹果每次WWDC活动的常客。通过不断的增强和升级，苹果努力将多年来最薄弱的环节转化为强项。</p><p id="83d6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在WWDC 2019期间，苹果展示了它如何改进苹果地图。虽然大多数新的苹果地图更新将在2019年底推出，但<a class="ae kz" href="https://developer.apple.com/documentation/mapkit" rel="noopener ugc nofollow" target="_blank"> MapKit </a>已经为我们准备了很多。</p><p id="a281" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是MapKit今年带来的一些改进:</p><ul class=""><li id="0dd7" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">兴趣点。</li><li id="20d5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">优化的折线和多边形渲染。</li><li id="6e10" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">改进的搜索和自动完成。</li><li id="968e" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">控制相机边界和变焦。</li></ul><p id="84be" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将详细讨论这些增强功能。在本文的整个过程中，我们将使用<a class="ae kz" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>实现MapKit示例。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="ac96" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">过滤兴趣点</h1><p id="4a0d" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">iOS 13中升级的MapKit框架现在允许我们在地图上按类别包含和排除某些地方。</p><p id="84bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是目前可用的兴趣点类别:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/bc545ef063ed13376e2464d2ef72d8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jW3-RbgENpjtFFyl5Ivs6A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://developer.apple.com/videos/play/wwdc2019/236/" rel="noopener ugc nofollow" target="_blank">来自WWDC 2019视频</a></p></figure><p id="a894" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码展示了如何过滤兴趣点，以便在<code class="fe np nq nr ns b">MKMapView</code>中只包含一组特定的类别。</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="7b71" class="nx ms iu ns b gz ny nz l oa ob">let categories:[MKPointOfInterestCategory] = [.cafe]<br/>let filters = MKPointOfInterestFilter(including: categories)</span><span id="1cbc" class="nx ms iu ns b gz oc nz l oa ob">mapView.pointOfInterestFilter = .some(filters)</span></pre><p id="a3f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果，我们在SwiftUI中得到如下过滤后的地图外观。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/fb16a747d1338f85b65c32e3bf03a96e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MW332d64OoO_PFZUQSnQmQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">屏幕截图</p></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="df03" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">优化的地图覆盖</h1><p id="839b" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">iOS 13 MapKit引入了<code class="fe np nq nr ns b">MKMultiPoyline</code>和<code class="fe np nq nr ns b">MKMultiPolygon</code>类，以相同的风格对叠加进行分组，而不是为每个创建单独的渲染器对象。</p><p id="1020" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您在一个<code class="fe np nq nr ns b">MapView</code>上处理多个覆盖时，这极大地提高了您的应用程序的性能。</p><p id="88a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">添加如下所示的折线将创建三个不同的渲染器。</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="3720" class="nx ms iu ns b gz ny nz l oa ob">view.addOverlay(poyline1)<br/>view.addOverlay(poyline2)<br/>view.addOverlay(poyline3)</span></pre><p id="1ee2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，使用<code class="fe np nq nr ns b">MKMultiPolyine</code>执行以下操作将只创建一个渲染器，并防止应用程序中出现任何性能问题。</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="3415" class="nx ms iu ns b gz ny nz l oa ob">view.addOverlays([polyline1, polyline2, polyline3])</span></pre><p id="6654" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看如何通过在基于SwiftUI的视图中实现<code class="fe np nq nr ns b">MKMapViewDelegate</code>协议来集成新的<code class="fe np nq nr ns b">MKMultiPolylines</code>。</p><h2 id="32ea" class="nx ms iu bd mt oe of dn mx og oh dp nb lj oi oj nd ln ok ol nf lr om on nh oo bi translated">将多段线添加到地图视图</h2><p id="2eb9" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">以下代码设置UIKit和SwiftUI之间的协调器桥，并在地图上添加折线覆盖:</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="c67b" class="nx ms iu ns b gz ny nz l oa ob">struct PolylineMapView: UIViewRepresentable {<br/>    func makeCoordinator() -&gt; MapViewCoordinator{<br/>         return MapViewCoordinator(self)<br/>    }<br/>    <br/>    func updateUIView(_ view: MKMapView, context: Context){</span><span id="c7e5" class="nx ms iu ns b gz oc nz l oa ob">        <strong class="ns iv">view.delegate = context.coordinator</strong><br/>        let b2MLocation = ... //add your location coordinates here<br/>        let m2DLocation = ...<br/>        let d2BLocation = ...<br/>        <br/>        let polyline1 = MKPolyline(coordinates: b2MLocation, count: b2MLocation.count)<br/>        let polyline2 = MKPolyline(coordinates: m2DLocation, count: m2DLocation.count)<br/>        let polyline3 = MKPolyline(coordinates: d2BLocation, count: d2BLocation.count)<br/>        view.addOverlays([polyline1, polyline2, polyline3])<br/>    }<br/>    <br/>    func makeUIView(context: Context) -&gt; MKMapView{<br/>         MKMapView(frame: .zero)<br/>    }<br/>}</span></pre><p id="7683" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该委托负责将协调器类的更改传达给SwiftUI视图。</p><h2 id="7e3d" class="nx ms iu bd mt oe of dn mx og oh dp nb lj oi oj nd ln ok ol nf lr om on nh oo bi translated">设置MKMapViewDelegate和PolylineRenderer</h2><p id="30fe" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">在下面的代码中，我们已经在实例<code class="fe np nq nr ns b">MKMultiPolylineRenderer</code>(iOS 13中新引入的)上设置了折线样式:</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="eabd" class="nx ms iu ns b gz ny nz l oa ob">class MapViewCoordinator: NSObject, MKMapViewDelegate {<br/>        var mapViewController: PolylineMapView<br/>        <br/>        init(_ control: PolylineMapView) {<br/>          self.mapViewController = control<br/>        }<br/>    <br/>        func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer {</span><span id="018d" class="nx ms iu ns b gz oc nz l oa ob">if let multiPolyline = overlay as? MKMultiPolyline{<br/>            let polylineRenderer = <strong class="ns iv">MKMultiPolylineRenderer</strong>(multiPolyline: multiPolyline)<br/>            polylineRenderer.strokeColor = UIColor.blue.withAlphaComponent(0.5)<br/>            polylineRenderer.lineWidth = 5<br/>        }<br/>        return MKOverlayRenderer(overlay: overlay)<br/>    }<br/>}</span></pre><p id="70d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是针对多条折线优化的新渲染器与旧渲染器的对比:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/5513ef73c4b2308b55879140a97983b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3XStqWMvtVD9AUkKOXpwQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">右边的是新的iOS 13</p></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="0c7d" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">改进的搜索结果</h1><p id="2474" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">地图工具包搜索和自动完成结果通过包含新的<code class="fe np nq nr ns b">ResultType</code>得到了增强，它允许我们指定我们想要看到的结果。</p><ul class=""><li id="0a13" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe np nq nr ns b">.pointsOfInterest</code></li><li id="d787" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe np nq nr ns b">.address</code></li><li id="6702" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe np nq nr ns b">.query</code></li></ul><p id="b0ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，搜索完成器还允许通过兴趣点过滤，将结果限制在特定类别。下面是一些小代码，展示了iOS 13地图工具包增强的自动完成功能:</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="20aa" class="nx ms iu ns b gz ny nz l oa ob">let completer = MKLocalSearchCompleter()</span><span id="8af6" class="nx ms iu ns b gz oc nz l oa ob">completer.delegate = self</span><span id="f09f" class="nx ms iu ns b gz oc nz l oa ob">completer.pointOfInterestFilter = .some(MKPointOfInterestFilter(including: [.cafe]))</span><span id="48ed" class="nx ms iu ns b gz oc nz l oa ob">completer.resultTypes = .query</span></pre><p id="3f33" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">保存搜索结果的<code class="fe np nq nr ns b">MKMapItem</code>实例现在有了一个包含<code class="fe np nq nr ns b">pointsOfInterest</code>的附加属性，以指示返回位置或名称的类别类型。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="4603" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">控制相机边界</h1><p id="970b" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated"><code class="fe np nq nr ns b">CameraBoundary</code>是<code class="fe np nq nr ns b">MKMapView</code>中新引入的类。它允许我们将地图的平移限制在特定的边界区域。这意味着，即使您将贴图区域设置在边界之外，也不会违反相机边界。</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="9a7f" class="nx ms iu ns b gz ny nz l oa ob">mapView.cameraBoundary = MKMapView.CameraBoundary(coordinateRegion: region)</span></pre><p id="55a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">或者，我们也可以在<code class="fe np nq nr ns b">CameraBoundary</code>内部传递一个<code class="fe np nq nr ns b">MKMapRect</code>实例。</p><p id="dc2e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">iOS 13出来的另一个新类是<code class="fe np nq nr ns b">CameraZoomRange</code>。这允许我们根据中心坐标距离设置摄像机变焦控制。</p><p id="87d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码展示了实现这两个类的<code class="fe np nq nr ns b">MapView</code>:</p><pre class="kk kl km kn gu nt ns nu nv aw nw bi"><span id="6d93" class="nx ms iu ns b gz ny nz l oa ob">struct CameraBoundaryMapView: UIViewRepresentable {<br/>    <br/>    func updateUIView(_ view: MKMapView, context: Context){</span><span id="b883" class="nx ms iu ns b gz oc nz l oa ob">let region = MKCoordinateRegion(center: CLLocationCoordinate2D(<br/>        latitude: 12.9352, longitude: 77.6244), latitudinalMeters: 500, longitudinalMeters: 500)<br/>        <br/>        view.setCameraZoomRange(MKMapView.<strong class="ns iv">CameraZoomRange</strong>(minCenterCoordinateDistance: 500, maxCenterCoordinateDistance: 2000), animated: true)</span><span id="32e8" class="nx ms iu ns b gz oc nz l oa ob">view.cameraBoundary = MKMapView.<strong class="ns iv">CameraBoundary</strong>(coordinateRegion: region)   <br/>    }<br/>    func makeUIView(context: Context) -&gt; MKMapView{<br/>         MKMapView(frame: .zero)<br/>    }<br/>}</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oq"><img src="../Images/864fe324d7a4d13e912e4a2000fa5f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/1*YTlD8XY6D5dKLTynctY0Bg.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">iOS 13中可以限制相机变焦和平移</p></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="8e6c" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结论</h1><p id="99d9" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">因此，我们已经讨论了一些非常有趣的变化，如兴趣点和相机变焦，并看到了iOS 13中的MapKit如何优化叠加渲染。</p><p id="ece8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完整的SwiftUI源代码可在<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/iOS13MapKit" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中获得。</p><p id="ba84" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这件作品到此为止。我希望你喜欢读它。</p></div></div>    
</body>
</html>