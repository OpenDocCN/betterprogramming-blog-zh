<html>
<head>
<title>The Right Way to Compare Floats in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中比较浮点数的正确方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-right-way-to-compare-floats-in-python-ee18042abcc?source=collection_archive---------6-----------------------#2022-03-22">https://betterprogramming.pub/the-right-way-to-compare-floats-in-python-ee18042abcc?source=collection_archive---------6-----------------------#2022-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解浮点错误为什么常见，为什么有意义，以及如何在Python中处理它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89d4eb7db351582115d4c40cbdc624e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3f1a4JAXFarmkQXZWkSJCA.png"/></div></div></figure><p id="b42f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">浮点数是一种快速有效的存储和处理数字的方法，但是它们有一系列的缺陷，这些缺陷肯定难倒了许多新手程序员——可能也难倒了一些有经验的程序员！演示浮动缺陷的经典例子是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="3737" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一次看到这个可能会迷失方向。但是不要把你的电脑扔进垃圾桶。这种行为是正确的！</p><p id="7eaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将向您展示为什么像上面这样的浮点错误是常见的，为什么它们是有意义的，以及您可以在Python中做些什么来处理它们。</p><h1 id="e8bd" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">你的电脑(在某种程度上)是个骗子</h1><p id="6600" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">你已经看到<code class="fe mp mq mr ms b">0.1 + 0.2</code>不等于<code class="fe mp mq mr ms b">0.3</code>,但是疯狂还不止于此。以下是一些更令人困惑的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="904e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题也不仅限于平等比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="482d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是怎么回事？你的电脑在骗你吗？看起来的确如此，但在表面之下还有更多。</p><p id="78ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您在Python解释器中键入数字<code class="fe mp mq mr ms b">0.1</code>时，它会作为浮点数存储在内存中。当这种情况发生时，会发生一种转变。<code class="fe mp mq mr ms b">0.1</code>是以10为基数的十进制，但浮点数是以二进制存储的。换句话说，<code class="fe mp mq mr ms b">0.1</code>从基数10转换成基数2。</p><p id="4895" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">得到的二进制数可能无法准确表示原始的十进制数。<code class="fe mp mq mr ms b">0.1</code>就是一个例子。二进制表示是<code class="fe mp mq mr ms b">0.000110011…</code>。也就是说，<code class="fe mp mq mr ms b">0.1</code>在以2为基数书写时是一个无限重复的小数。当你把分数⅓写成十进制的小数时，也会发生同样的事情。你最终得到无限重复的小数<code class="fe mp mq mr ms b">0.3333…</code>。</p><p id="c20e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">计算机内存是有限的，所以<code class="fe mp mq mr ms b">0.1</code>的无限重复二进制分数表示被四舍五入为有限分数。这个数字的值取决于计算机的体系结构(32位与64位)。查看为<code class="fe mp mq mr ms b">0.1</code>存储的浮点值的一种方法是使用<code class="fe mp mq mr ms b">.as_integer_ratio()</code>方法来获取浮点表示的分子和分母:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="e9cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在使用<code class="fe mp mq mr ms b">format()</code>显示精确到小数点后55位的分数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1c24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<code class="fe mp mq mr ms b">0.1</code>被舍入到一个比它的真实值稍大的数字。这个错误被称为<strong class="kw iu">浮点表示错误</strong>，比你可能意识到的更经常发生。</p><h1 id="d0ad" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">表示错误真的很常见</h1><p id="29b5" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">当用浮点数表示时，数字被舍入有三个原因:</p><ol class=""><li id="95c8" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp my mz na nb bi translated">该数字的有效位数超过了浮点允许的位数。</li><li id="d966" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">这个数是无理数。</li><li id="326a" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp my mz na nb bi translated">该数是有理数，但有一个非终止的二进制表示。</li></ol><p id="e807" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">64位浮点数适用于大约16或17位有效数字。任何具有更高有效位数的数字都会被四舍五入。无理数，像π和<em class="nh"> e </em>，不能用任何整数底数的任何终止分数来表示。所以，不管怎样，无理数在存储为浮点数时都会被四舍五入。</p><p id="c8f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两种情况产生了一组无法精确表示为浮点数的无限数字。但是除非你是一个处理微小数字的化学家，或者是一个处理天文数字的物理学家，否则你不太可能遇到这些问题。</p><p id="a01a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非终止有理数呢，比如基数为2的<code class="fe mp mq mr ms b">0.1</code>？这是您将会遇到大多数浮点问题的地方，并且感谢决定一个分数是否终止的数学，您将会比您想象的更经常地遇到表示错误。</p><p id="3a7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在基数为10的情况下，如果一个分数的分母是10的质因数的幂的乘积，则该分数可以表示为终止分数。10的两个质因数是2和5，所以像、、⅕、⅛和⅒这样的分数都会终止，但⅓、⅐和⅑不会。然而，在基数2中，只有一个质因数:2。所以只有分母是2的幂的分数才会终止。因此，像⅓、⅕、⅙、⅐、⅑和⅒这样的分数在用二进制表示时都是非终止的。</p><p id="aa4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您现在可以理解本文中的原始示例了。<code class="fe mp mq mr ms b">0.1</code>、<code class="fe mp mq mr ms b">0.2</code>和<code class="fe mp mq mr ms b">0.3</code>在转换为浮点数时都取整:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="6812" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe mp mq mr ms b">0.1</code>和<code class="fe mp mq mr ms b">0.2</code>相加时，结果是一个比<code class="fe mp mq mr ms b">0.3</code>稍大的数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe mp mq mr ms b">0.1 + 0.2</code>比<code class="fe mp mq mr ms b">0.3</code>稍大，并且<code class="fe mp mq mr ms b">0.3</code>由一个比其自身稍小的数表示，所以表达式<code class="fe mp mq mr ms b">0.1 + 0.2 == 0.3</code>的计算结果为<code class="fe mp mq mr ms b">False</code>。</p><blockquote class="nj nk nl"><p id="bd14" class="ku kv nh kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">⚠️浮点表示错误是每种语言的每个程序员都需要知道并知道如何处理的事情。<strong class="kw iu">不是针对Python </strong>的。你可以在埃里克·威芬的网站<a class="ae ni" href="https://0.30000000000000004.com/" rel="noopener ugc nofollow" target="_blank">0.30000000000000004.com</a>上看到许多不同语言的印刷结果。</p></blockquote><h1 id="9979" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">如何在Python中比较浮点数</h1><p id="5369" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">那么，在Python中比较浮点时，如何处理浮点表示错误呢？诀窍是避免检查相等性。切勿将<code class="fe mp mq mr ms b">==</code>、<code class="fe mp mq mr ms b">&gt;=</code>或<code class="fe mp mq mr ms b">&lt;=</code>与浮动一起使用。请使用<code class="fe mp mq mr ms b"><a class="ae ni" href="https://docs.python.org/3/library/math.html#math.isclose" rel="noopener ugc nofollow" target="_blank">math.isclose()</a></code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="859c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">math.isclose()</code>检查第一个参数是否可接受地接近第二个参数。但是这到底是什么意思呢？诀窍是检查第一个参数和第二个参数之间的距离，它相当于两个值之差的绝对值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="2213" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe mp mq mr ms b">abs(a - b)</code>小于<code class="fe mp mq mr ms b">a</code>或<code class="fe mp mq mr ms b">b</code>中较大者的某个百分比，那么<code class="fe mp mq mr ms b">a</code>被认为与<code class="fe mp mq mr ms b">b</code>足够接近，从而“等于”<code class="fe mp mq mr ms b">b</code>。这个百分比称为<strong class="kw iu">相对公差。</strong>可以用<code class="fe mp mq mr ms b">math.isclose()</code>的<code class="fe mp mq mr ms b">rel_tol</code>关键字参数指定，默认为<code class="fe mp mq mr ms b">1e-9</code>。换句话说，如果<code class="fe mp mq mr ms b">abs(a - b)</code>小于<code class="fe mp mq mr ms b">0.00000001 * max(abs(a), abs(b))</code>，那么<code class="fe mp mq mr ms b">a</code>和<code class="fe mp mq mr ms b">b</code>被认为彼此“接近”。这保证了<code class="fe mp mq mr ms b">a</code>和<code class="fe mp mq mr ms b">b</code>大约等于9位小数。</p><p id="13b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果需要，可以更改相对公差:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="34b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，相对容差取决于您正在解决的问题所设置的约束。然而，对于大多数日常应用，默认的相对容差应该足够了。</p><p id="7b8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果<code class="fe mp mq mr ms b">a</code>或<code class="fe mp mq mr ms b">b</code>中的一个是零，而<code class="fe mp mq mr ms b">rel_tol</code>小于1，就会出现问题。在这种情况下，无论非零值与零有多接近，相对容差保证了对接近性的检查总是会失败。在这种情况下，使用绝对公差作为后备:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="4066" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">math.isclose()</code>这些会自动为您检查。<code class="fe mp mq mr ms b">abs_tol</code>关键字参数决定了绝对公差。然而，<code class="fe mp mq mr ms b">abs_tol</code>默认为<code class="fe mp mq mr ms b">0.0</code>，所以如果你需要检查一个值有多接近零，你需要手动设置它。</p><p id="fb9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总而言之，<code class="fe mp mq mr ms b">math.isclose()</code>返回以下比较的结果，该比较将相对和绝对测试合并到一个表达式中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">math.isclose()</code>是在<a class="ae ni" href="https://peps.python.org/pep-0485/" rel="noopener ugc nofollow" target="_blank"> PEP 485 </a>中引入的，从Python 3.5开始就有了。</p><h1 id="c246" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">什么时候应该用<code class="fe mp mq mr ms b">math.isclose()</code>？</h1><p id="5b32" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">一般来说，只要需要比较浮点值，就应该使用<code class="fe mp mq mr ms b">math.isclose()</code>。用<code class="fe mp mq mr ms b">math.isclose()</code>替换<code class="fe mp mq mr ms b">==</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="1fe4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还需要小心<code class="fe mp mq mr ms b">&gt;=</code>和<code class="fe mp mq mr ms b">&lt;=</code>的比较。使用<code class="fe mp mq mr ms b">math.isclose()</code>分别处理等式，然后检查严格比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="f2ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">存在各种替代<code class="fe mp mq mr ms b">math.isclose()</code>的方案。如果您使用NumPy，您可以利用<code class="fe mp mq mr ms b"><a class="ae ni" href="https://numpy.org/doc/stable/reference/generated/numpy.allclose.html" rel="noopener ugc nofollow" target="_blank">numpy.allclose()</a></code>和<code class="fe mp mq mr ms b"><a class="ae ni" href="https://numpy.org/doc/stable/reference/generated/numpy.isclose.html" rel="noopener ugc nofollow" target="_blank">numpy.isclose()</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="edfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，默认的相对和绝对公差与<code class="fe mp mq mr ms b">math.isclose()</code>不同。<code class="fe mp mq mr ms b">numpy.allclose()</code>和<code class="fe mp mq mr ms b">numpy.isclose()</code>的默认相对公差为<code class="fe mp mq mr ms b">1e-05</code>，默认绝对公差为<code class="fe mp mq mr ms b">1e-08</code>。</p><p id="e5df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">math.isclose()</code>对单元测试特别有用，尽管有一些替代方法。Python的内置<code class="fe mp mq mr ms b">unittest</code>模块有一个<code class="fe mp mq mr ms b"><a class="ae ni" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual" rel="noopener ugc nofollow" target="_blank">unittest.TestCase.assertAlmostEqual()</a></code>方法。然而，该方法仅使用绝对差异检验。这也是一个断言，意味着失败会引发一个<code class="fe mp mq mr ms b">AssertionError</code>，使其不适合在您的业务逻辑中进行比较。</p><p id="8bea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于单元测试来说，<code class="fe mp mq mr ms b">math.isclose()</code>的另一个很好的选择是<code class="fe mp mq mr ms b"><a class="ae ni" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank">pytest</a></code> <a class="ae ni" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank">包</a>中的<code class="fe mp mq mr ms b"><a class="ae ni" href="https://docs.pytest.org/en/latest/reference/reference.html?highlight=approx#pytest-approx" rel="noopener ugc nofollow" target="_blank">pytest.approx()</a></code>函数。与<code class="fe mp mq mr ms b">math.isclose()</code>不同，<code class="fe mp mq mr ms b">pytest.approx()</code>只接受一个参数——即您期望的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0782" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">pytest.approx()</code>有<code class="fe mp mq mr ms b">rel_tol</code>和<code class="fe mp mq mr ms b">abs_tol</code>关键字参数，用于设置相对和绝对公差。然而，默认值与<code class="fe mp mq mr ms b">math.isclose()</code>不同。<code class="fe mp mq mr ms b">rel_tol</code>的默认值为<code class="fe mp mq mr ms b">1e-6</code>，而<code class="fe mp mq mr ms b">abs_tol</code>的默认值为<code class="fe mp mq mr ms b">1e-12</code>。</p><p id="16eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果传递给<code class="fe mp mq mr ms b">pytest.approx()</code>的前两个参数是类数组的，这意味着它们是Python可迭代的，如列表或元组，甚至是NumPy数组，那么<code class="fe mp mq mr ms b">pytest.approx()</code>的行为类似于<code class="fe mp mq mr ms b">numpy.allclose()</code>并返回两个数组在容差范围内是否相等:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="a13d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">pytest.approx()</code>甚至可以使用字典值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="899f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当不需要绝对精度时，浮点数非常适合处理数字。它们速度快，内存效率高。但是如果您确实需要精度，那么您应该考虑一些浮点的替代方法。</p><h1 id="b188" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">精确的浮点替代</h1><p id="e3e5" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Python中有两个内置的数值类型，在浮点不够用的情况下可以提供完全的精度:<code class="fe mp mq mr ms b">Decimal</code>和<code class="fe mp mq mr ms b">Fraction</code>。</p><h2 id="3538" class="np lt it bd lu nq nr dn ly ns nt dp mc ld nu nv me lh nw nx mg ll ny nz mi oa bi translated"><code class="fe mp mq mr ms b">Decimal</code>型</h2><p id="b1a9" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated"><code class="fe mp mq mr ms b"><a class="ae ni" href="https://docs.python.org/3/library/decimal.html#decimal-objects" rel="noopener ugc nofollow" target="_blank">Decimal</a></code> <a class="ae ni" href="https://docs.python.org/3/library/decimal.html#decimal-objects" rel="noopener ugc nofollow" target="_blank">型</a>可以精确存储十进制数值，精度可根据您的需要而定。默认情况下，<code class="fe mp mq mr ms b">Decimal</code>保留了28个有效数字，但是您可以根据自己的需要修改它，以适应您正在解决的特定问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="6c4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在<a class="ae ni" href="https://docs.python.org/3/library/decimal.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a>中阅读更多关于<code class="fe mp mq mr ms b">Decimal</code>类型的内容。</p><h2 id="fb56" class="np lt it bd lu nq nr dn ly ns nt dp mc ld nu nv me lh nw nx mg ll ny nz mi oa bi translated"><code class="fe mp mq mr ms b">Fraction</code>式</h2><p id="2b56" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">浮点数的另一种替代方式是<code class="fe mp mq mr ms b"><a class="ae ni" href="https://docs.python.org/3/library/fractions.html#fractions.Fraction" rel="noopener ugc nofollow" target="_blank">Fraction</a></code> <a class="ae ni" href="https://docs.python.org/3/library/fractions.html#fractions.Fraction" rel="noopener ugc nofollow" target="_blank">类型</a>。<code class="fe mp mq mr ms b">Fraction</code>能准确存储有理数，克服浮点数遇到的表示错误问题；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="20fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与标准浮点值相比，<code class="fe mp mq mr ms b">Fraction</code>和<code class="fe mp mq mr ms b">Decimal</code>提供了许多好处。然而，这些好处是有代价的:速度降低和内存消耗增加。如果你不需要绝对精确，你最好坚持使用浮动。但是对于像金融和关键任务应用这样的事情来说，<code class="fe mp mq mr ms b">Fraction</code>和<code class="fe mp mq mr ms b">Decimal</code>之间的权衡可能是值得的。</p><h1 id="8b8b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="b8ee" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">浮点值既是福也是祸。它们提供了快速的算术运算和高效的内存使用，但代价是表示不准确。在本文中，您了解了:</p><ul class=""><li id="91ec" class="mt mu it kw b kx ky la lb ld mv lh mw ll mx lp ob mz na nb bi translated">为什么浮点数不精确</li><li id="7224" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated">为什么浮点表示错误很常见</li><li id="be59" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated">如何在Python中正确比较浮点值</li><li id="525e" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated">如何使用Python的<code class="fe mp mq mr ms b">Fraction</code>和<code class="fe mp mq mr ms b">Decimal</code>类型精确地表示数字</li></ul><p id="6269" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你知道在Python中比较浮点数的正确方法了！</p><h1 id="1e1c" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">额外资源</h1><ul class=""><li id="72ac" class="mt mu it kw b kx mk la ml ld oc lh od ll oe lp ob mz na nb bi translated"><a class="ae ni" href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="noopener ugc nofollow" target="_blank">浮点运算:问题与局限</a></li><li id="0779" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated"><a class="ae ni" href="https://floating-point-gui.de/" rel="noopener ugc nofollow" target="_blank">浮点运算指南</a></li><li id="c157" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated"><a class="ae ni" href="https://www.lahey.com/float.htm" rel="noopener ugc nofollow" target="_blank">浮动点的危险</a></li><li id="8d4e" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated"><a class="ae ni" href="https://0.30000000000000004.com/" rel="noopener ugc nofollow" target="_blank">浮点数学</a></li><li id="11fd" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated"><a class="ae ni" href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="noopener ugc nofollow" target="_blank">关于浮点运算，每个计算机科学家都应该知道的事情</a></li><li id="d0a4" class="mt mu it kw b kx nc la nd ld ne lh nf ll ng lp ob mz na nb bi translated"><a class="ae ni" href="https://realpython.com/python-rounding/" rel="noopener ugc nofollow" target="_blank">如何在Python中舍入数字</a></li></ul></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt om ms on oo aw op bi"><span id="3880" class="np lt it ms b gy oq or l os ot"><strong class="ms iu"><em class="nh">Want to take your Python skills to the next level?</em></strong></span><span id="c89c" class="np lt it ms b gy ou or l os ot"><em class="nh">I offer private one-on-one coaching for Python programming and technical writing. </em><a class="ae ni" href="https://davidamos.dev/coaching" rel="noopener ugc nofollow" target="_blank"><em class="nh">Click here</em></a><em class="nh"> to learn more.</em></span></pre></div></div>    
</body>
</html>