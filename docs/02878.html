<html>
<head>
<title>Use Flow to Check Your JavaScript Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flow检查您的JavaScript类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-using-flow-for-checking-javascript-types-dccc8a4e1505?source=collection_archive---------18-----------------------#2020-01-06">https://betterprogramming.pub/introduction-to-using-flow-for-checking-javascript-types-dccc8a4e1505?source=collection_archive---------18-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b819" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的项目中设置流，并使用它来检查基本类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a431e8d67de786c26865c98a906bb4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1RDpIoLKrppEkd11"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mikeanywhere?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·刘易斯HeadSmart媒体</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="fd86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为JavaScript是一种动态类型语言，所以变量和对象属性有意外类型会有问题。此外，一些JavaScript类型的强制规则是任意的。为了使开发JavaScript应用程序更容易，脸书对JavaScript进行了扩展，为语言添加了类型注释和类型检查。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="373e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向项目添加流程</h1><p id="1ee5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种语言由脸书对JavaScript的扩展以及原始的JavaScript语言组成，被称为Flow。</p><p id="5fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地在新项目中使用它。为了全局添加它，我们只需安装Yarn并运行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0b44" class="ne md it na b gy nf ng l nh ni">yarn add --dev @babel/core @babel/cli @babel/preset-flow</span></pre><p id="32f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建一个<code class="fe nj nk nl na b">.babelrc</code>文件，并添加以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="604c" class="ne md it na b gy nf ng l nh ni">{<br/>  "presets": ["@babel/preset-flow"]<br/>}</span></pre><p id="2b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以构建并运行代码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="754b" class="ne md it na b gy nf ng l nh ni">yarn run babel src/ -- -d lib/</span></pre><p id="c7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令可以添加到<code class="fe nj nk nl na b">package.json</code>文件，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a937" class="ne md it na b gy nf ng l nh ni">{<br/>  "name": "project-name",<br/>  "main": "lib/index.js",<br/>  "scripts": {<br/>    "build": "babel src/ -d lib/"<br/>  }<br/>}</span></pre><p id="5e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以通过在我们的项目中运行<code class="fe nj nk nl na b">yarn add --dev flow-bin</code>来为每个项目添加它，添加Flow作为项目的开发依赖。然后我们可以运行<code class="fe nj nk nl na b">flow</code>命令:<code class="fe nj nk nl na b">yarn run flow</code>(如果你以前没有运行过的话，你可能需要运行<code class="fe nj nk nl na b">yarn run flow init</code>)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2761" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">向添加流代码以进行类型检查</h1><p id="a829" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然安装了Flow，我们可以向代码中添加类型注释，让Flow进行类型检查。</p><p id="d0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的方法是在变量后添加类型注释来指示其类型:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6e82" class="ne md it na b gy nf ng l nh ni">// @flow<br/>let x: number = 1;</span></pre><p id="6ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们必须在我们的代码上添加<code class="fe nj nk nl na b">// @flow</code>,以使Flow能够对我们的代码进行类型检查。</p><p id="e788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以向函数参数添加类型注释:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d190" class="ne md it na b gy nf ng l nh ni">// @flow<br/>function cube(x: number): number {<br/>  return x**3;<br/>}</span></pre><p id="5bb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后当我们写:<code class="fe nj nk nl na b">cube('');</code>时，我们得到下面的错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bbed" class="ne md it na b gy nf ng l nh ni">[Flow] Cannot call `cube` with empty string bound to `x` because string [1] is incompatible with number [2].</span></pre><p id="e97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们将一个字符串传递给了一个需要数字的函数。</p><p id="fe85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们传入一个数字，它应该是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5744" class="ne md it na b gy nf ng l nh ni">cube(2);</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1c48" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本类型</h1><p id="03ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于我们将在JavaScript中遇到的各种数据类型，Flow有自己的类型注释。</p><p id="8e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像JavaScript一样，它有各种原始数据类型。JavaScript有以下基本类型:</p><ul class=""><li id="e8ae" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">布尔运算</li><li id="a74d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">用线串</li><li id="6a5b" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">数字</li><li id="b6c1" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">null</code></li><li id="0a12" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">undefined</code>(流量类型中的<code class="fe nj nk nl na b">void</code>)</li><li id="2255" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">符号(从ES6开始，但在Flow中尚不支持)</li></ul><p id="c22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们可以作为文字使用，也可以用包装构造函数或函数来构造:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="495c" class="ne md it na b gy nf ng l nh ni">//literals<br/>true;<br/>"abc";<br/>1;<br/>null;<br/>undefined;</span><span id="e4e4" class="ne md it na b gy oa ng l nh ni">// constructors<br/>new Boolean(false);<br/>new String("abc");<br/>new Number(1);</span><span id="cef9" class="ne md it na b gy oa ng l nh ni">// factory function<br/>Symbol("abc");</span></pre><p id="20fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文字值有小写的类型名。用构造函数创建的类型对象的类型名是大写的。例如，我们可以有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1ad2" class="ne md it na b gy nf ng l nh ni">// literals<br/>x: number</span><span id="66e8" class="ne md it na b gy oa ng l nh ni">// constructor objects<br/>x: Number</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/86bb06fddb12f00563bac2de58238f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zt-hwQ-oMstPSm51"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塞缪尔·费拉拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="cb15" class="ne md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">布尔运算</h2><p id="470f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">布尔值可以是<code class="fe nj nk nl na b">true</code>或<code class="fe nj nk nl na b">false</code>。我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1bca" class="ne md it na b gy nf ng l nh ni">// <a class="ae ky" href="http://twitter.com/flow" rel="noopener ugc nofollow" target="_blank">@flow</a><br/>function boo(val: boolean) {<br/>  <br/>}</span><span id="a445" class="ne md it na b gy oa ng l nh ni">boo(true);<br/>boo(2);</span></pre><p id="72e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">boo(2);</code>会给我们带来以下错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="682a" class="ne md it na b gy nf ng l nh ni">[Flow] Cannot call `boo` with `2` bound to `val` because number [1] is incompatible with boolean [2].</span></pre><p id="5ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript会在需要时将对象转换为布尔值。例如，当我们比较布尔值时，它将在<code class="fe nj nk nl na b">if</code>语句或等式语句中转换它。</p><p id="b8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以这样写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dce1" class="ne md it na b gy nf ng l nh ni">if (1) {}</span></pre><p id="7d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为它有真和假的价值。当转换为布尔值完成时，假值被转换为<code class="fe nj nk nl na b">false</code>。以下值是假的:</p><ul class=""><li id="be4b" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi">0</li><li id="f20f" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">undefined</code></li><li id="2915" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">null</code></li><li id="519c" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">NaN</code></li><li id="d3ad" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">空字符串</li><li id="882b" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe nj nk nl na b">false</code></li></ul><p id="8dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他一切都是真实的。</p><p id="06ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Flow，如果我们有一个类型为<code class="fe nj nk nl na b">boolean</code>或<code class="fe nj nk nl na b">Boolean</code>的参数或变量，我们必须显式地传入布尔值。<code class="fe nj nk nl na b">boolean</code>和<code class="fe nj nk nl na b">Boolean</code>类型不能与流程互换。鉴于我们有:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7685" class="ne md it na b gy nf ng l nh ni">// <a class="ae ky" href="http://twitter.com/flow" rel="noopener ugc nofollow" target="_blank">@flow</a><br/>function boo(val: boolean) {<br/>  <br/>}</span></pre><p id="6a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们写<code class="fe nj nk nl na b">boo(new Boolean(true));</code>我们会得到下面的错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="237b" class="ne md it na b gy nf ng l nh ni">Cannot call `boo` with `new Boolean(...)` bound to `val` because `Boolean` [1] is incompatible with boolean [2].</span></pre><h2 id="760c" class="ne md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">数字</h2><p id="0688" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript只有一种类型的数字。它可以是浮点或整数。</p><p id="1e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流量有<code class="fe nj nk nl na b">number</code>和<code class="fe nj nk nl na b">Number</code>两种类型。<code class="fe nj nk nl na b">number</code>类型用于数值，而<code class="fe nj nk nl na b">Number</code>类型是包装器对象。</p><p id="e6d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5d29" class="ne md it na b gy nf ng l nh ni">let x: number = 1;</span></pre><p id="d36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bbc8" class="ne md it na b gy nf ng l nh ni">let x: Number = new Number(1);</span></pre><p id="366b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不能写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3faf" class="ne md it na b gy nf ng l nh ni">let x: number = new Number(1);</span></pre><p id="a494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码会给我们带来以下错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dcf5" class="ne md it na b gy nf ng l nh ni">[Flow] Cannot assign `new Number(...)` to `x` because `Number` [1] is incompatible with number [2].</span></pre><p id="4eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也不能写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a218" class="ne md it na b gy nf ng l nh ni">let x: Number = 1;</span></pre><p id="384f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会给我们带来以下错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2a78" class="ne md it na b gy nf ng l nh ni">[Flow] Cannot assign `1` to `x` because number [1] is incompatible with `Number` [2].</span></pre><h2 id="6d21" class="ne md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated">用线串</h2><p id="c208" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">流分别有文字和包装对象的<code class="fe nj nk nl na b">string</code>和<code class="fe nj nk nl na b">String</code>类型。</p><p id="064e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它像其他原始类型一样工作。所以我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3e5f" class="ne md it na b gy nf ng l nh ni">let x: string = 'abc';</span></pre><p id="aab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1763" class="ne md it na b gy nf ng l nh ni">let x: String = new String('abc');</span></pre><p id="1494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们不能颠倒文字和包装对象的赋值。</p><p id="2ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Flow将只接受字符串和其他字符串或数字的串联。这意味着以下内容将起作用:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="324c" class="ne md it na b gy nf ng l nh ni">"foo" + "bar";<br/>"foo" + 1;</span></pre><p id="1995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将一个字符串文字和一个包装器对象字符串连接起来。例如，我们可以写:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="36b6" class="ne md it na b gy nf ng l nh ni">"foo" + String('abc');</span></pre><p id="079d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们不能将一个字符串与用字符串构造函数创建的字符串连接起来。所以下面会给我们一个错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1633" class="ne md it na b gy nf ng l nh ni">"foo" + new String('abc');</span></pre><p id="de47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将字符串与任何其他类型连接会给我们带来错误。</p><h2 id="2edc" class="ne md it bd me oc od dn mi oe of dp mm li og oh mo lm oi oj mq lq ok ol ms om bi translated"><code class="fe nj nk nl na b">null</code>和<code class="fe nj nk nl na b">void</code></h2><p id="5634" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Flow用<code class="fe nj nk nl na b">null</code>类型表示<code class="fe nj nk nl na b">null</code>值，用<code class="fe nj nk nl na b">void</code>表示<code class="fe nj nk nl na b">undefined</code>值。</p><p id="2203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，以下内容将会起作用:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1e34" class="ne md it na b gy nf ng l nh ni">let x: null = null;<br/>let y: void = undefined;</span></pre><p id="e42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不能将任何其他内容分配给这些类型。函数参数也是如此。</p><p id="769c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脸书创建了Flow来让我们检查代码中数据类型的正确性。它防止对变量和函数参数进行意外的类型赋值。</p><p id="d237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于基本类型，它有单独的对象类型，这些对象是用基本对象和文字的构造函数创建的。例如，<code class="fe nj nk nl na b">string</code>是字符串文字，<code class="fe nj nk nl na b">String</code>是用<code class="fe nj nk nl na b">new String(...)</code>创建的字符串。</p><p id="061d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还有<code class="fe nj nk nl na b">null</code>和<code class="fe nj nk nl na b">void</code>两种型号，分别用于<code class="fe nj nk nl na b">null</code>和<code class="fe nj nk nl na b">undefined</code>。</p></div></div>    
</body>
</html>