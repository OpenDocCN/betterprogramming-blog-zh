# 单元测试以及为什么你应该这样做

> 原文：<https://betterprogramming.pub/unit-testing-and-why-you-should-be-doing-it-ab61407c53ce>

## 你能称你的代码为“好”的唯一方法是它是否经过了充分的单元测试

![](img/7d6d68533bddfe050c8add313ab1017e.png)

由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的[émile Perron](https://unsplash.com/@emilep?utm_source=medium&utm_medium=referral)拍摄的照片

> 我是在建议 100%的测试覆盖率吗？不，我要求它。你写的每一行代码都应该被测试。句号。
> 
> 我不希望管理层强制要求 100%的测试覆盖率。我希望你的良心把它作为一个荣誉问题。
> 
> 怎么样:如果你有 100%的把握，你可以随时放心地野蛮重构。

我从鲍伯·马丁叔叔和他的一些追随者在推特上的对话中引用了上面的话。

他非常热衷于代码覆盖和单元测试。我们可能都不像 Bob 叔叔那样严格，但是我们都应该对单元测试有一点热情。

这种热情应该源于编写好代码的愿望。我要说明的是，你能称你的代码为“好”的唯一方法是它是否经过了充分的单元测试。

如果你编写和交付的代码没有经过完全的单元测试，你应该会觉得自己像是赤身裸体地走在街上。你应该感到暴露，好像每个人都在看着你。

你应该坚信，除非你的代码完全被单元测试覆盖，否则你的代码会失败得很惨。

# 什么是单元测试

单元测试是对代码的测试，以确保它执行它应该执行的任务。它在尽可能低的级别测试代码——类的单个方法。

这是编写干净、可维护的代码的关键。如果你专注于编写易于测试的代码，你最终会得到易于维护的解耦的、干净的、高质量的代码。不喜欢什么？

但是，当涉及到单元测试时，有时会有关于术语定义的问题。例如，到底什么是“单位”？“嘲讽”是什么意思？我如何知道我是否真的在进行单元测试？

本文将介绍这些术语的含义。

# 什么是单位？

当讨论单元测试时，首先出现的问题是，什么是单元？不知道单元是什么，就不能进行单元测试。

当谈到单元测试时，我把单元看作是任何可以独立测试的离散的代码模块。它可以像一个独立的例程一样简单，但通常是一个单独的类及其方法。

在许多现代语言中，类是主要的、独立的代码实体，因此是代码的基本构造块。它们是数据结构，当一起使用时，形成一个系统。

在单元测试的世界里，这个类通常被称为测试中的*类* (CUT)或者测试中的*系统* (SUT)。

您将看到这些术语被广泛使用——强烈建议您使用 CUT 作为被测试类的变量名。

定义:一个单元是任何可以被孤立测试的代码实体，通常是一个类。

# 我在做单元测试吗？

因此，当你进行单元测试时，你通常是在测试类(为了讨论的方便，这将是下文的假设)。

但是要注意的关键是，当对一个类进行单元测试时，你是在对给定的类进行单元测试，而且只对给定的类进行单元测试。单元测试总是在隔离中完成的——也就是说，被测试的类需要与任何其他类或任何其他系统完全隔离。

如果你正在测试一个类，并且你需要一些外部实体，那么你就不再是单元测试了。一个类只有当它的依赖项可以是并且是“伪造的”时才是“可测试的”,从而在没有任何真正的外部依赖项的情况下被测试。

因此，如果您正在运行您认为是单元测试的东西，并且该测试需要访问数据库、文件系统或任何其他外部系统，那么您已经停止了单元测试，并且已经开始了集成测试。

有一点我想明确一下。做集成测试没什么丢人的。集成测试真的很重要，应该做。单元测试框架通常是进行集成测试的一个非常好的方法。

我不想给你留下这样的印象，因为集成不是单元测试，你不应该这样做——恰恰相反。然而，这是一个重要的区别。

这里的要点是认识到什么是单元测试，并在打算编写单元测试时努力编写它们。无论如何，要写集成测试，但是不要写集成测试来代替单元测试。

这么想吧。每个单元测试框架都创建一个测试可执行文件。如果您不能在您母亲的计算机上的一个只读目录中成功地运行测试可执行文件，那么您就不再是单元测试了。

定义:单元测试是孤立地测试一个类的行为，完全脱离它的任何实际依赖。

定义:集成测试是测试单个类及其一个或多个实际外部依赖的行为。

# 什么是隔离框架？

通常，开发人员使用术语*模仿框架*来描述提供虚假服务以允许类被隔离测试的代码。

然而，正如我们将在下面看到的, *mock* 是一种特殊的伪类，还有存根。因此，使用术语*隔离框架*而不是*模仿框架*可能更准确。

一个有用的隔离框架将允许容易地创建两种类型的假货——模仿和存根。

Fakes 允许您通过提供依赖项的实现来单独测试一个类，而不需要真正的依赖项。

定义:一个隔离框架是一个代码的集合，它使得伪造变得容易。

定义:假类是任何提供足够的功能来假装它是被测试类所需要的依赖项的类。假货有两种:存根和仿制品。

如果你想深入了解这个东西，我强烈推荐你阅读 [*《单元测试的艺术:示例》。罗伊·奥舍洛夫著*](https://www.amazon.com/Art-Unit-Testing-examples/dp/1617290890) 网。或者，你可以在 [Hanselminutes](http://hanselminutes.com/169/the-art-of-unit-testing-with-roy-osherove) 播客中听听 Roy 和 Scott Hanselman 的对话。

如果你想成为超级极客，就去买一本杰拉德·梅萨罗什写的《xUnit 测试模式:重构测试代码》。

这本厚重的书是单元测试的杰作，概述了测试和测试模式的完整分类。它不适合胆小的人，但是，如果你读了那本书，你会知道所有该知道的事情，甚至更多。

# 存根

stub 是一个绝对最小化的类，它看起来是被测试类的一个实际依赖项。它不提供测试所需的任何功能，除了实现给定的接口或继承给定的基类。

当 CUT 调用它时，存根通常什么也不做。存根完全是测试 CUT 的外围设备，其存在纯粹是为了使 CUT 能够运行。

一个典型的例子是提供日志服务的存根。CUT 可能需要实现，比如说，`ILogger`接口来执行，但是没有一个测试关心日志记录。

你明确地不希望切割记录任何东西。因此，存根通过实现接口假装是日志记录服务，但是该实现实际上什么也不做。它的实现方法可能为空。

此外，虽然存根可能会返回数据以使 CUT 满意并运行，但它绝不会采取任何会导致测试失败的操作。如果是这样，那么它就不再是一个存根，而是一个模拟。

定义:存根是一个对测试的通过或失败没有影响的赝品，它的存在纯粹是为了让测试运行。

# 嘲弄

模拟有点复杂。Mocks 做了 stubs 所做的事情，因为它们提供了 CUT 所需的依赖项的假实现。

然而，它们通过记录自身和切口之间的相互作用而不仅仅是一个存根。mock 记录了与 CUT 的所有交互并报告回来，如果 CUT 行为正确，则通过测试，如果不正确，则测试失败。

因此，决定测试是否通过的是模拟，而不是切割本身。

这里有一个例子。

假设您有一个名为`WidgetProcessor`的类。它有两个依赖项，一个`ILogger`和一个`IVerifier`。为了测试`WidgetProcessor`，您需要伪造这两个依赖项。

然而，为了测试`WidgetProcessor`，你需要做两个测试——一个测试你存根`ILogger`并测试与`IVerifier`的交互，另一个测试你存根`IVerifier`并测试与`ILogger`的交互。

两者都需要假货，但是在每种情况下，您都要为一个提供一个存根类，为另一个提供一个模拟类。

让我们更仔细地看看第一个场景，这里我们剔除了`ILogger`，并对`IVerifier`使用了一个 mock。我们讨论过的存根。你要么写一个空的`ILogger`实现，要么用一个隔离框架实现接口什么都不做。

然而，`IVerifier`的假变得更有趣了——它需要一个模拟类。假设验证小部件的过程需要两步。首先，处理器需要查看小部件是否在系统中，如果在，处理器需要检查小部件的配置是否正确。

因此，如果您正在测试`WidgetProcessor`，您需要运行一个测试来检查`WidgetProcessor`是否进行了第二次调用，如果它从第一次调用中获得了`True`的话。

这个测试需要模拟类做两件事。首先，它需要从第一次调用返回`True`,然后它需要跟踪是否进行了最终的配置调用。

然后，模拟类的工作就是提供通过/失败信息。如果在第一次调用之后进行的第二次调用返回`True`，则测试通过；否则，测试失败。

这就是这个假类成为 mock 的原因:mock 本身包含需要检查通过/失败标准的信息。

定义:mock 是一种假的东西，它跟踪被测试类的行为，并根据该行为通过或失败测试。

大多数隔离框架都有能力对模拟类内部发生的事情进行广泛而复杂的跟踪。

例如，模拟不仅可以判断给定方法是否被调用，还可以跟踪给定方法被调用的次数以及传递给这些调用的参数。

他们可以决定某样东西是否被不该叫的叫了出来，或者某样东西没有被应该叫的叫出来。作为测试设置的一部分，如果事件和参数的确切序列没有按计划执行，您可以准确地告诉 mock 会发生什么以及会失败。

存根的构建和使用相对简单，但是模拟可能会变得相当复杂。

但是，这里的要点是孤立地测试你的类；您希望您的部门能够在没有任何外部、真实、外部依赖的情况下履行其职责。

因此，最后一个定义是:

定义 **:** 单元测试是对一个单独的代码实体的测试，当它与它的依赖项完全隔离时。

# 为什么要进行单元测试？

我发现做单元测试有很多阻力。许多开发人员似乎认为这是浪费时间，或者仅仅是在截止日期前延迟项目的完成。他们觉得自己从中得不到任何好处。

我完全不同意。原因如下。

## 单元测试会发现错误

无论您是进行测试驱动开发并首先编写测试，还是在开发过程中编写测试，或者在代码编写后很久才编写测试，单元测试都会发现 bug。

当您编写一整套测试来定义一个给定类的预期行为时，该类中任何不按预期行为的行为都会暴露出来。

## 单元测试会让错误远离

一套完整而彻底的单元测试将有助于确保任何潜移默化到你的代码中的错误将被立即发现。

做出一个引入 bug 的更改，您的测试可以在您下一次运行测试时揭示它。如果您发现了一个在单元测试套件范围之外的 bug，您可以为它编写一个测试来确保 bug 不再出现。

## 单元测试节省时间

单元测试是否节省时间是单元测试中最有争议的概念。大多数开发人员认为编写单元测试花费的时间比节省的时间多。我不这样认为——事实上，我持相反的观点。

编写单元测试有助于确保您的代码从一开始就按设计运行。单元测试定义了你的代码应该做什么，这样你就不会花时间去写那些不应该做的事情。

每一个单元测试都变成了一个回归测试，确保在你开发的时候事情继续按照设计的那样工作。它们有助于确保后续的更改不会破坏事物。

它们有助于确保你第一次写的东西是正确的。所有这些好处在短期和长期都可以节省时间。

如果你想一想，你已经在编写代码的时候测试了你的代码。也许你写一个简单的控制台应用程序。至少，你可以编译并看到它运行。

没有人会签入他们不相信有效的代码，你必须做一些事情让你自己相信它是有效的。花时间编写单元测试，你将会用一套回归测试来解耦工作编码。

## 单元测试让人安心

拥有一套完整、完整、彻底的测试来覆盖代码的全部功能可能很难实现，但是拥有它会让你安心。

您可以运行所有这些测试，并知道您的代码按预期工作。您可以重构和更改代码，知道如果您破坏了任何东西，您会马上知道。

知道你的代码的状态，知道它能工作，知道你能无所畏惧地更新和改进它，这是一件非常好的事情。

所有代码都会老化，但是你可以防止你的代码真正成为遗留代码。有几种方法来定义遗留代码，但一种方法是:“你害怕接触的代码。”如果你的代码有单元测试，它很难成为遗留代码。

我们很多人都有害怕接触的代码块，但是有了单元测试，你就不会有那种代码了。单元测试消除了触摸代码的恐惧。

在《有效使用遗留代码 的 [*一书中，Michael Feathers 甚至将遗留代码定义为任何没有单元测试的代码。想要避免您的代码成为遗留代码吗？为它编写单元测试。*](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)

## 单元测试记录了一个类的正确使用

单元测试的好处之一是您的测试可以为后续开发人员定义应该如何使用该类。

实际上，单元测试变成了代码如何工作、它应该做什么以及使用被测试代码的正确方式的简单例子。代码的消费者可以从单元测试中找到让代码做它应该做的事情的正确方法的信息。

# 结论

好吧，如果这些都不能说服你去做单元测试，我不知道还有什么能说服你。

我希望读完这篇文章后，你会对什么是单元测试以及为什么你应该这样做有一个更好的了解。我认为你很难找到后悔花时间编写单元测试的人。因此，如果你没有编写单元测试，考虑马上开始。