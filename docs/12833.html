<html>
<head>
<title>Integrate Crypto Payments in a Classic Commerce App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在经典商务应用中集成加密支付</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/accepting-crypto-payments-in-a-classic-commerce-app-6fcb64a968ce?source=collection_archive---------12-----------------------#2022-07-05">https://betterprogramming.pub/accepting-crypto-payments-in-a-classic-commerce-app-6fcb64a968ce?source=collection_archive---------12-----------------------#2022-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="334d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在不依赖第三方服务的情况下，在任何在线商店上集成定制的安全加密支付方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f407ac66dcb76a26412e4cfdb6d3f549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G745WMVqHYwxzOpheJidUA.jpeg"/></div></div></figure><p id="343e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">电子商务商店在向顾客提供加密支付方式方面进展缓慢。加密支付插件或支付网关集成通常不可用，或者它们依赖第三方托管人来收集、交换和分发资金。考虑到加密货币的拥有率和实验率不断增长，一个“用加密支付”按钮可能会极大地推动销售。</p><p id="52b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文演示了如何在不依赖第三方服务的情况下，将自定义的安全加密支付方法集成到任何在线商店中。编码和维护智能合同需要相当多的幕后工作，我们将这项工作移交给Truffle suite，这是区块链建筑商常用的工具链。为了在开发期间和应用程序后端提供对区块链节点的访问，我们依赖Infura节点，这些节点以慷慨的免费层提供对以太网的访问。一起使用这些工具将使开发过程更加容易。</p><h1 id="39c6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">场景:阿梅顿书店</h1><p id="a7a4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">目标是建立一个可下载电子书的店面，接受以太坊区块链的本地货币(“以太”)和ERC20 stablecoins(与美元挂钩的支付令牌)作为支付方式。从现在开始我们称它为“Amethon”。</p><p id="c464" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的实现可以在附带的<a class="ae mk" href="https://github.com/elmariachi111/amethon" rel="noopener ugc nofollow" target="_blank"> GitHub monorepo </a>上找到。所有代码都是用TypeScript编写的，可以使用包的<code class="fe ml mm mn mo b">yarn build</code>或<code class="fe ml mm mn mo b">yarn dev</code>命令编译。</p><p id="2a24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将一步一步地引导您完成这个过程，但是熟悉智能合约、以太坊以及Solidity编程语言的少量知识可能会对您的阅读有所帮助。我们建议您先阅读一些基础知识，以熟悉生态系统的基本概念。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/c533bccde96b721f96bf9391274d526a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b7qKremqEE-QCq5O9uJs8g.gif"/></div></div></figure><h2 id="c054" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">应用程序结构</h2><p id="eb40" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">商店后端是作为一个CRUD API构建的，它本身没有连接到任何区块链。它的前端触发该API上的支付请求，客户使用他们的加密钱包完成支付。</p><p id="415a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Amethon被设计为一个“传统的”电子商务应用程序，它处理业务逻辑，除了支付本身之外，不依赖任何链上数据。在结帐过程中，后端发布带有唯一标识符(如“发票号”)的<code class="fe ml mm mn mo b">PaymentRequest</code>对象，用户将该标识符附加到他们的支付交易中。</p><p id="3c85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">后台守护程序监听相应的合同事件，并在检测到付款时更新商店的数据库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/fd7f38650c344a0d30d3627890a50def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HoVu2MoIviKsTItV.png"/></div></div></figure><p id="c6ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nd">Amethon支付结算</em></p><h1 id="c2c9" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">付款接收方合同</h1><p id="2a4d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在Amethon的中心,<code class="fe ml mm mn mo b">PaymentReceiver</code>智能合同代表店面所有者接受和支付款项。</p><p id="553f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每当用户向<code class="fe ml mm mn mo b">PaymentReceiver</code>合同发送资金时，就会发出一个<code class="fe ml mm mn mo b">PaymentReceived</code>事件，其中包含支付来源(客户的以太坊账户)、总价值、使用的ERC20令牌合同地址以及引用后端数据库条目的<code class="fe ml mm mn mo b">paymentId</code>等信息。</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="4f26" class="mq lo iq mo b gy ni nj l nk nl">event PaymentReceived(<br/>    address indexed buyer,<br/>    uint256 value,<br/>    address token,<br/>    bytes32 paymentId<br/>  );</span></pre><p id="005d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以太坊合约的行为类似于基于用户(又名“外部所有”/ EOA)的账户，并在部署时获得自己的账户地址。接收本地以太货币需要实现<code class="fe ml mm mn mo b">receive</code>和<code class="fe ml mm mn mo b">fallback</code>函数，当有人将以太资金转移到合同时调用这两个函数，并且没有其他函数签名与该调用匹配:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="bab5" class="mq lo iq mo b gy ni nj l nk nl">receive() external payable {<br/>    emit PaymentReceived(msg.sender, msg.value, ETH_ADDRESS, bytes32(0));<br/>  }</span><span id="9a62" class="mq lo iq mo b gy nm nj l nk nl">  fallback() external payable {<br/>    emit PaymentReceived(<br/>      msg.sender, msg.value, ETH_ADDRESS, bytes32(msg.data));<br/>  }</span></pre><p id="0a17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mk" href="https://docs.soliditylang.org/en/v0.8.11/contracts.html?highlight=receive#special-functions" rel="noopener ugc nofollow" target="_blank">正式固化文档</a>指出了这些函数之间的细微差别:<code class="fe ml mm mn mo b">receive</code>在传入的事务不包含附加数据时被调用，否则<code class="fe ml mm mn mo b">fallback</code>被调用。以太坊的原生货币本身不是ERC20令牌，除了作为计数单位之外没有任何效用。然而，它有一个可识别的地址<code class="fe ml mm mn mo b">(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)</code>，我们用它在我们的<code class="fe ml mm mn mo b">PaymentReceived</code>事件中发出以太支付的信号。</p><p id="ce40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，以太传输有一个主要缺点:接收时允许的计算量极低。顾客发送的气体仅仅允许我们发出一个事件，但不能将资金重定向到店主的原始地址。因此，收货人合同保留所有进货乙醚，并允许店主随时将它们发放到自己的账户:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="097a" class="mq lo iq mo b gy ni nj l nk nl">function getBalance() public view returns (uint256) {<br/>  return address(this).balance;<br/>}</span><span id="53ac" class="mq lo iq mo b gy nm nj l nk nl">function release() external onlyOwner {<br/>  (bool ok, ) = _owner.call{value: getBalance()}("");<br/>  require(ok, "Failed to release Eth");<br/>}</span></pre><p id="591b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于历史原因，接受ERC20代币作为付款稍微困难一些。2015年，<a class="ae mk" href="https://eips.ethereum.org/EIPS/eip-20" rel="noopener ugc nofollow" target="_blank">初始规范</a>的作者无法预测即将到来的需求，并尽可能保持ERC20标准的接口简单。最值得注意的是，ERC20契约不能保证通知接收者有关转移的信息，所以当ERC20令牌被转移给我们的<code class="fe ml mm mn mo b">PaymentReceiver</code>时，它无法执行代码。</p><p id="311a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ERC20生态系统已经发展，现在包括更多规格。例如，<a class="ae mk" href="https://eips.ethereum.org/EIPS/eip-1363" rel="noopener ugc nofollow" target="_blank"> EIP 1363 </a>标准解决了这个问题。不幸的是，你不能依赖主要的stablecoin平台来实现它。</p><p id="8bd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此Amethon必须以“经典”方式接受ERC20代币支付。合同不是在不知情的情况下在上面“丢下”代币，而是代表客户处理转账。这要求用户首先<em class="nd">允许</em>合同处理他们一定数量的资金。这不方便地要求用户在与真正的支付方法交互之前，首先将<code class="fe ml mm mn mo b">Approval</code>交易传输到ERC20令牌合同。EIP-2612可能会改善这种情况，但是，我们暂时还得按老规矩来。</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="3109" class="mq lo iq mo b gy ni nj l nk nl">function payWithErc20(<br/>    IERC20 erc20,<br/>    uint256 amount,<br/>    uint256 paymentId<br/>  ) external {<br/>    erc20.transferFrom(msg.sender, _owner, amount);<br/>    emit PaymentReceived(<br/>      msg.sender,<br/>      amount,<br/>      address(erc20),<br/>      bytes32(paymentId)<br/>    );<br/>  }</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/981f2d54c906c1d1c71fba6a3e659db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*cwM0tdRKL9yfTRfV.png"/></div></figure><h2 id="1f0a" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">编译、部署和可变安全</h2><p id="d18f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一些工具链允许开发人员编译、部署以太坊智能合约并与之交互，但最先进的工具链之一是<a class="ae mk" href="https://trufflesuite.com/" rel="noopener ugc nofollow" target="_blank"> Truffle Suite </a>。它带有一个基于<a class="ae mk" href="https://trufflesuite.com/ganache/" rel="noopener ugc nofollow" target="_blank"> Ganache </a>的内置开发区块链，以及一个允许您自动化和安全运行合同部署的迁移概念。</p><p id="e084" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在“真正的”区块链基础设施上部署契约，比如以太坊测试网，需要两件事:一个连接到区块链节点的以太坊提供者，一个账户的私钥/钱包助记符，或者一个可以代表账户签署交易的钱包连接。该帐户还需要有一些(测试网)醚，以支付部署期间的汽油费。</p><p id="7e1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">元掩码完成了这项工作。创建一个除了部署之外没有其他用途的新帐户(它将成为合同的“所有者”)，并使用您首选的testnet水龙头为其注入一些乙醚(我们推荐<a class="ae mk" href="https://faucet.paradigm.xyz/" rel="noopener ugc nofollow" target="_blank">范式</a>)。通常，您现在会导出该帐户的私钥(“Account Details”&gt;“Export Private Key”)，并将其与您的开发环境连接起来，但为了规避该工作流隐含的所有安全问题，Truffle附带了一个专用的仪表板网络和web应用程序，可用于在浏览器中使用Metamask签署合同部署等交易。要启动它，在一个新的终端窗口中执行<code class="fe ml mm mn mo b">truffle dashboard</code>,并使用带有活动元掩码扩展的浏览器访问<a class="ae mk" href="http://localhost:24012/" rel="noopener ugc nofollow" target="_blank">http://localhost:24012/</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/675c9a2ab40edf2e1bfc5b837ffd1209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WtAJnHMu8URWmAP4.png"/></div></div></figure><p id="4ea3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用truffle的仪表板在不暴露私钥的情况下签署交易</p><p id="2868" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Amethon项目也依赖于各种秘密设置。注意，由于<code class="fe ml mm mn mo b">dotenv-flow</code>的工作方式，<code class="fe ml mm mn mo b">.env</code>文件包含样本或公开可见的设置，它们会被gitignored <code class="fe ml mm mn mo b">.env.local</code>文件覆盖。将包子目录中的所有<code class="fe ml mm mn mo b">.env</code>文件复制到<code class="fe ml mm mn mo b">.env.local</code>并覆盖它们的值。</p><p id="a5e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要将您的本地环境连接到以太网，请访问同步的区块链节点。虽然您当然可以下载众多客户端中的一个，并等待它在您的机器上同步，但是将您的应用程序连接到作为服务提供的以太坊节点要方便得多，最著名的是<a class="ae mk" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"> Infura </a>。他们的免费层为您提供三个不同的访问密钥和每月100k RPC请求，支持广泛的以太坊网络。</p><p id="3f9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注册后，记下您的Infura密钥，并将其作为<code class="fe ml mm mn mo b">INFURA_KEY</code>放入您的<code class="fe ml mm mn mo b">contracts .env.local</code>中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6962112eb8746b96030363892e2aad35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vudtdY-EbpS_Vr7X.png"/></div></div></figure><p id="427a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想与合同进行交互，例如在Kovan网络上，只需将相应的truffle配置和一个<code class="fe ml mm mn mo b">--network kovan</code>选项添加到所有的<code class="fe ml mm mn mo b">truffle</code>命令中。您甚至可以启动一个交互式控制台:<code class="fe ml mm mn mo b">yarn truffle console --network kovan.</code>本地测试合同不需要任何特殊的设置过程。为了简化我们的生活，我们使用Metamask通过truffle dashboard提供者注入的提供者和签名者。</p><p id="a2e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">转到<code class="fe ml mm mn mo b">contracts</code>文件夹并运行<code class="fe ml mm mn mo b">yarn truffle develop.</code>这将启动一个有预充值账户的本地区块链，并在其上打开一个连接的控制台。要将元掩码wallet连接到开发网络，请使用<a class="ae mk" href="http://localhost:9545/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9545 </a>作为其RPC端点来创建一个新网络。记录链开始时列出的帐户:您可以将他们的私钥导入您的Metamask钱包，代表他们在您当地的区块链发送交易。</p><p id="c049" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">键入<code class="fe ml mm mn mo b">compile</code>一次编译所有契约，并将它们部署到本地链。使用<code class="fe ml mm mn mo b">migrate.</code>您可以通过请求它们当前部署的实例来与契约交互，并像这样调用它的函数:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="6113" class="mq lo iq mo b gy ni nj l nk nl">pr = await PaymentReceiver.deployed()<br/>balance = await pr.getBalance()</span></pre><p id="9772" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦您对结果感到满意，您就可以将它们部署在公共测试网(或mainnet)上，也可以:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="4921" class="mq lo iq mo b gy ni nj l nk nl">yarn truffle migrate --interactive --network dashboard</span></pre><h1 id="4c8a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">后端</h1><h2 id="0faf" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">商店API / CRUD</h2><p id="d3d9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们的后端提供了一个JSON API来与支付实体进行高级交互。我们已经决定使用<a class="ae mk" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>和一个本地SQLite数据库来支持<code class="fe ml mm mn mo b">Books</code>和<code class="fe ml mm mn mo b">PaymentRequests</code>的实体。书籍代表了我们商店的主要实体，有一个零售价，以美元美分表示。要在数据库中植入书籍，可以使用附带的<code class="fe ml mm mn mo b">seed.ts</code>文件。编译完文件后，您可以通过调用<code class="fe ml mm mn mo b">node build/seed.js.</code>来执行它</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="120f" class="mq lo iq mo b gy ni nj l nk nl">//backend/src/entities/Book.ts<br/>import { Entity, Column, PrimaryColumn, OneToMany } from "typeorm";<br/>import { PaymentRequest } from "./PaymentRequest";</span><span id="f1cd" class="mq lo iq mo b gy nm nj l nk nl">@Entity()<br/>export class Book {<br/>  @PrimaryColumn()<br/>  ISBN: string;</span><span id="506d" class="mq lo iq mo b gy nm nj l nk nl">  @Column()<br/>  title: string;</span><span id="0735" class="mq lo iq mo b gy nm nj l nk nl">  @Column()<br/>  retailUSDCent: number;</span><span id="4a55" class="mq lo iq mo b gy nm nj l nk nl">  @OneToMany(<br/>    () =&gt; PaymentRequest,<br/>    (paymentRequest: PaymentRequest) =&gt; paymentRequest.book<br/>  )<br/>  payments: PaymentRequest[];<br/>}</span></pre><p id="ddc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:在任何计算机系统上，强烈建议不要将货币值存储为浮点值<a class="ae mk" href="https://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency" rel="noopener ugc nofollow" target="_blank">，因为对浮点值进行操作肯定会引入精度误差。这也是为什么所有加密令牌都使用18位十进制数字，而Solidity甚至没有浮点数据类型。1以太实际上代表最小的以太单位“1000000000000000000】卫。</a></p><p id="777c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于打算<em class="nd">从Amethon购买</em>一本书的用户，首先通过调用<code class="fe ml mm mn mo b">/books/:isbn/order</code>路线为他们的商品创建一个单独的<code class="fe ml mm mn mo b">PaymentRequest</code>。这将创建一个新的唯一标识符，该标识符必须随每个请求一起发送。</p><p id="500b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里使用普通整数，但是，对于真实世界的用例，您将使用更复杂的东西。唯一的限制是id的二进制长度必须适合32个字节(<code class="fe ml mm mn mo b">uint256</code>)。每个<code class="fe ml mm mn mo b">PaymentRequest</code>继承了图书的零售价值(单位为美分),并带有客户地址，<code class="fe ml mm mn mo b">fulfilledHash</code>和<code class="fe ml mm mn mo b">paidUSDCent</code>将在购买过程中确定。</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="d226" class="mq lo iq mo b gy ni nj l nk nl">//backend/src/entities/PaymentRequest.ts<br/>@Entity()<br/>export class PaymentRequest {<br/>  @PrimaryGeneratedColumn()<br/>  id: number;</span><span id="1e0e" class="mq lo iq mo b gy nm nj l nk nl">  @Column("varchar", { nullable: true })<br/>  fulfilledHash: string | null;</span><span id="f721" class="mq lo iq mo b gy nm nj l nk nl">  @Column()<br/>  address: string;</span><span id="b457" class="mq lo iq mo b gy nm nj l nk nl">  @Column()<br/>  priceInUSDCent: number;</span><span id="661f" class="mq lo iq mo b gy nm nj l nk nl">  @Column("mediumint", { nullable: true })<br/>  paidUSDCent: number;</span><span id="7db4" class="mq lo iq mo b gy nm nj l nk nl">  @ManyToOne(() =&gt; Book, (book) =&gt; book.payments)<br/>  book: Book;<br/>}</span></pre><p id="56f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建一个<code class="fe ml mm mn mo b">PaymentRequest</code>实体的初始订单请求如下所示:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="4a74" class="mq lo iq mo b gy ni nj l nk nl">POST http://localhost:3001/books/978-0060850524/order<br/>Content-Type: application/json</span><span id="2fd7" class="mq lo iq mo b gy nm nj l nk nl">{<br/>  "address": "0xceeca1AFA5FfF2Fe43ebE1F5b82ca9Deb6DE3E42"<br/>}<br/>---&gt;<br/>{<br/>  "paymentRequest": {<br/>    "book": {<br/>      "ISBN": "978-0060850524",<br/>      "title": "Brave New World",<br/>      "retailUSDCent": 1034<br/>    },<br/>    "address": "0xceeca1AFA5FfF2Fe43ebE1F5b82ca9Deb6DE3E42",<br/>    "priceInUSDCent": 1034,<br/>    "fulfilledHash": null,<br/>    "paidUSDCent": null,<br/>    "id": 6<br/>  },<br/>  "receiver": "0x7A08b6002bec4B52907B4Ac26f321Dfe279B63E9"<br/>}</span></pre><h2 id="4da7" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">区块链监听器后台服务</h2><p id="3a6b" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">查询区块链的状态树不会耗费客户端任何精力，但是节点仍然需要计算。当这些操作变得计算量过大时，它们可能会超时。对于实时交互，强烈建议不要轮询链状态，而是监听事务发出的事件。这需要使用支持WebSocket的提供者，所以确保使用以<code class="fe ml mm mn mo b">wss://</code>开头的Infura端点作为后端的<code class="fe ml mm mn mo b">PROVIDER_RPC</code>环境变量的URL方案。然后您可以启动后端的<code class="fe ml mm mn mo b">daemon.ts</code>脚本并监听任何链上的<code class="fe ml mm mn mo b">PaymentReceived</code>事件:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="85d0" class="mq lo iq mo b gy ni nj l nk nl">//backend/src/daemon.ts<br/>  const web3 = new Web3(process.env.PROVIDER_RPC as string);<br/>  const paymentReceiver = new web3.eth.Contract(<br/>    paymentReceiverAbi as AbiItem[],<br/>    process.env.PAYMENT_RECEIVER_CONTRACT as string<br/>  );</span><span id="42c2" class="mq lo iq mo b gy nm nj l nk nl">  const emitter = paymentReceiver.events.PaymentReceived({<br/>    fromBlock: "0",<br/>  });</span><span id="ccb2" class="mq lo iq mo b gy nm nj l nk nl">  emitter.on("data", handlePaymentEvent);<br/>})();</span></pre><p id="92a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意我们是如何用一个<a class="ae mk" href="https://docs.soliditylang.org/en/v0.8.11/abi-spec.html" rel="noopener ugc nofollow" target="_blank">应用程序二进制接口</a>实例化<code class="fe ml mm mn mo b">Contract</code>实例的。Solidity编译器生成ABI，并包含RPC客户端关于如何编码事务以调用和解码智能合约上的函数、事件或参数的信息。</p><p id="031e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦实例化，您就可以在契约的<code class="fe ml mm mn mo b">PaymentReceived</code>日志上挂钩一个监听器(从块0开始)并在收到后处理它们。</p><p id="a08c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于Amethon支持Ether和stable coin(“USD”)支付，守护程序的<code class="fe ml mm mn mo b">handlePaymentEvent</code>方法首先检查用户支付中使用了哪种令牌，并在需要时计算其美元值:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="e90d" class="mq lo iq mo b gy ni nj l nk nl">//backend/src/daemon.ts<br/>const ETH_USD_CENT = 2_200 * 100;<br/>const ACCEPTED_USD_TOKENS = (process.env.STABLECOINS as string).split(",");<br/>const NATIVE_ETH = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";</span><span id="dd8c" class="mq lo iq mo b gy nm nj l nk nl">const handlePaymentEvent = async (event: PaymentReceivedEvent) =&gt; {<br/>  const args = event.returnValues;<br/>  const paymentId = web3.utils.hexToNumber(args.paymentId);<br/>  const decimalValue = web3.utils.fromWei(args.value);<br/>  const payment = await paymentRepo.findOne({ where: { id: paymentId } });<br/>  let valInUSDCents;<br/>  if (args.token === NATIVE_ETH) {<br/>    valInUSDCents = parseFloat(decimalValue) * ETH_USD_CENT;<br/>  } else {<br/>    if (!ACCEPTED_USD_TOKENS.includes(args.token)) {<br/>      return console.error("payments of that token are not supported");<br/>    }<br/>    valInUSDCents = parseFloat(decimalValue) * 100;<br/>  }</span><span id="6856" class="mq lo iq mo b gy nm nj l nk nl">  if (valInUSDCents &lt; payment.priceInUSDCent) {<br/>    return console.error(`payment [${paymentId}] not sufficient`);<br/>  }</span><span id="90d9" class="mq lo iq mo b gy nm nj l nk nl">  payment.paidUSDCent = valInUSDCents;<br/>  payment.fulfilledHash = event.transactionHash;<br/>  await paymentRepo.save(payment);<br/>};</span></pre><h1 id="cd62" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">前端</h1><p id="b354" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们书店的前端建立在官方的<a class="ae mk" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create React App </a>模板上，支持Typescript，并使用<a class="ae mk" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> Tailwind </a>作为基本样式。它支持所有已知的CRA脚本，所以在你创建了自己的<code class="fe ml mm mn mo b">.env.local</code>文件后，你可以通过<code class="fe ml mm mn mo b">yarn start</code>在本地启动它，该文件包含你之前创建的收款人和稳定币合同地址。</p><p id="0255" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:CRA5将其webpack依赖关系升级到一个不再支持浏览器中节点聚合填充的版本。这打破了今天几乎所有以太坊相关项目的构建。避免弹出的一个常见解决方法是挂钩到CRA构建过程。我们正在使用<a class="ae mk" href="https://github.com/timarney/react-app-rewired" rel="noopener ugc nofollow" target="_blank"> react-app-rewired </a>但是你可以简单地停留在CRA4直到社区提出一个更好的解决方案。</p><h2 id="198b" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">连接Web3钱包</h2><p id="4304" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">任何Dapp的关键部分是连接到用户的钱包。您可以尝试按照<a class="ae mk" href="https://docs.metamask.io/guide/getting-started.html" rel="noopener ugc nofollow" target="_blank">官方元掩码文档</a>手动连接该流程，但是我们强烈建议使用合适的React库。我们发现诺亚·辛斯梅斯特的web3-react是最好的。检测和连接一个web3客户端归结为这个代码<code class="fe ml mm mn mo b">(ConnectButton.tsx):</code></p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="146c" class="mq lo iq mo b gy ni nj l nk nl">//frontend/src/components/ConnectButton.ts<br/>import { useWeb3React } from "@web3-react/core";<br/>import { InjectedConnector } from "@web3-react/injected-connector";<br/>import React from "react";<br/>import Web3 from "web3";</span><span id="2952" class="mq lo iq mo b gy nm nj l nk nl">export const injectedConnector = new InjectedConnector({<br/>  supportedChainIds: [42, 1337, 31337], //Kovan, Truffle, Hardhat<br/>});</span><span id="0e3e" class="mq lo iq mo b gy nm nj l nk nl">export const ConnectButton = () =&gt; {<br/>  const { activate, account, active } = useWeb3React&lt;Web3&gt;();</span><span id="5c40" class="mq lo iq mo b gy nm nj l nk nl">  const connect = () =&gt; {<br/>    activate(injectedConnector, console.error);<br/>  };</span><span id="cbb1" class="mq lo iq mo b gy nm nj l nk nl">  return active ? (<br/>    &lt;div className="text-sm"&gt;connected as: {account}&lt;/div&gt;<br/>  ) : (<br/>    &lt;button className="btn-primary" onClick={connect}&gt;<br/>      Connect<br/>    &lt;/button&gt;<br/>  );<br/>};</span></pre><p id="50b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过将<code class="fe ml mm mn mo b">App</code>的代码包装在<code class="fe ml mm mn mo b">&lt;Web3ReactProvider getLibrary={getWeb3Library}&gt;</code>上下文中，您可以从任何组件使用<code class="fe ml mm mn mo b">useWeb3React</code>钩子访问web3提供者、帐户和连接状态。由于Web3React对于正在使用的web3库(<a class="ae mk" href="https://www.npmjs.com/package/web3" rel="noopener ugc nofollow" target="_blank"> Web3.js </a>或<a class="ae mk" href="https://www.npmjs.com/package/ethers" rel="noopener ugc nofollow" target="_blank"> ethers.js </a>)是不可知的，所以您必须提供一个回调来生成一个连接的“库”:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="31af" class="mq lo iq mo b gy ni nj l nk nl">//frontend/src/App.tsx<br/>import Web3 from "web3";<br/>function getWeb3Library(provider: any) {<br/>  return new Web3(provider);<br/>}</span></pre><h1 id="1d92" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">支付流程</h1><p id="d6d5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">从Amethon后端加载可用的书籍后，<code class="fe ml mm mn mo b">&lt;BookView&gt;</code>组件首先检查该用户的付款是否已经处理，然后显示捆绑在<code class="fe ml mm mn mo b">&lt;PaymentOptions&gt;</code>组件中的所有支持的付款选项。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/22d987770cd15748a45b545df4b1827e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3vLoOHOTkTT3YnGu.png"/></div></div></figure><h2 id="8bc3" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">用ETH支付</h2><p id="33f8" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><code class="fe ml mm mn mo b">&lt;PayButton&gt;</code>负责向<code class="fe ml mm mn mo b">PaymentReceiver</code>合同发起直接以太网传输。因为这些调用不直接与契约的接口交互，所以我们甚至不需要初始化契约实例:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="8d7e" class="mq lo iq mo b gy ni nj l nk nl">//frontend/src/components/PayButton.tsx<br/>const weiPrice = usdInEth(paymentRequest.priceInUSDCent);</span><span id="53c8" class="mq lo iq mo b gy nm nj l nk nl">const tx = web3.eth.sendTransaction({<br/>  from: account, //the current user<br/>  to: paymentRequest.receiver.options.address, //the PaymentReceiver contract address<br/>  value: weiPrice, //the eth price in wei (10**18)<br/>  data: paymentRequest.idUint256, //the paymentRequest's id, converted to a uint256 hex string<br/>});<br/>const receipt = await tx;<br/>onConfirmed(receipt);</span></pre><p id="3833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如前所述，由于新事务带有一个<code class="fe ml mm mn mo b">msg.data</code>字段，Solidity的约定触发<code class="fe ml mm mn mo b">PaymentReceiver's fallback() external payable</code>函数，该函数用Ether的令牌地址发出一个<code class="fe ml mm mn mo b">PaymentReceived</code>事件。这由后台化的链监听器获取，该监听器相应地更新后端的数据库状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a7c17e36bc27d9c3cce86074d77b809a.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/0*xKuIujXvknA2uF35.png"/></div></figure><p id="7b8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">静态助手函数负责将当前的美元价格转换为以太值。在现实世界的场景中，从像<a class="ae mk" href="https://www.coingecko.com/en/api" rel="noopener ugc nofollow" target="_blank"> Coingecko </a>这样的可信第三方或者像<a class="ae mk" href="https://docs.uniswap.org/sdk/guides/fetching-prices" rel="noopener ugc nofollow" target="_blank"> Uniswap </a>这样的DEX查询汇率。这样做允许您扩展Amethon以接受任意令牌作为支付。</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="8ac1" class="mq lo iq mo b gy ni nj l nk nl">//frontend/src/modules/index.ts<br/>const ETH_USD_CENT = 2_200 * 100;<br/>export const usdInEth = (usdCent: number) =&gt; {<br/>  const eth = (usdCent / ETH_USD_CENT).toString();<br/>  const wei = Web3.utils.toWei(eth, "ether");<br/>  return wei;<br/>};</span></pre><h2 id="4af7" class="mq lo iq bd lp mr ms dn lt mt mu dp lx la mv mw lz le mx my mb li mz na md nb bi translated">用ERC20 Stablecoins支付</h2><p id="f287" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">由于前面提到的原因，从用户的角度来看，ERC20代币支付稍微复杂一些，因为人们不能简单地在合同中放弃代币。像几乎所有有类似用例的人一样，我们必须首先请求用户给他们的<em class="nd">许可</em>让我们的<code class="fe ml mm mn mo b">PaymentReceiver</code>契约转移他们的资金，并调用代表用户转移所请求资金的实际<code class="fe ml mm mn mo b">payWithEerc20</code>方法。</p><p id="dbe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是<code class="fe ml mm mn mo b">PayWithStableButton</code>的代码，用于授予对所选ERC20令牌的权限:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="fb53" class="mq lo iq mo b gy ni nj l nk nl">//frontend/src/components/PayWithStableButton.tsx<br/>const contract = new web3.eth.Contract(<br/>  IERC20ABI as AbiItem[],<br/>  process.env.REACT_APP_STABLECOINS<br/>);</span><span id="50e0" class="mq lo iq mo b gy nm nj l nk nl">const appr = await coin.methods<br/>  .approve(<br/>    paymentRequest.receiver.options.address, //receiver contract's address<br/>    price // USD value in wei precision (1$ = 10^18wei)<br/>  )<br/>  .send({<br/>    from: account,<br/>  });</span></pre><p id="f373" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，设置ERC20令牌的<code class="fe ml mm mn mo b">Contract</code>实例所需的ABI接收通用IERC20 ABI。我们使用从<a class="ae mk" href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin的官方库</a>生成的ABI，但是任何其他生成的ABI都可以完成这项工作。批准转账后，我们可以开始付款:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="2796" class="mq lo iq mo b gy ni nj l nk nl">//frontend/src/components/PayWithStableButton.tsx<br/>const contract = new web3.eth.Contract(<br/>  PaymentReceiverAbi as AbiItem[],<br/>  paymentRequest.receiver.options.address<br/>);<br/>const tx = await contract.methods<br/>  .payWithErc20(<br/>    process.env.REACT_APP_STABLECOINS, //identifies the ERC20 contract<br/>    weiPrice, //price in USD (it's a stablecoin)<br/>    paymentRequest.idUint256 //the paymentRequest's id as uint256<br/>  )<br/>  .send({<br/>    from: account,<br/>  });</span></pre><h1 id="e5ea" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">签署下载请求</h1><p id="dfb0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">最后，我们的客户可以下载他们的电子书。但是有一个问题:由于我们没有“登录”用户，我们如何确保只有真正为内容付费的用户才能调用我们的下载路径？答案是加密签名。在将用户重定向到我们的后端之前，<code class="fe ml mm mn mo b">&lt;DownloadButton&gt;</code>组件允许用户签署一条独特的消息，作为帐户控制的证明提交:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="ddf9" class="mq lo iq mo b gy ni nj l nk nl">//frontend/src/components/DownloadButton.tsx<br/>const download = async () =&gt; {<br/>  const url = `${process.env.REACT_APP_BOOK_SERVER}/books/${book.ISBN}/download`;</span><span id="f027" class="mq lo iq mo b gy nm nj l nk nl">  const nonce = Web3.utils.randomHex(32);<br/>  const dataToSign = Web3.utils.keccak256(`${account}${book.ISBN}${nonce}`);</span><span id="8394" class="mq lo iq mo b gy nm nj l nk nl">  const signature = await web3.eth.personal.sign(dataToSign, account, "");</span><span id="5df7" class="mq lo iq mo b gy nm nj l nk nl">  const resp = await (<br/>    await axios.post(<br/>      url,<br/>      {<br/>        address: account,<br/>        nonce,<br/>        signature,<br/>      },<br/>      { responseType: "arraybuffer" }<br/>    )<br/>  ).data;<br/>  // present that buffer as download to the user...<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/912103a65bb008d7747a3e1bd6eac2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/0*x51lMEth-ZxaO2iP.png"/></div></figure><p id="182a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">后端的<code class="fe ml mm mn mo b">download</code>路由可以恢复签名者的地址，方法是以与用户之前相同的方式组装消息，并使用消息和提供的签名调用crypto suite的<code class="fe ml mm mn mo b">ecrecover</code>方法。如果恢复的地址与我们数据库中的一个已履行的<code class="fe ml mm mn mo b">PaymentRequest</code>相匹配，我们知道我们可以允许访问所请求的电子书资源:</p><pre class="kg kh ki kj gt ne mo nf ng aw nh bi"><span id="0386" class="mq lo iq mo b gy ni nj l nk nl">//backend/src/server.ts<br/>app.post(<br/>  "/books/:isbn/download",<br/>  async (req: DownloadBookRequest, res: Response) =&gt; {<br/>    const { signature, address, nonce } = req.body;</span><span id="fd1a" class="mq lo iq mo b gy nm nj l nk nl">    //rebuild the message the user created on their frontend<br/>    const signedMessage = Web3.utils.keccak256(<br/>      `${address}${req.params.isbn}${nonce}`<br/>    );</span><span id="0e6d" class="mq lo iq mo b gy nm nj l nk nl">    //recover the signer's account from message &amp; signature<br/>    const signingAccount = await web3.eth.accounts.recover(<br/>      signedMessage,<br/>      signature,<br/>      false<br/>    );</span><span id="b921" class="mq lo iq mo b gy nm nj l nk nl">    if (signingAccount !== address) {<br/>      return res.status(401).json({ error: "not signed by address" });<br/>    }</span><span id="96af" class="mq lo iq mo b gy nm nj l nk nl">    //deliver the binary content...<br/>  }<br/>);</span></pre><p id="77ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里提供的帐户所有权的证明仍然不是绝对可靠的。任何知道所购买物品的有效签名的人都可以成功地呼叫下载路线。最后的解决办法是首先在后端创建随机消息，并让客户签字批准。由于用户无法理解他们应该签署的乱码，他们不知道我们是否会欺骗他们签署另一个可能危及他们账户的有效交易。</p><p id="3286" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然我们已经通过使用web3的<code class="fe ml mm mn mo b">eth.personal.sign</code>方法避免了这种攻击，但是以一种人类友好的方式显示要签名的消息更好。这就是<a class="ae mk" href="https://eips.ethereum.org/EIPS/eip-712" rel="noopener ugc nofollow" target="_blank"> EIP-712 </a>所实现的——meta mask已经支持的标准<a class="ae mk" href="https://docs.metamask.io/guide/signing-data.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="4f87" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论和下一步措施</h1><p id="29b7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">对于开发者来说，在电子商务网站上接受支付从来都不是一件容易的事情。虽然web3生态系统允许店面接受数字货币，但独立于服务的插件解决方案的可用性仍然不足。本文展示了一种安全、简单和定制的方式来请求和接收加密支付。</p><p id="4994" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法还有进一步发展的空间。以太坊主网上ERC20传输的天然气成本远远超过了我们的账面价格。低价商品的加密支付在像<a class="ae mk" href="https://www.xdaichain.com/" rel="noopener ugc nofollow" target="_blank"> Gnosis Chain </a>(他们的“本地”以太货币是戴，所以你甚至不用担心这里稳定的货币转移)或<a class="ae mk" href="https://arbitrum.io/" rel="noopener ugc nofollow" target="_blank"> Arbitrum </a>这样的天然气友好型环境中是有意义的。您还可以使用购物车结帐扩展后端，或者使用DEXes将任何传入的ERC20令牌交换为您喜欢的货币。</p><p id="a737" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">毕竟，web3的承诺是允许没有中间人的直接货币交易，并为希望吸引精通密码的客户的在线商店增加巨大价值。</p></div></div>    
</body>
</html>