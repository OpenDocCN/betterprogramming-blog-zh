<html>
<head>
<title>Modern Javascript Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代Javascript技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modern-javascript-techniques-cf2084236af4?source=collection_archive---------4-----------------------#2019-08-28">https://betterprogramming.pub/modern-javascript-techniques-cf2084236af4?source=collection_archive---------4-----------------------#2019-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d6e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">追求纯净的干净和可扩展的语法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/350be117ec75a9e8dbafe0a99518a365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jj5ucCqbGquDKXfdXWKGcg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格里特·维穆伦在<a class="ae ky" href="https://unsplash.com/photos/hLmIbKb7PCA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b5a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一门非常复杂且适应性很强的语言，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>拥有许多优势，而且每年都在增长。难怪该语言和社区如此受欢迎，因为它在将用户界面交互性和响应性web设计引入互联网方面发挥了巨大作用。虽然有时很复杂，但这种语言被证明很容易掌握，并且通过在客户端执行可以获得更快的用户体验。</p><p id="13a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很长一段时间，JavaScript被视为有问题和有缺陷的。这从来都不是语言的问题，而是运行语言的平台:浏览器。这个生态系统是有缺陷的，因为有如此多的分支派别——最明显的是微软的介入，把一切都搞砸了。</p><p id="c226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一时期，Mozilla一直是理性的声音，但直到Chrome获得了足够的市场份额，人们才开始考虑引擎应该是什么样子以及如何构建的标准。</p><p id="3e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<a class="ae ky" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> V8 </a>设定标准就是<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>随后的构建方式。作为一种具有服务器端执行支持的完整编程语言，JavaScript现在为现代web应用程序提供支持，并在整个技术堆栈中扩展。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="db39" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法</h1><p id="038f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为智能法律合同开源项目<a class="ae ky" href="https://www.accordproject.org/" rel="noopener ugc nofollow" target="_blank"> Accord Project </a>的维护者和全栈工程师，我的经历向我展示了JavaScript可以实现的强大应用。</p><p id="2cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我变得非常热衷于学习和采用更好、更有效的语言实践。我将分享这一点，作为对他人的有益参考，也作为我自己未来的历史参考。我希望在后续更深入的文章中扩展这个话题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/d41861a7fc5b856757535e1e85817e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9x1Uz7BusTjLUBDZ7ny8MA.png"/></div></div></figure><p id="7e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在Accord项目中的大部分工作都是用JavaScript编写的，还混合了一些特定领域的语言。为了构建一个可靠的技术栈，允许智能合同的稳定性和效率，Accord项目依赖于JavaScript，以及<a class="ae ky" href="https://ocaml.org/" rel="noopener ugc nofollow" target="_blank"> OCaml </a>和<a class="ae ky" href="https://www.accordproject.org/projects/ergo" rel="noopener ugc nofollow" target="_blank"> Ergo </a>。JavaScript提供了最好的工具集，可以在各种各样的用例及环境中处理这个问题。我们选择JavaScript是因为它的适用性、库的多样性和易用性。这种语言的语法既有表现力又很简单。</p><p id="516c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Accord项目核心代码库包含超过25万行代码。连同我们的模板库和UI组件，有将近一百万个。</p><h2 id="99cb" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">大纲:</h2><p id="c66e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">→ <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#db39" rel="noopener">方法</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#1519" rel="noopener">基础</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#205c" rel="noopener">工作流程</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#7389" rel="noopener">操作</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#3f3d" rel="noopener">功能</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#eff3" rel="noopener">异步</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#dc1e" rel="noopener">功能编程</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#63d0" rel="noopener">结论</a> <br/> → <a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#fff0" rel="noopener">资源</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1519" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本原则</h1><h2 id="0746" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">可理解的</h2><p id="48f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">文档代码。可读性对于编程来说是至关重要的，因为是人类需要解释代码来进行协作。与通过用单个字母命名变量来节省一些额外的字符相比，足够冗长以便日后或对其他人来说清晰易读是一种更好的做法。此外，注释和文档——如<a class="ae ky" href="https://devdocs.io/jsdoc/about-getting-started" rel="noopener ugc nofollow" target="_blank"> JSDocs </a>格式——对于构建可与团队或其他人共享的可访问代码非常有用。</p><p id="2fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这似乎是多余的，但是尽可能地对代码进行注释将允许您在几个月后回到某个项目或与同事合作时，轻松地刷新内置文档。</p><h2 id="7ca2" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">全局</h2><p id="d131" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">避免全局范围内的变量。避免在全局范围内使用变量有多种原因。由于函数执行会导致JavaScript从in到out搜索范围变化，直到找到全局对象，因此性能会降低。此外，这也存在安全缺陷，因为在全局空间中定义函数时，可以通过浏览器调用这些函数。这一点将在<a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#dc1e" rel="noopener">功能编程章节</a>中再次出现。</p><h2 id="f9ba" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">变量</h2><p id="311e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">停止使用<code class="fe nm nn no np b">var</code>。范围行为是不一致和混乱的，这可能会导致错误。ES6带来了<code class="fe nm nn no np b">const</code>和<code class="fe nm nn no np b">let</code>。严格以使用<code class="fe nm nn no np b">const</code>为目标，只有在不可能的情况下才使用<code class="fe nm nn no np b">let</code>。有更多的限制，而且<code class="fe nm nn no np b">const</code>是不可重新分配的，但也不是完全不可变的。该变量将具有对同一对象或原始值的不变引用，但是该变量持有的值不是不可变的。尽管如此，这仍将是向前发展的最佳实践。</p><h2 id="71fe" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">命名</h2><p id="6955" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有点跑题了，但是程序员可以在命名约定上花费10倍的精力，却努力让自己的语言具有包容性。</p><p id="0b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花些时间来描述和适当的易读性和全面的可读性将会在代码的未来创造奇迹。</p><p id="33c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对那些希望教育他人的人来说尤其重要；变量名应该有助于解释和给出代码中发生的事情的上下文。刚接触这段代码的人应该能够对正在发生的事情有一个大致的了解。使用动词。布尔变量的例子可以从<code class="fe nm nn no np b">is…</code>开始，函数的例子可以是动作动词。</p><p id="3a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里可以找到很好的参考资料:<a class="ae ky" href="https://dev.to/somedood/a-grammar-based-naming-convention-13jf" rel="noopener ugc nofollow" target="_blank"> <em class="nq">一个基于语法的命名约定</em> </a></p><h2 id="205c" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">工作流程</h2><p id="19ff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可维护性的一个主要关键是将逻辑保持在正确的位置，而不是杂乱无章。项目或代码库的构建方式会对理解和遵循的难易程度产生很大影响。</p><h2 id="bd88" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">进口订单</h2><p id="79bc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从粒度级别开始，导入不同模块的顺序可以通过一个可预测的模式来减少混乱。你所使用的特定结构不如存在某种结构重要:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="3b2a" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">模块化</h2><p id="1e8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要记住的一个目标是保持包、模块、函数和范围较小。在实践中，可重用性和链接变得更加容易。相似的功能，或者有许多步骤的功能，可以归入一个模块或类。尽量保持功能简单，逐步执行复杂的过程。</p><p id="5c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一个文件超过300-400行代码，就很有可能变得过于混乱和不可维护。在这一点上，通过创建新的模块和文件夹来分解流程可以获得很多好处。将项目想象成一棵有许多分支的树，而不是堆积如山的代码。</p><p id="14ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ESLint 是一个很好的工具。目标是让文件的深度少于四到五个凹痕。这使代码保持专门化，并鼓励清理死代码。做一个小程序的几个函数比做几件事的一个函数更有用。大函数只能以这种方式使用，而小函数可以在一个项目的多个过程中使用。公开这些较小的辅助函数会在项目中创建一个健壮的API库。</p><p id="bd1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">伟大的代码可以在不重写一切的情况下得到改进。</p><h2 id="c48f" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">隔离代码</h2><p id="09b0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个功能应该有一个目的，而不是做多个动作。这个目的应该不是副作用，但是我们会在<a class="ae ky" href="https://medium.com/@jolene.langlinais/modern-javascript-techniques-cf2084236af4#dc1e" rel="noopener">函数式编程部分</a>回到这个话题。</p><p id="65d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个人为的例子是封装条件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="136f" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">保护条款</h2><p id="fe19" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">构造具有导致错误或空结果的边缘情况的函数的一个好方法是尽早检查这些无效结果。如果这个条件没有被满足或者有一个无效的用例，那么大部分的计算就被阻止了，因为我们已经知道了结果。这被称为<a class="ae ky" href="http://rikschennink.nl/thoughts/the-bouncer-pattern/" rel="noopener ugc nofollow" target="_blank">弹跳模式</a>或g <a class="ae ky" href="https://dev.to/lanecwagner/guard-clauses-how-to-clean-up-conditionals-2fdm" rel="noopener ugc nofollow" target="_blank"> uard子句</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅会优化代码，还会鼓励以一种考虑处理边缘情况的方式来思考函数和过程。</p><h2 id="f59b" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">漂亮和林挺</h2><p id="9006" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我的文章的一个主题是代码应该易于阅读和理解。随之而来的是一致的风格和结构。棉绒——任何棉绒——都会非常有用。ESLint是一个linter，可以识别代码正确性的问题，比如使用<code class="fe nm nn no np b">var</code>的警告。<a class="ae ky" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>是一个格式化程序，例如，它将识别一致性和一致性问题，并自动对齐括号。鼓励两者结合使用。</p><p id="0b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要一个好的起点，StandardJS 和ESLint的<a class="ae ky" href="https://github.com/feross/eslint-config-standard" rel="noopener ugc nofollow" target="_blank">预定义配置</a>是林挺规则的好来源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7389" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">操作</h1><h2 id="2fb8" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">解构</h2><p id="ab07" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过保持变量简短并在早期从对象中取出，析构可以帮助节省大量的输入和代码行。ECMAScript 6 引入了这一功能，允许从任何对象或模块访问特定字段，并立即将其赋给变量。</p><p id="2c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组(跳过由<code class="fe nm nn no np b">, ,</code>组成的元素):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ce6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">功能(类似于对象):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="fac4" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">默认值</h2><p id="291e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当进行析构时，可以为参数分配默认值。这也可以向用户表明可以传入什么值或者需要什么值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在值没有被传递时不应该抛出错误，那么默认值可能是有用的。</p><h2 id="4885" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">第三的</h2><p id="8ca0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该运算符类似于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators" rel="noopener ugc nofollow" target="_blank">逻辑运算符</a>和<code class="fe nm nn no np b">if…else</code>语句，有三个部分:</p><p id="725b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.布尔条件<br/> 2。真实情况下的返回值<br/> 3。falsy情况下的返回值</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽量避开消极条件句——检查某事是否存在，而不是它是否不存在。</p><h2 id="4c06" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">传播</h2><p id="8084" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一种形式的对象析构，spread操作符允许从数据中提取值，而不必显式地迭代数据。这在<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>和函数式编程中很常见，因为这是一种在不改变对象的情况下添加对象的捷径——通过扩展旧对象并向其添加新值来复制旧对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="08cc" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">模板文字</h2><p id="3b24" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个特性允许将动态内容嵌入到字符串中，并编写跨多行的字符串。这些用反引号(<code class="fe nm nn no np b">``</code>)和模板文字片段(<code class="fe nm nn no np b">${}</code>)指定。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3f3d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">功能</h1><h2 id="13eb" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">限制范围</h2><p id="f00f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数应该做一件事。一旦他们开始执行多个动作，就很难测试和推理。目标是在函数中不要超过一个抽象层次——如果必要的话，将函数拆分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="41a5" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">箭</h2><p id="939f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种新的函数语法为符号提供了简明清晰的流程。通过从定义函数的作用域中继承<code class="fe nm nn no np b">this</code>,这些函数还有更实际的作用域行为。</p><p id="794a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，函数可以写成:<br/> <code class="fe nm nn no np b">function someFunction(input) { /* ...code */ }</code></p><p id="faa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们把同一个东西定义为:<br/> <code class="fe nm nn no np b">const someFunction = input =&gt; { /* ...code */ }</code></p><p id="37cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果函数只是返回一些简单的东西，我们可以用一个隐式的<code class="fe nm nn no np b">return</code>语句将它写成一行:<br/> <code class="fe nm nn no np b">const add = (a, b) =&gt; a + b;</code></p><p id="2a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">const createObject = (a, b) =&gt; ({ a, b });</code></p><h2 id="0419" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">因素</h2><p id="e562" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">旨在限制传递给函数的参数数量，以提高可测试性。理想情况下，这将低于3。通常，如果有三个或更多的参数，该函数可能试图自己做很多事情，应该拆分和合并。</p><h2 id="ab3b" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">链接</h2><p id="8a0b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当前令人沮丧的一个原因是无法方便地访问对象中的嵌套值。目前可能会使用类似这样的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="65dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可怕的。</p><p id="5dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的原因是，如果您直接进入最后一行，您可能会遇到这种错误:<br/> <code class="fe nm nn no np b">TypeError: Cannot read property ‘fourthProp’ of undefined</code></p><p id="32eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TC39(决定哪些特性成为JavaScript标准的一部分的技术委员会)已经将<a class="ae ky" href="https://github.com/tc39/proposal-optional-chaining" rel="noopener ugc nofollow" target="_blank">可选链接提议</a>移到了接受的后期阶段。</p><p id="94fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的很期待，因为它会让上面的代码看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果任何属性不存在，挖掘退出并返回<code class="fe nm nn no np b">undefined</code>。</p><p id="7c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个当前的解决方案是<a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>，它使用一个名为<code class="fe nm nn no np b">path</code>的函数在运行时安全地执行代码，并且不会在控制台中遇到<code class="fe nm nn no np b">undefined</code>错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eff3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步的</h1><p id="803b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我以前写过“<a class="ae ky" href="https://medium.com/swlh/asynchronous-with-redux-sagas-b43c9630f218" rel="noopener">与Redux Sagas </a>的异步”，但我将更多地关注<code class="fe nm nn no np b">async</code> / <code class="fe nm nn no np b">await</code>并对此做出承诺。</p><p id="9f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步仅仅意味着事情的发生独立于主程序流；电脑就是这样设计的。处理器不会暂停以等待副作用发生来恢复操作。JavaScript默认是同步的，单线程的；代码不能并行运行。</p><p id="8764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，JavaScript是为响应用户动作而设计的，本质上是异步的。JavaScript所在的浏览器提供了一组处理该功能的API。而且，<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>引入了非阻塞I/O环境，将这个概念扩展到文件、网络调用等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/6d2b487f01cbe13152399e253d41e951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEsdyEjZp4-nO5TXH1vaxQ.jpeg"/></div></div></figure><p id="95be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这个side函数被交给一个单独的线程时，比如一个API调用，它作为一个回调函数返回，这个回调函数是作为一个参数传递给另一个函数的函数。然后在外部函数中调用它来完成一个动作。</p><h2 id="8d57" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">异步和等待</h2><p id="477b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以前，JavaScript依赖于异步代码的承诺和回调。这很容易导致<a class="ae ky" href="https://blog.hellojs.org/asynchronous-javascript-from-callback-hell-to-async-and-await-9b9ceb63c8e8" rel="noopener ugc nofollow" target="_blank">回调地狱</a>。这种建立在承诺之上的语法糖提供了一种更加平滑的处理异步代码的方式，但是它不能用于普通回调或节点回调。现在异步代码可以写得更像同步代码。类似于承诺，这些是非阻塞的。</p><p id="3cf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个的函数需要在它前面有<code class="fe nm nn no np b">async</code>关键字，<code class="fe nm nn no np b">await</code>只能在有这个关键字的函数中使用。这个<code class="fe nm nn no np b">async</code>函数隐式返回一个承诺，该承诺将解析为函数内部返回的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="74ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">好处:</strong> <br/> +清晰:代码更少，可读性更强。<br/> +错误处理:<code class="fe nm nn no np b">try</code> / <code class="fe nm nn no np b">catch</code>可以处理同步和异步代码<br/> +条件:更直接地处理动态结果<br/> +调试:错误堆栈跟踪更容易跟踪<br/> +等待任何东西</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc1e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">函数式编程</h1><p id="1cae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">谈到编程，有两种主要的范例:命令式和声明式。编写函数的强制性方法是解释过程的每一步，而声明性方法表达了计算逻辑，而没有描述具体的流程。</p><p id="eb6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">命令式</strong>:如何做某事<br/> <em class="nq">例句</em>:指示某人烤一个蛋糕，按部就班<br/> <strong class="lb iu">陈述式</strong>:做什么<br/> <em class="nq">例句</em>:通过描述一个蛋糕来告诉某人烤一个蛋糕</p><p id="3301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程是声明性的。作为一种令人生畏的强大编程范式，函数式编程将计算视为数学函数的评估，并避免改变<a class="ae ky" href="https://en.wikipedia.org/wiki/Program_state" rel="noopener ugc nofollow" target="_blank">状态</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">可变</a>数据。函数是JavaScript中的一级实体，这意味着它们被视为值，可以用作数据。函数可以从常量和变量中引用，作为参数传递给其他函数，并作为函数的结果返回。</p><h2 id="6513" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">纯函数</h2><p id="c1a2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在函数式代码中，输出值只取决于传入的参数，对于相同的输入，输出值总是相同的。相反，面向对象的程序通常依赖于状态，并且在不同的时间使用相同的参数会产生不同的结果。</p><p id="f43b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纯函数是遵循函数式编程的一些准则的函数；也就是说，给定相同的参数(<a class="ae ky" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">幂等</a>)，它返回相同的结果，并且不会引起可观察到的副作用。这使得它在引用上是透明的，这样做的好处是代码更容易测试。有了这个概念，我们就能够<a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记住</a>这些功能。</p><h2 id="ffef" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">副作用</h2><p id="1aff" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在函数式编程中避免可变性，例如修改全局对象或全局范围内的值。函数式编程的目的不是改变数据，而是通过增加或减少来创建新的数据副本，而不是改变原始数据。</p><p id="3fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要的一点是避免陷阱，比如在对象之间共享状态，或者使用可以被任何东西写入的可变数据。一个不纯粹的动作，比如写文件，应该被限制在一个服务范围内——尽量减少不纯粹的功能。</p><p id="858f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，原始数据类型通过值传递，而对象通过引用传递。因此，如果一个函数对一个数组进行了更改，那么引用该数组的任何其他函数都会受到影响。这是函数式编程试图避免的巨大危险；如果两个独立且不相关的函数接受相同的输入，但其中一个函数改变了该输入，那么另一个函数现在就有缺陷。一直克隆大型对象会对性能造成很大的负担，但是有一些非常好的库，比如<a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>。</p><h2 id="b956" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank">拉姆达</a></h2><p id="e65d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Ramda是一个优秀的库，它为JavaScript中的函数式编程提供了额外的工具，使创建代码管道变得更加容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1a8ad848457722c427404a4045d80294.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*crIzQXuJ85uizBoq5lhObw.jpeg"/></div></figure><p id="3f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的函数都是自动生成的，这使得这个库非常有用。他们的wiki有一个帮助你的有用部分，叫做“<a class="ae ky" href="https://github.com/ramda/ramda/wiki/What-Function-Should-I-Use" rel="noopener ugc nofollow" target="_blank">我应该使用什么功能</a>？”</p><p id="6352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://www.sitepoint.com/currying-in-functional-javascript/" rel="noopener ugc nofollow" target="_blank"> Currying </a>给了我们使用高阶函数(将函数作为输入和返回函数的函数)和闭包的能力。curried函数不是一个有多个参数的函数，而是一个只有一个参数并返回一个只有一个参数的函数。这些串在一起形成一个管道。</p><h2 id="abf7" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">平静的</h2><p id="fb4e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然<a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>非常适合在一个管道中组合函数，但是JavaScript是一种不断发展的语言，很快就会有这种特性。TC39目前有一个p <a class="ae ky" href="https://github.com/tc39/proposal-pipeline-operator/wiki" rel="noopener ugc nofollow" target="_blank"> ipeline操作符</a>的提案。同时，检查一下<a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>，找到一些真正强大的工具。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="63d0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="55b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">许多圈子对JavaScript的批评已经失去了价值。我想这需要10倍的时间来消除他们的疑虑。这种语言具有很高的效率，适用于许多环境和应用程序。整个技术领域有许多激动人心的使用案例，能够触及整个堆栈。</p><p id="61f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抛开这一领域的把关和毒性不谈，进入如此多不同部门的能力为社区提供了一个更具协作性和更有经验的群体。这种语言有如此强大的力量。跨平台桌面应用可以用电子版的JavaScript构建，移动应用可以用React Native构建，服务器端解决方案可以用Node.js构建。</p><p id="ab79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这种语言在不断发展，但并不是每周都有新的框架。进步是好的，这种语言背后的社区是相当进步和创新的。</p><p id="eee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如有任何问题或反馈，请随时联系我。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fff0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><h2 id="5708" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">社区</h2><p id="4566" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://dev.to/t/javascript" rel="noopener ugc nofollow" target="_blank">DEV # Javascript</a><br/><a class="ae ky" href="https://javascriptweekly.com/" rel="noopener ugc nofollow" target="_blank">Javascript周刊</a></p><h2 id="6ec7" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">教育</h2><p id="d608" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://learn.freecodecamp.org/" rel="noopener ugc nofollow" target="_blank"> FreeCodeCamp </a> <br/> <a class="ae ky" href="https://www.khanacademy.org/computing/computer-programming" rel="noopener ugc nofollow" target="_blank">可汗学院计算机编程</a><br/><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" rel="noopener ugc nofollow" target="_blank">JavaScript再入门</a> <br/> <a class="ae ky" href="https://javascript.info/" rel="noopener ugc nofollow" target="_blank">现代JavaScript教程</a></p><h2 id="b755" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">书</h2><p id="2dc2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/getify/You-Dont-Know-JS" rel="noopener ugc nofollow" target="_blank"> <em class="nq">你不知道的JavaScript</em></a><em class="nq"><br/></em><a class="ae ky" href="https://eloquentjavascript.net/" rel="noopener ugc nofollow" target="_blank"><em class="nq">雄辩的Javascript </em> </a></p><h2 id="11c9" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated"><em class="nv">博客</em></h2><p id="edfe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@_ericelliott" rel="noopener">埃里克艾略特</a></p><h2 id="99f7" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">播客</h2><p id="1bac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://pca.st/m5IV" rel="noopener ugc nofollow" target="_blank">Javascript Jabber</a><br/><a class="ae ky" href="https://pca.st/ijqf" rel="noopener ugc nofollow" target="_blank">JS Part</a>y<br/><a class="ae ky" href="https://pca.st/fmx9" rel="noopener ugc nofollow" target="_blank">syntax . FM</a><br/><a class="ae ky" href="https://pca.st/fullstack" rel="noopener ugc nofollow" target="_blank">全栈电台</a> <br/> <a class="ae ky" href="https://pca.st/ZD17" rel="noopener ugc nofollow" target="_blank">瓢虫播客</a> <br/> <a class="ae ky" href="https://pca.st/tr6K" rel="noopener ugc nofollow" target="_blank"> Javascript to榆树</a> <br/> <a class="ae ky" href="https://pca.st/i2d2" rel="noopener ugc nofollow" target="_blank">榆树镇</a></p><h2 id="e13f" class="na md it bd me nb nc dn mi nd ne dp mm li nf ng mo lm nh ni mq lq nj nk ms nl bi translated">多方面的</h2><p id="c242" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=Bv_5Zv5c-Ts" rel="noopener ugc nofollow" target="_blank"> JavaScript:理解怪异部分</a> <br/> <a class="ae ky" href="https://javascript30.com/" rel="noopener ugc nofollow" target="_blank"> 30天JavaScript挑战配相应视频Wes Bos </a> <br/> <a class="ae ky" href="https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q/featured" rel="noopener ugc nofollow" target="_blank"> Fun Fun函数</a><br/>Switch Case vs Object Literal:<br/>→<a class="ae ky" href="https://medium.com/front-end-weekly/switch-case-if-else-or-a-lookup-map-a-study-case-de1c801d944" rel="noopener">Switch Case、 if else or a loup map by May Shavin</a><br/>→<a class="ae ky" href="https://medium.com/chrisburgin/rewriting-javascript-replacing-the-switch-statement-cfff707cf045" rel="noopener">重写Javascript:用克里斯布尔金</a> <br/>替换Switch语句静态键入<br/>→<a class="ae ky" href="https://en.wikipedia.org/wiki/Microsoft_TypeScript" rel="noopener ugc nofollow" target="_blank">TypeScript</a><br/>→<a class="ae ky" href="https://dev.to/robertcoopercode/get-started-with-typescript-in-2019-6hd" rel="noopener ugc nofollow" target="_blank">2019年开始使用TypeScript</a><br/>→<a class="ae ky" href="https://scrimba.com/g/gintrototypescript" rel="noopener ugc nofollow" target="_blank">TypeScript</a><br/>→<a class="ae ky" href="http://2ality.com/2018/04/type-notation-typescript.html" rel="noopener ugc nofollow" target="_blank">了解TypeScript的类型符号</a> <br/>功能前端</p></div></div>    
</body>
</html>