<html>
<head>
<title>Build a React Frontend With Umbraco Including Server Side Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Umbraco构建一个包含服务器端渲染的React前端</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/umbraco-v10-with-server-side-rendering-ssr-react-frontend-dde6cb6c2f4c?source=collection_archive---------3-----------------------#2022-09-24">https://betterprogramming.pub/umbraco-v10-with-server-side-rendering-ssr-react-frontend-dde6cb6c2f4c?source=collection_archive---------3-----------------------#2022-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0583" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建搜索引擎优化友好的网络应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/702f807a5192feb09d71b0aec464c5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZX-oYHHbUqReBwjuFgtbjg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用DALL-E (OpenAI)创建</p></figure><p id="158e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，我想尝试一下，如果Umbraco CMS可以与React前端集成，同时保持搜索引擎友好。如果我们想让网络爬虫尽可能容易地索引我们的网页，解决方案必须包括服务器端呈现(SSR)。该代码是<a class="ae lr" href="https://authority.se/" rel="noopener ugc nofollow" target="_blank">权威机构</a>概念验证的一部分。</p><p id="b875" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我偶然发现了与SSR和Umbraco相关的不同来源，如<a class="ae lr" href="https://medium.com/mirum-budapest/building-react-on-an-umbraco-backend-3147d59a292f" rel="noopener"> this article </a>或<a class="ae lr" href="https://reactjs.net/features/server-side-rendering.html" rel="noopener ugc nofollow" target="_blank"> ReactJS。NET </a>，但是第一个有遗漏的回购，另一个从2020年6月开始就没有更新过，也就是说写这个帖子的时候截止到今天不支持<a class="ae lr" href="https://reactjs.org/blog/2022/03/29/react-v18.html" rel="noopener ugc nofollow" target="_blank"> React 18 </a>。</p><p id="b3d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过几次尝试和错误，我可以得到一些非常干净的工作，所以我想我应该与你分享我采用的实现。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="46d9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决方案概述</h1><p id="8341" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">该解决方案由三个不同的部分组成:</p><ul class=""><li id="1eb7" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">Umbraco Web应用程序</li><li id="08a4" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">服务器端渲染应用程序(Express — Node.js)</li><li id="1d92" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">反应应用程序</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/32b70e25ef20b16b99eb13389f893070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PjYc1WTOd1c5OohsB3fHQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">解决方案图表</p></figure><p id="6a3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">具体来说，第一个请求是从Express服务器向涉及SSR的Umbraco <code class="fe nl nm nn no b">RenderMvcController</code>发出的，所有后续请求都是从React应用程序向各个Umbraco <code class="fe nl nm nn no b">ApiControllers</code>发出的。</p><p id="915f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Docker-compose运行应用程序，但可能在本地调试。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dbce" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">苏维埃社会主义共和国</h1><p id="c6e3" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">第一个请求是由一个翁布拉克<code class="fe nl nm nn no b">RenderMvcController</code>提出的。默认情况下，Umbraco项目中的所有文档类型共享相同的模板，因此对Umbraco页面的所有请求将使用相同的功能，即<code class="fe nl nm nn no b">SsrDataController</code>中的<code class="fe nl nm nn no b">IndexAsync</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9cbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从那里，控制器通过调用<code class="fe nl nm nn no b">Mediator</code>来检索模型，以便检索我们的SSR所需的模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e16b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦模型被检索，它被注入到结果模板<code class="fe nl nm nn no b">Index.cshtml</code> <em class="nr"> </em>中，并使用<code class="fe nl nm nn no b">Master.cshtml</code> <em class="nr"> </em>模板。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c8a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">添加到React web应用程序根的<code class="fe nl nm nn no b">TagHelper</code> (asp-prerender-data)将依次向我们的Express服务器发出POST请求，并将模型作为有效负载。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2842" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的应用程序组件在服务器端被实例化，并提供了渲染页面所需的所有数据(通过props注入)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="411c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React应用程序的App组件呈现后，它将作为一个字符串返回给我们的Umbraco应用程序，最终注入到我们的视图中，并将视图返回给用户。</p><p id="0392" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您检查页面的代码源，您将会看到页面的主体已经存在，并且预先填充了数据。</p><p id="583d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">来自React应用程序的所有后续请求都使用指向各种Umbraco API控制器的其他端点。</p><p id="6796" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> NB </strong>:当一个组件被预渲染时，<code class="fe nl nm nn no b">useEffect</code>钩子没有运行，因此此时没有请求。</p><p id="b0bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> NB2 </strong>:如果你的应用包含路由，确保使用<code class="fe nl nm nn no b">StaticRouter</code> <em class="nr"> </em>而不是<code class="fe nl nm nn no b">BrowserRouter</code>，否则<code class="fe nl nm nn no b">ReactDOMServer</code>将无法渲染你的组件。这就是为什么我的应用程序的根用一个<code class="fe nl nm nn no b">Router.tsx</code>组件包装的原因，这个组件将决定选择哪种路由器类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6e80" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">翁布拉科</h1><p id="c674" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">Umbraco应用程序分为三种文档类型:</p><ul class=""><li id="0a6b" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">收集</li><li id="e8d0" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">成分</li><li id="2803" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">页面类型</li></ul><p id="2d7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">页面类型非常简单，主要包含属性:</p><ul class=""><li id="d517" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">[计]元数据</li><li id="9b00" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">区段的块列表&gt;容器&gt;块</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/942d94f7e5c2af6ba29eb546affda769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrrx8_Roc7k805_WFU1lqg.png"/></div></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5c28" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">反应应用程序</h1><p id="096c" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">React应用程序是通过<a class="ae lr" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create-React-App </a>设置的，相当基本，有一个导航栏、主体和一些块类型。没什么特别的。</p><p id="5515" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里唯一的要求是，React应用程序显然应该知道一些Umbraco ApiControllers返回的响应类型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6c19" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">密码</h1><p id="80a8" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">所有代码都可以在这个<a class="ae lr" href="https://github.com/clement-joye/umbraco-react-ssr" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到，自述文件提供了构建和测试解决方案所需的所有信息。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="736c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">更进一步</h1><p id="acab" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">在这个示例中，只发出了一个检索页面主体的请求，这足以检索页面的不同部分和块。尽管可能需要其他请求来从导航项目中检索数据，或者例如在加载之后由其他组件发出的后续请求。</p><p id="d282" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了简化起见，我没有包括这一部分。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2f39" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">信用</h1><p id="8f3e" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">发起预渲染的请求是受<a class="ae lr" href="https://github.com/dawiddworak88/ASP.NET-Core-React-and-SSR" rel="noopener ugc nofollow" target="_blank">该报告</a>的启发。</p></div></div>    
</body>
</html>