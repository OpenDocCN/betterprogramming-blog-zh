<html>
<head>
<title>Best Practices for TCC Distributed Transaction In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中TCC分布式事务的最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-tcc-distributed-transaction-made-easy-with-go-c0a38d2a8c44?source=collection_archive---------5-----------------------#2022-03-30">https://betterprogramming.pub/a-tcc-distributed-transaction-made-easy-with-go-c0a38d2a8c44?source=collection_archive---------5-----------------------#2022-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3739" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文将给出一个完整的TCC示例，让读者准确理解TCC类型的事务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/391ccf4d9e4dd720c8ebb612bd91c15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d7KBWAwK2VeEyuLd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="ccf4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">业务场景</h1><p id="a2b7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">典型的分布式交易场景是银行间转账，其中A需要通过银行将资金转移到B。假设的需求场景是，从A转出和转入B的转账都可能成功和失败，并且转入和转出都将最终成功或失败。</p><p id="e988" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有一个要求，如果有回滚，佐贺模式会导致A发现自己的余额被扣了，而收款人B却迟迟没有收到余额，会造成很大的苦恼。企业希望避免这种情况</p><h1 id="10c5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">变矩器离合器部件</h1><p id="a668" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">变矩器离合器分为3个部分</p><ul class=""><li id="754f" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">尝试部分:尝试执行，完成所有业务检查(一致性)，保留必要的业务资源。</li><li id="7021" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">确认部分:如果所有分支都在Try阶段成功，那么我们就转移到Confirm阶段，在这里Confirm实际执行业务，而不进行任何业务检查，只使用Try阶段保留的业务资源</li><li id="3f39" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">取消部分:如果所有分支中有一个<code class="fe nd ne nf ng b">Trys</code>失败，我们进入取消阶段，释放在尝试阶段预留的业务资源。</li></ul><p id="0c93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们要执行一个类似于银行间转账的交易，TransOut和TransIn在不同的微服务中，一个成功完成的TCC交易的典型时序图如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/9e8ba7dc5970dfed638f36dd4669c324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fqZY7e5mTrU3jtfQ.jpg"/></div></div></figure><h1 id="3c3a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">核心运营</h1><p id="ca33" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先我们创建账户余额表，其中<code class="fe nd ne nf ng b">trading_balance</code>表示已经冻结的金额。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="3774" class="nm kx iq ng b gy nn no l np nq">create table if not exists dtm_busi.user_account(<br/>  id int(11) PRIMARY KEY AUTO_INCREMENT,<br/>  user_id int(11) UNIQUE,<br/>  balance DECIMAL(10, 2) not null default '0',<br/>  trading_balance DECIMAL(10, 2) not null default '0',<br/>  create_time datetime DEFAULT now(),<br/>  update_time datetime DEFAULT now(),<br/>  key(create_time),<br/>  key(update_time)<br/>);</span></pre><p id="1cb1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们先写核心代码，冻结/解冻资金操作将检查约束余额+交易余额&gt; = 0，如果约束无效，执行失败</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6600" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们编写具体的尝试/确认/取消处理函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d318" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些功能的核心逻辑是冻结和调整平衡，<code class="fe nd ne nf ng b">bb.Call</code>在其中的作用将在后面详细解释</p><h1 id="f993" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">TCC交易</h1><p id="5182" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">然后创建TCC事务并进行分支调用</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="37aa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">至此，一个完整的TCC分布式事务完成。</p><h1 id="7c09" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">奔跑</h1><p id="aff0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您想完整地运行一个成功的示例，步骤如下。</p><ol class=""><li id="0958" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nt mv mw mx bi translated">运行dtm</li></ol><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="1651" class="nm kx iq ng b gy nn no l np nq">git clone https://github.com/dtm-labs/dtm &amp;&amp; cd dtm<br/>go run main.go</span></pre><ol class=""><li id="ee11" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nt mv mw mx bi translated">运行示例</li></ol><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="b692" class="nm kx iq ng b gy nn no l np nq">git clone https://github.com/dtm-labs/dtm-examples &amp;&amp; cd dtm-examples<br/>go run main.go http_tcc_barrier</span></pre><h1 id="d5ee" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">处理网络异常</h1><p id="a2f2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设提交给<code class="fe nd ne nf ng b">dtm</code>的事务在其中一个步骤中短暂失败。<code class="fe nd ne nf ng b">dtm</code>将重试未完成的操作，要求全局事务的子事务是幂等的。<code class="fe nd ne nf ng b">dtm</code> framework开创了子交易障碍技术，提供了<code class="fe nd ne nf ng b">BranchBarrier</code>实用程序类来帮助用户轻松处理幂等性。它提供了一个函数调用，保证该函数内部的操作最多被调用一次:</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="2fd8" class="nm kx iq ng b gy nn no l np nq">func (bb *BranchBarrier) Call(tx *sql.Tx, busiCall BarrierBusiFunc) error</span></pre><p id="a25c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个<code class="fe nd ne nf ng b">BranchBarrier</code>不仅可以自动处理等幂，还可以自动处理零补偿和挂起问题，详见<a class="ae kv" href="https://en.dtm.pub/practice/barrier.html" rel="noopener ugc nofollow" target="_blank">异常和解决方案</a>。</p><h1 id="a84a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">TCC回滚</h1><p id="edf4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果银行正准备给用户2转账，发现用户2账户异常，返回失败，会怎样？我们修改代码来模拟这种情况。</p><pre class="kg kh ki kj gt ni ng nj nk aw nl bi"><span id="57d1" class="nm kx iq ng b gy nn no l np nq">app.POST(BusiAPI+"/TccBTransInTry", dtmutil.WrapHandler2(func(c *gin.Context) interface{} {<br/>  return dtmcli.ErrFailure<br/>}))</span></pre><p id="8583" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是事务失败交互的时序图</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/5b73ef7bc4ba31bf832083652a445620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3KiE-xFMLf_TeXug.jpg"/></div></div></figure><p id="a85f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这与成功的TCC的区别在于，当子事务返回失败时，全局事务随后被回滚，调用每个子事务的取消操作，以确保全局事务被全部回滚。</p><p id="8917" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nd ne nf ng b">TransInTry</code>的正向操作没有做任何事情就返回一个失败，此时调用<code class="fe nd ne nf ng b">TransInCancel</code>补偿操作会导致反向调整出错吗？</p><p id="bc7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不要担心，前面的子事务屏障技术确保了如果<code class="fe nd ne nf ng b">TransInTry</code>错误发生在提交之前，它将被补偿为空操作，如果临时错误发生在提交之后，补偿操作将提交数据。</p><p id="7356" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以将<code class="fe nd ne nf ng b">TccBTransInTry</code>改为</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="358c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最终结果平衡仍然正确，详情见<a class="ae kv" href="https://en.dtm.pub/practice/barrier.html" rel="noopener ugc nofollow" target="_blank">异常和解决方案</a>。</p><h1 id="1be5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="d498" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本文给出了一个完整的TCC事务解决方案。通过对这个例子做一些简单的修改，您可以用它来解决您的实际问题</p><p id="242b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有关变矩器离合器原理的更多信息，请参见<a class="ae kv" href="https://en.dtm.pub/practice/tcc.html" rel="noopener ugc nofollow" target="_blank">变矩器离合器</a>。欢迎您参观https://github.com/dtm-labs/dtm项目。</p></div></div>    
</body>
</html>