<html>
<head>
<title>Introduction to NestJS Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS服务介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-nestjs-services-2a7c9a629da9?source=collection_archive---------6-----------------------#2020-01-08">https://betterprogramming.pub/introduction-to-nestjs-services-2a7c9a629da9?source=collection_archive---------6-----------------------#2020-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff3a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们如何在NestJS中使用服务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7cf9e0edba27d336d9bcbce2e39b71bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTbTuBA4_RtKoXCsZ-ybKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NestJS标志</p></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="b695" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">服务</h1><p id="b3c3" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">在企业应用中，我们遵循稳固原则，其中S代表<em class="mq">单一责任</em>。</p><p id="9c37" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">控制器负责接受来自客户端的HTTP请求并提供响应。为了提供响应，您可能需要连接到一些外部数据源。</p><p id="5d33" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">如果我们添加代码来连接内部的外部源，我们就没有遵循单一责任原则。</p><p id="7f20" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">为了避免这个问题，您使用服务，它将负责提供一些数据，这些数据可以在整个应用程序中重用。它还可以保存一些验证逻辑或验证用户的逻辑。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="5061" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">创建和使用服务</h1><p id="eeeb" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">在<a class="ae mw" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>中可以创建两种类型的服务:</p><ul class=""><li id="673e" class="mx my iq lw b lx mr ma ms md mz mh na ml nb mp nc nd ne nf bi translated">基于类的提供程序</li><li id="05d8" class="mx my iq lw b lx ng ma nh md ni mh nj ml nk mp nc nd ne nf bi translated">非基于类的提供程序</li></ul><p id="a35e" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">注意:<strong class="lw ir"> </strong>如果你来自Angular，很有可能你已经知道这些概念。</p><h2 id="7053" class="nl ld iq bd le nm nn dn li no np dp lm md nq nr lo mh ns nt lq ml nu nv ls nw bi translated">基于类的提供程序</h2><p id="054d" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">要创建基于类的提供程序，我们可以使用下面的CLI命令，该命令将在产品文件夹中创建服务。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="9242" class="nl ld iq ny b gy oc od l oe of">nest generate service product</span></pre><p id="d32f" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">在产品文件夹中，您会找到两个文件:</p><ul class=""><li id="66c8" class="mx my iq lw b lx mr ma ms md mz mh na ml nb mp nc nd ne nf bi translated"><code class="fe og oh oi ny b">product.service.ts</code>(用于逻辑。)</li><li id="ae2e" class="mx my iq lw b lx ng ma nh md ni mh nj ml nk mp nc nd ne nf bi translated"><code class="fe og oh oi ny b">product.service.spec.ts</code>(用于单元测试。)</li></ul><p id="9efc" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">您最终可能会为一个特性使用多个服务，甚至是多种类型的提供者。</p><h2 id="97f5" class="nl ld iq bd le nm nn dn li no np dp lm md nq nr lo mh ns nt lq ml nu nv ls nw bi translated">使用基于类的提供程序</h2><p id="cd17" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">现在打开<code class="fe og oh oi ny b">product.service.ts</code>文件并添加下面的代码，我们将把一些代码从<code class="fe og oh oi ny b">ProductController</code>移到<code class="fe og oh oi ny b">ProductService</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="efa8" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">现在服务准备就绪，打开<code class="fe og oh oi ny b">product.controller.ts</code>并进行以下更改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="16ec" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">这里使用<code class="fe og oh oi ny b">ProductService</code>的方式被称为<a class="ae mw" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。</p><p id="1fa2" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">像控制器一样，服务也需要注册，CLI为我们完成了这项工作，您可以通过将它添加到模块的<code class="fe og oh oi ny b">providers</code>数组中来手动完成这项工作。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="c816" class="nl ld iq ny b gy oc od l oe of">providers: [AppService, ProductService]</span></pre><p id="46a3" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">还有更多关于基于类的服务，我们将在接下来的文章中介绍。</p><h2 id="bb5a" class="nl ld iq bd le nm nn dn li no np dp lm md nq nr lo mh ns nt lq ml nu nv ls nw bi translated">非基于类的提供程序</h2><p id="3921" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我们还可以创建一个不是基于类的服务。有两种类型:</p><ul class=""><li id="1ca2" class="mx my iq lw b lx mr ma ms md mz mh na ml nb mp nc nd ne nf bi translated">令牌:我们可以使用字符串值作为令牌。</li><li id="8443" class="mx my iq lw b lx ng ma nh md ni mh nj ml nk mp nc nd ne nf bi translated">工厂:当我们的一个服务需要来自另一个服务的一些数据时，工厂很有用。</li></ul><h2 id="5762" class="nl ld iq bd le nm nn dn li no np dp lm md nq nr lo mh ns nt lq ml nu nv ls nw bi translated">创建令牌</h2><p id="ff56" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">您可以创建一个注入令牌来用作服务，为此，在产品文件夹中创建一个新文件<code class="fe og oh oi ny b">product.token.ts</code>并添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="da72" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">现在打开<code class="fe og oh oi ny b">app.module.ts</code>并使用<code class="fe og oh oi ny b">providers</code>属性注册令牌。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="988e" class="nl ld iq ny b gy oc od l oe of">import { PRODUCT, Product_Token } from './product/product.token';</span><span id="9c3d" class="nl ld iq ny b gy ol od l oe of">providers: [<br/>{<br/>    provide : PRODUCT,<br/>    useValue: Product_Token<br/>}]</span></pre><p id="539a" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">接下来，打开<code class="fe og oh oi ny b">product.service.ts</code>，让我们使用这个令牌并添加下面的代码。这只是为了演示的目的，在实时应用程序中我们可能要使用这个值。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="1aee" class="nl ld iq ny b gy oc od l oe of">import { Injectable, Inject } from '@nestjs/common';<br/>import { PRODUCT, Product } from './product.token';</span><span id="0e6d" class="nl ld iq ny b gy ol od l oe of">constructor(@Inject(PRODUCT) product: Product) <br/>{<br/>    console.log(product.endPoint);<br/>}</span></pre><p id="20eb" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">一旦使用该值运行应用程序，<code class="fe og oh oi ny b">endPoint</code>将被记录在控制台上。</p><h2 id="62c9" class="nl ld iq bd le nm nn dn li no np dp lm md nq nr lo mh ns nt lq ml nu nv ls nw bi translated">使用工厂</h2><p id="aba0" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">工厂是另一种类型的提供者，可用于非常特殊的用例。</p><p id="7b77" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">一般来说，当我们提供一个服务时，它们是在模块被加载时被解析的，但是可能有些情况下我们需要动态地创建实例，这就是我们需要工厂的地方。</p><p id="53b2" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">例如，获取数据库连接，以便客户端在运行时决定连接到哪个数据库。</p><p id="f20d" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">运行以下命令创建两个服务:</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="8085" class="nl ld iq ny b gy oc od l oe of">nest generate service dbprovider<br/>nest generate service client</span></pre><p id="8903" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">在<code class="fe og oh oi ny b">client.service.ts</code>中添加以下代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="1c69" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">接下来，打开<code class="fe og oh oi ny b">dbprovider.service.ts</code>并添加下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6fe7" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">在<code class="fe og oh oi ny b">dbprovider.service.ts</code>中，我们使用了一个字符串属性，如果你试图运行这个应用程序，你会得到错误，因为这是不允许的。</p><p id="1c06" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">我们想在运行时创建<code class="fe og oh oi ny b">DbproviderService</code>的实例，所以我们需要再做一个修改。打开<code class="fe og oh oi ny b">app.module.ts</code>并从<code class="fe og oh oi ny b">providers</code>属性中移除<code class="fe og oh oi ny b">DbproviderService</code>。</p><p id="fbd3" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">Nest让我们创建工厂，创建新文件<code class="fe og oh oi ny b">connection.provider.ts</code>，并添加下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6fa7" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">这里我们通过从<code class="fe og oh oi ny b">ClientService</code>获取<code class="fe og oh oi ny b">db</code>来创建一个<code class="fe og oh oi ny b">DbproviderService</code>的新实例。您可以在这里使用多个服务，您只需要在<code class="fe og oh oi ny b">useFactory</code>中以逗号分隔的方式传递它们，并且需要在<code class="fe og oh oi ny b">inject</code>属性中添加相同的服务。</p><p id="5422" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">现在我们完成了工厂，让我们注册并使用它。打开<code class="fe og oh oi ny b">app.module.ts</code>，在<code class="fe og oh oi ny b">providers</code>属性中添加<code class="fe og oh oi ny b">dbConnectionFactory</code>。</p><p id="2ed3" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">接下来，打开<code class="fe og oh oi ny b">product.service.ts</code>并添加以下代码。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="6889" class="nl ld iq ny b gy oc od l oe of">constructor(@Inject(PRODUCT) product: Product,<br/>    <strong class="ny ir">@Inject('ClientConnection') dbProviderService: DbproviderService</strong>){<br/>    console.log(product.endPoint);<br/>    <strong class="ny ir">console.log(dbProviderService.getProductsForClient())</strong><br/>}</span></pre></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="72bc" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="df45" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我们学习了如何在NestJS中创建和使用不同类型的提供者，我们使用了依赖注入设计模式来使用服务，这也让您可以实现单一责任。</p><p id="6c06" class="pw-post-body-paragraph lu lv iq lw b lx mr jr lz ma ms ju mc md mt mf mg mh mu mj mk ml mv mn mo mp ij bi translated">服务是单一的，但是我们也可以控制服务的范围，这将在下一篇文章中看到。</p></div></div>    
</body>
</html>