<html>
<head>
<title>Should You Stop Using isMounted in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是否应该停止使用React中的isMounted？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/should-you-stop-using-ismounted-in-react-a4feab96ee02?source=collection_archive---------10-----------------------#2022-10-31">https://betterprogramming.pub/should-you-stop-using-ismounted-in-react-a4feab96ee02?source=collection_archive---------10-----------------------#2022-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bde7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">克服React中最古老的反模式之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce357d61c52f908c462fb4e087820ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m7PAfIpbnbOPMpv3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@lautaroandreani" rel="noopener ugc nofollow" target="_blank"> @lautaroandreani </a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e37a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您熟悉React组件的生命周期，您就会知道React组件会经历一个安装阶段和一个卸载阶段。如果您已经使用了类组件，那么您已经使用了生命周期挂钩，如<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentWillUnmount</code>来设置和清理组件。</p><p id="1188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着几年前React转向功能组件和挂钩，许多开发人员感到困惑，因为没有类似于<code class="fe lv lw lx ly b">useIsMounted</code>、<code class="fe lv lw lx ly b">useDidMount</code>和<code class="fe lv lw lx ly b">useWillUnmount</code>的挂钩。一些开发人员和库也为此创建了自定义挂钩。</p><p id="d135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES6类支持之前，React有一个<code class="fe lv lw lx ly b">isMounted</code>方法，许多开发人员将它用作反模式<a class="ae ky" href="https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html" rel="noopener ugc nofollow" target="_blank">。让我们看看有多少开发人员，包括我自己，分别在ES6类和功能组件中重复了这个模式。</a></p><p id="dcf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES6类中，我们通过执行以下操作回到了反模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们在许多文章中建议上述方法，并堆积溢出的答案，最终由一个同事传给另一个。React不再有<code class="fe lv lw lx ly b">isMounted</code>方法是有原因的！</p><p id="4ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe lv lw lx ly b">isMounted</code>反模式的链接文章解释了开发人员使用它来防止已经卸载的组件上的状态更新，因为这将引发警告。</p><p id="5cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在上面的代码中，<code class="fe lv lw lx ly b">loadData</code>方法执行一个异步操作。然而，当数据加载时，这个组件可能不再存在于DOM / Screen中。因此，作为一种变通方法，我们只在当前挂载的情况下在<code class="fe lv lw lx ly b">loadData</code>方法中调用<code class="fe lv lw lx ly b">setState</code>。如果我们要删除<code class="fe lv lw lx ly b">if (this.isMounted) return;</code> guard子句，如果在<code class="fe lv lw lx ly b">setState</code>运行时组件没有安装，我们将从React得到一个警告。</p><p id="02ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文章还解释说，最好在<code class="fe lv lw lx ly b">componentWillUnmount</code>上编写清理逻辑，以确保未安装的组件根本不运行任何代码。在上面的例子中，我们将使用如下的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank">AbortController</a></code>进行清理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="77ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为，与通过检查<code class="fe lv lw lx ly b">isMounted</code>的值来阻止状态更新相比，上述代码的意图更加明确。</p><p id="41c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看功能组件。在功能组件中重复这种模式似乎没有意义，因为它们根本没有生命周期方法！然而，我们中的许多人，包括我自己，通过做以下事情重复了这种模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f1d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，因为我们不能使用<code class="fe lv lw lx ly b">this</code>关键字，所以我们使用<code class="fe lv lw lx ly b">useRef</code>作为替换(这是React文档中提到的有效模式<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">)。我们在空依赖效果期间设置<code class="fe lv lw lx ly b">isMounted</code>的值。然后，我们使用从<code class="fe lv lw lx ly b">useEffect</code>返回的清理函数作为<code class="fe lv lw lx ly b">componentWillUnmount</code>的替代。</a></p><p id="4448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，这种模式的出现是因为没有任何依赖关系的<code class="fe lv lw lx ly b">useEffect</code>钩子经常被比作基于类的组件中的<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentDidUpdate</code>生命周期方法。虽然他们可以比较，但他们的行为并不相同！</p><p id="fa8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">useEffect</code>的目的是当组件内部的一些值改变时运行副作用。在<code class="fe lv lw lx ly b">useEffect</code>中声明的副作用将总是至少运行一次，即使它没有依赖关系。我们利用这种行为来做我们在类组件中的<code class="fe lv lw lx ly b">componentDidMount</code>内部会做的事情。围绕<code class="fe lv lw lx ly b">React Suspense</code>有一个完整的数据获取策略叫做<a class="ae ky" href="https://17.reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense" rel="noopener ugc nofollow" target="_blank">随取随渲染</a>，使得不依赖效果加载数据成为可能。</p><p id="a589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看如何使用清理函数来解决这个问题，而不是使用<code class="fe lv lw lx ly b">isMounted</code>方法。如果您曾经将<code class="fe lv lw lx ly b">cleanup function</code>与<code class="fe lv lw lx ly b">useEffect</code>一起使用过，解决方案应该非常明显。毕竟，它被称为清理功能！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7ff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只在<code class="fe lv lw lx ly b">useEffect</code>中加载数据，代码会更简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="2f8c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="f6fd" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">作为软件开发人员，我们的工作首先是找到让事情按预期运行的解决方案。不可能知道做每件事的正确和预期的方法。毫无疑问，<code class="fe lv lw lx ly b">isMounted</code>解决方案是可行的！我很确定许多代码库不处理未安装组件的状态更新，更不用说使用<code class="fe lv lw lx ly b">isMounted</code>解决方案了。</p><p id="71d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我想说这是一个好的开始。然而，如果我们知道如何做，放弃反模式并更优雅地解决问题并不是坏事。</p></div></div>    
</body>
</html>