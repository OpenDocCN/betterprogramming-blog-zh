<html>
<head>
<title>TypeScript: Anonymous Types, Type Aliases, and Interface Declarations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:匿名类型、类型别名和接口声明</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-anonymous-types-type-aliases-and-interface-declarations-b60bc8a08f8c?source=collection_archive---------2-----------------------#2021-11-09">https://betterprogramming.pub/typescript-anonymous-types-type-aliases-and-interface-declarations-b60bc8a08f8c?source=collection_archive---------2-----------------------#2021-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="12d8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于类型定义的完整指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb5c6a288a5f5441a5b410e3215900e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tUMLUub0qkvnZxaI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sharonmccutcheon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript是一种基于JavaScript的强类型编程语言。它在编译期间提供类型检查，并且大多数ide都支持在我们键入代码时进行类型检查。TypeScript是为开发大型应用程序而设计的。TypeScript代码被反编译成在浏览器中运行的JavaScript。</p><p id="5e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型安全在TypeScript中至关重要。它阻止或防止由不同数据类型之间的差异导致的类型错误。定义类型有三种方式:</p><ul class=""><li id="aac3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">匿名类型:它们是没有名字的类型，包含属性和方法。它通常指定义了一组相关属性和方法的对象类型。</li><li id="f147" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">类型别名:它们是现有类型或新创建类型的替代名称。它适用于基本类型、对象类型等等。可能就简单叫<code class="fe mj mk ml mm b">type</code>。</li><li id="b521" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">接口声明:它们是新创建类型的名称。它指的是对象类型，其中定义了一组相关的属性和方法。或许可以简称为<code class="fe mj mk ml mm b">interface</code>。</li></ul><p id="8159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看这些类型。</p><h1 id="d84e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">匿名类型是临时的</h1><p id="ceae" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">TypeScript是强类型的。变量、参数或属性的类型可以用名称后的<code class="fe mj mk ml mm b">:Type</code>来指定。冒号后面可能有一个或多个空格。<code class="fe mj mk ml mm b">Type</code>包括所有有效类型，可能是基元类型、匿名类型、类型别名或接口声明。</p><p id="5f09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">匿名类型是没有任何名称但包含属性和方法的类型。下面是匿名类型的一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="df53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">grow</code>(第1-4行)和<code class="fe mj mk ml mm b">speak</code>(第10行)的函数参数由匿名类型定义。这是抑制打字稿投诉的一种快速而肮脏的方法，但这种方法是临时的，很难维护。</p><p id="35a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当类型包含属性和方法时，建议不要使用匿名类型。相反，类型别名或接口声明应该是更好的选择。</p><h1 id="6cbd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">类型别名和接口声明具有不同的语法</h1><p id="6fc5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">类型别名是任何类型的名称。语法是<code class="fe mj mk ml mm b">type &lt;name&gt; = &lt;definition&gt;</code>。下面是一个对象类型定义的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="85b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1–7行定义了一种类型的<code class="fe mj mk ml mm b">Person</code>，它包括属性(第2–5行)和方法(第6行)。每个属性都有一个类型名，可以标记为<code class="fe mj mk ml mm b">readonly</code>(第2行)，或者可选的(第4行的<code class="fe mj mk ml mm b">?</code>)。有两种方法来定义函数，作为箭头函数的属性(第5行)或作为普通函数的方法(第6行)。</p><p id="2248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第9–17行定义了<code class="fe mj mk ml mm b">Person</code>类型的<code class="fe mj mk ml mm b">record</code>。</p><p id="7629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第19行打印出记录内容。</p><p id="39ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第27行调用属性定义的函数<code class="fe mj mk ml mm b">speak1</code>。第28行调用方法定义的函数<code class="fe mj mk ml mm b">speak2</code>。他们俩的工作方式是一样的。选择哪种方式，看个人喜好。</p><p id="3d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口声明定义了一组描述对象的相关属性和方法。语法是<code class="fe mj mk ml mm b">interface &lt;name&gt; { &lt;definition&gt; }</code>。</p><p id="d8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于前面的例子，我们将<code class="fe mj mk ml mm b">type</code>改为<code class="fe mj mk ml mm b">interface</code>(第1行)，其工作方式都是一样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于定义对象，类型别名和接口声明非常相似，在大多数情况下，我们可以在它们之间自由选择。</p><h1 id="28f1" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">类型别名适用于任何类型</h1><p id="5238" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">类型别名可以定义或重命名任何类型。适用于原语类型、对象类型、<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/a-complete-guide-to-enums-in-typescript-6f76da009146">枚举类型、</a>联合类型、元组类型、交集类型、<code class="fe mj mk ml mm b">keyof</code>类型、<code class="fe mj mk ml mm b">typeof</code>类型、模板文字类型、索引访问类型、映射类型、条件类型、接口类型、类类型、泛型类型等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a9c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口声明只能定义对象的形状，尽管每个接口的属性/方法都可以由任何有效类型定义，包括类型别名和接口声明。</p><p id="3b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个建立在前面的<code class="fe mj mk ml mm b">type</code>例子上的<code class="fe mj mk ml mm b">interface</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="2674" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">类型别名和接口声明都可以扩展</h1><p id="b2c5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">类型别名和接口声明都可以扩展，尽管语法不同。类型别名<code class="fe mj mk ml mm b">extend </code>由交集完成，接口声明<code class="fe mj mk ml mm b">extend</code>使用内置的<code class="fe mj mk ml mm b">extend</code>机制。它们都可以从一个或多个接口、类型和/或类中扩展。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="2dbd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">类可以实现接口和类型</h1><p id="12cb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在大多数情况下，一个类可以实现一个或多个接口和/或类型。我们将<code class="fe mj mk ml mm b">WaterAnimal</code>定义为<code class="fe mj mk ml mm b">interface</code>，将<code class="fe mj mk ml mm b">FlyingAnimal</code>定义为<code class="fe mj mk ml mm b">type</code>。一个类可以实现其中任何一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个类被认为是静态的蓝图。它可以实现任何接口，这也是一个静态蓝图。但是，类不能实现命名联合类型的类型别名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="96bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，第3行显示了一个错误:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="5fb7" class="nq mo it mm b gy nr ns l nt nu">A class can only implement an object type or intersection of object types with statically known members.</span></pre><h1 id="ef85" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">接口声明可以有声明合并</h1><p id="ff76" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">声明合并意味着编译器将两个用相同名称声明的独立声明合并成一个定义。合并的定义具有两个原始声明的特征。事实上，它并不局限于两个声明。可以合并任意数量的声明。</p><p id="c4a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是第一个接口(第1–5行)和第二个接口(第7–9行)合并成一个组合接口的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">声明合并不适用于类型别名。如果我们将第1行和/或第7行更改为<code class="fe mj mk ml mm b">type</code>，则显示错误:<code class="fe mj mk ml mm b">Duplicate identifier 'Person'.</code></p><p id="38fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某种程度上，类型别名使用交集实现了类似的功能。</p><h1 id="c027" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="f092" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们已经走过了类型定义。匿名类型是临时的，不推荐使用。类型别名适用于任何类型，接口声明用于对象。对于定义对象，它们非常相似，我们可以在它们之间自由选择，只是类不能实现命名联合类型的类型别名。</p><p id="a811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。如果你有兴趣，可以看看<a class="ae ky" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener">我的其他媒体文章</a>。</p></div></div>    
</body>
</html>