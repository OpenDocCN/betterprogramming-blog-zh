<html>
<head>
<title>Master These 5 Topics to Nail Your Next JavaScript Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握这5个主题，为你的下一次JavaScript面试做好准备</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/master-these-5-topics-to-nail-your-next-javascript-interview-2b0da3380e5c?source=collection_archive---------8-----------------------#2021-01-19">https://betterprogramming.pub/master-these-5-topics-to-nail-your-next-javascript-interview-2b0da3380e5c?source=collection_archive---------8-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4753" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在面试新的JavaScript开发人员时，我总是使用这个清单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56e4fcb5dbea64e7d7c6f7edbc2ec10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-oBKee5dYW7bAAo2relgA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@demoya?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔·德莫亚</a>在<a class="ae ky" href="https://unsplash.com/s/photos/interview?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面试一份新工作会让人精疲力尽。每个公司都有自己独特的测试你的方式。在决定你是否有价值时，每个面试官都有一套偏好的话题。</p><p id="960a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到JavaScript时，有太多的主题需要涉及。实际上，你可以谈论任何事情——如果你面试的是一个特定的基于框架的角色(例如，React开发人员、Vue guru等),就更是如此。).</p><p id="520b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，根据我的经验，我发现任何能够真正理解以下五个主题如何工作的开发人员都可以处理我可能扔给他们的任何东西。</p><p id="256e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以事不宜迟，这里是我认为任何面试JS职位的人都必须知道的五大JavaScript话题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0262" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">事件循环</h1><p id="5363" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript中的事件循环是面试中一个确定无疑的问题。这个问题可能有不同的形式，但是你真正需要理解的是引擎如何解析和执行你的代码来处理不同的任务。</p><h2 id="8b3e" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">这与JavaScript无关</h2><p id="0d5d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是其中一把钥匙。事件循环属于引擎(通常是<a class="ae ky" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank">谷歌的V8 </a>)，不属于语言本身。</p><h2 id="5757" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">没有线程——嗯，几乎没有</h2><p id="62e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来要理解的是，事件循环负责处理和启用JavaScript中的异步行为。关于这一点最常见的误解之一是，引擎使用<a class="ae ky" href="https://libuv.org/" rel="noopener ugc nofollow" target="_blank"> libuv </a>通过C++中的线程实现这些调用。</p><p id="6cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然在某些特定情况下确实如此，但常见的异步用例已经被您正在与之交互的API(例如，操作系统、外部数据库等)所涵盖。)，不再需要定制线程。</p><h2 id="be62" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">这都是关于阶段的</h2><p id="a0d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">循环的另一个关键方面是它有不同的阶段，每个阶段处理不同类型的异步函数。</p><p id="fcc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些阶段是:</p><ul class=""><li id="83d6" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu">定时器</strong>:在此阶段，<code class="fe nu nv nw nx b">setTimeout</code>和<code class="fe nu nv nw nx b">setInterval</code>被评估。</li><li id="269f" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated"><strong class="lb iu">回调</strong>:这些是特定于系统的回调，在需要时被调用。</li><li id="0504" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated"><strong class="lb iu">检查</strong>:我们的好朋友<code class="fe nu nv nw nx b">setImmediate</code>在这个阶段得到评估。</li><li id="c5f1" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated"><strong class="lb iu">关闭</strong> <strong class="lb iu">事件</strong>:在此阶段调用所有的<code class="fe nu nv nw nx b">close</code>事件回调。</li><li id="be87" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated"><strong class="lb iu"> Poll </strong>:这里是执行所有I/O相关回调的地方。如果所有的回调函数都被调用了，那么循环将在这里等待，直到新的函数被注册。</li></ul><p id="2cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常在正常执行时，首先引起引擎注意的是当前线程。一旦完成，它需要调用<code class="fe nu nv nw nx b">nextTick</code>，所以如果你用这个函数设置了任何回调，它们将在下一个被执行。</p><p id="d7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以开始了，但通常我们可以预期以下顺序:计时器、检查，最后是轮询。</p><p id="6758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以编写一个简短的代码片段来检查这种行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您希望这个脚本的输出是什么？根据我们所了解的，你应该能猜到:</p><pre class="kj kk kl km gt of nx og oh aw oi bi"><span id="0baf" class="mz md it nx b gy oj ok l ol om">5: Current thread - Fibonacci(20): 6765 - Callback<br/>Next Tick Call #1<br/>Next Tick Call #2<br/>4: Timers...<br/>3: Checks (setImmediate) ...<br/>2: Polling (reading file)...<br/>1: Polling (http request)...</span></pre><p id="b593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先是当前线程(如果完成斐波那契数列)。然后调用下一个tick回调，因为这就是循环正在做的事情(调用<code class="fe nu nv nw nx b">nextTick</code>)。然后轮到计时器了。之后才是<code class="fe nu nv nw nx b">setImmediate</code>——如果你仔细想想，这是很讽刺的。三次回调比这次更直接。</p><p id="587e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，进入轮询阶段，这里的执行顺序取决于操作。读取文件比执行HTTP请求要快得多，所以这里首先调用第二个回调。</p><h2 id="2eda" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">关于计时器的一个有趣推论</h2><p id="389c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在跳到下一个主题之前，我想先介绍一个关于定时器的小细节。所有三个基于时间的回调，<code class="fe nu nv nw nx b">setImmediate</code>、<code class="fe nu nv nw nx b">setInterval</code>和<code class="fe nu nv nw nx b">setTimeout</code>，都不能保证在您配置它们的时候被执行。</p><p id="c43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您注意到的<code class="fe nu nv nw nx b">setImmediate</code>的延迟执行，其他因素也会影响执行时间。因此，不是确保您的回调将在您配置的超时时间(或您配置的时间间隔)准确地被调用<em class="on">，而是一旦该时间过去，回调将至少被调用<em class="on">。不会更早，但也不一定正好在那个时候。</em></em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5cd1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">提升</h1><p id="0d75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个快速而简单的概念，但也因此容易被忽视。提升在JavaScript中定义了一个特殊的行为，如果你不考虑它，它会影响你的答案的结果。</p><p id="07f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用<code class="fe nu nv nw nx b">var</code>而不是<code class="fe nu nv nw nx b">let</code>来使用提升更有意义——因为如果用<code class="fe nu nv nw nx b">var</code>定义变量，可以在声明发生之前使用它(在正确的范围内)。引擎会将所有变量声明移动到顶部，允许您使用它们而不会出现引用错误。</p><p id="e0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，用<code class="fe nu nv nw nx b">let</code>声明的变量没有同样的好处。如果你使用的是<code class="fe nu nv nw nx b">let</code>，那么虽然你的代码块知道它，但是你不能在它声明之前使用它——相反，你会得到一个引用错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="90d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你试图给<code class="fe nu nv nw nx b">y</code>赋值时，上面的代码会在第7行抛出一个异常，因为它是在第15行用<code class="fe nu nv nw nx b">let</code>定义的。您还可以看到如何在第2行使用在第14行定义并赋值为10的<code class="fe nu nv nw nx b">x2</code>——但是没有实际赋值。这是因为提升只是将声明移动到顶部，其他什么都没有。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="11fa" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这是什么？</h1><p id="c83c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然我们倾向于将关键字<code class="fe nu nv nw nx b">this</code>与OOP上下文联系起来，但是JavaScript让这个关键字随处可及。</p><p id="4a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在就可以在您最喜欢的JS运行时上编写<code class="fe nu nv nw nx b">console.log(this)</code>——无论是您的浏览器控制台还是带有节点REPL的终端窗口——您都会得到一个有效的结果。</p><p id="4ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">this</code>关键字引用代码执行的上下文，虽然在代码中间使用它没有什么意义，但在函数或方法调用中使用它很有意义。</p><h2 id="8546" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">在函数调用内部</h2><p id="1657" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除非另有说明，函数可以通过<code class="fe nu nv nw nx b">this</code>关键字访问全局对象。在浏览器上下文中，该关键字将引用<code class="fe nu nv nw nx b">window</code>对象。然而，在Node中，您可以访问<code class="fe nu nv nw nx b">globalThis</code>对象，该对象引用了<code class="fe nu nv nw nx b">setInterval</code>、<code class="fe nu nv nw nx b">setImmediate</code>等方法。</p><p id="0a1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过两种方式影响此行为:</p><ol class=""><li id="525b" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu oo nr ns nt bi translated">如果您设置了严格模式，那么除非另有说明，<code class="fe nu nv nw nx b">this</code>关键字将是未定义的。</li><li id="671f" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu oo nr ns nt bi translated">一旦调用函数，可以使用<code class="fe nu nv nw nx b">bind</code>或<code class="fe nu nv nw nx b">call</code>和<code class="fe nu nv nw nx b">apply</code>等函数方法覆盖<code class="fe nu nv nw nx b">this</code>的值。</li></ol><h2 id="6d03" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">在方法调用内部</h2><p id="781d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">方法调用是对关键字<code class="fe nu nv nw nx b">this</code>更直观的使用。换句话说，使用<code class="fe nu nv nw nx b">this</code>关键字将引用对象本身，允许您访问其他方法或属性。</p><p id="66f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，您可以利用这样一个事实，即方法只是JavaScript中的函数，并且您还可以在调用它们时覆盖它们的<code class="fe nu nv nw nx b">this</code>引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，上面的代码不应该工作——类<code class="fe nu nv nw nx b">C2</code>没有名为<code class="fe nu nv nw nx b">method1</code>的方法。但是，我们可以通过执行以下操作来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bb8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们是如何用对另一个对象(具有所需方法的对象)的引用来覆盖<code class="fe nu nv nw nx b">this</code>关键字的。这样做肯定是危险的，只有当你明白自己在做什么以及为什么要做的时候，你才应该这样做。</p><h2 id="6ff9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">箭头函数如何改变这一点？</h2><p id="1293" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，由于JavaScript组合中添加了箭头函数，我们还需要考虑另一种行为。</p><p id="17cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数和arrow函数的主要区别之一是，后者没有自己定义的<code class="fe nu nv nw nx b">this</code>或执行上下文。相反，它们从它们的父类继承一个(当被定义时)，所以对于arrow函数来说，这是关于何时以及如何定义它们的问题。</p><p id="7de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么将箭头函数用作文字对象的方法并不理想，但将它们用作独立的函数并在调用它们时正确绑定它们的上下文才是理想的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b629" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关闭</h1><p id="691a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我的采访中，我通常会问一个关于这个话题的简单问题:什么是结束？</p><p id="d21d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望得到的答案是这样的:当一个函数被定义时，JavaScript获取其上下文的快照，并将其与新定义相关联。这允许您的函数被分配和传递，并且仍然可以访问它的上下文。</p><p id="1aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常使用下面的函数作为例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="318f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你认为这个函数会输出什么？当然，它会在你的终端上打印<code class="fe nu nv nw nx b">10</code>，这是因为当匿名函数被声明时，它的执行上下文也被附加到它上面。因此当我们返回它时，它仍然可以访问变量<code class="fe nu nv nw nx b">a</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0a82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生活</h1><p id="c552" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">也称为<em class="on">立即调用的函数表达式，</em>这些函数是在定义后立即调用的。</p><p id="625f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们没什么奇怪的。这只是一个正确书写定义的问题，这样你就可以用一组括号把它括起来，然后执行那个表达式。</p><p id="c8e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。如果你将代码复制并粘贴到REPL中，它会自动调用这个函数。</p><p id="41fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么他们有什么好宣传的呢？IIFEs对于创建一个作用域块非常有用，在这个作用域块中，您可以定义依赖关系而不会有命名冲突。</p><p id="5c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，在使用不同库的环境中，当其中一些库可能有相同的名称或者有冲突名称的导出方法时，IIFEs允许您定义包含哪些依赖项，而不会引起任何冲突。</p><p id="5dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下在一个已经使用了<a class="ae ky" href="https://underscorejs.org/" rel="noopener ugc nofollow" target="_blank">下划线. js </a>的项目中不得不使用<a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>。我知道，这是一个非常困难的用例，但是很方便，所以我要用它。如果添加lodash，就会与导出的全局<code class="fe nu nv nw nx b">_</code>发生名称冲突。然而，您可以定义一个IIFE来封装您的逻辑并接收lodash作为参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f53f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，函数中的<code class="fe nu nv nw nx b">_</code>将只引用您想要的，因为它覆盖了全局名称。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d2c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="2674" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">掌握JavaScript面试并不容易——有许多不同的主题要涉及，而针对特定框架的问题就更难了。然而，一些基本主题影响JavaScript相关开发的所有领域，这五个主题涉及所有领域。</p><p id="888b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你呢？在之前的采访中，你是否不得不面对我在这里没有提到的其他难以破解的话题？</p></div></div>    
</body>
</html>