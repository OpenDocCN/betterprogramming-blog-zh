<html>
<head>
<title>Mastering TypeScript’s Mapped Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握TypeScript的映射类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-typescripts-mapped-types-5fa5700385eb?source=collection_archive---------2-----------------------#2020-12-29">https://betterprogramming.pub/mastering-typescripts-mapped-types-5fa5700385eb?source=collection_archive---------2-----------------------#2020-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">像专家一样学习处理Typescript映射类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36553d1e9d548419faa0638d18f1daa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bGtJSNGcsTcmuZVf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dmjdenise?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼斯·简斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="975d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript最早出现在2012年10月，它从一开始就对它持怀疑态度。难道不是扼杀了Javascript的精神吗？这难道不是在我们的代码库中添加更多的样板文件吗？我个人认为没有必要。</p><p id="e8cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那是在映射类型发布之前。它们是在四年后的<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html" rel="noopener ugc nofollow" target="_blank"> TypeScript 2.1 </a>版本中出现的。这个新功能立刻吸引了我。正是这缺失的部分将Typescript带到了一个全新的水平。</p><p id="b799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道映射类型的真正潜力吗？你在你的代码库中使用了他们所有的好处吗？我们将一起检查用它们你能做出什么了不起的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b11" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基础知识</h1><p id="524c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">什么是映射类型？它们是避免重新定义接口的一种方式。使用它们，你可以将一个类型建立在另一个类型或接口的基础上，这样你就不用手工操作了。总结一下:这是一种基于另一种类型创建新类型的方法。有效的转型类型。</p><p id="dfe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解本文，您可以运行Typescript Playground中的所有示例，在这里找到<a class="ae ky" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"/>。是玩Typescript和练习技能的绝佳工具。</p><p id="4030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始看看一些运行中的类型脚本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要扩展这个接口，您可以执行以下操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="605e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做同样的事情，但是使用映射类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="956d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷，不是吗？尽管在这个场景中，我们并没有真正展示任何不能用界面完成的事情，不是吗？不过，我们才刚刚开始。</p><p id="743b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个特定的虚拟示例中，最好使用接口。这只是一个展示，所以你可以看到它的多功能性。</p><p id="ccf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个使用映射类型更有意义的例子。让我们将两个界面结合在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="22c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它真正开始发光的地方。我们可以看到这变得多么容易做到和可读。</p><p id="6979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深入研究之前，我们先来看看<code class="fe nb nc nd ne b">keyof</code>原语。它非常直观:它将通过一个联合类型公开任何给定接口/类型的键。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f591" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">内置实用程序类型</h1><p id="fc9b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript附带了许多实用工具类型，因此您不必在每个项目中重写它们。让我们来看看一些最常见的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="92e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">Omit</code>、<code class="fe nb nc nd ne b">Partial</code>、<code class="fe nb nc nd ne b">Readonly</code>、<code class="fe nb nc nd ne b">Exclude</code>、<code class="fe nb nc nd ne b">Extract</code>、<code class="fe nb nc nd ne b">NonNullable</code>、<code class="fe nb nc nd ne b">ReturnType</code>——这些都是最常见的。你可以点击查看完整名单。</p><p id="4c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不局限于一次只使用一个，而是可以根据需要组合使用，这才是真正的乐趣所在。它们就像乐高积木一样帮助你实现目标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a833" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">映射类型在钩子下是如何工作的？</h1><p id="8b40" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在开始之前，让我们了解一下如何访问接口/类型属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="327f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何迭代一个类型的属性？以类似于迭代javascript对象的方式:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="91b4" class="nj md it ne b gy nk nl l nm nn">[P in K]: T[P]</span></pre><p id="a99f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些知识，我们现在就可以开始检查TypeScript如何构建它的实用程序了。让我们看看<code class="fe nb nc nd ne b">Omit</code>，它使用了两种实用程序类型:<code class="fe nb nc nd ne b">Pick</code>和<code class="fe nb nc nd ne b">Exclude</code>。让我们递归地检查一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="beec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当把它分解成小单元时，更容易理解。<code class="fe nb nc nd ne b">keyof</code>到底是做什么的？</p><blockquote class="no np nq"><p id="8e28" class="kz la nr lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">keyof</code>操作符接受一个对象类型，并产生一个字符串或其键的数字联合——MDN</p></blockquote><p id="4426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在映射类型中起着很大的作用。这里，通过将第二个参数设为<code class="fe nb nc nd ne b">extends keyof T</code>，我们可以确保我们想要排除的属性属于该类型。</p><p id="04a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之<code class="fe nb nc nd ne b">Omit</code>正在做的是:</p><ul class=""><li id="dbfc" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">使用<code class="fe nb nc nd ne b">Pick</code>循环输入我们的类型键。</li><li id="16da" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">通过将其转换为<code class="fe nb nc nd ne b">never</code>来排除我们的目标键。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c3d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">构建您自己的实用程序类型</h1><p id="aa92" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们创建我们的第一个自定义实用程序。假设我们想要定义一个对象，其中所有的键值都来自一个特定的类型。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="e826" class="nj md it ne b gy nk nl l nm nn">type GenericString = { [key: string]: string }</span></pre><p id="7655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？让我们使用<code class="fe nb nc nd ne b">Generics</code>并使<code class="fe nb nc nd ne b">string</code>类型可配置。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="c905" class="nj md it ne b gy nk nl l nm nn">type GenericObject&lt;T&gt; = { [key: string]: T }</span></pre><p id="10ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加另一个泛型类型来创建一个泛型键对值类型:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="a173" class="nj md it ne b gy nk nl l nm nn">type GenericKeyObject&lt;K extends keyof any, T&gt; = {<br/>  [P in K]?: T;<br/>};</span></pre><p id="e633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看实际情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当构建复杂的映射类型时，对我有用的是从简单开始，然后逐渐增加复杂性。你可能会发现开始太复杂令人沮丧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="654c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">提升你的效用类型和用途</h1><p id="0e29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很容易用映射类型构建一个非常简单的例子。现在让我们更深入地挖掘一下。</p><p id="fc5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，让我们先看看<code class="fe nb nc nd ne b">never</code>原语。它是在2.0版本中引入的。它表示该值永远不会出现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bf34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看2.8版本中添加的<code class="fe nb nc nd ne b">infer</code>原语。</p><p id="2b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript非常依赖类型推断。有一个<code class="fe nb nc nd ne b">infer</code>原语，它赋予映射类型显式推理的能力。您可以使用它来提取条件类型中的类型。</p><p id="de10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是条件类型？它只是一个表达式，用于根据表示为类型关系的条件从两个可能的类型中选择一个。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="0a92" class="nj md it ne b gy nk nl l nm nn">T extends U ? X : Y</span></pre><p id="b2e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这些都发挥出来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想从由<code class="fe nb nc nd ne b">getData</code>返回的<code class="fe nb nc nd ne b">Promise</code>中解包该类型呢？简单:使用<code class="fe nb nc nd ne b">infer</code>创建自己的实用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5788" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那里发生了什么事？如果<code class="fe nb nc nd ne b">T</code>延伸一个<code class="fe nb nc nd ne b">Promise</code>或者一个<code class="fe nb nc nd ne b">Function</code>，你只是在推断类型；否则，您只是返回给定的类型<code class="fe nb nc nd ne b">T</code>。</p><p id="3595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做最后一个作为奖励。让我们做一个接口，如果对象是空的，它将返回<code class="fe nb nc nd ne b">true</code>，如果类型有一些属性，它将返回<code class="fe nb nc nd ne b">false</code>。是的，我们可以在TypeScript中做这样疯狂的事情。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="e0ad" class="nj md it ne b gy nk nl l nm nn">type Empty&lt;T extends {}&gt; = {} extends Required&lt;T&gt; ? true : false;</span><span id="8511" class="nj md it ne b gy oj nl l nm nn">type isEmpty = Empty&lt;{}&gt;; // true</span><span id="b5fc" class="nj md it ne b gy oj nl l nm nn">type isNotEmpty = Empty&lt;{ name: string}&gt;; // false</span></pre><p id="73cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这很有用？您可以将映射类型<code class="fe nb nc nd ne b">Empty</code>与任何条件推断/映射类型相结合，以创建更多的定制类型。所以我们刚刚创建了一个工具，它将帮助我们创建更多的映射类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7d46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能达到的目标很疯狂，不是吗？极限是你的想象力。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="209f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">类型脚本元组</h1><p id="3550" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后增加和改进的是<code class="fe nb nc nd ne b">Tuples</code>。<code class="fe nb nc nd ne b">Tuples</code>是元素个数固定的数组。它们的类型是已知的，并且它们不一定是相同的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="88c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，具有多种类型的非固定大小数组不会被推断到<code class="fe nb nc nd ne b">Tuple</code>中。因为数组是动态的，可能会改变<code class="fe nb nc nd ne b">Typescript</code>不知道正确的类型。我将返回所有可能类型的联合。</p><p id="2069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要强制数组推断到一个<code class="fe nb nc nd ne b">Tuple</code>中，使用<code class="fe nb nc nd ne b">as const</code>。这将告诉Typescript数组是固定的，类型的顺序将被保留。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="02ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">Tuple</code>很有用。现在有一种情况很常见:反应钩子。Hooks实现通常会返回一个包含结果和函数的数组，对该数组进行类型化确实非常方便。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="594b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包裹</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c71f9562dd53ab8e49aef6b2960237dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X0G7wMQMecrPesd8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@eddybllrd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃迪·比拉德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一些基本的映射开始，以一些Typescript高级类型结束。到目前为止，映射类型是TypeScript中最有趣的特性。</p><p id="45bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们很好地展示了TypeScript的强大和动态。如果您对尝试TypeScript犹豫不决，我希望我的文章给了您所需要的最后一击。即使你现在不打算使用它，明智的做法是知道有什么，以防在不久的将来会派上用场。</p><p id="c577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将来会有更多的TypeScript内容出现——干杯！</p><p id="ba68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不是中等会员吗？支持我<a class="ae ky" href="http://dioxmio.medium.com/membership" rel="noopener">成为这里的</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a5d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> <em class="ol">相关</em> </strong></h1><div class="om on gp gr oo op"><a href="https://medium.com/better-programming/typescript-4-1s-advanced-mapped-types-eba9a2ba7a9" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">TypeScript 4.1的高级映射类型</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">看看递归条件类型、模板文字类型等等</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>