<html>
<head>
<title>Enhance Your Node.js Performance Through Clustering (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过集群增强Node.js的性能(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/enhance-your-node-js-performance-through-clustering-part-1-4cf9cc710774?source=collection_archive---------12-----------------------#2020-01-06">https://betterprogramming.pub/enhance-your-node-js-performance-through-clustering-part-1-4cf9cc710774?source=collection_archive---------12-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4873" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解Node.js是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a1990fa9fe949a0bb5d0c162e07aa999.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*1dzWfKzhph6oFhPjqj6x2g.png"/></div></figure><h1 id="b18c" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated"><strong class="ak">为什么要在Node.js中使用集群？</strong></h1><p id="e45e" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Node.js应用程序运行在单个处理器上，这意味着默认情况下它们不利用多核系统。如果您有一个4核CPU，并且正常运行Node.js应用程序，那么它将在一个核上执行，而其他三个核将保持未使用状态。</p><p id="dfa3" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们讨论一个简单Node.js应用程序的基本可伸缩性问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/6d3c602ebac37ca8f87fca8289bf8c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*9ckfB4pgRW5JJoxOi_3xAw.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">简单的Node.js应用程序。集群是在父进程下运行的相似工作线程的池。</p></figure><p id="d3bf" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们在其中添加一小段代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="548a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">该应用程序有两条路线:</p><p id="5873" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">1.<code class="fe mq mr ms mt b">/slow</code>正在调用<code class="fe mq mr ms mt b">load()</code>，这将需要五秒钟才能完成。并且这个路由会返回一个随机字符串(“我用了5秒”)。<br/> 2。<code class="fe mq mr ms mt b">/fast</code>尽快返回一些随机的字符串。</p><p id="b0d7" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如果我加载一个<code class="fe mq mr ms mt b">/slow</code>页面，需要5秒钟——如我所料。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/0ccf1d65ef7ee9829d5bed2c74edb6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2L2adu7koaEYmQ3rsrgvw.png"/></div></div></figure><p id="29d5" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如果我加载一个<code class="fe mq mr ms mt b">/fast</code>页面，需要6毫秒——这几乎可以忽略不计。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/035824d5baf14a088797fc37b1d5c9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiCI-k3woAUhOpYm1epRjw.png"/></div></div></figure><p id="1ecb" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">但是，如果我先尝试加载<code class="fe mq mr ms mt b">/slow</code>页面，然后立即尝试加载<code class="fe mq mr ms mt b">/fast</code>页面，执行会花费多少时间？让我们检查一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/20cc26b477d1d10782d37566810cbb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qF-via5qg--9B4bncKurbw.png"/></div></div></figure><p id="0e0b" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">页面花费了4.5秒，而不是之前的几毫秒。</p><h2 id="2eb5" class="na kr it bd ks nb nc dn kw nd ne dp la lr nf ng lc lv nh ni le lz nj nk lg nl bi translated"><strong class="ak">为什么会这样？</strong></h2><p id="ab00" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为我们的应用程序运行在一个集群上。当我们试图在加载完<code class="fe mq mr ms mt b">/slow</code>页面后立即加载<code class="fe mq mr ms mt b">/fast</code>页面时，<code class="fe mq mr ms mt b">/fast</code>页面加载仍在等待<code class="fe mq mr ms mt b">/slow</code>页面加载先完成。</p><p id="c676" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">想象一下，如果这种情况发生在拥有数百万用户的生产环境中。这肯定会损害用户体验，甚至可能导致用户流失，这对任何组织都是危险的。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="714b" class="kq kr it bd ks kt nt kv kw kx nu kz la jz nv ka lc kc nw kd le kf nx kg lg lh bi translated"><strong class="ak">集群在这里有什么帮助</strong></h1><p id="163d" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">借助集群，我们可以借助node的集群模块在同一个Node.js应用程序中创建多个节点集群。</p><p id="b4fa" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">使用这种方法的主要优势是，我们可以通过利用多个处理器内核轻松扩展我们的应用程序执行。另一个优势是集群在同一个端口上运行，因此所有请求都将通过一个端口进行路由。</p><p id="0c07" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">集群管理器是主进程，它负责通过使用<code class="fe mq mr ms mt b">child_process</code>模块的<code class="fe mq mr ms mt b">fork()</code>方法来创建和控制工作进程。虽然理论上听起来很复杂，但是非常简单。借助Node.js集群模块，我们可以在应用程序中使用集群。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/16a5aa9282c085b246057bfc13ea527c.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*V3J8x5q3AUTm7cBcZkFjbA.png"/></div></figure><p id="6523" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">要使用集群模块:</p><pre class="kj kk kl km gt ny mt nz oa aw ob bi"><span id="41be" class="na kr it mt b gy oc od l oe of">const cluster = require(“cluster”);</span></pre><p id="7dce" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">集群模块多次执行同一个Node.js进程，因此您必须确定主进程执行了哪部分代码，子进程执行了哪部分代码。</p><p id="97d8" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">借助于<code class="fe mq mr ms mt b">cluster.isMaster</code> <strong class="lk iu"> </strong>标志，集群模块帮助我们识别主流程和子流程。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9b1d" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们检查输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi og"><img src="../Images/8409e1eb9a328ffe406e36d85d80938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQX3O82kSO0VolayU5b7ag.png"/></div></div></figure><p id="b227" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">所以如果你叫两次<code class="fe mq mr ms mt b">cluster.fork()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5fcd" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">以下是输出结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oh"><img src="../Images/fda8d997595ace2ad1065d73bb93f454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdDPllTfZMQ25_uo2u27LQ.png"/></div></div></figure><p id="9ab6" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">集群模块已经执行了三次相同的过程。第一个在主模式下执行，接下来的两个在子模式下执行。</p><p id="f0ca" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们以前面讨论过的同一个<code class="fe mq mr ms mt b">/slow</code>和<code class="fe mq mr ms mt b">/fast</code>为例，使用集群来执行它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2ebf" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们加载<code class="fe mq mr ms mt b">/slow</code>路线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/0ccf1d65ef7ee9829d5bed2c74edb6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2L2adu7koaEYmQ3rsrgvw.png"/></div></div></figure><p id="8737" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在来加载<code class="fe mq mr ms mt b">/fast</code>路线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/5f31c79f5b244b0641bde7401496819f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6KJE36Pjm1tQL0RV1BMvg.png"/></div></div></figure><p id="5fba" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated"><code class="fe mq mr ms mt b">/slow</code>路线花费了5秒来加载(与之前花费的时间相同)，但是<code class="fe mq mr ms mt b">/fast</code>路线，之前花费了将近4.4秒，现在只需要7毫秒就可以加载。</p><h2 id="6c58" class="na kr it bd ks nb nc dn kw nd ne dp la lr nf ng lc lv nh ni le lz nj nk lg nl bi translated">为什么会这样？</h2><p id="7858" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以前，这两个路由都在单个内核中加载，但现在在集群的帮助下，这些<code class="fe mq mr ms mt b">/slow</code>和<code class="fe mq mr ms mt b">/fast</code>路由在两个不同的内核中加载——因为我们通过调用<code class="fe mq mr ms mt b">cluster.fork()</code>两次创建了两个工作子进程。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="c28b" class="kq kr it bd ks kt nt kv kw kx nu kz la jz nv ka lc kc nw kd le kf nx kg lg lh bi translated">下一步是什么？</h1><p id="8209" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在理解聚类概念时，肯定会产生许多疑问，例如:</p><ol class=""><li id="ab5e" class="oi oj it lk b ll me lo mf lr ok lv ol lz om md on oo op oq bi translated">为了获得最佳吞吐量，我们应该创建多少个理想的子进程？</li><li id="f5bd" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated">有没有更好更现实的方法来测试集群流，而不是冗余地加载<code class="fe mq mr ms mt b">/slow</code>和<code class="fe mq mr ms mt b">/fast</code>路由？</li><li id="0682" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated">调用<code class="fe mq mr ms mt b">fork()</code>是使用集群的唯一方式吗(因为通常不经常使用)？</li></ol><p id="f546" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">别急，这些问题都会在下一篇回答。</p><h2 id="41a5" class="na kr it bd ks nb nc dn kw nd ne dp la lr nf ng lc lv nh ni le lz nj nk lg nl bi translated">在这个系列中</h2><p id="71d5" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们需要详细讨论更多的话题。在接下来的几篇文章中，我将详细讲述以下主题:</p><ul class=""><li id="94da" class="oi oj it lk b ll me lo mf lr ok lv ol lz om md ow oo op oq bi translated">通过集群提高Node.js的性能(第2部分)</li><li id="adb2" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md ow oo op oq bi translated">节点事件循环的内部工作方式</li><li id="f4cb" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md ow oo op oq bi translated">创业应该用<a class="ae ox" href="https://hapi.dev/" rel="noopener ugc nofollow" target="_blank"> hapi </a>还是<a class="ae ox" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>呢？</li></ul><p id="ddb1" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">感谢阅读。</p></div></div>    
</body>
</html>