<html>
<head>
<title>Using Generators in Python: The Why, The What, and The When</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用生成器:原因、内容和时间</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-generators-in-python-the-why-the-what-and-the-when-e7d33c0b606?source=collection_archive---------9-----------------------#2021-08-16">https://betterprogramming.pub/using-generators-in-python-the-why-the-what-and-the-when-e7d33c0b606?source=collection_archive---------9-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8973" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过4Ws解释Python生成器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94dc87e4dae1738661ea673de3d75434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ynN0blZNXWcpvIuc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@danialaez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dani Aláez </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="be1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，“Python中的生成器是什么”和“Python中的生成器有什么用”是一些最受欢迎的Python面试问题。</p><p id="e08c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，<a class="ae ky" href="https://wiki.python.org/moin/Generators" rel="noopener ugc nofollow" target="_blank">生成器</a>被认为是Python中稍微更中间的概念之一。如果您是学习Python的新手，您可能以前没有遇到过Generator。这里有一个提示，它与函数内部的<code class="fe lv lw lx ly b">yield</code>语句的使用有关。</p><p id="e4ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将重点介绍在Python中使用生成器的一些用例、原因和优势。简而言之，在处理内存受限的大型数据集时，应该考虑使用生成器。</p><p id="3941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再深入一点，好吗？</p><h2 id="6917" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="9172" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated">在处理大型数据集时，可以考虑使用生成器</li><li id="407f" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">考虑在不需要重复多次的场景中使用生成器</li><li id="048b" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">生成器给我们懒惰的评价</li><li id="f92f" class="ms mt it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">它们是以高效的方式生成序列的好方法</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="1491" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka mk kc nx kd mn kf ny kg mq nz bi translated">我为什么要关心发电机的使用</h1><h2 id="df4d" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">内存限制</h2><p id="e0c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">为了理解你为什么应该使用生成器，我们必须首先理解计算机有有限的内存(<a class="ae ky" href="https://en.wikipedia.org/wiki/Random-access_memory" rel="noopener ugc nofollow" target="_blank"> RAM </a>)。每当我们存储或操作变量、列表等时。所有这些都储存在我们的记忆中。</p><p id="700b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问，为什么计算机程序要把它们存储在内存里？因为这是我们写入和检索数据的最快方式。</p><h2 id="98cf" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">情节</h2><p id="93d7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">你曾经不得不处理一个大得让你碰到<code class="fe lv lw lx ly b">MemoryError</code>的列表吗？也许，你已经尝试过从一个超大的Excel(或<code class="fe lv lw lx ly b">.csv</code>)文件中读取行。我所记得的是，执行这些任务极其缓慢或者根本不可能。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="b3c3" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka mk kc nx kd mn kf ny kg mq nz bi translated">什么是发电机功能</h1><p id="da28" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">简单地说，生成器函数是一种特殊的函数，它返回多个项。这里的要点是，项目是一个接一个返回的，而不是一次全部返回。</p><p id="db06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常规函数和生成器函数的主要区别在于Python中分别使用了<code class="fe lv lw lx ly b">return</code>和<code class="fe lv lw lx ly b">yield</code>语句。</p><h2 id="c656" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">生成器给你懒惰的评价</h2><p id="f044" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">你可能遇到过这种说法。但是，这到底意味着什么呢？</p><p id="dff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉<a class="ae ky" href="https://www.w3schools.com/python/python_iterators.asp" rel="noopener ugc nofollow" target="_blank">迭代器</a>，那么一个生成器函数本质上就是这样一个函数。</p><p id="244d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后台，生成器不会在实例化时计算每一项的值。相反，当我们要求时，他们会计算。这就是人们所说的发电机给你<em class="od">懒</em>的评价。</p><p id="93ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，生成器允许我们一次处理一个值，而不必先将所有内容都加载到内存中。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="e835" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka mk kc nx kd mn kf ny kg mq nz bi translated">我应该在何时何地使用发电机</h1><p id="8e95" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">当您遇到需要从大型数据集读取数据的问题时，生成器非常有用。从大型数据集中读取间接意味着我们的计算机或服务器必须为它分配内存。</p><p id="caff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的唯一条件是，一个生成器只能迭代<strong class="lb iu">一次</strong>。换句话说，只要我们不需要数据集中以前的值，我们总是可以使用Generator。</p><h2 id="2b8a" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">读取相当大的CSV</h2><p id="6a23" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">使用生成器的另一个常见用例是当我们处理Excel或CSV文档这样的大文件时。在不使用生成器函数的情况下，我们可以这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用常规函数的示例</p></figure><p id="cb1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行上面的例子时，我们可能会经历一些缓慢甚至<code class="fe lv lw lx ly b">MemoryError</code>取决于我们的电脑。</p><p id="99da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看上面的代码示例，为了生成结果，<code class="fe lv lw lx ly b">read_csv_from_regular_fn</code>将打开我们的CSV文件，并在一个实例中加载内存中的所有内容。</p><p id="950f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理比我们可用内存更大的文件时，这不是一个好的解决方案。或者，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用生成器函数的示例</p></figure><p id="f770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个场景中，我们基本上使用<code class="fe lv lw lx ly b">read_csv_from_generator_fn</code>作为我们的生成器函数。这个新的生成器打开我们的大型CSV文件，遍历每一行，一次生成每一行，而不是一次生成所有行。</p><p id="14dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，当从我们的<code class="fe lv lw lx ly b">large_dataset.csv</code>读取数据时，我们不会遇到任何<code class="fe lv lw lx ly b">MemoryError</code>，甚至不会因为内存限制而变慢。</p><p id="5f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要以字节为单位检查内存使用情况，我们可以执行以下操作:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="4bcb" class="lz ma it ly b gy ok ol l om on">import sys</span><span id="eb91" class="lz ma it ly b gy oo ol l om on">print(sys.getsizeof(read_csv_from_generator_fn())) # 112 bytes<br/>print(sys.getsizeof(read_csv_from_regular_fn())) # 1624056 bytes</span></pre><h2 id="bb98" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">遍历一个大列表(数组)</h2><p id="56b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">另一个经常使用生成器的例子是我们打算处理大型列表中的值:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="5acf" class="lz ma it ly b gy ok ol l om on"><strong class="ly iu"># Example 1</strong><br/>nums_list_comprehension = [i * i for i in range(100_000_000)]</span><span id="27dc" class="lz ma it ly b gy oo ol l om on">sum(nums_list_comprehension) # 333333328333333350000000</span></pre><p id="bf91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据你的电脑，你可能会遇到<code class="fe lv lw lx ly b">MemoryError</code>或至少几秒钟的缓慢，当评估上述表达式。</p><p id="ea64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<a class="ae ky" href="https://www.w3schools.com/python/python_lists_comprehension.asp" rel="noopener ugc nofollow" target="_blank">列表理解</a>，生成器表达式允许我们快速创建一个生成器对象，而不必使用<code class="fe lv lw lx ly b">yield</code>语句。</p><p id="5668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了应对我们的内存限制，我们可以将上面的代码示例转换成一个生成器表达式。下面这一行代码几乎可以立即计算:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="8994" class="lz ma it ly b gy ok ol l om on"><strong class="ly iu"># Example 2</strong><br/>nums_generator = (i * i for i in range(100_000_000))<br/># &lt;generator object &lt;genexpr&gt; at 0x106ecc580&gt;</span><span id="d767" class="lz ma it ly b gy oo ol l om on">sum(nums_generator) # 333333328333333350000000</span></pre><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在示例1中，用于整个范围的<code class="fe lv lw lx ly b">100_000_000</code>的<code class="fe lv lw lx ly b">i ** i</code>被预先评估并存储在存储器中。它返回一个完整的列表。</p><p id="b6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在示例2中，<code class="fe lv lw lx ly b">i ** i</code>仅在迭代时被评估，一次一个。它返回一个生成器表达式。</p><p id="3c19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，生成器在被实例化时不会计算每一项的值。</p><p id="8667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存使用的差异如下:</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="1137" class="lz ma it ly b gy ok ol l om on">import sys</span><span id="d73f" class="lz ma it ly b gy oo ol l om on">print(sys.getsizeof(nums_generator)) # 112 bytes<br/>print(sys.getsizeof(nums_list_comprehension)) # 835128600 bytes</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="4a85" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka mk kc nx kd mn kf ny kg mq nz bi translated">何时不使用发电机</h1><h2 id="f67a" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">我们需要以前的值</h2><p id="7a48" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">一个生成器只能迭代一次。</p><p id="47b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子显示了来自<code class="fe lv lw lx ly b">nums_generator</code>的生成器表达式只能迭代一次。第二次在它上面使用<code class="fe lv lw lx ly b">sum</code>的结果是零，因为发电机耗尽了。</p><pre class="kj kk kl km gt og ly oh oi aw oj bi"><span id="afa2" class="lz ma it ly b gy ok ol l om on"># Continuing from Example 2<br/>sum(nums_generator) # 333333328333333350000000<br/>sum(nums_generator) # 0, because it can only be iterated once.</span></pre><h2 id="f8f2" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">处理相对较小的文件</h2><p id="ea7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">当处理相对较小的文件或列表时，我们可能不想使用Generator，因为它可能会降低我们的速度。</p><p id="63dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用前面的例子<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/profile.html" rel="noopener ugc nofollow" target="_blank">cProfile</a></code>来描述列表理解和生成器表达式在对值求和时的性能差异。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">cProfile</code>使用列表理解与生成器表达式进行求和</p></figure><p id="ac3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的<code class="fe lv lw lx ly b">cProfile</code>结果中，我们可以看出，如果我们不遇到内存限制，使用列表理解会快很多。</p><p id="6b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，如果记忆不是问题，我们应该坚持使用常规函数或列表理解。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="c02a" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka mk kc nx kd mn kf ny kg mq nz bi translated">结论</h1><p id="cc84" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">总之，在我们不需要重复多次的场景中，Generator是Python中一个令人惊奇的工具。</p><p id="cd53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于生成器为我们提供了惰性评估，它们是一种以内存高效的方式生成序列的好方法。在处理大型数据集时，我们应该考虑使用Generator来优化我们的程序。</p><p id="c05f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="fccc" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated"><a class="ae ky" href="https://jerrynsh.com/using-generators-in-python-the-why-the-what-and-the-when/" rel="noopener ugc nofollow" target="_blank">最初发表于jerrynsh.com</a></h2><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/everything-you-need-to-know-about-context-managers-in-python-f83556fbdfb"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">关于Python中的上下文管理器，您需要知道的一切</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">通过示例了解Python中“with”语句背后的魔力</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-write-clean-code-in-python-5d67746133f2"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">如何用Python写干净的代码</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">使用Python示例编写干净代码的3个技巧</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">better编程. pub</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>