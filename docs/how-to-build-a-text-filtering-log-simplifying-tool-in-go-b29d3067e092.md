# 如何在 Go 中建立一个文本过滤、日志简化工具

> 原文：<https://betterprogramming.pub/how-to-build-a-text-filtering-log-simplifying-tool-in-go-b29d3067e092>

## 轻松删除匹配的文本行。非常适合在调试时减少日志！

![](img/b64e71455b82cda0fd821785f2456061.png)

这是四部分系列的第一部分(有些仍在进行中)。你可以在这里找到其他人:

*   [第 2 部分:添加正则表达式支持](https://medium.com/@gourikabang1996/part-2-how-to-prepare-for-your-next-coding-interview-d048b188301e)
*   [第 3 部分:Go 中的基准程序](/benchmarking-in-go-substrings-vs-regular-expressions-a84de7f0eb02)
*   [第 4 部分:针对 grep 的命令行基准测试](/benchmarking-command-line-tools-7d00ed4813cc)

# 我们在建造什么？

在软件工程中，我们经常解析日志文件来了解程序的内部状态。在存在频繁但不相关的(嘈杂的)日志的情况下，这可能是乏味的，尤其是在作为分布式团队进行调试时。为此，我在 Go 中编写了一个简单的程序，删除包含子字符串(或一系列子字符串中的一个)的任何文本行，并生成一个包含除匹配以外的所有内容的新文件。多年来，这被证明是非常宝贵的——对我和那些从我停下的地方开始调试系统的人来说都是如此。

标准工具可以帮助过滤现有的日志行，但是这个程序允许你做相反的事情——遍历一个文件，删除你发现的有干扰的日志！

# 设计工具

在我们开始编码之前，让我们考虑一下如何使用这个工具。鉴于这是一个相当技术性的产品，只需要一个简单的界面，命令行界面(CLI)似乎是合适的。

输入呢？我们需要提供文件源、从该源中删除的关键短语，以及我们是否希望该文件被就地编辑。一个可选的增强可以是提供输出文件的路径(如果没有被就地编辑),或者使用输出文件路径的存在来确定就地编辑。

现在，我们要送什么？我们可以为各种操作系统和架构构建和分发二进制文件，甚至可能部署它们(artifactory，有人知道吗？).同样，由于这是一个技术产品(而且是免费/开源的！)，我们应该可以交付带有构建和使用说明的`README.md`，并期望我们的用户制作他们自己的二进制文件。

# 构建工具

接下来，我们将定义构建该工具所需的技术细节。在我们的简单例子中，我们需要以下组件:

*   标志解析(针对用户提供的选项)
*   帮助输出(如果工具使用不当)
*   一种确定文本行是否匹配给定输入字符串的方法
*   要写入的输出/目标文件
*   从输入中剪切匹配文本行的方法
*   一种替换“就地”编辑的原始文件的方法
*   基准/测试(我们将在另一篇文章中讨论)

让我们从我们的主要运行循环开始。这将处理用户输入标志和编辑文本文件的基本逻辑。

在这里，我们获取用户提供的参数来调整文件，然后执行调整(如果有任何错误，我们就退出)。

为了获得用户提供的参数，我们将定义一个`config`结构，并使用标准库中的[标志包](https://pkg.go.dev/flag)，如下所示:

我们定义`config`是为了方便我们自己和未来的读者——我们可以发送对`config`的引用，集中定义和任何可能的文档，而不是在函数之间传递三个或更多参数。如果我们决定扩展这个工具(提示，提示😉).

然后，我们根据上面的要求定义输入——一个字符串表示输入文件路径，一个字符串表示要删除的关键短语，一个布尔值表示文件是否应该就地编辑。我们为每个标志定义名称、默认值和用法/助手解释器字符串。请注意，每个返回指针都指向所指示的类型(而不是所指示的类型本身)。`flags.Parse()`将来自`os.Args[1:]`的用户提供的标志解析成这些指针变量。在那里，我们验证是否适当地提供了标志，并将它们返回给调用者。

接下来是转换输入的业务逻辑。下面，我们清理任何预先存在的临时输出文件，生成一个全部是`cfg.inputPath`的输出文件，没有任何行包含`cfg.keys`中的任何键，最后，替换原始文件(如果用户指定到位)。

最后，我们构建实际的逻辑来解析输入文件，检查提供的任何键，并生成输出:

我们首先打开所提供的输入文件(如果有任何问题，就退出)。注意，我们使用的是一个命名的错误返回参数——我们稍后会讨论这个问题。

因为我们正在处理文件，所以我们应该记得通过推迟`sourceFile.Close()`来清理自己的文件(从技术上讲，我们不需要为这里的 readonly 文件这样做，但是这仍然是一个很好的实践。你可以在这里深入了解更多[。](https://stackoverflow.com/questions/62986434/is-close-needed-for-a-file-opened-by-os-open)

然后，我们使用与源文件相同的文件前缀和目录创建或打开输出文件，使其可写。我们将推迟在成功时关闭它，但这里我们关心的是错误，因为它可能表明输出文件不完整。因此，如果之前没有错误，我们将把返回错误值设置为由`outFile.Close()`生成的任何错误。

日志文件可能非常大。因此，这段代码可能会执行许多小的写操作，影响性能。为了缓解这种情况，我们将使用 [bufio](https://pkg.go.dev/bufio) (另一个标准库包)来提供缓冲的 I/O。本质上，这将把许多小的写操作批处理为更少但更大的写操作，这将导致更少的性能开销(您可以在这里阅读关于`bufio` [的更多信息)。我们还将在源文件上使用缓冲阅读器。](https://medium.com/golangspec/introduction-to-bufio-package-in-golang-ad7d1877f762)

打开源文件和目标文件后，我们将生成一个缓冲的 writer。为了避免最后丢失任何数据，我们将推迟一个`Flush()`调用来强制将缓冲区中的任何内容写入目标文件，并且我们将根据需要再次设置我们的返回错误参数。

然后，我们在源文件上生成一个缓冲读取器，并逐行扫描内容。如果该行不包含任何作为子串的`keys`，我们将它写入缓冲的 writer(最终将被写入我们的目标文件)。在所有行都被读完或推迟后开始。假设没有错误，我们将`Flush()`缓冲区以将任何剩余内容写入文件，关闭文件，并成功返回。

# 使用工具

使用该工具的形式如下:

`go run main.go -file="<path/to/src/file>" -keys="<keys to search for|with multiple separated by|pipes>"`(和一个可选的`-inplace`，用输出替换源文件)。

如果您克隆了[项目](https://github.com/swayne275/lineremover)，您可以在`example/input.txt`上测试一些修剪操作，如下所示:

*删除所有以“hello”为前缀的内容*:

`go run main.go -file="example/input.txt -keys="hello"`

*删除所有包含“世界”的内容*(即删除所有线条):

`go run main.go -file="example/input.txt -keys="world"`

*删除包含“大”或“小”字样的所有内容:*

`go run main.go -file="example/input.txt -keys="big|small"`

您可以查看自述文件以了解更多信息，并进行试验，看看您能得出什么结论！

# 进一步的改进

我们一起构建了一个简单而有效的工具。尽管如此，仍有明显的改进余地。

对于子串搜索，最好采用正则表达式(regex)作为输入，而不是一个或多个键。你可以在这个系列的第二部分中找到。

我计划写一篇后续文章来探讨这些选择。如果你还能想到什么，请在评论中告诉我。我也非常感谢任何命名建议或代码清晰度的改进！

我计划写一篇后续文章来讨论 Go 中的基本基准测试(你可能会在这个项目的 [GitHub repo 中看到一些早期代码)。](https://github.com/swayne275/lineremover)