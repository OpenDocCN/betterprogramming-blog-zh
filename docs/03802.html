<html>
<head>
<title>Exploring Filter in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中探索过滤器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-filter-in-go-158abc3926?source=collection_archive---------5-----------------------#2020-03-05">https://betterprogramming.pub/exploring-filter-in-go-158abc3926?source=collection_archive---------5-----------------------#2020-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c4d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我使用Go创建函数数组过滤器的旅程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/79599e05e749ad4be1ff43838694f525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*ovNW30xTjZgVgc8C2V4fgQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:<a class="ae ku" href="https://www.flaticon.com/free-icon/filter_408317?term=filter&amp;page=1&amp;position=33" rel="noopener ugc nofollow" target="_blank">Flaticon.com</a></p></figure><p id="edb9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设一个数组对象有<code class="fe lr ls lt lu b">N</code>个条目。你想过滤它，只得到带有<code class="fe lr ls lt lu b">flagged = true</code>或<code class="fe lr ls lt lu b">flagged = false, amount &lt;= 500</code>的条目。你开始写代码，<code class="fe lr ls lt lu b">imperatively</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ul class=""><li id="db7c" class="lx ly it kx b ky kz lb lc le lz li ma lm mb lq mc md me mf bi translated">这里，我们需要读取循环内部的所有代码，只是为了知道它的意图。</li><li id="1f55" class="lx ly it kx b ky mg lb mh le mi li mj lm mk lq mc md me mf bi translated">如果过滤每个条目需要<code class="fe lr ls lt lu b">x</code>的时间，那么<code class="fe lr ls lt lu b">n</code>个条目的总时间就是<code class="fe lr ls lt lu b">t = n * x</code>。</li><li id="1ce6" class="lx ly it kx b ky mg lb mh le mi li mj lm mk lq mc md me mf bi translated">给定<code class="fe lr ls lt lu b">x=1s</code>和<code class="fe lr ls lt lu b">n=1000</code>然后<code class="fe lr ls lt lu b">t=1000*1s = 1000s</code>。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="dc53" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Go中的并行滤波</h1><p id="7553" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">想象一个叫做<code class="fe lr ls lt lu b">ParallelFilter</code>的函数。它需要两个参数:</p><ul class=""><li id="c4fd" class="lx ly it kx b ky kz lb lc le lz li ma lm mb lq mc md me mf bi translated"><code class="fe lr ls lt lu b">Array</code>指任何一种物体。姑且称之为<code class="fe lr ls lt lu b">source</code>。</li><li id="7228" class="lx ly it kx b ky mg lb mh le mi li mj lm mk lq mc md me mf bi translated"><code class="fe lr ls lt lu b">Function</code>获取<code class="fe lr ls lt lu b">Array</code>的每个条目并返回一个<code class="fe lr ls lt lu b">boolean</code>。姑且称之为<code class="fe lr ls lt lu b">filter</code>。</li></ul><pre class="kj kk kl km gt np lu nq nr aw ns bi"><span id="e479" class="nt mt it lu b gy nu nv l nw nx"><em class="ny">// ParallelFilter an array using go routine</em><br/><em class="ny">// This function will not guarantee order of results</em><br/>func ParallelFilter(arr, filter interface{}) (interface{}, error) {<br/>    <em class="ny">//TODO:</em><br/>}</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="eec0" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">通过单元测试确保ParallelFilter行为</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1e63" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">TODO-1。确保源的类型</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d5b2" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">TODO-2。确保F <code class="fe lr ls lt lu b">ilter</code>不为零并且是一个函数</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="4c96" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">待办事项-3。正在准备结果队列</h1><p id="1eb9" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">基本思路是这样的。每次我们发现条目满足<code class="fe lr ls lt lu b">filter</code>函数，我们就把值放入<code class="fe lr ls lt lu b">queue</code>。然后还有另一个进程等待<code class="fe lr ls lt lu b">queue</code>并收集所有结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5541" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">TODO-4进行循环并返回结果</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="4c54" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">将它们缝合在一起</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="47d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">测试结果显示如下:</p><pre class="kj kk kl km gt np lu nq nr aw ns bi"><span id="1f3a" class="nt mt it lu b gy nu nv l nw nx">Running tool: /usr/local/opt/go/libexec/bin/go test -timeout 30s github.com/bastianrob/go-experiences/filter -run ^(TestParallelFilter)$</span><span id="13f8" class="nt mt it lu b gy nz nv l nw nx">ok       github.com/bastianrob/go-experiences/filter    0.007s<br/>Success: Tests passed.</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="19bf" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">基准平行过滤器</h1><p id="b742" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">首先，我们将尝试模拟慢速运行的过滤器功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="05d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">基准测试结果:</p><pre class="kj kk kl km gt np lu nq nr aw ns bi"><span id="8e48" class="nt mt it lu b gy nu nv l nw nx">BenchmarkParallelFilter-4            100      22920607 ns/op       18678 B/op         451 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/go-experiences/filter    2.322s<br/>Success: Benchmarks passed.</span><span id="e0dd" class="nt mt it lu b gy nz nv l nw nx">pkg: github.com/bastianrob/go-experiences/filter<br/>BenchmarkImperative-4                  1    2289902017 ns/op        1240 B/op           7 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/go-experiences/filter    2.295s<br/>Success: Benchmarks passed.</span></pre><p id="eca2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">ParallelFilter</code>在处理大量条目时速度更快，而<code class="fe lr ls lt lu b">filter</code>处理速度较慢。但是跑得更快的<code class="fe lr ls lt lu b">filter</code>呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3d2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">基准测试结果:</p><pre class="kj kk kl km gt np lu nq nr aw ns bi"><span id="f0a9" class="nt mt it lu b gy nu nv l nw nx">BenchmarkParallelFilterFast-4        10000          184717 ns/op       11216 B/op         347 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/go-experiences/filter    1.870s<br/>Success: Benchmarks passed.</span><span id="4652" class="nt mt it lu b gy nz nv l nw nx">BenchmarkImperativeFast-4         50000000            40.7 ns/op           0 B/op           0 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/go-experiences/filter    2.079s<br/>Success: Benchmarks passed.</span></pre><p id="5b74" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这说明<code class="fe lr ls lt lu b">ParallelFilter</code>绝对是被正常的<code class="fe lr ls lt lu b">imperative</code>滤镜谋杀的。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9305" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">ParallelFilter使用稍微不同的方法</h1><p id="a440" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">如果我们把收集过滤结果的责任倒置给函数调用方会怎么样？这在Go中通过使用<code class="fe lr ls lt lu b">channel</code>是可能的，所以让我们做一个<code class="fe lr ls lt lu b">DeferredFilter</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="9296" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">基准测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f0a8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结果是:</p><pre class="kj kk kl km gt np lu nq nr aw ns bi"><span id="a001" class="nt mt it lu b gy nu nv l nw nx">BenchmarkDeferredFilterFast-4          10000        144723 ns/op        9060 B/op         304 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/go-experiences/filter    1.471s<br/>Success: Benchmarks passed.</span></pre><p id="ddc1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">测试显示时间/操作稍快。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="c5fa" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">如果我们不用围棋套路呢？</h1><p id="fd93" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">让我们来制作刚才制作的<code class="fe lr ls lt lu b">Filter</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1d68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">基准测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1142" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结果是:</p><pre class="kj kk kl km gt np lu nq nr aw ns bi"><span id="878f" class="nt mt it lu b gy nu nv l nw nx">BenchmarkFilterFast-4          50000         33171 ns/op        7864 B/op         244 allocs/op<br/>PASS<br/>ok      github.com/bastianrob/go-experiences/filter    2.008s<br/>Success: Benchmarks passed.</span></pre><p id="287c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当然，它比<code class="fe lr ls lt lu b">ParallelFilter</code>快，但它还是被<code class="fe lr ls lt lu b">imperative</code>环路谋杀了。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5fc3" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="ec15" class="pw-post-body-paragraph kv kw it kx b ky nk ju la lb nl jx ld le nm lg lh li nn lk ll lm no lo lp lq im bi translated">不幸的是，除非您正在处理大块的数组并过滤每个条目，这需要很长时间，否则使用<code class="fe lr ls lt lu b">ParallelFilter</code>、<code class="fe lr ls lt lu b">DeferredFilter</code>或仅仅使用<code class="fe lr ls lt lu b">Filter</code>几乎没有任何好处。</p><p id="93b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我想如果我们也能流式传输输入源，而不是发送整个数组，那会更好。但那是<code class="fe lr ls lt lu b">Pipeline Processing</code>，一个我在这篇文章里不会触及的话题！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="4da8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我的Github中找到所有这些恶作剧:</p><div class="oa ob gp gr oc od"><a href="https://github.com/bastianrob/go-experiences/tree/master/filter" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">Bastian rob/go-体验</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">假设一个数组对象有N个条目。您希望对其进行过滤，以便只获得带有flagged = true的条目，或者…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or ko od"/></div></div></a></div></div></div>    
</body>
</html>