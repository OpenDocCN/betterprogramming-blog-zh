<html>
<head>
<title>10 SwiftUI and Swift Coding Tips for Writing Cleaner Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更简洁代码的10个SwiftUI和Swift编码技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-helpful-tips-for-writing-cleaner-swift-and-swiftui-code-5a84e5407269?source=collection_archive---------5-----------------------#2021-01-05">https://betterprogramming.pub/10-helpful-tips-for-writing-cleaner-swift-and-swiftui-code-5a84e5407269?source=collection_archive---------5-----------------------#2021-01-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="388c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">编写有意义的代码，更快地发布应用</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/715a22a9ff33017c66295b28db190ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KP7aw16TqI9FFeVRsB4Bxw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5665770" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kz" href="https://pixabay.com/users/dark_shutterz-12874543/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5665770" rel="noopener ugc nofollow" target="_blank"> mohamed ramzee </a>。</p></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="b587" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">1.在SwiftUI中设置TextField键盘焦点</h1><p id="571d" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">我们要做一个定制版的<code class="fe mv mw mx my b">TextField</code>，可以控制键盘是否处于活动状态。换句话说，我们要控制第一反应者是谁。首先，我们需要一个有助于响应与<code class="fe mv mw mx my b">UITextView</code>相关的事件的<code class="fe mv mw mx my b">Coordinator</code>类。由于结构只能符合协议，不能从类继承，我们为此使用了一个类:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="68fa" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">现在，我倾向于使用所提供的系统类型的扩展，这给了我简化创建的便利初始化器。</p><p id="f953" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我还包含了一个函数，用于有条件地设置第一个响应者，因为<code class="fe mv mw mx my b">UITextField</code>对这两者都使用了void方法，并且不能只将一个布尔值作为参数发送:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="a49d" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">最后，我们需要创建我们的<code class="fe mv mw mx my b">UIViewRepresentable</code>。如你所见，<code class="fe mv mw mx my b">UITextField</code>是用我们方便的初始化器创建的，它将委托设置为我们的<code class="fe mv mw mx my b">CustomTextFieldCoordinator</code>类。当<code class="fe mv mw mx my b">UIView</code>更新时，我们确保我们的本地绑定仍然是最新的，包括设置第一响应者:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="bd1d" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">要将焦点放在代码中的键盘上，只需更改<code class="fe mv mw mx my b">isResponder</code>绑定的值。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="057e" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">2.向SwiftUI添加摄像头馈送</h1><p id="9515" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">如果你想看到相机看到的东西，你需要获得用户的许可才能使用相机。这就需要你有一个站得住脚的理由，你的应用如果听起来不好听就会被App Store拒绝。右键单击Xcode项目中的<code class="fe mv mw mx my b">Info.plist</code>文件，并选择Open As &gt; Source code。这是将以下内容复制粘贴到结束标签<code class="fe mv mw mx my b">&lt;/dict&gt;</code>和<code class="fe mv mw mx my b">&lt;/plist&gt;</code>之前的最简单方法:</p><pre class="kk kl km kn gu ng my nh ni aw nj bi"><span id="e3ab" class="nk li iu my b gz nl nm l nn no">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;<br/>&lt;string&gt;The camera is needed in order to see what is around you&lt;/string&gt;</span></pre><p id="9879" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这不是一个很好的解释为什么我们需要摄像头，因为我不知道你的应用程序会做什么，但它仍然阻止了应用程序崩溃。</p><p id="439d" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">现在<code class="fe mv mw mx my b">Info.plist</code>已经不碍事了，我们需要创建一个<code class="fe mv mw mx my b">UIView</code>来显示我们的摄像机画面:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="2588" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">SwiftUI不包括相机功能，所以我们依赖于旧的做事方式。这个过程相对简单，因为我们正在创建一个包含一个<code class="fe mv mw mx my b">AVCaptureVideoPreviewLayer</code>的<code class="fe mv mw mx my b">UIView</code>，我们的摄像机画面将在这个<code class="fe mv mw mx my b">AVCaptureVideoPreviewLayer</code>上绘制。我还为<code class="fe mv mw mx my b">AVCaptureSession</code>添加了一个方便的初始化器，它将完成从我们稍后选择的相机获取信息的工作。</p><p id="bdb3" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">最后，让我们将其转换为SwiftUI，以便将其添加到我们的应用程序中:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="a2be" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我们正在请求访问摄像机，如果我们被允许，用我们之前做的便利初始化器创建一个<code class="fe mv mw mx my b">AVCaptureSession</code>。</p><p id="b448" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">现在可以在SwiftUI中的任何地方使用，只需将其创建为<code class="fe mv mw mx my b">CameraView()</code>。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="a784" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">3.文档注释</h1><p id="8937" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">当你按住option (⌥)键并点击任何苹果系统类、函数或属性时，你会得到一个弹出窗口，告诉你更多的信息。查看此信息的另一种方式是使用右侧面板，它的顶部有一个问号选项卡，用于快速帮助。您可以按下option (⌥)、command (⌘)和3的组合，在右侧面板中调出快速帮助，显示当前键入光标所在的位置。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj np"><img src="../Images/7e92ef3f7c679d681d016576e7cbe0a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VpEJGQbJ1LL-6SQi.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。</p></figure><p id="2ee2" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">显而易见，本文档被分成许多部分。声明是自动生成的，因此总是包含在内。其他一切都可以添加到您的自定义函数、类和属性中。可以在任何东西上面添加一个以<code class="fe mv mw mx my b">/**</code>开头的注释块，第一行是简短的总结，第二行是更详细的描述。我已经包含了Xcode可以识别并放在标题下的所有内容，包括解释参数和返回类型的能力:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="f09f" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">您不需要添加所有这些字段，但是添加与您的代码所做的事情相关的任何内容都会有所帮助。阅读您的代码的其他人可以访问快速帮助并获得更多信息，即使那个人是您，而您已经过了很长时间，并且已经忘记了为什么要这样做。这在创建类、调用函数或分配属性时特别有用。</p><p id="c450" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">在这些情况下使用快速帮助允许您访问文档注释——即使您不在编写注释的文件附近。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="ceeb" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">4.将SwiftUI backgroundColor设置为与foregroundColor相同的方式</h1><p id="8007" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">SwiftUI有一个名为<code class="fe mv mw mx my b">.background()</code>的修饰符很有用，这样你就可以在当前视图后面添加任何类型的视图。不再局限于颜色，你的背景可以是一幅图像或者更复杂的形状。但是当我使用<code class="fe mv mw mx my b">.foregroundColor()</code>修饰符时，我利用了这样一个事实，即通过给一个像<code class="fe mv mw mx my b">.blue</code>这样的参数，一个<code class="fe mv mw mx my b">Color</code>是被期望的。你不能对<code class="fe mv mw mx my b">.background()</code>做同样的事情，因为背景可以是任何一种景色。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="6e5d" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这个扩展使得给视图添加背景颜色变得更加容易。</p><p id="bb56" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我发现自己更经常添加颜色作为背景，所以这对我很有用。如果你想有一个更复杂的视图作为背景，我会建议使用一个<code class="fe mv mw mx my b">ZStack</code>。这给了你更多的灵活性，允许多层，而不是一个主视图和背景。<code class="fe mv mw mx my b">.overlay()</code>修饰符也有类似的目的，让您能够在现有视图的前面添加一个视图。</p><p id="f7b0" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我对这个修改器的建议是一样的，因为我认为<code class="fe mv mw mx my b">ZStack</code>在我能想到的任何情况下都更加灵活。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="f2b8" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">5.像SwiftUI的路径一样容易地创建UIBezierPath和CGPath</h1><p id="c708" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated"><code class="fe mv mw mx my b">Path</code>提供了一种使用SwiftUI构建形状的简单方法。我们用来构造它的闭包传递到一个实例中，然后我们向该实例添加直线和四次曲线。</p><p id="f470" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated"><code class="fe mv mw mx my b">UIBezierPath</code>可用于创建<code class="fe mv mw mx my b">SKShapeNode</code>，由<code class="fe mv mw mx my b">SpriteKit</code>用于创建自定义形状。实际上，这个初始化器使用了一个<code class="fe mv mw mx my b">CGPath</code>，但是可以使用一个<code class="fe mv mw mx my b">UIBezierPath.</code>的<code class="fe mv mw mx my b">cgPath</code>属性来访问它</p><p id="d359" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">通过首先构造一个<code class="fe mv mw mx my b">UIBezierPath</code>来构造一个<code class="fe mv mw mx my b">CGPath</code>的主要原因是<code class="fe mv mw mx my b">CGPath</code>本身没有允许你添加直线和曲线的方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="7237" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这个扩展允许像构造SwiftUI <code class="fe mv mw mx my b">Path</code>一样构造<code class="fe mv mw mx my b">UIBezierPath</code>。我还添加了<code class="fe mv mw mx my b">addQuadCurve</code>方法。</p><p id="a5fd" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">SwiftUI中的<code class="fe mv mw mx my b">Path</code>调用第二个参数<code class="fe mv mw mx my b">control</code>——而不是<code class="fe mv mw mx my b">controlPoint</code>——所以我包含了一个<code class="fe mv mw mx my b">addQuadCurve</code>方法来保证两者的一致性。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="b9de" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">6.在一个范围内扩展到与箝位值相当</h1><p id="34cb" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">您可能需要确保某个值在某个范围内，并且条件逻辑包含人为错误的危险。例如，我们想使用<code class="fe mv mw mx my b">&lt;</code>操作符还是<code class="fe mv mw mx my b">&lt;=</code>操作符？有一种简单的方法在所有情况下重复这个过程是有帮助的，这样它就能如我们期望的那样一致地工作，并减少我们需要编写的代码量。有许多数字类型，如<code class="fe mv mw mx my b">Int</code>、<code class="fe mv mw mx my b">Float</code>和<code class="fe mv mw mx my b">Double</code>，以及这些不同大小的版本。不出所料，<code class="fe mv mw mx my b">Int8</code>是8位大小，而<code class="fe mv mw mx my b">Float16</code>是16位，而不是通常的32位大小。</p><p id="9f90" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我们如何一次为所有这些添加功能？</p><p id="5f4e" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">通过扩展他们共有的协议！</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="f355" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">当数组中的项目符合<code class="fe mv mw mx my b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/comparable" rel="noopener ugc nofollow" target="_blank">Comparable</a></code>协议时，<code class="fe mv mw mx my b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/array/1687893-min" rel="noopener ugc nofollow" target="_blank">min()</a></code>和<code class="fe mv mw mx my b"><a class="ae kz" href="https://developer.apple.com/documentation/swift/array/1688806-max" rel="noopener ugc nofollow" target="_blank">max()</a></code>方法可用。这为我们提供了一个可选值，取决于数组中是否有值。空数组返回<code class="fe mv mw mx my b">nil</code>，但是重复相同数字的数组将返回该数字作为最小值和最大值。在我的例子中，我用两个值硬编码我的数组，所以答案永远不会是<code class="fe mv mw mx my b">nil</code>。尽管如此，我还是使用了<code class="fe mv mw mx my b">??</code><code class="fe mv mw mx my b">nil</code>-合并操作符来设置它。</p><p id="7a2a" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">在许多情况下，使用这个操作符比使用不安全的调用操作符<code class="fe mv mw mx my b">!</code>进行强制解包要好得多。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="1975" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">7.扩展枚举以在事例之间安全循环</h1><p id="9ffc" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">虽然枚举不是一个数组，但有时需要迭代它包含的事例。在我的枚举中，我有三个水果的名字:<code class="fe mv mw mx my b">apple</code>、<code class="fe mv mw mx my b">banana</code>、<code class="fe mv mw mx my b">pear</code>。我的enum符合<code class="fe mv mw mx my b">CaseIterable</code>协议，这允许我访问我的案例数组。</p><p id="487a" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">如果我想从当前案例转换到下一个案例，该怎么办？</p><p id="5687" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">选择数组中下一个事例的问题是，我不知道我当前事例的索引是什么。</p><p id="da95" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这就是我的计算属性<code class="fe mv mw mx my b">index</code>所做的。数组可以访问方法<code class="fe mv mw mx my b">firstIndex(of:)</code>，该方法将为我们提供任何想要的值的索引。在任何其他数组中，都有可能找不到该数组。如果没有找到值，我使用<code class="fe mv mw mx my b">nil</code>-合并操作符<code class="fe mv mw mx my b">??</code>给出<code class="fe mv mw mx my b">endIndex</code>。<code class="fe mv mw mx my b">endIndex</code>实际上是在一个数组的最后一个有效索引之后，所以它相当于没有找到有效索引。</p><p id="1dff" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">但是，在这种情况下，我们正在搜索的数组是当前事例所属的枚举的事例数组。</p><p id="ee58" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">因此，<code class="fe mv mw mx my b">endIndex</code>永远不会被返回，只是为了说明如何解决返回的索引为<code class="fe mv mw mx my b">nil</code>的情况:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="71e9" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">其余的扩展属性以各种方式使用我的<code class="fe mv mw mx my b">index</code>属性。</p><p id="4cd4" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我们有<code class="fe mv mw mx my b">previousCase</code>和<code class="fe mv mw mx my b">nextCase</code>作为计算属性，以及其中每一个的循环变体。如果没有循环，<code class="fe mv mw mx my b">previousCase</code>属性将在第一个案例处停止，并继续返回，而不会移出范围。</p><p id="5f4a" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">类似地，<code class="fe mv mw mx my b">nextCase</code>属性将到达最后一个案例，而不会试图超越它。</p><p id="44b4" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">正如你可能已经猜到的，循环种类将从最后到第一或从第一到最后直接进行，这取决于方向。</p><p id="7355" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">您可能会注意到，我使用了<code class="fe mv mw mx my b">indices</code>集合来检查索引是否有效。</p><p id="1b81" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这可以避免很多错误，我推荐你在试图偏移数组索引时使用这种检查。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="2ccc" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">8.使用协议简化SwiftUI</h1><p id="4b72" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">面向协议的编程允许我们更直接地处理值类型，如结构，而不是引用类型，如类。结构不能从超类型继承，因此它们不从祖先继承任何属性。SwiftUI依赖于与<code class="fe mv mw mx my b">View</code>协议的一致性，该协议为特定目的指定属性。我们的<code class="fe mv mw mx my b">View</code>结构不能从超类继承，但是我们仍然可以通过将它分解成协议和扩展来分离关注点:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="8f34" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这是最简单的例子，但是它展示了一种新的构造SwiftUI的方法，这种方法将<code class="fe mv mw mx my b">body</code>属性从结构的其余部分中分离出来。我们的协议<code class="fe mv mw mx my b">TextDisplayable</code>符合<code class="fe mv mw mx my b">View</code>协议本身，导致了传递到<code class="fe mv mw mx my b">TextView</code>结构的一致性链。这仍然是一致性，而不是继承！这就是为什么我可以使用<code class="fe mv mw mx my b">TextView</code>的扩展来提供<code class="fe mv mw mx my b">body</code>属性，而不用指定一致性。如果我从<code class="fe mv mw mx my b">TextDisplayable</code>协议中移除一致性，我将需要在<code class="fe mv mw mx my b">TextView</code>声明或包含主体的扩展中指定它。</p><p id="361c" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">以这种方式使用协议允许我们的结构只包含它需要的<code class="fe mv mw mx my b">text</code>属性。扩展的唯一限制是它们不能包含存储属性，计算属性除外，就像<code class="fe mv mw mx my b">body</code>的情况一样。如果您决定对SwiftUI使用这种方法，请尽可能精确地指定您的协议的目的。</p><p id="e01b" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">协议名称的标准后缀是- <code class="fe mv mw mx my b">ible</code>、- <code class="fe mv mw mx my b">able</code>和- <code class="fe mv mw mx my b">ing</code>，尽管在大多数情况下，它们中的一个足以持续使用。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="5147" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">9.为UserDefaults使用静态字符串常量</h1><p id="caaf" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated"><code class="fe mv mw mx my b">UserDefaults</code>给我们提供了一种存储数据的简单方法，但它有其局限性。</p><p id="a946" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">正如阿克塞尔·基的网站所说:</p><blockquote class="nq"><p id="d048" class="nr ns iu bd nt nu nv nw nx ny nz mu dk translated">使用iExplorer之类的应用程序，用户可以访问他们iPhone的Library/Preferences文件夹，并轻松读取/修改UserDefaults plist数据</p></blockquote><p id="3746" class="pw-post-body-paragraph lz ma iu mb b mc oa jv me mf ob jy mh mi oc mk ml mm od mo mp mq oe ms mt mu in bi translated">结构化数据属于<code class="fe mv mw mx my b">CoreData</code>，而敏感数据属于keychain。</p><p id="fb17" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">然而，当存储简单的数据时，比如在我的例子中的用户的姓名和年龄，<code class="fe mv mw mx my b">UserDefaults</code>工作得相当好。</p><p id="55ab" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">原始字符串是一件危险的事情。如果您犯了拼写错误，编译器不会帮助您，因为字符串可以有任何拼写。对于<code class="fe mv mw mx my b">UserDefaults</code>来说尤其如此，它依靠字符串来保存和加载值到它的属性列表中。显而易见，保存时拼错一个键会导致一个值在键的多种拼写下被存储多次，尝试从拼错的键加载会给人一种没有设置值的错觉。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="7d59" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">使用<code class="fe mv mw mx my b">String</code>的扩展允许我们容易地分配静态常数。虽然我用<code class="fe mv mw mx my b">UserDefaults</code>作为例子，但是这些可以用在任何以<code class="fe mv mw mx my b">String</code>作为参数的函数或初始化器中。在SwiftUI中，我使用iOS 14中新增的<code class="fe mv mw mx my b"><a class="ae kz" href="https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-appstorage-property-wrapper" rel="noopener ugc nofollow" target="_blank">@AppStorage</a></code> <a class="ae kz" href="https://www.hackingwithswift.com/quick-start/swiftui/what-is-the-appstorage-property-wrapper" rel="noopener ugc nofollow" target="_blank">属性包装器</a>从<code class="fe mv mw mx my b">UserDefaults</code>加载。这个属性包装器需要一个<code class="fe mv mw mx my b">String</code>作为键，所以我给它一个<code class="fe mv mw mx my b">nameKey</code>常量。</p><p id="1def" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">在SwiftUI之外的任何环境中，都有必要以传统的方式做事。</p><p id="aa6c" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我使用<code class="fe mv mw mx my b">UserDefaults.standard</code>和我的<code class="fe mv mw mx my b">ageKey</code>常量作为键来加载我的年龄属性。</p><p id="256d" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">不言而喻，你不能在你的常量中犯拼写错误，但是这比每次你需要使用它们时的失败点要少得多。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="2ad4" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">使用枚举而不是原始字符串安全地构造URL</h1><p id="a91a" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">以下是如何安全地创建URL，尽可能减少对原始字符串的依赖。</p><p id="120b" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这可能看起来很多，但是我们基本上是将enums与一个原始类型的<code class="fe mv mw mx my b">String</code>和<code class="fe mv mw mx my b">URLComponents</code>组合在一起。该结构提供了一种单独添加方案、主机和路径组件的方法，而不是传递可能失败的原始字符串。</p><p id="169b" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我们不是依靠硬编码的字符串来获得URL中正确的点和斜线的数量，而是依靠<code class="fe mv mw mx my b">URLComponents</code>结构来完成这项工作。</p><p id="9dfa" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">所以我们添加的组件都不会有斜杠或者点，除了子域和域名之间的点(比如<code class="fe mv mw mx my b">maps.google.com</code>中)。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mz na l"/></div></figure><p id="55b0" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我提供了三个初始化器运行的例子。苹果网址带你到<code class="fe mv mw mx my b">apple.com/accessibility</code>，以<code class="fe mv mw mx my b">accessibility</code>作为路径组件。如果我想添加更多的路径组件，比如<code class="fe mv mw mx my b">apple.com/accessibility/vision</code>，<code class="fe mv mw mx my b">accessibility</code>和<code class="fe mv mw mx my b">vision</code>将是我传递的数组中的独立字符串。</p><p id="aeec" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">同样，不需要斜线，因为这是由<code class="fe mv mw mx my b">URLComponents</code>结构自动完成的。</p><p id="05d5" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">Google URL是用于地图的，所以它使用可选的子域<code class="fe mv mw mx my b">maps</code>。</p><p id="d848" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">我还添加了英国的Google网站，主要是为了展示对这种字符串使用枚举的局限性。因为枚举的案例名称中不能有点，所以我必须指定<code class="fe mv mw mx my b">case couk = “co.uk”</code>。</p><p id="3363" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">只要有可能，尽量让枚举事例反映作为其基础原始值的字符串。</p><p id="8923" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">这样，Swift为我们处理原始值，我们不必像我在这种情况下所做的那样明确地陈述它。</p><p id="c254" class="pw-post-body-paragraph lz ma iu mb b mc nb jv me mf nc jy mh mi nd mk ml mm ne mo mp mq nf ms mt mu in bi translated">感谢阅读！</p></div></div>    
</body>
</html>