<html>
<head>
<title>Advanced TypeScript by Example: React Form Carousel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级打字稿示例:反应表单转盘</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-typescript-by-example-react-form-carousel-ab2545d5a8e3?source=collection_archive---------11-----------------------#2019-08-12">https://betterprogramming.pub/advanced-typescript-by-example-react-form-carousel-ab2545d5a8e3?source=collection_archive---------11-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="baa3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">具有Formik和样式组件集成的类型化carousel的演练</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07ca86c5848b1605c99fe443e82e020f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6-K6Sgd-be0pqRAR3cl-g.jpeg"/></div></div></figure><h1 id="12d8" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">一个真实的TypeScript &amp; React示例项目</h1><p id="25f4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">TypeScript在生态系统中对React和周围的包有很好的支持——这篇文章将演示如何将这些技术结合起来创建一个可靠的组件:一个定制的carousel，其中包含表单并与表单集成。</p><p id="7786" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们将一步一步地完成这个项目——它也可以在Github <a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel" rel="noopener ugc nofollow" target="_blank">这里</a>克隆。转盘被设计为与表单状态集成，并且当表单的该部分完成时，转盘的每个阶段都有变成绿色的链接。每个阶段都有一个嵌入其中的<a class="ae mn" href="https://jaredpalmer.com/formik/" rel="noopener ugc nofollow" target="_blank"> Formik </a>表单。carousel本身就是一个组件，<code class="fe mo mp mq mr b">FormCarousel</code>，它可以将定制组件作为它的舞台。</p><p id="4bf8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是一个正在运行的项目的截屏，展示了一旦表单被验证(通过Formik的<code class="fe mo mp mq mr b">validation</code>函数)，转盘的各个阶段是如何被动画化并更新到完成状态的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/753360387be804df50164862f89c34c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BZUCXuwEZEYdmUil-1oVLg.gif"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">具有表单集成的类型脚本和反应转盘</p></figure><p id="383d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个解决方案需要访问一些聪明和时尚的方式来一起使用TypeScript，React和JSX。它是最基本的，设想开发人员想要扩展这个初始设置或修改它以集成到现有的项目中。</p><p id="c405" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该项目旨在便于跟踪和参考:</p><ul class=""><li id="b56d" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated"><strong class="lo iu">字母排序:</strong>所有CSS属性、组件属性和类型/接口属性都是按字母排序的</li><li id="8bff" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><a class="ae mn" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iu">样式化组件</strong> </a> <strong class="lo iu"> </strong>已经从组件逻辑中分离出来，以便于参考和阅读</li><li id="e3fd" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><strong class="lo iu">单一类型来源:</strong>所有<code class="fe mo mp mq mr b">FormCarousel</code>的具体类型都在<code class="fe mo mp mq mr b">types.ts</code>文件中定义，该文件位于<code class="fe mo mp mq mr b">FormCarousel</code>组件文件夹中。接下来，我们将简要介绍项目结构，强调解决方案如何划分为一系列组件，以便于定制</li><li id="68ce" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><strong class="lo iu">开源:</strong>该项目可以从<a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中拉出，在本地运行(欢迎修改！).稍后我将简要介绍安装步骤和依赖项</li></ul><p id="f660" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这次演讲中，我们将更多地关注类型脚本、道具和组件结构，而不是CSS和样式，尽管所有使用的样式都可以根据具体项目的需要进行研究或扩展。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="9f26" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">项目安装和依赖项</h1><p id="8f81" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">最简单的开始方式是在本地运行项目，但是我们也将介绍一个基本项目的设置步骤。</p><h2 id="2537" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated">安装项目</h2><p id="b094" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">该演示基于<a class="ae mn" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>，将以熟悉的方式打包。从GitHub克隆它并安装依赖项:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="cae1" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu"># local setup</strong></span><span id="d300" class="nx kv it mr b gy or oo l op oq">git clone <a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel.git" rel="noopener ugc nofollow" target="_blank">https://github.com/rossbulat/ts-react-formik-carousel.git</a></span><span id="9152" class="nx kv it mr b gy or oo l op oq">cd ts-react-formik-carousel<br/>yarn &amp;&amp; yarn start</span></pre><p id="9429" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该项目处于最小状态，不需要太多的依赖。如果您需要一个全新的设置，也许想要完全创建您自己的版本，使用包含TypeScript的<code class="fe mo mp mq mr b">create-react-app</code>安装一个基础项目:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="c47a" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu"># generate typescript CRA<br/></strong>npx create-react-app my-carousel-app --typescript</span></pre><p id="716c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="os">注意:</em> </strong> <em class="os"> </em> <code class="fe mo mp mq mr b"><em class="os">npx</em></code> <em class="os">允许我们从节点模块(或已安装的NPM包)执行二进制。它本身是一个全局包，可以用</em> <code class="fe mo mp mq mr b"><em class="os">yarn global add npx</em></code> <em class="os">安装。我们还假设CRA也安装了；用</em> <code class="fe mo mp mq mr b"><em class="os">yarn global add create-react-app</em></code> <em class="os">这样做。</em></p><p id="bff6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">从这里，我们可以跳转到项目目录并安装依赖项:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="5de5" class="nx kv it mr b gy on oo l op oq">cd my-carousel-app</span><span id="9e90" class="nx kv it mr b gy or oo l op oq"><strong class="mr iu"># styled-components with its types</strong><br/>yarn add <a class="ae mn" href="https://www.npmjs.com/package/styled-components" rel="noopener ugc nofollow" target="_blank">styled-components</a> @types/styled-components</span><span id="a10f" class="nx kv it mr b gy or oo l op oq"><strong class="mr iu"># formik form management</strong><br/>yarn add formik</span><span id="ad4d" class="nx kv it mr b gy or oo l op oq"><strong class="mr iu"># FontAwesome icons are used for stage buttons<br/></strong>yarn add <a class="ae mn" href="https://www.npmjs.com/package/@fortawesome/react-fontawesome" rel="noopener ugc nofollow" target="_blank">@fortawesome/react-fontawesome</a> \ <br/>@fortawesome/fontawesome-svg-core \<br/>@fortawesome/free-solid-svg-icons</span></pre><p id="3f59" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这些都是我们需要的依赖；这可以通过参考项目的<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">package.json</a></code>文件来验证。这突出了为您的应用程序定制carousel解决方案的一大优势——较小的文件大小。</p><h2 id="73ef" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated">定制转盘与一体式转盘</h2><p id="e7c5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有能力的轮播包的问题就在于此——它们是一体化的解决方案。这对于快速开发周转和原型开发很有用，但代价是更大的应用构建。添加您自己的定制也变得更加困难，因为您必须遵守所有软件包的设计原则，同时尽量避免破坏已经存在的东西。</p><p id="1f02" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"/></p><p id="594d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">毫无疑问，定制解决方案是一个更好的长期解决方案，有利于你的应用程序的用户体验，并允许你保持加载时间短，只包括你需要的功能。事实上，我们这里的依赖项实际上都不是特定于轮播的，它们都可以在整个应用程序中使用:</p><ul class=""><li id="8adb" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated">样式化组件将用于样式化您的整个应用程序</li><li id="e78f" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated">Formik将成为你的应用程序的表单管理器</li><li id="17d3" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated">只有所使用的字体超赞图标会被捆绑到您的最终版本中，并且可在您应用程序的其他区域导入</li></ul><p id="0551" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">此外，没有什么可以阻止您将您的定制carousel解决方案打包到NPM包中，以便在您的整个项目中使用。我在这里写了一篇关于如何用你自己的NPM注册中心做到这一点的文章。</p><p id="a3c2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们检查一下项目结构，看看<code class="fe mo mp mq mr b">FormCarousel</code>组件是如何形成的。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8940" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">项目结构</h1><p id="00a9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mo mp mq mr b">FormCarousel</code>由多个组件组成，都放在一个<code class="fe mo mp mq mr b">FormCarousel/</code>文件夹下。我们的旋转木马的基本概念是能够将任意数量的表单放入任意数量的旋转木马平台。</p><p id="3b0f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="os">注:</em> </strong> <em class="os"> Stage是我用来表示旋转木马的一个项目的术语。每个项目都是一个阶段，每个阶段都承载一个表单。</em></p><p id="052c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们嵌入到carousel中的表单可以在您的项目中的任何地方定义，并在它的props中提供给<code class="fe mo mp mq mr b">FormCarousel</code>。生成的文件夹结构如下:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="66b9" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu"># component structure</strong></span><span id="d3e9" class="nx kv it mr b gy or oo l op oq">src/<br/>  FormCarousel/<br/>    Stage.tsx<br/>    StageButton.tsx<br/>    Wrapper.tex<br/>    index.tsx<br/>    ...</span><span id="c955" class="nx kv it mr b gy or oo l op oq">  Details.tsx<br/>  Bio.tsx<br/>  <em class="os">^<br/>  FormCarousel is not aware of Form components</em></span></pre><ul class=""><li id="69b5" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/FormCarousel/Stage.tsx" rel="noopener ugc nofollow" target="_blank">Stage.tsx</a></code>和<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/FormCarousel/Wrapper.tsx" rel="noopener ugc nofollow" target="_blank">Wrapper.tsx</a></code>是样式组件——简单地定义了轮播的CSS结构</li><li id="b609" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">StageButton.tsx</code>是一个可点击的按钮，点击后导航到该阶段</li><li id="e7f8" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">index.tsx</code>是<code class="fe mo mp mq mr b">FormCarousel</code>组件本身，它组装样式化的组件、舞台按钮和舞台。这就是组装一个<code class="fe mo mp mq mr b">FormCarousel</code>所需要导入的全部内容(我们将在下一节访问导入和传递道具到<code class="fe mo mp mq mr b">FormCarousel</code>)</li></ul><p id="19c7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">即使表单组件与<code class="fe mo mp mq mr b">FormCarousel</code>解耦，它们仍然需要遵循转盘阶段期望的类型，以确保对转盘的支持，例如将阶段更新为完成状态。如果我们现在进入一个阶段的界面(我们将在整篇文章中更深入地研究类型和类型脚本特定的语法)，我们可以确切地看到每个阶段在道具方面的期望:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="1202" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu"># snippet from </strong><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/FormCarousel/types.ts" rel="noopener ugc nofollow" target="_blank"><strong class="mr iu">FormCarousel/types.ts</strong></a></span><span id="9131" class="nx kv it mr b gy or oo l op oq">export interface FormCarousel_Stage {<br/>   <strong class="mr iu">form: React.ComponentType&lt;FormCarousel_Form&gt;;</strong><br/>   icon: React.ReactNode;<br/>   label: string;<br/>}</span></pre><p id="dad6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">请注意<code class="fe mo mp mq mr b">form</code>属性，它是一个通用的React组件，需要它的props符合<code class="fe mo mp mq mr b">FormCarousel_Form</code>类型。只要有一个<code class="fe mo mp mq mr b">form</code>组件遵循这一点，TypeScript就不会抛出任何编译器错误。我们将进一步讨论<code class="fe mo mp mq mr b">FormCarousel_Form</code>道具。</p><p id="b69b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有了对carousel如何构造的高级概念理解，现在让我们看看<code class="fe mo mp mq mr b">FormCarousel</code>是如何导入的，以及表单和其他配置是如何作为道具传递到组件中的。然后，我们将一路向下，一路上参观一些有趣的语法。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="54fa" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">导入和使用<FormCarousel/></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/163f461fa1eca012ca42f46e8887b355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLrIGhc4qy28qWzrKGgV6w.jpeg"/></div></div></figure><p id="8bdb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用<code class="fe mo mp mq mr b">FormCarousel</code>就像导入它并给它一个道具:<code class="fe mo mp mq mr b">stages</code>一样简单。这是在演示项目的<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/App.tsx" rel="noopener ugc nofollow" target="_blank">App.tsx</a></code>中完成的，我们为每个阶段提供了一个表单、一个图标和一个标签:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="52dc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">FormCarousel</code>只带一个道具，<code class="fe mo mp mq mr b">stages</code>。如果我们参考组件签名，我们可以准确地找到该道具需要包含的内容:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="728f" class="nx kv it mr b gy on oo l op oq">export class FormCarousel extends React.Component&lt;<strong class="mr iu">FormCarouselProps</strong>, FormCarouselState&gt;</span></pre><p id="d864" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通过跳转到<code class="fe mo mp mq mr b">FormCarousel/types.ts</code>，我们可以看到<code class="fe mo mp mq mr b">FormCarousel</code>期望一个<code class="fe mo mp mq mr b">FormCarousel_Stage</code>的数组:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="7d96" class="nx kv it mr b gy on oo l op oq">export interface FormCarouselProps {<br/>  <strong class="mr iu">stages: FormCarousel_Stage[];</strong><br/>}</span><span id="613e" class="nx kv it mr b gy or oo l op oq">export interface FormCarousel_Stage {<br/>  form: React.ComponentType&lt;FormCarousel_Form&gt;;<br/>  icon: React.ReactNode;<br/>  label: string;<br/>}</span></pre><p id="8360" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="os">注意:</em></strong><em class="os">CMD+点击你编辑器内的类型名(我用的是VS代码)跳转到定义文件。</em></p><p id="390b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们在上面简要介绍了<code class="fe mo mp mq mr b">FormCarousel_Stage</code>，但现在我们可以介绍剩余的属性:</p><ul class=""><li id="3cb0" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">icon</code>属性需要一个字体很棒的图标形式的React节点。这是因为<code class="fe mo mp mq mr b"><a class="ae mn" href="https://www.npmjs.com/package/@fortawesome/react-fontawesome" rel="noopener ugc nofollow" target="_blank">react-fontawesome</a></code>包为我们提供了包装在React组件中的SVG</li><li id="7886" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">label</code>属性只是一个字符串，它将与图标一起显示在舞台的相应<code class="fe mo mp mq mr b">StageButton</code>中</li></ul><p id="e465" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">form</code>属性是最神秘的，我们现在不需要担心一般的<code class="fe mo mp mq mr b">&lt;FormCarousel_Form&gt;</code>类型——我们只是在这个阶段提供一个React组件，并且在呈现组件时，将在JSX元素中为它提供道具。</p><p id="2c65" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有了给<code class="fe mo mp mq mr b">FormCarousel</code>的<code class="fe mo mp mq mr b">FormCarousel_Stage</code>数组，我们现在可以使用这些道具来构建转盘本身。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="4f48" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">在FormCarousel组件内部</h1><p id="aee0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">逻辑的实质发生在<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/FormCarousel/index.tsx" rel="noopener ugc nofollow" target="_blank">FormCarousel/index.tsx</a></code>内部。</p><p id="4e49" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">FormCarousel</code>有一些状态，在我们的<code class="fe mo mp mq mr b">types.ts</code>文件中定义为<code class="fe mo mp mq mr b">FormCarouselState</code>:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="0402" class="nx kv it mr b gy on oo l op oq">export interface FormCarouselState {<br/>  activeStage: number;<br/>  stageOut: number;<br/>  stageCompleted: Array&lt;boolean&gt;;<br/>}</span></pre><p id="0f5f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">每个阶段都有一个从<code class="fe mo mp mq mr b">0</code>开始的索引。这是索引轮播的最简单的方法，有利于映射或循环每个阶段，每个阶段都有一个匹配索引的对应键。</p><ul class=""><li id="33b4" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">activeStage</code>存储当前显示的阶段——默认索引为<code class="fe mo mp mq mr b">0</code></li><li id="30ab" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">stageOut</code>跟踪过渡出来的阶段。这仅仅是为了制作动画。我们需要知道哪个阶段要制作动画(我们已经知道<code class="fe mo mp mq mr b">activeStage</code>是要制作动画的阶段)。在初始渲染时，给定一个值<code class="fe mo mp mq mr b">-1</code>,以确保没有一个会过渡出来</li></ul><p id="4963" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">stageCompleted</code>只是一个表示每个阶段是否完成的布尔数组，在初始声明时给出一个空数组:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="1819" class="nx kv it mr b gy on oo l op oq">state: FormCarouselState = {<br/>  activeStage: 0,<br/>  stageOut: -1,<br/>  stageCompleted: []<br/>};</span></pre><p id="5724" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个数组的长度是任意的——它取决于我们通过前面提到的<code class="fe mo mp mq mr b">stages</code>属性传递到组件中的级数。因此，我们在组件的<code class="fe mo mp mq mr b">constructor</code>中填充这个状态值，根据我们通过props提供的级数动态定义数组的长度:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="1694" class="nx kv it mr b gy on oo l op oq">constructor (props: FormCarouselProps) {<br/>    super(props);<br/>    <br/>   const stages = props.stages.map((item: FormCarousel_Stage) =&gt; {<br/>      return false;<br/>    });<br/>   this.state.stageCompleted = stages;<br/>  }</span></pre><p id="7469" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通过用<code class="fe mo mp mq mr b"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">Array.map()</a></code>遍历每个阶段，我们可以构造一个新的数组，用值<code class="fe mo mp mq mr b">false</code>索引每个阶段。上面的代码片段做到了这一点，并用结果数组更新了<code class="fe mo mp mq mr b">this.state.stageCompleted</code>。</p><p id="1ec4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="os">注意:</em> </strong> <em class="os">如果你想在初始渲染时启动一个完整的表单，你可以在这里检查你的表单组件以确定表单是否完整——随意添加额外的道具来帮助更多的配置。</em></p><h2 id="491b" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated">轮播互动方法</h2><p id="7a25" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mo mp mq mr b">FormCarousel</code>定义了两个方法来更新它的状态，这两个方法被传递给<code class="fe mo mp mq mr b">StageButton</code>和每个表单组件，以便与转盘本身进行交互:</p><ul class=""><li id="302e" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">toggleActiveStage()</code>:更新转盘活动阶段的方法</li><li id="b294" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">setStageCompleted()</code>:切换特定阶段是否已完成的方法。这将在Formik的<code class="fe mo mp mq mr b">handleSubmit()</code>方法中被调用，我们将在下面看到。</li></ul><p id="93d0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这些方法没有什么突破性的，但是，<code class="fe mo mp mq mr b">setStageCompleted()</code>遵循了一个重要的惯例，即在操作状态对象的值之前复制它，然后用<code class="fe mo mp mq mr b">setState()</code>将它应用到组件状态。此函数在将复制的状态对象中的阶段的完成状态应用到状态本身之前，更新该状态:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="26da" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu"># duplicating state -&gt; amending -&gt; setState pattern</strong></span><span id="66c6" class="nx kv it mr b gy or oo l op oq">const stageCompleted: Array&lt;boolean&gt; =       <br/>   Object.values(this.state.stageCompleted);</span><span id="29b0" class="nx kv it mr b gy or oo l op oq">stageCompleted[index] = true;</span><span id="ba3d" class="nx kv it mr b gy or oo l op oq">this.setState({ stageCompleted: stageCompleted });</span></pre><p id="3188" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这些方法，以及组件的状态，现在可以用来配置要传递给<code class="fe mo mp mq mr b">StageButton</code>和每个表单组件的道具。呈现这些组件发生在JSX内部定义的两个映射中。</p><p id="8171" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是我们的目标模式:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="9e92" class="nx kv it mr b gy on oo l op oq">...<br/>render() {<br/> &lt;Wrapper&gt;<br/>  &lt;header&gt;<br/>      { loop through stage buttons and render }<br/>        { include arrow icon in-between buttons }<br/>  &lt;/header&gt;<br/>  &lt;div&gt; <br/>      { loop through forms, display active form and animate in}<br/>        { also display previous form to animate out }<br/>  &lt;/div&gt;<br/> &lt;/Wrapper&gt;<br/>}<br/>...</span></pre><p id="cb72" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu"> <em class="os">注意:</em> </strong> <em class="os">映射一个对象也可以在JSX之外完成，但这在其他项目和文档中常见。有时内联JSX制图对于开发者来说更容易阅读，并且将你所有的JSX标记保存在一个地方。</em></p><p id="4643" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来让我们回顾一下这是如何完成的，触及一些组成我们的<code class="fe mo mp mq mr b">render()</code>函数的有趣语法。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="fa5d" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">渲染了一下<StageButton/></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/b0ec883f011e40485d6b2a6a4eaf8073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9jG6iNDonUY5Ps-WmVxrw.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">3个StageButton组件，中间有字体分隔箭头</p></figure><p id="9075" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们看看<code class="fe mo mp mq mr b">StageButton</code>是如何生成的，遍历每个<code class="fe mo mp mq mr b">props.stages</code>来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="f04f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里有几件有趣的事情:</p><ul class=""><li id="b3f5" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated">如果我们的映射索引大于0，我们已经使用<code class="fe mo mp mq mr b">React.Fragment</code>来包装每个<code class="fe mo mp mq mr b">StageButton</code>和可能的<code class="fe mo mp mq mr b">FontAwesomeIcon</code>(我们不需要第一个<code class="fe mo mp mq mr b">StageButton</code>左边的箭头！)</li></ul><p id="e9e9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="os">为什么用</em> <code class="fe mo mp mq mr b"><a class="ae mn" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank"><em class="os">React.Fragment</em></a></code> <em class="os">？JSX渲染方法必须有一个最顶层的组件，如果我们在</em> <code class="fe mo mp mq mr b"><em class="os">StageButton</em></code> <em class="os">旁边渲染一个图标，情况就不一样了。</em> <code class="fe mo mp mq mr b"><em class="os">React.Fragment</em></code> <em class="os">就是为这样的场景而推出的。我们还把强制可迭代的</em> <code class="fe mo mp mq mr b"><em class="os">key</em></code> <em class="os">道具与</em> <code class="fe mo mp mq mr b"><em class="os">React.Fragment</em></code> <em class="os">列入其中。</em></p><ul class=""><li id="6d3a" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated">我们映射的<code class="fe mo mp mq mr b">i</code>参数也充当我们的阶段索引，并被传递到<code class="fe mo mp mq mr b">StageButton</code>中，因此它知道它代表哪个阶段</li><li id="5bcf" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated"><code class="fe mo mp mq mr b">toggleActiveStage()</code>作为一个道具被传入<code class="fe mo mp mq mr b">StageButton</code>，给按钮更新传送带的权限</li></ul><p id="5849" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们访问<code class="fe mo mp mq mr b">FormCarousel_StageButton</code>界面，我们可以看到所有支持的<code class="fe mo mp mq mr b">StageButton</code>道具:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="768a" class="nx kv it mr b gy on oo l op oq">export interface FormCarousel_StageButton {<br/>  active: boolean;<br/>  complete: boolean;<br/>  icon: React.ReactNode;<br/>  index: number;<br/>  label: string;<br/> <strong class="mr iu"> toggle (index: number): void;</strong><br/>}</span></pre><p id="0734" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">确实包含了<code class="fe mo mp mq mr b">toggle</code>方法的签名，每个阶段<code class="fe mo mp mq mr b">index</code>也是如此，还包含了其他配置，如阶段是否为<code class="fe mo mp mq mr b">active</code>和<code class="fe mo mp mq mr b">completed</code>。这些道具最终决定了按钮的样式，例如颜色和活动指示器(活动舞台按钮下面的项目符号)。</p><h2 id="af51" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated"><stagebutton>的样式组件</stagebutton></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/b39e4337b18654398b85906dd922a27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drgRrq4ESb5EZMZ6MP2y0A.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">StageButton的三种状态:完成、活动和非活动</p></figure><p id="1a45" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果我们看一下<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/FormCarousel/StageButton.tsx" rel="noopener ugc nofollow" target="_blank">StageButton.tsx</a></code>本身，我们可以看到它被一个<code class="fe mo mp mq mr b">StyledButton</code>组件所包装，该组件通过<code class="fe mo mp mq mr b">props.toggle()</code>处理一个点击事件来更新carousel:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="7e74" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu">const StyledButton = styled.button&lt;FormCarousel_StyledStageButton&gt;`<br/>   ...<br/>`;</strong></span><span id="3551" class="nx kv it mr b gy or oo l op oq">return (<br/>   <strong class="mr iu">&lt;StyledButton</strong><br/>     complete={props.complete}<br/>     disabled={props.active ? true : false}<br/>     <strong class="mr iu">onClick={() =&gt; { props.toggle(props.index) }}</strong><br/>   &gt;<br/>     {props.icon !== undefined &amp;&amp; props.icon}<br/>     {props.label}<br/>     {props.active &amp;&amp; &lt;span&gt;&amp;bull;&lt;/span&gt;}<br/>   <strong class="mr iu">&lt;/StyledButton&gt;</strong><br/>);</span></pre><p id="ddde" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有趣的是，样式化组件支持泛型类型，这给了我们严格定义样式化组件的机会。<code class="fe mo mp mq mr b">FormCarousel_StyledStageButton</code>类型迎合了该样式组件所需的道具:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="7f89" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu">// type specifically for a styled component</strong></span><span id="96a4" class="nx kv it mr b gy or oo l op oq">export interface FormCarousel_StyledStageButton {<br/>  complete: boolean;<br/>  disabled: boolean;<br/>  onClick (index: number): void;<br/>}</span></pre><p id="971d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">completed</code>属性在<code class="fe mo mp mq mr b">StyledButton</code>本身中被多次访问，以确定默认的灰色或完整的绿色是否应该被分配给属性— <code class="fe mo mp mq mr b">border</code>是这些属性之一:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="d5e5" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu">// accessing props to determine property values</strong></span><span id="e4a8" class="nx kv it mr b gy or oo l op oq">const completedColor = '#28a81b';<br/>const inactiveColor = '#888';<br/>const activeColor = '#000';</span><span id="0eb9" class="nx kv it mr b gy or oo l op oq">const StyledButton = styled.button&lt;FormCarousel_StyledStageButton&gt;`<br/>   <!-- -->border: 1px solid <strong class="mr iu">${props =&gt;</strong> props.complete === true ? `${completedColor} !important` : inactiveColor<strong class="mr iu">};<br/></strong>   ...<br/>`;</span></pre><p id="8fe5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">StageButton</code>的完整实现可以在这里找到<a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/FormCarousel/StageButton.tsx" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="176d" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">呈现阶段(表单组件)</h1><p id="355c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">像<code class="fe mo mp mq mr b">StageButton</code>一样，我们也迭代<code class="fe mo mp mq mr b">FormCarousel</code>的<code class="fe mo mp mq mr b">props.stages</code>并呈现适当的表单，以及表单进入和退出所需的动画。</p><p id="05e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该循环类似于以下内联JSX:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="0962" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu">// rendering forms in-line JSX</strong></span><span id="1020" class="nx kv it mr b gy or oo l op oq">&lt;div&gt;<br/>{this.props.stages.map((stage: FormCarousel_Stage, i: number) =&gt; {<br/>     <strong class="mr iu">const Form: React.ComponentType&lt;FormCarousel_Form&gt; = <br/>       stage.form;<br/>    </strong> return (<br/>       &lt;Form ... /&gt;<br/>    );<br/>  })}<br/>&lt;/div&gt;</span></pre><p id="97bb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意我们是如何抓取<code class="fe mo mp mq mr b">stage.form</code>并将新对象键入为<code class="fe mo mp mq mr b">React.ComponentType&lt;FormCarousel_Form&gt;</code>。这是告诉Typescript编译器<code class="fe mo mp mq mr b">stage.form</code>到底是什么所必需的。然后我们将<code class="fe mo mp mq mr b">Form</code>渲染成一个JSX元素以及所有需要的道具。</p><p id="26b9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">FormCarousel_Form</code>接口定义了每个表单组件需要的道具，4个粗体属性对我们的表单很重要:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="35e2" class="nx kv it mr b gy on oo l op oq">export interface FormCarousel_Form {<br/>  className: string;<br/>  <strong class="mr iu">index: number;</strong><br/>  key: number;<br/><strong class="mr iu">  setCompleted (index: number, completed: boolean): void;<br/>  toggleStage (index: number): void;<br/>  transition: StageTransition;<br/></strong>}</span></pre><p id="f6bc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">除了这两个carousel方法，我们还定义了表单的stage <code class="fe mo mp mq mr b">index</code>和iterable的required<code class="fe mo mp mq mr b">key</code>prop——两者是相同的。</p><p id="e6e9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">transition</code>是这里有趣的属性——它有一个特定的类型，限制了它可以接受的值。让我们进一步探讨这个问题。</p><h2 id="468b" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated">舞台过渡关键帧动画</h2><p id="55b5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mo mp mq mr b">StageTransition</code>类型定义了所有可能的<code class="fe mo mp mq mr b">transition</code>值，这些值决定了舞台上实际发生的关键帧动画:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="7490" class="nx kv it mr b gy on oo l op oq">export type StageTransition = <br/>   'stage_in_left' | 'stage_out_left' | <br/>   'stage_in_right' | 'stage_out_right' | <br/>   'none';</span></pre><p id="5006" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">StageTransition</code>是一个<a class="ae mn" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types" rel="noopener ugc nofollow" target="_blank">字符串文字类型</a>，它定义了过渡接受的关键帧动画名称。舞台可以从左边或右边进入或退出。我们确实可以通过参考活动阶段索引和前一阶段索引来计算正确的转换。</p><p id="e706" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这正是在<code class="fe mo mp mq mr b">transition</code> prop中所做的，通过简单地嵌入多个<code class="fe mo mp mq mr b">expression ? true : false</code>语句来确定最终的阶段转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="abdb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这也可以作为一组if-else语句来完成，但是这种方法允许我们将语法保持在最少——并且保持为内联JSX。</p><p id="5c32" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">随着动画变得越来越复杂，您可能希望创建自己的动画控制器类，而不是将此逻辑作为道具嵌入！在任何情况下，上面的程序块都声明:</p><ul class=""><li id="bbd7" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated">如果<code class="fe mo mp mq mr b">activeStage</code>指数小于<code class="fe mo mp mq mr b">stageOut</code>指数，则从左侧转变<code class="fe mo mp mq mr b">activeStage</code>，否则从右侧转变<code class="fe mo mp mq mr b">activeStage</code></li><li id="c126" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated">如果<code class="fe mo mp mq mr b">activeStage</code>指数小于<code class="fe mo mp mq mr b">stageOut</code>指数，则向右移动<code class="fe mo mp mq mr b">stageOut</code>，否则向左移动<code class="fe mo mp mq mr b">stageOut</code></li><li id="d6e2" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated">仅将过渡应用于<code class="fe mo mp mq mr b">activeStage</code>和<code class="fe mo mp mq mr b">stageOut</code>索引。所有其他阶段都有一个<code class="fe mo mp mq mr b">none</code>过渡</li></ul><p id="4130" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们没有提到的另一个属性<code class="fe mo mp mq mr b">className</code>，将为不是<code class="fe mo mp mq mr b">activeStage</code>或<code class="fe mo mp mq mr b">stageOut</code>的所有阶段保存一个值<code class="fe mo mp mq mr b">hidden</code>:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="06d1" class="nx kv it mr b gy on oo l op oq">&lt;Form<br/>   className={<br/>     this.state.activeStage !== i &amp;&amp; this.state.stageOut !== i <br/>       ? `hidden` <br/>       : ``<br/>   }<br/>   ...<br/>/&gt;</span></pre><p id="e3d4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有了这个逻辑，我们就可以确保只显示转入和转出的两个阶段，而隐藏其余的阶段。</p><p id="3e0b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，关键帧动画本身是在<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/FormCarousel/Stage.tsx" rel="noopener ugc nofollow" target="_blank">Stage.tsx</a></code>中定义的，这是一个样式化的组件，它定义了所有与表单相关的CSS并包装了表单组件。</p><p id="247a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">transition</code>道具首先传入样式化组件:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="31de" class="nx kv it mr b gy on oo l op oq"><strong class="mr iu">// from within any Form component (Details, Bio, Submit)</strong></span><span id="4d23" class="nx kv it mr b gy or oo l op oq">&lt;Stage transition={props.transition}&gt;<br/>   ...<br/>&lt;/Stage&gt;</span></pre><p id="e402" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在组件知道了正确的转换，它可以被嵌入到<code class="fe mo mp mq mr b">animation</code>属性中。还要注意我们的<code class="fe mo mp mq mr b">StateTransition</code>字符串文字值如何匹配关键帧动画名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="f67f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这就结束了旋转木马的动画解决方案。概括地说，只需要显示活动阶段和退出阶段，并分别附加一个输入和输出动画。</p><p id="2aed" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在剩下要访问的就是表单本身，通过Formik经由<code class="fe mo mp mq mr b">withFormik()</code> HOC进行管理。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="ee49" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">圆盘传送带表单</h1><p id="7cc5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本节利用Formik的HOC，<code class="fe mo mp mq mr b">withFormik()</code>，将Formik的功能包装在一个表单中。我已经发表了一篇关于Formik和这个HOC的文章，在深入本节之前可能是一篇有用的阅读，可以在这里找到<a class="ae mn" href="https://medium.com/@rossbulat/react-forms-with-formik-hocs-and-functional-components-df394afd2039" rel="noopener"/>。</p><p id="db37" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们在这里要关注的是如何利用TypeScript来使Formik类型安全，这涉及到我们的自定义carousel道具和“FormikBag”——Formik自己的一系列用于管理包装表单的道具。</p><p id="ee76" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">正如我们在<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/App.tsx" rel="noopener ugc nofollow" target="_blank">App.tsx</a></code>中看到的，我们有三个表单组件作为道具被导入到carousel中；<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/Details/index.tsx" rel="noopener ugc nofollow" target="_blank">Details</a></code>、<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/Bio/index.tsx" rel="noopener ugc nofollow" target="_blank">Bio</a></code>、<code class="fe mo mp mq mr b"><a class="ae mn" href="https://github.com/rossbulat/ts-react-formik-carousel/blob/master/src/Submit/index.tsx" rel="noopener ugc nofollow" target="_blank">Submit</a></code>。这些组件故意保持简单，以免使读者困惑或超出讨论范围，坚持每个表单一个输入。</p><p id="ec19" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">表单是旋转木马的一个很好的用例，应该在现代应用程序开发中更多地使用。</strong></p><p id="8467" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们通过<code class="fe mo mp mq mr b">Detail</code>来了解输入Formik表单的重要概念。</p><h2 id="5f29" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated">解构细节形式</h2><p id="d476" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本项目中的每个Formik模板都以相同的方式构建:</p><ul class=""><li id="e324" class="mx my it lo b lp mi ls mj lv mz lz na md nb mh nc nd ne nf bi translated">定义表单标记的表示组件，利用Formik提供的组件有<code class="fe mo mp mq mr b">Form</code>、<code class="fe mo mp mq mr b">Field</code>、<code class="fe mo mp mq mr b">ErrorMessage</code>等。</li><li id="a18d" class="mx my it lo b lp ng ls nh lv ni lz nj md nk mh nc nd ne nf bi translated">特设包装了表示组件，定义了Formik特定的功能，如验证、提交和初始表单值</li></ul><p id="4c93" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们检查一下表示性组件签名，以了解注入其中的道具的范围:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="ba55" class="nx kv it mr b gy on oo l op oq">const DetailsForm: React.FC&lt;<strong class="mr iu">FormCarousel_Form &amp; FormikProps&lt;Form_Details&gt;</strong>&gt; = (props) =&gt; {<br/>   ...<br/>}</span></pre><p id="9eb1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们定义了一个交集类型，将<code class="fe mo mp mq mr b">FormCarousel_Form</code>和<code class="fe mo mp mq mr b">FormikProps&lt;Form_Details&gt;&gt;</code>组合在一起，组成我们的组件<code class="fe mo mp mq mr b">props</code>。</p><p id="2504" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">FormDetails</code>简单定义我们期望的表单值。在我们的例子中，<code class="fe mo mp mq mr b">Details</code>表单只包含一个<code class="fe mo mp mq mr b">email</code>字段:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="f597" class="nx kv it mr b gy on oo l op oq">export interface Form_Details {<br/>   email: string<br/>}</span></pre><p id="2309" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe mo mp mq mr b">FormikProps&lt;T&gt;</code>，一个促进props <code class="fe mo mp mq mr b">withFormik()</code>注入范围的类型，也为我们的表单值类型的传入提供了一个通用类型。因此我们到达<code class="fe mo mp mq mr b">FormikProps&lt;Form_Details&gt;</code>。<code class="fe mo mp mq mr b">FormCarousel_Form</code>则方便了我们在<code class="fe mo mp mq mr b">FormCarousel/index.tsx</code>中通过的所有道具。</p><p id="a270" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦定义了<code class="fe mo mp mq mr b">DetailsForm</code>，我们就开始用<code class="fe mo mp mq mr b">withFormik()</code>包装它。</p><h2 id="231c" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated">withFormik特设集成</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/7561f6facb090a698d6b223e3e295d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CqotDO-LK7ct7xvSackEg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">formikHOC管理验证，正如这里看到的一个空的Bio错误消息</p></figure><p id="aaf1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">参考<a class="ae mn" href="https://jaredpalmer.com/formik/docs/guides/typescript#withformik" rel="noopener ugc nofollow" target="_blank"> TypeScript Formik文档</a>，我们需要为HOC提供两种通用类型——表单属性和表单值。看起来是这样的:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="f336" class="nx kv it mr b gy on oo l op oq">const Details = <strong class="mr iu">withFormik&lt;FormCarousel_Form &amp; FormProps, Form_Details&gt;</strong>({<br/>   ... <strong class="mr iu"><br/></strong>})(DetailsForm);</span></pre><p id="eb57" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们再次提供了从<code class="fe mo mp mq mr b">FormCarousel</code>传来的与Formik道具结合的道具，以及与<code class="fe mo mp mq mr b">Form_Details</code>结合的表单值。处理好类型后，我们就可以像在Formik中一样处理我们的业务，定义验证、初始值等。</p><p id="8ad0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有趣的是，在<code class="fe mo mp mq mr b">handleSubmit()</code>中，我们从我们的自定义道具中抓取了<code class="fe mo mp mq mr b">setCompleted()</code>和<code class="fe mo mp mq mr b">setActiveStage()</code>，它们现在位于<code class="fe mo mp mq mr b">props.formikBag</code>中。表单成功提交后，将执行这些方法，从而更新转盘状态:</p><pre class="kj kk kl km gt oj mr ok ol aw om bi"><span id="9c28" class="nx kv it mr b gy on oo l op oq">...<br/>handleSubmit: (values, formikBag) =&gt; {<br/>   formikBag.props.setCompleted(formikBag.props.index, true);<br/>   formikBag.props.toggleStage(formikBag.props.index + 1);<br/>}<br/>...</span></pre><p id="ff16" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这就是我们的Formik管理的表单与carousel组件交互的方式。在状态改变时，传送带重新呈现，这又导致阶段转换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/2dcec7a0c5931576d33535b266591ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9m1LdKjFjv8g2iEViDVmxQ.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">处于完成状态的转盘，由每个阶段按钮突出显示</p></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="df7f" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">总结</h1><p id="0ae0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本演练试图展示一个使用TypeScript、React和Formik(以及样式化组件！)来创建一个有用的可重用组件，以便于表单显示。</p><p id="ceaa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该解决方案已经完全定型，并准备好进行扩展以适应各个项目。</p><h2 id="12d9" class="nx kv it bd kw ny nz dn la oa ob dp le lv oc od lg lz oe of li md og oh lk oi bi translated">了解本项目中使用的概念的更多信息</h2><p id="20a5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在我关于这个主题的文章中了解更多关于TypeScript和泛型的使用:</p><div class="oz pa gp gr pb pc"><a href="https://medium.com/@rossbulat/typescript-generics-explained-15c6493b510f" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">解释了类型脚本泛型</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">了解什么是泛型以及如何在Typescript中使用泛型</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ks pc"/></div></div></a></div><p id="0d1b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要复习样式组件，请查看如何将它与应用程序的明暗模式结合使用:</p><div class="oz pa gp gr pb pc"><a href="https://medium.com/@rossbulat/react-dark-mode-with-styled-theming-and-context-57557de6400" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">用风格化的主题和上下文来反应黑暗模式</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">如何用React挂钩、上下文和样式组件切换主题</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="pr l pn po pp pl pq ks pc"/></div></div></a></div><p id="d6a5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于Formik的具体研究，请查看我的文章，重点关注Formik提供的<code class="fe mo mp mq mr b">withFormik()</code> HOC和其他组件:</p><div class="oz pa gp gr pb pc"><a href="https://medium.com/@rossbulat/react-forms-with-formik-hocs-and-functional-components-df394afd2039" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">与Formik HOCs和功能组件反应的形式</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">使用Formik HOCs开发表单并将Formik注入定制组件</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="ps l pn po pp pl pq ks pc"/></div></div></a></div></div></div>    
</body>
</html>