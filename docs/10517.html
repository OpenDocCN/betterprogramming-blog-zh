<html>
<head>
<title>Building a Responder Chain Using the SwiftUI View Hierarchy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI视图层次结构构建响应者链</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-responder-chain-using-the-swiftui-view-hierarchy-2a08df23689c?source=collection_archive---------4-----------------------#2022-01-12">https://betterprogramming.pub/building-a-responder-chain-using-the-swiftui-view-hierarchy-2a08df23689c?source=collection_archive---------4-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="38a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用环境价值轻松响应视图层次结构中生成的事件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e97881d62af2d3e8a632a7bb1218782d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5f1kV0Q8d9UHPv9V"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mael_balland?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mael BALLAND </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的10年里，我花了很多时间在StackOverflow中回答问题，我经常看到的一个问题是:</p><blockquote class="ls lt lu"><p id="6c16" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">我如何从类<code class="fe lz ma mb mc b">B</code>中的函数触发类<code class="fe lz ma mb mc b">A</code>中的事件？</p></blockquote><p id="68d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个经验丰富的开发人员来说，这似乎是一个简单的问题，毕竟我们有多种方法可以做到这一点，我们可以使用委托、回调、通知等。，但这仍然是我们经常遇到的情况，两个对象相距越远，它们之间的通信就越复杂。</p><p id="2d71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">挑战的一部分是以可扩展和可维护的方式实现这一点。你<em class="lv">可以</em>创建一个应用程序，通过<code class="fe lz ma mb mc b">NotificationCenter</code>发送每一个事件，但是你很快就会把头撞到桌子上。</p><h1 id="d8d8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">输入响应者链</h1><p id="6921" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">响应者链是一种设计模式，其中响应者对象形成一个“链”。事件在链的“链接”或“节点”之一中生成，节点确定它是否能够处理事件。如果它不能处理该事件，则该事件被发送到链中的下一个节点。这个过程一直持续到一个节点可以处理该事件，或者到达链的末端。</p><p id="7429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lz ma mb mc b">object-delegate</code>关系是这种模式的一个简单例子。<code class="fe lz ma mb mc b">object</code>创建了一个它自己不能处理的事件，因此该事件被发送到链中的下一个节点，也就是<code class="fe lz ma mb mc b">delegate</code>。更复杂的例子是<code class="fe lz ma mb mc b">UIResponder</code>链。</p><p id="97bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显式响应器链在iOS开发中并不常见，可能是因为大多数<code class="fe lz ma mb mc b">UIKit</code>的核心构建块，如<code class="fe lz ma mb mc b">UIViewController</code>及其子类，使得构建起来非常容易。</p><p id="b952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用SwiftUI，每个对象都通过视图层次结构<em class="lv">链接</em>到根视图，这意味着我们构建响应者链所需的整体结构已经就绪，我们需要添加的只是响应者和事件。</p><h1 id="a12c" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">SwiftUI视图层次结构</h1><p id="082f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">SwiftUI视图层次结构的一个有趣的特性是，它的一些值，比如<code class="fe lz ma mb mc b">Environment</code>和<code class="fe lz ma mb mc b">EnvironmentObjects</code>，会沿着层次结构向下传递，直到它们被替换。我们可以用这个，尤其是<code class="fe lz ma mb mc b">Environment</code>，来记录我们的响应者。</p><p id="2799" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让事情更加直观，这是从这个简单的视图中生成的层次结构。注意像<code class="fe lz ma mb mc b">foregroundColor</code>这样的修改器是如何创建一个节点的，这个节点是它们正在修改的视图的父节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/ebed99b23abc310c6a8530bf2e6de88b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3E6O_extvecc4fbrmUe1xg.png"/></div></div></figure><h1 id="a0ee" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">SwiftUI环境</h1><p id="2dda" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">环境值起初看起来令人生畏，因为它们经常被用于系统动作，比如删除一个表，添加我们自己的需要扩展一个系统类型，<code class="fe lz ma mb mc b">EnvironmentValues</code>。尽管这样做非常安全，而且因为它们可以是任何类型，所以它们的<code class="fe lz ma mb mc b">Type</code>可以是一个闭包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">因为我们对事件需要的对象类型没有任何限制，所以我们将使用任意类型的对象。</p></figure><p id="4f7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个值，任何视图都可以读取我们的自定义环境值，并为它设置一个新值。由于我们添加的值是一个闭包，所以我们的视图也可以称之为闭包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="ee58" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">创建响应者</h1><p id="15d9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">前面我们提到过，响应者有责任确定它是否能够处理一个事件。我们的视图将通过在环境中注册自己的<code class="fe lz ma mb mc b">eventClosure</code>来注册自己为响应者。</p><p id="0e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何调用<code class="fe lz ma mb mc b">eventClosure</code>的子视图都将触发我们视图的处理程序，只要中间视图没有替换它。如果我们的视图确定它不能处理该事件，它可以使用它从环境中读取的闭包，这将来自一个父响应器，以允许该事件继续通过该链。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/038a5e13b4d765119466c9794120b97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U54vl3NNMkHm0nqyNkaG9w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两名注册响应者。黄色<strong class="bd ne">不能</strong>处理事件，因此事件继续其路径并到达绿色，绿色<strong class="bd ne">可以</strong>处理它。</p></figure><p id="2698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这将是一个常见的模式，我们将创建一个<code class="fe lz ma mb mc b">ViewModifier</code>来封装这个功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ad7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们新的<code class="fe lz ma mb mc b">handler</code>闭包有一个返回类型<code class="fe lz ma mb mc b">Any?</code>，因为这是我们决定事件是否被处理的方式。如果返回值是<code class="fe lz ma mb mc b">nil</code>，事件将被视为已处理，如果返回值是其他任何值，该值将被发送到链上。</p><p id="a59f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">视图现在可以通过调用我们的修饰符并传递一个处理程序闭包来将自己注册为响应者。</p><h1 id="2a8d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">发送事件</h1><p id="924f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">触发事件要简单得多，我们所需要做的就是从环境中读取<code class="fe lz ma mb mc b">eventClosure</code>并用任何值调用它。</p><p id="757a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单但完整的示例如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e98b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个重要的细节是，对于能够接收事件的响应者，事件的源必须是响应者的直接后代。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/4fcf5e5018d6f12909ee42b17d2b9762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Szqclf1aXWAzrIuNnpTKAw.png"/></div></div></figure><p id="28b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，这意味着我们的响应者通常会在每个特性或屏幕的根节点注册。</p><h1 id="bfd8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">可扩展和可维护</h1><p id="5fb4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在SwiftUI中，从子视图触发事件的一种更常见的方式是将闭包作为参数传递，就像使用<code class="fe lz ma mb mc b">Button</code>一样。当负责调用闭包的视图在视图层次结构中变得更深时，这个闭包必须由多个中间视图<em class="lv">携带</em>。</p><p id="288b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的方法更具有<strong class="ky ir">可维护性</strong>，因为只有响应者和触发器视图需要知道事件。这意味着我们的层次结构可以被修改，而不必通过多个层次“携带”这个闭包。</p><p id="e568" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">得益于此，我们的方法也是<strong class="ky ir">可扩展的</strong>，创建一个事件就像定义一个新类型一样简单。不需要为每个事件添加新的环境值。</p><h1 id="e79a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">创建一个框架</h1><p id="10c0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">按照这个模式，我创建了框架<a class="ae kv" href="https://github.com/EmilioPelaez/HierarchyResponder" rel="noopener ugc nofollow" target="_blank"> HierarchyResponder </a>，用于处理事件和错误。</p><p id="2301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该框架采用了这一概念，并通过添加特定的修饰符来接收、处理或转换事件或错误，以及捕捉错误，从而扩展了这一概念。</p><ol class=""><li id="ca82" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">通过接收事件或错误，您可以决定是否处理该事件。</li><li id="f512" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">处理事件或错误意味着它将被消费，没有其他选择。</li><li id="be05" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">转换修饰符允许您用不同的值替换接收到的事件或错误。</li></ol><p id="64d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个特性是每个修改器都有一个带有<code class="fe lz ma mb mc b">Type</code>参数的通用版本，它会自动过滤任何与你提供的类型不匹配的值。</p></div></div>    
</body>
</html>