<html>
<head>
<title>6 Killer Features From Remix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混音版的6个黑仔特色</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-killer-features-from-remix-3d7e01b0789e?source=collection_archive---------0-----------------------#2021-12-27">https://betterprogramming.pub/6-killer-features-from-remix-3d7e01b0789e?source=collection_archive---------0-----------------------#2021-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4630" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改变游戏规则的全栈JavaScript框架的主要亮点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1bb4c0ac468f618fd38597e7638e92de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7i76-AVGjDZkjqriy5mFUw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">remix.run的标题</p></figure><p id="e50a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React web生态系统从未如此之好。2021年，我们看到了Next.js 12版本的大发布。它带来了令人敬畏的功能，如基于SWC Rust的编译器、中间件、对React 18的支持和URL导入。</p><p id="35b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们以为这一年结束了，我们刚刚得到了最新发布的混音。它已经转变为一个免费和开源的全栈框架。他们最近登上了肯特·c·多兹号。他是谁？<code class="fe lu lv lw lx b">React Testing Library</code>的创造者。一个非常棒的测试库，它改变了我们现在测试React组件的方式。从那以后，他用混音版重写了他的整个博客。</p><p id="c538" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">突然之间，选择一个框架变得更加困难。不过这并不是坏消息，在开始新项目时，我们还有另一个很棒的全栈框架可以考虑。</p><p id="52d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看到使这个框架如此神奇的特性，以及为什么您应该在您的下一个项目中考虑它。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="fe65" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.易于安装</h1><p id="b6e2" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">一个框架应该总是易于安装和开始。这促进了它的采用。Remix确实选中了那个框。</p><p id="5e71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有一个直观的设置，我们所要做的就是运行下面的命令</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="2a82" class="ng mg it lx b gy nh ni l nj nk"><strong class="lx iu">npx create-remix@latest</strong></span></pre><p id="66f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们必须回答两个问题。第一个是关于我们希望在哪里托管我们的应用程序:应用程序:Remix App Server、Express Server、AWS Lambda、Fly.io、Netlify、Vercel或Cloudflare Pages。我们可以很容易地改变这一点。</p><p id="df23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们必须定义我们的项目是基于JavaScript还是基于Typescript。</p><p id="c687" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">瞧，就这样我们都准备好了。不到一分钟，我们都准备好了。</p><p id="7d0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行我们的项目非常容易。我们可以使用很多yarn/npm任务。让我们看看如何直接进入开发模式:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="ca5c" class="ng mg it lx b gy nh ni l nj nk">// after setup<br/>cd [whatever you named the project]<br/><strong class="lx iu">npm install<br/>npm run dev</strong></span></pre><p id="dbc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，我们仍然可以进行手动安装。我们只需要安装依赖项并添加几个配置文件。这不太方便，但可行。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="b158" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.渐进增强</h1><p id="91a6" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">JavaScript使我们能够构建更快、更高效的网站。它使<strong class="la iu">S</strong>single<strong class="la iu">P</strong>age<strong class="la iu">A</strong>应用范例成为可能。但是，JavaScript仍然可以被禁用。通常这会破坏整页。再混合就不会这样了。唯一的副作用将是交互体验降级。它是如何实现的？主要依靠默认的内置浏览器语言，如表单和链接。</p><p id="296e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要以一种特定的方式来构建我们的应用程序以获得渐进增强的支持吗？是的，我们将不得不接受固执己见的混合方法。</p><p id="0857" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Remix框架尽可能地利用服务器的计算能力。默认的重新混合行为是执行服务器端渲染。因此，当JavaScript不可用时，我们的用户不会看到空白页面。他们将获得相同的HTML页面，但与原始的HTML体验。页面不会被水合，因为没有JavaScript将被执行。</p><p id="74ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像表单和路由这样的交互特性会发生什么？当JavaScript可用时，它通过阻止默认浏览器行为来增强特性。当它被禁用时，将使用浏览器原始行为。我们将在表单、路由和数据加载特性中看到更多细节。</p><p id="77cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得JavaScript不仅仅是一个需求，而是一个特性。禁用它只会降低用户体验。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="ef05" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.数据加载</h1><p id="20a4" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这是一个很好的特性。通常我们做的是加载路线，然后在一个<code class="fe lu lv lw lx b">useEffect(..., [])</code>钩子上加载数据。重新混合的方法是不同的。相反，它会在根页面模块上寻找一个导出的<code class="fe lu lv lw lx b">loader</code>函数。如果可用，它将在服务器上执行，并将结果传递给浏览器。</p><p id="acc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以从任何地方获取数据:JSON、API、数据库……我们可以访问路径参数。怎么会？它们可以作为<code class="fe lu lv lw lx b">loader</code>函数的一个参数。</p><p id="ee6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何使这些类型安全呢？params对象是<code class="fe lu lv lw lx b">string</code>和<code class="fe lu lv lw lx b">string | undefined</code>联合的键值。我们只需要断言参数不为空。为此，我们可以使用<code class="fe lu lv lw lx b">tiny-invariant</code>库:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="50d7" class="ng mg it lx b gy nh ni l nj nk">import invariant from "tiny-invariant";</span><span id="dd2a" class="ng mg it lx b gy nl ni l nj nk">export const Loader: LoaderFunction = async ({params}) =&gt; {<br/>  ...<br/>  // ✅ if param is absent we will thrown an error<br/>  <strong class="lx iu">invariant</strong>(params.id, "Expected id Parameter");<br/>  ...<br/>}</span></pre><p id="8369" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个完整的例子，一个<code class="fe lu lv lw lx b">/posts/${id}</code>页面的示例<code class="fe lu lv lw lx b">loader</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d596" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们向客户端公开了数据。在那里我们如何能接近它？通过提供的自定义挂钩:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="d3d5" class="ng mg it lx b gy nh ni l nj nk">import { useLoaderData } from "remix";</span><span id="c1bc" class="ng mg it lx b gy nl ni l nj nk">export default function PostDetails() {<br/>    let post = <strong class="lx iu">useLoaderData</strong>();<br/>...<br/>}</span></pre><p id="223e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Remix框架提供了我们需要的一切，以提供闪电般的用户数据加载体验。</p><p id="285a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据什么时候重新加载？Remix框架通过刷新表单提交和其他用例的加载器来解决这个问题。我们可以选择退出，用<code class="fe lu lv lw lx b">unstable_shouldReload</code>处理程序自己管理它。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="668c" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.内置表单</h1><p id="6d05" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">这一开始是一个令人震惊的特性。早在JavaScript出现之前，表单就已经存在了，现在，表单的重新组合包含了这种原始的行为。它们只是使用<code class="fe lu lv lw lx b">action</code>方法重定向到一个动作的<code class="fe lu lv lw lx b">POST</code>请求，或者在不存在时使用相同的路由。</p><p id="545d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当JavaScript启用时，表单提交将使用<code class="fe lu lv lw lx b">event.preventDefault()</code>禁用，所有事情都将通过AJAX发生。表单将在服务器上进行序列化和处理。然后，数据将返回给客户端。我们也可以执行类似于<code class="fe lu lv lw lx b">redirect</code>的操作。</p><p id="60d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的表单验证都将在服务器上处理。在Remix中，如果有任何错误，最好返回一个<code class="fe lu lv lw lx b">errors</code>键值对象。</p><p id="db00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">混音将如何处理提交后的表单？我们需要在表单<code class="fe lu lv lw lx b">root</code>页面上公开一个<code class="fe lu lv lw lx b">action</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="916f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上是我们在服务器端处理表单提交所需做的全部工作。我们在客户端有什么API？</p><ul class=""><li id="eea6" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useSubmit</code>:返回以编程方式提交表单的函数。</li><li id="16cf" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useTransition</code>:它告诉我们关于表单提交状态需要知道的一切。我们可以显示加载状态，禁用表单提交，乐观更新…等等。</li><li id="45a1" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useFormAction</code>:使用React路由器的相对路径解析<code class="fe lu lv lw lx b">&lt;form action&gt;</code>的名称。</li><li id="49b3" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useActionData</code>:返回提交表单的数据。这是将错误从服务器传回web客户端的首选方式。</li></ul><p id="82c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当JavaScript被禁用时，表单以传统方式提交。浏览器知道如何序列化和发送表单。表单将继续执行，并且<code class="fe lu lv lw lx b">action</code>仍将在提交时执行。显然，上面的JavaScript APIs不会在客户端运行。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f599" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.内置路由</h1><p id="5509" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">就像Next.js一样，Remix框架有一种固执己见的路由方式。它允许嵌套路由。然而，Remix是建立在<code class="fe lu lv lw lx b">React Router v6</code>之上的。它是最流行的React路由器库之一，我们可以通过remix访问它们的API和组件。</p><p id="377a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着我们可以使用我们最喜欢的react-router V6 API:</p><ul class=""><li id="e686" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">Outlet</code>:嵌套页面的占位符。</li><li id="d72b" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useLocation</code>:返回当前位置对象。</li><li id="743b" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useNavigate</code>:返回以编程方式导航的函数。</li><li id="6c51" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useParams</code>:返回URL参数和路由路径URL的匹配项。</li><li id="2d95" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">useResolvedPath</code>:返回解析后的URL路径。</li></ul><p id="939e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">路由将预加载所有嵌套的路由，并并行传递这些路由。这可能会导致初始负载稍长，但交互时间会更短。</p><p id="3dc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看下面标题中的网络选项卡。我们可以看到Remix是如何并行加载所有嵌套路由的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/fbabb4f093b2955368401901a9a6f3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZVe4AFuMWuUVyyifc_gcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何加载资产</p></figure><p id="47e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于路由的一个很酷的特性是它将依赖于HTML导航。这意味着我们不需要JavaScript来让它正常工作。当JavaScript存在时，路由系统将工作得最好。必须喜欢表单功能，它只会在JavaScript可用时增强其行为。</p><p id="b1bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">混合路由支持路由范围内的元配置。我们所要做的就是在模块页面中导出一个<code class="fe lu lv lw lx b">meta</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="c2c9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">6.快速发展</h1><p id="ef02" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">Remix框架不再使用Webpack了。相反，它依赖于esbuild。这使得它超级快速。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5a30b12c9ca1c2c6753c346e6e6a471e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jngnSTQkaH5BWSNoKYhOTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自esbuild.github.io的标题</p></figure><p id="b0e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它目前支持以下功能:</p><ul class=""><li id="9dbd" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">ES6和CommonJS模块</li><li id="d7aa" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">ES6模块的树抖动</li><li id="d37d" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">类型脚本和JSX语法</li><li id="6e38" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">源地图</li><li id="ea06" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">缩小</li><li id="6877" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">插件</li></ul><p id="255e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个生成器是用Go编程语言构建的，主要由Ewan Wallace维护。可惜还没到<code class="fe lu lv lw lx b">1.0.0</code>。因此，我们可以预期这里和那里会有一些错误和问题。然而，现在离阿尔法阶段还很远。我们可以认为这是一个测试阶段。</p><p id="4ce5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我个人认为Next.js选择的构建器更加稳定和成熟。只有时间能证明这是否值得。我的手表模式出现了一些小故障，我希望能尽快修复🤞。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="6b56" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">包裹</h1><p id="b41c" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">起初，我不愿意尝试混音。当Next.js如此之好的时候，我不明白我为什么要费心去尝试它。起初，我不喜欢必须记住它所有的惯例。一切都连接好了，我们所要做的就是用正确的名称在正确的位置导出特性。</p><p id="be97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在摆弄了一段时间后，我越来越喜欢它了。这是一种不同于我们传统的构建web应用程序的方法，需要一些时间来适应。</p><p id="5981" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我只提到了它的一些关键特性，但它还有更多。例如，它的文件是杰出的。它很直观，也很有趣。毫无疑问，这是载人飞船的必备装备。</p><p id="3db3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我必须说我被迷住了。当我在2022年为我的下一个项目选择一个框架时，这个框架将会出现在我的顶层列表中。</p><p id="05db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。</p><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-vs-remix-analyzing-key-aspects-and-differences-8674beaba695"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">Next.js vs. Remix:分析关键方面和差异</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">通过比较Remix和Next.js的最新版本，知道哪一个适合你</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/5-new-killer-features-of-next-js-12-dfd1d766b539"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">Next.js 12的5个新黑仔功能</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">改变游戏规则的版本的主要亮点</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">better编程. pub</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div></div></div>    
</body>
</html>