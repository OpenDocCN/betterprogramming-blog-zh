<html>
<head>
<title>Understanding Higher-Order Functions With Simple Examples in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的简单例子理解高阶函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-higher-order-functions-with-simple-examples-in-python-51dcafe9903?source=collection_archive---------6-----------------------#2021-01-19">https://betterprogramming.pub/understanding-higher-order-functions-with-simple-examples-in-python-51dcafe9903?source=collection_archive---------6-----------------------#2021-01-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a09c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">掌握映射、过滤和减少功能</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/1dc1e22766c895194651f43b276b9909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jDAPtyXuogWJQtXQ6zrxw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/@ady-april-386980?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">紫琳于4月</a>日在<a class="ae kz" href="https://www.pexels.com/photo/man-jumping-over-white-fence-1030794/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄。</p></figure><p id="e96a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">高阶函数是将函数作为参数和/或返回函数作为输出的函数。</p><p id="face" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一些有用的高阶函数有<code class="fe lw lx ly lz b">map()</code>、<code class="fe lw lx ly lz b">filter()</code>和<code class="fe lw lx ly lz b">reduce()</code>。<code class="fe lw lx ly lz b">map()</code>和<code class="fe lw lx ly lz b">filter()</code>是内置函数，而<code class="fe lw lx ly lz b">reduce()</code>包含在<code class="fe lw lx ly lz b">functools()</code>模块中。</p><p id="b290" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来学习一下本文中的<code class="fe lw lx ly lz b">map()</code>、<code class="fe lw lx ly lz b">filter()</code>、<code class="fe lw lx ly lz b">reduce()</code>。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="669f" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">地图()</h1><p id="c78b" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe lw lx ly lz b">map()</code>用于将一个函数同时应用到iterable中的每一项。<br/> <code class="fe lw lx ly lz b">map()</code>将返回一个迭代器的映射对象:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="8ece" class="ni mi iu lz b gz nj nk l nl nm">map(function,iterable…)</span></pre><p id="dbc1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">计算iterable中所有数字的平方:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure><ul class=""><li id="b310" class="np nq iu lc b ld le lg lh lj nr ln ns lr nt lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">square=map(lambda x:x*2, num)</code>:我们可以通过<code class="fe lw lx ly lz b">lambda</code>函数或者<code class="fe lw lx ly lz b">user_defined</code>函数。<code class="fe lw lx ly lz b">lambda</code>函数的语法是<strong class="lc iv"> </strong> <code class="fe lw lx ly lz b">lambda <em class="ny">parameters</em> : <em class="ny">expression</em></code>。</li><li id="d02e" class="np nq iu lc b ld nz lg oa lj ob ln oc lr od lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">map()</code>返回一个迭代器的映射对象。我们可以使用列表构造函数(<code class="fe lw lx ly lz b">print(list(square))</code>)将迭代器(map对象)转换成类似<code class="fe lw lx ly lz b">list</code>的可迭代对象。</li></ul><h2 id="e030" class="ni mi iu bd mj oe of dn mn og oh dp mr lj oi oj mt ln ok ol mv lr om on mx oo bi translated">map与for循环</h2><p id="98d0" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">使用<code class="fe lw lx ly lz b">for</code>循环解决相同的问题(数字的平方):</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="56c7" class="ni mi iu lz b gz nj nk l nl nm">num=[1,2,3,4,5]<br/>square=[]<br/><strong class="lz iv">for </strong>i <strong class="lz iv">in </strong>num:<br/>    square.append(i*2)<br/>print (square)</span></pre><ul class=""><li id="feee" class="np nq iu lc b ld le lg lh lj nr ln ns lr nt lv nu nv nw nx bi translated">我们必须使用一个<code class="fe lw lx ly lz b">for</code>循环遍历iterable ( <code class="fe lw lx ly lz b">list</code>)并将结果追加到一个新列表中。</li><li id="1a4b" class="np nq iu lc b ld nz lg oa lj ob ln oc lr od lv nu nv nw nx bi translated">顺序遍历:我们要遍历一个iterable(长度<em class="ny"> n </em> ) <em class="ny"> n </em>次。</li></ul><h2 id="2aea" class="ni mi iu bd mj oe of dn mn og oh dp mr lj oi oj mt ln ok ol mv lr om on mx oo bi translated">地图与列表理解</h2><p id="11a6" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">使用列表理解解决相同的问题(数字的平方):</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="a5f4" class="ni mi iu lz b gz nj nk l nl nm">num=[1,2,3,4,5]<br/>result=[i**2 <strong class="lz iv">for </strong>i <strong class="lz iv">in </strong>num]<br/>print (result)<br/><em class="ny">#Output:[1, 4, 9, 16, 25]</em></span></pre><p id="1986" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">列表理解将返回一个列表而不是迭代器，而<code class="fe lw lx ly lz b">map()</code>将返回一个迭代器的map对象。</p><p id="2e99" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们知道迭代器可以创建需要很少内存的按需序列，而链表需要更多内存来存储数据。如果你正在处理大量的数据，列表理解是没有用的。<code class="fe lw lx ly lz b">map()</code>可用于返回一个map对象，它是一个迭代器，并根据需要计算值，不需要一次具体化所有的值。</p><h2 id="339f" class="ni mi iu bd mj oe of dn mn og oh dp mr lj oi oj mt ln ok ol mv lr om on mx oo bi translated">映射与生成器表达式</h2><p id="e48a" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">与列表理解相比，当我们处理大量数据时，会使用生成器表达式。生成器表达式返回迭代器。</p><p id="754f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用生成器带来的性能提升是延迟(按需)值生成的结果，这意味着更低的内存使用率。</p><p id="7d85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">计算iterable中所有数字的平方:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure><h2 id="b05d" class="ni mi iu bd mj oe of dn mn og oh dp mr lj oi oj mt ln ok ol mv lr om on mx oo bi translated">什么时候我们应该选择map()而不是生成器表达式？</h2><p id="c538" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe lw lx ly lz b">map()</code>和生成器表达式都只返回一个迭代器。</p><ul class=""><li id="0b9a" class="np nq iu lc b ld le lg lh lj nr ln ns lr nt lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">map</code>语法:<code class="fe lw lx ly lz b">map(function,iterable)</code></li><li id="9bc6" class="np nq iu lc b ld nz lg oa lj ob ln oc lr od lv nu nv nw nx bi translated">生成器表达式语法:<code class="fe lw lx ly lz b">(expression for item in iterable if conditional)</code></li></ul><p id="fadb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当列表理解/生成器表达式的逻辑太复杂而无法理解时，最好使用<code class="fe lw lx ly lz b">map()</code>。</p><p id="8260" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe lw lx ly lz b">map()</code>函数中，我们把函数分开，这样设计的非常清晰。</p><p id="5815" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">map()</code>和生成器表达式的另一个区别在于<code class="fe lw lx ly lz b">map()</code>函数。我们可以重用一个<code class="fe lw lx ly lz b">lambda</code>或函数定义。</p><h2 id="74f2" class="ni mi iu bd mj oe of dn mn og oh dp mr lj oi oj mt ln ok ol mv lr om on mx oo bi translated"><strong class="ak">地图()vs星图()</strong></h2><p id="b905" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">使用<code class="fe lw lx ly lz b">map()</code>将函数应用于两个可迭代对象:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="1b94" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据<a class="ae kz" href="https://docs.python.org/3/library/itertools.html#itertools.starmap" rel="noopener ugc nofollow" target="_blank"> Python文档</a>，<code class="fe lw lx ly lz b">starmap()</code>是“当实参参数已经从单个iterable分组到元组中时使用的，而不是<code class="fe lw lx ly lz b"><a class="ae kz" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank">map()</a></code>(数据已经被‘预压缩’)”</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/857c03a7b8c971dfaa99c71f9ca42d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9QBmxLNIZ8UQfCjeHt3WQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">地图vs .星图()。作者照片。</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="6783" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">过滤器()</h1><p id="23a1" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe lw lx ly lz b">filter()</code>用于从符合特定条件的iterable中过滤元素:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="d776" class="ni mi iu lz b gz nj nk l nl nm">filter(function,iterable)</span></pre><p id="4d18" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">过滤iterable中的偶数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="4f59" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">filter()</code>也返回一个迭代器的过滤器对象。它不会立即检查所有的元素，但会在我们请求时返回下一个值<br/>(使用<code class="fe lw lx ly lz b">next()</code>):</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure><p id="2756" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们想一次得到所有结果，我们可以使用<code class="fe lw lx ly lz b">list()</code>构造函数将其转换成一个列表。</p><h2 id="aeda" class="ni mi iu bd mj oe of dn mn og oh dp mr lj oi oj mt ln ok ol mv lr om on mx oo bi translated">filter()与filterfalse()</h2><blockquote class="oq"><p id="7271" class="or os iu bd ot ou ov ow ox oy oz lv dk translated">"创建一个迭代器，从iterable中过滤元素，只返回那些谓词为假的元素."— <a class="ae kz" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a></p></blockquote><pre class="pa pb pc pd pe ne lz nf ng aw nh bi"><span id="d639" class="ni mi iu lz b gz nj nk l nl nm">filterfalse(predicate,iterable)</span></pre><p id="1bea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">过滤不以<code class="fe lw lx ly lz b">“r”</code>开头的元素:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="5c42" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">减少()</h1><p id="1eb2" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe lw lx ly lz b">functools</code>模块提供以下功能:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="199b" class="ni mi iu lz b gz nj nk l nl nm">functools.reduce()</span></pre><p id="ff83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从左到右将两个参数的函数累积应用于iterable的项，以便将iterable缩减为单个值:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="8c1a" class="ni mi iu lz b gz nj nk l nl nm">functools.reduce(function, iterable)</span></pre><p id="adba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python提供了一些内置的归约函数:</p><ul class=""><li id="3315" class="np nq iu lc b ld le lg lh lj nr ln ns lr nt lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">max()</code>返回iterable中的最大值。</li><li id="2db9" class="np nq iu lc b ld nz lg oa lj ob ln oc lr od lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">min()</code>返回iterable中的最小数字。</li><li id="2a86" class="np nq iu lc b ld nz lg oa lj ob ln oc lr od lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">sum()</code>返回一个iterable中所有数字的和。</li></ul><p id="d83c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">查找列表中所有元素的乘积:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="efad" class="ni mi iu lz b gz nj nk l nl nm"><strong class="lz iv">from </strong>functools <strong class="lz iv">import </strong>reduce<br/>num1=[1,2,3,4,5]<br/>num2=reduce(<strong class="lz iv">lambda </strong>x,y:x*y,num1)<br/>print (num2)<em class="ny">#Output:120</em></span></pre><h2 id="8d56" class="ni mi iu bd mj oe of dn mn og oh dp mr lj oi oj mt ln ok ol mv lr om on mx oo bi translated">减少()与累积()</h2><blockquote class="oq"><p id="b9e8" class="or os iu bd ot ou ov ow ox oy oz lv dk translated">创建一个迭代器，返回累加和或其他二元函数的累加结果(通过可选的func参数指定)— <a class="ae kz" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a></p></blockquote><pre class="pa pb pc pd pe ne lz nf ng aw nh bi"><span id="21d8" class="ni mi iu lz b gz nj nk l nl nm">itertools.accumulate(iterable.function)</span></pre><p id="5e9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">求一个迭代式中数的乘积，求累计值:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pf"><img src="../Images/93695f3f1a4ca515e93b9eb9703c7e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cycIte80wUrYp1jLktOpUQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">减少()与累积()</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nn no l"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="10bf" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">关键要点</h1><ul class=""><li id="c551" class="np nq iu lc b ld mz lg na lj pg ln ph lr pi lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">map()</code>:对iterable中的每个元素应用函数(<code class="fe lw lx ly lz b">map(function,iterable)</code>)。</li><li id="c37e" class="np nq iu lc b ld nz lg oa lj ob ln oc lr od lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">filter()</code>:过滤iterable中符合一定条件<br/> <code class="fe lw lx ly lz b">(filter(function,iterable)</code>的元素。</li><li id="96a6" class="np nq iu lc b ld nz lg oa lj ob ln oc lr od lv nu nv nw nx bi translated"><code class="fe lw lx ly lz b">reduce()</code>:获取iterable中的连续元素，并以某种方式组合它们(<code class="fe lw lx ly lz b">reduce(function,iterable)</code>)。</li></ul></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><p id="538e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="ny">关注此空间，了解更多关于Python和数据科学的文章。如果你喜欢多看我的教程，就关注我的</em> <a class="ae kz" href="https://medium.com/@IndhumathyChelliah" rel="noopener"> <strong class="lc iv"> <em class="ny">中</em></strong></a><a class="ae kz" href="https://www.linkedin.com/in/indhumathy-chelliah/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv"><em class="ny">LinkedIn</em></strong></a><strong class="lc iv"><em class="ny"/></strong><a class="ae kz" href="https://twitter.com/IndhuChelliah" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv"><em class="ny">推特</em> </strong> </a> <strong class="lc iv"> <em class="ny">。</em> </strong></p><p id="46eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="ny">点击这里成为中等会员:</em><a class="ae kz" href="https://indhumathychelliah.medium.com/membership" rel="noopener"><em class="ny">https://indhumathychelliah.medium.com/membership</em></a></p></div></div>    
</body>
</html>