<html>
<head>
<title>Build Your First Neural Network From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始建立你的第一个神经网络</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-first-neural-network-from-scratch-c5d5490a3f76?source=collection_archive---------4-----------------------#2020-11-25">https://betterprogramming.pub/build-your-first-neural-network-from-scratch-c5d5490a3f76?source=collection_archive---------4-----------------------#2020-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们教AI做一些简单的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/934214122e6d76abd8763834fe4e3a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1si9yFDJor7-uIAVmqXfPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/ahmedgad-9403351/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3501528" rel="noopener ugc nofollow" target="_blank">艾哈迈德·加德</a>从<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3501528" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="0f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直想玩神经网络很长一段时间，最后我发现了一个机会的窗口，可以在神经网络周围乱搞。它离天网相当远，我不认为我完全掌握了这背后的数学，但我们先教AI做一些简单的事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="168f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码背后的理论</h1><p id="6878" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">神经网络并不是一个新概念。它们是由沃伦麦卡洛克和沃尔特皮茨在1943年首次提出的。</p><p id="0ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将建立一个没有隐藏层或感知器的单层神经网络。它将由一个包含训练示例、突触或权重以及神经元的输入层和一个包含正确答案的输出层组成。这是神经网络的图示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ad9afa4dd08a8a7ab0987e992d141415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*aijXBMQIF29TMuWaCQzCkw.png"/></div></figure><p id="7c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要了解一些数学概念，如sigmoid和导数，以了解神经元如何学习。但是神经元所做的仅仅是取一个输入值，乘以突触权重。然后，我们对所有这些乘法求和，并使用sigmoid函数来获得0到1范围内的输出。</p><p id="2bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神经元表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/45ea7d1e61238f655a5802f16bf362e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*L6IcAYqhvrpIE00YRv7PjA.png"/></div></div></figure><p id="f605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sigmoid函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/d41f7e3948cf1bfadfdb42d651b771dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*LA7L91D3R0IePUzuhcE7Dw.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="183f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题定义</h1><p id="7adb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们在输入层有一系列的数字。我们希望神经网络在输入数据集样本的第一个数字为1时返回1，在第一个数字为0时返回0。这表现在输出层。这是问题集的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fd5d2cbb9872131921ac7b6c468a0764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*0jOLwzsE2HVuamEM7kHLIg.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f34e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="06e9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望我们发展一些概念上的理解，我们可以开始编码。</p><p id="ea75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Python和<a class="ae ky" href="https://numpy.org/doc/stable/" rel="noopener ugc nofollow" target="_blank"> NumPY </a>库。</p><p id="242d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPY安装:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="61a4" class="ni md it ne b gy nj nk l nl nm"><em class="nn">pip install numpy</em></span></pre><p id="c6d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果安装成功，我们就可以进入编码部分了。首先，我们需要做的是将NumPy导入Python文件:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="a68b" class="ni md it ne b gy nj nk l nl nm"><em class="nn">import numpy as np</em></span></pre><p id="42d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备好描述和训练我们的神经网络。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e89d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">培养</h1><p id="63ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们创建一个sigmoid函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e23427e93bb1e1b4800e0499c9d8e21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*ThsDgJBeSfFOMPN6PMttmw.png"/></div></figure><p id="f7e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将定义训练示例、输入(在一个4x 5的矩阵中)和输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/9ac0984cedfbbfd355e60efeaa7cce53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNtJsOH-Y5gwgQS-wc4YLQ.png"/></div></div></figure><p id="162c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要通过生成随机值来初始化突触权重，并将它们放入一个4乘1的矩阵中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c51fe42877aae7fe6542fcf94b79155e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*c-x7Bo6DrapTvWRHjzsQkw.png"/></div></figure><p id="01c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们开始构建训练模型。我们将使用一个<code class="fe nr ns nt ne b">for</code> <strong class="lb iu"> </strong>循环，所有的训练都将发生在这个循环内部。我们将调用sigmoid函数，并传递所有输入的总和乘以sigmoid权重。<code class="fe nr ns nt ne b">Np.dot</code> <strong class="lb iu"> </strong>会给我们做矩阵乘法。以下是我们所掌握的情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a018eef9ed9bc8e4017cf3e45e1bcc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*dWV2584-vy4F6xH3a8MjkA.png"/></div></figure><p id="a86c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的输出是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fff2e87eef13bc8632045368ffaae3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*HeXRHWTZvwx4hrG40WZ4mQ.png"/></div></figure><p id="1c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备好进行训练了。我们将通过计算sigmoid函数的输出和实际输出之差来实现。然后我们可以根据错误的严重程度来调整我们的权重。我们要重复几次，比如说一万次。</p><p id="233c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义sigmoid导数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f4261cbb850e2e0c738cf4331feaef5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*gAuT4vQFdJUP-olni2sLDg.png"/></div></div></figure><p id="13a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们计算和调整权重的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/44b5c5fd09a28abb789243d1ec2a64a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*th61BPrBpvCoc4Hk6smA1w.png"/></div></figure><p id="d08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始学习，看看学习过程的长短会如何影响结果。我们将从100次迭代开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2f085a7f4a5c85c6203040b9c74fe18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*0VdhMulogv_oNLcs-1lK4A.png"/></div></figure><p id="93f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于开始来说还不错——我们的人工智能学会了如何识别模式，但错误的百分比仍然很高。现在让我们做1000次迭代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a72eca0f6b807c39c413072d6cb97ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*0H__Y-GZrPgZsTd0RvHMdA.png"/></div></figure><p id="b62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了，但是让我们继续做10，000次迭代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/39b90a70beb374c52d2a700f709f9f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*p1aNmaLAqYCBfQmUDQPlWg.png"/></div></figure><p id="9740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后100，000次迭代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/7f3be4f8f60850cc0f81128b5a5bc454.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*KjczZ6xxdpS9HcGrMdStsg.png"/></div></figure><p id="c020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以跟上增加更多的学习迭代，但我们永远不会达到100%的准确性，因为那将需要无限量的计算。但即使在最坏的情况下，我们也有99.77%的可能准确率，这已经很不错了。</p><p id="a664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于最后的代码，我已经把它做得很漂亮，并按功能分开。我还添加了一个非常复杂的方法，将权重存储在文本文件中。这使得我们可以一次性完成学习过程，当我们需要使用我们的人工智能时，我们可以只导入权重并使用sigmoid函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9306" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="34fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们的第一个人工智能已经可以生产了。即使它只能在非常小的数据集上识别非常简单的模式，现在我们可以扩展它，例如，尝试教人工智能识别图片中的东西。我将在下一篇文章中讨论进一步的发展。</p><p id="17ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不断学习，不断成长！</p></div></div>    
</body>
</html>