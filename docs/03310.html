<html>
<head>
<title>Static Properties, Abstract Classes, and Constructor Functions in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的静态属性、抽象类和构造函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-typescript-classes-static-properties-abstract-classes-and-more-869f1eaa4835?source=collection_archive---------10-----------------------#2020-02-03">https://betterprogramming.pub/introduction-to-typescript-classes-static-properties-abstract-classes-and-more-869f1eaa4835?source=collection_archive---------10-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6cf8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在TypeScript中改进您的类</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8995773065518e1d2e0bc271e32f62f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qi6NQ5EyzSY40jahpcFWKw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wocintechchat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae ky" href="https://unsplash.com/s/photos/employee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与JavaScript一样，TypeScript中的类是其原型继承模型的一种特殊语法，这是基于类的面向对象语言中的一种类似继承。类只是添加到ES6中的特殊函数，用来模仿其他语言中的关键字<code class="fe lv lw lx ly b">class</code>。</p><p id="137d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以有<code class="fe lv lw lx ly b">class</code>声明和<code class="fe lv lw lx ly b">class</code>表达式，因为它们只是函数。所以像所有其他函数一样，有函数声明和函数表达式。TypeScript也是如此。类充当创建新对象的模板。TypeScript扩展了JavaScript类的语法，然后添加了自己的特色。在本文中，我们将研究静态属性、抽象类和构造函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bcea" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">静态属性</h1><p id="5ba0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用TypeScript，我们可以将成员指定为实例变量(前面没有关键字<code class="fe lv lw lx ly b">static</code>)和静态成员(前面有关键字<code class="fe lv lw lx ly b">static</code>)。</p><p id="2d4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无需实例化类就可以访问静态成员。当然，这是为成员指定的访问修饰符。因此可以从类外部直接访问公共静态成员。私有静态成员只能在类中使用，受保护的成员可以由定义该成员的类访问，也可以由该类的子类访问。</p><p id="d4bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字段和方法都可以使用关键字<code class="fe lv lw lx ly b">static</code>。例如，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="60b5" class="nh mh it ly b gy ni nj l nk nl">class Person {<br/>  static numPeople = 0;  <br/>  constructor(name: string) {<br/>    Person.numPeople++;<br/>  }<br/>  static getNumPeople() {<br/>    return this.numPeople;<br/>  }<br/>}</span><span id="62f1" class="nh mh it ly b gy nm nj l nk nl">const john = new Person('John');<br/>const jane = new Person('Jane');<br/>console.log(Person.numPeople);<br/>console.log(Person.getNumPeople());</span></pre><p id="61a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们每实例化一次<code class="fe lv lw lx ly b">Person</code>类，静态属性<code class="fe lv lw lx ly b">numPeople</code>就加1。由于静态属性由类的所有实例共享，并且不属于任何一个实例，我们可以通过使用<code class="fe lv lw lx ly b">Person.numPeople</code>直接访问<code class="fe lv lw lx ly b">numPeople</code>。</p><p id="0aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们有一个静态方法<code class="fe lv lw lx ly b">getNumPeople</code>，我们可以直接调用，而不需要实例化<code class="fe lv lw lx ly b">Person</code>类。因此，当我们通过使用<code class="fe lv lw lx ly b">Person.numPeople</code>获得<code class="fe lv lw lx ly b">numPeople</code>并调用<code class="fe lv lw lx ly b">Person.getNumPeople()</code>时，两者都返回值2。</p><p id="df59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为成员是静态的，所以值是类的一部分，而不是任何实例的一部分，所以即使实例被销毁，值也会被保留。这与实例变量不同，实例变量是从类内的<code class="fe lv lw lx ly b">this</code>和类外的类实例变量中访问的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0d39" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">抽象类</h1><p id="dfab" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">TypeScript具有抽象类，这些类具有某个类的部分实现，并且可以从其中派生其他类。它们不能被直接实例化。</p><p id="cdca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与接口不同，抽象类可以有其成员的实现细节。要声明一个抽象类，我们可以使用<code class="fe lv lw lx ly b">abstract</code>关键字。我们还可以对方法使用<code class="fe lv lw lx ly b">abstract</code>关键字来声明抽象方法，这些方法由从抽象类派生的类来实现。</p><p id="e44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象方法不包含方法的实现。由从抽象类派生的子类来实现列出的方法。它们还可以选择性地包括访问修饰符。</p><p id="0c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用抽象类和方法，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0750" class="nh mh it ly b gy ni nj l nk nl">abstract class Person {<br/>  name: string;<br/>  age: number;<br/>  constructor(name: string, age: number) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="a435" class="nh mh it ly b gy nm nj l nk nl">  abstract getName(): string;<br/>  abstract getAge(): number;<br/>}</span><span id="45db" class="nh mh it ly b gy nm nj l nk nl">class Employee extends Person{<br/>  constructor(name: string, age: number) {<br/>    super(name, age);<br/>  }</span><span id="cda6" class="nh mh it ly b gy nm nj l nk nl">  getName() {<br/>    return this.name;<br/>  }</span><span id="dfe6" class="nh mh it ly b gy nm nj l nk nl">  getAge() {<br/>    return this.age;<br/>  }<br/>}</span><span id="aca1" class="nh mh it ly b gy nm nj l nk nl">let employee = new Employee('Jane', 20);<br/>console.log(employee.getName());<br/>console.log(employee.getAge());</span></pre><p id="c439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有抽象的<code class="fe lv lw lx ly b">Person</code>类，它有抽象的方法<code class="fe lv lw lx ly b">getName</code>和<code class="fe lv lw lx ly b">getAge</code>。</p><p id="f240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，抽象方法中只有签名。方法的实际实现在<code class="fe lv lw lx ly b">Employee</code>类中，它扩展了<code class="fe lv lw lx ly b">Person</code>类。</p><p id="c5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">Employee</code>类中实际实现了<code class="fe lv lw lx ly b">getName</code>和<code class="fe lv lw lx ly b">getAge</code>方法。</p><p id="69f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript检查方法签名和类的返回类型，因此我们必须实现抽象类中概述的抽象方法。这意味着在上面的例子中，<code class="fe lv lw lx ly b">getName</code>方法必须不带参数，并且必须返回一个字符串。</p><p id="1339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样地，<code class="fe lv lw lx ly b">getAge</code>方法必须不带参数，并且必须返回一个数字。抽象方法实现后，我们可以像调用其他方法一样正常调用它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d95e4a8cabf66250031421c17874bcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aOmJoesHncwfGU3M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米切尔·奥尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3f8c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">构造函数</h1><p id="7ef6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们声明一个类型脚本时，我们同时声明了多个东西。我们声明了该类的一个实例，它是代码以关键字<code class="fe lv lw lx ly b">class</code>开头的实体。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3bd8" class="nh mh it ly b gy ni nj l nk nl">class Employee{<br/>  name: string;<br/>  age: number;<br/>  constructor(name: string, age: number) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="8127" class="nh mh it ly b gy nm nj l nk nl">}<br/>let employee: Employee = new Employee('Jane', 20);</span></pre><p id="20f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面代码片段的最后一行，我们使用<code class="fe lv lw lx ly b">Employee</code>作为类<code class="fe lv lw lx ly b">Employee</code>的实例类型。</p><p id="201e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们正在创建另一个值，我们称之为<em class="no">构造函数。</em>这是在使用<code class="fe lv lw lx ly b">new</code>关键字创建类的新实例时调用的函数。</p><p id="f283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将上面的类型脚本代码编译成ES5或更早的版本，我们可以看到生成了类似下面的代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7624" class="nh mh it ly b gy ni nj l nk nl">"use strict";<br/>var Employee = /** <a class="ae ky" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a> */ (function () {<br/>    function Employee(name, age) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/>    return Employee;<br/>}());<br/>var employee = new Employee('Jane', 20);</span></pre><p id="4d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，构造函数是下面的代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a8a0" class="nh mh it ly b gy ni nj l nk nl">function Employee(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}</span></pre><p id="0985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这样做是因为在JavaScript中，不管我们用的是什么版本，类只是构造函数的语法糖。TypeScript的继承模型只是从JavaScript扩展而来。它没有改变JavaScript的继承模型，因为它应该与现有的JavaScript代码100%兼容，所以可以采用现有的JavaScript代码来使用TypeScript。</p><p id="c522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在TypeScript中，我们可以用<code class="fe lv lw lx ly b">typeof</code>操作符获得构造函数的类型。它不同于它在JavaScript中的用法，因为它被扩展为获取类的构造函数的类型。如果我们运行下面的代码…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3fc6" class="nh mh it ly b gy ni nj l nk nl">class Employee{<br/>  name: string;<br/>  age: number;<br/>  static companyName: string = 'ABC Company';<br/>  constructor(name: string, age: number) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }</span><span id="1ef6" class="nh mh it ly b gy nm nj l nk nl">}</span><span id="92c5" class="nh mh it ly b gy nm nj l nk nl">let employeeConstructor: typeof Employee = Employee;<br/>console.log(Employee.companyName);<br/>console.log(employeeConstructor.companyName);</span></pre><p id="f75b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…当我们获得两个<code class="fe lv lw lx ly b">console.log</code>语句中记录的静态成员<code class="fe lv lw lx ly b">companyName</code>的值时，这是有意义的。从编译后的输出可以看出…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3d0f" class="nh mh it ly b gy ni nj l nk nl">"use strict";<br/>var Employee = /** <a class="ae ky" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a> */ (function () {<br/>    function Employee(name, age) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/>    Employee.companyName = 'ABC Company';<br/>    return Employee;<br/>}());<br/>var employeeConstructor = Employee;<br/>console.log(Employee.companyName);<br/>console.log(employeeConstructor.companyName);</span></pre><p id="9674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript和TypeScript类最终只是函数。类语法使JavaScript的继承更容易使用，因为它看起来像是使用基于类的继承，但它实际上是原型继承模型之上的语法糖，自JavaScript首次问世以来就一直如此。</p><p id="64bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript通过让我们定义抽象类使继承变得容易——其中一些实现由抽象类完成，其他实现在扩展抽象类的子类中完成。</p><p id="4b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也有子类可以实现的抽象方法。抽象方法只有签名和返回类型，没有实现细节。</p><p id="b43c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态成员让我们定义属于类的成员，而不是类的实例。</p><p id="84a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样重要的是要知道，类语法最终是从JavaScript开始就存在的原型继承模型的语法糖。然而，现在我们可以把它放在一边，因为我们可以使用语法糖来使它更容易理解和实现继承。</p></div></div>    
</body>
</html>