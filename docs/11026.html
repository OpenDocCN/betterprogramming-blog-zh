<html>
<head>
<title>A Guide to Working With Forms and Input Fields in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中使用表单和输入字段的指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-guide-to-working-with-forms-and-input-fields-in-react-403d64aaedf3?source=collection_archive---------1-----------------------#2022-02-11">https://betterprogramming.pub/a-guide-to-working-with-forms-and-input-fields-in-react-403d64aaedf3?source=collection_archive---------1-----------------------#2022-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="86bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React中所有受控和非受控组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5cc97f68cd9973a5c78abeda315311e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kek71OKBc7qPvqrc9SXUmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Toy_Story" rel="noopener ugc nofollow" target="_blank">玩具总动员</a></p></figure><p id="b064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解任何框架的基础的最好方法是开发一个CRUD应用程序，每个CRUD应用程序总是有一个带有不同输入字段的表单。在React中使用表单时，您会遇到一些奇怪的术语，如“受控”和“非受控”组件。我写这篇文章的目的是用简单的英语来解释这些花哨的术语。</p><p id="d276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇博文的先决条件是您对HTML表单有基本的了解。如果没有，您可以参考<a class="ae ky" href="https://www.w3schools.com/html/html_forms.asp" rel="noopener ugc nofollow" target="_blank">本</a>快速复习。</p><h1 id="8688" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考文献与DOM</h1><p id="fbbe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">ref</code>是默认情况下出现在所有输入元素上的属性。它们允许我们访问其他DOM元素并使用它们。</p><blockquote class="mw mx my"><p id="67a0" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">Refs提供了一种方法来访问在render方法中创建的DOM节点或React元素。</p><p id="e25f" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">–<a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">reactjs.org</a></p></blockquote><p id="edd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解<code class="fe ms mt mu mv b">ref</code>能做什么，让我们看看表单是如何使用的。如果你有使用React的经验，你会知道<code class="fe ms mt mu mv b">useState</code>是什么，以及它如何处理表单域。对于其他人，让我们考虑这个小例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用<code class="fe ms mt mu mv b">input</code>上的<code class="fe ms mt mu mv b">onChange</code>事件处理程序在每次击键时更新用户名的值，并将其存储在<code class="fe ms mt mu mv b">name</code>变量中。我们使用<code class="fe ms mt mu mv b">value</code>属性将该状态反馈到<code class="fe ms mt mu mv b">input</code>中。然后，我们使用表单的提交处理程序来使用变量值，最后清除输入。这是一个“受控”输入域/组件的完美例子。</p><p id="30ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是管理表单状态的完美方式。但是，当我们只需要表单提交期间的状态时，每次击键都更新状态(即<code class="fe ms mt mu mv b">name</code>)是低效的。</p><p id="0e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<code class="fe ms mt mu mv b">refs</code>发挥作用的地方。</p><h1 id="6d86" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">裁判是如何工作的？</h1><p id="3929" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Refs在DOM中呈现的HTML元素和JavaScript代码之间建立连接。我们通过使用名为–<code class="fe ms mt mu mv b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef()</a></code>的react挂钩来实现这一点</p><p id="32a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旁注:</p><ol class=""><li id="84d4" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">React.createRef</code> <em class="mz">(摘自React 16.3) </em></li><li id="aeab" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">useRef</code>钩子<em class="mz">(摘自React 16.8) </em></li></ol><p id="413e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像所有钩子一样，<code class="fe ms mt mu mv b">useRef()</code>遵循React钩子的所有<a class="ae ky" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则。它有一个默认值，我们可以用它来初始化，但这是可选的。它返回一个值，一旦我们将它连接到一个HTML DOM元素，这个值将允许我们以后使用那个<code class="fe ms mt mu mv b">ref</code>。为了连接，我们将使用一个名为<code class="fe ms mt mu mv b">ref</code>的内置属性/道具，它出现在每个HTML DOM元素上。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="77b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为您可以将<code class="fe ms mt mu mv b">ref</code>连接到任何HTML DOM元素，但这并不意味着您应该这样做。您将主要在表单中使用<code class="fe ms mt mu mv b">ref</code>。</p><p id="bf85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe ms mt mu mv b">nameRef</code>将在它的<code class="fe ms mt mu mv b">current</code>属性中保存一个完整的DOM元素。如果我控制<code class="fe ms mt mu mv b">nameRef.current</code>，我们可以看到我们有了完整的输入原生HTML DOM元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="678e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解，这是它将在案例2中呈现的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/808c66f2449387cee3c4448ec3c80305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGBdwGwS2A73WuR5wkWo4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nu">当前属性保存连接的DOM元素的值</em></p></figure><p id="8b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:他们强烈建议不要强制操作DOM，即不要使用React。当我们使用<code class="fe ms mt mu mv b">useState</code>来操作DOM时，这是很好的，也是做事情的理想方式。<code class="fe ms mt mu mv b">useRef</code>的用例是不同的，不应该成为你操作DOM的首选解决方案，比如从字段重新设置、更新表单字段值等。使用<code class="fe ms mt mu mv b">ref</code>进行只读操作仍然是可以接受的，因为您没有改变任何状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="252e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">何时使用ref？</h1><p id="6dc7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用<code class="fe ms mt mu mv b">ref</code>的理想场合是当你想做只读动作的时候。有时，您会遇到希望读取一个值而不更改它的用例。如果是这种情况，可以避免使用<code class="fe ms mt mu mv b">useState</code>。会造成很多多余的代码。</p><p id="408c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://reactjs.org/docs/refs-and-the-dom.html#when-to-use-refs" rel="noopener ugc nofollow" target="_blank">官方文件</a>，参考的几个好用例:</p><ul class=""><li id="6084" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated">管理焦点、文本选择或媒体播放。</li><li id="e8e7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">触发命令式动画——其中命令式动画意味着使用JavaScript 定义<a class="ae ky" href="https://anvaka.github.io/sj/compare/" rel="noopener ugc nofollow" target="_blank">动画</a></li><li id="9c5c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nv nl nm nn bi translated">与第三方DOM库集成。</li></ul><p id="6a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避免对任何可以声明完成的事情使用refs。</p><h1 id="665a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ref的一个用例</h1><p id="328c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">考虑一个用例，当表单提交过程中出现错误时，您希望将焦点放在输入DOM元素上。我们可以使用<code class="fe ms mt mu mv b">ref</code>来做到这一点</p><p id="cd05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，如果用户试图提交一个没有输入的表单，这将是一个无效的提交动作，并且该表单将获得焦点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/aad0a304d633e2db990b24ce797fd47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jlwRPl2eR27NwY0c0jVtYQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nu">名称输入获得无效表单提交的焦点</em></p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="42ee" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用带有功能组件的ref</h1><p id="ed94" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">是的，每个HTML DOM元素都有一个<code class="fe ms mt mu mv b">ref</code>道具，你可以用它来定位。但是您不能在React功能组件上使用<code class="fe ms mt mu mv b">ref</code>。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="46da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是React的维护者真的很体贴。您可以使用另一个挂钩将<code class="fe ms mt mu mv b">ref</code>与功能组件配合使用。这个钩子有助于强制性地使用功能组件，也就是说，不是通过props传递一些状态给它，而是从父组件调用一个函数来改变组件内部的一些东西。这很像React中的父子关系管理。</p><p id="caca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你不应该经常做的事情。在这里展示是因为我的工作是在我真正的读者面前展示所有的武器，因为我不想让他们装备不良就去打仗(也就是工作)。</p><p id="83d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个用例，您希望以编程方式将焦点从呈现子元素的父组件转移到input元素。我将在<code class="fe ms mt mu mv b">Age</code>功能组件中添加两个自定义功能<code class="fe ms mt mu mv b">focusAgeInputField</code>和<code class="fe ms mt mu mv b">isAgeValid</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="eae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们试图做的是强制性地访问组件或组件内部的功能，这就是我们使用<code class="fe ms mt mu mv b">useImperativeHandle</code>钩子的地方。你可以通过Anik的这篇详细文章了解更多。</p><p id="239e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据官方文件:</p><blockquote class="mw mx my"><p id="9cdc" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated"><code class="fe ms mt mu mv b"><strong class="lb iu">useImperativeHandle</strong></code>定制使用<code class="fe ms mt mu mv b">ref</code>时暴露给父组件的实例值。和往常一样，在大多数情况下应该避免使用引用的命令式代码。<code class="fe ms mt mu mv b"><strong class="lb iu">useImperativeHandle</strong></code>应与<code class="fe ms mt mu mv b"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#reactforwardref" rel="noopener ugc nofollow" target="_blank">forwardRef</a></code>配合使用:</p><p id="96d3" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">–<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank">reactjs.org</a></p></blockquote><p id="5246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe ms mt mu mv b">useImperativeHandle</code>时，你完全意识到你想要控制输入不是通过状态属性管理，不是通过从父组件控制组件的状态，而是通过编程直接调用或操作组件中的某些东西。这既不建议，也不推荐，但你无论如何要知道！</p><h1 id="5bb6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用useImperativeHandle</h1><p id="fda3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">useImperativeHandle</code>钩子接受两个参数:</p><ul class=""><li id="35eb" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated"><strong class="lb iu"> ref </strong>:通过来自外部的参考点。这个<code class="fe ms mt mu mv b">ref</code>是伴随<code class="fe ms mt mu mv b">props</code>而来的第二个论点。第二个<code class="fe ms mt mu mv b">ref</code>参数只在用<code class="fe ms mt mu mv b">React.forwardRef</code>调用定义组件时存在。常规函数或类组件不接收<code class="fe ms mt mu mv b">ref</code>参数，并且<code class="fe ms mt mu mv b">ref</code>在props中也不可用。</li></ul><p id="164f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ref转发不限于DOM组件。您也可以将引用转发给类组件实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="ac17" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated"><strong class="lb iu">回调函数</strong>:该函数必须返回一个对象。该对象将包含您能够从外部使用的所有数据。对象属性的名称将是您将从外部使用的名称。功能组件的第二个参数，即<code class="fe ms mt mu mv b">ref</code>，将作为第一个参数传递给<code class="fe ms mt mu mv b">useImperativeHandle</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了导出<code class="fe ms mt mu mv b">Age</code>功能组件中的<code class="fe ms mt mu mv b">ref</code>参数，我们需要以一种特殊的方式导出功能组件。</p><h1 id="b22a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用forwardRef</h1><p id="8429" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们需要使用<code class="fe ms mt mu mv b">React.forwardRef</code>包装功能组件，以便能够激活<code class="fe ms mt mu mv b">ref</code>参数。</p><p id="fc1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自react官方文档:</p><blockquote class="mw mx my"><p id="b498" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">引用转发是一种自动将引用通过一个组件传递给其子组件的技术。对于应用程序中的大多数组件来说，这通常是不必要的。然而，对于某些类型的组件，尤其是在可重用的组件库中，它可能是有用的。</p><p id="c646" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">–<a class="ae ky" href="https://reactjs.org/docs/forwarding-refs.html#gatsby-focus-wrapper" rel="noopener ugc nofollow" target="_blank">reactjs.org</a></p></blockquote><p id="0c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">React.forwardRef</code>将功能组件作为第一个参数，并返回一个可以绑定到<code class="fe ms mt mu mv b">ref</code>的自定义功能组件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d5bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ms mt mu mv b">Age</code>功能组件通过<code class="fe ms mt mu mv b">ref</code>访问上面的两个方法。还有一件事，眼尖的读者可能已经注意到了，即<code class="fe ms mt mu mv b">&lt;&gt;</code>和<code class="fe ms mt mu mv b">&lt;/&gt;</code>。这些被称为<a class="ae ky" href="https://adityatyagi.com/index.php/2022/01/21/how-to-write-cleaner-react-code/" rel="noopener ugc nofollow" target="_blank">反应片段</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有这些放在一起，我们现在可以提交带有空年龄输入的函数，结果，它将聚焦于该字段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/ee400e7e807150ec2d42c6893adccf5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oFKquC8ve2danY85GGdF7w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nu">年龄输入成为无效提交的焦点</em></p></figure><h1 id="0032" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">非受控v/s受控组件</h1><p id="479d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你刚刚学到的上述所有东西不过是使用“<a class="ae ky" href="https://reactjs.org/docs/uncontrolled-components.html" rel="noopener ugc nofollow" target="_blank">未受控的</a>”组件。所谓不受控制，意味着您必须处理值/状态，而不是使用React来完成。</p><p id="95aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于“受控”组件和输入字段，您可以使用状态来读取、写入和更新组件状态。这是当您使用<code class="fe ms mt mu mv b">useState</code>或<code class="fe ms mt mu mv b">useReducer</code>创建一个状态，然后将该状态绑定到您的组件/输入字段。一旦你这样做了，它就变成了一个“受控的”输入域/组件。</p><p id="4f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据官方文件:</p><blockquote class="mw mx my"><p id="2f1a" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">由于不受控制的组件在DOM中保留了事实的来源，所以在使用不受控制的组件时，有时更容易集成React和非React代码。如果你想变得又快又脏，代码也可以少一点。否则，您通常应该使用受控组件。</p><p id="f505" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">reactjs.org</p></blockquote><p id="0b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为这篇博文做研究的时候，我也偶然发现了戈萨·阿里尼奇的作品。</p><h1 id="5ce7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">默认值与值</h1><p id="a886" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您不能在非受控组件/表单字段上使用<code class="fe ms mt mu mv b">value</code>属性。如果你想给一个不受控制的表单域一个默认值，使用<code class="fe ms mt mu mv b">defaultValue</code>。点击此处了解更多信息<a class="ae ky" href="https://scriptverse.academy/tutorials/reactjs-defaultvalue-value.html" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="03b5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">额外收获:一个游乐场</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ne l"/></div></figure><p id="910c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了。试着到处玩，把你的手弄脏！我希望你已经发现这是有用的。感谢您的阅读。</p></div></div>    
</body>
</html>