<html>
<head>
<title>Making a Simple Reddit App With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SwiftUI制作简单的Reddit应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-a-simple-reddit-app-with-swiftui-d0a3e76d980a?source=collection_archive---------0-----------------------#2019-10-05">https://betterprogramming.pub/making-a-simple-reddit-app-with-swiftui-d0a3e76d980a?source=collection_archive---------0-----------------------#2019-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b70d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我创建一个经典的初级iOS应用程序的经历:一个Reddit客户端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6643a65c22a0a1dd8a191ba4fc3c7796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ib_tTUOfxL0yZHQeeY_h3Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/search/photos/reddit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@conkarampelas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Con Karampelas </a>拍摄的照片</p></figure><p id="a8d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，本文是使用macOS Catalina GM版本、Xcode 11.0和Swift 5.1编写的。因此，某些材料可能会发生变化。</p><p id="2518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然Xcode 11终于发布了，SwiftUI看起来也稳定了，我觉得有必要创建一个简单的应用程序，写下我这样做的经历，也许还可以教给那些不怎么使用新框架的人一些东西。</p><p id="9571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我决定做一个经典的初学iOS应用:一个Reddit客户端。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a10e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们在做什么</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/5945f20eb321389685b91bc6f55177de.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/1*wO31KTZOpvK2SZRCpx9q9g.gif"/></div></div></figure><p id="3437" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在上面的GIF中看到的，这个Reddit应用程序只允许用户查看单页帖子，点击一行以在网络视图中加载该帖子，并搜索特定的子编辑以查看该子编辑中帖子的第一页。</p><p id="bb3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！听起来很简单，对吗？</p><p id="fee4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，如果你以前做过应用程序，这很容易！但是，后退一步，想想用UIKit实现这个应用程序需要做的一切。</p><p id="f4f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要创建一个带有<code class="fe ms mt mu mv b">UITableView</code>、实现<code class="fe ms mt mu mv b">UITableViewDataSource</code>和<code class="fe ms mt mu mv b">UITableViewDelegate</code>的视图控制器，添加一个<code class="fe ms mt mu mv b">UITextField</code> <em class="mw">、</em>实现<code class="fe ms mt mu mv b">UITextFieldDelegate</code>、<em class="mw">、</em>，然后继续使用SFSafariViewController或带有嵌入式<code class="fe ms mt mu mv b">WKWebView</code>的视图控制器。</p><p id="def3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我们需要在故事板或代码中创建所有的视图。很明显，我们需要编写大量的视图和控制器代码来创建这个简单的应用程序。</p><p id="398e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，有了SwiftUI，许多视图和控制器代码就消失了。使用SwiftUI，我们只需创建三个视图:</p><ol class=""><li id="0750" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">每行代表一篇Reddit帖子。</li><li id="d4c4" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">另一个用于显示帖子的整个列表<em class="mw"> </em>，以及顶部的搜索文本字段。</li><li id="5307" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">第三个显示网页内容。</li></ol><p id="006f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，几乎所有的控制器代码都被转移到视图模型中。</p><p id="726d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在我们深入SwiftUI视图层之前，让我们首先创建我们的模型和视图模型代码，因为这对于UIKit和SwiftUI实现几乎完全相同。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a328" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建模型</h1><p id="5ef3" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">为了创建我们的模型，我们首先必须知道当数据来自Reddit的API时会是什么样子。为此，请打开一个新的选项卡并转到此<a class="ae kv" href="https://www.reddit.com/.json" rel="noopener ugc nofollow" target="_blank"> URL </a>。这就是为Reddit提供动力的数据的样子。</p><p id="7bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，它可能看起来很难看，所以我建议将它复制并粘贴到一个程序中，如<a class="ae kv" href="https://jsonformatter.org" rel="noopener ugc nofollow" target="_blank"> JSON Formatter </a>，它可以用一种程序员更可读的方式格式化JSON。</p><p id="abcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个简单的应用程序，我们将去掉所有不需要的东西，只创建两个模型。一个代表一个<code class="fe ms mt mu mv b">Post</code> <em class="mw"> </em>，一个代表我们称之为<code class="fe ms mt mu mv b">Listing</code>的帖子列表。</p><h2 id="649e" class="nq ma iq bd mb nr ns dn mf nt nu dp mj lf nv nw ml lj nx ny mn ln nz oa mp ob bi translated">海报模特</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ecec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你以前用过iOS应用程序，这里的一切对你来说应该很熟悉，除了一点:符合<code class="fe ms mt mu mv b">Identifiable</code>协议。</p><p id="53ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">Identifiable</code>协议强迫我们添加ID属性，并假设该ID的值对于该类型的每个实例都是唯一的。我们这样做是为了让SwiftUI能够高效地布局我们的<code class="fe ms mt mu mv b">Posts</code>列表。</p><h2 id="f541" class="nq ma iq bd mb nr ns dn mf nt nu dp mj lf nv nw ml lj nx ny mn ln nz oa mp ob bi translated">上市模式</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c20c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">Listing</code>型很直白。它基本上只是保持着<code class="fe ms mt mu mv b">Posts</code>的列表。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="05d3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建服务层</h1><p id="a733" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">与模型一样，这部分代码适用于该应用程序的UIKit和SwiftUI版本。</p><h2 id="cdb5" class="nq ma iq bd mb nr ns dn mf nt nu dp mj lf nv nw ml lj nx ny mn ln nz oa mp ob bi translated">RedditService</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="f87e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个类也非常简单。它接受一个<code class="fe ms mt mu mv b">URLSession</code> <strong class="ky ir"> </strong>来执行网络请求<strong class="ky ir">，一个</strong><code class="fe ms mt mu mv b">JSONDecoder</code><strong class="ky ir"/>来解析响应，并且它在一个函数中使用这两个函数来执行获取、解析数据，并将数据或错误发送给它的完成处理程序。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="988a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建视图模型</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是事情可能开始变得更奇怪的地方。你可以在顶部看到，我们导入了苹果全新的<code class="fe ms mt mu mv b">Combine</code> <strong class="ky ir"> </strong>库，本质上是他们对函数式反应式编程的采用。</p><p id="61f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导入<code class="fe ms mt mu mv b">Combine</code>允许我们使我们的视图模型符合<code class="fe ms mt mu mv b">ObservableObject</code> <em class="mw"> </em>协议<em class="mw"> </em>，这反过来允许我们在我们的视图模型和我们的视图之间建立反应绑定。</p><p id="51e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还会注意到<code class="fe ms mt mu mv b">@Published</code> <strong class="ky ir"> </strong>属性包装器。该属性包装器为其关联属性提供了一种快捷方式，以便每当其值发生变化时自动通知其观察者。</p><p id="e9f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了具有可观察的属性之外，这个视图模型还为视图提供了一个接口，用于从Reddit的服务器获取帖子。与模型和服务层一样，该方法对于该应用程序的UIKit和SwiftUI版本是相同的。</p><p id="f49a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，SwiftUI有趣的生物…</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="605a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建文章行</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2707" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在<em class="mw">预览</em>窗口中运行，您会注意到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/7b68a773366cce1643504df039ab3e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*jRoUVBHpg6pWiMm3df2_aA.png"/></div></figure><p id="afa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来分析一下。</p><p id="57ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">PostRow</code>符合<code class="fe ms mt mu mv b">View</code> <strong class="ky ir"> </strong>协议，这意味着我们必须实现<code class="fe ms mt mu mv b">var body: some View</code>。</p><p id="7a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不打算深入讨论这到底意味着什么，而是尽可能简洁地总结一下，我们放入计算属性的内容就是视图呈现的内容。</p><p id="2326" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在主体中，最外面的视图是一个<code class="fe ms mt mu mv b">HStack</code> <strong class="ky ir"> </strong>(水平堆栈)，它从左到右水平对齐其中的视图。在<code class="fe ms mt mu mv b">HStack</code>内部，我们有一个<code class="fe ms mt mu mv b">Image</code>和一个<code class="fe ms mt mu mv b">VStack</code>(垂直堆栈)。</p><p id="adf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">Image</code>是苹果全新的<a class="ae kv" href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/" rel="noopener ugc nofollow" target="_blank">科幻符号</a>之一，这是一个简单、易用、日常图标的扩展库。我决定在这个项目中使用一个，只是为了玩玩新的SF符号，正如你所看到的，就像图像已经在你的资产目录中一样简单。</p><p id="dc98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ms mt mu mv b">VStack</code>中，我们有两个<code class="fe ms mt mu mv b">Text</code> <strong class="ky ir"> </strong>对象，你猜对了，它们是垂直堆叠的。顶部标签使用标题字体呈现我们的<code class="fe ms mt mu mv b">Post</code>的标题，底部标签使用副标题字体呈现我们的<code class="fe ms mt mu mv b">Post</code>的子编辑名称，文本颜色设置为灰色。</p><p id="6514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，SwiftUI语法极具表现力，易于阅读，即使您以前从未使用过SwiftUI。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="49eb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">创建帖子列表</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，这是呈现文章列表的视图。这显然比<code class="fe ms mt mu mv b">PostRow</code>要复杂一点，所以我们来分解一下，从顶部开始。</p><p id="192d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个结构的顶部，我们有之前创建的视图模型，它有属性包装器<code class="fe ms mt mu mv b">@ObservedObject</code>。</p><p id="bb03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个属性包装器与<code class="fe ms mt mu mv b">ObservableObject</code> <strong class="ky ir"> </strong>携手并进，并且允许我们的视图和我们的视图模型绑定在一起，以便它们总是保持同步。</p><p id="1b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们在视图中又多了两个属性:<code class="fe ms mt mu mv b">query</code> <strong class="ky ir"> </strong>和<code class="fe ms mt mu mv b">subredditTitle</code>。这两个都有<code class="fe ms mt mu mv b">@State</code> <strong class="ky ir"> </strong>属性的包装器。</p><p id="5a3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个属性包装器的工作方式与<code class="fe ms mt mu mv b">@ObservedObject</code>非常相似，它保持视图和相关属性的值同步，但是它通常用于我们的视图模型不关心的属性。</p><p id="0fd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们身体中最外层的视图是一个<code class="fe ms mt mu mv b">NavigationView</code>，它创建了一个标准的iOS导航栏。</p><p id="787c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe ms mt mu mv b">NavigationView</code>里面，有一个<code class="fe ms mt mu mv b">List</code>。列表给了我们创建任意组合的垂直滚动列表的能力。</p><p id="dad6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ms mt mu mv b">List</code>的顶部是搜索<code class="fe ms mt mu mv b">TextField</code>。初始化器将占位符文本设置为“Search Subreddit”，将文本字段中的值绑定到<code class="fe ms mt mu mv b">query</code>属性，当用户点击return时，它执行结尾的闭包。在这种情况下，更新<code class="fe ms mt mu mv b">subredditTitle</code>属性并执行提取。</p><p id="688c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ms mt mu mv b">TextField</code>下面，我们遍历视图模型中的帖子数组，为每个帖子创建一个<code class="fe ms mt mu mv b">PostRow</code> <strong class="ky ir"> </strong>并将其包装在一个<code class="fe ms mt mu mv b">NavigationLink</code>中。</p><p id="ab0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将每一行包装在<code class="fe ms mt mu mv b">NavigationLink</code> <strong class="ky ir"> </strong>中会将公开指示符添加到每一行的尾部，并自动添加往返于目的地的推送和弹出功能<code class="fe ms mt mu mv b">View</code>。</p><p id="0c5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要两个修改器来完成这个<code class="fe ms mt mu mv b">View</code>。首先，<code class="fe ms mt mu mv b">List</code>需要修饰符<code class="fe ms mt mu mv b">.navigationBarTitle(Text(subredditTitle))</code> <strong class="ky ir"> </strong>将导航视图中的标题设置为<code class="fe ms mt mu mv b">subredditTitle</code>属性的值。</p><p id="70a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二，<code class="fe ms mt mu mv b">NavigationView</code> <strong class="ky ir"> </strong>需要修饰符<code class="fe ms mt mu mv b">.onAppear(perform: fetchListing)</code> <strong class="ky ir"> </strong>，这样当这个视图出现在屏幕上时，文章列表就会被获取。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="82fc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">创建网络视图</strong></h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="e940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，SwiftUI没有为我们提供它自己版本的web视图(还没有)，但是它确实为我们提供了一个很好的协议，让普通的<code class="fe ms mt mu mv b">UIView</code>像SwiftUI视图一样工作:<code class="fe ms mt mu mv b">UIViewRepresentable</code>。</p><p id="167b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个协议要求我们实现<code class="fe ms mt mu mv b">makeUIView</code>和<code class="fe ms mt mu mv b">updateUIView</code>。</p><p id="ae93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">makeUIView</code> <strong class="ky ir"> </strong>是一个需要我们定义正在创建的<code class="fe ms mt mu mv b">UIView</code>的类型，然后创建它的函数。</p><p id="420e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">updateUIView</code> <strong class="ky ir"> </strong>每当我们的视图需要更新自身以响应它所呈现的数据的变化时就会被调用。然而，在这种情况下，当视图被创建时，它只被调用一次，它所做的就是在<code class="fe ms mt mu mv b">WKWebView</code>中加载URL。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a663" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">更新场景代理</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a970" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为了让整个应用程序在我们按下play时工作，我们需要更新<code class="fe ms mt mu mv b">SceneDelegate</code>来创建我们需要的所有初始数据，并将其传递给应用程序的第一个<code class="fe ms mt mu mv b">View</code>:T10。</p><p id="8008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！这就是使用SwiftUI和Combine创建一个简单应用程序的全部内容。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9c56" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="c917" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">应该清楚SwiftUI在多大程度上简化和减少了我们需要为视图和控制器层编写的代码。</p><p id="b237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您也使用Combine框架时，整个代码库变得更加声明性、简洁和自文档化。然而，它确实感觉SwiftUI仍然处于婴儿期，因为随着你越来越多地使用它并试图在界限之外着色，会有随机的错误出现。</p><p id="8046" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从好的方面来看，我们已经可以用SwiftUI优先的方法制作真实世界的工作应用程序，这让我对未来的更新充满希望。我希望，从现在起的一两年内，SwiftUI将为黄金时间做好准备。</p><p id="a37e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看整个项目，请查看我的GitHub 上的<a class="ae kv" href="https://github.com/etlasky/Reddit-SwiftUI" rel="noopener ugc nofollow" target="_blank">回购。</a></p></div></div>    
</body>
</html>