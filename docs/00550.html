<html>
<head>
<title>I Don’t Like the Provider Model Anymore — Here’s Why You Shouldn’t Either</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我不再喜欢提供商模式，以下是你也不应该喜欢的原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-dont-like-the-provider-model-anymore-here-s-why-you-shouldn-t-either-aafc1fa6fcdf?source=collection_archive---------3-----------------------#2019-06-08">https://betterprogramming.pub/i-dont-like-the-provider-model-anymore-here-s-why-you-shouldn-t-either-aafc1fa6fcdf?source=collection_archive---------3-----------------------#2019-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有些设计模式没有达到现代人的期望。提供者模型就是其中之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f51c7a12935c99313f4935b2bc45542c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyV_ota7eG1mIjYetPUnTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/3h7j04-6y3Q" rel="noopener ugc nofollow" target="_blank">去飞溅</a></p></figure><p id="8dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">技术正以令人难以置信的速度发展。随着技术的发展，我们相应地修改架构模式和设计以保持相关性。然而，有一种模式我们没有机会挽救。跟不上时代了。虽然在其全盛时期，这是一个很好的模式，但提供商模式已经跟不上SaaS供应商的步伐。这些提供者提供他们的API的方式，我们不需要再浪费时间包装服务调用了。</p><p id="6189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不熟悉<a class="ae ky" href="https://blogs.msdn.microsoft.com/dansellers/2005/10/20/asp-net-2-0-provider-model-introduction-to-the-provider-model/" rel="noopener ugc nofollow" target="_blank">提供者模型</a>，这是微软设计的一种模式，用于调用API或第三方服务。开发人员用他们自己的代码包装服务，以便应用程序调用他们的托管代码，而不是直接调用提供者。这允许公司在不改变调用应用程序的情况下交换提供者，而是改变提供者包装器。</p><p id="e4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探讨一下使用提供者模型的一些先前的理由，并发现为什么它们不再相关了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7346" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">原因1:您的应用程序代码只会调用您的代码</h2><p id="46a8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><strong class="lb iu">理论</strong>:通过用自己的代码包装第三方服务，可以保证你的应用和服务之间的接口永远不会中断。如果提供者改变了您使用的服务调用，您只需要改变您的包装器，而不是所有利用该特性的应用程序。</p><p id="5a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现实:试图通过包装来降低第三方服务中的重大变更的风险是徒劳的。如今，如果一个SaaS供应商要对现有服务进行更新，他们将保持向后兼容性。如果供应商引入了一个突破性的变化，他们要么将它作为一个可选的主要版本发布，要么将其作为一个新的服务添加。您当前使用的服务因更新而中断的可能性微乎其微。</p><p id="d981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包装服务也会限制你的发展。一些SaaS供应商拥有丰富的功能，但这些功能仅通过他们的网站提供，而不是通过他们的API提供。以Twilio工作室为例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/945478e0c798996eebc3b0c9ef28be44.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Pcj6E4ie0WOEc-xdyZkYFw.jpeg"/></div></figure><p id="a065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Twilio是一家平台即服务(PaaS)公司，旨在向用户发送通知。他们有一套健壮的API供你的应用程序调用，可以发送文本、电子邮件或打电话。但是，如果您只与他们的API接口，您将无法获得Twilio Studio提供的丰富功能来构建带有逻辑分支、查找和更新的流程图。您实际上将自己限制为发送千篇一律的消息，并将所有的逻辑和路由责任放在您的应用程序上。</p><p id="4666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您只包装您期望在您的应用程序中使用的调用，您将丢失您的API发现。如果你对这个术语不熟悉，这就是我们作为开发人员在试图弄清楚一个库可以采取什么行动时所做的事情。我们打开IDE，使用intellisense滚动浏览对象的可用函数和属性。如果我们只包装了对第三方服务的选定的几个API调用，我们实际上已经失去了充分利用它的能力，因为我们不知道还有什么其他功能可用。</p><p id="20f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将所有可用的调用打包到服务中，那么很可能您要么有暑期实习生供您使用，要么您通过实现一些您从未打算使用的API而没有充分利用您的一名员工。这样做的好处是您可以获得完整的API发现。不利的一面是，你将浪费一些时间来构建你永远不会用到的调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8023" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">原因2:您没有被特定的供应商锁定</h2><p id="8729" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><strong class="lb iu">理论</strong>:提供者模型允许你在不改变你的应用程序代码的情况下很容易地交换供应商。唯一需要做的更改是对您的服务包装层进行更改，以便它可以引用新的提供者。即使您在后端更改了供应商，应用程序也将继续正常运行。</p><p id="8456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">现实</strong>:100次中有99次，你不会换供应商。除非他们大幅改变你的服务价格，否则没有理由改变。你已经和供应商建立了融洽的关系。你知道他们的代表，他们也知道你的代表。即使他们真的改变了合同价格，也不会没有通知。当你与当前供应商的合同到期时，你将有时间研究替代方案。</p><p id="5f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切换到新的供应商会带来无法保持功能对等的风险。新的供应商可以为不同的功能提供新的API，但是如果他们不提供您的应用程序已经使用的API，您将会破坏您的用户群，让他们感到沮丧和不高兴。即使新供应商提供相同的功能，它也可能需要与旧供应商不同的信息。这意味着您的契约必须在您的服务包装层中进行更改，这也导致您在应用程序代码中进行额外的更改。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6bbc" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">原因3:管理自己的代码更简单</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/ec90c7685fefdea1aa4a3a3d3bf7ba52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hU1SzM_NS8nT2PyAiZwquA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Pixabay的Magic创意</p></figure><p id="8f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论:编写一个包装器将允许你控制应用程序服务调用的输入和输出。它更简单，因为您定义了方法签名，并且可以以可控的方式丰富调用，而不必依赖大量开发人员来知道需要传入什么。你通过黑盒的方式提供了一个安全网。包装器消除了调用供应商API的复杂性。如果需要更改传入API的值，可以相应地更改包装器。</p><p id="9631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">现实</strong>:提供现代SaaS或PaaS软件的公司已经采取了服务优先的方法，这意味着他们非常重视提供简单、直观的API和强大的示例来启动开发。与供应商集成不再像过去那样困难。随着RESTful API的兴起，调用提供者就像发出HTTP请求一样简单。使用这些API比以往任何时候都容易。</p><p id="bbcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，围绕服务调用构建包装器意味着您也必须管理这些代码。您正在创建额外的代码来维护，这些代码提供了有限的附加值。根据您选择的语言，从SaaS提供者调用API可能只有一行代码。但是，如果您已经包装了该服务调用，那么现在就需要维护整个类、方法签名，并扩充您的代码库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3a24" class="nc md it bd me nd ne nf mh ng nh ni mk jz nj ka mn kc nk kd mq kf nl kg mt nm bi translated">最后的想法</h1><p id="9168" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对服务提供商进行API调用比以往任何时候都容易。不要害怕直接给他们打电话。用您自己的代码包装API只是增加了您的代码库，并没有提供更多的附加值。随着我们在软件开发世界中看到的变化速度，上市时间需要处于历史最低点。</p><p id="864d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建小型专用应用程序是缩短上市时间的一个好方法。为十年后的意外事件制作通用的包装器不会让你保持相关性。你现在正在开发的应用程序可能会在十年后停产，并被更新的应用程序所取代。为了保持你的应用程序小，扔掉包装器，直接调用你的API。如果您需要更换提供商，应该像更改URL一样简单。习惯敏捷和适应性强的想法。</p><p id="0672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都想构建现代的、相关的应用程序。因此，让我们停止使用过时的做法，如提供者模型，并把我们的重点放在构建应用程序，而不是包装。您的最终用户、利益相关者和开发人员都会感谢您。</p><p id="df01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你发现供应商模式的现代用法了吗？你认为还有其他我们需要摒弃的模式吗？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="5406" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">相关文章</h2><p id="b15d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/the-5-ws-of-the-rapid-prototype-8e7614f82d29" rel="noopener">快速原型制作的5个W</a><br/><a class="ae ky" href="https://medium.com/swlh/design-to-delight-raising-the-bar-on-software-design-a1eec234188b" rel="noopener">愉悦设计:提高软件设计的标准</a> <br/> <a class="ae ky" href="https://medium.com/better-programming/choosing-the-right-platform-for-your-new-app-7d7820191d3d" rel="noopener">为你的新应用选择合适的平台</a></p></div></div>    
</body>
</html>