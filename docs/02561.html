<html>
<head>
<title>Python Progress Bars with Tqdm by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Tqdm的Python进度条示例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-progress-bars-with-tqdm-by-example-ce98dbbc9697?source=collection_archive---------2-----------------------#2019-12-09">https://betterprogramming.pub/python-progress-bars-with-tqdm-by-example-ce98dbbc9697?source=collection_archive---------2-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0080" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">了解如何利用Juypter笔记本和Python应用程序中的进度条</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/1208fe83e5bf26f970660b02c075a6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xQ54nqXMe0X5ssGQ.png"/></div></div></figure><p id="3964" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">进度条可以设定期望值，给人一种活动的印象，并且可以镇定神经。我们已经拥有它们很多年了，有些令人兴奋，有些令人厌烦，有些只是没有很好的记录。</p><p id="f29c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">进度条本质上是根据完成任务的进度百分比来填充的。条形图的移动基于任务中的某些里程碑。这通常是通过预先计算要处理的输入项，然后用<code class="fe lr ls lt lu b">number_of_items_processed</code>除以<code class="fe lr ls lt lu b">total_input_items</code>来计算进度来实现的。当然，这是对问题的过度简化。还有其他因素需要考虑，例如网络速度、延迟，以及如果将数据保存到本地存储中以获得更准确的ETA ( <em class="lv">估计到达时间</em>)，写入速度。</p><p id="9311" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你正在阅读这篇文章，你可能和我一样，对网上有限的tqdm例子感到沮丧，这些例子没有很好地说明这个包在各种用例中是如何工作的。这些例子似乎假设您事先已经知道这个包是如何工作的。如果您不擅长清除Git问题，您可能无法在社区和开发人员之间的来回对话中找到您需要的示例。</p><p id="f1c6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们划分之前，让我们理解tqdm的实际含义。当我第一次开始了解tqdm时，这个名字让我迷惑不解。我完全不明白为什么这个包会被这样命名——这看起来完全不相关。那是因为我不懂阿拉伯语。Tqdm在阿拉伯语中是<em class="lv"> taqadum的简称，</em>意为<strong class="kx iu">进步</strong>。</p><p id="044b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Tqdm包是python中较为全面的进度条包之一，对于那些希望构建脚本来让用户了解应用程序状态的情况来说非常方便。Tqdm可以在任何平台(Linux、Windows、Mac、FreeBSD、NetBSD、Solaris/SunOS)上的任何控制台或GUI中工作，并且对IPython/Jupyter笔记本也很友好，我们将在pandas的一个示例中看到这一点。</p><p id="8210" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，tqdm不能很好地配合Python的核心日志库。你可能不得不求助于黑客来获得同样的无缝进度条。由于tqdm生成的进度条利用回车符和换行符来控制字符，因此了解它们在不支持这一功能的环境中的使用情况非常重要。例如，在Jenkins日志记录终端或第三方日志记录框架(如splunk、cloudwatch和Loggly等)中，期望的输出可能不是您所期望的，例如，输出被流式传输到每一行，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lw"><img src="../Images/586ee60325fa3f45c7776ac08d69c106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRK0-5IAJQTT2WY8TAgw7Q.png"/></div></div></figure><p id="56c4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个简短的教程将会给你一些例子来帮助你快速上手，而不会在这个过程中伤到你的背。这里的例子补充了tqdm已经在他们的git存储库上展示的内容，增加了对代码如何工作的理解。请随意在评论中添加示例，以便该资源可以作为其他开发人员的参考点。现在，让我们开始在您的本地机器上设置tqdm。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f828" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">先决条件</h1><p id="14bf" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">Python 3必须安装在您的机器上。如果你在Mac上，你可以使用Brew或者按照<a class="ae nb" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python网站</a>上的设置说明进行操作。如果您使用的是Windows，Python MSI应该为您跑腿，至少在配置路径变量和安装Python方面。</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="4e14" class="ng mf it lu b gy nh ni l nj nk">$ brew install python3</span></pre><p id="9a22" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意Pip3是和Python3捆绑在一起的。通过pip运行安装virtualenv:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="7c28" class="ng mf it lu b gy nh ni l nj nk">$ pip3 install virtualenv</span></pre><p id="be67" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">确定您想要编写代码的目录，并创建一个<a class="ae nb" href="https://docs.python.org/3/tutorial/venv.html" rel="noopener ugc nofollow" target="_blank">虚拟环境</a>:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="1ecb" class="ng mf it lu b gy nh ni l nj nk">$ virtualenv -p python3 &lt;your-desired-path&gt;</span></pre><p id="01a4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">激活virtualenv:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="dbff" class="ng mf it lu b gy nh ni l nj nk">$ source &lt;desired-path&gt;/bin/activate</span></pre><p id="a1a5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您希望停用virtualenv，您可以执行以下命令:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="07a8" class="ng mf it lu b gy nh ni l nj nk">$ deactivate</span></pre><p id="403a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">执行:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="399a" class="ng mf it lu b gy nh ni l nj nk">$ pip install tqdm<br/>$ pip freeze &gt; requirements.txt</span></pre><p id="c162" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建一个运行python代码的虚拟环境是您应该遵循的最佳实践。Python虚拟环境为Python项目创建了一个隔离的环境。这意味着每个项目都可以有自己的依赖项，而不管其他项目有什么依赖项。激活指示pip在被调用时将软件包安装到您创建的虚拟环境文件夹中。停用会关闭终端会话中到虚拟环境的链接。运行pip freeze可让您获取与您的应用程序一起工作的当前版本的包的快照。让我们浏览一些tqdm使用案例。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f6cb" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">向for循环添加进度条</h1><p id="5dde" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">您可以轻松地添加一个进度条，而不是在Python循环的每次迭代中打印出索引或其他信息来查看进度，如下例所示。在循环中添加进度条可以让您在运行长脚本时随时了解情况。如果您在Windows机器上运行，您可能需要添加colorama pip包。</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="c34b" class="ng mf it lu b gy nh ni l nj nk">import time<br/>import sys<br/>from tqdm import trange<br/><br/><br/>def do_something():<br/>    time.sleep(1)<br/><br/>def do_another_something():<br/>    time.sleep(1)<br/><br/><br/>for i in trange(10, file=sys.stdout, desc='outer loop'):<br/>    do_something()<br/><br/>    for j in trange(100,file=sys.stdout, leave=False, unit_scale=True, desc='inner loop'):<br/>        do_another_something()</span></pre><p id="be8d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这给了我们一个漂亮的嵌套进度条。对于每个外部循环，迭代十次。默认情况下，tqdm打印到sys.stderr输出流。要将其重新引导到标准输出流，可以使用下面的参数:<code class="fe lr ls lt lu b">file=sys.stdout</code></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nl"><img src="../Images/d918757af37e5d7fbd593f2e7f4204f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6u4SJYIgN6gE-DJvuuuucQ.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">嵌套for循环中的tqdm嵌套进度条</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="5a75" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">进度条的预测性手动更新</h1><p id="4875" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">它们是您需要控制并以一定的时间间隔手动更新进度条的实例。例如，当以块或流数据的形式下载多部分文件时。可以认为这是周期性的时间间隔更新或以特定的时间间隔脉动。Tqdm包允许我们手动邀请更新进度条功能，如下例所示:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="3227" class="ng mf it lu b gy nh ni l nj nk">import time<br/>import sys<br/>from tqdm import tqdm<br/><br/><br/>def do_something():<br/>    time.sleep(1)<br/><br/><br/>with tqdm(total=100, file=sys.stdout) as pbar:<br/>    for i in range(10):<br/>        do_something()<br/>        # Manually update the progress bar, useful for streams such as reading files.<br/>        pbar.update(10)<br/>        # Updates in increments of 10 stops at 100</span></pre><p id="25a7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上面的tqdm类属性<strong class="kx iu"> </strong> <code class="fe lr ls lt lu b">total</code>是预期的迭代次数，在上面的代码中已经设置为100。对函数update的调用在每次迭代中递增10，直到达到100%。<br/>如果未指定总数，则尽可能使用<code class="fe lr ls lt lu b">len</code> (iterable)。如果你忽略这个<br/>，只显示基本的进度统计(没有ETA，没有进度条)，这可能对你没有用，但仍然显示后台正在进行的工作。</p><h1 id="0be2" class="me mf it bd mg mh nq mj mk ml nr mn mo jz ns ka mq kc nt kd ms kf nu kg mu mv bi translated">用Tqdm进度条下载大文件</h1><p id="03bf" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">对于这个例子，您需要通过pip将一个<a class="ae nb" href="https://github.com/psf/requests" rel="noopener ugc nofollow" target="_blank">请求包</a>和<a class="ae nb" href="https://validators.readthedocs.io/en/latest/#installation" rel="noopener ugc nofollow" target="_blank">验证器</a>添加到您的Python站点包中。</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="b02d" class="ng mf it lu b gy nh ni l nj nk">$ pip install requests validators</span><span id="6b5c" class="ng mf it lu b gy nv ni l nj nk">#  Copyright 2019 tiptapcode Authors. All Rights Reserved.<br/>#<br/>#  Licensed under the Apache License, Version 2.0 (the "License");<br/>#  you may not use this file except in compliance with the License.<br/>#  You may obtain a copy of the License at<br/>#<br/>#       http://www.apache.org/licenses/LICENSE-2.0<br/>#<br/>#  Unless required by applicable law or agreed to in writing, software<br/>#  distributed under the License is distributed on an "AS IS" BASIS,<br/>#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br/>#  See the License for the specific language governing permissions and<br/>#  limitations under the License.<br/><br/># -*- coding: utf-8 -*-<br/>import os<br/>import sys<br/>import tqdm<br/>import requests<br/>import validators<br/><br/><br/>class FileDownloader(object):<br/><br/>    def get_url_filename(self, url):<br/>        """<br/>        Discover file name from HTTP URL, If none is discovered derive name from http redirect HTTP content header Location<br/>        :param url: Url link to file to download<br/>        :type url: str<br/>        :return: Base filename<br/>        :rtype: str<br/>        """<br/>        try:<br/>            if not validators.url(url):<br/>                raise ValueError('Invalid url')<br/>            filename = os.path.basename(url)<br/>            basename, ext = os.path.splitext(filename)<br/>            if ext:<br/>                return filename<br/>            header = requests.head(url, allow_redirects=False).headers<br/>            return os.path.basename(header.get('Location')) if 'Location' in header else filename<br/>        except requests.exceptions.HTTPError as errh:<br/>            print("Http Error:", errh)<br/>            raise errh<br/>        except requests.exceptions.ConnectionError as errc:<br/>            print("Error Connecting:", errc)<br/>            raise errc<br/>        except requests.exceptions.Timeout as errt:<br/>            print("Timeout Error:", errt)<br/>            raise errt<br/>        except requests.exceptions.RequestException as err:<br/>            print("OOps: Something Else", err)<br/>            raise err<br/><br/>    def download_file(self, url, filename=None, target_dir=None):<br/>        """<br/>        Stream downloads files via HTTP<br/>        :param url: Url link to file to download<br/>        :type url: str<br/>        :param filename: filename overrides filename defined in Url param<br/>        :type filename: str<br/>        :param target_dir: target destination directory to download file to<br/>        :type target_dir: str<br/>        :return: Absolute path to target destination where file has been downloaded to<br/>        :rtype: str<br/>        """<br/>        if target_dir and not os.path.isdir(target_dir):<br/>            raise ValueError('Invalid target_dir={} specified'.format(target_dir))<br/>        local_filename = self.get_url_filename(url) if not filename else filename<br/><br/>        req = requests.get(url, stream=True)<br/>        file_size = int(req.headers['Content-Length'])<br/>        chunk_size = 1024  # 1 MB<br/>        num_bars = int(file_size / chunk_size)<br/><br/>        base_path = os.path.abspath(os.path.dirname(__file__))<br/>        target_dest_dir = os.path.join(base_path, local_filename) if not target_dir else os.path.join(target_dir, local_filename)<br/>        with open(target_dest_dir, 'wb') as fp:<br/>            for chunk in tqdm.tqdm(req.iter_content(chunk_size=chunk_size), total=num_bars, unit='KB', desc=local_filename, leave=True, file=sys.stdout):<br/>                fp.write(chunk)<br/><br/>        return target_dest_dir<br/><br/><br/>if __name__== "__main__":<br/><br/>    links = ['https://nodejs.org/dist/v12.13.1/node-v12.13.1.pkg', 'https://aka.ms/windev_VM_virtualbox']<br/><br/>    downloader = FileDownloader()<br/><br/>    for url in links:<br/>        downloader.download_file(url)</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="c6a6" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">螺纹进度条</h1><p id="a9b9" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">在这个例子中，我们可以看到如何将tqdm包包装到Python线程中。这里的线程不应该与进程混淆。如果您想充分利用计算机上的内核总数，那么多处理是一个不错的选择。tqdm <strong class="kx iu"> position </strong>参数允许我们指定打印该条的行偏移量(从0开始)。如果没有指定，它将默认为自动。对于我们的例子，指定这个值来一次管理多个条是很重要的(例如，来自线程)。如果省略此参数，您的条将被不同的线程覆盖</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nw"><img src="../Images/e72d3438d35a04a3cffec71df89306e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xcxZsnJyQHL1Qqvsor4kA.png"/></div></div></figure><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="6785" class="ng mf it lu b gy nh ni l nj nk">import time<br/><br/>from random import randrange<br/>from multiprocessing.pool import ThreadPool<br/><br/>from tqdm import tqdm<br/><br/><br/>def func_call(position, total):<br/>    text = 'progressbar #{position}'.format(position=position)<br/>    with  tqdm(total=total, position=position, desc=text) as progress:<br/>        for _ in range(0, total, 5):<br/>            progress.update(5)<br/>            time.sleep(randrange(3))<br/><br/><br/>pool = ThreadPool(10)<br/>tasks = range(5)<br/>for i, url in enumerate(tasks, 1):<br/>    pool.apply_async(func_call, args=(i, 100))<br/>pool.close()<br/>pool.join()</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="e812" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">如何在熊猫数据框架中应用Tqdm</h1><p id="0a1b" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">Tqdm扩展了pandas apply和map并生成了一个tqdm进度条，现在你可以用<code class="fe lr ls lt lu b">progress_apply</code>代替<code class="fe lr ls lt lu b">apply</code>，用<code class="fe lr ls lt lu b">progress_map </code>代替<code class="fe lr ls lt lu b">map</code>，如下例所示。在每个pandas行单元项迭代中，tqdm更新挂钩已基于数据帧中的全部数据被调用——因此，可以导出ETA</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nx"><img src="../Images/5a37c5cd7c92e16ffea900e9727c60a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2weeNb-UD2pVQ7qSCoeItw.png"/></div></div></figure><p id="d9aa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要运行此程序，请确保您安装了requests、tqdm和pandas:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="f4d6" class="ng mf it lu b gy nh ni l nj nk">pip install requests tqdm pandas</span><span id="334d" class="ng mf it lu b gy nv ni l nj nk">import time<br/>import pandas as pd<br/>import requests<br/><br/>from tqdm import tqdm<br/><br/><br/>def percent_off(product_price, discount):<br/>    try:<br/>        discount = float(discount)<br/>        if discount &lt; 0  and discount &gt; 100:<br/>            raise ValueError('discout amount should be between 1 and 100%')<br/>        value = (product_price - (product_price * (discount / 100.0)))<br/>        time.sleep(0.0001)<br/>        return value<br/>    except ValueError as e:<br/>        print('invalid product_price or discount amount', e)<br/>        raise e<br/><br/>def appy_discount(perentage):<br/><br/>    df = pd.DataFrame(pd.read_json('products.json'))<br/><br/>    df.insert(4, 'discount', 0)<br/><br/>    tqdm.pandas(desc='apply_{}_percent_off'.format(perentage))<br/><br/>    df['discount'] = df['price'].progress_apply(lambda x: percent_off(x, perentage))<br/><br/>    return df<br/><br/><br/># Downlaod sample best buy products json file<br/># It sucks right that you do not see a progress bar while downloadng this large file below<br/>r = requests.get('https://github.com/BestBuyAPIs/open-data-set/raw/master/products.json', allow_redirects=True)<br/>open('products.json', 'wb').write(r.content)<br/><br/># How about now imagine performing a large pandas dataframe calculation<br/>df = appy_discount(5)<br/><br/>df # use this to a nice html output in jupyter notebooks else print to sysout</span></pre><p id="2b64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要在Juypter笔记本中运行该程序，您需要安装带有pip的juy pter笔记本:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="fa21" class="ng mf it lu b gy nh ni l nj nk">python3 -m pip install jupyter</span></pre><p id="e1f1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要运行笔记本，请在终端(Mac/Linux)或命令提示符(Windows)下运行以下命令。这将打开您的浏览器，Jupyter运行在默认端口:</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="2dad" class="ng mf it lu b gy nh ni l nj nk">jupyter notebook</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="cb46" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">如何给你的Tqdm进度条添加颜色</h1><p id="a746" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">如果你不觉得给进度条添加颜色会分散注意力，那么这个例子可能适合你。tqdm可以与<a class="ae nb" href="https://github.com/tartley/colorama" rel="noopener ugc nofollow" target="_blank"> colorama </a>协同工作，colorama是Python中一种简单的跨平台彩色终端文本。彩色文本的跨平台打印可以使用colorama的ANSI转义序列的常量速记来完成:Colorama的例子和源代码可以在这里找到<a class="ae nb" href="https://github.com/tartley/colorama/tree/master/demos" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="ab44" class="ng mf it lu b gy nh ni l nj nk">from tqdm import trange<br/>from colorama import Fore<br/><br/># Cross-platform colored terminal text.<br/>color_bars = [Fore.BLACK,<br/>    Fore.RED,<br/>    Fore.GREEN,<br/>    Fore.YELLOW,<br/>    Fore.BLUE,<br/>    Fore.MAGENTA,<br/>    Fore.CYAN,<br/>    Fore.WHITE]<br/><br/>for color in color_bars:<br/>    for i in trange(int(7e7),<br/>                    bar_format="{l_bar}%s{bar}%s{r_bar}" % (color, Fore.RESET)):<br/>        pass</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ny"><img src="../Images/a2b37693fd3581aec01e38b4193bca4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5ZDFUo6VGkWJ68lN2Icow.png"/></div></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="bc7b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">如何将Python Logger与Tqdm结合使用</h1><p id="dc45" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">以下示例说明了如何登录Python日志记录框架。这个想法是创建一个定制的日志记录器，它从StringIO和channel继承记录的数据。使用StringIO之类的缓冲模块有助于我们像操作普通文件一样操作数据，以便进一步处理。</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="cb0a" class="ng mf it lu b gy nh ni l nj nk">#  Copyright 2019 tiptapcode Authors. All Rights Reserved.<br/>#<br/>#  Licensed under the Apache License, Version 2.0 (the "License");<br/>#  you may not use this file except in compliance with the License.<br/>#  You may obtain a copy of the License at<br/>#<br/>#       http://www.apache.org/licenses/LICENSE-2.0<br/>#<br/>#  Unless required by applicable law or agreed to in writing, software<br/>#  distributed under the License is distributed on an "AS IS" BASIS,<br/>#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br/>#  See the License for the specific language governing permissions and<br/>#  limitations under the License.<br/><br/>import io<br/>import os<br/>import sys<br/>import logging<br/>import validators<br/><br/>from urllib import request<br/>from tqdm import tqdm<br/><br/><br/>class ProgressBar(tqdm):<br/><br/>    def update_progress(self, block_num=1, block_size=1, total_size=None):<br/>        if total_size is not None:<br/>            self.total = total_size<br/>        self.update(block_num * block_size - self.n)  # will also set self.n = b * bsize<br/><br/><br/>class DownloadFileHandler(object):<br/><br/>    @staticmethod<br/>    def download_file_by_url(url, download_dir=None):<br/>        if not validators.url(url):<br/>           raise ValueError('Invalid url := {}'.format(url))<br/>        if download_dir is not None and not os.path.isdir(download_dir):<br/>            raise FileNotFoundError('Directory specified := {} does not exist'.format(download_dir))<br/>        else:<br/>            download_dir = os.path.abspath(os.path.dirname(__file__))<br/>        filename = os.path.basename(url)<br/>        download_destination = os.path.join(download_dir, filename)<br/><br/>        #The magic happens here in order to log to python logger we need to create<br/>        # A custom logger that channels the output stream to the log stream<br/>        with ProgressBar(<br/>                file=TqdmSystemLogger(logger, suppress_new_line=False),<br/>                unit='B',<br/>                unit_scale=True,<br/>                miniters=1,<br/>                desc=filename<br/>        ) as progressBar:<br/>            # request.urlretrieve has an internal callback function that get invoked reporthook<br/>            # The reporthook argument should be<br/>            #     a callable that accepts a block number, a read size, and the<br/>            #     total file size of the URL target. The data argument should be<br/>            #     valid URL encoded data.<br/>            #     tqdm uses this data to derive a progress bar as we know the total file size we can estimate ETA<br/>            request.urlretrieve(url, filename=download_destination, reporthook=progressBar.update_progress, data=None)<br/><br/>        return download_destination<br/><br/><br/>class SystemLogger(object):<br/><br/>    def __init__(self):<br/>        pass<br/><br/>    @staticmethod<br/>    def get_logger(name, level=None):<br/><br/>        root_logger = logging.getLogger(name)<br/>        root_logger.setLevel(level if level else logging.INFO)<br/><br/>        # An attempt to replace logger output as to print on same line may not work on some terminals<br/>        # only applicable to logging to sys.stdout<br/>        # formatter = logging.Formatter('\x1b[80D\x1b[1A\x1b[K%(message)s')<br/><br/>        formatter = logging.Formatter(fmt='%(levelname)s:%(name)s: %(message)s (%(asctime)s; %(filename)s:%(lineno)d)', datefmt="%d-%m-%YT%H:%M:%S%z")<br/><br/>        handler_stdout = logging.StreamHandler(sys.stdout)<br/>        handler_stdout.setFormatter(formatter)<br/>        handler_stdout.setLevel(logging.WARNING)<br/>        handler_stdout.addFilter(type('', (logging.Filter,), {'filter': staticmethod(lambda r: r.levelno &lt;= logging.INFO)}))<br/><br/>        handler_stdout.flush = sys.stdout.flush<br/><br/>        root_logger.addHandler(handler_stdout)<br/><br/>        handler_stderr = logging.StreamHandler(sys.stderr)<br/>        handler_stderr.setFormatter(formatter)<br/>        handler_stderr.setLevel(logging.WARNING)<br/><br/>        handler_stderr.flush = sys.stderr.flush<br/><br/>        root_logger.addHandler(handler_stderr)<br/><br/>        return root_logger<br/><br/><br/>class TqdmSystemLogger(io.StringIO):<br/><br/>    def __init__(self, logger, suppress_new_line=True):<br/>        super(TqdmSystemLogger, self).__init__()<br/>        self.logger = logger<br/>        self.buf = ''<br/>        # only tested and works inside pycharm terminal logging to sys.stdout<br/>        # by replacing default terminator newline we force logger to override the output on screen<br/>        # thus giving us a progress depiction in a single line instead of multiple lines<br/>        if suppress_new_line:<br/>            for handler in self.logger.handlers:<br/>                if isinstance(handler, logging.StreamHandler):<br/>                    handler.terminator = ""<br/><br/>    def write(self, buf):<br/>        self.buf = buf.strip('\r\n\t ')<br/><br/>    def flush(self):<br/>        self.logger.log(self.logger.level, '\r' + self.buf)<br/><br/><br/>try:<br/>    logger = SystemLogger.get_logger('DownloadFileHandler', level=logging.WARNING)<br/>    # Download a file to this scripts relative directory and log output to python logger sysout<br/>    DownloadFileHandler.download_file_by_url('https://nodejs.org/dist/v12.13.1/node-v12.13.1-darwin-x64.tar.gz')<br/>except Exception as e:<br/>    print(str(e))</span></pre><h1 id="e53b" class="me mf it bd mg mh nq mj mk ml nr mn mo jz ns ka mq kc nt kd ms kf nu kg mu mv bi translated">向python子流程添加Tqdm</h1><p id="49fa" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">Python子进程用于并且应该用于访问系统命令，例如，如果您在基于Unix的系统上运行，则在您的终端上执行windows终端命令或bash命令。子流程模块允许我们生成流程，连接到它们的输入/输出/错误管道，并获得它们的返回代码。</p><pre class="kk kl km kn gt nc lu nd ne aw nf bi"><span id="0531" class="ng mf it lu b gy nh ni l nj nk"><strong class="lu iu">import </strong>sys<br/><strong class="lu iu">import </strong>subprocess<br/><br/><strong class="lu iu">from </strong>tqdm <strong class="lu iu">import </strong>tqdm<br/><br/><br/><strong class="lu iu">def </strong>create_test_bash_script():<br/>    <em class="lv">"""<br/>    Create a bash script that generates numbers 1 to 1000000<br/>    This is just for illustration purpose to simulate a long running bash command<br/>    """<br/>    </em><strong class="lu iu">with </strong>open(<strong class="lu iu">'hello'</strong>, <strong class="lu iu">'w'</strong>) <strong class="lu iu">as </strong>bash_file:<br/>        bash_file.write(<strong class="lu iu">'''\<br/>    #!/bin/bash<br/>    # Tested using bash version 4.1.5<br/>    for ((i=1;i&lt;=1000000;i++));<br/>    do<br/>        # your-unix-command-here<br/>        echo $i<br/>    done<br/>    '''</strong>)<br/><br/><br/><strong class="lu iu">def </strong>run_task(cmd):<br/><br/>    <strong class="lu iu">try</strong>:<br/>        <em class="lv"># create a default tqdm progress bar object, unit='B' definnes a String that will be used to define the unit of each iteration in our case bytes<br/>        </em><strong class="lu iu">with </strong>tqdm(unit=<strong class="lu iu">'B'</strong>, unit_scale=<strong class="lu iu">True</strong>, miniters=1, desc=<strong class="lu iu">"run_task={}"</strong>.format(cmd)) <strong class="lu iu">as </strong>t:<br/>            <em class="lv"># subprocess.PIPE gets the output of the child process<br/>            </em>process = subprocess.Popen(cmd, shell=<strong class="lu iu">True</strong>, bufsize=1, universal_newlines=<strong class="lu iu">True</strong>, stdout=subprocess.PIPE,<br/>                                       stderr=subprocess.PIPE)<br/><br/>            <em class="lv"># print subprocess output line-by-line as soon as its stdout buffer is flushed in Python 3:<br/>            </em><strong class="lu iu">for </strong>line <strong class="lu iu">in </strong>process.stdout:<br/>                <em class="lv"># Update the progress, since we do not have a predefined iterator<br/>                # tqdm doesnt know before hand when to end and cant generate a progress bar<br/>                # hence elapsed time will be shown, this is good enough as we know<br/>                # something is in progress<br/>                </em>t.update()<br/>                <em class="lv"># forces stdout to "flush" the buffer<br/>                </em>sys.stdout.flush()<br/><br/>            <em class="lv"># We explicitly close stdout<br/>            </em>process.stdout.close()<br/><br/>            <em class="lv"># wait for the return code<br/>            </em>return_code = process.wait()<br/><br/>            <em class="lv"># if return code is not 0 this means our script errored out<br/>            </em><strong class="lu iu">if </strong>return_code != 0:<br/>                <strong class="lu iu">raise </strong>subprocess.CalledProcessError(return_code, cmd)<br/><br/>    <strong class="lu iu">except </strong>subprocess.CalledProcessError <strong class="lu iu">as </strong>e:<br/>        sys.stderr.write(<br/>            <strong class="lu iu">"common::run_command() : [ERROR]: output = {}, error code = {}\n"</strong>.format(e.output, e.returncode))<br/><br/><br/>create_test_bash_script()<br/><br/><em class="lv"># run your terminal command using below<br/></em>run_task(<strong class="lu iu">'chmod 755 hello &amp;&amp; ./hello'</strong>)<br/><br/>run_task(<strong class="lu iu">'xx*3238'</strong>) <em class="lv"># this will fail not a valid command﻿﻿</em></span></pre><p id="07e7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的例子中，我们迭代地传输由您执行的命令生成的输出，并使用它来更新tqdm进度条。因为你没有一个明确的具有预定义长度的迭代器，我们不能预测迭代的结束，因此tqdm将默认使用运行时间作为输出。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nz"><img src="../Images/1ab3454fbb05a3d5c1caf25575399438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVaHUsPzhAdcy4lacqRHJA.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">没有进度条时tqdm运行时间</p></figure><p id="d9ae" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在您不希望终端中有详细输出的情况下，可能需要经过的时间。</p><p id="eefc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">需要注意的是，官方Python文档对使用<strong class="kx iu"> shell=True参数</strong>提出了警告。</p><blockquote class="oa ob oc"><p id="d98d" class="kv kw lv kx b ky kz ju la lb lc jx ld od lf lg lh oe lj lk ll of ln lo lp lq im bi translated">"使用shell=True调用系统外壳程序，如果与不受信任的输入结合使用，可能会有安全隐患"</p></blockquote><h1 id="0377" class="me mf it bd mg mh nq mj mk ml nr mn mo jz ns ka mq kc nt kd ms kf nu kg mu mv bi translated">最后的想法</h1><p id="91e8" class="pw-post-body-paragraph kv kw it kx b ky mw ju la lb mx jx ld le my lg lh li mz lk ll lm na lo lp lq im bi translated">我希望这些例子在你的日常工作中有用。敬请关注更多内容！</p></div></div>    
</body>
</html>