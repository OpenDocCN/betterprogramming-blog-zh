<html>
<head>
<title>Write Cleaner Code by Using JavaScript Destructuring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript析构编写更简洁的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-cleaner-code-by-using-javascript-destructuring-cd6b55c25bac?source=collection_archive---------4-----------------------#2020-07-17">https://betterprogramming.pub/write-cleaner-code-by-using-javascript-destructuring-cd6b55c25bac?source=collection_archive---------4-----------------------#2020-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="050c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过在JavaScript中析构对象和数组，增加代码的清晰度并降低代码的复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce7d5e05a55dffc800779415b8c18747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-mNn0rVcSdzJ4FZq_Oj9w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="2ba3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">析构是我最喜欢的JavaScript工具之一。简单地说，析构允许你把一个复杂的结构(比如一个数组或者一个对象)分解成更简单的部分，尽管还有更多。</p><p id="10d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="9840" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，一些人已经使用这个功能有一段时间了——可能是在构建React应用程序的时候——但他们并不太理解它。对于其他人来说，可能是第一次。因此，我将从头到尾指导您完成这个过程，以便在本文结束时我们都有相同的理解水平。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d5d8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解构对象</h1><p id="3e49" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在上面的例子中，所有的魔法都发生在下面的代码行中:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9c17" class="nf me it nb b gy ng nh l ni nj">const { title, rating, author: { name } } = article</span></pre><p id="b0ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在赋值的左边有这样的括号可能有点奇怪，但是这就是我们告诉JavaScript我们正在析构一个对象的方式。</p><p id="e40b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过析构对象，您可以在任意深度绑定到对象的不同属性。让我们从一个更简单的例子开始:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e9c4" class="nf me it nb b gy ng nh l ni nj">const me = {<br/>  name: "Juan"<br/>}</span><span id="1b5d" class="nf me it nb b gy nk nh l ni nj">const { name } = me</span></pre><p id="2171" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们声明了一个名为<code class="fe nl nm nn nb b">name</code>的变量，它将从对象<code class="fe nl nm nn nb b">me</code>中同名的属性初始化，这样当我们评估<code class="fe nl nm nn nb b">name</code>的值时，我们得到<code class="fe nl nm nn nb b">Juan</code>。厉害！这同样适用于任何深度。回到我们的例子:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4831" class="nf me it nb b gy ng nh l ni nj">const { title, rating, author: { name } } = article</span></pre><p id="c639" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe nl nm nn nb b">title</code>和<code class="fe nl nm nn nb b">rating</code>，和我们已经解释过的完全一样。但是在<code class="fe nl nm nn nb b">author</code>中，事情就有点不一样了。当我们到达一个属性，或者是一个对象，或者是一个数组，我们可以选择是创建一个引用了<code class="fe nl nm nn nb b">article.author</code>对象的变量<code class="fe nl nm nn nb b">author</code>，还是进行一个深度的析构并立即访问内部对象的属性。</p><p id="d4ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">访问对象属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="10a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进行深度或嵌套的析构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5db5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等等，什么？如果我析构了<code class="fe nl nm nn nb b">author</code>，为什么没有定义？其实挺简单的。当我们要求JavaScript也析构<code class="fe nl nm nn nb b">author</code>对象时，绑定本身并没有被创建，相反我们可以访问我们选择的所有<code class="fe nl nm nn nb b">author</code>属性。所以请永远记住这一点。</p><p id="3777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">传播算子(<code class="fe nl nm nn nb b">…</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="a74f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们可以使用spread操作符<code class="fe nl nm nn nb b">...</code>来创建一个具有所有未被析构的属性的对象。</p><p id="9d2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有兴趣了解更多关于spread operator的信息，请查看我的文章。</p><h2 id="dd77" class="nf me it bd mf np nq dn mj nr ns dp mn lh nt nu mp ll nv nw mr lp nx ny mt nz bi translated">重命名属性</h2><p id="bb05" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">析构的一个很好的特性是能够为变量选择一个不同的名字来作为我们要提取的属性。让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="93e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过在属性上使用<code class="fe nl nm nn nb b">:</code>，我们可以为它提供一个新的名称(在我们的例子中是<code class="fe nl nm nn nb b">newName</code>)。然后我们可以在代码中访问这个变量。需要注意的是，具有原始属性<code class="fe nl nm nn nb b">name</code>的变量不会被定义。</p><h2 id="79ee" class="nf me it bd mf np nq dn mj nr ns dp mn lh nt nu mp ll nv nw mr lp nx ny mt nz bi translated">缺少属性</h2><p id="902e" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">那么，如果我们试图析构一个没有在对象中定义的属性，会发生什么呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="63d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，用值<code class="fe nl nm nn nb b">undefined</code>创建变量。</p><h2 id="9a6c" class="nf me it bd mf np nq dn mj nr ns dp mn lh nt nu mp ll nv nw mr lp nx ny mt nz bi translated">默认值</h2><p id="9518" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">扩展缺失的属性，当属性不存在时，可以分配一个默认值。让我们来看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="7694" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是给我们的析构对象赋值默认值的例子。仅当属性为<code class="fe nl nm nn nb b">undefined</code>时，才会分配默认值。例如，如果属性的值是<code class="fe nl nm nn nb b">null</code>或<code class="fe nl nm nn nb b">string</code>，则不会分配默认值，但会分配属性的实际值。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="daaa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">析构数组和迭代</h1><p id="b25d" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">我们已经看到了一些析构对象的例子，但是同样的例子也适用于一般的数组或可迭代对象。让我们从一个例子开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4a6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们需要析构一个数组时，我们需要使用<code class="fe nl nm nn nb b">[]</code>而不是<code class="fe nl nm nn nb b">{}</code>，我们可以用不同的变量映射数组的每个位置。但是有一些好的技巧。</p><h2 id="d0bd" class="nf me it bd mf np nq dn mj nr ns dp mn lh nt nu mp ll nv nw mr lp nx ny mt nz bi translated">跳过元素</h2><p id="4e5f" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">通过使用<code class="fe nl nm nn nb b">,</code>操作符，我们可以从iterable中跳过一些元素，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="5085" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意在<code class="fe nl nm nn nb b">,</code>之间留一个空格是如何跳过元素的。这很微妙，但对结果有很大的影响。</p><p id="39fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你还能做什么？您也可以使用展开运算符<code class="fe nl nm nn nb b">...</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="f195" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，<code class="fe nl nm nn nb b">z</code>将获取<code class="fe nl nm nn nb b">b</code>之后的所有值作为数组。或者你有一个更具体的需求，你想析构数组中的特定位置。没问题。JavaScript涵盖了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="105a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们把一个数组当作一个对象来析构，我们可以把索引当作属性来使用，从而访问数组中的任何位置。</p><h2 id="491c" class="nf me it bd mf np nq dn mj nr ns dp mn lh nt nu mp ll nv nw mr lp nx ny mt nz bi translated">缺少属性</h2><p id="d31e" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">与对象一样，也可以为数组中未定义的元素设置默认值。让我们来看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="2fcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当析构数组时，也可以为<code class="fe nl nm nn nb b">undefined</code>属性设置默认值。然而，当我们有扩展操作符<code class="fe nl nm nn nb b">...</code>时，不可能设置默认值。在<code class="fe nl nm nn nb b">undefined</code>的情况下，它将返回一个空数组。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8398" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">交换变量</h1><p id="6ab1" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">这是一个有趣的析构用例。两个变量可以在一个表达式中交换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="38ed" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用计算的属性进行析构</h1><p id="c1c6" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">直到现在，任何时候我们想要析构一个对象的属性或者一个iterable的元素，我们都使用静态键。如果我们想要动态键(像存储在变量中的那些)，我们需要使用计算属性。</p><p id="4b61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="91e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很棒，对吧？通过在<code class="fe nl nm nn nb b">[]</code>之间使用一个变量，我们可以在赋值之前评估它的值。因此，可以进行动态析构，尽管必须为这个新变量提供一个名称。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4251" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">析构函数参数</h1><p id="cc6f" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">析构变量可以放在我们可以声明变量的任何地方(例如，通过使用<code class="fe nl nm nn nb b">let</code>、<code class="fe nl nm nn nb b">const</code>或<code class="fe nl nm nn nb b">var</code>)，但是也可以析构函数参数。下面是这个概念的一个简单例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4d99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非常简洁优雅。此外，我们之前讨论的所有规则都适用。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7d97" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="ca00" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">析构在开始时可能看起来很笨拙，但是一旦你习惯了，就没有回头路了。它真的可以帮助你的代码更具可读性，这是一个很好的概念。</p><p id="4142" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你知道在导入模块时也可以使用析构吗？看看我关于这个话题的文章。</p><p id="e8ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！我希望你喜欢它。</p></div></div>    
</body>
</html>