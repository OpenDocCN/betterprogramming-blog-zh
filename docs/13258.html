<html>
<head>
<title>Testing a Django Application With Pytest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pytest测试Django应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-a-django-application-with-pytest-3615df7e81f8?source=collection_archive---------3-----------------------#2022-08-11">https://betterprogramming.pub/testing-a-django-application-with-pytest-3615df7e81f8?source=collection_archive---------3-----------------------#2022-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7cb6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Pytest向Django polls应用程序添加测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/43137c73ea138a6a3ae3d28833543ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlzCIp72zOUPHLBO__eZGA.png"/></div></figure><h1 id="781f" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">议程</h1><p id="d112" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我们将学习如何在Django中使用<code class="fe me mf mg mh b">pytest</code>。</p><p id="3f54" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们将为Django polls应用程序编写测试。</p><p id="2833" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">Polls应用程序是Django的官方入门教程。因此，我们选择它而不是别的。</p><h1 id="df85" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">设置</h1><p id="3363" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们用的是Python 3.10和Django 4.0。</p><p id="145d" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">民意测验教程由六部分组成。我们将为每个部分添加测试。</p><p id="98fa" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">下面介绍一下完成<a class="ae mn" href="https://docs.djangoproject.com/en/4.0/intro/tutorial01/" rel="noopener ugc nofollow" target="_blank"> part 1 </a>后的第一个测试。</p><p id="f276" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们已经建立了一个Github库来跟踪我们的代码。我们在<a class="ae mn" href="https://github.com/akshar-raaj/polls/commit/58b135c814591bdb528618a23061628cab821499" rel="noopener ugc nofollow" target="_blank">提交</a>中完成第1部分。</p><p id="1f5a" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">现在，您应该已经完成了本教程的第1部分，并且应该能够访问它了。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="ca0a" class="ms kr it mh b gy mt mu l mv mw">http://localhost:8000/polls/</span></pre><p id="811e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们需要安装<code class="fe me mf mg mh b">pytest</code>来运行测试。发出以下命令:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="61ff" class="ms kr it mh b gy mt mu l mv mw">$ pip install pytest</span></pre><p id="09e8" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">注意<code class="fe me mf mg mh b">$</code>是命令提示符，实际命令是<code class="fe me mf mg mh b">pip install pytest</code>。</p><p id="ce9f" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">有了这个，你应该可以从终端发出<code class="fe me mf mg mh b">pytest</code>命令。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="3986" class="ms kr it mh b gy mt mu l mv mw">$ pytest</span></pre><p id="50bb" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">它应该给出类似于以下内容的输出:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="8c3f" class="ms kr it mh b gy mt mu l mv mw">=============================================================<br/>test session starts =============================================================<br/><br/>platform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0<br/><br/>rootdir: /Users/akshar/Play/Python/Djangos/mysite<br/><br/>collected 0 items<br/><br/><br/>=============================================================<br/>no tests ran in 0.00s =============================================================</span></pre><p id="f50a" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们需要为pytest安装插件<code class="fe me mf mg mh b">pytest-django</code>，以便能够运行Django应用程序的测试。发出以下命令:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="9584" class="ms kr it mh b gy mt mu l mv mw">$ pip install pytest-django</span></pre><p id="85cf" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">在pytest可以从Django项目运行测试之前，它需要设置Django项目。因此它需要知道django设置模块的路径。</p><p id="2c6c" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">这可以通过添加环境变量<code class="fe me mf mg mh b">DJANGO_SETTINGS_MODULE</code>来设置。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="6878" class="ms kr it mh b gy mt mu l mv mw">$ export DJANGO_SETTINGS_MODULE=mysite.settings</span></pre><p id="7fa4" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们通过发出命令<code class="fe me mf mg mh b">pytest</code>来尝试运行测试。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="4430" class="ms kr it mh b gy mt mu l mv mw">$ pytest</span></pre><p id="ef71" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">它应该输出如下所示的内容:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="6bae" class="ms kr it mh b gy mt mu l mv mw">=============================================================<br/>test session starts =============================================================<br/><br/>platform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0<br/><br/>django: settings: mysite.settings (from env)<br/><br/>rootdir: /Users/akshar/Play/Python/Djangos/mysite<br/><br/>plugins: django-4.5.2<br/><br/>collected 0 items<br/><br/><br/>===============================================================<br/>warnings summary ===============================================================<br/><br/>../../../../.pyenv/versions/3.10.4/envs/pyenv3104/lib/python3.10/site-packages/django/conf/__init__.py:229<br/><br/>      /Users/akshar/.pyenv/versions/3.10.4/envs/pyenv3104/lib/python3.10/site-packages/django/conf/__init__.py:229: RemovedInDjango50Warning: The USE_L10N setting is deprecated. Starting with Django 5.0, localized formatting of data will always be enabled. For example Django will display numbers and dates using the format of the current locale.<br/><br/>warnings.warn(USE_L10N_DEPRECATED_MSG, RemovedInDjango50Warning)<br/><br/><br/>-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html<br/><br/>===============================================================<br/>1 warning in 0.06s ===============================================================</span></pre><p id="84c9" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">您会注意到输出包含<code class="fe me mf mg mh b">django-4.5.2</code>。因此<code class="fe me mf mg mh b">pytest</code>意识到我们正在Django项目中运营。</p><p id="8459" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">您还会注意到输出有<code class="fe me mf mg mh b">django: settings: mysite.settings</code>(来自env)。</p><p id="bd06" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">因此<code class="fe me mf mg mh b">pytest</code>能够找到Django设置模块，并且应该能够设置Django项目。</p><p id="9225" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">但是，从输出中收集的0个项目来看，似乎没有运行任何测试。</p><p id="9bf4" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们添加第一个测试。Django会在添加应用程序投票时创建一个文件<code class="fe me mf mg mh b">polls/tests.py</code>。让我们把测试放在同一个文件中。</p><p id="91f1" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">下面我们给<code class="fe me mf mg mh b">polls/tests.py</code>补充一下内容。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="ad50" class="ms kr it mh b gy mt mu l mv mw">def test_one():<br/><br/>    assert 1 == 1</span></pre><p id="b226" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">这里没什么有趣的，因为我们只是断言两个相等的值相等。目前的目标是确保<code class="fe me mf mg mh b">pytest</code>能够找到写在这个文件中的测试。一旦我们能够做到这一点，我们将增加更多有趣的测试。</p><p id="c4bb" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">通过发出命令<code class="fe me mf mg mh b">pytest</code>尝试再次执行测试。您仍会看到收集的0件物品。这是因为<code class="fe me mf mg mh b">pytest</code>测试发现期望测试文件名为<code class="fe me mf mg mh b">test_*.py</code>或<code class="fe me mf mg mh b">*_test.py</code>。它找不到<code class="fe me mf mg mh b">tests.py</code>。</p><p id="31bc" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">参见<code class="fe me mf mg mh b">pytest</code>测试发现规则<a class="ae mn" href="https://pytest-django.readthedocs.io/en/latest/faq.html#my-tests-are-not-being-found-why" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="2a83" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">因此，我们需要提示<code class="fe me mf mg mh b">pytest</code>也在Django测试文件中寻找测试。</p><p id="ba30" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">在项目的根目录下添加一个文件<code class="fe me mf mg mh b">pytest.ini</code>，内容如下:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="4ff6" class="ms kr it mh b gy mt mu l mv mw">[pytest]<br/><br/>python_files = tests.py</span></pre><p id="4f6d" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">再次发出<code class="fe me mf mg mh b">pytest</code>命令。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="241a" class="ms kr it mh b gy mt mu l mv mw">$ pytest</span></pre><p id="548d" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">输出应该类似于:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="8777" class="ms kr it mh b gy mt mu l mv mw">=============================================================<br/>test session starts =============================================================<br/><br/>platform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0<br/><br/>django: settings: mysite.settings (from env)<br/><br/>rootdir: /Users/akshar/Play/Python/Djangos/mysite, configfile: pytest.ini<br/><br/>plugins: django-4.5.2<br/><br/>collected 1 item<br/><br/>polls/tests.py .</span></pre><p id="8f01" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">从输出中可以明显看出，polls' <code class="fe me mf mg mh b">tests.py</code>由<code class="fe me mf mg mh b">pytest</code>读取，因此收集了1个测试。</p><p id="65e3" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">可以在<a class="ae mn" href="https://github.com/akshar-raaj/polls/commit/ddae02782c6a225013c9604429838a902b1e00c2" rel="noopener ugc nofollow" target="_blank">提交</a>时检查运行所需的更改。</p><h1 id="7e1c" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">第1部分测试</h1><p id="708e" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本教程的第1部分介绍了URL和相应的视图。点击端点/轮询/返回状态代码为200的响应。</p><p id="fa34" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们应该为这个视图添加一个测试，它应该断言调用这个URL确实会返回200状态代码。</p><p id="ece6" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">修改polls/tests.py以删除之前的测试，即<code class="fe me mf mg mh b">test_one</code>。相反，添加另一个名为<code class="fe me mf mg mh b">test_polls</code>的测试函数，如下所示:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="6225" class="ms kr it mh b gy mt mu l mv mw">from django.test import Client<br/><br/><br/><br/>def test_polls():<br/><br/>    client = Client()<br/><br/>    response = client.get('/polls/')<br/><br/>    assert response.status_code == 200</span></pre><p id="d697" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们重新进行测试。</p><p id="214d" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">您应该看到测试通过，并有以下类型的输出:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="b3d0" class="ms kr it mh b gy mt mu l mv mw">=============================================================<br/>test session starts<br/>=============================================================<br/><br/>platform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0<br/><br/>django: settings: mysite.settings (from env)<br/><br/>rootdir: /Users/akshar/Play/Python/Djangos/mysite, configfile: pytest.ini<br/><br/>plugins: django-4.5.2<br/><br/>collected 1 item<br/><br/><br/><br/>polls/tests.py .<br/>===========================================================<br/>1 passed, 1 warning in 0.03s<br/>===========================================================</span></pre><p id="cfad" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们假设某个其他开发人员修改了相应的视图，即<code class="fe me mf mg mh b">polls/views.py</code>中的索引，并将响应的状态代码设为201。让我们模仿这种变化:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="acd5" class="ms kr it mh b gy mt mu l mv mw">def index(request):<br/><br/>    return HttpResponse("Hello, world. You're at the polls index.", status_code=201)</span></pre><p id="6b1e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">再次执行测试会导致测试失败。因此，测试是为了防止我们意外的变化。</p><p id="52f1" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们恢复索引视图中引入的更改，以确保测试再次通过。</p><p id="ff02" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">相关提交在这里是<a class="ae mn" href="https://github.com/akshar-raaj/polls/commit/6c248e9821670a2c35bc8027b584c87c13e1ce7d" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="bcde" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">第2部分测试</h1><p id="e8ac" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您应该已经完成了教程的第2部分<a class="ae mn" href="https://docs.djangoproject.com/en/4.0/intro/tutorial02/" rel="noopener ugc nofollow" target="_blank">才能从这里继续。</a></p><p id="bf4f" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">本教程的第2部分介绍了:</p><ul class=""><li id="3cd0" class="mx my it lk b ll mi lo mj lr mz lv na lz nb md nc nd ne nf bi translated">模型</li><li id="1868" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">管理</li></ul><p id="476a" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们想要添加一个测试来确保模型<code class="fe me mf mg mh b">Question</code>上的方法<code class="fe me mf mg mh b">was_published_recently</code>的行为符合预期。</p><p id="178f" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们在<code class="fe me mf mg mh b">polls/tests.py</code>中添加以下测试。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="0ac3" class="ms kr it mh b gy mt mu l mv mw">import pytest<br/><br/>import datetime<br/><br/>from django.utils import timezone<br/><br/><br/>@pytest.mark.django_db<br/><br/>def test_model_question():<br/><br/>    pub_date = timezone.now()<br/><br/>    question = Question.objects.create(question_text="How's the weather?",<br/><br/>                                       pub_date=pub_date)<br/><br/>    assert question.was_published_recently() is True</span></pre><p id="19dc" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">再次执行测试。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="202a" class="ms kr it mh b gy mt mu l mv mw">$ pytest</span></pre><p id="6408" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">您会注意到输出提到现在收集了2个项目。这证明这个新添加的测试也已经被<code class="fe me mf mg mh b">pytest</code>选中。</p><p id="0a95" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们可以在<code class="fe me mf mg mh b">test_model_question</code>中增加一个断言语句来检查<code class="fe me mf mg mh b">was_published_recently</code>是否为<code class="fe me mf mg mh b">False</code>。</p><p id="6faa" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">在<code class="fe me mf mg mh b">test_model_question</code>中添加以下额外语句。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="d835" class="ms kr it mh b gy mt mu l mv mw">pub_date = timezone.now() - datetime.timedelta(days=2)<br/><br/>question = Question.objects.create(question_text="How's the weather?",<br/><br/>                                   pub_date=pub_date)<br/><br/>assert question.was_published_recently() is False</span></pre><p id="da9e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">这个例子介绍了一个名为<code class="fe me mf mg mh b">mark</code>的Pytest特性。点击阅读更多相关信息<a class="ae mn" href="https://docs.pytest.org/en/stable/how-to/mark.html#mark" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2afb" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">相关的提交在这里是<a class="ae mn" href="https://github.com/akshar-raaj/polls/commit/6375b7be7cf4219fd3ade2133d0d232caf696c0a" rel="noopener ugc nofollow" target="_blank">T21。</a></p><h1 id="1acb" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">重构</h1><p id="ac7a" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">目前，我们所有的测试都在同一个文件中。随着我们逐渐添加更多的测试，管理会变得更加困难。因此，将测试分成不同的模块是有意义的。</p><p id="d79c" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们将视图测试保存在文件<code class="fe me mf mg mh b">polls/test_views.py</code>中。和文件<code class="fe me mf mg mh b">polls/test_models.py</code>中的模型测试</p><p id="a686" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们创建这两个文件。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="c8ef" class="ms kr it mh b gy mt mu l mv mw">$ touch polls/test_models.py<br/><br/>$ touch polls/test_views.py</span></pre><p id="34f0" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们从<code class="fe me mf mg mh b">polls/tests.py to polls/test_views.py</code>复制视图测试。<code class="fe me mf mg mh b">polls/test_views.py</code>应该是这样的:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="07b5" class="ms kr it mh b gy mt mu l mv mw">from django.test import Client<br/><br/><br/><br/>def test_polls():<br/><br/>    client = Client()<br/><br/>    response = client.get('/polls/')<br/><br/>    assert response.status_code == 200</span></pre><p id="7b4b" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">类似地，将模型测试复制到<code class="fe me mf mg mh b">polls/test_models.py</code>。它看起来像这样:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="742d" class="ms kr it mh b gy mt mu l mv mw">import pytest<br/><br/>import datetime<br/><br/><br/>from django.utils import timezone<br/><br/><br/>from .models import Question<br/><br/><br/>@pytest.mark.django_db<br/><br/>def test_model_question():<br/><br/>    pub_date = timezone.now()<br/><br/>    question = Question.objects.create(question_text="How's the weather?",<br/><br/>                                       pub_date=pub_date)<br/><br/>    assert question.was_published_recently() is True<br/><br/><br/>    pub_date = timezone.now() - datetime.timedelta(days=2)<br/><br/>    question = Question.objects.create(question_text="How's the weather?",<br/><br/>                                       pub_date=pub_date)<br/><br/>    assert question.was_published_recently() is False</span></pre><p id="0880" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">此外，我们需要修改pytest.ini以确保新的测试文件可以被<code class="fe me mf mg mh b">pytest</code>发现。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="7dfc" class="ms kr it mh b gy mt mu l mv mw">python_files = tests.py test_*.py</span></pre><p id="04c5" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">相关提交在这里是<a class="ae mn" href="https://github.com/akshar-raaj/polls/commit/5ad318134195f0d1f0dce5ccb486723bce3f94cf" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c24e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">你会注意到我们在<code class="fe me mf mg mh b">test_model_question</code>中有两个断言语句。理想情况下，测试应该尽可能的小，并且应该只测试一件事情。因此，我们应该将这个测试分成两个独立的测试函数。</p><p id="0008" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们也可以使用基于类的方法，将两个测试分组在一个类中。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="7c38" class="ms kr it mh b gy mt mu l mv mw">class TestModels():<br/><br/><br/>    @pytest.mark.django_db<br/><br/>    def test_question_published_recently(self):<br/><br/>        pub_date = timezone.now()<br/><br/>        question = Question.objects.create(question_text="How's the weather?",<br/><br/>                                           pub_date=pub_date)<br/><br/>        assert question.was_published_recently() is True<br/><br/><br/><br/>    @pytest.mark.django_db<br/><br/>    def test_question_not_published_recently(self):<br/><br/>        pub_date = timezone.now() - datetime.timedelta(days=2)<br/><br/>        question = Question.objects.create(question_text="How's the weather?",<br/><br/>                                           pub_date=pub_date)<br/><br/>        assert question.was_published_recently() is False</span></pre><p id="a92e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">这看起来比之前的方法干净多了。</p><p id="9e68" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">再次执行测试:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="f7b7" class="ms kr it mh b gy mt mu l mv mw">$ pytest</span></pre><p id="429d" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">您会注意到在输出中收集了3个项目。这里有两个测试来自<code class="fe me mf mg mh b">test_models.py</code>，而一个测试来自<code class="fe me mf mg mh b">test_views.py</code>。</p><p id="124d" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">Pytest还提供了只运行单个模块测试的能力。让我们只运行模型测试，不要查看测试。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="7127" class="ms kr it mh b gy mt mu l mv mw">$ pytest polls/test_models.py</span></pre><h1 id="8781" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">第3部分测试</h1><p id="3a4a" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您应该已经完成了教程的第3部分<a class="ae mn" href="https://docs.djangoproject.com/en/4.0/intro/tutorial03/" rel="noopener ugc nofollow" target="_blank">才能从这里继续。</a></p><p id="c1ba" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">本教程的第3部分介绍了:</p><ul class=""><li id="0e54" class="mx my it lk b ll mi lo mj lr mz lv na lz nb md nc nd ne nf bi translated">视图</li><li id="b9d6" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">姜戈奥姆</li><li id="7243" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">模板</li></ul><p id="cc42" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们添加以下测试。</p><ul class=""><li id="fe7a" class="mx my it lk b ll mi lo mj lr mz lv na lz nb md nc nd ne nf bi translated">索引视图必须只返回最近的5个问题</li><li id="ccfa" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">详细视图为无效id返回404响应。</li><li id="6e22" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">详细视图为有效id返回200响应。</li></ul><p id="1aca" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">因为我们想要对多个视图进行测试，所以将它们分组到一个类下是有意义的。</p><p id="432b" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">因此，让我们将之前的测试<code class="fe me mf mg mh b">test_polls</code>移到一个名为<code class="fe me mf mg mh b">TestViews</code>的类中。此外，我们应该将其重命名为<code class="fe me mf mg mh b">test_index</code>,因为视图的名称是一个索引。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="d313" class="ms kr it mh b gy mt mu l mv mw">import pytest</span><span id="e91e" class="ms kr it mh b gy nl mu l mv mw">from django.test import Client<br/></span><span id="2e74" class="ms kr it mh b gy nl mu l mv mw">class TestViews():<br/></span><span id="a590" class="ms kr it mh b gy nl mu l mv mw">    @pytest.mark.django_db</span><span id="034c" class="ms kr it mh b gy nl mu l mv mw">    def test_index(self):</span><span id="db7a" class="ms kr it mh b gy nl mu l mv mw">        client = Client()</span><span id="f2c6" class="ms kr it mh b gy nl mu l mv mw">        response = client.get('/polls/')</span><span id="bbb4" class="ms kr it mh b gy nl mu l mv mw">        assert response.status_code == 200</span></pre><p id="1240" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们添加另一个测试，以确保索引视图只显示最新的5个问题。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="9883" class="ms kr it mh b gy mt mu l mv mw">@pytest.mark.django_db</span><span id="4477" class="ms kr it mh b gy nl mu l mv mw">def test_index_num_questions(self):</span><span id="c22b" class="ms kr it mh b gy nl mu l mv mw">    """</span><span id="b22b" class="ms kr it mh b gy nl mu l mv mw">    This test asserts that latest n questions are shown by the index view.</span><span id="c070" class="ms kr it mh b gy nl mu l mv mw">    :return:</span><span id="48bb" class="ms kr it mh b gy nl mu l mv mw">    """</span><span id="57d3" class="ms kr it mh b gy nl mu l mv mw">    question_texts = [b'first', b'second', b'third', b'fourth', b'fifth', b'sixth']</span><span id="9559" class="ms kr it mh b gy nl mu l mv mw">    for question_text in question_texts:</span><span id="7706" class="ms kr it mh b gy nl mu l mv mw">        pub_date = timezone.now()</span><span id="6d12" class="ms kr it mh b gy nl mu l mv mw">        question = Question.objects.create(question_text=question_text,</span><span id="7d47" class="ms kr it mh b gy nl mu l mv mw">                                           pub_date=pub_date)<br/></span><span id="23df" class="ms kr it mh b gy nl mu l mv mw">        client = Client()</span><span id="99bd" class="ms kr it mh b gy nl mu l mv mw">        response = client.get('/polls/')</span><span id="96ab" class="ms kr it mh b gy nl mu l mv mw">        assert b'first' not in response.content</span><span id="1f0d" class="ms kr it mh b gy nl mu l mv mw">        for question_text in question_texts[1:]:</span><span id="0fd9" class="ms kr it mh b gy nl mu l mv mw">            assert question_text in response.content</span></pre><p id="0d3f" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们创建了六个问题实例。<code class="fe me mf mg mh b">Question</code>“第一个”是最初创建的，因此不是最近5个问题的一部分。因此，它不应该是响应的一部分。</p><p id="4ea0" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们现在要为其他视图添加测试，即详细信息、结果和投票。在这一点上，我们有机会看到参数化测试的使用。</p><p id="a4c6" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们希望确保视图细节、结果和投票返回状态代码200。使用当前的方法，我们将不得不再编写3个测试<code class="fe me mf mg mh b">test_detail</code>、<code class="fe me mf mg mh b">test_results</code>和<code class="fe me mf mg mh b">test_vote</code>。</p><p id="a933" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">它们都只是实例化一个<code class="fe me mf mg mh b">Client</code>，执行<code class="fe me mf mg mh b">client.get(url)</code>，并断言状态代码是200。</p><p id="3c77" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">这增加了重复代码。为了避免重复的代码，我们可以只添加一个测试并用<code class="fe me mf mg mh b">pytest.mark.parametrize</code>来修饰它。</p><p id="5bac" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">让我们添加以下测试函数:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="e58f" class="ms kr it mh b gy mt mu l mv mw">@pytest.mark.django_db</span><span id="7f0c" class="ms kr it mh b gy nl mu l mv mw">@pytest.mark.parametrize('url_fragment', ['', 'results/', 'vote/'])</span><span id="53a1" class="ms kr it mh b gy nl mu l mv mw">def test_detail_views(self, url_fragment):</span><span id="5379" class="ms kr it mh b gy nl mu l mv mw">    pub_date = timezone.now()</span><span id="e825" class="ms kr it mh b gy nl mu l mv mw">    question = Question.objects.create(question_text='How you doin? &lt;Joey style&gt;',</span><span id="e0ee" class="ms kr it mh b gy nl mu l mv mw">                                       pub_date=pub_date)</span><span id="237b" class="ms kr it mh b gy nl mu l mv mw">     client = Client()</span><span id="24cc" class="ms kr it mh b gy nl mu l mv mw">     response = client.get('/polls/{}/{}'.format(question.pk, url_fragment,))</span><span id="0859" class="ms kr it mh b gy nl mu l mv mw">     assert response.status_code == 200</span></pre><p id="434c" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">我们引入了一个新的pytest装饰器，名为pytest . mark . parameterize。</p><ul class=""><li id="3c3d" class="mx my it lk b ll mi lo mj lr mz lv na lz nb md nc nd ne nf bi translated"><code class="fe me mf mg mh b">test_detail_views</code>将被调用三次。</li><li id="f5a5" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">在第一次调用中，<code class="fe me mf mg mh b">url_fragment</code>将作为空字符串传递。</li><li id="4a96" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">在第二次调用中，<code class="fe me mf mg mh b">url_fragment</code>将作为<code class="fe me mf mg mh b">results/</code>传递。在这个测试调用中，<code class="fe me mf mg mh b">url /polls/&lt;question_pk&gt;/results/</code>将与<code class="fe me mf mg mh b">client.get</code>一起使用。</li><li id="24ca" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">在第三次调用中，<code class="fe me mf mg mh b">url_fragment</code>将作为<code class="fe me mf mg mh b">vote/</code>传递。</li></ul><p id="ca60" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">因此，可以通过编写一个测试方法来测试所有的3个视图。</p><p id="840c" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">进行测试。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="c79e" class="ms kr it mh b gy mt mu l mv mw">$ pytest</span></pre><p id="4293" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">之前的测试计数是4。您会注意到输出中的测试计数现在已经从4增加到7。</p><p id="ca33" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">因此，<code class="fe me mf mg mh b">test_detail_views</code>用不同的参数被调用了三次。每次调用都被视为一次单独的测试。</p><p id="cc5e" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">与这些更改相关的提交在这里是<a class="ae mn" href="https://github.com/akshar-raaj/polls/commit/7272e4cd80535f32bac3d94dc05c36df0bfe5aa6" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="4c82" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">固定装置</h1><p id="1ac1" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，我们还没有使用过夹具。</p><p id="af21" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">在多种情况下，某些东西是经常需要的。在我们的例子中，我们需要一个客户端来测试任何视图。</p><p id="75b7" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">Pytest有一个fixture机制，这样经常需要的东西可以被定义为fixture，并且可以在任何函数中使用。</p><p id="1328" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated"><code class="fe me mf mg mh b">test_index</code>可以修改成这样:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="e4dc" class="ms kr it mh b gy mt mu l mv mw">@pytest.mark.django_db</span><span id="6658" class="ms kr it mh b gy nl mu l mv mw">def test_index(self, client):</span><span id="64c4" class="ms kr it mh b gy nl mu l mv mw">    response = client.get('/polls/')</span><span id="78a4" class="ms kr it mh b gy nl mu l mv mw">    assert response.status_code == 200</span></pre><p id="f5a7" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">你会注意到我们如何从方法体中移除了<code class="fe me mf mg mh b">client = Client()</code>，并在方法签名中添加了一个名为client的参数。</p><p id="f51a" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated"><code class="fe me mf mg mh b">pytest-django</code>提供了一个名为client的fixture。无论何时任何fixture作为一个参数被添加到测试方法签名中，<code class="fe me mf mg mh b">pytest</code>足够聪明地在测试方法调用期间传递那个fixture。</p><p id="09a0" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">事实上，我们可以从所有测试方法中移除客户端的实例化，而使用fixture。</p><p id="a6d0" class="pw-post-body-paragraph li lj it lk b ll mi ju ln lo mj jx lq lr mk lt lu lv ml lx ly lz mm mb mc md im bi translated">与这些更改一起提交的相关代码在这里是<a class="ae mn" href="https://github.com/akshar-raaj/polls/commit/4652eaa1eda7f01da16e18d034e79b2d8ba1cda7" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="4cdb" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">概述</h1><ul class=""><li id="3d3d" class="mx my it lk b ll lm lo lp lr nm lv nn lz no md nc nd ne nf bi translated">我们熟悉以下内容:</li><li id="cb52" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">Django项目中的<code class="fe me mf mg mh b">pytest</code>入门</li><li id="153e" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">理解<code class="fe me mf mg mh b">pytest.ini</code>文件以配置pytest</li><li id="f0a3" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">熟悉<code class="fe me mf mg mh b">pytest</code>标志</li><li id="d38e" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">引入参数化测试</li><li id="13bb" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">引入了<code class="fe me mf mg mh b">pytest</code>夹具</li></ul></div></div>    
</body>
</html>