<html>
<head>
<title>Rust Basics: Structs, Methods, and Traits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust基础:结构、方法和特征</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-basics-structs-methods-and-traits-bb4839cd57bd?source=collection_archive---------6-----------------------#2020-01-22">https://betterprogramming.pub/rust-basics-structs-methods-and-traits-bb4839cd57bd?source=collection_archive---------6-----------------------#2020-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9687" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速浏览Rust，用简单的例子来演示概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/63bc162f8396bd8589c33a84dec14aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQsEqRx5QHTONZ9UZ0YYTA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马克斯·尼尔森</a>在<a class="ae kv" href="https://unsplash.com/s/photos/how?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4e58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一块的代码可在<a class="ae kv" href="https://github.com/abhirockzz/learning-rust" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6b49" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结构</h1><p id="2452" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Rust中的一个<code class="fe mw mx my mz b">struct</code>和Java中的一个<code class="fe mw mx my mz b">Class</code>或者<a class="ae kv" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>中的一个<code class="fe mw mx my mz b">struct</code>是一样的。它是一个命名的类型，你可以给它分配状态<em class="na"> </em>(属性/字段)和行为(方法/函数)。</p><p id="b3a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个带有字段的<code class="fe mw mx my mz b">struct</code>:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="0818" class="nf ma iq mz b gy ng nh l ni nj">struct Programmer {<br/>    email: String,<br/>    github: String,<br/>    blog: String,<br/>}</span></pre><p id="7e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要实例化一个<code class="fe mw mx my mz b">Programmer</code>，你可以简单地:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="768c" class="nf ma iq mz b gy ng nh l ni nj">let pg1 = Programmer {<br/>        email: String::from("abhirockzz@gmail.com"),<br/>        github: String::from("https://github.com/abhirockzz"),<br/>        blog: String::from("https://dev.to/abhirockzz"),<br/>    };</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f58c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">方法</h1><p id="6dd8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">方法是与给定类型关联的行为。方法中的第一个参数总是<code class="fe mw mx my mz b">self</code>，它表示方法被调用的实例。</p><p id="f55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们给<code class="fe mw mx my mz b">Programmer</code>加个方法吧。为此，我们需要使用一个<code class="fe mw mx my mz b">impl</code>模块:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="620f" class="nf ma iq mz b gy ng nh l ni nj">impl Programmer {<br/>    fn is_same_as(&amp;self, other: Programmer) -&gt; bool {<br/>        return self.email == other.email;<br/>    }<br/>}</span></pre><p id="dafa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">is_same_as</code>方法接受对在(<code class="fe mw mx my mz b">&amp;self</code>)和另一个<code class="fe mw mx my mz b">Programmer</code>实例上调用的实例的引用。要调用它，创建一个<code class="fe mw mx my mz b">Programmer</code> ( <code class="fe mw mx my mz b">pg2</code>)的另一个实例，并将<code class="fe mw mx my mz b">pg1</code>与它进行比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="0565" class="nf ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">自我类型</h2><p id="6699" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们使用<code class="fe mw mx my mz b">&amp;self</code>作为<code class="fe mw mx my mz b">is_same_as</code>的参数。这样，我们将只传递一个引用，函数将<em class="na">而不是</em>拥有该值——只借用它(参见<a class="ae kv" href="https://medium.com/better-programming/rust-ownership-and-borrowing-9cf7f081ade0" rel="noopener"> Rust:所有权和借用</a>)。也可以使用<code class="fe mw mx my mz b">self</code>和<code class="fe mw mx my mz b">&amp;mut self</code>。</p><p id="1134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe mw mx my mz b">self</code>，但是要小心它会将所有权传递给函数。我们来看看这个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="018d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以像使用<code class="fe mw mx my mz b">pg2.details();</code>一样使用<code class="fe mw mx my mz b">pg2</code>实例来调用它，您应该得到:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="a3da" class="nf ma iq mz b gy ng nh l ni nj">Email: abhirockzz@gmail.com,<br/>GitHub repo: https://github.com/abhirockzz,<br/>Blog: <a class="ae kv" href="https://medium.com/@abhishek1987" rel="noopener">https://medium.com/@abhishek1987</a></span></pre><p id="91ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您试图再次使用<code class="fe mw mx my mz b">pg2</code>(例如<code class="fe mw mx my mz b">pg2.is_same_as(&amp;pg1);</code>)，您将得到一个编译器错误:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="c864" class="nf ma iq mz b gy ng nh l ni nj">error[E0382]: borrow of moved value: `pg2`</span></pre><p id="2666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想改变<code class="fe mw mx my mz b">Programmer</code>实例，可以如下使用<code class="fe mw mx my mz b">&amp;mut self</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="921a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您没有将变量(<code class="fe mw mx my mz b">pg3</code>)标记为<code class="fe mw mx my mz b">mut</code>(可变)，您将得到一个编译器错误:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="7e52" class="nf ma iq mz b gy ng nh l ni nj">error[E0596]: cannot borrow `pg2` as mutable, as it is not declared as mutable</span></pre><h2 id="e408" class="nf ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">与结构相关的其他函数</h2><p id="a210" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您可以添加与<code class="fe mw mx my mz b">struct</code>的实例相关联的<code class="fe mw mx my mz b">associated functions</code>——可以把它想象成Java中的<code class="fe mw mx my mz b">static</code>方法。这些通常用作构造函数。</p><p id="e314" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与Java中构造函数的使用方式不同，但类似于Go方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8ed9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以这样使用它:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="3b52" class="nf ma iq mz b gy ng nh l ni nj">let pg3 = Programmer::new(<br/>        String::from("abhirockzz@gmail.com"),<br/>        String::from("https://github.com/abhirockzz"),<br/>        String::from("https://medium.com/@abhishek1987"),<br/>    );</span></pre><p id="d1ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们使用<code class="fe mw mx my mz b">::</code> ( <code class="fe mw mx my mz b">Programmer::new</code>)来访问<code class="fe mw mx my mz b">struct</code>(本例中是一个函数)的<code class="fe mw mx my mz b">associated</code>成员。</p><p id="cf60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同一个<code class="fe mw mx my mz b">struct</code>可以使用不同的<code class="fe mw mx my mz b">impl</code>模块。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a6f3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">特征</h1><p id="1d69" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Rust中的<code class="fe mw mx my mz b">Trait</code>类似于Java等其他语言中的<code class="fe mw mx my mz b">Interface</code>。它们帮助定义一组或多组行为，这些行为可以由不同的类型以它们自己独特的方式进行<code class="fe mw mx my mz b">implemented</code>。</p><p id="badd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust中实现<code class="fe mw mx my mz b">Trait</code>的方式与Java中的方式非常相似。在Java中，可以使用<code class="fe mw mx my mz b">implements</code>关键字，而Rust使用<code class="fe mw mx my mz b">impl</code>。</p><p id="43e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口和实现它的类型之间有显式的关联。这与Go有很大的不同，在Go中你不需要声明你正在实现哪个接口——如果你已经实现了所需的行为，编译器会很高兴的。</p><p id="f5b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从定义一个<code class="fe mw mx my mz b">Trait</code>开始。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="9173" class="nf ma iq mz b gy ng nh l ni nj">trait PrettyPrint {<br/>    fn pretty_print(&amp;self);<br/>}</span></pre><p id="f269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并付诸实施。</p><p id="816c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要担心例子的细节，只关注关键部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4b1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很简单——使用<code class="fe mw mx my mz b">impl</code>关键字，后跟您正在实现的特征，并在<code class="fe mw mx my mz b">for</code>关键字后包含实现该特征的类型。现在，您可以像使用任何其他方法一样使用它:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="4bf1" class="nf ma iq mz b gy ng nh l ni nj">let pg = Programmer::new(...);<br/>pg.pretty_print();</span></pre><h2 id="a94a" class="nf ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">使用一个库特征</h2><p id="72e5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Rust的标准库提供了许多你可以使用的<code class="fe mw mx my mz b">Trait</code>。让我们实现<code class="fe mw mx my mz b"><a class="ae kv" href="https://doc.rust-lang.org/std/fmt/trait.Display.html" rel="noopener ugc nofollow" target="_blank">std::fmt::Display</a></code>特征。这是面向用户的输出，例如，我们可以使用<code class="fe mw mx my mz b">println!</code>宏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="505e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要担心实现的细节和类型，比如<code class="fe mw mx my mz b">std::fmt::Formatter</code>等。现在，只要理解你可以从Rust <code class="fe mw mx my mz b">std::fmt</code>模块中实现<code class="fe mw mx my mz b">Display</code>特征。</p><p id="32dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，您可以像这样使用带有<code class="fe mw mx my mz b">println!</code>的<code class="fe mw mx my mz b">Programmer</code>的实例。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="2457" class="nf ma iq mz b gy ng nh l ni nj">let another_pg = Programmer::new(...);<br/>println!("programmer details: {}", another_pg);</span><span id="5f5f" class="nf ma iq mz b gy nx nh l ni nj">//output:<br/>programmer details: (abhirockzz@gmail.com, https://github.com/abhirockzz, <a class="ae kv" href="https://medium.com/@abhishek1987)" rel="noopener">https://medium.com/@abhishek1987)</a></span></pre><h2 id="c704" class="nf ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">免费赠品</h2><p id="0840" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Rust提供了很多有用的特性，你可以免费使用！这意味着你不需要显式地实现它们(如果你想的话，你当然可以)。方法是使用<code class="fe mw mx my mz b">#[derive]</code>属性。</p><p id="fb7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe mw mx my mz b">attribute</code>只是一段元数据，你可以把它应用于结构等等。它们让我想起了Java注释。</p><p id="ebfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子。我们可以在<code class="fe mw mx my mz b">Programmer</code>上应用<code class="fe mw mx my mz b">std::fmt::Debug</code>特征，然后和<code class="fe mw mx my mz b">println!</code>一起使用。</p><p id="dfac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类似于我们对<code class="fe mw mx my mz b">Display</code>所做的，但是关键的区别在于它不可能<code class="fe mw mx my mz b">derive</code>到<code class="fe mw mx my mz b">Display</code>(你<em class="na">让</em>去实现它)。您所需要做的就是将<code class="fe mw mx my mz b">#[derive(Debug)]</code>添加到<code class="fe mw mx my mz b">Programmer</code>结构中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1c2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地使用<code class="fe mw mx my mz b">:?</code>格式来利用默认的<code class="fe mw mx my mz b">Debug</code>功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="45d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你添加一个<code class="fe mw mx my mz b">#</code>到组合中，你可以免费得到漂亮的打印…耶！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="efd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有其他效用性状如<code class="fe mw mx my mz b">Eq</code>、<code class="fe mw mx my mz b">Clone</code>、<code class="fe mw mx my mz b">PartialEq</code>等。哪能<code class="fe mw mx my mz b">derive</code>。</p><h2 id="2b00" class="nf ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated">使用特征</h2><p id="5487" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了利用特征，您应该能够从函数和方法中接受和返回它们，以利用“一般”行为。我们可以编写一个接受实现<code class="fe mw mx my mz b">PrettyPrint</code>的类型的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ae91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe mw mx my mz b">impl</code>已经添加到参数中。</p><p id="d5ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以返回一个<code class="fe mw mx my mz b">PrettyPrint</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="2335" class="nf ma iq bd mb nm nn dn mf no np dp mj lf nq nr ml lj ns nt mn ln nu nv mp nw bi translated"><strong class="ak">默认方法</strong></h2><p id="0edd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">可以在trait本身中提供方法的默认实现(如果需要，可以覆盖这些实现)。这些方法也可以调用其他trait方法(默认或非默认)。</p><p id="c4da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请继续关注另一个关于Rust基础知识的博客！</p></div></div>    
</body>
</html>