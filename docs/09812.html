<html>
<head>
<title>When Should You Copy-Paste Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候应该复制粘贴代码？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-developers-are-allowed-to-copy-and-paste-the-code-d8db988c78ae?source=collection_archive---------2-----------------------#2021-10-14">https://betterprogramming.pub/when-developers-are-allowed-to-copy-and-paste-the-code-d8db988c78ae?source=collection_archive---------2-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b08b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">澄清何时允许开发者复制粘贴</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ce6ea940035215ef10feca5b1abc1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_EAxdAafch41Lwn8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@vsmilelx?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">浮萍 闪电</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="90b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制和粘贴代码通常被认为是反模式的，甚至是绝对邪恶的。然而，复制和粘贴只是一种工具，开发人员可以不恰当地使用它，对代码库造成重大损害，或者可以恰当地使用它，在不损害代码质量的情况下加快开发速度。</p><p id="0b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着弄清楚什么时候复制和粘贴代码是正当的，什么时候不是。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f954" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一些现有的代码只是新代码的模板</h1><p id="803e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个大型项目的代码库可能包含许多重复的代码块，从一行到几行不等。重复代码绝对没有问题，除非更改一个代码块需要对其他相似或相同的代码块进行相同的更改。</p><p id="682e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个开发人员收到了下面的简单文件，其中有两列(<code class="fe mz na nb nc b">Name</code>和<code class="fe mz na nb nc b">IsDeleted</code>)用于解析数据并将其加载到内存中:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8ccd" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">users.txt</strong></span><span id="1616" class="nh md it nc b gy nm nj l nk nl">Username, 0<br/>UserName, 0<br/>Username, 1</span></pre><p id="5cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员可以实现类似这样的东西来完成这项任务:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6208" class="nh md it nc b gy ni nj l nk nl">public UserFileParser<br/>{<br/>  public IEnumerable&lt;User&gt; Parse(string path)<br/>  {<br/>    StreamReader reader = File.OpenText(path);</span><span id="81e8" class="nh md it nc b gy nm nj l nk nl">    string line;<br/>    while ((line = reader.ReadLine()) != null)<br/>    {<br/>       string[] values = line.Split(',');<br/>       yield return new User(values[0], Convert.ToInt32(values[1]));<br/>    }<br/>  }<br/>}</span><span id="8008" class="nh md it nc b gy nm nj l nk nl">public class User<br/>{<br/>    public User(string name, bool isDeleted)<br/>    {<br/>        Name = name;<br/>        IsDeleted = isDeleted;<br/>    }</span><span id="4334" class="nh md it nc b gy nm nj l nk nl">    public string Name { get; set; }<br/>    public bool IsDeleted { get; set; }<br/>}</span></pre><p id="4cd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二天，开发人员得到了另一个要解析的文件。经过快速调查，开发人员发现两个文件模式是相同的，这意味着解析逻辑将与已经存在的非常相似。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7e69" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">admins.txt</strong></span><span id="d8b8" class="nh md it nc b gy nm nj l nk nl">Adminname, 1<br/>Adminname, 0<br/>Adminname, 1</span></pre><p id="5c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员现在有两种方法来完成新任务。第一种是使用泛型、策略或任何其他必要的技术来重用现有的解析逻辑，以最小化冗余行。</p><p id="266d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法是复制并粘贴整个<code class="fe mz na nb nc b">UserFileParser</code>类，将其重命名为<code class="fe mz na nb nc b">AdminFileParser,</code>，再做一些小的调整，就这样。</p><p id="edb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，复制和粘贴选项不仅比重用现有代码更好，而且是开发人员避免将来出现问题的唯一选择。</p><p id="5db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">碰巧的是，在某些时候，代表不同事物的两个不同文件具有相同的模式。然而，文件的模式很可能会彼此独立地改变——明天一个文件中将有更多的列，或者它的列将被交换，一个新的分隔符将被引入一个文件，等等。</p><p id="6845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维护单个文件解析器的多功能性将花费开发人员太多的精力。文件解析器中可能会出现条件语句，这会降低代码的可维护性和可测试性。此外，由于其中一个文件中的模式更改而试图更改解析器可能会中断对两个文件的解析。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="82c1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">复制和粘贴以避免紧密耦合</h1><p id="530c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当软件开发人员试图完全消除代码重复时，他们会使系统的组件耦合得更紧密。虽然紧密耦合通常不会在整体代码库中导致严重的问题，但是微服务架构或模块化整体应用程序可能会因为紧密耦合而受到严重影响。</p><p id="544a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先看看下面的例子:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8834" class="nh md it nc b gy ni nj l nk nl">public class PdfReportGenerator<br/>{<br/>    public void Generate(string path)<br/>    {<br/>        var file = Parser.Parse(path);<br/>        //Generate Pdf report from file content<br/>    }<br/>}</span><span id="45bd" class="nh md it nc b gy nm nj l nk nl">public class HtmlReportGenerator<br/>{<br/>    public void Generate(string path)<br/>    {<br/>        var file = Parser.Parse(path);<br/>        //Generate HTML report from file content<br/>    }<br/>}</span><span id="fda5" class="nh md it nc b gy nm nj l nk nl">public class Parser<br/>{<br/>   public static File Parse(string path)<br/>   {<br/>       //TODO: parse the file<br/>   }<br/>}</span></pre><p id="b2b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">PdfReportGenerator</code>和<code class="fe mz na nb nc b">HtmlReportGenerator</code>类重用封装在<code class="fe mz na nb nc b">Parser</code>类中的相同解析逻辑。上述所有类都是单个解决方案的一部分，更重要的是，它们作为单个部署单元一起部署。</p><p id="a703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果开发人员决定重命名<code class="fe mz na nb nc b">Parse</code>方法，但忘记在消费者中重命名方法调用，就会出现编译错误。开发人员将立即更新<code class="fe mz na nb nc b">Parse</code>方法的所有消费者，并部署工作代码。</p><p id="ab60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在微服务架构中，每个类可能属于每个自己的项目，并且每个项目可以单独部署。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/53c5ed61f02283f136a7420c05f8db27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8iOO-tuBqbSq5RvdDnsvfA.png"/></div></div></figure><p id="fd1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，更改<code class="fe mz na nb nc b">Parse</code>方法的接口而不更新消费者不会导致任何构建错误，因此开发人员可以向存储库提交重大更改。</p><p id="2b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了摆脱这种和其他常见依赖给系统带来的问题，开发人员可以将<code class="fe mz na nb nc b">Parser</code>实现复制到每个微服务中，并扔掉共享包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/4b9d085422a473582edaea62dc55d6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uA6G_-QY7QHzR5y-DZ3O3g.png"/></div></div></figure><p id="4b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在微服务中完全摆脱共享包是不可能的。每个微服务不能独立实现所有需要的代码，因为实现几乎每一个新的需求或修复一些问题通常需要在许多微服务中进行相同的更改。</p><p id="f9e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，那么如何决定什么时候复制粘贴以避免紧耦合，什么时候复制粘贴是合理的呢？一般建议是:</p><ul class=""><li id="9d66" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">具有数千行代码或领域知识的复杂基础设施代码应该只存在于一个共享包或微服务中。</li><li id="6903" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">不太可能改变的代码(例如，解析静态文件的代码，这些静态文件的模式多年来都是相同的)或简单的基础设施代码可以在多个微服务中复制和粘贴。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f92c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">因业务压力复制粘贴</h1><p id="d3f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">也许，在一个由软件开发人员驱动的世界里，将有足够的时间来重构代码，编写所有类型的测试，并遵循所有可能的最佳实践。</p><p id="ba8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在现实中，在业务驱动的世界中，软件开发人员可能需要尽快实现一些功能，这反过来迫使开发人员复制和粘贴现有的逻辑。</p><p id="8938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于业务压力，完全避免复制和粘贴代码是不可能的。当这种情况发生时，复制和粘贴代码的开发人员或评审人员至少应该做到以下几点:</p><ul class=""><li id="8ff4" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">在问题跟踪系统中登记技术债务票据。</li><li id="28d5" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">描述和评估机票。</li><li id="7b39" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">将科技股纳入最近的sprint的范围。</li></ul><p id="bb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过遵循这些步骤，不需要的重复代码的生命周期将会很短。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c6b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><ul class=""><li id="980a" class="np nq it lb b lc mu lf mv li od lm oe lq of lu nu nv nw nx bi translated">在您的应用程序中有相似甚至相同的代码块是完全正常的，除非更改一个代码块会导致另一个相似或相同的代码块发生相同的更改。</li><li id="0f01" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在微服务或模块化单片应用中，开发人员经常需要在代码冗余和紧耦合之间进行平衡。</li><li id="638a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">有时，开发人员可能会因为业务压力而复制和粘贴真正应该存在于一个地方的代码。在这种情况下，开发人员需要在问题跟踪系统中注册一个技术债务票据。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="og oh gp gr oi oj"><a href="https://levelup.gitconnected.com/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">慢速代码是可选的。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>