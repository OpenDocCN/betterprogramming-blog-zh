<html>
<head>
<title>Learn About SQL Injection Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解SQL注入攻击</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-about-sql-injection-attacks-ce9f8940a5ab?source=collection_archive---------5-----------------------#2020-11-03">https://betterprogramming.pub/learn-about-sql-injection-attacks-ce9f8940a5ab?source=collection_archive---------5-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">攻击者如何注入到SQL查询中，您如何防止它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea68ad14a5592be8787f150207fcb605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VcDzdYOIuwqiCjha"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来谈谈您的应用程序可能遇到的最严重的漏洞之一:SQL注入。</p><p id="e780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL注入允许攻击者代码更改应用程序的SQL查询结构，以窃取数据、修改数据或在底层操作系统中执行任意命令。</p><p id="5bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您的web应用程序的数据库包含一个名为Users的表。该表包含三列:ID、用户名和密码，分别包含每个注册用户的用户Id、用户名和密码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/ec355ea0f044905b086180ff0b0c7b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gU65W4fg3HhDI968Y0px8g.png"/></div></div></figure><p id="c825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你的网站上，你提示你的用户输入用户名和密码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/2293869e7e7e38afd67506aa8e072716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIO1ONYS5m3gc-bjf01tcQ.png"/></div></div></figure><p id="42d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户提交的用户名和密码将被插入到SQL查询中，以便用户登录。例如，如果用户输入用户名“user”和密码“password123”，将执行这个SQL查询来查找用户名和密码匹配的用户ID。然后，您的应用程序将使用该用户ID登录用户。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="bb1a" class="mc md it ly b gy me mf l mg mh">SELECT Id FROM Users</span><span id="ee30" class="mc md it ly b gy mi mf l mg mh">WHERE Username='user' AND Password='password123';</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="98e8" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">SQL注入攻击</h1><p id="fd8b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">那么这里的问题是什么呢？这里的问题是，攻击者可以插入SQL语言特有的字符来扰乱查询的逻辑，从而执行任意SQL代码。例如，如果攻击者提交这个字符串作为他们的用户名会怎么样？</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="5f57" class="mc md it ly b gy me mf l mg mh">username="<strong class="ly iu">admin'; —- </strong>"&amp;password=""</span></pre><p id="4f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的SQL查询将变成:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="95d7" class="mc md it ly b gy me mf l mg mh">SELECT Id FROM Users</span><span id="0090" class="mc md it ly b gy mi mf l mg mh">WHERE Username='admin'; —- AND Password='';</span></pre><p id="2737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no ly b">- -</code>序列表示SQL注释的开始。通过将<code class="fe nm nn no ly b">- -</code>添加到查询的用户名部分，攻击者注释掉SQL查询的其余部分。该查询实际上将变成:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="06ff" class="mc md it ly b gy me mf l mg mh">SELECT Id FROM Users WHERE Username='admin';</span></pre><p id="8339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该查询将返回管理员用户的ID，而不管攻击者提供了什么密码。通过注入到SQL查询中，攻击者绕过了身份验证，可以在不知道正确密码的情况下以管理员身份登录！这就是SQL注入:通过注入特殊字符和改变SQL查询结构，攻击者可以导致数据库执行非预期的SQL代码。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="38e7" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">利用SQL注入</h1><p id="b636" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">绕过身份验证并不是攻击者利用SQL注入漏洞可以实现的唯一目标。他们还可以从服务器上检索不允许他们访问的数据。</p><p id="8efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的网站允许用户通过向服务器提供用户名和访问密钥来证明他们的身份，从而访问他们的电子邮件列表。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3f68" class="mc md it ly b gy me mf l mg mh">username="vickie"&amp;accesskey="ZB6w0YLjzvAVmp6zvr"</span></pre><p id="ffce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这个请求将使用这个SQL语句生成一个对数据库的查询。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="5696" class="mc md it ly b gy me mf l mg mh">SELECT Title, Body FROM Emails</span><span id="388f" class="mc md it ly b gy mi mf l mg mh">WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr';</span></pre><p id="8a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，攻击者可以通过提交这个访问键，利用SQL查询从其他表中读取他们不应该读取的数据。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="27e0" class="mc md it ly b gy me mf l mg mh">username="vickie"&amp;accesskey="<strong class="ly iu">ZB6w0YLjzvAVmp6zvr' UNION SELECT Username, Password FROM Users; —- </strong>"</span></pre><p id="d45b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这个有效载荷分解一下。如果攻击者将上述访问密钥发送给服务器，服务器将执行这个SQL查询。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="20ac" class="mc md it ly b gy me mf l mg mh">SELECT Title, Body FROM Emails</span><span id="feb8" class="mc md it ly b gy mi mf l mg mh">WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr'</span><span id="0213" class="mc md it ly b gy mi mf l mg mh">UNION SELECT Username, Password FROM Users; —- ;</span></pre><p id="e04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no ly b">SQL UNION</code>操作符用于组合两个不同的<code class="fe nm nn no ly b">SELECT</code>语句的结果。这个查询结合了第一个<code class="fe nm nn no ly b">SELECT</code>语句(用户的电子邮件)和第二个<code class="fe nm nn no ly b">SELECT</code>语句(返回Users表中的所有用户名和密码)的结果。现在，攻击者可以读取存储在数据库中的所有用户的用户名和密码！</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="d999" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu">SELECT Title, Body FROM Emails</strong></span><span id="fb67" class="mc md it ly b gy mi mf l mg mh"><strong class="ly iu">WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr'</strong></span><span id="b074" class="mc md it ly b gy mi mf l mg mh">UNION <strong class="ly iu">SELECT Username, Password FROM Users</strong>; —- ;</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4da3" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">不仅仅是SELECT语句</h1><p id="c8ff" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">SQL注入不仅仅局限于<code class="fe nm nn no ly b">SELECT</code>的言论。攻击者还可以注入用于更新记录的<code class="fe nm nn no ly b">UPDATE</code>语句、用于删除现有记录的<code class="fe nm nn no ly b">DELETE</code>语句和用于在表中创建新条目的<code class="fe nm nn no ly b">INSERT</code>语句。例如，假设用户可以通过在HTTP表单中提供新密码来更改他们的密码。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="864f" class="mc md it ly b gy me mf l mg mh">new_password="password12345"</span></pre><p id="9ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该表单将使服务器使用当前登录用户的新密码执行SQL UPDATE查询。在本例中，用户ID为<code class="fe nm nn no ly b">2</code>的用户。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="782e" class="mc md it ly b gy me mf l mg mh">UPDATE Users</span><span id="36a6" class="mc md it ly b gy mi mf l mg mh">SET Password='password12345'</span><span id="dbdd" class="mc md it ly b gy mi mf l mg mh">WHERE Id = 2;</span></pre><p id="e02a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">攻击者可以控制<code class="fe nm nn no ly b">UPDATE</code>语句的<code class="fe nm nn no ly b">SET</code>子句。那么如果他们提交一个像这样的新密码呢？</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3050" class="mc md it ly b gy me mf l mg mh">new_password="<strong class="ly iu">password12345'; —- </strong>"</span></pre><p id="c435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个请求将导致<code class="fe nm nn no ly b"> UPDATE SQL</code>查询变成:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="89d9" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu">UPDATE Users</strong></span><span id="4256" class="mc md it ly b gy mi mf l mg mh"><strong class="ly iu">SET Password='password12345'</strong>; —- </span><span id="58c8" class="mc md it ly b gy mi mf l mg mh">WHERE Id = 2;</span></pre><p id="6caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该查询中的<code class="fe nm nn no ly b">WHERE</code>子句被注释掉，因此该查询会将Users表中的所有密码更改为“password12345”攻击者现在可以使用密码“password12345”以任何人的身份登录</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6e82" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">防止SQL注入</h1><p id="268e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">你可以看到SQL注入是一个严重的漏洞，你应该防止。现在让我们来谈谈如何在您的web应用程序中防止它们。</p><p id="9880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能听说过几种预防SQL注入的技巧，如准备好的陈述、批准列表、类型转换和转义。但是每个选项的优缺点是什么，以及何时应该使用它们？</p><ol class=""><li id="c99a" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">准备好的声明</li><li id="5239" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">批准列表</li><li id="aefa" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">铅字铸造</li><li id="f456" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">逃避</li></ol><h2 id="97f8" class="mc md it bd mr od oe dn mv of og dp mz li oh oi nb lm oj ok nd lq ol om nf on bi translated">准备好的声明</h2><p id="421d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">首先，让我们谈谈你的最佳选择:准备好的陈述。预准备语句也被称为<em class="oo">参数化查询</em>，它们使得SQL注入几乎不可能。</p><p id="d882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入研究预处理语句如何工作之前，理解SQL查询是如何执行的是很重要的。SQL本质上是一种编程语言，你的SQL查询本质上是一个程序。当SQL程序到达SQL server时，服务器将对其进行解析、编译和优化。最后，服务器将执行程序并返回执行结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f3c4047c0934c99fd95412d3fd64c5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkwo1M7w0KtUZElCxdLRXA.png"/></div></div></figure><p id="e440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将用户提供的输入直接插入到SQL查询中时，您基本上是在使用用户输入动态地重写您的程序。因此，攻击者可以提供干扰程序代码并改变其逻辑的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/9d2c9ec0bd7eceb1c0573c95d998699b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQxuBuryvXUEV9IqiJkU7Q.png"/></div></div></figure><p id="340c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和预处理语句的工作原理是确保用户提供的数据不会改变SQL查询的逻辑。准备好的语句是在插入任何用户提供的参数之前发送到SQL server并由SQL server编译的SQL语句。这意味着，不是将完整的SQL查询传递给服务器进行编译，而是首先定义所有的SQL逻辑，编译它，然后在执行之前将参数插入到查询中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/0dab96c1f788865c718124f8c8935106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWhzaNt0Ta4hgiHrr1qe5A.png"/></div></div></figure><p id="bd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将参数插入最终查询后，将不会解析和重新编译该查询。原始语句中没有的任何内容都将被视为字符串数据，而不是可执行的SQL代码。所以SQL查询的程序逻辑部分将保持不变。这允许数据库区分SQL查询的代码部分和数据部分，而不管用户输入看起来像什么。例如，下面是如何用PHP实现一个准备好的语句。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="4523" class="mc md it ly b gy me mf l mg mh">&lt;?php<br/>  $stmt = $mysqli-&gt;prepare(“SELECT Id FROM Users WHERE Username=? AND Password=?”);<br/>  $stmt-&gt;bind_param(“ss”, $username, $password);<br/>  $stmt-&gt;execute();<br/>?&gt;</span></pre><p id="360a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在预准备语句中，您应该首先定义查询的结构。您写出不带参数的查询，并将问号作为参数的占位符。然后，SQL server将把这个字符串编译成SQL代码。然后，您可以单独发送查询的参数。这里的<code class="fe nm nn no ly b">ss</code>表示我们提供两个参数，都是字符串。最后，执行查询。</p><p id="46dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要记住的另一点是，使用预准备语句并不一定意味着可以避免SQL注入。你也必须正确使用它们。例如，这里假设我们在<code class="fe nm nn no ly b">prepare</code>函数中连接用户输入，然后立即执行它:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="eadc" class="mc md it ly b gy me mf l mg mh">&lt;?php<br/>  $stmt = $mysqli-&gt;prepare(“SELECT Id FROM Users WHERE Username=’$username’ AND Password=’$password’”);<br/>  $stmt-&gt;execute();<br/>?&gt;</span></pre><p id="532f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不将用户输入作为参数单独发送到准备好的语句，而是仍然通过将字符串连接在一起来构建SQL查询，那么即使使用准备好的语句，您仍然容易受到SQL注入的攻击。</p><h2 id="1bc5" class="mc md it bd mr od oe dn mv of og dp mz li oh oi nb lm oj ok nd lq ol om nf on bi translated">批准列表</h2><p id="c39e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">假设你的程序允许用户根据一些标准对他们的邮件进行分类。如果用户按照邮件发送日期对邮件进行排序，应用程序将执行这个SQL查询来检索邮件。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="f39a" class="mc md it ly b gy me mf l mg mh">SELECT Title, Body FROM Emails</span><span id="8a54" class="mc md it ly b gy mi mf l mg mh">WHERE Username=’vickie’ AND AccessKey=’mykey_123'</span><span id="5a7d" class="mc md it ly b gy mi mf l mg mh">ORDER BY Date DESC;</span></pre><p id="df8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL <code class="fe nm nn no ly b">ORDER BY</code>子句允许查询指定根据哪一列对结果进行排序。该查询将返回我们的表中所有用户的电子邮件，这些邮件按<code class="fe nm nn no ly b">Date</code>列降序排序。</p><p id="6292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你希望你的用户能够选择他们的电子邮件按照哪个字段排序。在这种情况下，不能使用预处理语句来保护查询。预准备语句只能用于保护编译过程中不需要的字段。不能在列名、表名、SQL运算符或<code class="fe nm nn no ly b">ORDER BY</code>子句中使用预准备语句。因此，如果您需要在这些字段中使用用户提供的输入，批准列表将是针对SQL注入的最合适的防御措施。</p><p id="94ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oo">批准列表</em>是指只接受已知合法的输入值，拒绝所有其他输入。在这种情况下，您可以为<code class="fe nm nn no ly b">ORDER BY</code>子句使用列名的批准列表，而不是允许用户任意输入。假设用户只能按日期或发件人对邮件进行分类。您可以检查用户输入是否对应于允许的值之一，然后将其插入到SQL语句中。下面是如何在PHP中实现这种保护。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="de64" class="mc md it ly b gy me mf l mg mh">&lt;?php<br/>  <strong class="ly iu">if($_POST[“order_by”] == “Date” || $_POST[“order_by”] == “Sender”) {<br/>   $order_by = $_POST[“order_by”];<br/>  }</strong><br/>  $stmt = $mysqli-&gt;prepare(“SELECT Id FROM Emails WHERE Username=? AND AcessKey=? ORDER BY $order_by”);<br/>  $stmt-&gt;bind_param(“ss”, $username, $accesskey);<br/>  $stmt-&gt;execute();<br/>?&gt;</span></pre><p id="9b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以将用户提供的值映射到程序中预定义的字符串中，以避免将用户输入连接到SQL查询中。例如，如果您希望您的用户以升序或降序方式对他们的结果进行排序，您可以让用户指定一个布尔值，然后将该值映射到要插入到查询中的字符串。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="14d0" class="mc md it ly b gy me mf l mg mh">&lt;?php<br/>  if($_POST[“order_by”] == “Date” || $_POST[“order_by”] == “Sender”)   {<br/>   $order_by = $_POST[“order_by”];<br/>  }</span><span id="900f" class="mc md it ly b gy mi mf l mg mh"><strong class="ly iu">  $sort_by = “ASC”;<br/>  if($_POST[“desc”] == “1”) {<br/>   $sort_by = “DESC”;<br/>  }</strong><br/>  $stmt = $mysqli-&gt;prepare(“SELECT Id FROM Emails WHERE Username=? AND AcessKey=? ORDER BY $order_by $sort_by”);<br/>  $stmt-&gt;bind_param(“ss”, $username, $accesskey);<br/>  $stmt-&gt;execute();<br/>?&gt;</span></pre><h2 id="8b85" class="mc md it bd mr od oe dn mv of og dp mz li oh oi nb lm oj ok nd lq ol om nf on bi translated">铅字铸造</h2><p id="0872" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果您的用户输入应该是简单的数据类型，如布尔值、数字或日期，您还可以在将用户输入字符串追加到查询之前将其转换为更安全的数据类型。这被称为<em class="oo">型铸造</em>，可以用来防止SQL注入不使用准备好的声明。</p><p id="35dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您还允许用户使用他们的用户ID来检索他们的电子邮件。并且您知道所提供的用户ID应该总是一个整数。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3dc2" class="mc md it ly b gy me mf l mg mh">SELECT Title, Body FROM Emails</span><span id="55c7" class="mc md it ly b gy mi mf l mg mh">WHERE Id='2' AND AcessKey='mykey_123';</span></pre><p id="2981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，您可以在将用户输入字符串插入SQL查询之前将其转换为整数。这将确保输入是一个数字，并且没有会影响SQL逻辑的特殊字符会在转换后继续存在。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="7ebd" class="mc md it ly b gy me mf l mg mh">&lt;?php<br/>  <strong class="ly iu">$id = (int)$_POST[“id”];</strong><br/>  $accesskey = $_POST[“access_key”];</span><span id="54a5" class="mc md it ly b gy mi mf l mg mh">  $stmt = $mysqli-&gt;prepare(“SELECT Title, Body FROM Emails WHERE Id=$id AND AcessKey=?”);<br/>  $stmt-&gt;bind_param(“s”, $accesskey);<br/>  $stmt-&gt;execute();<br/>?&gt;</span></pre><p id="a502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，在这个示例中，我们可以只使用预准备语句。你完全正确。我建议尽可能使用预处理语句，而不是类型转换，因为预处理语句适用于所有数据类型。这样，您的编码风格可以对所有类型的用户输入保持一致。类型转换方法应该保留到预准备语句不可用时使用。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="d545" class="mc md it ly b gy me mf l mg mh">&lt;?php<br/>  $id = $_POST[“id”];<br/>  $accesskey = $_POST[“access_key”];</span><span id="2719" class="mc md it ly b gy mi mf l mg mh">  $stmt = $mysqli-&gt;prepare(“SELECT Title, Body FROM Emails WHERE Id=? AND AcessKey=?”);<br/>  $stmt-&gt;bind_param(“ss”, $id, $accesskey);<br/>  $stmt-&gt;execute();<br/>?&gt;</span></pre><h2 id="dfd5" class="mc md it bd mr od oe dn mv of og dp mz li oh oi nb lm oj ok nd lq ol om nf on bi translated">逃避</h2><p id="40b6" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">防止SQL注入的最后一种方法是小心地对用户输入进行净化和转义。这意味着您要编码或删除可能扰乱SQL逻辑的特殊字符。例如，应该清理或转义的一些特殊字符包括单引号(')和双引号(")，这通常允许攻击者中断参数字符串。还需要注意每种类型的数据库特有的特殊字符。</p><p id="41a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法只能作为最后的手段，如果可能的话，你不应该依赖它，因为它不能保证在所有情况下都能预防SQL注入。很容易忽略一些可能构成SQL注入攻击的特殊字符。</p><p id="dced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再来看看这个查询。如果您希望您的用户能够通过随机字段对他们的电子邮件进行排序，该怎么办？如果您无法确定在这种情况下可以使用的批准列表，您可以首先对用户输入字符串进行转义，然后将其插入到查询中。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="9fee" class="mc md it ly b gy me mf l mg mh">&lt;?php<br/>  <strong class="ly iu">$order_by = $mysqli-&gt;real_escape_string($_POST[“order_by”]);</strong><br/>  $stmt = $mysqli-&gt;prepare(“SELECT Id FROM Emails WHERE Username=? AND AcessKey=? ORDER BY $order_by”);<br/>  $stmt-&gt;bind_param(“ss”, $username, $accesskey);<br/>  $stmt-&gt;execute();<br/>?&gt;</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="25bd" class="mq md it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">注意安全！</h1><p id="a4d5" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如你所见，你有很多预防SQL注入的选择。预防SQL注入的最佳方法是尽可能使用预准备语句，并在无法使用预准备语句时使用批准列表。当您无法使用准备好的语句时，类型转换也可以用作批准列表的替代方法。输入转义和净化不应被用作抵御SQL注入的唯一保护措施。相反，这种方法与准备好的声明和批准列表结合使用，以获得最大程度的保护并防止其他web漏洞。</p><p id="0ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的安全课到此结束。下次见！</p></div></div>    
</body>
</html>