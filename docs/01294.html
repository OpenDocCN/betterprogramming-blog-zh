<html>
<head>
<title>Solving the Min-Stack Problem in O(1) Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">O(1)时间内求解最小堆栈问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-the-min-stack-problem-in-o-1-time-using-a-single-stack-in-ruby-626f65142927?source=collection_archive---------10-----------------------#2019-08-29">https://betterprogramming.pub/solving-the-min-stack-problem-in-o-1-time-using-a-single-stack-in-ruby-626f65142927?source=collection_archive---------10-----------------------#2019-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b51e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Ruby中使用单个堆栈返回最小元素</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/32101d01fb934c172999aa60f7d8e7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dICpU5F9ctPnxROlib8a8w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">贝基尔·登梅兹在<a class="ae kv" href="https://unsplash.com/search/photos/balance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0cdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">各位编码员好！我已经决定写更多关于抽象数据结构的文章，并用每种结构解决至少一个编程面试问题，所以请继续关注更多精彩内容。</p><p id="2e18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将堆积一些金钱或现金，无论你喜欢如何称呼它。</p><p id="d6f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我将在O(1)时间内解决最小堆栈问题，并加入一个额外的功能来跟踪堆栈中的最大元素。</p><p id="95fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很快，我将解释什么是堆栈，为那些没有遇到过一个堆栈的人。如果你有，继续读下去，因为我发现你不可能知道任何事情的一切。我可能会说一些你不知道的事情。</p><p id="e9c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我简短的解释之后，我将向您展示问题陈述和简单的解决方案。</p><p id="8691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">学习成果:</p><ul class=""><li id="75a0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">什么是堆栈</li><li id="cb35" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为什么堆栈很重要</li><li id="aca4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何实现堆栈</li><li id="9bf4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何跟踪堆栈中的最小和最大元素，并在O(1)时间内返回它们</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2af5" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">什么是栈？</strong></h1><p id="bea2" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">堆栈是一种抽象的数据结构。这就像双端队列或队列一样。唯一的区别是你只能从数据结构的顶端添加元素。</p><p id="5a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了形象化这意味着什么，我喜欢把它想象成一大堆书。你只能把一本书放在另一本书的上面。你不能把一本书放在一堆书的最下面，在中间或其他任何地方放一本可能都不是最聪明的主意。从一堆东西的底部拿出一个也是一样。你可能真的会被一些知识打脸——不要这样做！</p><p id="aa5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，堆栈是一种后进先出的数据结构。放在书架上的最后一本书必须是最先拿下来的，否则你可能会毁掉你的书城堡。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="cb6d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">栈为什么有用？</h1><p id="8129" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">它们非常有用，因为在数据结构的前端插入或删除数据时，它们为您提供了恒定的时间操作。堆栈的一个常见用途是在编译器中，在编译器中，堆栈可用于确保代码文件中的括号和圆括号都是平衡的，即，有一个开始和结束对应项。你可以查看这篇关于平衡支架的教程，看看它是如何工作的。堆栈在评估数学表达式时也非常有用。(稍后我会试着为此写一篇问题解决教程。)</p><p id="0a0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:就像deques一样，栈也是基于节点的。我们使用堆栈中的节点和指针来跟踪顺序。(如果你想了解更多，请查看这篇关于用Ruby实现deques的教程<a class="ae kv" href="https://medium.com/@oluwadamilareo_/implementing-a-deque-in-ruby-cf6e9bfd9c3c" rel="noopener">。)</a></p><p id="f50c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续前进。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e72d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">问题陈述和解决方案</strong></h1><p id="f669" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">创建一个包含标准push和pop方法的堆栈。它还应该包含另一个方法min，该方法返回堆栈中的最小数字。额外学分:所有操作都需要O(1)时间。</p><p id="d040" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧。</p><p id="6d10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们像这样定义我们的节点类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个节点类是这个数据结构最基本的部分——要小心使用。</p><p id="2f97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们设置stack类。终于！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，与deque不同，我们只初始化第一个节点(栈顶)。</p><p id="de16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们设置我们的<code class="fe nm nn no np b">pushFront</code>方法。注意这个方法和我们在里面写的东西。我会稍微分解一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0ac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一行中，我们创建了一个新节点，它的值为<em class="nq"> number </em>，它的下一个节点是我们之前的第一个节点。然后，我们将这个节点指定为新的第一个节点。</p><p id="c9fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将第一个节点赋给<code class="fe nm nn no np b">@min</code>变量，对<code class="fe nm nn no np b">@max</code>变量也是如此(但前提是这些变量以前不存在)。</p><p id="1ab9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，如果最小值和最大值之前存在，意味着堆栈不为空，我们将该数字与<code class="fe nm nn no np b">min?</code>和<code class="fe nm nn no np b">max?</code>的返回值进行比较。如果数字小于<code class="fe nm nn no np b">@min</code>，我们将min变量更新为一个新的节点，其值是较小的数字，其下一个节点是带有前一个最小值的前一个节点。如果数量大于之前的最大值，我们对<code class="fe nm nn no np b">@max</code>做同样的处理。</p><p id="9534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们看看我们的<code class="fe nm nn no np b">min?</code>和<code class="fe nm nn no np b">max?</code>方法在做什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到<code class="fe nm nn no np b">min?</code>方法简单地返回最小值变量的值，如果它存在的话。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="adc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">max?</code>方法返回存储在最大变量中的值。注意，两个操作都是常数时间:O(1)。</p><p id="7d06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信你会奇怪为什么我们没有讨论从堆栈中移除数据，但是在我们处理更技术性的<code class="fe nm nn no np b">popFront.</code>之前，让我们先解决两个更简单的方法</p><p id="8e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可能要问我们的堆栈是否为空。我们可以通过检查第一个元素是否有值来做到这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c2a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可能想要查看堆栈顶部的值，因为它基本上是我们所能看到的全部内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ffc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们期待已久的方法！<code class="fe nm nn no np b">popFront</code>。在常规堆栈中，所有需要做的就是更新<code class="fe nm nn no np b">@first</code>。但是现在，我们需要多考虑一点，因为我们还需要跟踪最大值和最小值。我把它简化了一点。请看这幅插图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/b9f8e606bba9692340a718f2f43d90a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6i1COx4Z3tpOfX7i1puipg.png"/></div></div></figure><p id="3439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到，当我们弹出左边堆栈的顶部时，我们也弹出了最小值。但是我们看到，在右边的堆栈中，最小值放弃了它的船，并更新为堆栈中的下一个最小值。因为它们是通过节点连接的，所以更新指针很容易。我不确定，但我打赌这就是《加勒比海盗》中杰克·斯派洛船长多次逃脱死亡的原因。</p><p id="9cab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="aaef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们检查<code class="fe nm nn no np b">@min</code>或<code class="fe nm nn no np b">@max</code>是否即将被驱逐。如果是，我们在弹出它们以前的形式之前，很快允许它们进入下一个可用的容器，然后我们返回刚刚删除的节点的值。</p><p id="5bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:<strong class="ky ir"> </strong>我们只更新最小值或最大值，如果它们被逐出，也就是说，它们是将要从顶部弹出的节点。他们只是跳船，直到无处可逃，无处可藏，就像杰克斯派洛一样！</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="11d1" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="7696" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">今天就到这里吧！要了解堆栈如何给编译器带来有用的超能力，请阅读我上面提到的关于使用堆栈平衡括号的教程。</p><p id="255b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">敬请关注更多内容！</p><p id="9913" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://github.com/Oluwadamilareolusakin/min-max-stack" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个教程的代码。</p></div></div>    
</body>
</html>