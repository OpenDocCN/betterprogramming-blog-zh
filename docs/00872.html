<html>
<head>
<title>Why Versioning Is Important and How To Do It Properly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么版本控制很重要，以及如何正确地进行</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-versioning-is-important-and-how-to-do-it-686ce13b854f?source=collection_archive---------5-----------------------#2019-07-23">https://betterprogramming.pub/why-versioning-is-important-and-how-to-do-it-686ce13b854f?source=collection_archive---------5-----------------------#2019-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f9fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现语义版本控制，以便每个依赖项都保持在同一页面上</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a949e792a963291755b8aeea5bb94f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKqXbOLqISoFSnYNkrwiOA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@christinhumephoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯汀·休姆</a>在<a class="ae ky" href="https://unsplash.com/search/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道软件、游戏或应用程序上的数字意味着什么。类似于<code class="fe lv lw lx ly b">11.2.3</code>或者<code class="fe lv lw lx ly b">10.4.3.2arm64</code>的东西。</p><p id="8da3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是应用程序当前的版本号或它所属的版本号。此外，对于同一版本，这被分为不同的类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c1dd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">版本控制的原因</h1><p id="691f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">但是我们为什么要版本化呢？有必要吗？</p><p id="4bf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有可能的是，随着应用程序的增长，项目中包含的依赖项的数量也会随之增长。依赖越多，事情就越难管理。</p><p id="bd88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您可能会发现很难在不中断与其他人的联系的情况下升级一个依赖项，因为其他人可能太紧密而无法升级。</p><p id="feef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他时候，依赖关系过于松散。有些依赖项为未来提供支持，有时超出了需求。这是典型的依赖地狱。</p><p id="f2bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的解决方案是使用一组通用的规则正确地开始版本控制，这有助于每个依赖项尽可能地保持在同一页面上。</p><p id="5a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这叫做<a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9180" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">语义版本控制</h1><p id="a14d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">语义版本控制有一些必须遵循的规则。这些规则可以在<a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">网站</a>上找到。</p><p id="e96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们考虑X.Y.Z (Major)的版本格式。未成年人.补丁)。</p><ul class=""><li id="ad10" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">不影响API的错误修正增加了补丁版本。</li><li id="60ea" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">向后兼容的API添加或更改会增加次要版本。</li><li id="6176" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">向后不兼容的API变化增加了主版本。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e27c597c9bbb45d02e95d71db5a0b4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*0hpnAVl61AG3KwFuRIkHhg.png"/></div></figure><p id="7f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该阅读规则，这样你就知道什么时候增加专业。未成年人。补丁的版本和何时不。</p><p id="081a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，每次更新项目的版本不是很繁琐吗？必须有几个文件需要更新，你需要记住你最后一次更新是什么时候。</p><p id="8297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来没什么意思。如果我告诉你你可以用更好的方法做这件事呢？</p><p id="6824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<a class="ae ky" href="https://github.com/c4urself/bump2version" rel="noopener ugc nofollow" target="_blank"> bump2version </a>的用武之地。<a class="ae ky" href="https://github.com/c4urself/bump2version" rel="noopener ugc nofollow" target="_blank">这个GitHub资源</a>可能是我发现的最好的版本控制Python库。会有多难呢？</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="1928" class="nw mh it ly b gy nx ny l nz oa">pip install --upgrade bump2version</span></pre><p id="fef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完成后，我们需要创建一个bump配置文件，这样脚本就能按照我们想要的方式运行。</p><p id="1afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们有一个目录<code class="fe lv lw lx ly b">project_xyz</code>，其中还有另外两个目录:<code class="fe lv lw lx ly b">Backend</code>和<code class="fe lv lw lx ly b">Frontend</code>。</p><p id="04da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设<code class="fe lv lw lx ly b">Backend</code>包含一个文件<code class="fe lv lw lx ly b">setup.py</code>，而<code class="fe lv lw lx ly b">Frontend</code>包含一个文件<code class="fe lv lw lx ly b">build.sh</code>。每个文件都包含<code class="fe lv lw lx ly b">Frontend</code>和<code class="fe lv lw lx ly b">Backend</code>的版本。这些版本可以不同也可以相似，这取决于您是如何递增的(遵循规则)。</p><p id="1c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个文件<code class="fe lv lw lx ly b">.bumpversion.cfg</code>(注意它是隐藏的)。这个文件将定义版本应该更新到哪里和更新到什么。</p><p id="4b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将该文件定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你想增加整个项目的版本时，你可以在<code class="fe lv lw lx ly b">project_xyz</code>的根目录下运行一些命令，它会自动更新所有的文件。</p><p id="ab9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单如:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="0145" class="nw mh it ly b gy nx ny l nz oa">bump2version major // 0.1.0 --&gt; 1.0.0</span><span id="0992" class="nw mh it ly b gy od ny l nz oa">bump2version minor // 0.1.0 --&gt; 0.2.0</span><span id="59f6" class="nw mh it ly b gy od ny l nz oa">bump2version patch // 0.1.0 --&gt; 0.1.1</span></pre><p id="aaf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，提到的所有文件都包含一行:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="8965" class="nw mh it ly b gy nx ny l nz oa">version = 0.1.0 //or the version updated</span></pre><p id="e47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，每当您想要对单个文件执行此操作时(例如，您刚刚更新了<code class="fe lv lw lx ly b">Backend</code>，并且想要仅递增该值)，您可能更喜欢:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="0e2c" class="nw mh it ly b gy nx ny l nz oa">bump2version minor Backend/setup.py</span></pre><p id="7f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义版本也有一种递增方式:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="7df4" class="nw mh it ly b gy nx ny l nz oa">to go from 0.5.1 directly to 0.6.1<!-- -->:</span><span id="18ed" class="nw mh it ly b gy od ny l nz oa">bump2version --current-version 0.5.1 --new-version 0.6.1 patch Backend/setup.py</span></pre><p id="b216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还有一种在版本控制中添加消息的方法:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="8077" class="nw mh it ly b gy nx ny l nz oa">bump2version --message 'Build {$BUILD_NUMBER}: {new_version}' patch</span></pre><p id="4706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用所有这些信息提交Git时，这就是我所说的离原子Git使用又近了一步。</p><p id="e2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，感谢阅读！</p></div></div>    
</body>
</html>