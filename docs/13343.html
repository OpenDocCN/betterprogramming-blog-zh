<html>
<head>
<title>How to Scale a Go WebSocket Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何扩展Go WebSocket服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scaling-a-websocket-service-with-go-858b259d4974?source=collection_archive---------3-----------------------#2022-08-18">https://betterprogramming.pub/scaling-a-websocket-service-with-go-858b259d4974?source=collection_archive---------3-----------------------#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cbfe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">因为Linux只能打开一定数量的文件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0fdbaf584a660e93630a68dda23ef745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CkOm2MRIXstWRHsS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Vishnu Mohanan 通过Unsplash提供的图片</p></figure><p id="6101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在科技行业呆过，你可能会听到有人提到“规模”这个词。甚至在科技之外，你可能已经观察到企业“扩大”他们的生产方式以满足需求。本质上，“缩放”等同于增加你的生产方式。在技术背景下，扩展增加了您作为服务提供商的能力。在技术领域，有两种常见的扩展方式，一种是垂直扩展，另一种是水平扩展。在这篇文章中，我将谈论水平伸缩，以及如何将它应用到通过websockets运行的服务中。作为参考，水平扩展包括添加额外的服务器(或节点)来增加容量。</p><h1 id="fdcb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">这个想法</h1><p id="8a88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我开发多人游戏时，我处理通信的最佳模式是让客户端只向服务器发送输入。然后，服务器将负责控制客户端的状态。这将保证所有玩家看到的是完全一样的东西。另一种方式是让服务器决定客户端的状态。对于这篇文章，客户机将是websocket服务器，服务器控制状态将是<code class="fe mp mq mr ms b">dBus</code>。下面的图表可以更好地说明这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/86d89a0f197db16c04e4976933e61944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mV3BY0Ff6MNQ9F5dNx-AoA.png"/></div></div></figure><p id="15fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我想向服务器1上的所有websocket连接广播一条消息，我会将该消息推送到我的IPC(在本例中是<code class="fe mp mq mr ms b">dBus</code>)，并等待dBus在服务器1上调度实际的广播。现在用代码实现它。</p><h1 id="1dfe" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码</h1><p id="b104" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这篇文章中，我将尝试构建一个echo服务器。服务器会将消息中继到所有连接的设备，这包括另一个服务器实例上的websocket连接。我的临时消息代理人将是<code class="fe mp mq mr ms b">dBus</code>。我将使用包<code class="fe mp mq mr ms b">github.com/gorilla/websocket</code>来实现我的websocket。我将使用包<code class="fe mp mq mr ms b">github.com/godbus/dbus/v5</code>访问<code class="fe mp mq mr ms b">dBus</code>。首先，我将定义一个包含websocket连接数组和到<code class="fe mp mq mr ms b">dBus</code>的连接的类型。下面是结构定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6e0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将继续定义全局变量。<code class="fe mp mq mr ms b">upgrader</code>将启动websocket连接。变量<code class="fe mp mq mr ms b">AppPath</code>和<code class="fe mp mq mr ms b">AppID</code>将用于<code class="fe mp mq mr ms b">dBus</code>通信。以下是我的全局变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我将为类型<code class="fe mp mq mr ms b">App</code>定义一个方法。该方法将向服务器上的所有websocket连接广播一条消息。我从这个方法开始，因为它不依赖于其他函数/方法来操作。下面是方法<code class="fe mp mq mr ms b">broadcast</code>的定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虽然没有提到，但请确保在循环之前锁定数组，之后解锁。</p></figure><p id="2a62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我将实现监听来自<code class="fe mp mq mr ms b">dBus</code>的消息的方法。该方法还将负责建立到<code class="fe mp mq mr ms b">dBus</code>的连接，以及向所有连接广播消息。一旦从<code class="fe mp mq mr ms b">dbus</code>接收到数据，该方法将向服务器实例上的所有websocket连接广播消息。这种方法将被称为<code class="fe mp mq mr ms b">listen</code>，下面是它的定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cb65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将为类型<code class="fe mp mq mr ms b">App</code>实现的最后一个方法是HTTP处理程序。这个处理程序负责建立websocket连接，存储连接，并将消息转发给<code class="fe mp mq mr ms b">dBus</code>。这个方法将被称为<code class="fe mp mq mr ms b">handler</code>。下面是它的定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">` p '是一个字节数组。虽然没有提到，但请确保锁定涉及阵列连接的操作</p></figure><p id="b411" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我已经定义了所有的组件，我将继续实现。方法<code class="fe mp mq mr ms b">listen</code>将在Goroutine上运行。我将把处理程序安装到端点路径<code class="fe mp mq mr ms b">sockettome</code>。下面是代表我的实现的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="20a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是实际运行的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/9de915249f78ece32a5d5ab8e4cef906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*g_xEt8wCe2yp5RxS.gif"/></div></div></figure><h1 id="cba0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="30de" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在生产环境中，<code class="fe mp mq mr ms b">dBus</code>可能并不合适。还有其他消息代理会表现得更好。<code class="fe mp mq mr ms b">dBus</code>是有限的，因为服务器实例必须在同一个物理主机上。在这篇文章中，我使用<code class="fe mp mq mr ms b">dBus</code>来模拟一个消息代理。</p><p id="15fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的理论是，中央服务(消息代理)应该规定每个单独的服务器实例向websocket连接写入什么。并且客户应该告诉中央服务要广播什么。在我看来，这消除了在实例级管理状态的需要，因为中央服务正在做这件事。下面有这篇文章中使用的代码的链接。</p><h1 id="1d9b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">附加链接</h1><div class="mw mx gp gr my mz"><a href="https://github.com/cheikhshift/medium_examples/tree/main/scale-websocket" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">medium _ examples/scale-web socket at main cheikh shift/medium _ examples</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">中型文章的代码示例。在GitHub上创建一个帐户，为cheikhshift/medium_examples开发做贡献。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>