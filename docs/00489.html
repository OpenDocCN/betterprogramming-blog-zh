<html>
<head>
<title>Swift Hacks: De-duplicate Tedious Type Declarations with In-line Configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Hacks:通过内嵌配置消除冗长的类型声明</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-hacks-de-duplicate-tedious-type-declarations-with-in-line-configuration-13f66370754?source=collection_archive---------3-----------------------#2019-05-30">https://betterprogramming.pub/swift-hacks-de-duplicate-tedious-type-declarations-with-in-line-configuration-13f66370754?source=collection_archive---------3-----------------------#2019-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3861" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向变量类型添加已配置的方法以提高编码效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4aa26f1b9374d0831ab8e99138035ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1WKa7KktbgPJEPEVbbQDQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯图尔特·弗里斯比在<a class="ae ky" href="https://unsplash.com/search/photos/barbican-estate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="d7d1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">现行标准</h1><p id="5b8e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们的Swift代码库中，我们广泛使用了“<a class="ae ky" href="https://medium.com/the-traveled-ios-developers-guide/swift-initialization-with-closures-5ea177f65a5" rel="noopener">闭包初始化</a>”标准。例如，不要这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="34cd" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">我们会这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9d16" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">这是一个很好的标准，有很多优点。例如，它在代码中提供了一个清晰的单一位置，在这里完成了特定UI元素的大部分(如果不是全部)配置。</p><p id="c272" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">然而，您可能已经注意到，我们被迫写出变量的类型两次——一次声明变量的类型，一次初始化它的值。</p><p id="f49b" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">在某些情况下，这可能是需要的。面向外部的类型从内部类型中分离出来，结合多态性(通过子类化或通过协议)，允许我们使用最有用的通用类型来声明变量，并对任何客户端隐藏实际类型的细节。例如，我可能声明了一个<code class="fe mu mv mw mx b">UILabel</code>属性，但是用我自己的<code class="fe mu mv mw mx b">FancyLabel</code>子类的一个实例来初始化这个值。或者，我可能将属性声明为<code class="fe mu mv mw mx b">UITableViewDataSource</code>，并交替使用各种符合类型作为实际值，而不必担心这会如何影响属性的客户端。</p><p id="019a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">然而，在实践中，我们并不经常获得这种优势；我们通常声明和初始化完全相同的类型。如果你在这个标准中创建了足够多的变量，它就会变得有点乏味。此外，当使用一种已经很乏味的类型时，这种乏味会加倍。例如，尝试声明以下几个变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="db41" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">一个更手指友好的标准怎么样？</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="216d" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">看这个问题</h1><p id="c0a0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们希望将使用闭包初始化标准的<em class="nk">而不是</em>的优势——即从初始化中推断变量类型的能力——与标准的优势相结合——例如将对象配置作为其声明的一部分。</p><p id="7ae3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">由于Swift的半功能范式，我们已经有了这种可能的模式。这个范例允许我们替换如下的多语句序列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="64f0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">有了这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e544" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">所以从这种类型的语法中得到启示，我建议我们添加一个<code class="fe mu mv mw mx b">configured</code>方法到我们想要在声明时配置的变量类型中。这基本上就像能够对单个变量进行<code class="fe mu mv mw mx b">map</code>运算。所以让我们开始吧！</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="dfb0" class="kz la it bd lb lc nf le lf lg ng li lj jz nh ka ll kc ni kd ln kf nj kg lp lq bi translated">添加配置方法</h1><p id="ef63" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的配置方法非常简单，所有类型的实现都是一样的。向任意类型添加方法的一个简单方法是声明一个协议，然后用要添加的方法扩展该协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5239" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">任何类型的人现在只要符合<code class="fe mu mv mw mx b">InlineConfigurable</code>就可以免费获得这个方法。让我们延长<code class="fe mu mv mw mx b">NSObject</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="27f9" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">就这样，各种iOS SDKs提供的大部分类型都是可以神奇配置的。如果我们想要我们自己定义的类型的这个功能，我们可以从<code class="fe mu mv mw mx b">NSObject</code>继承它们或者简单地使它们符合<code class="fe mu mv mw mx b">InlineConfigurable</code>。</p><p id="e9e7" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">最后，这是我们如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9956" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">Blammo！</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="485c" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">2019年8月9日更新</h2><p id="8cb4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我做了一个椰子版的。它叫做PHBApplying，你可以这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a536" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">我把名字从<code class="fe mu mv mw mx b">configured</code>改成了<code class="fe mu mv mw mx b">applying</code>，因为正如<a class="ae ky" href="https://medium.com/@MaciejNajbar" rel="noopener"> Maciej Najbar </a>在评论中指出的，这个概念在Kotlin中被称为<code class="fe mu mv mw mx b">apply</code>(感谢Maciej！)</p><p id="fe45" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">我还发现这个概念已经被实现为一个叫做<a class="ae ky" href="https://github.com/devxoul/Then" rel="noopener ugc nofollow" target="_blank">然后是</a>的CocoaPod。他们现有的实现比我自己的高一级，但是我不同意这个命名，因为<code class="fe mu mv mw mx b">then</code>通常与异步操作相关联。</p><p id="a2fa" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">参见<a class="ae ky" href="https://github.com/phlippieb/PHBApplying" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或<a class="ae ky" href="https://cocoapods.org/pods/PHBApplying" rel="noopener ugc nofollow" target="_blank"> CocoaPods </a>上的PHBApplying。</p><p id="7850" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">感谢阅读！</p></div></div>    
</body>
</html>