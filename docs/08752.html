<html>
<head>
<title>Understanding AsyncImage in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解SwiftUI中的AsyncImage</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-asyncimage-in-swiftui-55dd2fb6a86e?source=collection_archive---------6-----------------------#2021-06-08">https://betterprogramming.pub/understanding-asyncimage-in-swiftui-55dd2fb6a86e?source=collection_archive---------6-----------------------#2021-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9a6c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">首先查看异步加载和显示图像的新视图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b7796d68e4d6f7becd72757986898858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LroMOvoWcRyZ16B-bvWXw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@bugsster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Taras Shypka </a>在<a class="ae ky" href="https://unsplash.com/s/photos/xcode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="e523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在WWDC 2021上，苹果推出了大量新的SwiftUI功能，这些功能将允许开发者更加流畅地创建iOS应用。最令人期待的特性之一是使用<code class="fe lv lw lx ly b">Image</code>视图显示图像的能力。在SwiftUI的早期版本中，这是不可能的，必须使用自定义代码来实现。</p><p id="a5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在iOS 15和Xcode 13中，苹果推出了<code class="fe lv lw lx ly b">AsyncImage</code>，允许你只使用网址下载图片。在本文中，我们将看看如何在SwiftUI应用程序中使用<code class="fe lv lw lx ly b">AsyncImage</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8e2a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">履行</h1><p id="9b83" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">AsyncImage</code>使用起来非常简单。只需提供一个图像的网址，你就完成了。这显示在下面的实现中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="208c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b6fbabee15d6d7ccf2b1ee8fc4a5c8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*PaWtFm0UCXTEIQu9GG1Dhw.png"/></div></figure><p id="cef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，对吧？</p><p id="d006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AsyncImage</code>还提供了添加占位符视图的功能，该视图在主图像加载时显示。占位符视图可以是任何视图，但是要确保它返回一个<code class="fe lv lw lx ly b">View</code>类型。下面是一个使用<code class="fe lv lw lx ly b">LoadingView</code>作为占位符视图的<code class="fe lv lw lx ly b">AsyncImage</code>的简单实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cb06a3c945cacdcc5468d63ac7bd5002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/1*o13A1yYXnlUEUiMMqvaxmg.gif"/></div></figure><p id="47ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AsyncImage</code>确实提供了其他几个特性，可以帮助处理图像的不同加载状态。这些状态包括:</p><ul class=""><li id="e334" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">当映像成功加载时。</li><li id="a912" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">当图像被加载时。</li><li id="051d" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">当图像加载失败时。</li></ul><p id="b444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="936d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们使用了<code class="fe lv lw lx ly b">AsyncImagePhase</code>特性来检查下载图像的不同阶段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阶段结束时，我们检查是否可以访问图像。如果我们做了，那么我们简单地返回它。如果我们有一个错误，那么我们返回一个<code class="fe lv lw lx ly b">View</code>来显示这个错误。最后，当图像还没有加载时，我们显示<code class="fe lv lw lx ly b">LoadingView</code>，错误也是<code class="fe lv lw lx ly b">nil</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f065" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在列表中显示图像</h1><p id="7abf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">AsyncImage</code>也可用于在<code class="fe lv lw lx ly b">List</code>视图中显示图像。不幸的是，在这一点上，<code class="fe lv lw lx ly b">AsyncImage</code>并没有缓存图像。这意味着相同的图像被再次下载。让我们来看看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，<code class="fe lv lw lx ly b">loadPhotos</code>使用Swift的<code class="fe lv lw lx ly b">async/await</code>特性来执行和等待异步任务。一旦发出请求，<code class="fe lv lw lx ly b">await</code>会确保线程被挂起，并可用于其他任务。最后，<code class="fe lv lw lx ly b">URLSession</code>完成下载资源并填充<code class="fe lv lw lx ly b">photos</code>数组。</p><p id="e3f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI视图中，我们调用<code class="fe lv lw lx ly b">loadPhotos</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的任务修饰符允许我们在视图出现时执行代码，然后在视图消失时取消。在任务修改器中，我们使用异步闭包调用<code class="fe lv lw lx ly b">loadPhotos</code>并填充照片。</p><p id="b516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nv">注意:为了简单起见，本文没有使用任何架构模式。在实际的应用程序中，你应该使用MVVM、MVC或任何其他模式，这样你的视图就不会直接进行网络调用。</em></p><p id="d368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f0c73eee81227451719ae63446debe31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/1*pe_CEW5VPrEQZYUGtknctQ.gif"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5468" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="93d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">AsyncImage</code>是SwiftUI中一个受欢迎的特性，它减少了我们为下载图像而必须编写的定制代码的数量。我们希望它将来能支持更多的功能，包括缓存。</p><p id="5484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解Swift语言中新的Async/Await &amp; Actor功能。请查看以下我的课程:</p><div class="nw nx gp gr ny nz"><a href="https://www.udemy.com/course/asyncawait-and-actors-concurrency-in-swift/?couponCode=LAUNCHDAY" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">Async/Await和Actors—Swift中的并发性</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">并发允许多个任务同时运行。理解并发是iOS应用的重要组成部分…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.udemy.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>