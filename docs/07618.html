<html>
<head>
<title>Module Bundlers in 5 Minutes — the What, the Why, and the Which</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5分钟内完成模块打包——什么、为什么和什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-module-bundlers-2a1e9307d057?source=collection_archive---------7-----------------------#2021-02-02">https://betterprogramming.pub/javascript-module-bundlers-2a1e9307d057?source=collection_archive---------7-----------------------#2021-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解模块捆绑器在web开发中的作用，并使用三个流行的选项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/459e2baa8b6d55c2737690a39aa7cde2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCuqlnieqcHP1BboRCGk_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景图像—无飞溅</p></figure><p id="61ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块打包工 —你可能已经听说过他们一千次了，但是你有没有想过他们的必要性或者他们在幕后做什么？为了理解它们的作用，我们需要回到过去一点。所以，让我们开始吧。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="43b2" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么我们需要一个模块捆绑器？</h1><p id="e177" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">回到古代，建立一个网站只需要HTML、JS、CSS，事情就简单多了。但当互联网呈指数级增长时，构建更复杂的网页和应用程序的需求也在增长。想象一下，我们正在用传统的方式编写一个复杂的网站，只使用这三个。在理想的情况下，为了简单起见，我们将JS分成不同的文件，并将它们包含在HTML中。这里有一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/44377de8e9f9af9183b576d3d7212460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VCSjDdjsa9MKSyw3atIYw.png"/></div></div></figure><p id="741c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在这种情况下，每个文件将发出单独的HTTP请求，这导致了加载应用程序工作所需的所有内容的五个请求。为了避免这种情况，我们可以将它们合并成一个文件，其中包含所有内容，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/5b58f575dca8c58359833f0539713455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnkwnNu4OwSInt-6JAOLag.png"/></div></div></figure><p id="65c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这使得手动管理文件变得复杂和庞大。这不是一个容易或简单的过程。例如，两个文件可能具有相同的函数和变量，在部署之前解决问题将是一件令人头疼的事情。</p><p id="f329" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们考虑一个更现代的项目例子，它是用Angular这样的JS框架构建的，并且使用了npm的库。这在部署时会导致更多的问题。在构建时，我们会有太多的文件需要手动跟踪。如果项目依赖于某个库，那么该库可能依赖于多个其他库才能工作。这将要求开发人员在构建时创建一个复杂而庞大的依赖关系图。</p><p id="ae2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个问题是确保您编写的或库使用的JS代码在所有浏览器上的工作方式都是一样的。您可能需要为一些功能编写不同的代码集，以便在传统浏览器上工作。</p><p id="dc27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使我们克服了上述所有问题，以某种方式合并了所有内容——没有任何名称冲突或范围问题——在花费了太多的开发时间后，它可能会创建一个巨大的JS文件。这个文件将大大增加我们网站的加载时间，因为所有的东西都以一种非优化的方式捆绑在一起。不用说，所有这些花在开发应用上的时间实际上可以用来开发更多的功能或增强我们的web应用。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4212" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是模块捆绑器？</h1><p id="d552" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">用最简单的术语来解释，模块捆绑器是一个开发工具，它可以修复上面提到的所有问题，从而节省时间并优化我们的应用程序以获得最佳性能。模块捆绑器最重要的任务之一是获取多个JS文件，并将它们组合起来创建一个文件，该文件包含我们编写的代码以及加载到浏览器中所需的库。</p><p id="dd9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目中的库可能有多个依赖项，每个依赖项可能都有自己的依赖项。bundler创建一个依赖图来跟踪这一点，我们所要做的就是指定项目的入口点。例如，如果App.js是我们的入口点，那么bundler将扫描文件的依赖性，然后扫描每个产生的依赖性文件来创建图形。这是非常重要的——没有它，浏览器就不知道在哪里寻找我们在项目中使用的任何模块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/2b2c3a0e86c3cad5f42345462c1abbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zkQaJaksuPEdGtDX.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模块捆绑器如何将项目提取到静态资产中的示例。</p></figure><p id="5e8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">bundler还通过将所有CSS文件合并到一个缩小的文件中，为CSS等其他文件创建类似的过程。图像、字体等资产。，也被映射并捆绑在一起以获得最佳性能。捆绑器还允许您定制整个过程，以满足项目的各种需求。</p><p id="4b10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总而言之，现代web项目需要模块捆绑器，因为:</p><ul class=""><li id="bda9" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated">它帮助开发人员管理项目中的依赖关系，如果手动完成，这将花费大量时间。此外，它还可以帮助您按照依赖顺序加载模块。</li><li id="d2f9" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">避免浏览器不完全支持模块系统的问题。</li><li id="0497" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">它有助于转换、优化和精简我们的代码，使其正常工作</li><li id="f435" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">它有助于优化和加载资产，如CSS，图像等。，按照它们的依赖顺序</li></ul><p id="04b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们来看看一些最流行的模块打包器</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="23e1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">1.网络包</h1><p id="7c28" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Webpack是目前最流行的静态模块打包工具之一。它按照模块捆绑器应该工作的方式工作——通过构建依赖图来映射项目需要的每个模块。Webpack的一些优点和缺点包括:</p><ul class=""><li id="de7d" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated">基于可定制的配置生成输出。我们可以定制分割点，在同一个项目中创建单独的包。</li><li id="5ccd" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">更多地控制如何对待遇到的不同资产。</li><li id="41eb" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">丰富灵活的插件基础设施。</li><li id="0fba" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">需要时间来学习，包括理解复杂的配置文件，它的语法有点难以掌握。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="2d5d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">2.卷曲</h1><p id="63aa" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><a class="ae np" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>是另一个流行的模块捆绑器，它使用JavaScript的ES6修订版中包含的代码模块的新标准化格式，而不是以前的特殊解决方案，如CommonJS和AMD。选择汇总时需要注意的一些要点是:</p><ul class=""><li id="1633" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated">与Webpack相比，Rollup生成的包要小得多，并且没有<strong class="la iu">模块映射。</strong></li><li id="18e0" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">汇总具有用于导入/导出的节点聚合填充。</li><li id="0acf" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">Rollup支持配置中的相对路径。</li><li id="0843" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">所有的模块都被<strong class="la iu">【展平】</strong>成<strong class="la iu"> </strong>的包，还有<strong class="la iu"> </strong>没有功能包装的模块。这在许多情况下非常有用，但是当存在循环依赖时，它并不总是工作得很好。</li><li id="073e" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">它不支持异步/等待开箱即用。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="36fb" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak"> 3。包裹</strong></h1><p id="5386" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Parcel<a class="ae np" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">与其他两个类似，除了它比其他两个做得更有效率。比如<em class="nq">死码消除</em>或者更俗称<em class="nq">树摇。</em>包支持ES6和CommonJS模块的树摇动。选择要构建的宗地时，您会得到以下结果:</a></p><ul class=""><li id="105a" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated">对JS、CSS、HTML、图像等的现成支持。，不需要插件。</li><li id="6821" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">它可以拆分输出包，使我们能够只加载最初需要的内容。</li><li id="ed71" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">当出现错误时，它可以精确定位代码帧，因此我们可以更快地定位问题。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7d63" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">4.积雪场</h1><p id="1e83" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在这个列表中，Snowpack是我个人最喜欢的，也是bundler世界的最新成员。由于同样的原因，它有很多优点，也有一些局限性。为了增加视角，Webpack在2012年发布——甚至在ES模块存在之前。而Snowpack是在2019年现代浏览器支持ES模块和ESNext的时候出现的。</p><p id="9caa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当其他打包程序转换你的代码时，Snowpack更多的是一个安装时工具，而不是。例如，Webpack具有令人印象深刻的捆绑功能，每次我们对项目进行更改时，它都需要时间来生成构建。另一方面，Snowpack不需要花时间来做这件事，因为它不需要为每一个变化重新构建项目。使用Snowpack的一些主要优点是:</p><ul class=""><li id="5a27" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated">直接为浏览器编写ES模块，允许即时预览代码。</li><li id="0f9a" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">仅重建已更改的特定文件，而不是重建所有依赖项。</li><li id="27a8" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">更高效的缓存——如果代码或npm依赖项发生变化，访问网站的用户只需下载发生变化的确切文件和依赖项。不多不少！</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="56a7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="e584" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">好了，暂时就这样了。如果你以前没有用过Snowpack，你可能想试试它，看看它有多简单和高效。</p><p id="d10c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，如果您不熟悉整个模块捆绑器的概念，了解它们的最佳方式是尝试创建一个非常简单的项目，并使用不同的捆绑器和不同的配置来实验构建它。比较结果，然后尝试在更大的项目中根据您的需要定制它们，以掌握捆绑的艺术，从而创建更快、更高效的web应用程序。</p></div></div>    
</body>
</html>