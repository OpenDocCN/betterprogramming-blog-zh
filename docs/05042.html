<html>
<head>
<title>A Comprehensive Guide to Handling Exceptions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中处理异常的综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-comprehensive-guide-to-handling-exceptions-in-python-7175f0ce81f7?source=collection_archive---------2-----------------------#2020-06-03">https://betterprogramming.pub/a-comprehensive-guide-to-handling-exceptions-in-python-7175f0ce81f7?source=collection_archive---------2-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e37" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python异常处理最佳实践的注意事项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/591bf1f4ded0c6192d19665b81296546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fo9VNC5yp_AZnayb8K7B0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/collections/9641853/i-am-a-creator%3A-chaitra-radhakrishna?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@convertkit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">转换器</a>拍摄的照片</p></figure><p id="21be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有人希望他们的代码抛出错误，但是Python中的异常可以有各种各样的用例，并且对于编写好的代码至关重要。</p><p id="b997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文描述了编写异常时应该做什么和不应该做什么的一些例子。希望它能让您对异常处理有更深的理解，并提供一些有用的Python技巧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ba2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一定要写很多异常</h1><ul class=""><li id="cd08" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe nf ng nh ni b">AttemptedToAccessCoreDatabasePriorToDatabaseTransactionBeingInitiatedException</code></li><li id="66a3" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><code class="fe nf ng nh ni b">JavascriptMillisecondTimeFormatBufferOverflowException</code></li><li id="dd56" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated"><code class="fe nf ng nh ni b">CannotDeleteUserAccountThatDoesntExistException</code></li></ul><p id="3134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例外，例外，到处都是例外。这些名字读起来很有挑战性，而且打字很长，但是它们真的那么可怕吗？</p><p id="d69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些异常非常好地提供了最有价值的功能——它们是具体的、信息丰富的、切中要害的。</p><p id="9831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，最后一个可能会被重命名为<code class="fe nf ng nh ni b">CannotDeleteNonExistentUser</code>，当然，但关键是他们很清楚。你知道去哪里找到问题，你也知道如何<code class="fe nf ng nh ni b">try except</code>删除一个已经被删除的用户。</p><p id="6f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Atom、Visual Studio和IntelliJ出现之前，在Vi和Nano领域，可变的名称长度实际上会影响开发人员的工作效率。</p><p id="ba5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用Vim学习了C语言编码，没有自动完成功能。是的，我曾经给东西起名<code class="fe nf ng nh ni b">int num</code>或<code class="fe nf ng nh ni b">char* s1</code>。当然，我很懒。当然，我是一个年轻的学生。而且，我必须在<code class="fe nf ng nh ni b">num</code>中输入所有这三个字符。这些天，在我的IDE意识到我在做什么并完成工作之前，我会幸运地输入两个以上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/3ca804aac12a350a685acb0dc89018e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYj5LYJelZURH2r2J_onew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Year_2038_problem" rel="noopener ugc nofollow" target="_blank">2038年将会是非常奇怪的一年……</a></p></figure><p id="21d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长名字不再会减慢开发速度，但是对于调试或阅读代码的人来说，它们确实有很大的好处。没错——异常不仅仅是为了调试或处理。他们也帮助人们理解正在发生的事情。举下面这个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些供应商只想看着整个世界燃烧。</p><p id="a038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们肯定可以重构它，使响应代码成为enum或类似的表达格式，但是在这段代码中没有混淆，无论这些随机响应代码是什么，它们都意味着我们没有启用双因素身份验证，我们需要在我们的示例提供程序中配置此设置以使其工作。</p><p id="cad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则:只要你有关于特定的、可复制的边缘案例的信息，就使用它。</p><p id="e15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为什么要为异常费心呢？我们在测试中一直使用断言，它们做得很好。为什么不直接用它们来代替异常呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab48" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">除非你在测试中，否则不要“断言”</h1><p id="1bc6" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated"><code class="fe nf ng nh ni b">assert</code>和<code class="fe nf ng nh ni b">raise</code>似乎功能相似。两者都停止控制流，两者都可以终止程序，两者都可以记录/打印一条解释原因的消息。</p><p id="bd0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，使用<code class="fe nf ng nh ni b">assert</code> s来确认一切都处于有效状态似乎很诱人，但是这在企业Python开发中被认为是不好的做法。有几个原因，他们可以成为自己的一篇文章。</p><p id="d78a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是长话短说:你可以定制异常处理和异常细节，并且异常<code class="fe nf ng nh ni b">raises</code>永远不会被<a class="ae ky" href="https://github.com/IdentityPython/pysaml2/issues/451" rel="noopener ugc nofollow" target="_blank">“优化”出你的代码</a>。</p><p id="fd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经验法则:</strong>你应该只断言<em class="nu">不可能的条件，</em>比如断言你刚刚平方的值不是负的(假设你没有在模拟量子物理或其他同样疯狂的东西)。如果断言失败的可能性微乎其微，那么就应该用异常来代替它。</p><p id="108f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们经常犯这种错误的一个典型例子是在与第三方提供商打交道时。</p><p id="ceea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你正在你的应用程序中调用一个雅虎天气API，你决定添加一个<code class="fe nf ng nh ni b">assert</code>到<code class="fe nf ng nh ni b">response is not None</code>。您选择了一个<code class="fe nf ng nh ni b">assert</code>,因为Yahoo总是返回天气信息(尽管预测可能不总是正确的)。</p><p id="f722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当雅虎的天气API遭遇中断时会发生什么呢？突然间，你所有的服务都失败了，你所能做的就是<code class="fe nf ng nh ni b">AssertionError: response is None</code>。</p><p id="e42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我敢肯定雅虎天气可能是非常可靠的，你可能有你的日志行号。但是没有理由不花一分钟的额外开发时间来创建一个<code class="fe nf ng nh ni b">WeatherProviderUnresponsiveException</code> ( <a class="ae ky" href="https://martinfowler.com/bliki/TwoHardThings.html" rel="noopener ugc nofollow" target="_blank">“给事物命名很难……【让作者休息一下】”— Phil Karlton </a>)。</p><p id="5291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，我们应该使用大量的异常，但是我们应该使用哪些异常呢？在深入研究之前，我们需要理解异常处理(以及一般的编程)中的一个关键概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2e18" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">快速切线—什么是类型继承？</h1><p id="9520" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">让我们从最基本的开始，因为有很多东西需要解开。</p><p id="4217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，继承。当Python中的一个类从另一个类继承时，它会采用所有的方法和属性，但它也会采用父类的类型——也就是说，在Python的世界中，我是我自己，但我也是我的父亲和母亲。即使您覆盖了父类的方法或属性，您仍然会保留类型继承。让我们看一些代码来解释。</p><p id="513c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，有一点需要注意:类并不完全是类型，<a class="ae ky" href="https://stackoverflow.com/questions/4162578/python-terminology-class-vs-type" rel="noopener ugc nofollow" target="_blank">但是它们有点像</a>。好了，现在你比以前更困惑了，让我们看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里定义了一些自定义类型，它们都继承自内置的<code class="fe nf ng nh ni b">dict</code>类。以<code class="fe nf ng nh ni b">RedDict</code>为例，它有<code class="fe nf ng nh ni b">RedDict</code>类型，也有<code class="fe nf ng nh ni b">dict</code>。</p><p id="5534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">isinstance(red_map, dict) # True</code></p><p id="0027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">isinstance(red_map, RedDict) # True</code></p><p id="e68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，反过来就不正确了——因为<code class="fe nf ng nh ni b">RedDict</code>不是<code class="fe nf ng nh ni b">PurpleDict</code>。</p><p id="d861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">isinstance(red_map, PurpleDict) # False</code></p><p id="95ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码片段来查看上面所有类的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/4170eb2318d4b45c4f4741402b253e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2Waiz-Rr3fXPUxwygRing.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Python中，你可以对象化任何东西，因为任何东西都是对象</p></figure><p id="742c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在让我们回到刚才的地方…</p><p id="5c0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">try:<br/> segway_about_types()<br/>except OnATangentError, Exception as e:<br/> smooth_transition(e)</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f266" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要捕捉/ Except“异常为e”</h1><p id="a7c3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">捕捉所有异常并丢弃它们是第二个最有效的方法来获得无bug的代码(<a class="ae ky" href="https://www.youtube.com/watch?v=ySDX02WD0og" rel="noopener ugc nofollow" target="_blank">第一个是删除所有代码</a>)。所以这肯定意味着它是好的，对吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">捕获<code class="fe nf ng nh ni b">Exception</code>的问题与类型继承有关(因此是间歇期),因为我们不仅要捕获应用程序中的所有自定义异常，还要捕获大量Python内置的异常，包括一些您可能不想丢弃的异常。</p><p id="231a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python内置的异常具有复杂的继承结构。这是来自文档的最新列表，其中每个缩进都表示继承。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f3a2cfc5f38e83754b20050528493f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pp5jlYXgAQSW68rSwyIWAA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你不希望<a class="ae ky" href="https://docs.python.org/3/library/exceptions.html" rel="noopener ugc nofollow" target="_blank"> Python3文档</a>有漂亮的图表吗？</p></figure><p id="cb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种层次结构有一个很好的理由，所以你可以使用类型继承来聪明地捕捉异常(见下一点)。</p><p id="a9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚学到的类型继承告诉我们，这意味着一个<code class="fe nf ng nh ni b">TypeError</code>也是一个<code class="fe nf ng nh ni b">Exception</code>(它的父)，所以当我们捕获<code class="fe nf ng nh ni b">Exception</code>时，<code class="fe nf ng nh ni b">TypeError</code> s也会被捕获。这可能没问题。</p><p id="64f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe nf ng nh ni b">ModuleNotFoundError</code>呢？如果你的程序完全丢失了一个依赖项，你真的希望它继续运行吗？那<code class="fe nf ng nh ni b">MemoryError</code>呢？当然，当Python在你的记忆卡中窒息的时候，你不想回头。</p><p id="4438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不仅会捕捉到所有这些疯狂而奇妙的内置异常，还会捕捉到所有自定义异常(是的，除了那些从<code class="fe nf ng nh ni b">BaseException</code>而不是<code class="fe nf ng nh ni b">Exception</code>派生的异常)。</p><p id="5e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这真的是你想做的吗？或许，解决方案是捕获多个特定的自定义异常(通过元组实现)，如下所示:</p><p id="c6e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">except (FileNotFoundError, IsADirectoryError, PermissionError) as e:</code></p><p id="b9c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将安全地捕捉到一个<code class="fe nf ng nh ni b">FileNotFoundError</code>，但不会捕捉到更危险的<code class="fe nf ng nh ni b">OSError</code>，比如<code class="fe nf ng nh ni b">ChildProcessError</code>。</p><p id="c384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，有些情况下，捕捉所有异常是您想要做的，但是这种情况很少。同样需要注意的是，如何处理异常在这里也很重要。如果您捕获了所有异常，但随后再次引发该异常或使用<code class="fe nf ng nh ni b">logger.exception()</code>，这不是问题。</p><p id="ef5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望捕获所有异常的一些示例:</p><ul class=""><li id="56ce" class="mu mv it lb b lc ld lf lg li nx lm ny lq nz lu nb nc nd ne bi translated">在从队列中提取消息并一次处理一条消息时，您可以使用<code class="fe nf ng nh ni b">logger.exception()</code>来记录问题，而不会中断流程</li><li id="4419" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated">作为服务级别的混乱工程实践的一部分，特别是对于异步服务，你可以捕捉所有的异常，安全地关闭一切，然后引发或记录异常</li><li id="6629" class="mu mv it lb b lc nj lf nk li nl lm nm lq nn lu nb nc nd ne bi translated">Web抓取或爬行链接是一项肮脏的任务，经常会抛出各种错误——在某些情况下，这需要非常广泛的异常处理。</li></ul><p id="c551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经验法则:</strong>尽可能捕捉具体的错误。除非你确切知道自己在做什么，否则不要抓到<code class="fe nf ng nh ni b">Exception as e</code>。</p><p id="6ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确实提到过内置的异常层次很有用。让我们来看看例外是如何为我们服务的，而不是对我们不利的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="99fe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在合理的情况下，一定要使用内置异常</h1><p id="6917" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">这可能听起来像是对早期编写大量异常的反驳，但有时使用简单的内置Python异常(如<code class="fe nf ng nh ni b">ValueError</code>或TypeError)是有意义的。</p><p id="cb34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你正在制造一辆汽车，它可以是电力驱动的，汽油驱动的，或者是混合动力的，你想要传递两个布尔值来创建一辆指定引擎类型的汽车。</p><p id="660f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个适合使用<code class="fe nf ng nh ni b">ValueError</code>的完美例子。您不能在您的函数定义(RIP覆盖函数)中定义至少一个electric或petrols必须是<code class="fe nf ng nh ni b">true</code>的规则，因此您需要手动检查这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="00bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这是一个人为的例子，我创建它来证明一个观点——不要像这样使用布尔标志。</p><p id="570d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个使用<code class="fe nf ng nh ni b">inbuild ValueError</code>的好机会，因为许多程序可能会<code class="fe nf ng nh ni b">try except</code>这个错误并使用它。例如，一个自动运行参数测试的程序可能会运行每一个<code class="fe nf ng nh ni b">true</code>、<code class="fe nf ng nh ni b">false</code>和<code class="fe nf ng nh ni b">except</code>的组合，并跳过任何返回<code class="fe nf ng nh ni b">ValueErrors</code>的组合。</p><p id="6489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我喜欢更进一步。我们可以使用类型继承来增加代码的可读性，方法是从更具体的异常(如<code class="fe nf ng nh ni b">ValueError</code>)中继承我们的异常。这样，任何捕获<code class="fe nf ng nh ni b">ValueError</code>的程序也会捕获我们的异常，但是我们可以添加自定义代码和名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d7bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必须…写…更多…异常。</p><p id="0aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经验法则:</strong>总是尽可能从特定的内建异常中继承。如果您没有任何额外的信息要添加，就使用内置的异常。</p><p id="0b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关内置Python异常及其层次结构的完整列表，请参见<a class="ae ky" href="https://docs.python.org/3/library/exceptions.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要将敏感数据放在异常消息中</h1><p id="fc86" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我想要一个安全的系统，所以这很有意义。(不确定这是什么意思？<a class="ae ky" href="https://medium.com/better-programming/why-is-there-an-f-before-this-string-9a87e6d43563" rel="noopener">查看这篇文章</a>)。</p><p id="5427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的例外——这个例外的含义很清楚，我已经提供了足够的信息，而且它足够具体，可以安全地包装在一个try中——例如，如果我们对管理员密码比对用户密码更放松的话，就会有不同的处理方式。</p><p id="3bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题归结为敏感数据。我在这里用了一个不公平的例子，所以我希望你能明白这不是一个好的例外。这种异常将通过您的日志、响应、监控软件，甚至可能落入不良分子的手中，输出原始文本密码。</p><p id="5a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">供内部使用的异常(参见底部关于面向客户端的异常的注释)可以包含技术细节，如<code class="fe nf ng nh ni b">user_ids</code>或导致崩溃的特定数据，但重要的是要记住，当异常发生时，这些消息将通过日志记录、报告和监控软件广泛传播——如果您不小心，可能会传播到您的用户。</p><p id="868f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这一切都归结于良好的软件设计，但在一个围绕个人数据的监管不断变得越来越严格的世界<a class="ae ky" href="https://www.enforcementtracker.com/" rel="noopener ugc nofollow" target="_blank"/>，你怎么小心都不为过，而且几乎总是有可能在不损害客户隐私的情况下提供有价值的错误信息。</p><p id="0bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经验法则:</strong>不要在异常消息中使用敏感信息。</p><p id="0e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，你需要担心的不仅仅是客户隐私。坏演员无处不在。</p><p id="a429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你运营一个网站，用户供应量很大，你计算这个数字的因子。我们姑且称你的网站为<code class="fe nf ng nh ni b">FactoriseMe.com</code>。</p><p id="de43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你即将提高你的种子投资，但是市场上突然出现了一个竞争者，<code class="fe nf ng nh ni b">NumbersWithinNumbers.com</code>。你已经测试了他们的产品，虽然它能工作，但没有你的快。而且客户体验差很多。</p><p id="02ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的一位开发人员注意到，对于非常大的数字，您的后端服务很难计算这些因子——事实上，对于非常非常大的数字，该服务花费了整整180秒来处理数字，然后超时。</p><p id="dda7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您决定继续改善您的客户体验，向客户回复一个很好的错误:“计算器在计算系数时超时。不好意思，这几个比较硬。”</p><p id="f838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太棒了。现在客户知道为什么网站找不到任何因素了。你走进你的投资者给一个演示，突然你的网站关闭了。发生了什么事？</p><p id="ac32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看日志后，您注意到在上午9点到10点之间，您收到了1，000个数量巨大的请求，来自路那头的一个IP地址，离NumbersWithinNumbers总部不远。这些请求使您的后端服务超载，并使您的网站崩溃。发生了什么事？</p><p id="9f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你暴露了你的弱点。永远不要暴露你的弱点。或者至少不要向用户暴露你的软件内部工作的弱点。黑客、竞争对手、巨魔，互联网上到处都是想要破坏你所建立的东西的人。是的，你应该给你的用户关于正在发生的事情的反馈，但是永远不要告诉他们你的软件的内部工作方式。</p><p id="39e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经验法则:</strong>告诉用户他们能做什么，而不是发生了什么。</p><p id="1cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会发现这在许多应用程序中都很常见:“请稍后再试。”“如果这种情况再次发生，请联系支持人员。”“未知错误—很抱歉，我们正在调查。”</p><p id="13e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现在这整件事都跑题了，以用户为中心的异常是一个全新的问题。只要记得从天魔书里的骑士身上取一片叶子，假装一切都好就行了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e289" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要与你的代码的严格性相矛盾</h1><p id="111f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">所有这些该做的和不该做的在理论上都很棒，但是在现实世界中，你不得不与其他编写服务的团队打交道，他们有各种各样的例外。</p><p id="bf40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设团队A是创新团队——他们是特立独行的人，不会被你循规蹈矩的工程副总裁驯服。他们决定他们的代码有一个激进的异常策略，在最轻微的变化时抛出异常(在下一点，您将看到为什么这一点也不激进)。另一方面，在团队B中，你从a <code class="fe nf ng nh ni b">TeamBException</code>继承了所有的异常，很少使用它们，只表示严重的问题。</p><p id="8430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，您不得不使用团队A构建的库来完成一个项目，并且发现您甚至不能依赖一个简单的打印函数而不关闭您的服务。您已经到了最后期限，并且您意识到完成任务的唯一方法是用广泛的try——除了<code class="fe nf ng nh ni b">Exception as e</code>子句之外——将所有的接口打包，并且希望一切顺利。不理想。</p><p id="8b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么整个代码库包含一致的异常使用和处理是至关重要的。当涉及到异常处理时，您的工程和技术领导副总裁(以及每个人)应该推动一致的原则和实践，因为不一致会很快成为重大的技术债务。</p><p id="8eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经验法则:</strong>在你的公司里做一个好的异常处理的传播者。如果你的公司有关于例外的政策，那就遵守它。如果没有，为什么不根据这篇文章写一篇呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="910e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一定要捕捉许多特定的异常</h1><p id="e495" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">Python是一种美丽的语言——它非常受欢迎，有大量的学习资源，有各种各样的库，可以做从机器学习到硬件再到网络开发的任何事情。</p><p id="0bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许这就是你选择学习Python的原因，但是对许多人来说，我们选择Python是因为我们相信Python的价值。如果这听起来很邪教，那是因为它是。去你的终端，运行Python。然后输入<code class="fe nf ng nh ni b">import this</code>。你会看到Python的宣言，这是Python语言的19条(<a class="ae ky" href="https://stackoverflow.com/questions/4504487/the-zen-of-python-distils-the-guiding-principles-for-python-into-20-aphorisms-bu/24814971#24814971" rel="noopener ugc nofollow" target="_blank">或20条</a>)格言，作者是它的创造者Tim Peters。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这确实有超越娱乐的价值，因为它提供了对Python背后的使命的洞察，并给了我们如何使用它的提示。这种情况下重要的一行是:</p><blockquote class="oa ob oc"><p id="7894" class="kz la nu lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated">“错误永远不会无声无息地过去。除非明确沉默。”</p></blockquote><p id="8eff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这一点在以上几点中已经说得很清楚了。我把这理解为:“不要捕捉所有的异常，除非你真的打算这样做，并且经常捕捉显式异常。”</p><p id="869c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">社区中的另一个蟒习语是:</p><blockquote class="oa ob oc"><p id="3cd6" class="kz la nu lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated">“请求原谅，而不是许可。”</p></blockquote><p id="99eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Python与C、Java和其他传统语言的传统范例显著不同的地方。Python处理有异常的流程的方式是直接去做，如果出现异常就处理。</p><p id="ede8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在C语言中，在写入文件之前，您可能会编写一行又一行的代码来检查所有的先决条件，例如，文件是否存在，进程是否拥有对文件的写权限，等等。在C语言中，忽略所有这些情况并直接写入文件是不好的做法。</p><p id="54cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，情况完全相反。事实上，在某些情况下，先尝试后处理异常要有效得多。在上面的例子中，虽然文件权限完全有可能是错误的(或者其他问题)，但这是一种边缘情况。大多数情况下，您将写入一个存在且您有访问权限的文件，那么为什么要浪费宝贵的处理能力来检查文件权限呢？</p><p id="15f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理这个问题的Pythonic方法是将写操作包装在一个try-except中，只捕捉可能出现的特定异常/边缘情况，并适当地处理它们。在大多数情况下，写操作会成功，catch块中的任何逻辑都会完全丢失。万一出了问题，我们仍然会处理。</p><p id="10c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<a class="ae ky" href="https://stackoverflow.com/questions/12265451/ask-forgiveness-not-permission-explain" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出线程</a>的更多例子。</p><p id="20b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经验法则:</strong>当你可以预测和捕捉特定的异常时，不要花费过多的时间检查先决条件(例如，请求原谅，而不是许可)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d5e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">但是面向客户的异常怎么办？</h1><p id="eefa" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">客户端例外很好，但是非常不同。</p><p id="3e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南的第2部分将介绍面向客户端的异常与内部异常的不同之处，并将包括一些关于构建简单有效的异常结构的提示。</p></div></div>    
</body>
</html>