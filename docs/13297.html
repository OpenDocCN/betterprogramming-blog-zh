<html>
<head>
<title>Creating a Game Loop in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript创建游戏循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-game-loop-in-javascript-4b4d51c18f67?source=collection_archive---------13-----------------------#2022-08-15">https://betterprogramming.pub/creating-a-game-loop-in-javascript-4b4d51c18f67?source=collection_archive---------13-----------------------#2022-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="16b6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们用一个循环的过程来平滑玩家的移动。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca8870c83ad593263d87fbab401bf9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIgD49RNvTFZpC-olOzzaA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://freepik.com" rel="noopener ugc nofollow" target="_blank"> freepik </a>上的<a class="ae ky" href="https://www.freepik.com/author/stories" rel="noopener ugc nofollow" target="_blank">故事集</a></p></figure><p id="3e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几个月里，我一直在开发一个JavaScript游戏，玩家可以在程序生成的洞穴中漫游。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/59b380c732806511a089c1a46604a1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CC3DvASVF_J2qF5XXFMdqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个游戏关卡的截图，玩家是中间的蓝色方块。敌人是红色的。</p></figure><p id="d7f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个游戏使用带有两个<code class="fe lw lx ly lz b">&lt;canvas&gt;</code>元素的HTML Canvas API:一个用于蓝色玩家，一个用于洞穴、敌人和物品。在我的早期版本中，玩家会从一个方块移动到另一个方块，没有动画过渡。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">瓦片间的移动。</p></figure><p id="0aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让游戏更加流畅，我最近改用了动画的逐像素移动。它不会让玩家立即移动到相邻的瓷砖，而是一次移动一个像素，而不是总是与当前瓷砖对齐，玩家可以坐在两个或更多瓷砖之间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc mb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于像素的平滑移动</p></figure><p id="14b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很快意识到，加入这种流畅的玩家动作需要我重新思考我的游戏逻辑。以下是方法。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b3ad" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">跟踪关键状态</h1><p id="84e1" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在早期的平铺移动中，玩家在屏幕上的位置变化是由用户输入直接触发的。一个监听器等待一个光标键的按下，如果一个光标键被按下，相关的处理函数将移动播放器。</p><p id="801b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一旦我开始制作逐像素运动的动画，断断续续的玩家运动的出现让我意识到浏览器并不总是准备好改变屏幕的外观。如果一个按键立即触发了对<code class="fe lw lx ly lz b">&lt;canvas&gt;</code>元素的更改，游戏可能会在浏览器忙于做其他事情的时候重新绘制。</p><p id="8d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了引入更多的灵活性，我将用户输入从动画中分离出来。因此，按键处理程序不会直接触发玩家在屏幕上位置的改变——它们只是改变当前按下的光标键的内部映射。这是我的<code class="fe lw lx ly lz b">player</code>类中的关键状态图。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="4a5a" class="nl ml it lz b gy nm nn l no np">this.keyDown = {<br/>   left: false,<br/>   up: false,<br/>   down: false,<br/>   right: false<br/>};</span></pre><p id="f92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在按键或按键释放的情况下，这一行代码启动。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="acd5" class="nl ml it lz b gy nm nn l no np">player.keyDown[direction] = val;</span></pre><p id="e5ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个键被释放，<code class="fe lw lx ly lz b">val</code>为假；如果是追问，<code class="fe lw lx ly lz b">val</code>是真的。</p><p id="e314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个按键监听器，可以将地图中的一个键设置为<code class="fe lw lx ly lz b">true</code>。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="27b7" class="nl ml it lz b gy nm nn l no np">document.addEventListener('keydown', handleKeyPress);</span></pre><p id="5abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个按键释放监听器，可以将地图中的一个按键设置回<code class="fe lw lx ly lz b">false</code>。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="6082" class="nl ml it lz b gy nm nn l no np">document.addEventListener('keyup', removeDirection);</span></pre><p id="683e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移动设备上的滑动也模拟按键并改变按键状态的地图。例如，如果用户向上滑动，它被解释为按下“向上”光标键。</p><p id="d486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么如果按下一个键只是更新了键的状态，而不再触发玩家位置的变化，那么玩家是如何移动的呢？为此，我们引入了一个<em class="nq">游戏循环</em>——一个周期性运行的功能，检查按键状态并相应地移动玩家。让我们来看看这是如何工作的。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="d8c1" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">游戏循环</h1><p id="47a6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">游戏循环是通过递归调用自身的<code class="fe lw lx ly lz b">main</code>函数实现的。这是一个没有碰撞检测的游戏循环的简单版本。我正在分享这一个，因为它捕捉了发生的全部故事。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的游戏循环</p></figure><p id="dac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析一下发生了什么。在函数的开始，我们首先调用<code class="fe lw lx ly lz b">scanKeyMap</code>，如果一个键的状态改变了，它会调整玩家的速度。<code class="fe lw lx ly lz b">scanKeyMap</code>会是什么样子？水平移动的一个简单实现如下。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="795c" class="nl ml it lz b gy nm nn l no np">if (keyDown.left) {<br/>    player.velocity.x = -1;<br/>}<br/>else if (keyDown.right) {<br/>    player.velocity.x = 1;<br/>}<br/>else {<br/>    player.velocity.x = 0;<br/>}</span></pre><p id="43a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们调用<code class="fe lw lx ly lz b">movePlayer</code>，根据它的速度改变玩家的坐标。下面是一个多么简单的<code class="fe lw lx ly lz b">movePlayer</code>的实现，它调用<code class="fe lw lx ly lz b">clearRect</code>方法来清除玩家在其<code class="fe lw lx ly lz b">&lt;canvas&gt;</code>元素上的位置，并通过调用<code class="fe lw lx ly lz b">drawPlayer</code>来重绘。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">移动播放器的简单功能。</p></figure><p id="cdb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe lw lx ly lz b">drawPlayer</code>函数在其<code class="fe lw lx ly lz b">&lt;canvas&gt;</code>元素的新位置重新绘制播放器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">drawPlayer函数。</p></figure><p id="fffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，每次主函数运行时，它都会检查键的状态，根据哪个键被按下来调整速度，并通过重画其<code class="fe lw lx ly lz b">&lt;canvas&gt;</code>元素来移动播放器。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="d2d7" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">请求动画帧</h1><p id="c60d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">玩家移动后，我们递归调用<code class="fe lw lx ly lz b">main</code>函数，如下所示。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="b09c" class="nl ml it lz b gy nm nn l no np">const delay = 20;<br/>                                                           <br/>window.requestAnimationFrame(function() {                                        <br/>      main();                               <br/>});                                                               </span></pre><p id="c406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，游戏循环并没有立即调用自己——它使用了一个名为<code class="fe lw lx ly lz b">requestAnimationFrame</code>的方法，该方法将<code class="fe lw lx ly lz b">main()</code>函数作为回调函数。</p><h2 id="b8d9" class="nl ml it bd mm ns nt dn mq nu nv dp mu li nw nx mw lm ny nz my lq oa ob na oc bi translated">将运动同步到浏览器重画</h2><p id="d1bc" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">动画帧请求是游戏循环的关键部分——让我解释一下为什么。</p><p id="634d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当浏览器每次稍微改变<code class="fe lw lx ly lz b">&lt;canvas&gt;</code>元素的外观时，就会出现动画。这种外观上的变化被称为<em class="nq">浏览器重绘。</em>因为重画使用了宝贵的能量和资源，浏览器由于它所负责的其他任务而不总是准备好重画。有时它准备好了，有时没有。</p><p id="137d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们要求代码在下一次重画时执行，而不是强制立即执行<code class="fe lw lx ly lz b">main()</code>函数。通过这种方式，游戏流程与用户的浏览器和硬件准备保持同步。</p><p id="7905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再来看看游戏循环的这一部分。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="78d5" class="nl ml it lz b gy nm nn l no np">window.requestAnimationFrame(function() {                                        <br/>       main();                               <br/>});</span></pre><p id="893b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我调用<code class="fe lw lx ly lz b">requestAnimationFrame</code>时，它在浏览器准备好更新<code class="fe lw lx ly lz b">&lt;canvas&gt;</code>元素时调用<code class="fe lw lx ly lz b">main()</code>。结果，玩家的位置在下一次重画之前被更新。</p><h2 id="c240" class="nl ml it bd mm ns nt dn mq nu nv dp mu li nw nx mw lm ny nz my lq oa ob na oc bi translated">延误和取消</h2><p id="a927" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在更高级的版本中，我调用<code class="fe lw lx ly lz b">setTimeout</code>来延迟帧请求，因为我不需要在每个动画帧中移动播放器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mb l"/></div></figure><p id="65ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一切顺利运行时，每秒钟可以有多达60个动画帧。如果你不需要经常更新，一个小的延迟可以节省浏览器资源，同时保持流畅。</p><p id="8eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更高级的版本中，我捕获了<code class="fe lw lx ly lz b">requestAnimationFrame</code>的返回值，这是框架的ID。然后我将ID存储在我的<code class="fe lw lx ly lz b">game</code>对象中，这样我就可以停止游戏。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="f6f8" class="nl ml it lz b gy nm nn l no np">game.stopMain = window.requestAnimationFrame(function() {<br/>      main(num);<br/>});</span></pre><p id="ebfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lw lx ly lz b">game</code>对象的<code class="fe lw lx ly lz b">reset</code>函数中，我调用了一个叫做<code class="fe lw lx ly lz b">cancelAnimationFrame</code>的方法来停止游戏运行。要取消帧请求，我需要传入我捕获的最新帧ID。</p><pre class="kj kk kl km gt nh lz ni nj aw nk bi"><span id="c68d" class="nl ml it lz b gy nm nn l no np">window.cancelAnimationFrame(this.stopMain);</span></pre><p id="46c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于阻止<code class="fe lw lx ly lz b">main()</code>功能继续运行。</p><p id="927b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更复杂的游戏循环可能不仅仅是移动玩家——例如，它可以检查碰撞，移动敌人，并更新统计显示。请随意尝试这个<a class="ae ky" href="https://roguelike-smooth.netlify.app/demo-9-game/index.html" rel="noopener ugc nofollow" target="_blank">完整游戏</a>，它实现了带有敌人、物品和碰撞检测的游戏循环。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="a99e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">概述</h1><ul class=""><li id="cd00" class="od oe it lb b lc nc lf nd li of lm og lq oh lu oi oj ok ol bi translated">平滑的动画运动最好通过将动画从用户输入中分离出来来处理。</li><li id="6be5" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">游戏循环由一个递归调用自身的<code class="fe lw lx ly lz b">main()</code>函数组成。</li><li id="c941" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">通过使用<code class="fe lw lx ly lz b">requestAnimationFrame</code>，只有当浏览器准备好重画时，才会调用<code class="fe lw lx ly lz b">main()</code>函数。</li><li id="eae4" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated">您可以使用<code class="fe lw lx ly lz b">setTimeout</code>来控制调用<code class="fe lw lx ly lz b">main()</code>函数的频率。</li><li id="66f1" class="od oe it lb b lc om lf on li oo lm op lq oq lu oi oj ok ol bi translated"><code class="fe lw lx ly lz b">cancelAnimationFrame</code>方法可以用来停止游戏循环。</li></ul><p id="c3c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论你是用JavaScript、Python、C#、Swift还是其他语言来构建游戏，游戏循环都是一个很棒的概念，值得实现。</p><p id="4d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下你最喜欢的视频游戏如何使用游戏循环，或者你如何在下一个游戏中使用游戏循环。</p><div class="or os gp gr ot ou"><a href="https://javascript.plainenglish.io/how-to-add-swipe-control-to-a-javascript-roguelike-e8ef327e9930" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">如何在JavaScript游戏中添加滑动控件</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">让我们通过增加对触摸的反应将这个游戏带入现代。</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="c3fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要想无限制地访问我和其他优秀作家的文章，可以考虑 <a class="ae ky" href="https://medium.com/@nevkatz/membership" rel="noopener"> <strong class="lb iu"> <em class="nq">加入媒体</em> </strong> </a> <strong class="lb iu"> <em class="nq">。</em>T11】</strong></p></div></div>    
</body>
</html>