<html>
<head>
<title>Casting in C# — Do type conversion the proper way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的造型——以正确的方式进行类型转换</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/casting-in-c-b0cdb21e6048?source=collection_archive---------8-----------------------#2020-03-11">https://betterprogramming.pub/casting-in-c-b0cdb21e6048?source=collection_archive---------8-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d8f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类型转换是C#编程语言的核心部分，它在处理类型时提供了灵活性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/738da3d3ae50b195f5419a24cd13d8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uQrWSKhU-ckPvNI9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/Z4Sxy1_3wdY" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><div class="kz la gp gr lb lc"><a href="https://dleroari.medium.com/membership" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">dleroari.medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="63de" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">让我们停下来想一想，我们正在给某人传球。收到它的人不知道它是篮球、网球还是足球。这意味着他们不得不猜测，或者我们需要一种方法来通知这个人，以便他们做出正确的反应。</p><p id="2f45" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">幸运的是，在现实世界中，我们知道这些事情，因为我们可以直观地看到它，但在编程中，这些事情必须由编译器以某种方式强制执行。</p><p id="08af" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">编程中的数据类型是一种告诉接收者预期值的方式，有时值是相同的类型，其他时候我们想要改变它们。一种非常重视数据类型的著名编程语言是编程语言<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/" rel="noopener ugc nofollow" target="_blank"> C# </a>。</p><p id="de98" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在C#中，这是一种编译时静态类型的语言，一旦变量被声明，类型就不能改变，除非它是<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions#implicit-numeric-conversions" rel="noopener ugc nofollow" target="_blank">隐式可转换的</a>。</p><p id="317c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">例如，如果我们试图将一个类型为<code class="fe mw mx my mz b">double</code>的变量赋给一个<code class="fe mw mx my mz b">int</code>，编译器会输出一个隐式类型错误，因为我们失去了上下文(小数)。</p><p id="69d9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这些东西有助于我们进行安全的类型转换，防止我们处理损坏的数据，否则，我们最终会得到错误的数据和不满意的客户。</p><p id="b216" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是一个相当短的指南，涵盖了C#中的强制转换，以帮助任何想了解它如何工作以及何时使用它的人。</p><p id="4066" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">本质上，当我们谈论造型时，我们的意思是将变量的类型从A改为b。例如，如果一个变量的类型是<code class="fe mw mx my mz b">int</code>，我们想将其改为<code class="fe mw mx my mz b">double</code>，这个过程称为造型或类型转换。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="d507" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">我们要解决的问题</h1><ol class=""><li id="ddb0" class="nz oa it lt b lu ob lx oc ma od me oe mi of mm og oh oi oj bi translated">隐式铸造</li><li id="c831" class="nz oa it lt b lu ok lx ol ma om me on mi oo mm og oh oi oj bi translated">显式造型</li><li id="dc92" class="nz oa it lt b lu ok lx ol ma om me on mi oo mm og oh oi oj bi translated"><code class="fe mw mx my mz b">is</code>操作员</li><li id="0435" class="nz oa it lt b lu ok lx ol ma om me on mi oo mm og oh oi oj bi translated"><code class="fe mw mx my mz b">as</code>操作员</li></ol></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="4d5b" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">1.隐式铸造</h1><p id="a066" class="pw-post-body-paragraph lr ls it lt b lu ob ju lw lx oc jx lz ma op mc md me oq mg mh mi or mk ml mm im bi translated">隐式转换是指我们在不丢失任何数据的情况下进行类型转换，这也被称为<em class="os">隐式转换</em>。这意味着编译器会自动为我们处理转换。</p><p id="f491" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里有一个很好的<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions#implicit-numeric-conversions" rel="noopener ugc nofollow" target="_blank">列表</a>，它显示了编译器从左向右读取时哪些数据类型可以隐式转换。</p><p id="f772" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果在此过程中丢失了一些信息，编译器会用隐式类型错误通知您，以确保数据没有损坏。下面是一个编译器成功进行隐式转换的例子:</p><pre class="kj kk kl km gt ot mz ou ov aw ow bi"><span id="724f" class="ox ni it mz b gy oy oz l pa pb">// Implicit conversion<br/>int price = 27;<br/>double totalPrice = price; (success)</span></pre><p id="46e5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如上所示，当进行从类型<code class="fe mw mx my mz b">int</code>到<code class="fe mw mx my mz b">double</code>的转换时，值27保持不变。但是如果我们得到不同的结果，比如26而不是27，那么我们就丢失了原始数据。</p><p id="d014" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，让我们看看当有一个相反的隐式转换时会发生什么，从类型<code class="fe mw mx my mz b">double</code>到<code class="fe mw mx my mz b">int</code>，这一次有一些额外的小数:</p><pre class="kj kk kl km gt ot mz ou ov aw ow bi"><span id="02cc" class="ox ni it mz b gy oy oz l pa pb">// Implicit conversion<br/>double price = 49.55; <br/>int totalPrice = price; // Implicit conversion error</span><span id="cb90" class="ox ni it mz b gy pc oz l pa pb">Output: Error CS0266 Cannot implicitly convert type ‘double’ to ‘int’. An explicit conversion exists (are you missing a cast?)</span></pre><p id="40d4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是一个例子，编译器发现当前值已被更改，并通过显示隐式转换错误来标记它。为了理解为什么我们会得到一个错误，我们需要更仔细地看看数据类型支持什么。</p><p id="1e77" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mw mx my mz b">int</code>类型不支持小数(逗号后的值)，但是<code class="fe mw mx my mz b">double</code>类型支持，因此，我们最终会丢失小数<code class="fe mw mx my mz b">.55</code>。所有这些都是因为编译器足够聪明，能够意识到我们正在处理损坏的数据。</p><p id="2f61" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">但是如果我们意识到小数丢失了，并且需要一种方法来通知编译器继续处理，那该怎么办呢？先说显式选角！</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="2344" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">2.显式造型</h1><p id="14f0" class="pw-post-body-paragraph lr ls it lt b lu ob ju lw lx oc jx lz ma op mc md me oq mg mh mi or mk ml mm im bi translated">显式强制转换是指当你进行类型转换时，你接受使用<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-operator-" rel="noopener ugc nofollow" target="_blank">强制转换操作符</a> <code class="fe mw mx my mz b"><a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-operator-" rel="noopener ugc nofollow" target="_blank">()</a></code>会丢失数据。它建立在与隐式转换相同的概念上，除了不管数据丢失它都继续，因为它看到开发人员熟悉它。</p><p id="92f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们来看一个转换示例，其中我们丢失了一些数据:</p><pre class="kj kk kl km gt ot mz ou ov aw ow bi"><span id="e5c4" class="ox ni it mz b gy oy oz l pa pb">// Explicit conversion<br/>double price = 49.55; <br/>int totalPrice = (int)price; // output: 49</span></pre><p id="4fc9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如上所示，唯一的区别是我们添加了带有我们想要转换的类型的<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-operator-" rel="noopener ugc nofollow" target="_blank">转换操作符</a> <code class="fe mw mx my mz b"><a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-operator-" rel="noopener ugc nofollow" target="_blank">()</a></code>，比如<code class="fe mw mx my mz b">(int)price</code>，这是一个显式转换的例子。</p><p id="4271" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了正确理解，我们说我们想要获取<code class="fe mw mx my mz b">price</code>变量，并将其转换(转换)为类型<code class="fe mw mx my mz b">int</code>(从右向左读取)。一旦我们执行了代码，编译器就会检测到它并执行类型转换。</p><p id="c87b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最终结果是我们丢失了小数，但是由于我们正在进行显式转换，编译器理解我们被告知了结果，并且没有显示任何隐式转换错误。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="85cb" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">3.<code class="fe mw mx my mz b">is</code>操作员</h1><p id="259e" class="pw-post-body-paragraph lr ls it lt b lu ob ju lw lx oc jx lz ma op mc md me oq mg mh mi or mk ml mm im bi translated"><code class="fe mw mx my mz b">is</code>操作符用于在进行安全的类型转换之前进行类型检查，以减少类型错误。</p><p id="c1bf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时我们需要确保两个对象、变量或类之间的类型是相同的，以避免编译时出错。如果两个类型相等，则返回<code class="fe mw mx my mz b">true</code>，如果不相等，则返回<code class="fe mw mx my mz b">false</code>。</p><p id="07f2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">例如，假设我们有两个类，一个基类(<code class="fe mw mx my mz b">User</code>)和一个派生类(<code class="fe mw mx my mz b">Student</code>)，我们想使用<code class="fe mw mx my mz b">is</code>操作符执行类型转换:</p><pre class="kj kk kl km gt ot mz ou ov aw ow bi"><span id="89f2" class="ox ni it mz b gy oy oz l pa pb">public class User<br/>{<br/>    public string Id = "1234567";<br/>}<br/><br/>public class Student : User { }</span></pre><p id="4e20" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们想从student类访问user类中的一个字段，比如检索<code class="fe mw mx my mz b">id</code>，为此，我们首先需要检查类型是否相等(<code class="fe mw mx my mz b">true</code>，然后执行类型转换。</p><pre class="kj kk kl km gt ot mz ou ov aw ow bi"><span id="6407" class="ox ni it mz b gy oy oz l pa pb">var student = new Student();<br/><br/>if (student is User) // true<br/>{<br/>    var stud = (User) student; <br/>    Console.WriteLine(stud.Id); // output: 1234567<br/>}</span></pre><p id="a3a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如上所示，第一条语句<code class="fe mw mx my mz b">student is User</code>返回<code class="fe mw mx my mz b">true</code>，因为学生类继承了用户类<code class="fe mw mx my mz b">public class Student : User {}</code>。</p><p id="f931" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们尝试反过来，检查基类是否是派生类的类型，它返回<code class="fe mw mx my mz b">false</code>。这是一个正常的初学者错误，经验法则是我们只能将派生类与其继承的类进行比较，换句话说，就是基类。</p><p id="3a30" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mw mx my mz b">is</code>操作符很棒并且易于阅读(声明性的),但是如果我们想用一行代码完成上面显示的所有事情呢？先说一下<code class="fe mw mx my mz b">as</code>运算符。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="2fe7" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">4.作为操作员</h1><p id="af32" class="pw-post-body-paragraph lr ls it lt b lu ob ju lw lx oc jx lz ma op mc md me oq mg mh mi or mk ml mm im bi translated">除了在一个地方为我们执行类型转换之外，<code class="fe mw mx my mz b">as</code>操作符几乎与<code class="fe mw mx my mz b">is</code>操作符相同。</p><p id="d90a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果转换失败，<code class="fe mw mx my mz b">as</code>操作符将总是返回<code class="fe mw mx my mz b">null</code>，这意味着<code class="fe mw mx my mz b">as</code>操作符从不抛出异常，这在某些情况下可能是好事也可能是坏事，这取决于项目需求。</p><p id="07f5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们使用前面显示的使用<code class="fe mw mx my mz b">as</code>操作符的同一个例子:</p><pre class="kj kk kl km gt ot mz ou ov aw ow bi"><span id="80a3" class="ox ni it mz b gy oy oz l pa pb">var stud = new Student() as User;<br/>Console.WriteLine(stud.Id); // output: 1234567</span></pre><p id="fd2d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如您所见，我们在一行中执行了整个类型转换，这在可读性方面非常好，尤其是对于像我这样懒惰的开发人员。</p><p id="6534" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然而，我们仍然需要确保如果<code class="fe mw mx my mz b">stud</code>实例是<code class="fe mw mx my mz b">null</code>，我们不会访问任何字段。这意味着我们需要一个额外的条件语句来保证这种安全性。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="3520" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">摘要</h1><p id="2b26" class="pw-post-body-paragraph lr ls it lt b lu ob ju lw lx oc jx lz ma op mc md me oq mg mh mi or mk ml mm im bi translated">好了，现在我们已经学习了C#中多种类型转换的方法，以及哪一种用于正确的工作。以下是对每一个问题的快速回顾:</p><ul class=""><li id="d894" class="nz oa it lt b lu lv lx ly ma pd me pe mi pf mm pg oh oi oj bi translated">隐式转换是编译器自动为我们执行转换，只要我们不丢失任何数据。</li><li id="41b0" class="nz oa it lt b lu ok lx ol ma om me on mi oo mm pg oh oi oj bi translated">显式强制转换是开发人员手动确定要转换成什么类型。</li><li id="e8ca" class="nz oa it lt b lu ok lx ol ma om me on mi oo mm pg oh oi oj bi translated">在进行类型转换之前，我们希望在<code class="fe mw mx my mz b">is</code>操作符中检查两个值之间的类型。它返回<code class="fe mw mx my mz b">true</code>或<code class="fe mw mx my mz b">false</code>。</li><li id="5ec7" class="nz oa it lt b lu ok lx ol ma om me on mi oo mm pg oh oi oj bi translated">在进行类型转换之前，我们希望在<code class="fe mw mx my mz b">as</code>操作符中检查两个值之间的类型。它返回结果(转换后的值)或<code class="fe mw mx my mz b">false</code>。</li></ul></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><blockquote class="ph"><p id="ceac" class="pi pj it bd pk pl pm pn po pp pq mm dk translated">如果你喜欢这篇文章，并想要更多这样的，请鼓掌❤，并与可能需要它的朋友分享，这是好的因果报应。</p><p id="6d8b" class="pi pj it bd pk pl pm pn po pp pq mm dk translated">你可以在我每周发表文章的媒体上找到我。或者你可以在推特上关注我。</p></blockquote></div></div>    
</body>
</html>