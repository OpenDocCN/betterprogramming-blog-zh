# 抛开 Git Checkout 不谈。改变一下，考虑 Git 开关

> 原文：<https://betterprogramming.pub/leave-aside-git-checkout-consider-git-switch-for-a-change-7849df8714b0>

## 在不签出的情况下在分支之间切换

![](img/1f2054e3c80fcd11cf9e40b37c1b9132.png)

罗斯·芬登在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

不用看得更远，你能直接说出`git checkout`命令是干什么的吗？我问过我的团队和我自己。包括我在内，没有人能给出一个完整的答案。

首先，想到的是在现有分支之间切换。运行命令`git checkout main`将从电流切换到分支*主*。这是一个正确的答案，但还不完整。

该命令可以做的另一件事是切换到历史日志中的某个提交。运行命令`git checkout 21f25fe0`将使用 SHA 散列`21f25fe0`带来 commit 中所做更改的状态。

尽管如此，还是缺少了一些东西。Git checkout 命令可以做更多的事情。可以重置文件中未暂存的更改。运行`git checkout README.md`将删除任何没有添加到索引中的更改。

现在，知道了所有这些，感觉这是正确的工程解决方案吗？相反。这给人一种我们正在处理的巨大遗产的印象。这个命令根据参数做三件事。我们可以用什么来代替？

# 在分支之间切换

当我们需要在分支之间导航时，我们习惯了命令`git checkout`。Git 有一个专用的命令。通过运行`git switch main`,我们能够在分支之间导航。这看起来很合理，不是吗？

checkout 命令也可以接受参数`-b`。当我们想要创建一个新的分支并立即切换到它时，我们使用它。命令`git checkout -b new_branch`将创建一个新的分支，然后切换到它。这是一个方便的操作，一次做两个动作。好消息是命令*开关*也有这个选项。参数是`-c`，命令`git switch -c new_branch`将完全一样。

# 跳转到提交

当你需要回到过去进行某个提交时，我们也使用 checkout 命令。我们指定一个我们想要检查的修订，文件将接收到提交的状态。如果我们想知道什么时候东西坏了，这是运行 bug 调查的一个方便的选项。

此类功能已被另一个命令覆盖。当我们运行`git reset 21f25fe0`时，文件将从版本`21f25fe0`接收状态。这些命令将在指定提交时恢复文件的状态。并且在该提交之后所做的改变将被表示在工作目录中。

reset 命令与 checkout 命令的作用相同。但是，最后的结果看起来不一样。运行 reset 命令后，我们保持在同一分支中，同时运行 checkout 命令后，我们结束于*分离*状态。可以检查代码并进行修改，但是没有专门的分支可以继续工作。说实话，我没发现超脱状态有什么实际用途。当 git 的整个概念都是有状态的时，为什么还需要这个呢？

# 重置更改

最后，checkout 命令能够在文件级恢复工作目录中的更改。这是一个有趣的时刻。它只恢复工作目录中的文件。将文件添加到索引后，它不会对它们做任何事情。你为什么需要这样的行为？有什么选择呢？

由于我们需要重置更改，显而易见的答案是使用 reset 命令。如果我们运行命令`git reset`,所有暂存的变更都将从索引中删除。如果要清理工作目录，需要添加一个参数`--hard`。命令`git reset --hard`将从工作目录和索引中删除所有更改。

但是硬复位有一个问题。不可能在单个文件或特定目录下运行它。它只在当前目录下执行。为什么这样做是另一个好问题。好消息是有一个解决方案。

命令`git restore`能够在文件级重置已分级和未分级的更改。例如，命令`git restore README.md`删除对工作目录中文件`README.md`的所有修改。添加参数`--staged`将删除从舞台上删除的文件。

restore 命令已经处于试验状态有一段时间了。然而，这意味着它在未来可能会改变。但最有可能的是，随着需求的增加，它会趋于稳定。

# 结束语

checkout 命令是一种传统。软件工程师出于习惯一直使用它。但是当他们必须向 Git 新手解释时，就会产生很多困惑。显然，checkout 命令有很多替代方法。那为什么不开始使用它们呢？