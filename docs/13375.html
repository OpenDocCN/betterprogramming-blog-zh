<html>
<head>
<title>Async/Await Tips To Be Aware of at All Times</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">始终要注意的异步/等待技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-await-tips-to-be-aware-of-at-all-times-fb5bd15b1baf?source=collection_archive---------7-----------------------#2022-08-22">https://betterprogramming.pub/async-await-tips-to-be-aware-of-at-all-times-fb5bd15b1baf?source=collection_archive---------7-----------------------#2022-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2497" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">请确保您也在等待这些有用的提示</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ab5a85ab87ff2342d297ca57f1bf2162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qf-XWVMC9dQ-0DNJRol78Q.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">MockupEditor.com<a class="ae ku" href="https://www.pexels.com/photo/silver-imac-near-white-ceramic-kettle-205316/" rel="noopener ugc nofollow" target="_blank">摄影</a></p></figure><p id="ab31" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">JavaScript中的异步编程长期以来一直是美国开发人员面临的一个挑战。问题是很难编写异步代码。</p><p id="54b0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>出现之前，回调模式是编写异步代码最有效的方式。然而，这种模式仍然受到不可维护代码的困扰，比如<a class="ae ku" href="https://en.wiktionary.org/wiki/callback_hell#:~:text=callback%20hell%20(uncountable),understand%20and%20maintain%20the%20code." rel="noopener ugc nofollow" target="_blank">回调hell </a>，尤其是在严重依赖异步操作的代码中。</p><p id="4e43" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最终，承诺被引入来解决开发人员在使用回调编写异步代码时经常遇到的问题。然而，即使有了承诺，开发者仍然面临困惑。</p><p id="34c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">承诺需要实现返回新的或现有承诺的回调，而新的或现有的承诺必须实现返回下一个值的另一个回调(可以是另一个承诺，以此类推)。这最终会再次带来以前的问题，比如回调地狱。</p><p id="a0b0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们学习的表达代码的方式(以及一般的写作)与JavaScript代码在运行时执行的方式略有不同。JavaScript甚至其他编程语言在设计上没有任何问题，也不是抽象的问题。从上到下、从左到右阅读文本是人的天性。</p><p id="3fc8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">JavaScript需要一种合适的方式让开发人员编写这种性质的异步代码，并最终引入了一种使用ECMAScript标准的<code class="fe lr ls lt lu b">async</code>函数和作为表达式的<code class="fe lr ls lt lu b">await</code>关键字的解决方案。简而言之，这通常被称为async/await。</p><p id="0499" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本帖中，我们将回顾一些重要的技巧，每个JavaScript开发人员都必须知道这些技巧，以防止应用程序中出现棘手的错误。</p><h1 id="7f7e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">你要返回的承诺会在同一个函数块中被捕获吗？</h1><p id="479a" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">在处理async/await函数中的错误时，一个棘手的问题是返回拒绝当前函数调用方的承诺。这样做时，我们会将我们的拒绝处理转发给呼叫者。</p><p id="d568" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看下面的代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d4c2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们的<code class="fe lr ls lt lu b">start</code>函数中，我们返回函数<code class="fe lr ls lt lu b">getRandomItem</code>的结果，并期望我们的拒绝在它的本地<code class="fe lr ls lt lu b">try/catch</code>块中被捕获，因为我们希望我们的JavaScript运行时能够通过向用户显示一个警告窗口来继续运行。然而，当我们运行代码时，它实际上根本不显示弹出窗口，相反，在执行我们放入<code class="fe lr ls lt lu b">getRandomItem</code>函数的<code class="fe lr ls lt lu b">Throw</code>后，JavaScript运行时崩溃:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/e7ee35f2a3dd31b7ebdea02f9e7f4bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E1g6L6wDPPo_Gq2d.png"/></div></div></figure><p id="42cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是因为我们的承诺由<code class="fe lr ls lt lu b">getRandomItem</code>返回，而不是在同一个功能块中等待:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/10381202508090b9635da6c4d1d359e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NgvLxeGt3VIefjB4.png"/></div></div></figure><p id="febe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要解决这个问题，我们需要做的就是添加一个简单的<code class="fe lr ls lt lu b">await</code>关键字，这样它就会在同一个功能块中被等待:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="bf73" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">理解这一点很重要，它只发生在返回一个全新的承诺时，所以返回像数字这样的常规值不会受到影响:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="23e5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">避免在forEach内部编写异步代码</h1><p id="34e4" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">新的JavaScript开发人员在编写异步代码时更容易受到这种“陷阱”的影响。</p><p id="63a9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="94be" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">将此记录到控制台会给我们一个空数组<code class="fe lr ls lt lu b">[]</code>，这可能不是我们所期望的。<code class="fe lr ls lt lu b">forEach</code>函数忽略每次循环返回的承诺！</p><p id="79bf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">换句话说，这在技术上等同于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cbf4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">像<code class="fe lr ls lt lu b">map</code>这样的迭代函数可以在收集和解析承诺时工作，因为它们在每个循环中都返回调用<code class="fe lr ls lt lu b">callback</code>的结果。在JavaScript中，任何返回promise的函数都变成了thenable(一个带有<code class="fe lr ls lt lu b">.then</code>方法的对象)。</p><p id="2577" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">承诺也是变量，因为<code class="fe lr ls lt lu b">map</code>返回<code class="fe lr ls lt lu b">callback</code>的每个结果，这意味着如果需要，我们可以使用回调函数的异步版本，而不是同步版本。</p><p id="9c19" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这在技术上与以下内容相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="953c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在前面的例子中，我们可以在<code class="fe lr ls lt lu b">map</code>返回的最终结果上使用<code class="fe lr ls lt lu b">Promise.all</code>(如果我们从回调处理程序中返回了这些结果，那么它们最终可以成为一个变量或<code class="fe lr ls lt lu b">promises</code>的集合，如果您记得的话):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b55b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结果如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="c55d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">承诺解决链永无止境的循环</h1><p id="1a36" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">如果承诺陷入永无止境的递归循环，它们最终会让我们的应用崩溃。不，我不是在谈论这些类型的递归:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9326" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我说的是陷入永无止境的递归承诺链中的承诺，这种承诺链实际上永远不会通过调用自身来解决。</p><p id="1539" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，在下面的代码片段中，我们有一个异步函数，它返回一个可解析并返回原始承诺调用(<code class="fe lr ls lt lu b">start</code>)的名称。这将返回另一个thenable ( <code class="fe lr ls lt lu b">delay</code>)，后者将返回原始promise调用的另一个调用，依此类推:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f162" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最大的问题是对<code class="fe lr ls lt lu b">start</code>函数的原始调用实际上从来没有办法找到对原始承诺调用的解析。这会导致我们的程序出现内存泄漏，最终导致程序崩溃。</p><p id="e8b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么，如何才能避免这种情况呢？</p><p id="b579" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以利用类似于我们之前讨论的<code class="fe lr ls lt lu b">forEach</code>的概念，而不是返回承诺，我们可以让函数忽略承诺结果(就像<code class="fe lr ls lt lu b">forEach</code>所做的)。因此，每个调用在运行完功能块后都会到达它们的末尾:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7c68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">虽然这解决了内存泄漏问题，但它完全丧失了从新调用中捕获内部承诺拒绝的能力。</p><p id="926e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以用一个简单的包装器让<code class="fe lr ls lt lu b">start</code>捕捉它的任何深层拒绝，这解决了我们的问题。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="5028" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="561c" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>