<html>
<head>
<title>SQLite on iOS: The MVVM Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS上的SQLite:MVVM之路</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sqlite-on-ios-the-mvvm-way-8a4827d62519?source=collection_archive---------3-----------------------#2022-03-02">https://betterprogramming.pub/sqlite-on-ios-the-mvvm-way-8a4827d62519?source=collection_archive---------3-----------------------#2022-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a73f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI遇上SQLite</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c15bd85f7e1e9bad555d204c07c1e4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BkIwCuoEb9ZqRwFz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="68a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我在研究NetNewsWire ,看看我是否能在我的项目中找到一些有趣的东西。</p><p id="b1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现的一件很酷的事情是，这个项目没有使用CoreData，而是使用了SQLite。该项目的作者在Sundell podcast第95集上解释了为什么采用SQLite极大地提高了性能的一些优点。</p><p id="cd86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您可能想从数据存储中获得更多，您想要更多的控制，或者您只想使用表格和SQL lite语句。</p><p id="ae8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想尝试一下，因为我与CoreData和CloudKit集成的关系不太好，而且我不是GUI的粉丝。还因为我在后端服务上做了很多工作，所以我更喜欢在数据层工作，自己优化索引和查询，并把它们写下来。</p><p id="148e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看一看一个要点中的最终代码，你可以在这里找到<a class="ae ky" href="https://gist.github.com/mattrighetti/4db0c5266fe8717509ab9048895461ba" rel="noopener ugc nofollow" target="_blank">并跟随。</a></p><h1 id="9e31" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">FMDB简介</h1><p id="1d8d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/ccgus/fmdb[FMDB" rel="noopener ugc nofollow" target="_blank"> FMDB </a>是一个围绕SQLite的Objective-C包装器，它是开源的，非常容易设置，而且它恰好是唯一一个允许您这样做的好库(在这里我可能是错的，如果您知道其他好的库，请告诉我，我很乐意尝试一下！)</p><h1 id="36f4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置</h1><p id="db3c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们创建一个新的Xcode项目，我将把我的称为<code class="fe ms mt mu mv b">SQLiteIntro</code>。</p><p id="a1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个应用程序不会很复杂，因为我只是想对这个主题做一个简单的介绍，让你对在Swift项目中使用SQL有个大概的了解。</p><h1 id="c0e9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">包装材料</h1><p id="d3bd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在专用的类/结构中分离逻辑是一个很好的实践。在这种情况下，因为我们使用的是SQL数据库，所以我想创建一个类来抽象一点数据层逻辑，这样代码会更加简洁。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="316f" class="na lw it mv b gy nb nc l nd ne">final class DataWrapper: ObservableObject {<br/>    private let db: FMDatabase<br/>    <br/>    init(fileName: String = "test") {<br/>        // 1 - Get filePath of the SQLite file<br/>        let fileURL = try! FileManager.default<br/>            .url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: true)<br/>            .appendingPathComponent("\(fileName).sqlite")<br/>        <br/>        // 2 - Create FMDatabase from filePath<br/>        let db = FMDatabase(url: fileURL)<br/>        <br/>        // 3 - Open connection to database<br/>        guard db.open() else {<br/>            fatalError("Unable to open database")<br/>        }<br/>        <br/>        // 4 - Initial table creation<br/>        do {<br/>            try db.executeUpdate("create table if not exists users(username varchar(255) primary key, age integer)", values: nil)<br/>        } catch {<br/>            fatalError("cannot execute query")<br/>        }<br/>        <br/>        self.db = db<br/>    }<br/>}</span></pre><p id="0076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你需要开始的，简单吧？</p><p id="bbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码很简单:当最初创建<code class="fe ms mt mu mv b">DataWrapper</code>类时，它将查找数据库文件，如果文件不存在，FMDB将使用该路径为您创建一个数据库。最后，它打开一个到数据库的连接并创建<code class="fe ms mt mu mv b">user</code>表。</p><h1 id="c4e9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型</h1><p id="e9e4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了处理数据库记录，我想创建一个<code class="fe ms mt mu mv b">User</code>结构，在我的例子中，我将包含一些其他与JSON相关的东西，因为我稍后将使用它通过一些web APIs创建具有随机名称的用户。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8ed6" class="na lw it mv b gy nb nc l nd ne">struct User: Hashable, Decodable {<br/>    let username: String<br/>    let age: Int<br/>    <br/>    init(username: String, age: Int) {<br/>        self.username = username<br/>        self.age = age<br/>    }<br/>    <br/>    init?(from result: FMResultSet) {<br/>        if let username = result.string(forColumn: "username") {<br/>            self.username = username<br/>            self.age = Int(result.int(forColumn: "age"))<br/>        } else {<br/>            return nil<br/>        }<br/>    }<br/>    <br/>    private enum CodingKeys : String, CodingKey {<br/>        case username = "first_name"<br/>    }<br/>    <br/>    init(from decoder: Decoder) throws {<br/>        let container = try decoder.container(keyedBy: CodingKeys.self)<br/>        username = try container.decode(String.self, forKey: .username)<br/>        age = Int.random(in: 1..&lt;100)<br/>    }<br/>}</span></pre><p id="c9f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">FMResultSet</code>是您从数据库执行查询时总是会得到的结果，即使您期望的是单个记录或空结果，这就是为什么在这种情况下有一个专用的init函数来处理所有设置逻辑是有用的。</p><h1 id="fede" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">联合收割机和MVVM</h1><p id="c271" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因为我正在使用SwiftUI，所以我希望<code class="fe ms mt mu mv b">DataWrapper</code>是反应式的，并通知<br/>数据库中可能发生的变化。回到<code class="fe ms mt mu mv b">DataWrapper</code>的实现，我添加了一个<code class="fe ms mt mu mv b">@Published</code>用户数组，这样我可以在<code class="fe ms mt mu mv b">List</code>中显示他们。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6c18" class="na lw it mv b gy nb nc l nd ne">final class DataWrapper: ObservableObject {<br/>    private let db: FMDatabase<br/>    @Published var users = [User]()<br/>    ...</span><span id="b480" class="na lw it mv b gy nf nc l nd ne">}</span></pre><p id="887e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从数据库中获取用户并在数据库打开后立即发布他们，我们需要创建一个方法来查询所有用户，并在数据库初始化后将他们设置为<code class="fe ms mt mu mv b">DataWrapper</code>的users变量。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a0ec" class="na lw it mv b gy nb nc l nd ne">func getAllUsers() -&gt; [User] {<br/>    var users = [User]()<br/>    do {<br/>        let result = try db.executeQuery("select username, age from users", values: nil)<br/>        while result.next() {<br/>            if let user = User(from: result) {<br/>                users.append(user)<br/>            }<br/>        }<br/>        return users<br/>    } catch {<br/>        return users<br/>    }<br/>}</span></pre><p id="254e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将该调用放在<code class="fe ms mt mu mv b">DataWrapper</code>的<code class="fe ms mt mu mv b">init</code>方法的底部</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="72be" class="na lw it mv b gy nb nc l nd ne">users = getAllUsers()</span></pre><p id="cfcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当你第一次启动<code class="fe ms mt mu mv b">DataWrapper</code>时，它将自动获取所有用户，并且他们将准备好在SwiftUI中使用。</p><p id="09ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将创建一个稍后会用到的<code class="fe ms mt mu mv b">insert</code>函数:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="bb81" class="na lw it mv b gy nb nc l nd ne">func insert(_ user: User) {<br/>    do {<br/>        try db.executeUpdate(<br/>            """<br/>            insert into users (username, age)<br/>            values (?, ?)<br/>            """,<br/>            values: [user.username, user.age]<br/>        )<br/>        users.append(user)<br/>    } catch {<br/>        fatalError("cannot insert user: \(error)")<br/>    }<br/>}</span></pre><h1 id="e25b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">快速浏览视图</h1><p id="738f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我想创建一个<code class="fe ms mt mu mv b">List</code>来显示数据库包含的所有用户，并创建一个简单的函数来查询web API以获得一个随机用户名，并将一个新用户插入到数据库中。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ded1" class="na lw it mv b gy nb nc l nd ne">struct ContentView: View {<br/>    <a class="ae ky" href="http://twitter.com/EnvironmentObject" rel="noopener ugc nofollow" target="_blank">@EnvironmentObject</a> var db: DataWrapper<br/>    <br/>    var body: some View {<br/>        NavigationView {<br/>            List(db.users, id: \.self) { user in<br/>                HStack {<br/>                    Text(user.username)<br/>                    Spacer()<br/>                    Text("\(user.age)")<br/>                }<br/>            }<br/>            <br/>            .navigationTitle("Users")<br/>            .toolbar {<br/>                ToolbarItem(id: "plus", placement: .navigationBarTrailing, showsByDefault: true) {<br/>                    Button(action: {<br/>                        createRandomUser()<br/>                    }, label: {<br/>                        Image(systemName: "plus")<br/>                    })<br/>                }<br/>            }<br/>        }<br/>    }<br/>    <br/>    private func createRandomUser() {<br/>        let url = URL(string: "<a class="ae ky" href="https://random-data-api.com/api/name/random_name" rel="noopener ugc nofollow" target="_blank">https://random-data-api.com/api/name/random_name</a>")!<br/>        let task = URLSession.shared.dataTask(with: url) { data, response, error in<br/>            guard let data = data else {<br/>                fatalError("No data")<br/>            }<br/>            <br/>            DispatchQueue.main.async {<br/>                let user = try! JSONDecoder().decode(User.self, from: data)<br/>                db.insert(user)<br/>            }<br/>        }<br/>        task.resume()<br/>    }<br/>}</span></pre><p id="be47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你现在运行你的应用程序，你会看到一个空列表，但如果你按下加号按钮，你将开始在数据库中插入东西，名字将开始反应性地出现在你的列表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="76dd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="63b9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个非常简单的场景，现在可能显示CoreData版本的性能有了巨大的提升，但这是一种在更熟悉的SQLite数据库中存储数据的不同方式。</p><p id="f2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望对数据有更多的控制，SQLite和SQL的强大功能肯定不会让您失望。SQLite可以提高需要细粒度控制和目标查询优化的应用程序的性能。使用CloudKit同步数据也更容易，因为现在您只需同步SQLite文件，而无需处理所有的CoreData表和不同的版本。</p><p id="3a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在写一篇关于SQLite迁移策略的文章，<br/>所以如果你想了解更多，请继续关注！</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0db2" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">Want to Connect?</strong></span><span id="2cea" class="na lw it mv b gy nf nc l nd ne">This article is also available on my <a class="ae ky" href="http://mattrighetti.com" rel="noopener ugc nofollow" target="_blank">website</a>.</span></pre></div></div>    
</body>
</html>