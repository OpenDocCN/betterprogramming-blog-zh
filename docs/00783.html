<html>
<head>
<title>Creating iOS Apps Without Storyboards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建没有故事板的iOS应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-ios-apps-without-storyboards-42a63c50756f?source=collection_archive---------1-----------------------#2019-07-14">https://betterprogramming.pub/creating-ios-apps-without-storyboards-42a63c50756f?source=collection_archive---------1-----------------------#2019-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba1f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它们真的会成为过去</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8b4f7c5d344ffd822bf35b9b049cc871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K8rWnbOWCze7_QJ1"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哈尔·盖特伍德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4ec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多iOS开发文章和教程使用故事板来创建用户界面。这是有意义的，因为它们是创建和修改你的设计的非常直观的方式，并且有助于加速你的学习过程。但是，除非你发现自己是一个应用程序的唯一开发者，否则这不是团队环境中专业iOS开发的完全现实的观点。当你第一次面对一个只有很少或者没有故事板的应用时，它可能会对系统造成冲击。让我们通过了解在没有故事板的情况下如何设计一个应用程序来为这种可能性做好准备。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b9e0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用编程布局的情况</h1><p id="3dd8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我是一个非常视觉化的人，我个人反对这种方法，所以我可以理解你是否也有这种想法。如果你曾经在团队环境中工作过，你可能会有一些非常困难的尝试来解决故事板的合并冲突。你可能还会被同事阻止，他们需要在你完成特定任务之前修改故事板。如果这些事情还没有发生在你身上，它们会发生的。有一些方法可以缓解这些问题，比如拆分故事板和<a class="ae kv" href="https://docs.elementscompiler.com/Platforms/Cocoa/XIB/" rel="noopener ugc nofollow" target="_blank">xib</a>，但它们并不是万无一失的，一旦你习惯了没有故事板，你就会开始看到好处。到目前为止，最大的好处是比你坚持故事板更好地理解UIKit。而且，正如我们在<a class="ae kv" href="https://developer.apple.com/wwdc19/" rel="noopener ugc nofollow" target="_blank"> WWDC2019 </a>上看到的<a class="ae kv" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>的首次亮相，故事板真的将成为过去。</p><p id="4038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么这么多的团队环境趋向于去除故事板和xib呢？除了合并冲突和阻塞问题，团队远离故事板的主要原因之一是大多数属性值不容易被审查。从故事板XML中挑选代码很容易出错，因此您最好重做这项工作，这消除了拥有代码存储库的一个优势。让我们看一个例子。</p><p id="5f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有一个简单的单视图应用程序，其表单包含两个文本字段和一个按钮。按钮对其中一个文本字段有一个垂直约束，该约束有一个常量<code class="fe mw mx my mz b">20</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/bc6fb8fb633e796794a700b86bbfedf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*DhFcaJAiLLfLSS5O3EkEPQ.png"/></div></figure><p id="875a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计师要求我们将这个数字增加到<code class="fe mw mx my mz b">40</code>。我进行了更改，提交了一份PR，并指定您为审核人。您可以在PR中看到以下变化。</p><p id="df4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="ab90" class="nf ma iq mz b gy ng nh l ni nj">&lt;rect key="frame" x="20" y="383" width="374" height="30"/&gt;<br/>&lt;rect key="frame" x="20" y="333" width="374" height="30"/&gt;<br/>&lt;constraint firstItem="pYg-JC-an0" firstAttribute="top" secondItem="Kfc-mn-gVn" secondAttribute="bottom" constant="20" id="r92-HL-ecY"/&gt;</span></pre><p id="9423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="431c" class="nf ma iq mz b gy ng nh l ni nj">&lt;rect key="frame" x="20" y="363" width="374" height="30"/&gt;<br/>&lt;rect key="frame" x="20" y="313" width="374" height="30"/&gt;<br/>&lt;constraint firstItem="pYg-JC-an0" firstAttribute="top" secondItem="Kfc-mn-gVn" secondAttribute="bottom" constant="40" id="r92-HL-ecY"/&gt;</span></pre><p id="c1e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里改变了什么？你知道它应该是按钮控件和文本字段之间的约束，但是你确定<code class="fe mw mx my mz b">pYg-JC-an0</code>和<code class="fe mw mx my mz b">Kfc-mn-gVn</code>是正确的控件吗？您可以浏览XML来找到这两个值，但是如果这是一个包含许多控件的复杂视图，并且我修改了所有控件的间距，那该怎么办呢？你真的有时间把他们都找出来吗？如果代码就在您面前，在视图控制器中，包含所有其他视图逻辑，不是更容易吗？</p><p id="5634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，在这个例子中，编程布局中的这种修改会是什么样子呢？</p><p id="acf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始约束:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="9f80" class="nf ma iq mz b gy ng nh l ni nj">loginButton.topAnchor.constraint(equalTo: passwordTextField.bottomAnchor, constraint: 20)</span></pre><p id="5158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">修改的约束:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="1756" class="nf ma iq mz b gy ng nh l ni nj">loginButton.topAnchor.constraint(equalTo: passwordTextField.bottomAnchor, constraint: 40)</span></pre><p id="2fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是啊。差别很大。</p><p id="b3d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不仅会使PRs更容易审查，而且追踪与布局相关的bug也变得更加容易。所有与布局相关的设置都将在代码中呈现在你面前，而不是隐藏在Xcode检查器的几十个地方。所以，让我们看看没有故事板的情况下需要做些什么。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a84a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">入门指南</h1><p id="739a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了开始学习编程布局，让我们在Xcode中创建新项目。</p><p id="726b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建单视图应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/7fd914711205c1d0d35d23cb5cdbaf1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyNHJn7Qh9vHhBFseak6ew.png"/></div></div></figure><p id="2310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将其命名为<code class="fe mw mx my mz b">GoodbyeStoryboard</code>，并将其保存在适当的地方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/27631725556b942cc3cf6b441a1a0e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyzovSoBjBMn_BKH8Wsvuw.png"/></div></div></figure><h2 id="288e" class="nf ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">删除故事板</h2><p id="182a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在Xcode中创建并打开项目后，选择<code class="fe mw mx my mz b">Main.storyboard</code>文件并删除它。从确认对话框中选择“移到废纸篓”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/5fa4f883bd0acf4adfb29953ef7b0fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqTGnQXSz8JEpHB--kU9nQ.png"/></div></div></figure><p id="45c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拜拜故事板！</p><p id="7ea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在项目导航器中，选择项目。在Deployment Info部分下的<code class="fe mw mx my mz b">GoodbyeStoryboard</code>目标中，从主界面字段中删除单词<code class="fe mw mx my mz b">Main</code>并按⌘S保存更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/935d8b24242c900112b82e3108948336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHCVF3Y7ryMCreD1cIa_FA.png"/></div></div></figure><p id="0f47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您现在构建并运行，项目将成功构建，应用程序将运行，但您只会看到一个黑屏。这是因为您的应用程序不再有窗口。而且，即使这样，Xcode为您创建的<code class="fe mw mx my mz b">ViewController.swift</code>也不再被设定为窗口的根视图控制器。这些都是故事板自动处理的事情，而你却没有意识到。虽然这听起来像是积极的，但这也意味着使用UIKit的一些方面您还没有意识到。</p><p id="38dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需要少量代码就可以补救这种情况。打开<code class="fe mw mx my mz b">AppDelegate.swift</code>。您将看到一个<code class="fe mw mx my mz b">UIWindow?</code>类型的<code class="fe mw mx my mz b">window</code>属性，除了一些空函数，唯一真正的代码在方法<code class="fe mw mx my mz b">application(_:didFinishLaunchingWithOptions:)</code>中，并且只包含一个<code class="fe mw mx my mz b">return true</code>语句。用此代码修改<code class="fe mw mx my mz b">application(_:didFinishLaunchingWithOptions:)</code>:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="9bd3" class="nf ma iq mz b gy ng nh l ni nj">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {<br/>   //Create a window that is the same size as the screen<br/>   window = UIWindow(frame: UIScreen.main.bounds)<br/>   // Create a view controller<br/>   let viewController = ViewController()<br/>   // Assign the view controller as `window`'s root view controller<br/>   window?.rootViewController = viewController<br/>   // Show the window<br/>   window?.makeKeyAndVisible()<br/><br/>   return true<br/> }</span></pre><p id="b791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">application(_:didFinishLaunchingWithOptions:)</code>方法是在应用程序即将运行时执行的，所以这是您想要进行最后调整的地方。这是实例化我们的应用程序窗口并使<code class="fe mw mx my mz b">ViewController</code>成为该窗口的根视图控制器的最佳位置。让我们一行一行地检查上面的代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="f5b9" class="nf ma iq mz b gy ng nh l ni nj">window = UIWindow(frame: UIScreen.main.bounds)</span></pre><p id="b3f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是创建窗口。通过使用<code class="fe mw mx my mz b">UIWindow(frame: UIScreen.main.bounds)</code>，我们创建了一个新窗口，并将其大小设置为设备的屏幕大小。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="80b1" class="nf ma iq mz b gy ng nh l ni nj">let viewController = ViewController()<br/>window?.rootViewController = viewController</span></pre><p id="b1a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们初始化一个新的视图控制器。然后我们将它分配给窗口的<code class="fe mw mx my mz b">rootViewController</code>属性。根视图控制器只是一个窗口内容的容器。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="c528" class="nf ma iq mz b gy ng nh l ni nj">window?.makeKeyAndVisible()</span></pre><p id="7c57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使窗口可见。<code class="fe mw mx my mz b">makeKeyAndVisible()</code>方法只是一个方便的方法，它强制窗口成为关键窗口(换句话说，它把它放在所有其他窗口的前面——在这一点上，没有其他窗口),并使它可见。</p><p id="5017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并运行，你应该会看到…一个黑色的视图占据了整个屏幕。这不是很令人印象深刻，我们写代码之前有一个黑屏，所以这甚至工作吗？</p><p id="cc13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mw mx my mz b">ViewController.swift</code>并将以下内容添加到<code class="fe mw mx my mz b">viewDidLoad()</code>方法的<code class="fe mw mx my mz b">super.viewDidLoad()</code>行之后:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="f800" class="nf ma iq mz b gy ng nh l ni nj">view.backgroundColor = .white</span></pre><p id="c0eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并再次运行，您现在应该会看到一个完整的白屏，证明我们现在有一个窗口，并且<code class="fe mw mx my mz b">ViewController</code>实际上是可见的。祝贺您，您现在已经构建了一个没有故事板的应用程序！而且只用了四行代码。</p><p id="1e2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总结一下我们到目前为止所做的工作，我们移除了故事板，修改了项目，使它不再寻找故事板，创建了我们的主应用程序窗口，并使<code class="fe mw mx my mz b">ViewController</code>成为窗口的根视图控制器。很简单的东西。但是，您将拖放到故事板中并连接到<code class="fe mw mx my mz b">IBOutlets</code>和<code class="fe mw mx my mz b">IBActions</code>的所有视图和控件呢？我们接下来会看看这些。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="18b3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">添加UI元素</h1><p id="7ea9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们有了一个可以再次使用的视图，让我们深入研究如何添加UI元素。在故事板中，我们只需将一个文本字段或按钮拖到视图上，并创建出口和动作，这样我们就可以用代码与它进行交互，但是没有故事板，这是如何实现的呢？让我们从单个控件开始，慢慢来。</p><p id="0e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果尚未打开，打开<code class="fe mw mx my mz b">ViewController.swift</code>。</p><p id="98a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">viewDidLoad()</code>函数上方添加以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="ae65" class="nf ma iq mz b gy ng nh l ni nj">var loginButton: UIButton!</span></pre><p id="52ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，通过在<code class="fe mw mx my mz b">viewDidLoad()</code>中的<code class="fe mw mx my mz b">view.backgroundColor = .white</code>行之后添加以下代码，实例化并配置按钮控件:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="788a" class="nf ma iq mz b gy ng nh l ni nj">loginButton = UIButton(type: .system)<br/>loginButton.setTitle("Login", for: .normal)<br/>loginButton.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(loginButton)</span></pre><p id="e84d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一行一行地看看这个:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="7034" class="nf ma iq mz b gy ng nh l ni nj">loginButton = UIButton(type: .system)</span></pre><p id="5e8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这相当于在“身份”检查器中设置“类”值，在“属性”检查器中设置“类型”值。</p><div class="kg kh ki kj gt ab cb"><figure class="ny kk nz oa ob oc od paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/64d3ef880ea91c7e53d4c59e95d27a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*IpmNuPVuhrPwjPH-BpNrHQ.png"/></div></figure><figure class="ny kk nz oa ob oc od paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/961f30344939f840a298aee2aaedd082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*RSkGfAVCB2AS_-YE5tyOhQ.png"/></div></figure></div><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="3759" class="nf ma iq mz b gy ng nh l ni nj">loginButton.setTitle("Login", for: .normal)</span></pre><p id="6320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将按钮的标题设置为正常状态。这相当于在属性检查器中设定这些值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ab468aafe0932f3b453cf6e4efdea8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*_rjNFzVMSAsUk8BwcHSw1w.png"/></div></figure><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="95d0" class="nf ma iq mz b gy ng nh l ni nj">loginButton.translatesAutoresizingMaskIntoConstraints = false</span></pre><p id="2a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在事情变得有趣了；这可能是你从未见过的。这里我们声明我们将使用AutoLayout。这看起来不像是我们正在做的事情，而且显式地设置这一点看起来很奇怪，但是这实际上是在你每次向故事板添加视图或控件时为你做的。所以不管你知不知道，你一直都在这么做。下面是按钮的脚本XML的一部分:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="8691" class="nf ma iq mz b gy ng nh l ni nj">&lt;button opaque="NO" contentMode="scaleToFill" fixedFrame="YES" <br/>   contentHorizontalAlignment="center"     <br/>   contentVerticalAlignment="center" <br/>   buttonType="roundedRect"<br/>   lineBreakMode="middleTruncation" <br/>   translatesAutoresizingMaskIntoConstraints="NO" <br/>   id="DLu-Zl-IKU"&gt;</span></pre><p id="53b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后你会看到<code class="fe mw mx my mz b">translatesAutoresizingMaskIntoConstraints="NO"</code>一直都在那里。所以，是的，为你添加的每一个视图或控件都这样做是很乏味的，但是你做得越多，它就会变得越自动化。</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="4032" class="nf ma iq mz b gy ng nh l ni nj">view.addSubview(loginButton)</span></pre><p id="b89f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你把一个控件拖到故事板上时，很明显它已经变成了它的父控件的子视图，即使你从来没有想过它。与代码中的大多数事情一样，我们需要明确地说明这一点。</p><p id="dc5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来处理按钮的定位。现在，我们就把它放在中间。在<code class="fe mw mx my mz b">viewDidLoad()</code>功能后增加以下功能:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="53c6" class="nf ma iq mz b gy ng nh l ni nj">func constraintsInit() {<br/>    NSLayoutConstraint.activate([<br/>      loginButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),<br/>      loginButton.centerYAnchor.constraint(equalTo: view.centerYAnchor)<br/>    ])<br/>}</span></pre><p id="679d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里所做的是将<code class="fe mw mx my mz b">loginButton</code>的中心X和中心Y锚点分别与<code class="fe mw mx my mz b">view</code>的中心X和中心Y锚点对齐。如果你对主播不熟悉，我强烈推荐找一个主播教程。它们非常易于阅读和理解，但是深入解释它们超出了本文的范围。我们将在本文中更多地使用它们，所以如果它们对您来说是新的，现在就跟随它们吧。</p><p id="a73e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe mw mx my mz b">viewDidLoad()</code>中，在<code class="fe mw mx my mz b">view.addSubview(loginButton)</code>后添加这一行:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="accb" class="nf ma iq mz b gy ng nh l ni nj">constraintsInit()</span></pre><p id="0d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并运行，您应该看到您的登录按钮就在视图的中央。</p><p id="62e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们加快进度，添加简单登录表单的剩余部分。在<code class="fe mw mx my mz b">var loginButton: UIButton!</code>行的正下方添加以下代码:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="b00e" class="nf ma iq mz b gy ng nh l ni nj">var nameTextField: UITextField!<br/>var passwordTextField: UITextField!</span></pre><p id="ceef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在<code class="fe mw mx my mz b">view.addSubview(loginButton)</code>线之后<code class="fe mw mx my mz b">constraintsInit()</code>线之前的<code class="fe mw mx my mz b">viewDidLoad()</code>中添加:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="3687" class="nf ma iq mz b gy ng nh l ni nj">nameTextField = UITextField(frame: .zero)<br/>nameTextField.placeholder = "Login Name"<br/>nameTextField.borderStyle = .roundedRect<br/>nameTextField.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(nameTextField)<br/><br/>passwordTextField = UITextField(frame: .zero)<br/>passwordTextField.placeholder = "Password"<br/>passwordTextField.isSecureTextEntry = true<br/>passwordTextField.borderStyle = .roundedRect<br/>passwordTextField.translatesAutoresizingMaskIntoConstraints = false<br/>view.addSubview(passwordTextField)</span></pre><p id="054f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，这里唯一应该是新的是在我们将框架设置为<code class="fe mw mx my mz b">.zero</code>的实例化行中。如果这对您来说是新的，它确实如其名:它将控件的大小设置为零。如果保持这种方式，在运行应用程序时，您将看不到该控件，因为它的高度和宽度都为零。这将通过添加我们接下来要做的约束来解决。</p><p id="3dcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">constraintsInit()</code>中，在<code class="fe mw mx my mz b">loginButton.centerYAnchor.constraint(equalTo: view.centerYAnchor)</code>行的末尾添加一个逗号，然后添加:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="36d3" class="nf ma iq mz b gy ng nh l ni nj">passwordTextField.bottomAnchor.constraint(equalTo: loginButton.topAnchor, constant: -20),</span><span id="7247" class="nf ma iq mz b gy of nh l ni nj">passwordTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),</span><span id="40d1" class="nf ma iq mz b gy of nh l ni nj">passwordTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20),<br/><br/>nameTextField.bottomAnchor.constraint(equalTo: passwordTextField.topAnchor, constant: -20),</span><span id="ee98" class="nf ma iq mz b gy of nh l ni nj">nameTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),</span><span id="9ab9" class="nf ma iq mz b gy of nh l ni nj">nameTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20)</span></pre><p id="52a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了指出我们使用<code class="fe mw mx my mz b">readableContentGuide</code>作为文本字段的水平布局之外，我不打算在此详述。在使用约束条件时，可以使用一些指南，可读内容指南是一种在视图中定义可读区域的指南，该区域不会被系统控件(如滚动条)遮挡。它还通过考虑设备宽度和动态文本大小来调整可读宽度。这是一个需要注意的重要指南，尤其是在调整用户界面的可访问性时。</p><p id="448c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并运行，您应该会看到一个非常基本的登录表单，它是以完全编程的方式创建的，没有故事板！</p><p id="c81a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有最后一件事要处理:行动。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ea26" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">添加操作</h1><p id="7836" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当使用故事板时，你可能会将登录按钮连接到一个<code class="fe mw mx my mz b">IBAction</code>来处理点击事件。因为我们没有使用界面构建器，所以没有<code class="fe mw mx my mz b">IBAction</code>可以利用。相反，我们将使用一个目标动作。</p><p id="4095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">constraintsInit()</code>功能后添加这个新功能:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="6ad4" class="nf ma iq mz b gy ng nh l ni nj">@objc func handleLoginTouchUpInside() {<br/>    print("Login has been tapped")<br/>    if nameTextField.isFirstResponder {<br/>      nameTextField.resignFirstResponder()<br/>    }<br/>    if passwordTextField.isFirstResponder {<br/>      passwordTextField.resignFirstResponder()<br/>    }<br/>  }</span></pre><p id="2c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为用户可能会关注任一文本字段，所以我们将简单地查询每个字段，并询问它是否是第一个响应者。如果是这样，我们将放弃第一响应者的身份。如果这对你来说是新的，在一个文本字段上重新签名将隐藏键盘。此外，请注意，还有其他方法可以做到这一点，但这是一个足够好的演示方法。</p><p id="88b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，要为按钮上的点击事件添加一个动作，就在<code class="fe mw mx my mz b">viewDidLoad()</code>中的<code class="fe mw mx my mz b">view.addSubview(loginButton)</code>行下面添加以下内容:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="1853" class="nf ma iq mz b gy ng nh l ni nj">loginButton.addTarget(self, <br/>                      action: #selector(handleLoginTouchUpInside), <br/>                      for: .touchUpInside)</span></pre><p id="523f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将为登录按钮添加一个目标，该按钮将在检测到内部触发动作时运行<code class="fe mw mx my mz b">handleLoginTouchUpInside()</code>功能。</p><p id="4044" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建和运行，你应该看到一切工作了！如果您有任何问题，<code class="fe mw mx my mz b">ViewController</code>代码的完整列表在本文的底部。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="05ea" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="1320" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如你所见，移除故事板并不困难。它揭示了视图和视图控制器的一些工作方式，尤其是布局，这些都是通过使用故事板隐藏起来的。这种接触是一件好事，因为您将更加熟悉视图、控制器和约束是如何工作的。现在，有了工具带中的编程布局，所有UI代码都将完全公开，并且更容易审查和调试。</p><h2 id="a60a" class="nf ma iq bd mb nl nm dn mf nn no dp mj lf np nq ml lj nr ns mn ln nt nu mp nv bi translated">完整列表</h2><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="ade5" class="nf ma iq mz b gy ng nh l ni nj">class ViewController: UIViewController {<br/><br/>  var loginButton: UIButton!<br/>  var nameTextField: UITextField!<br/>  var passwordTextField: UITextField!<br/><br/>  override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>    view.backgroundColor = .white<br/><br/>    loginButton = UIButton(type: .system)<br/>    loginButton.setTitle("Login", for: .normal)<br/>    loginButton.translatesAutoresizingMaskIntoConstraints = false<br/>    view.addSubview(loginButton)<br/>    loginButton.addTarget(self, action: #selector(handleLoginTouchUpInside), for: .touchUpInside)<br/><br/>    nameTextField = UITextField(frame: .zero)<br/>    nameTextField.placeholder = "Login Name"<br/>    nameTextField.borderStyle = .roundedRect<br/>    nameTextField.translatesAutoresizingMaskIntoConstraints = false<br/>    view.addSubview(nameTextField)<br/><br/>    passwordTextField = UITextField(frame: .zero)<br/>    passwordTextField.placeholder = "Password"<br/>    passwordTextField.isSecureTextEntry = true<br/>    passwordTextField.borderStyle = .roundedRect<br/>    passwordTextField.translatesAutoresizingMaskIntoConstraints = false<br/>    view.addSubview(passwordTextField)<br/><br/>    constraintsInit()<br/>  }<br/><br/>  func constraintsInit() {<br/>    NSLayoutConstraint.activate([<br/>      loginButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),<br/>      loginButton.centerYAnchor.constraint(equalTo: view.centerYAnchor),<br/><br/>      passwordTextField.bottomAnchor.constraint(equalTo: loginButton.topAnchor, constant: -20),<br/>      passwordTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),<br/>      passwordTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20),<br/><br/>      nameTextField.bottomAnchor.constraint(equalTo: passwordTextField.topAnchor, constant: -20),<br/>      nameTextField.leadingAnchor.constraint(equalTo: view.readableContentGuide.leadingAnchor, constant: 20),<br/>      nameTextField.trailingAnchor.constraint(equalTo: view.readableContentGuide.trailingAnchor, constant: -20)<br/>    ])<br/>  }<br/><br/>  @objc func handleLoginTouchUpInside() {<br/>    print("Login has been tapped")<br/>    if nameTextField.isFirstResponder {<br/>      nameTextField.resignFirstResponder()<br/>    }<br/>    if passwordTextField.isFirstResponder {<br/>      passwordTextField.resignFirstResponder()<br/>    }<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>