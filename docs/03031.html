<html>
<head>
<title>Async Iteration with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript异步迭代</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/async-iteration-with-javascript-420b6d67c372?source=collection_archive---------21-----------------------#2020-01-15">https://betterprogramming.pub/async-iteration-with-javascript-420b6d67c372?source=collection_archive---------21-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b019" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript中的异步迭代器和生成器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6aa6a6f25ae1ba2c3f00a772c9c4166d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9j-EdymbX4qh_EOC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alessandrodesantis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山德罗·德桑蒂斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步代码是JavaScript非常重要的一部分。我们需要编写大量的异步代码，因为JavaScript是单线程语言。如果我们一行一行地运行所有的东西，那么需要更长时间运行的代码将会阻碍程序，导致它冻结。</p><p id="7c32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了容易地编写异步代码，JavaScript有承诺，这些承诺是可链接的，并且可以按顺序运行，无需嵌套。</p><p id="fd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES2017引入了用于链接承诺的<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>语法，这使得一切变得更容易。然而，仍然没有办法按顺序运行承诺，按顺序迭代它们。这意味着在一个序列中运行大量的承诺仍然是一个无解的问题。</p><p id="f2f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，在ES2018中，我们终于有了一个可以与ES2017中引入的<code class="fe lv lw lx ly b">async</code>函数一起使用的<code class="fe lv lw lx ly b">for-await-of</code>循环。它适用于任何可迭代对象，比如同步<code class="fe lv lw lx ly b">for...of</code>循环。这意味着我们可以用它迭代对象，比如映射、集合、节点列表和<code class="fe lv lw lx ly b">arguments</code>对象。</p><p id="b78a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它可以使用<code class="fe lv lw lx ly b">Symbol.iterator</code>方法处理任何对象，该方法返回一个生成器让我们进行迭代。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3f74" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">for-await-of循环</h1><p id="d855" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以如下使用<code class="fe lv lw lx ly b">for-await-of</code>循环:</p><p id="485b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/BetterProgramming/a6c34421c67bd84ab894861e3256e449.js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/better programming/a6c 34421 c 67 BD 84 ab 894861 e 3256 e 449 . js</a></p><p id="4f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们添加了十个承诺，在<code class="fe lv lw lx ly b">for</code>循环中定义它们，然后将它们推到<code class="fe lv lw lx ly b">promises</code>数组中。然后，我们通过定义一个<code class="fe lv lw lx ly b">async</code>函数来运行承诺，然后使用<code class="fe lv lw lx ly b">for-await-of</code>循环来遍历每个承诺，一次运行一个。</p><p id="8174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">for-await-of</code>循环中的<code class="fe lv lw lx ly b">await</code>将从承诺中获取解析值，而<code class="fe lv lw lx ly b">console.log</code>将记录解析值。</p><p id="8e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和其他<code class="fe lv lw lx ly b">async</code>函数一样，只能返回承诺。</p><p id="fb9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">for-await-of</code>循环的语法与任何其他<code class="fe lv lw lx ly b">for...of</code>循环相同。<code class="fe lv lw lx ly b">let p</code>是变量声明，<code class="fe lv lw lx ly b">promises</code>是我们正在迭代的<code class="fe lv lw lx ly b">promises</code>数组。</p><p id="c0d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码像<code class="fe lv lw lx ly b">Promise.all</code>一样工作，代码是并行运行的，所以一秒钟后我们看到一到十。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2a1e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">异步迭代</h1><p id="0dbc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">或者，如果我们用<code class="fe lv lw lx ly b">Symbol.asyncIterator</code>方法定义一个对象，我们可以定义我们自己的异步可迭代对象。这是一个特殊的方法，它返回一个生成器，让我们用<code class="fe lv lw lx ly b">for-await-of</code>循环遍历它。</p><p id="827d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="76c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将返回一个生成器，它在<code class="fe lv lw lx ly b">for-await-of</code>循环运行时返回一个新的承诺。</p><p id="e1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Symbol.asyncIterator</code>方法中，我们有一个<code class="fe lv lw lx ly b">next</code>函数，如果我们想创建一个异步可迭代对象，就需要这个函数。此外，我们有<code class="fe lv lw lx ly b">i</code>属性来跟踪我们迭代的内容。</p><p id="1f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们返回的承诺中，我们有一个带有回调函数的<code class="fe lv lw lx ly b">setTimeout</code>，它解析为一个带有我们想要解析的<code class="fe lv lw lx ly b">value</code>和属性<code class="fe lv lw lx ly b">done</code>的对象。如果迭代器应该继续为<code class="fe lv lw lx ly b">for-await-of</code>循环返回新值，则<code class="fe lv lw lx ly b">done</code>属性为<code class="fe lv lw lx ly b">false</code>，否则为<code class="fe lv lw lx ly b">true</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/abc6a1f91bc0be9c428553683f4d86dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dXHVT8Dakt-eQB8w"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jeisblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰森·黑眼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5c80" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">异步发电机</h1><p id="4a42" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">yield</code>关键字来缩短代码，使生成器函数返回一个生成器。生成器是另一种可迭代对象，可以与<code class="fe lv lw lx ly b">for-await-of</code>循环一起使用。</p><p id="4240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键字<code class="fe lv lw lx ly b">function*</code>表示我们的函数只返回一个生成器。<code class="fe lv lw lx ly b">async</code>表示发电机异步运行。在<code class="fe lv lw lx ly b">asyncGenerator</code>函数中，我们有<code class="fe lv lw lx ly b">yield</code>关键字。当我们用<code class="fe lv lw lx ly b">for-await-of</code>循环遍历生成器时，<code class="fe lv lw lx ly b">yield</code>关键字从生成器中获取下一个项目。</p><p id="2866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">yield</code>关键字只适用于顶层代码。它在回调函数中不起作用。</p><p id="17f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们应该得到一到十个输出。</p><p id="3c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们这样写:</p><pre class="kj kk kl km gt ng ly nh ni aw nj bi"><span id="a61f" class="nk mh it ly b gy nl nm l nn no">async function* asyncGenerator() {<br/>  for (let i = 1; i &lt;= 10; i++) {<br/>    setTimeout(() =&gt; {<br/>      yield i;<br/>    }, 1000);<br/>  }<br/>}</span></pre><p id="385b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会得到一个<code class="fe lv lw lx ly b">SyntaxError</code>。</p><p id="cf16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们定义一个被设置为生成器函数的<code class="fe lv lw lx ly b">Symbol.asyncIterator</code>方法，那么一个对象就可以成为可迭代的。</p><p id="9084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们在<code class="fe lv lw lx ly b">console.log</code>输出中记录了一到十个。</p><p id="5ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它像我们上面定义的<code class="fe lv lw lx ly b">asyncIterable</code>对象一样工作，除了代码更短。同样，我们不能在回调中使用<code class="fe lv lw lx ly b">yield</code>关键字，所以我们必须像上面那样写。</p><p id="81a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以编写以下代码来直接循环遍历承诺:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="74c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">await</code>关键字实际上等待每个承诺的解析，直到运行下一个，所以当我们运行代码时，一秒钟后就会显示每个数字。</p><p id="9dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步迭代解决了顺序运行许多承诺的承诺。随着<code class="fe lv lw lx ly b">for-await-of</code>循环和异步迭代器和生成器的引入，该功能在ES2018或更高版本中可用。有了这些，迭代异步代码的问题就解决了。</p></div></div>    
</body>
</html>