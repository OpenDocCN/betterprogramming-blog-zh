<html>
<head>
<title>SFTP and Process XML Files in Google Cloud Platform with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python在Google云平台中SFTP和处理XML文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/sftp-and-process-xml-files-in-google-cloud-platform-with-python-bdcf3a302764?source=collection_archive---------4-----------------------#2022-10-12">https://betterprogramming.pub/sftp-and-process-xml-files-in-google-cloud-platform-with-python-bdcf3a302764?source=collection_archive---------4-----------------------#2022-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4df1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何使用Python从SFTP服务器提取XML文件，将它们备份到谷歌云存储，并处理它们的指南——所有这些都不需要启动虚拟机。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0861b7ea71b5286a6ef13b199ad32f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*CNq2qwfkKg1VKzgWuGxFvQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><h1 id="7dc6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">简介——提出问题</h1><p id="e729" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通常，当组织在数据驱动的项目上与合作伙伴协作时，文件和信息的传输可以采用无数的技术解决方案。有时，组织的合作伙伴可能会将所需的数据文件托管在专有服务器上。组织倾向于访问这些托管数据，并将其备份到自己的谷歌云平台(GCP)云存储中以供进一步处理，这种情况并不罕见。备份到云存储的数据可以下载、处理并重定向到另一个平台，而无需在GCP启动虚拟机。幸运的是，这些过程不需要手动进行，也不需要相互区分。Python可以分别与SFTP服务器和GCP通信，以便在它们之间实现一个精简的数据管道。</p><p id="e7cb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">注意:</strong>在本指南中，XML文件将用于解释目的，但同样的过程也适用于任何其他结构化数据文件(直到XML解析)。</p><p id="9ac3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">注意:</strong>所有敏感信息已被替换为占位符值。请密切注意需要手动替换的占位符值。</p><p id="45aa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">总的来说，本指南将逐步说明如何:</p><ol class=""><li id="d43a" class="mo mp iq lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">与目标SFTP服务器建立连接</li><li id="57a2" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">将SFTP服务器上所需的XML文件备份到GCP存储桶中</li><li id="7797" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">在没有GCP虚拟机的情况下处理XML文件</li></ol><p id="d7cc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如有任何问题，请<a class="ae nc" href="https://www.linkedin.com/in/rfinatan/" rel="noopener ugc nofollow" target="_blank">在LinkedIn </a>上加我，我会尽力回答你。相关的项目文件也可以在<a class="ae nc" href="https://github.com/rfinatan/SFTP-XML-GCP-Python-Pipeline" rel="noopener ugc nofollow" target="_blank"> this GitHub repository </a>中找到。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="6608" class="kv kw iq bd kx ky nk la lb lc nl le lf jw nm jx lh jz nn ka lj kc no kd ll lm bi translated">与目标SFTP服务器建立连接</h1><p id="41e3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先，有一个与我们的目标SFTP服务器通信所需的包。在Python中，加载以下包:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="0dad" class="nu kw iq nq b gy nv nw l nx ny"># import required packages</span><span id="c5fc" class="nu kw iq nq b gy nz nw l nx ny">import paramiko</span></pre><p id="7ced" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Paramiko 是SSHv2协议的纯Python实现，提供客户端和服务器功能。它为高级SSH库结构提供了基础，推荐用于常见的客户端用例，比如运行远程shell命令或传输文件。</p><p id="9101" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，实例化一个新的SSH客户机变量。这将作为SSH服务器会话的高级表示。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="b4c3" class="nu kw iq nq b gy nv nw l nx ny"># create ssh client</span><span id="2788" class="nu kw iq nq b gy nz nw l nx ny">ssh_client = paramiko.SSHClient()</span></pre><p id="3c7a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您将需要一组凭据来启用与SFTP服务器的通信。这组凭证可以通过与拥有您尝试访问的SFTP服务器的组织的IT部门交谈来获得。</p><p id="60fd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">以下身份证明是必需的，端口规格是可选的，具体取决于SFTP服务器的设置。将凭据存储在各自的变量中。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="53c0" class="nu kw iq nq b gy nv nw l nx ny"># fill required credential information</span><span id="d8a1" class="nu kw iq nq b gy nz nw l nx ny">HOSTNAME = "xfer.example.com"<br/>USERNAME = "exampleuser"<br/>PASSWORD = "examplepassword"<br/>#PORT = specify your port number here</span></pre><p id="4b4b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，连接到服务器并验证上述凭证。可以选择打印一条成功声明，以验证正在建立的连接。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="c79f" class="nu kw iq nq b gy nv nw l nx ny"># establish connection with targeted server</span><span id="f4ae" class="nu kw iq nq b gy nz nw l nx ny">ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>ssh_client.connect(HOSTNAME,PORT,USERNAME,PASSWORD)</span><span id="c0f7" class="nu kw iq nq b gy nz nw l nx ny"># optional</span><span id="18a8" class="nu kw iq nq b gy nz nw l nx ny">print('connection established successfully')</span></pre><blockquote class="oa ob oc"><p id="6c61" class="ln lo od lp b lq mj jr ls lt mk ju lv oe ml ly lz of mm mc md og mn mg mh mi ij bi translated"><strong class="lp ir">重要提示:</strong>如果Python函数的输出IP地址不在SFTP服务器的白名单中，连接尝试将会失败。如果这是一个驻留在本地机器上的功能，通过在Google中键入“我的IP是什么”找到你的IP地址，并请求将该地址加入白名单。如果这是一个作为GCP功能一部分的功能，您必须<a class="ae nc" href="https://cloud.google.com/functions/docs/networking/network-settings" rel="noopener ugc nofollow" target="_blank">设置一个云网络地址转换(NAT)和一个用于白名单的静态IP</a>。</p></blockquote></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="3388" class="kv kw iq bd kx ky nk la lb lc nl le lf jw nm jx lh jz nn ka lj kc no kd ll lm bi translated">将服务器XML文件备份到GCP存储桶</h1><p id="c560" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">下一步是在SFTP服务器上打开一个SSH会话。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="0c5a" class="nu kw iq nq b gy nv nw l nx ny"># open a SSH session on the SFTP server</span><span id="6977" class="nu kw iq nq b gy nz nw l nx ny">sftp = ssh_client.open_sftp()</span></pre><p id="62e1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">获取服务器的目录列表，并将目录打印到IDE的输出面板上。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="a324" class="nu kw iq nq b gy nv nw l nx ny"># get list of files</span><span id="8493" class="nu kw iq nq b gy nz nw l nx ny">files = sftp.listdir()<br/>print(files)</span></pre><p id="3eaf" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果您要查找的文件在最上面的目录中，请继续下一步。更有可能的是，文件将驻留在一个文件夹中。使用以下命令检查所需文件的文件夹内容:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="81d6" class="nu kw iq nq b gy nv nw l nx ny"># inspect a folder's contents</span><span id="bdb1" class="nu kw iq nq b gy nz nw l nx ny">folder_directory = sftp.listdir('folder_name')<br/>print(folder_directory)</span></pre><p id="3171" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在检查服务器的目录时，索引也是可能的。例如，可以使用典型的索引命令检索文件夹中的第一个文件:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="cfb8" class="nu kw iq nq b gy nv nw l nx ny"># determine first file in directory</span><span id="c1ea" class="nu kw iq nq b gy nz nw l nx ny">first_file =  f"{folder_directory[0]}"<br/>print(first_file)</span></pre><p id="d417" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">还建议在文件夹目录的内容中找到所需文件的路径后，存储该路径。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="75a0" class="nu kw iq nq b gy nv nw l nx ny"># store the path of the first file in directory</span><span id="652c" class="nu kw iq nq b gy nz nw l nx ny">first_file_path = f"folder_name/{folder_directory[0]}"<br/>print(first_file_path)</span></pre><blockquote class="oa ob oc"><p id="8d3f" class="ln lo od lp b lq mj jr ls lt mk ju lv oe ml ly lz of mm mc md og mn mg mh mi ij bi translated">本指南假设您对Google云存储有所了解，确保在执行后续步骤之前已经创建了Google云存储空间。有关如何创建云存储桶的更多信息，请<a class="ae nc" href="https://cloud.google.com/storage/docs/creating-buckets" rel="noopener ugc nofollow" target="_blank">阅读本指南</a>。</p></blockquote><p id="3a5d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">既然已经找到了想要的文件，备份到Google云存储的过程就很简单了。</p><p id="ff7b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">首先，从Google Cloud客户端库中导入<code class="fe oh oi oj nq b">storage</code>模块。然后，从<code class="fe oh oi oj nq b">oauth2client</code>包中导入<code class="fe oh oi oj nq b">oauth2client.service_account</code>模块。这将授权您的凭据，并根据您的GCP服务帐户进行验证。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="14dc" class="nu kw iq nq b gy nv nw l nx ny"># import google cloud storage dependencies</span><span id="fc03" class="nu kw iq nq b gy nz nw l nx ny">from gcloud import storage<br/>from oauth2client.service_account import ServiceAccountCredentials<br/>import os</span></pre><p id="6e83" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">要获取您的服务帐户凭据，请在GCP境内的搜索栏中搜索“<em class="od">服务帐户</em>”。点击'<em class="od">服务账户，IAM &amp;管理'</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/ea0ad16c438cfb7810d3bf91ec883882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plOwCw1hU0Q8WnC1QJ0aSA.png"/></div></div></figure><p id="e6fc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">选择与您想要放置SFTP文件的云存储空间相关联的GCP项目。</p><p id="08d0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果服务帐户存在，请选择现有帐户。如果项目不存在服务帐户，请单击“<em class="od">创建服务帐户</em>”。创建或选择服务帐户后，单击操作菜单按钮，并选择“<em class="od">管理密钥</em>”。</p><p id="0e6c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在密钥选项卡中，点击'<em class="od">添加密钥'</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/d6dff1d9bda6b6e15fe277c5af770f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xj1kpWylHN5GeKtLElPgmA.png"/></div></div></figure><p id="90fc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">之后，点击“<em class="od">创建新密钥</em>”。使用JSON推荐的键类型创建一个新的键。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/192d8b70eeb2c44442b481912ad8662c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUt0hei43YZkZAaPMUCptQ.png"/></div></div></figure><p id="710d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，这个密钥将被下载到您的本地或虚拟实例。在任何IDE或文本编辑器中打开该项以查看其内容。</p><p id="f8d2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">回到我们的Python程序，实例化一个名为<code class="fe oh oi oj nq b">credentials_dict</code>的新字典变量。将JSON凭证值作为字典的内容传递。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="c84b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，通过名为<code class="fe oh oi oj nq b">credentials</code>的变量将JSON GCP凭证传递给oauth2模块。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="bb8c" class="nu kw iq nq b gy nv nw l nx ny"># pass JSON GCP credentials to OAuth2 package</span><span id="1a43" class="nu kw iq nq b gy nz nw l nx ny">credentials = ServiceAccountCredentials.from_json_keyfile_dict(<br/>credentials_dict)</span></pre><p id="057e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">此外，将JSON GCP凭证传递给<code class="fe oh oi oj nq b">gcloud storage</code>模块。确保您的项目名称与GCP显示的名称完全一致。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="3783" class="nu kw iq nq b gy nv nw l nx ny"># pass GCP credentials to gcloud storage</span><span id="ab9c" class="nu kw iq nq b gy nz nw l nx ny">client = storage.Client(credentials=credentials, project='example-project')</span></pre><p id="df91" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，创建一个bucket变量，指定将XML文档上传到哪个bucket。同样，确保bucket名称与在云存储中为各个项目创建的期望bucket完全对应。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="5d5f" class="nu kw iq nq b gy nv nw l nx ny"># create bucket variable</span><span id="4ce3" class="nu kw iq nq b gy nz nw l nx ny">bucket = client.get_bucket('example-project-bucket')</span></pre><p id="bee0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于在<code class="fe oh oi oj nq b">bucket</code>变量中指定的桶值，有必要创建一个blob数据对象来存储二进制大对象。使用以下命令实例化blob，将<code class="fe oh oi oj nq b">first_file</code>更改为包含所需文件名的变量，该文件名先前在SFTP服务器的目录中找到。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="7c86" class="nu kw iq nq b gy nv nw l nx ny"># create blob variable</span><span id="306c" class="nu kw iq nq b gy nz nw l nx ny">blob = bucket.blob(first_file, chunk_size=262144)</span></pre><p id="5775" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，使用blob类型对象将文件作为副本从SFTP服务器推送到指定的云存储桶。同样，将<code class="fe oh oi oj nq b">first_file_path</code>更改为包含先前在SFTP服务器目录中找到的所需文件路径的变量。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="93cb" class="nu kw iq nq b gy nv nw l nx ny"># upload to GCP bucket</span><span id="7d29" class="nu kw iq nq b gy nz nw l nx ny">with sftp.open(first_file_path, bufsize=32768) as f:</span><span id="6e27" class="nu kw iq nq b gy nz nw l nx ny">blob.upload_from_file(f)</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="e9a7" class="kv kw iq bd kx ky nk la lb lc nl le lf jw nm jx lh jz nn ka lj kc no kd ll lm bi translated">在没有GCP虚拟机的情况下处理XML文件</h1><p id="1399" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通常，已经在GCP的XML文件的附加处理将通过使用虚拟机来进行。但是，本指南提供了一种更经济的解决方案，其中不需要启动虚拟机。为了避免VM实例，blob下载会将XML转换成可读的文本以便存储和处理。</p><p id="4c9c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">从加载所需的依赖项开始。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="e4b9" class="nu kw iq nq b gy nv nw l nx ny"># pull XML as string from GCP bucket</span><span id="1df9" class="nu kw iq nq b gy nz nw l nx ny">import pandas as pd<br/>import xml.etree.ElementTree as ET</span></pre><p id="ab43" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe oh oi oj nq b">pandas</code>包不需要介绍，但是，如果你不熟悉它的用法，请在这里阅读它的文档<a class="ae nc" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0d7c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe oh oi oj nq b">XML.etree.ElementTree</code> <a class="ae nc" href="https://docs.python.org/3/library/xml.etree.elementtree.html" rel="noopener ugc nofollow" target="_blank">是一个包</a>，它实现了一个简单高效的API来解析和创建XML数据。它对于嵌套的XML文档特别有用，因为<code class="fe oh oi oj nq b">pandas.read_xml</code>不适合嵌套的XML文档。</p><p id="ee8e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">以下命令将把我们的XML文件下载为字符串，而不是XML。这就不需要将文件存储在本地或虚拟的虚拟机上，而是将其内容直接存储到之前实例化的变量<code class="fe oh oi oj nq b">blob</code>中。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="96db" class="nu kw iq nq b gy nv nw l nx ny">blob = blob.download_as_string()</span><span id="fea2" class="nu kw iq nq b gy nz nw l nx ny">blob = blob.decode('utf-8')</span></pre><p id="02c8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了解析XML，需要一个函数来提取不同层次的嵌套信息。根据所分析的XML文件及其嵌套级别，嵌套关系的数量可能会有所不同。</p><p id="d5bb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">下面，我给出了一个例子，说明如何解析一个包含1个根、1个子元素和3个子元素嵌套的XML文档。嵌套的信息随后存储在一个名为<code class="fe oh oi oj nq b">all_records</code>的空列表中，该列表构成了一个<code class="fe oh oi oj nq b">pandas </code>数据帧的基础。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8229" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，用之前建立的包含XML内容的blob变量调用函数。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="c1d3" class="nu kw iq nq b gy nv nw l nx ny"># create pandas dataframe from extracted nested XML</span><span id="d9c0" class="nu kw iq nq b gy nz nw l nx ny">with sftp.open(first_file_path) as o:</span><span id="cd51" class="nu kw iq nq b gy nz nw l nx ny">df = xml2df(blob)</span></pre><p id="02a1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于一些可选的清除，如果在最终输出中不需要NA值，则删除所有的空行。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="30c3" class="nu kw iq nq b gy nv nw l nx ny">#Drop empty columns in dataframe</span><span id="267c" class="nu kw iq nq b gy nz nw l nx ny">df = df.drop(columns='row')</span><span id="3459" class="nu kw iq nq b gy nz nw l nx ny"># df =df.dropna(axis=1)</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="08b8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">关于如何使用Python从SFTP服务器提取XML文件，将它们备份到Google云存储，并处理它们以供进一步分析的指南到此结束。和往常一样，你可以在这个项目的<a class="ae nc" href="https://github.com/rfinatan/SFTP-XML-GCP-Python-Pipeline" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到相关的项目文件。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="21d3" class="nu kw iq nq b gy nv nw l nx ny"><strong class="nq ir">Want to Connect?</strong></span><span id="0255" class="nu kw iq nq b gy nz nw l nx ny">Feel free to <a class="ae nc" href="https://www.linkedin.com/in/rfinatan/" rel="noopener ugc nofollow" target="_blank">connect on LinkedIn</a></span></pre></div></div>    
</body>
</html>