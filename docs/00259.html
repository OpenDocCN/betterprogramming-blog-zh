<html>
<head>
<title>How to Improve Your Asynchronous JavaScript Code With Async and Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Async和Await改进异步JavaScript代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improve-your-asynchronous-javascript-code-with-async-and-await-c02fc3813eda?source=collection_archive---------0-----------------------#2019-01-06">https://betterprogramming.pub/improve-your-asynchronous-javascript-code-with-async-and-await-c02fc3813eda?source=collection_archive---------0-----------------------#2019-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/472d51fad58553ab26de08e4adcd4e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qq6OeOaNR1Ct6vF7"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ed15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有机会观察现代JavaScript代码，你很有可能在某个地方见过<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>语法。</p><p id="2ddd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Async/await</code>可以说是该语言中最受欢迎的新词之一。<strong class="ki iu"> Async/await </strong>使<strong class="ki iu">异步</strong>代码像同步代码一样出现和运行。<strong class="ki iu">异步/等待是基于承诺的。</strong></p><p id="d7c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们进入async/await之前，我们必须理解什么是承诺以及它们扮演的角色。</p><h1 id="09f7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">承诺</h1><p id="5fc3" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>是代表异步操作最终完成或失败的对象。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/697e27cdfd71732cc5f04f71202c6464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjS8YJqd5oZgyKuTrLkwaw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Using _ promises</a></p></figure><h2 id="aceb" class="mq lj it bd lk mr ms dn lo mt mu dp ls kr mv mw lw kv mx my ma kz mz na me nb bi translated">我们为什么需要异步代码呢？</h2><p id="b300" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript是单线程语言——这意味着JavaScript一次只能做一件事。想象一下，同步调用我们的API并在API调用期间阻塞整个线程——我们的用户将不得不等待30秒或网络请求解决所需的时间——这是一大禁忌！</p><p id="0da8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有兴趣了解更多，这里有一个关于JavaScript异步编程的更深入的解释。</p><div class="nc nd gp gr ne nf"><a href="https://eloquentjavascript.net/11_async.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">异步编程::雄辩的JavaScript</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">两个重要的JavaScript编程平台——浏览器和node . js——进行操作可能需要一段时间…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">eloquentjavascript.net</p></div></div><div class="no l"><div class="np l nq nr ns no nt jz nf"/></div></div></a></div><p id="1541" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们过去处理异步JavaScript代码的方式是通过回调。你很有可能会遇到回调。</p><h2 id="fa22" class="mq lj it bd lk mr ms dn lo mt mu dp ls kr mv mw lw kv mx my ma kz mz na me nb bi translated">什么是回调？</h2><p id="462d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">回调函数也称为高阶函数，是传递给另一个函数的函数。函数在JavaScript中是一级公民——这意味着它们可以作为参数传递给函数。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6f3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经见过类似这样的jQuery特定代码。</p><p id="f628" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码在我们的按钮上附加了一个事件监听器，一旦被触发就调用<code class="fe le lf lg lh b">alert</code>。</p><p id="ecd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nw">回调在哪里？你能看出来吗？</em></p><p id="8a42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你或许可以——它是在<code class="fe le lf lg lh b">click</code>函数括号内的匿名<code class="fe le lf lg lh b">function</code>。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/0389dabaab80d1609d55cf37f64a0a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlyEUlhuI64crI1SozQS5w.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/" rel="noopener ugc nofollow" target="_blank">https://JavaScript sexy . com/understand-JavaScript-callback-functions-and-use-them/</a></p></figure><p id="a2ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单地说，回调:我们触发一个函数，做一些事情，然后调用另一个函数。</p><p id="977e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调也不全是坏事；他们成功了——现在仍然如此。但是，如果回调中有回调，回调中有回调，会发生什么——你明白了。很快就会变得很乱很难维护。</p><p id="2409" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述问题被命名为<em class="nw">“回调地狱”</em></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/5bc4e8b17a9c75fba15c2b0feab4f467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5Lw_G7W4AwaFsyucfM9Bw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">http://callbackhell.com/</a></p></figure><p id="263a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里还有一个例子来密封回调的情况。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/4d51c94b19cadd47f303a94075ba952a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAXfR07Hq-AUGgU3llCijQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">我们有一个甜瓜！</p></figure><p id="1faf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们检查数组中是否有甜瓜——如果有，我们咀嚼甜瓜。嚼完之后，我们把瓜扔掉。我们还用<code class="fe le lf lg lh b">err</code>回调处理异常。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/c9c8ec17fa3b14c31db5e0ed12615c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGM1B_-hVZkj2K8l80JM6Q.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">嘿——我们改吃香蕉了！</p></figure><p id="a6ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nw">注意:</em><code class="fe le lf lg lh b">err</code>回调总是节点世界中的第一个参数— <a class="ae kf" href="https://stackoverflow.com/a/40512067/5073961" rel="noopener ugc nofollow" target="_blank">最佳实践</a>！</p><p id="85a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只是为了让你不那么困惑——我尽可能地让前面的代码可读性更好。以下是更常见的情况:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/1b7cbe0ac7193dc6c108babaebae33ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcV2CfVqHrKMq30f43XNpg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">迷你回调地狱；从技术上讲，使用匿名箭头函数是一种补救措施，但仍然不是完美的解决方案。</p></figure><p id="bb4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以想象，再有几次回调，我们就要踏上通往地狱的高速公路了——双关语！</p><h1 id="03b1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">承诺救援！</h1><p id="c61b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">承诺是编写异步代码的一种干净的方式。承诺只有一个参数，即回调。</p><p id="bc39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调有两个参数，即<code class="fe le lf lg lh b">reject</code>和<code class="fe le lf lg lh b">resolve</code>条件。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/6462f27eef421ceb5f6672c185c06958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncn09AoJaWsDPQfYA9aqOg.png"/></div></div></figure><p id="8198" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用箭头函数来缩短代码:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/ec02987d3b6a776747d76a2a55c6408d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCimDgvDvaLVOikoarmPGA.png"/></div></div></figure><p id="1fbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在承诺块中，我们可以决定何时解决，何时拒绝承诺。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/35dba1bb6c715926212497500e2ae189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IremUlel-3JY2_u2mACPXA.png"/></div></div></figure><p id="44ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在承诺中，我们检查我们是否有一个甜瓜。如果我们这样做了，让我们用传递给<code class="fe le lf lg lh b">resolve</code>的值来<code class="fe le lf lg lh b">resolve</code>这个函数——我们可以传递任何值给<code class="fe le lf lg lh b">resolve</code>。</p><p id="458d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">承诺被立即调用/解决，这就是为什么我们看到了<code class="fe le lf lg lh b">console.log </code>而没有调用承诺。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/3b3f7c2d4649078dcec3d733ad74dddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMoMkKMXLnlqNoJR202bQA.png"/></div></div></figure><p id="1546" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe le lf lg lh b">then</code>和<code class="fe le lf lg lh b">catch</code>方法调用和链接承诺。可以这样想:承诺已经有了一个值——我们该怎么处理它呢？</p><p id="bc21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是<code class="fe le lf lg lh b">then</code>和<code class="fe le lf lg lh b">catch</code>语法出现的地方。它们都是接受一个参数的回调，这个参数是在承诺内部传递的返回值。</p><p id="b918" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我们如何处理拒绝承诺的情况:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/38b1bcf55fd1c6528fa4047a0473b908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrQYvKXUeQJQFIUvnnPOkg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">用catch()处理承诺拒绝</p></figure><p id="7cfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对，现在我们的承诺不是很有活力——为什么？</p><p id="3efc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们有一个非动态的if语句。当包装在一个函数中时，承诺是非常强大的。我们称之为高阶函数。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/ee93f8d2780aa21a0a485d3231a65adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H5WNLy666odCP_92nPgbg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">将我们的承诺包装在函数中</p></figure><p id="5448" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你注意到这个小变化了吗？在这种情况下，我们将承诺包装在一个接受一个参数的函数中。这给了我们的承诺巨大的灵活性。我们可以将任何条件传递给我们的承诺，基于这个条件，它要么被拒绝，要么被解决。</p><p id="033c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是得到解决的完全有效的承诺。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/d477c553731d524b093de8787139cb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpLYPUvg2s873d_tL7CZ6w.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">坚定的承诺</p></figure><p id="c3f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和被拒绝的承诺。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/6bd643f1d2de77598ba8d2447d4f7afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71pl8GJzdcXnZge1Lz4Ung.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">被拒绝的承诺</p></figure><p id="f8dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始变得熟悉？你可能见过类似下面这样的<a class="ae kf" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a> API调用。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Axios API调用示例(基于承诺)</p></figure><p id="3cd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者fetch API调用；</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">获取API调用示例(基于承诺)</p></figure><p id="0c1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们有什么共同点？</p><p id="8338" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，它们都是承诺。他们基本上是在利用“兜帽”下的承诺。就像我们将承诺包装在函数中一样，这两个例子也是如此。</p><p id="28a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，它们都是异步代码。承诺自然是异步的。</p><p id="5598" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是异步API调用的样子:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/a64944ceaae3f3d56e0d3e70c1ecadad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IYZfZ4juddH9UoKcE0vGQ.png"/></div></div></figure><p id="0fd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以肯定地说，承诺比回访好得多。尽管承诺也有自己的缺陷——承诺会很快失控。</p><p id="0962" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有更好的方法，更干净的方法呢。<strong class="ki iu">异步/等待</strong>救援！</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/6a1c9fa88e7fcd6fa43535fe9bfb0be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pt5gRMe30EEznkQ0Co60dg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://codesandbox.io/s/p9mr3jzwp0?autoresize=1&amp;expanddevtools=1&amp;hidenavigation=1" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/p9mr3jzwp0?autoresize=1&amp;扩展工具=1 &amp;隐藏导航=1 </a></p></figure><p id="f95e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将函数标记为<code class="fe le lf lg lh b">async</code>——在函数内部，我们将异步代码标记为<code class="fe le lf lg lh b">await</code>。JavaScript将解析承诺，然后继续下一行。简而言之，我们将异步代码改为像同步代码一样阅读，同时仍然异步运行。</p><p id="97c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们不再调用promise构造函数，并且<code class="fe le lf lg lh b">then()</code>和<code class="fe le lf lg lh b">catch()</code>方法也少了很多。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/760a5f427b6f897af8b7b7e8e0b4b94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xq59dvcKNFjxHf3043axNg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/async _ function</a></p></figure><h1 id="a4fe" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">错误处理呢？</h1><p id="26c6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们当前的async/await不处理异常。这可能会导致灾难性的错误，使你的应用程序崩溃。</p><p id="269d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Try…catch</code>来救援了！</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/816204f6b017f8bfd14092b99983b9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BDAJTLZ5R95-n0qJ1K_Mw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在try catch块中包装我们的异步函数</p></figure><p id="b687" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">try catch块尝试执行代码，如果遇到任何异常/问题，它会将错误对象传递给catch块，并执行catch块内的代码。</p><div class="nc nd gp gr ne nf"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">尝试...捕捉</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">尝试...catch语句标记要尝试的语句块，并指定在引发异常时的响应。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">developer.mozilla.org</p></div></div><div class="no l"><div class="on l nq nr ns no nt jz nf"/></div></div></a></div><p id="b494" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们的异步/等待获取在错误处理时的样子。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/a1362ae5acc62111f25c76574327d6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bI90INRSx6J389sin2LESg.png"/></div></div></figure><p id="17c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是许多例子中的一个，有许多方法可以利用<strong class="ki iu"> async/await </strong>。如果你很好奇，这里有一个很好的例子，StackOverflow回答探索替代方案。</p><div class="nc nd gp gr ne nf"><a href="https://stackoverflow.com/a/40886720/5073961" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">带有异步/等待的try/catch块</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">感谢贡献一个堆栈溢出的答案！你过去的一些回答不太受欢迎，你…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">stackoverflow.com</p></div></div><div class="no l"><div class="op l nq nr ns no nt jz nf"/></div></div></a></div><p id="faaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你真的想知道如何管理承诺以及异步JavaScript代码是如何工作的，我推荐通读“<a class="ae kf" href="https://amzn.to/2K8WUYR" rel="noopener ugc nofollow" target="_blank">带承诺的JavaScript:管理异步代码</a>”这本书。</p><p id="f8df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，我希望你发现这是有用的！❤</p></div></div>    
</body>
</html>