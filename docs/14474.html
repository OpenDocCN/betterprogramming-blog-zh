<html>
<head>
<title>How To Split a Monolith Into Microservices with Jitar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Jitar将一个整体分割成微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-split-a-monolith-into-microservices-with-jitar-95caf6f81e08?source=collection_archive---------3-----------------------#2022-12-21">https://betterprogramming.pub/how-to-split-a-monolith-into-microservices-with-jitar-95caf6f81e08?source=collection_archive---------3-----------------------#2022-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b9ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用Jitar运行时将整体转化为微服务，而无需重构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c4c9c4f66df6358e81af81a0416d9ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-ukQjh9rqHr6oOD0STJ0A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@soulsana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SOULSANA </a>在<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bfd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-i-split-a-monolith-into-microservices-without-refactoring-5d76924c34c2">上一篇文章</a>中，我写了我迈向一种即时架构风格的旅程，这种风格使我能够在不重构的情况下将一个整体分割成微服务。我发现的关键解决方案是自动化API创建和灵活的细分策略的结合。这导致了<a class="ae kv" href="https://github.com/MaskingTechnology/jitar" rel="noopener ugc nofollow" target="_blank"> Jitar </a>的产生，它是JavaScript(和TypeScript)应用程序的可分发运行时。</p><p id="d95a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我想深入构建一个可拆分的整体，并使用Jitar运行时将它拆分成微服务。我们将使用上一篇文章中的小型在线商店示例。如果你还没有读上一篇文章，我建议你读一读，但这不是必须的。应用程序和转换将一步一步地解释，这样您就可以跟上了。最终结果也可以在<a class="ae kv" href="https://github.com/petermasking/jitar-microservices" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="e22b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始之前，确保您的机器上安装了<a class="ae kv" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank">node . js</a>18.7版或更高版本。我喜欢类型安全，所以我将使用TypeScript作为示例。确保您安装了版本4.4.2或更高版本。我使用<a class="ae kv" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS Code </a>作为编辑器，但是可以随意使用另一个。另外，我用的是MacBook。本文中的命令适用于Mac OS和Linux。准备，预备，开始！</p><h1 id="fd76" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤1:设置应用程序</h1><p id="65e8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们先仔细看看网店。店后面的公司虽然小，但是分四个部门。每个人都有自己独特的职责。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/8873b8753e68d5b0103ac70360220366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9whKzicaB01ZMtFP_5JEew.png"/></div></div></figure><p id="3818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的应用程序将通过以下步骤自动执行订单下达流程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/85dbab5712d89ae88ca9253de8cbfb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjbmlD29ygWM3rAM_z6Y8Q.png"/></div></div></figure><p id="0365" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要创建一个新的NPM项目来设置应用程序。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="0018" class="mw lt iq ms b be mx my l mz na">mkdir jitar-microservices<br/>cd jitar-microservices<br/>npm init</span></pre><p id="abcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经通过初始化进入我的方式使用默认设置。在这里，您可以随意做出其他选择。Jitar非常依赖ES模块系统。Node默认使用CommonJS模块系统，所以我们需要在<code class="fe nb nc nd ms b">package.json</code>文件中通过将类型设置为<code class="fe nb nc nd ms b">module</code>来改变这一点。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="b8f7" class="mw lt iq ms b be mx my l mz na">{<br/>    "type": "module",<br/>    /* name, version, description, etc. */<br/>}</span></pre><p id="ce16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了设置TypeScript，我们需要添加一个配置文件。我们可以使用以下命令:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="34cf" class="mw lt iq ms b be mx my l mz na">touch tsconfig.json</span></pre><p id="5ce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用以下配置:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="cc97" class="mw lt iq ms b be mx my l mz na">{<br/>    "compilerOptions":<br/>    {<br/>        "target": "esnext",<br/>        "module": "es2022",<br/>        "rootDir": "./src/",<br/>        "moduleResolution": "node",<br/>        "outDir": "./dist",<br/>        "removeComments": true,<br/>        "forceConsistentCasingInFileNames": true,<br/>        "strict": true,<br/>        "skipLibCheck": true<br/>    },<br/>    "exclude": ["cache", "dist", "node_modules"]<br/>  }</span></pre><p id="348e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们需要确保ES模块系统被编译器用作输出格式。</p><p id="6a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们还需要一个源代码文件夹来存放我们的代码文件。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="94eb" class="mw lt iq ms b be mx my l mz na">mkdir src</span></pre><p id="cddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经准备好识别和设置应用程序模块了。为了简单起见，我们将使用业务能力的<a class="ae kv" href="https://microservices.io/patterns/decomposition/decompose-by-business-capability.html" rel="noopener ugc nofollow" target="_blank">分解</a>来识别模块。在这种情况下，我们可以将每个部门翻译成一个模块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/84cf6c73edb0c550d9c9ab04aa0ab141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2OeqIu8AAHfVpPQ6qujQpg.png"/></div></div></figure><p id="df1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了建立基本的应用程序结构，我们将在源文件夹中为每个模块创建一个单独的子文件夹。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="2eaa" class="mw lt iq ms b be mx my l mz na">cd src<br/>mkdir order product inventory delivery</span></pre><p id="0221" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以看看实现。我已经创建了一个序列图来可视化模块之间的交互。这对我翻译代码总是有帮助。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/86cb2e8a89aa8f4df0ce5a8b3a1cea37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebENKfWt1rXkJRgYPxrZAg.png"/></div></div></figure><p id="3037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该图显示，订单模块控制着流程，这意味着它与其他模块有很强的关系。这对于较小的应用程序来说没什么问题，但是较大的应用程序可能会受益于一种更加解耦的方法。</p><p id="bc52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建应用程序的时间到了。我们将为每个组件创建一个单独的文件。这不是强制性的，但我认为这是很好的实践，因为它避免了在与多个开发人员合作时踩到对方的脚趾。我们需要两种类型的组件:功能组件和数据组件。让我们先创建文件。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="aef1" class="mw lt iq ms b be mx my l mz na">touch order/placeOrder.ts product/getProducts.ts product/Product.ts inventory/updateStock.ts order/createOrder.ts order/Order.ts delivery/planDelivery.ts delivery/Delivery.ts</span></pre><p id="247d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从编写主要的功能组件开始，它实现了place order流程。我们将为实现创建一个调用其他模块中的函数的函数。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="06e4" class="mw lt iq ms b be mx my l mz na">// src/order/placeOrder.ts<br/>import { planDelivery } from '../delivery/planDelivery.js';<br/>import { updateStock } from '../inventory/updateStock.js';<br/>import { getProducts } from '../product/getProducts.js';<br/>import { createOrder } from './createOrder.js';<br/><br/>export async function placeOrder(productIds: string[], address: string): Promise&lt;string&gt;<br/>{<br/>    const products = await getProducts(productIds);<br/>    await updateStock(productIds);<br/><br/>    const order = await createOrder(products);<br/>    const delivery = await planDelivery(address);<br/><br/>    return `Your order #${order.id} with ${order.productCount} products `<br/>         + `will be delivered to "${delivery.address}" on ${delivery.dateString}`;<br/>}</span></pre><p id="2de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这个函数和所有其他函数都是异步的。这是一个重要的附加功能，可以拆分应用程序。</p><p id="cd1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将按照调用的顺序实现其他函数。代码如下:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="9801" class="mw lt iq ms b be mx my l mz na">// src/product/getProducts.ts<br/>import { Product } from "./Product.js";<br/><br/>const products =<br/>[<br/>    new Product("1", "Product 1"),<br/>    new Product("2", "Product 2"),<br/>    new Product("3", "Product 3"),<br/>    new Product("4", "Product 4"),<br/>    new Product("5", "Product 5")<br/>]<br/><br/>export async function getProducts(productIds: string[]): Promise&lt;Product[]&gt;<br/>{<br/>    return products.filter(product =&gt; productIds.includes(product.id));<br/>}</span></pre><p id="6a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我用一个简单的静态产品列表代替了数据库。对于产品的实现，我们将创建一个数据组件。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="b47b" class="mw lt iq ms b be mx my l mz na">// src/product/Product.ts<br/>export class Product<br/>{<br/>    #id: string;<br/>    #name: string;<br/><br/>    constructor(id: string, name: string)<br/>    {<br/>        this.#id = id;<br/>        this.#name = name;<br/>    }<br/><br/>    get id(): string { return this.#id; }<br/><br/>    get name(): string { return this.#name; }<br/>}</span></pre><p id="a77e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我使用了私有字段来封装数据。产品创建后不能更新，不可更改。在使用分布式系统时，这是一种常见的做法，在不进行重构的情况下分解和扩展应用程序时，这一点非常重要。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="28f1" class="mw lt iq ms b be mx my l mz na">// src/inventory/updateStock.ts<br/>export async function updateStock(productIds: string[]): Promise&lt;void&gt;<br/>{<br/>    // Update stock per product<br/>    // Throw error if product is out of stock<br/>}</span></pre><p id="4d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于演示的目的，我已经添加了更新股票函数，但还没有实现它来监视球。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="9b12" class="mw lt iq ms b be mx my l mz na">// src/order/createOrder.ts<br/>import { Product } from '../product/Product.js';<br/>import { Order } from './Order.js';<br/><br/>export async function createOrder(products: Product[]): Promise&lt;Order&gt;<br/>{<br/>    const id = Math.floor(Math.random() * 1000);<br/><br/>    return new Order(id, products);<br/>}</span></pre><p id="3e17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这里有一个使用数据组件创建订单的简单实现:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="cb33" class="mw lt iq ms b be mx my l mz na">// src/order/Order.ts<br/>import { Product } from '../product/Product.js';<br/><br/>export class Order<br/>{<br/>    #id: number;<br/>    #products: Product[];<br/><br/>    constructor(id: number, products: Product[])<br/>    {<br/>        this.#id = id;<br/>        this.#products = products;<br/>    }<br/><br/>    get id(): number { return this.#id; }<br/><br/>    get products(): Product[] { return this.#products; }<br/><br/>    get productCount(): number { return this.#products.length; }<br/>}</span></pre><p id="e236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，当应用程序被拆分时，数据组件会自动通过网络传输。Jitar可以序列化主要类型(数字、布尔值等)。)和复杂对象(地图、日期等。).它支持私有字段，只要该对象可以使用构造函数或setter来重构。这是我尝试过的其他(反)序列化器失败的地方。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="3733" class="mw lt iq ms b be mx my l mz na">// src/delivery/planDelivery.ts<br/>import { Delivery } from './Delivery.js';<br/><br/>export async function planDelivery(address: string): Promise&lt;Delivery&gt;<br/>{<br/>    const today = new Date();<br/>    const tomorrow = new Date();<br/><br/>    tomorrow.setDate(today.getDate() + 1);<br/><br/>    return new Delivery(address, tomorrow);<br/>}</span></pre><p id="2930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不想让顾客等太久，所以我们总是第二天送货:-)。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="96f8" class="mw lt iq ms b be mx my l mz na">// src/delivery/Delivery.ts<br/>export class Delivery<br/>{<br/>    #address: string;<br/>    #date: Date;<br/><br/>    constructor(address: string, date: Date)<br/>    {<br/>        this.#address = address;<br/>        this.#date = date;<br/>    }<br/><br/>    get address(): string { return this.#address; }<br/><br/>    get date(): Date { return this.#date; }<br/><br/>    get dateString(): string { return this.#date.toDateString(); }<br/>}</span></pre><p id="f9a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码部分到此为止。我们拥有启动和运行应用程序所需的所有组件。</p><h1 id="ed66" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤2:运行应用程序</h1><p id="ee91" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了使用Jitar作为运行时，我们添加了它的Node.js服务器作为依赖项。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="9221" class="mw lt iq ms b be mx my l mz na">cd ..<br/>npm install jitar-nodejs-server</span></pre><p id="10e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们从一个整体开始，所以我们只需要一个包含所有四个模块的后端部分。订单模块是我们的主模块，所以我们可以从订单段开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/8600a7bcf70bd8a792c13afb903fde38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgM-4aTAxpnYwVGqHWxAgA.png"/></div></div></figure><p id="1fd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ms b">placeOrder</code>组件需要向外界公开，以启动流程。我们可以在<a class="ae kv" href="https://docs.jitar.dev/04_basic_features#segmentation" rel="noopener ugc nofollow" target="_blank">段配置</a>文件中进行配置。拆分应用程序时，我们将创建更多的段文件。因此，我们将首先为这些段创建一个单独的文件夹。该文件夹位于项目根文件夹中。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="b548" class="mw lt iq ms b be mx my l mz na">mkdir segments</span></pre><p id="c7d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以创建第一个段文件。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="4255" class="mw lt iq ms b be mx my l mz na">touch segments/order.segment.json</span></pre><p id="8b23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并增加以下内容:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="fbdd" class="mw lt iq ms b be mx my l mz na">{<br/>    "./order/placeOrder.js": { "placeOrder": { "access": "public" } }<br/>}</span></pre><p id="552d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">段文件的结构与JavaScript模块系统非常相似。在这种情况下，我们从<code class="fe nb nc nd ms b">./order/placeOrder.js</code>导入<code class="fe nb nc nd ms b">placeOrder</code>。此外，我们将访问权限设置为public(默认为private)。</p><p id="cb79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，文件路径是相对于应用程序的源根目录的，它导入编译后的JavaScript文件(以。js)。在加载段文件时，Jitar会将这个组件与其他组件一起导入。</p><p id="3459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要加载段文件，我们需要配置Jitar。这是通过创建新的配置文件来完成的。但首先，我们将创建一个新文件夹，因为我们稍后将添加更多配置。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="c8bd" class="mw lt iq ms b be mx my l mz na">mkdir jitar</span></pre><p id="e150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个文件夹中，我们将创建第一个配置文件。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="e186" class="mw lt iq ms b be mx my l mz na">touch jitar/standalone.json</span></pre><p id="898e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并增加以下内容:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="d1e6" class="mw lt iq ms b be mx my l mz na">{<br/>    "url": "http://127.0.0.1:3000",<br/>    "standalone":<br/>    {<br/>        "source": "./dist",<br/>        "cache": "./cache"<br/>    }<br/>}</span></pre><p id="311c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将配置一个独立的设置，意味着所有需要的运行时服务都被捆绑到一个Jitar服务器实例中。它还告诉Jitar从dist文件夹中读取编译后的JavaScript，并将其缓存写入缓存文件夹。</p><p id="6431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启动Jitar，我们需要在源根文件夹中创建一个引导程序。下面是如何做到这一点:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="28bb" class="mw lt iq ms b be mx my l mz na">touch src/jitar.ts</span></pre><p id="087c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并增加以下内容:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="7368" class="mw lt iq ms b be mx my l mz na">import { startServer } from 'jitar-nodejs-server';<br/><br/>const moduleImporter = async (specifier: string) =&gt; import(specifier);<br/><br/>startServer(moduleImporter);</span></pre><p id="aebd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着服务器的启动，我们需要提供一个模块导入器，它从本地应用程序上下文而不是Jitar上下文中导入节点依赖关系。虽然这背后的理论很有趣，但我现在将细节放在一边。</p><p id="4353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要向<code class="fe nb nc nd ms b">package.json</code>文件添加构建和运行脚本。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="a3ef" class="mw lt iq ms b be mx my l mz na">{<br/>    "scripts": {<br/>        "build": "tsc",<br/>        "standalone": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar/standalone.json"<br/>  },<br/>}</span></pre><p id="24c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都准备好了。我们可以使用以下命令测试这两个脚本:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="06e0" class="mw lt iq ms b be mx my l mz na">npm run build<br/>npm run standalone</span></pre><p id="ee16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">启动Jitar后，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/d0de8b94138fb5e3b204e482ff259bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0a78d1L3dICCUz_-u2prQ.png"/></div></div></figure><p id="e1be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们的组件已经成功注册为RPC条目。这意味着我们可以使用Jitar的<a class="ae kv" href="https://docs.jitar.dev/05_advanced_features#apis" rel="noopener ugc nofollow" target="_blank"> PRC API </a>来调用它。我喜欢使用HTTP文件来创建和共享测试请求，所以我也将在这里创建一个。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="0033" class="mw lt iq ms b be mx my l mz na">touch request.http</span></pre><p id="2d0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并添加一个测试请求。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="0e9f" class="mw lt iq ms b be mx my l mz na">POST http://localhost:3000/rpc/order/placeOrder HTTP/1.1<br/>content-type: application/json<br/><br/>{<br/> "productIds": [ "1", "3", "5" ],<br/> "address": "My Secret Lair"<br/>}</span></pre><p id="ab31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将使用POST请求调用组件，请求的主体是产品id和交付地址。为了执行，我对VS代码使用了<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" rel="noopener ugc nofollow" target="_blank"> REST客户端</a>插件，但是你可以随意使用任何你想要的API工具。</p><p id="2693" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一切顺利，您应该会得到这样的响应:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="745d" class="mw lt iq ms b be mx my l ng na">Your order #952 with 3 products will be delivered to "My Secret Lair" <br/>on Thu Dec 22 2022</span></pre><p id="55eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是设置Jitar和运行应用程序的全部内容。我们现在拥有了横向扩展所需的一切。</p><h1 id="fa23" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤3:拆分应用程序</h1><p id="71e5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在上一篇文章中，我使用了跟踪和追踪特性的引入作为分离和负载平衡交付模块的示例理由(我不是唯一一个一直在刷新的人，对吗？).是时候将这一点付诸实践，将交付模块转变为微服务了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/fe79cf713812e03c4d176aa88f23a534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpB8FzeFKJckmLfH3aWoNA.png"/></div></div></figure><p id="4a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如图所示，我们需要为交付创建一个单独的分段。像订单段一样，我们需要向segments文件夹添加一个段文件。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="749c" class="mw lt iq ms b be mx my l mz na">touch segments/delivery.segment.json</span></pre><p id="9a3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含以下内容:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="ca7f" class="mw lt iq ms b be mx my l mz na">{<br/>    "./delivery/planDelivery.js": { "planDelivery": { "access": "public" } }<br/>}</span></pre><p id="4206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用<code class="fe nb nc nd ms b">npm run standalone</code>命令重启应用程序时，我们现在应该看到<code class="fe nb nc nd ms b">planDelivery</code>组件也已经注册。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/96500899a91a958ad64124c804a4c588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gx1uch9YsCtp4BKItoKCDA.png"/></div></div></figure><p id="5e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当作为独立服务器启动Jitar时，它会自动扫描和注册所有的<code class="fe nb nc nd ms b">*.segment.json</code>文件，并作为一个整体运行应用程序。这在开发应用程序时非常有用，但是要在生产中分离它们，我们需要对Jitar进行不同的配置。</p><p id="7db0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Jitar附带了几个<a class="ae kv" href="https://docs.jitar.dev/03_runtime_services" rel="noopener ugc nofollow" target="_blank">运行时服务</a>，它们以独立模式组合在一起。要拆分应用程序，我们需要拆分运行时。对于本例，我们可以使用以下设置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/9e7a8c3c09a4f7d10a22dd15c4c91552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKktLK6aboF0s_KH3xLdmA.png"/></div></div></figure><p id="2d58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该设置使用三种不同的运行时服务:</p><ol class=""><li id="146d" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">用于定位和负载平衡组件的网关</li><li id="91b7" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">保存和提供组件的存储库</li><li id="2fbc" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">用于加载和运行段组件的两个节点</li></ol><p id="0f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端使用网关作为应用程序的中央访问点。网关将把请求转发给适当的节点。如果你有一些微服务的经验，这应该看起来很熟悉。仓库是我们中间唯一的陌生人，但不要让它欺骗了你。它扮演着最重要的角色。</p><p id="8f3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个节点(worker)启动时，它加载分配给它的段的组件。这些组件可以从不在此节点上运行的其他段导入。存储库是片段感知的，并且确切地知道何时提供远程实现而不是实际实现。</p><p id="c5e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要为每个服务添加一个单独的Jitar配置来创建这个设置。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="8524" class="mw lt iq ms b be mx my l mz na">touch jitar/repository.json jitar/gateway.json jitar/node-order.json jitar/node-delivery.json</span></pre><p id="86a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将按照开始的顺序创建它们，从<code class="fe nb nc nd ms b">repository.json</code>文件中的存储库开始。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="70f0" class="mw lt iq ms b be mx my l mz na">{<br/>    "url": "http://127.0.0.1:4000",<br/>    "repository":<br/>    {<br/>        "source": "./dist",<br/>        "cache": "./cache"<br/>    }<br/>}</span></pre><p id="7a8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种设置看起来非常类似于独立配置。这是因为独立模式处理其他服务的配置。</p><p id="d84f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将在<code class="fe nb nc nd ms b">gateway.json</code>文件中配置网关。我们只需要设置存储库的位置，因为节点会在网关上注册自己。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="661e" class="mw lt iq ms b be mx my l mz na">{<br/>    "url": "http://127.0.0.1:3000",<br/>    "gateway":<br/>    {<br/>        "repository": "http://127.0.0.1:4000"<br/>    }<br/>}</span></pre><p id="ebc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们有两个节点，所以需要分别配置它们。第一个将加载并运行在<code class="fe nb nc nd ms b">node-order.json</code>文件中配置的订单段。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="057c" class="mw lt iq ms b be mx my l mz na">{<br/>    "url": "http://127.0.0.1:3001",<br/>    "node":<br/>    {<br/>        "repository": "http://127.0.0.1:4000",<br/>        "gateway": "http://127.0.0.1:3000",<br/>        "segments": [ "order" ]<br/>    }<br/>}</span></pre><p id="4bd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个节点将加载并运行交付段，并在<code class="fe nb nc nd ms b">node-delivery.json</code>文件中进行配置。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="fd8d" class="mw lt iq ms b be mx my l mz na">{<br/>    "url": "http://127.0.0.1:3002",<br/>    "node":<br/>    {<br/>        "repository": "http://127.0.0.1:4000",<br/>        "gateway": "http://127.0.0.1:3000",<br/>        "segments": [ "delivery" ]<br/>    }<br/>}</span></pre><p id="bb46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，每个配置在URL规范中使用不同的端口。这样，我们可以在同一台机器上运行服务，这对于现在来说很方便。</p><p id="77cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了启动服务，我们需要在<code class="fe nb nc nd ms b">package.json</code>文件中为它们添加脚本。总的来说，脚本部分如下所示:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="3930" class="mw lt iq ms b be mx my l mz na">{<br/>    "scripts": {<br/>        "build": "tsc",<br/>        "standalone": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar/standalone.json",<br/>        "repository": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar/repository.json",<br/>        "gateway": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar/gateway.json",<br/>        "order": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar/node-order.json",<br/>        "delivery": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar/node-delivery.json"<br/>    },<br/>}</span></pre><p id="b2c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试时间到了。我们还没有接触应用程序，所以我们可以跳过构建步骤。我们需要按照以下顺序从单独的终端启动每个服务:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="447e" class="mw lt iq ms b be mx my l mz na">npm run repository<br/>npm run gateway<br/>npm run order<br/>npm run delivery</span></pre><p id="14f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从订单节点开始，我们应该看到它只注册了<code class="fe nb nc nd ms b">placeOrder</code>组件。交付节点应该只注册<code class="fe nb nc nd ms b">planDelivery</code>组件。如果是这种情况，那么分段是有效的。我们可以通过再次执行请求来检查这一点。网关应该告诉我们它已经分别运行了这两个组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/964ea97cab64b8b51e1a392068c722da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70Ay3VhxgVu_KtBpOiE-aw.png"/></div></div></figure><p id="a098" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！您只是将一个模块转换成了一个服务，而没有进行重构。</p><p id="ae03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这里开始，很容易为交付服务设置负载平衡。我们只需要启动交付节点一秒钟，三分钟，…时间。这在您的本地机器上不起作用，因为端口已经被使用。但是我们可以将配置复制到一个新文件中。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="314a" class="mw lt iq ms b be mx my l mz na">cp jitar/node-delivery.json jitar/node-delivery2.json</span></pre><p id="7c36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在<code class="fe nb nc nd ms b">node-delivery2.json</code>文件的URL中增加端口号。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="bbe6" class="mw lt iq ms b be mx my l mz na">{<br/>    "url": "http://127.0.0.1:3003",<br/>    "node":<br/>    {<br/>        "repository": "http://127.0.0.1:4000",<br/>        "gateway": "http://127.0.0.1:3000",<br/>        "segments": [ "delivery" ]<br/>    }<br/>}</span></pre><p id="5652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记给<code class="fe nb nc nd ms b">package.json</code>文件添加一个脚本。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="31f2" class="mw lt iq ms b be mx my l mz na">"delivery2": "node --experimental-network-imports --experimental-fetch dist/jitar.js --config=jitar/node-delivery2.json"</span></pre><p id="df3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">启动节点，看看多次执行请求时会发生什么。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="8ff2" class="mw lt iq ms b be mx my l mz na">npm run delivery2</span></pre><p id="57ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网关现在应该将负载循环分配给两个传送节点。</p><p id="13de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在当前设置中，订单段包含订单、产品和库存模块。根据您的需要，可以为每个模块创建一个单独的段，并在同一个节点上运行它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/7a1d89229e16678d216bfc1ddd2f4ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KU9gLxdsVExpe3sBEHJRhA.png"/></div></div></figure><p id="b1a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以通过创建新的段文件并将段添加到节点配置中来完成。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="c50a" class="mw lt iq ms b be mx my l mz na">{<br/>    "url": "http://127.0.0.1:3001",<br/>    "node":<br/>    {<br/>        "repository": "http://127.0.0.1:4000",<br/>        "gateway": "http://127.0.0.1:3000",<br/>        "segments": [ "order", "product", "inventory" ]<br/>    }<br/>}</span></pre><p id="15f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">效果与当前的设置相同，但是增加了可部署性的灵活性。如果您正在开发一个供多个客户使用的单租户应用程序，可以配置节点以始终满足当前(云)托管需求。尽可能长时间地在单个节点上运行数据段有助于降低运营成本。</p><h1 id="80da" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="8c98" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Jitar使开发人员的生活变得更加轻松，因为它无需重构就可以拆分和分发应用程序。这并不意味着构建可分发的应用程序变得超级简单，但是它增加了很多我在别处没有发现的灵活性。例如，应用程序可以作为一个整体来开发，作为微服务来部署。</p><p id="3feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然本文关注的是后端，但是Jitar也允许拆分前端。在之前的一篇文章中，我写过如何用Jitar 创建一个全栈应用程序。那篇文章使用了一个单独的片段，但是也可以像本文一样创建多个片段。</p><p id="0c54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我结束之前，我想感谢您阅读这篇文章。我总是乐于接受反馈，并乐意回答任何问题。在接下来的文章中，我想深入探讨一些细节，比如处理数据(数据库)、授权等。欢迎建议/请求。</p><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/how-i-split-a-monolith-into-microservices-without-refactoring-5d76924c34c2"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">我如何在不重构的情况下将一个整体分割成多个微服务</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">我通过即时架构风格变得更加敏捷的旅程</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">better编程. pub</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kp oa"/></div></div></a></div></div></div>    
</body>
</html>