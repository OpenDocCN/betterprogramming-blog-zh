<html>
<head>
<title>RxJS Declarative Pattern in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS角度声明模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjs-declarative-pattern-in-angular-cafba3983d21?source=collection_archive---------1-----------------------#2022-04-01">https://betterprogramming.pub/rxjs-declarative-pattern-in-angular-cafba3983d21?source=collection_archive---------1-----------------------#2022-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="08b9" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@lorenzozar/list/rxjs-39bc4f4110ec" rel="noopener"> RxJS </a>，<a class="ae ep" href="https://medium.com/@lorenzozar/list/angular-5496c492a185" rel="noopener">有角</a></h2><div class=""/><div class=""><h2 id="49aa" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用声明性RxJS模式检索Angular中的数据</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7b934a65abe5ef89fd62a54244e4684e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDwRP2g_KeFBaD1OxKf8cg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">RxJS徽标</p></figure><p id="3dc2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">RxJS <strong class="lg ja"> </strong>是一个JavaScript库，支持反应式编程，广义来说是一种声明式编程。然而，需要明确的是，RxJS并没有让你的代码默认为反应式或声明式的。</p><p id="ac98" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您可以使用命令式或声明式风格进行编码。这两种风格都可以在合适的环境中增加价值。</p><p id="edb9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，如果在使用RxJS时使用命令式编程风格，那么您可能会失去反应式/声明式编程风格的一些好处。</p><p id="3fd7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在开始一个使用RxJS和Angular的例子之前，我将简要讨论命令式编程和声明式编程之间的区别。</p><ol class=""><li id="2943" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">命令式与声明式:简单介绍命令式和声明式编程风格之间的理论差异。</li><li id="3ea2" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">Angular中的RxJS:通过一些例子展示了如何在Angular中使用RxJS按照命令式和声明式模式检索数据，从而将理论付诸实践。</li></ol><p id="58ae" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了充分利用这篇文章，你应该熟悉<a class="ae mo" href="https://www.vitainbeta.org/2022/02/06/angular-tutorial-and-posts/" rel="noopener ugc nofollow" target="_blank">角度</a>、<a class="ae mo" href="https://www.vitainbeta.org/2022/01/18/what-is-rxjs/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>和<a class="ae mo" href="https://www.vitainbeta.org/2022/02/01/what-are-observables/" rel="noopener ugc nofollow" target="_blank">可观测量</a>。尽管RxJS是框架不可知的，但它被广泛用于Angular。</p><h1 id="2b3c" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">命令式vs陈述式</h1><p id="2401" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">对于一些读者来说，这一部分是不必要的，因为命令式编程和声明式编程之间的区别已经在别处广泛讨论过了。</p><p id="4397" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，如果你想更深入地挖掘，我在这一节的末尾增加了一些深度。</p><h2 id="92cd" class="nm mq iq bd mr nn no dn mv np nq dp mz ln nr ns nb lr nt nu nd lv nv nw nf iw bi translated">概观</h2><p id="c6e3" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">简而言之，声明式编程告诉一个程序<em class="nx">需要做什么</em>；命令式编程告诉程序<em class="nx">如何</em>去做。</p><p id="5e86" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">简而言之:</p><ul class=""><li id="838b" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz ny mg mh mi bi translated">声明式编程描述了要实现的目标，但没有描述如何实现它。声明式编程不描述中间步骤；它回答了这个问题:目标是什么？示例语言:C、C++、Java。</li><li id="e3de" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz ny mg mh mi bi translated">命令式编程是程序应该执行以实现特定目标的一系列命令。命令式编程描述了如何实现目标；它回答了这样一个问题:如何实现目标？示例语言:Haskell、Lisp、SQL。</li></ul><p id="43cb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">你可以用两种方法达到同样的目的。</p><h2 id="ed28" class="nm mq iq bd mr nn no dn mv np nq dp mz ln nr ns nb lr nt nu nd lv nv nw nf iw bi translated">什么和如何</h2><p id="65f2" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">假设我饿了，所以我的目标是煮点东西。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/7cff069a88504fd448db9dd377e4f399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bcMrkXbmRffJ9KQ-"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae mo" href="https://unsplash.com/@mggbox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mgg Vitchakorn </a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="18f6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">遵循陈述风格，我可以说“煮一些意大利面。”目标是什么？做些意大利面。</p><p id="d581" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">遵循命令式风格，我需要说明如何实现它:</p><ul class=""><li id="5858" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz ny mg mh mi bi translated">烧开一升水</li><li id="7646" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz ny mg mh mi bi translated">加入一撮盐</li><li id="06c4" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz ny mg mh mi bi translated">当水沸腾时，加入80克意大利面</li><li id="a405" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz ny mg mh mi bi translated">包装上标明的时间过后，将意大利面从水中取出</li></ul><p id="aca4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这两种风格截然不同。</p><p id="1059" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们甚至可以说，命令式风格以一种逐步的、机械的方式解释了要做什么，但可能对我们想要解决的问题没有什么洞察力。</p><p id="ec12" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">声明式风格提出了一个解决方案，并试图解决一个问题，而不解释如何解决。</p><h2 id="26d8" class="nm mq iq bd mr nn no dn mv np nq dp mz ln nr ns nb lr nt nu nd lv nv nw nf iw bi translated">上下文无关的</h2><p id="72c1" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">此外，我们可以说声明式编程是上下文无关的，因为我可以使用相同的声明在餐馆或其他上下文中烹饪意大利面。</p><p id="2e45" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">遵循命令式的风格，我们声明了可能不适合其他环境(如餐馆)的数量。</p><h2 id="6bf3" class="nm mq iq bd mr nn no dn mv np nq dp mz ln nr ns nb lr nt nu nd lv nv nw nf iw bi translated">优点和缺点</h2><p id="485b" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">声明式编程比命令式编程好吗？看情况！</p><p id="43a1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">声明式编程的抽象程度更高。</strong></p><p id="0d57" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">更高层次的抽象既不好也不坏。它能把复杂的问题包装成简单的解决方案。它甚至可以通过隐藏一些复杂性来加速开发。</p><p id="5cdf" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">设想一个创建标准表单的库，包括样式和状态管理。太棒了！</p><p id="3a0b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">只要您不需要更改表单的某些部分来适应您的特定用例。</p><p id="ebba" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">对于更高层次的抽象，也是一样的。如果您不需要使用复杂性，并且不会对性能产生太大影响，那么隐藏复杂性是一件好事。</p><p id="fd84" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">说了这么多，我们想对RxJS使用声明式风格。</p><h1 id="98e7" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">RxJS以角度表示</h1><p id="12aa" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">同样，使用RxJS不会使您的代码具有声明性。实际上，只要你一使用<code class="fe oa ob oc od b">subscribe()</code>方法，你就要势在必行了！</p><p id="2627" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们来看看检索数据的经典模式，并将其与声明性模式进行比较。</p><h2 id="3ff7" class="nm mq iq bd mr nn no dn mv np nq dp mz ln nr ns nb lr nt nu nd lv nv nw nf iw bi translated">经典图案</h2><p id="30e3" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">在下面的代码中，您可以看到一个带有<code class="fe oa ob oc od b">getTodo</code>方法的Angular服务，它在第20行发出HTTP GET请求。</p><p id="a0ff" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">它返回一个<code class="fe oa ob oc od b">ToDo</code>类型的可观察对象。代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7011" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了按照经典模式使用服务和可观察对象，我们需要适当地订阅和取消订阅。</p><p id="825d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在<code class="fe oa ob oc od b">app.component.ts</code>中，我们将订阅包含在<code class="fe oa ob oc od b">ngOnInit</code>中，以便在页面加载时检索数据。</p><p id="46e5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将订阅存储在<code class="fe oa ob oc od b">subscription</code>变量中，这样当页面卸载时，我们可以很容易地在<code class="fe oa ob oc od b">ngOnDestroy</code>中取消订阅，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="887d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以在模板中使用字符串插值<code class="fe oa ob oc od b">{{data.title}}</code>来显示与我们检索到的数据相关的标题。</p><pre class="kp kq kr ks gt og od oh oi aw oj bi"><span id="5de9" class="nm mq iq od b gy ok ol l om on">// app.component.html</span><span id="a641" class="nm mq iq od b gy oo ol l om on">&lt;div *ngIf="data"&gt;<br/>  {{ data.title }}<br/>&lt;/div&gt;</span></pre><h2 id="57be" class="nm mq iq bd mr nn no dn mv np nq dp mz ln nr ns nb lr nt nu nd lv nv nw nf iw bi translated">陈述模式</h2><p id="bfb7" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">让我们回顾一下代码，以实现一个声明性模式。</p><p id="0c3f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以从服务开始，我们声明一个变量<code class="fe oa ob oc od b">todo$</code>，而不是声明一个<code class="fe oa ob oc od b">getTodo</code>方法。</p><p id="ecd1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">美元符号是一种约定，表示变量是一个<code class="fe oa ob oc od b">Observable</code>而不是实际的数据。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="30e4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们转到组件。</p><p id="0812" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先，我们删除所有管理订阅和相关导入的代码。在这个简单的例子中，我们甚至可以去掉<code class="fe oa ob oc od b">ngOnInit</code>和<code class="fe oa ob oc od b">ngOnDestroy</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e691" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里的关键行是第10行，它是:</p><pre class="kp kq kr ks gt og od oh oi aw oj bi"><span id="5d06" class="nm mq iq od b gy ok ol l om on">data$ = this.todoService.todo$;</span></pre><p id="0998" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们刚刚定义了另一个名为<code class="fe oa ob oc od b">data$</code>的局部变量。我们将服务中的可观察对象分配给变量，使其在组件中可用。</p><p id="a4e6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">注意，我们不是在告诉Angular订阅或退订！我们甚至看不到一个观察者！这是真正的声明式风格的亮点。</p><p id="7c2a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，我们只想在模板中显示一些数据。这是我们的目标。Angular如何实现它不关我们的事。</p><p id="8fc6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们转到模板。</p><p id="f5c3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们使用异步管道。异步管道自动订阅和取消订阅，如下所示:</p><pre class="kp kq kr ks gt og od oh oi aw oj bi"><span id="6422" class="nm mq iq od b gy ok ol l om on">// app.component.html</span><span id="d7ce" class="nm mq iq od b gy oo ol l om on">&lt;div *ngIf="data$ | async as data"&gt;<br/>  {{ data.title }}<br/>&lt;/div&gt;</span></pre><p id="fa17" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先，我们从组件绑定到<code class="fe oa ob oc od b">data$</code>。</p><p id="044a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">其次，我们使用异步管道来订阅和取消订阅<code class="fe oa ob oc od b">data$</code></p><p id="9d08" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">第三，我们使用<code class="fe oa ob oc od b">as data</code>来定义变量，该变量将包含来自可观察值的值。最后，我们可以像以前一样在模板上使用<code class="fe oa ob oc od b">data</code>。</p><h1 id="80fa" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">概述</h1><p id="0d1e" class="pw-post-body-paragraph le lf iq lg b lh nh ka lj lk ni kd lm ln nj lp lq lr nk lt lu lv nl lx ly lz ij bi translated">要在Angular中使用声明性模式检索数据，</p><ol class=""><li id="d7f8" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">首先在服务中声明可观察变量</li><li id="d167" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">在组件中使用一个局部变量，使可观察对象在模板中可用</li><li id="f489" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">在模板中使用角度异步管道</li></ol></div></div>    
</body>
</html>