<html>
<head>
<title>Improve the Performance of Docker on MacOS With Docker-Sync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker-Sync提高MacOS上Docker的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improve-performance-of-docker-on-macos-by-using-docker-sync-4f46edbde570?source=collection_archive---------5-----------------------#2020-05-11">https://betterprogramming.pub/improve-performance-of-docker-on-macos-by-using-docker-sync-4f46edbde570?source=collection_archive---------5-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4418" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Mac上的Docker可能是一个资源猪，但它不一定是</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/96a3fafea357dac1733105e34edbd1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UamunQB0RfYhlv7EmOphEQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mahdi17?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Md Mahdi </a>在<a class="ae kv" href="https://unsplash.com/s/photos/mac?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="808b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经将开发环境迁移到Docker，并且您在Mac上，您可能会注意到您的web应用程序堆栈比您已经习惯的另一个本地环境要慢。事实是，与Linux机器相比，Docker for Mac的IO性能非常慢。</p><p id="7310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在OSX/Windows下用docker开发是一件非常痛苦的事情，因为将代码共享到容器中会降低代码执行的速度。为了解决性能问题，我们可以使用<code class="fe ls lt lu lv b"><a class="ae kv" href="http://docker-sync.io/" rel="noopener ugc nofollow" target="_blank">docker-sync</a></code> <em class="lw">。</em>为了展示如何在我们的应用程序中设置<em class="lw"> docker-sync </em>，我们举一个Rails应用程序的例子。</p><p id="3836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的rails应用程序中，我有一个如下配置的<code class="fe ls lt lu lv b">docker-compose.yml</code> <em class="lw"> </em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="e874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，你需要安装<code class="fe ls lt lu lv b">docker-sync</code>宝石:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="fede" class="md me iq lv b gy mf mg l mh mi">sudo gem install docker-sync</span></pre><p id="c7cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你需要创建<code class="fe ls lt lu lv b">docker-sync.yml</code>。这将具有以下配置，src入口点将用作<em class="lw"> </em> <code class="fe ls lt lu lv b">docker-compose.yml</code>中的外部卷:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="6324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你创建了<code class="fe ls lt lu lv b">docker-sync.yml</code>，你需要更新<code class="fe ls lt lu lv b">docker-compose.yml</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="ff22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，整个<code class="fe ls lt lu lv b">docker-compose.yml</code>文件将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="dfa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启动容器，您可以使用<code class="fe ls lt lu lv b">docker-sync-stack start</code> <em class="lw"> — </em>该命令将启动您的同步过程以及服务器。</p><p id="9339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想先启动同步过程，然后分别启动容器，可以使用以下命令:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="f38e" class="md me iq lv b gy mf mg l mh mi">docker-sync clean<br/>docker-sync start<br/>docker-compose up</span></pre><p id="68fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置好<code class="fe ls lt lu lv b">docker-sync</code> <em class="lw"> </em>之后，您可能会遇到这样的问题:在数据库容器启动之前，您的主应用程序容器试图启动并运行。如果发生这种情况，那么您的主应用程序容器将无法启动。为了防止这种情况，我们可以对您的<code class="fe ls lt lu lv b"><em class="lw">docker-compose.yml </em></code>文件进行以下更改。</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="10ed" class="md me iq lv b gy mf mg l mh mi">command: bash -c "while !&lt;/dev/tcp/db/5432; do sleep 1; done; rm -f tmp/pids/server.pid &amp;&amp; bundle exec rails s -p 3000 -b '0.0.0.0'"</span></pre><p id="7750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个配置是可选的——这完全取决于如何在<code class="fe ls lt lu lv b">docker-compose.yml</code>文件中设置依赖容器。通过使用这种配置，除非数据库容器已经启动，否则主应用程序容器不会启动。</p><p id="c213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个设置对我们来说非常好，使我们能够在Mac上运行Docker。</p></div></div>    
</body>
</html>