<html>
<head>
<title>The Difference Between Regular Functions and Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常规函数和箭头函数的区别</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/difference-between-regular-functions-and-arrow-functions-f65639aba256?source=collection_archive---------0-----------------------#2019-07-25">https://betterprogramming.pub/difference-between-regular-functions-and-arrow-functions-f65639aba256?source=collection_archive---------0-----------------------#2019-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6fac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索ES6中的粗箭头特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d6fac33457aae083178cd1eae915051f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6zvXMZc4UZ73rdpc4r5nQ.png"/></div></div></figure><p id="04b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Arrow function —也称为fat arrow function—是ES6中引入的新功能，它是一种用于编写函数表达式的更简洁的语法。虽然常规的JavaScript函数和arrow函数的工作方式相似，但它们之间还是有一些不同之处。</p><h2 id="4a99" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">1.句法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7572" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的arrow函数示例允许开发人员用更少的代码行和大约一半的输入完成相同的结果。</p><p id="e782" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果只有一个表达式，则不需要花括号。上面的例子也可以这样写:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="77eb" class="lq lr it mm b gy mq mr l ms mt">let add = (x, y) =&gt; x + y;</span></pre><p id="a631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果只有一个参数，也不需要括号:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="50fc" class="lq lr it mm b gy mq mr l ms mt">let squareNum = x =&gt; x * x;</span></pre><p id="77af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有争论呢？</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="db8a" class="lq lr it mm b gy mq mr l ms mt">let sayHi = _ =&gt; console.log(“Hi”);</span></pre><h2 id="fbd2" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">2.参数绑定</h2><p id="fcb6" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">箭头函数没有<code class="fe mz na nb mm b">arguments</code>绑定。但是，它们可以访问最近的非箭头父函数的arguments对象。很大程度上依赖于命名参数和rest参数来捕获传递给箭头函数的参数。</p><p id="f129" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在常规函数的情况下:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="d7ee" class="lq lr it mm b gy mq mr l ms mt">let myFunc = {  <br/> showArgs(){ <br/>  console.log(arguments); <br/> } <br/>}; <br/>myFunc.showArgs(1, 2, 3, 4);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/cfc2b8ea96f52a557dc699fd0ddbc637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zfZ5LPxucvbcY8U6awHuQ.png"/></div></div></figure><p id="cdce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在箭头功能的情况下:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="42b3" class="lq lr it mm b gy mq mr l ms mt">let myFunc = {  <br/>  showArgs : () =&gt; { <br/>  console.log(...arguments); <br/> } <br/>}; <br/>myFunc.showArgs(1, 2, 3, 4);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/ae1afad6f246293237744d8ee3f6c38b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPVEh4B91qEttNYkOA1Zug.png"/></div></div></figure><h2 id="3d5b" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">3.此关键字的使用</h2><p id="193b" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">与常规函数不同，箭头函数没有自己的<code class="fe mz na nb mm b">this</code>。箭头函数中<code class="fe mz na nb mm b">this</code>的值在函数的整个生命周期中保持不变，并且总是绑定到最近的非箭头父函数中<code class="fe mz na nb mm b">this</code>的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/9e16b6b03684cd5e49b9b54e4009199f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukgCbQsUCzWFk8DnajPxAw.png"/></div></div></figure><h2 id="b5ee" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">4.使用新关键字</h2><p id="6551" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">使用函数声明或表达式创建的正则函数是可构造和可调用的。因为常规函数是可构造的，所以可以使用<code class="fe mz na nb mm b">new</code>关键字调用它们。</p><p id="9d5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，箭头函数只可调用，不可构造，也就是说，箭头函数永远不能用作构造函数。因此，永远不能用关键字<code class="fe mz na nb mm b">new</code>调用它们。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="073e" class="lq lr it mm b gy mq mr l ms mt">let add = (x, y) =&gt; console.log(x + y);</span><span id="f35f" class="lq lr it mm b gy ne mr l ms mt">new add(2,3);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/fdfd8c46094aacdc336ae3d20f5584b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YNGQqx_kYCNCmyOLzLt6w.png"/></div></div></figure><h2 id="9ad8" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">5.没有重复的命名参数</h2><p id="0f54" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">无论是在严格模式还是非严格模式下，箭头函数都不能有重复的命名参数。</p><p id="8693" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着以下是有效的JavaScript:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="3fdc" class="lq lr it mm b gy mq mr l ms mt">function add(x, x){}</span></pre><p id="b423" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在使用严格模式时却不是这样:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="76df" class="lq lr it mm b gy mq mr l ms mt">'use strict';<br/>function add(x, x){}<br/>// SyntaxError: duplicate formal argument x</span></pre><p id="a746" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于arrow函数，无论是严格模式还是非严格模式，重复的命名参数总是无效的。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="30eb" class="lq lr it mm b gy mq mr l ms mt">(x, x) =&gt; {}<br/>// SyntaxError: duplicate argument names not allowed in this context</span></pre><p id="4869" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">希望这对^_^有所帮助</strong></p></div></div>    
</body>
</html>