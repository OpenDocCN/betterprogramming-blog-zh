<html>
<head>
<title>React: Real-Time Price Chart SVG Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:实时价格图表SVG组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-real-time-price-chart-svg-components-3f93767fc350?source=collection_archive---------12-----------------------#2019-11-11">https://betterprogramming.pub/react-real-time-price-chart-svg-components-3f93767fc350?source=collection_archive---------12-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="86e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在React中实现实时SVG线图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d1e1303c186b8e3643bcaf730d536ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEtJy8AAJ7XjTOiWgiZoFw.jpeg"/></div></div></figure><h1 id="2013" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">价格图表是任何金融平台的重要组成部分</h1><p id="ad27" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在财务应用程序的登录页面和仪表板上包括价格图表已经成为标准做法，无论是在应用程序中还是在web上。这些图表是作为SVG构建的，旨在显示一段时间(通常是24小时)内的趋势，通常每隔几秒到几分钟更新一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/04a320c67071cdf6e50b200346b59b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3e5QvesP915ElXvStQWSg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">价格图表的典型示例，显示资产的24小时价格变动</p></figure><p id="313d" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">描述价格变动的图表通常与其他资产数据(如价格和价格变化)一起显示在列表中，通常通过仅显示线条本身来保持简单的美感。</p><p id="991a" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们还将介绍如何用不同的颜色给线下的区域着色，这是这些图形的另一个共同特征。</p><p id="5b85" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">由于这些图形的简单性，没有必要采用一个更强大的绘图解决方案，这会导致项目规模膨胀和增加不必要的复杂性。有了与React状态结合使用的SVG操作知识，以及规范化数据集以适合我们的SVG作为定位点的过程，我们可以自己创建一个优雅、快速、轻量级的解决方案。</p><p id="e14c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">本文详细介绍了这个过程，将这些图形创建为React组件，该组件通过内联JSX获取一系列点来构建SVG。我们将涵盖:</p><ul class=""><li id="cf25" class="ms mt it lo b lp mn ls mo lv mu lz mv md mw mh mx my mz na bi translated">如何使用一个SVG构建一个线图，用一个<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline" rel="noopener ugc nofollow" target="_blank">polyline</a></code>表示线本身，用一个<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon" rel="noopener ugc nofollow" target="_blank">polygon</a></code>表示线下可选的阴影区域——这对于增加图形的美感也非常有用</li><li id="aeda" class="ms mt it lo b lp ng ls nh lv ni lz nj md nk mh mx my mz na bi translated">如何构建一个<code class="fe nb nc nd ne b">&lt;PriceChart /&gt;</code>组件，它接受一组坐标作为支撑，利用它们来构建线图的形状</li><li id="3343" class="ms mt it lo b lp ng ls nh lv ni lz nj md nk mh mx my mz na bi translated">如何获取一系列原始价格，并在0到100的范围内对其进行归一化，以绘制到SVG上</li></ul><p id="b1b1" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在将SVG包装在React组件中并为行坐标嵌入道具之前，让我们首先探索如何构造SVG本身。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="0d65" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">构建价格图表SVG</h1><p id="9e1b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">构建SVG图表组件有三个步骤:</p><ol class=""><li id="5150" class="ms mt it lo b lp mn ls mo lv mu lz mv md mw mh nx my mz na bi translated">价格图表的形状和密度是要考虑的第一件事——与决定要使用的SVG维度的数据集相一致。</li><li id="ef4b" class="ms mt it lo b lp ng ls nh lv ni lz nj md nk mh nx my mz na bi translated">一旦确定下来，我们就可以将SVG模板化为React组件，将其包装在一个样式化的组件中，以适应其大小和颜色。</li><li id="19d9" class="ms mt it lo b lp ng ls nh lv ni lz nj md nk mh nx my mz na bi translated">最后，价格坐标可以通过props嵌入到SVG中，并绘制成SVG元素中的点。</li></ol><h2 id="bb63" class="ny kv it bd kw nz oa dn la ob oc dp le lv od oe lg lz of og li md oh oi lk oj bi translated">确定SVG大小</h2><p id="ae78" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">规划SVG的维度非常重要。大多数价格图表都绘制在一个矩形区域内，这不是巧合。这就是为什么:</p><ul class=""><li id="f328" class="ms mt it lo b lp mn ls mo lv mu lz mv md mw mh mx my mz na bi translated"><strong class="lo iu">SVG的宽度</strong>通常与将要绘制的价格一致。例如，5分钟间隔的每个像素1个点为我们提供了24小时内总共288个图。在这种情况下，SVG的宽度将是287px(因为第一个点将位于x位置0)。</li><li id="11c6" class="ms mt it lo b lp ng ls nh lv ni lz nj md nk mh mx my mz na bi translated"><strong class="lo iu">SVG的高度</strong>需要<em class="ok">标准化友好。</em>换句话说，一旦我们将价格标准化为0到1之间的值，它们需要再次相乘以适应SVG的维度(SVG不会只有1px高)。例如，我们可以添加另一种计算方法，将这些标准化值乘以100，这样我们就可以得到0到100之间的范围。现在我们可以开始工作了。</li></ul><p id="fa0d" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">一旦我们的React价格图表组件构建完成并准备好获取坐标，我们将在本文的后半部分更详细地讨论这个标准化过程。</p><p id="7859" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">考虑到上述情况，我们将在图表中显示过去24小时的价格变动。</p><p id="be6d" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">对于这个时间框架，以五分钟为间隔绘制点是完全可以接受的，提供了足够的细节来显示价格的准确变动，总共有288个价格点可供使用:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="3789" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// price points with 5 minute intervals</strong></span><span id="3c9b" class="ny kv it ne b gy ot oq l or os">86,400 (seconds in a day) / 300 (seconds in 5 minutes) = 288</span></pre><p id="e75e" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们最终得到的是一个合适的SVG区域<code class="fe nb nc nd ne b">287px by 100px</code>。这个区域非常适合在列表或小部件中嵌入价格图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/5dac90cb1f40d8146d36e66abd81400a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GoJr34eGY4wEHGjuCmg-yg.png"/></div></div></figure><p id="13e1" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">确定价格区间时需要考虑的一些事情:你计划的图表有多大？你能减少点数，从而降低应用带宽要求吗？您的数据源允许的最短间隔是多少？您可能需要围绕这个或其他约束来设计您的UI。</p><p id="dfb7" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们的SVG大小现在可以根据您的UI目标作为进一步操作的基础。因此，如果您的价格图表需要横跨整个页面，您可以每四个像素而不是每个像素绘制一个点，对于相同的五分钟间隔，总宽度将为1151像素，或者任何符合您需要的形状。</p><p id="0849" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在SVG <code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox" rel="noopener ugc nofollow" target="_blank">viewBox</a></code>的维度已经确定，我们可以安全地定义我们的<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg" rel="noopener ugc nofollow" target="_blank">svg</a></code>元素(尽管里面还没有任何东西):</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="266c" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// defining the price chart </strong><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox" rel="noopener ugc nofollow" target="_blank"><strong class="ne iu">viewBox</strong></a><strong class="ne iu"> dimensions</strong></span><span id="f380" class="ny kv it ne b gy ot oq l or os">&lt;svg<br/>   ae nf" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>   <strong class="ne iu">viewBox="0 0 287 100"<br/></strong>&gt;<br/>   ...<br/>&lt;/svg&gt;</span></pre><p id="1a42" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在，让我们继续定义构成线图本身的元素以及这条线下面的阴影区域。</p><h2 id="2c48" class="ny kv it bd kw nz oa dn la ob oc dp le lv od oe lg lz of og li md oh oi lk oj bi translated">SVG元素:折线和多边形</h2><p id="6d9b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们价格图表的线条是一个强制元素，通过<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline" rel="noopener ugc nofollow" target="_blank">polyline</a></code> SVG元素实现。<code class="fe nb nc nd ne b">polyline</code>是一个基本形状，它通过一个<code class="fe nb nc nd ne b">points</code>属性连接几个坐标来创建直线:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="da19" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// polyline drawing a zig-zag line</strong></span><span id="ba5d" class="ny kv it ne b gy ot oq l or os">&lt;svg ...&gt;<br/>  &lt;polyline <strong class="ne iu">points</strong>="0,0 25,50 50,0 75,50 100,0" /&gt;<br/>&lt;/svg&gt;</span></pre><p id="f322" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated"><code class="fe nb nc nd ne b">polyline</code>下方的阴影区域是通过<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon" rel="noopener ugc nofollow" target="_blank">polygon</a></code>元素实现的。A <code class="fe nb nc nd ne b">polygon</code>定义了由一组相连的直线段组成的闭合形状。像<code class="fe nb nc nd ne b">polyline</code>一样，<code class="fe nb nc nd ne b">polygon</code>也接受一系列定义形状的点:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="ccc9" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// polygon drawing a square</strong></span><span id="6d7e" class="ny kv it ne b gy ot oq l or os">&lt;svg ...&gt;<br/>  &lt;polygon <strong class="ne iu">points</strong>="0,0 100,0 100,100 0,100" /&gt;<br/>&lt;/svg&gt;</span></pre><p id="3f02" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">将这些形状组合在一起就是一个美观的价格图表所需要的。考虑下面的插图，看看<code class="fe nb nc nd ne b">polyline</code>和<code class="fe nb nc nd ne b">polygon</code>如何共同赋予价格图表一些个性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/8c0e63e5d6f219aa8b60533935e8485b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prIC3MAYOuIebFjItz-5YA.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">SVG由两个元素组成:a <polyline/>和<polygon/></p></figure><p id="3779" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们只需要担心<code class="fe nb nc nd ne b">polyline</code>的<code class="fe nb nc nd ne b">stroke</code>颜色和<code class="fe nb nc nd ne b">polygon</code>的<code class="fe nb nc nd ne b">fill</code>颜色。这些都可以通过CSS来实现，这将在下面进一步讨论。</p><p id="1378" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">你可以把<code class="fe nb nc nd ne b">polygon</code>想象成一个盒子，它上面有一大堆点，准备好与线条本身进行相同的运动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/5be1f83d0b8b57114408d573255f294a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-GCcyFlWRLUG7Y2cjxMxA.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">只有我们<polygon/>的顶行被操纵</p></figure><p id="7447" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">考虑到这一点，我们现在可以对上一节的<code class="fe nb nc nd ne b">svg</code>进行一点更新，添加这两个元素:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="511e" class="ny kv it ne b gy op oq l or os">&lt;svg<br/>   ae nf" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>   viewBox="0 0 287 100"<strong class="ne iu"><br/></strong>&gt;<br/>  &lt;polygon<br/>    <strong class="ne iu">points</strong>={`${...} 287,100 0,100}<br/>  /&gt;<br/>  &lt;polyline<br/>    <strong class="ne iu">points</strong>={`${...}}<br/>   /&gt;<br/>&lt;/svg&gt;</span></pre><p id="f6ef" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在我们有所进展，但是现在需要提供<code class="fe nb nc nd ne b">points</code>道具来定义形状。</p><p id="4977" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在，我已经添加了空字符串文字，并添加了<code class="fe nb nc nd ne b">polygon</code>元素的底部点——记住，我们只需要定义该形状的顶部线条来匹配<code class="fe nb nc nd ne b">polyline</code>移动。</p><h2 id="ff05" class="ny kv it bd kw nz oa dn la ob oc dp le lv od oe lg lz of og li md oh oi lk oj bi translated">SVG作为React组件</h2><p id="2237" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个难题的最后一部分是实现一个React组件，它将接受一个<code class="fe nb nc nd ne b">points</code>prop——一个坐标数组——并将它们作为点放在SVG元素中。</p><p id="3ced" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">首先，让我们考虑如何格式化这些坐标。它们将是数组，每个点提供一个<code class="fe nb nc nd ne b">x</code>和<code class="fe nb nc nd ne b">y</code>值。这里我们不假设任何格式规则，比如在<code class="fe nb nc nd ne b">polyline</code>和<code class="fe nb nc nd ne b">polygon</code>元素中分隔每个点的x和y坐标的逗号——我们将在组件本身中处理格式。</p><p id="b3fd" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在让我们只导入带有虚拟数据的普通值。这可能是如何做到的:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="4131" class="ny kv it ne b gy op oq l or os">import { PriceChart } from './PriceChart';</span><span id="b197" class="ny kv it ne b gy ot oq l or os">const MyComponent = () =&gt; (<br/>  <strong class="ne iu">&lt;PriceChart</strong><br/>    <strong class="ne iu">points</strong>={[[0,50],[1,51],[2, 50.5],[3,56],[4,50] ... [287,78]]}<br/>  <strong class="ne iu">/&gt;</strong><br/>);</span></pre><p id="bd9b" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们提供了一个数组的数组，每个数组都有一个<code class="fe nb nc nd ne b">x</code>和<code class="fe nb nc nd ne b">y</code>坐标。<code class="fe nb nc nd ne b">x</code>值始于<code class="fe nb nc nd ne b">0</code>——图表的左侧——并逐点通过。<code class="fe nb nc nd ne b">y</code>值是我们在<code class="fe nb nc nd ne b">0</code>和<code class="fe nb nc nd ne b">100</code>之间的标准化价格，其范围我们之前已经确定。</p><p id="ef21" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在API级别，<code class="fe nb nc nd ne b">x</code>坐标的计算非常简单。在返回完整的坐标序列之前，您可以循环遍历您的<code class="fe nb nc nd ne b">y</code>坐标并增加一个初始化为0的计数器。另一个解决方案是简单地返回标准化价格，并增加前端的<code class="fe nb nc nd ne b">x</code>坐标。</p><p id="6165" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这就剩下我们的<code class="fe nb nc nd ne b">&lt;PriceChart /&gt;</code>组件来绘制这些点了。让我们把它们取出来，并以我们的SVG元素能够理解的方式进行格式化:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="72f6" class="ny kv it ne b gy op oq l or os">export const PriceChart = (props) =&gt; (<br/>  &lt;svg...&gt;<br/>    &lt;polygon<br/>      points={`${<strong class="ne iu">props.points.map(p =&gt; <br/>                 ' ' + p[0] + ',' + p[1]<br/>                )</strong>} 287,100 0,100`<br/>             }<br/>    /&gt;<br/>    &lt;polyline<br/>      points={`<strong class="ne iu">${props.points.map(p =&gt; <br/>                 ' ' + p[0] + ',' + p[1]</strong><br/>                <strong class="ne iu">)</strong>}`<br/>             }<br/>    /&gt;<br/>  &lt;/svg&gt;<br/>);</span></pre><p id="a4e1" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们的<code class="fe nb nc nd ne b">&lt;PriceChart /&gt;</code>功能组件现在返回完整的SVG。它在JSX级别绘制出<code class="fe nb nc nd ne b">points</code>道具，将每个点作为<code class="fe nb nc nd ne b">p</code>并以<code class="fe nb nc nd ne b">x,y</code>的格式返回一个格式化的坐标，同时还在每个点之间添加一个空格。每个<code class="fe nb nc nd ne b">p</code>点的索引<code class="fe nb nc nd ne b">0</code>是我们的<code class="fe nb nc nd ne b">x</code>坐标，而索引<code class="fe nb nc nd ne b">1</code>是我们的<code class="fe nb nc nd ne b">y</code>坐标。</p><p id="e1a5" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在通过样式化组件添加了一些CSS之后，我们完成的组件类似于下面的Github要点。下面是完整的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="ec54" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">就样式而言，我们将SVG本身包装在一个我们称之为<code class="fe nb nc nd ne b">Wrapper</code>的样式<code class="fe nb nc nd ne b">div</code>中。</p><p id="832b" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们已经确保包含的<code class="fe nb nc nd ne b">svg</code>元素保持了<code class="fe nb nc nd ne b">Wrapper</code>的全宽，并且还分别为<code class="fe nb nc nd ne b">polyline</code>和<code class="fe nb nc nd ne b">polygon</code>定义了<code class="fe nb nc nd ne b">stroke</code>和<code class="fe nb nc nd ne b">fill</code>属性。<code class="fe nb nc nd ne b">Wrapper</code>自身坚持其包含元素的维度；很有可能我们将把<code class="fe nb nc nd ne b">&lt;PriceChart /&gt;</code>嵌入到另一个包含组件中，所以我们希望回到那些维度。</p><p id="2654" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">好了，现在我们的组件已经出来了，让我们最终探索JavaScript中的价格规范化过程。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="e02f" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">使一组价格数据正常化</h1><p id="b7c5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本节专门介绍如何将一系列价格，例如:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="f2aa" class="ny kv it ne b gy op oq l or os">const prices = [<br/>  961.7442,<br/>  8963.1259,<br/>  8961.5466,<br/>  8959.3715,<br/>  8954.2278,<br/>  ...<br/>];</span></pre><p id="afd1" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">…转换成符合我们的SVG的标准化值，SVG的高度为<code class="fe nb nc nd ne b">100px</code>:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="b2e3" class="ny kv it ne b gy op oq l or os">const normalised_prices = [<br/>  12.40342549423265,<br/>  12.111408873991664,<br/>  12.445187442672605,<br/>  12.904885894352674,<br/>  13.991985763740644,<br/>  ...<br/>}</span></pre><p id="236d" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们在这里采用的标准化方法称为<a class="ae nf" href="https://en.wikipedia.org/wiki/Feature_scaling" rel="noopener ugc nofollow" target="_blank">特征缩放</a>。要素缩放取数据集中的最大值和最小值，并在值0和1之间重新缩放整个数据集。我们将很快用JavaScript编写这个等式，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/e880a13b6472cd17dac142969cafed12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szN3JXIswoufGkn59VOgZg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">将数据集归一化到0和1之间的特征比例方程</p></figure><p id="6289" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">为什么要这么做？因为数据，尤其是价格，变化很大。它们是如此的不可预测，以至于我们不可能预测SVG的维度。此外，我们的SVG设计用于处理各种不同价格范围的市场。</p><p id="f79b" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">对一系列值进行标准化是解决这种不可预测性的一个很好的方法。我们已经获得了手头的最低和最高价格。如果您只是将价格放在一个数组中，您可以使用JavaScript的<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min" rel="noopener ugc nofollow" target="_blank">Math.min()</a></code>和<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max" rel="noopener ugc nofollow" target="_blank">Math.max()</a></code>函数来获取这些值:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="a28f" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// getting min and max from an array</strong></span><span id="1f66" class="ny kv it ne b gy ot oq l or os">const min = Math.min(...prices);<br/>const max = Math.max(...prices);</span></pre><p id="99e4" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">如果您正在处理复杂的JSON对象，一个更耗费资源(但语法最少)的解决方案是遍历对象，在计算最小值和最大值之前手动填充一个数组:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="9b3c" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// getting max and min from some JSON API result</strong></span><span id="be6f" class="ny kv it ne b gy ot oq l or os">let prices = [];</span><span id="0283" class="ny kv it ne b gy ot oq l or os">for (let i = 0; i &lt; json.length; i++) {<br/>   prices.push(parseFloat(json[i].marketdata.ask_price));<br/>}</span><span id="73e9" class="ny kv it ne b gy ot oq l or os">const min = Math.min(...prices);<br/>const max = Math.max(...prices);</span></pre><p id="178b" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在上面的例子中，我们从<code class="fe nb nc nd ne b">json[i].marketdata</code>的<code class="fe nb nc nd ne b">ask_price</code>字段获取价格。</p><p id="1f05" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">从这里开始，我们可以遍历每个价格，并应用归一化方程返回一个在<code class="fe nb nc nd ne b">0</code>和<code class="fe nb nc nd ne b">1</code>之间的值:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="a6a1" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// feature scaling equation in Javascript</strong></span><span id="56cd" class="ny kv it ne b gy ot oq l or os">let normalised_price = <br/>   (parseFloat(prices[i]) - min) / (min - max);</span><span id="fd0f" class="ny kv it ne b gy ot oq l or os">if (isNaN(normalised_price)) {<br/>  normalised_price = 0;<br/>}</span></pre><p id="6fa4" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">在JavaScript中，0除以0会得到<code class="fe nb nc nd ne b">NaN</code>，它不是一个浮点数。正因为如此，我已经添加了一个额外的检查与<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN" rel="noopener ugc nofollow" target="_blank">isNan()</a></code>，以覆盖正常化的价格到<code class="fe nb nc nd ne b">0</code>，如果我们有一个不活跃的市场的价格。</p><p id="8947" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">这已经足够好了——我们现在需要将这个范围从0–1增加到0–100，以符合高度为100像素的SVG。为此，我们可以将<code class="fe nb nc nd ne b">normalised_price</code>乘以<code class="fe nb nc nd ne b">100</code>:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="fb9c" class="ny kv it ne b gy op oq l or os">normalised_price = Math.abs(normalised_price * 100);</span></pre><p id="fd64" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们在这里使用了<code class="fe nb nc nd ne b"><a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs" rel="noopener ugc nofollow" target="_blank">Math.abs()</a></code>来确保我们处理的是无符号值。</p><p id="a56c" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">现在肯定一切都很好；我们的值将毫无问题地嵌入到我们的SVG中。嗯——差不多。还有一个问题需要解决:SVG的原点(0，0)在<code class="fe nb nc nd ne b">viewBox</code>的左上角，而不是我们在标准数学中所期望的左下角。</p><p id="5c74" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">正因为如此，我们的价值观目前是颠倒的。非常高的标准化价格90将出现在图表底部附近，而较低的价格5将出现在顶部5个像素处。我们需要添加另一个计算来反转我们的价格:</p><pre class="kj kk kl km gt ol ne om on aw oo bi"><span id="e897" class="ny kv it ne b gy op oq l or os"><strong class="ne iu">// inverting our prices to make up for SVG coordinate system</strong></span><span id="2de7" class="ny kv it ne b gy ot oq l or os">normalised_price = Math.abs(normalised_price - 100);</span></pre><p id="3341" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们只是从正常价格中扣除了100，并删除了负号，确保结果值再次不带符号。有了这个地方，一个正常化的高价格90将转化为<code class="fe nb nc nd ne b">10</code>，一个低价格5将转化为<code class="fe nb nc nd ne b">95</code>——所有这些都与我们的SVG <code class="fe nb nc nd ne b">viewBox</code>设置一致。</p><p id="a029" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">总结整个标准化过程，以下是完整的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="086b" class="ku kv it bd kw kx ns kz la lb nt ld le jz nu ka lg kc nv kd li kf nw kg lk ll bi translated">摘要</h1><p id="32d7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本文探讨了如何利用SVG和React创建实时价格图表，其中的<code class="fe nb nc nd ne b">polygon</code>和<code class="fe nb nc nd ne b">polyline</code>点是通过一个组件prop提供的。</p><p id="6afc" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">该属性传递原始坐标值，不采用SVG期望的任何格式规则。相反，格式化是在映射点数组时在React组件中完成的。</p><p id="2340" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">我们还参观了如何使用特性缩放来计算这些标准化值，理想情况下，这些值将在后端进行计算，并通过API或Websocket提供给React应用程序。</p><h2 id="38d6" class="ny kv it bd kw nz oa dn la ob oc dp le lv od oe lg lz of og li md oh oi lk oj bi translated">更多资源</h2><p id="29a2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">阅读有关Websockets的更多信息，将您的React应用连接到实时数据:</p><div class="oy oz gp gr pa pb"><a href="https://medium.com/@rossbulat/react-managing-websockets-with-redux-and-context-61f9a06c125b" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">React:用Redux和上下文管理Websockets</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">使用React上下文和Redux存储将组件连接到实时Socket.io事件</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><p id="3bd6" class="pw-post-body-paragraph lm ln it lo b lp mn ju lr ls mo jx lu lv mp lx ly lz mq mb mc md mr mf mg mh im bi translated">阅读有关如何在React中制作SVG动画的更多信息:</p><div class="oy oz gp gr pa pb"><a href="https://medium.com/@rossbulat/react-svg-stroke-animation-with-css-explained-c1e8e3d2e206" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">React:解释了CSS的SVG笔画动画</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">和创建带有样式化组件的CSS菜单切换过渡</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp ks pb"/></div></div></a></div></div></div>    
</body>
</html>