<html>
<head>
<title>What’s New in TypeScript 4.7?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.7有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-7-cb9bf618b768?source=collection_archive---------2-----------------------#2022-05-23">https://betterprogramming.pub/whats-new-in-typescript-4-7-cb9bf618b768?source=collection_archive---------2-----------------------#2022-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e2f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NodeJs ESM支持终于来了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd4f66eee67e52f29bd1ae73912f2647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxbKkJbUxeszlqIS2SavCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a193" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打字稿<code class="fe lu lv lw lx b">4.7</code>版本计划于5月24日发布🎉。在一个不那么令人兴奋的TypeScript 4.6版本之后，我们要享受一下了。</p><p id="1725" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">众所周知，该团队专注于NodeJs集成。它对Node上的<code class="fe lu lv lw lx b">ES Modules</code>的支持是一个期待已久的特性。它是打着实验的旗号在<code class="fe lu lv lw lx b">4.5</code>版本上发布的。为什么？许多零碎的东西需要擦亮。秘密发布是开始收集反馈和问题的绝佳方式。</p><p id="a3a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在这个新版本中，NodeJs集成作为一个稳定的特性发布。这不是我唯一感到兴奋的特性。由于它的<code class="fe lu lv lw lx b">moduleSuffixes</code>特性，如果你是React原生开发者，这个版本是非常棒的。</p><p id="945f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将重点介绍最相关的新特性。一如既往，你可以在这里玩新版本<a class="ae ly" href="https://www.typescriptlang.org/play/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="9bff" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Node.js中的ECMAScript模块支持</h1><p id="d9e2" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">Node.js的模块基础一直是CommonJS。随着向多态应用程序的转变，支持ECMAScript模块的呼声越来越高。在过去的几年里，Node.js一直致力于支持这些。从Node 12版本开始，对ES模块的支持已广泛提供。</p><p id="1359" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在有两个新的<code class="fe lu lv lw lx b">module</code>配置设置:<code class="fe lu lv lw lx b">nodenext</code>和<code class="fe lu lv lw lx b">node12</code>。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="c803" class="na ma it lx b gy nb nc l nd ne">{<br/>  "compilerOptions": {<br/>    "module": "nodenext"<br/>  }<br/>}</span></pre><h2 id="becc" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">package.json中的“类型”属性</h2><p id="041c" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">通过<code class="fe lu lv lw lx b">package.json</code>文件，我们现在可以配置节点将用于文件的模块格式。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="94f8" class="na ma it lx b gy nb nc l nd ne">{<br/>    ...<br/>    "name": "my package",<br/>    "type": "module",<br/>    ...<br/>}</span></pre><p id="f26b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有哪些选择？我们可以在用于<code class="fe lu lv lw lx b">ES Modules</code>的<code class="fe lu lv lw lx b">module</code>或用于传统CommonJS模块的<code class="fe lu lv lw lx b">commonjs</code>之间进行选择。</p><p id="3715" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种行为适用于所有不带扩展名的常规JavaScript文件。TypeScript将通过它的<code class="fe lu lv lw lx b">.ts</code>文件包含相同的系统行为。</p><p id="1aaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它在实践中是如何工作的？当编译器找到一个<code class="fe lu lv lw lx b">.ts/.tsx/.js/.jsx</code>时，它会查看最近的<code class="fe lu lv lw lx b">package.json</code>文件来确定它的模块风格。</p><h2 id="4aad" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">通过文件扩展名进行配置</h2><p id="1a7e" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">我们已经看到了默认行为。单个文件如何确定自己的模块系统？只要改变它的文件扩展名。</p><p id="40f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看新的约定:</p><ul class=""><li id="74c5" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><code class="fe lu lv lw lx b">.cjs/.cjx</code>:不管最近的父<code class="fe lu lv lw lx b">"type"</code>配置如何，文件将以CommonJS格式导入。</li><li id="c9a3" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe lu lv lw lx b">.cts/.ctx/.d.cts</code>:文件将以CommonJS格式导入，不考虑父<code class="fe lu lv lw lx b">"type"</code>规格。当输出文件时，它会输出相应的<code class="fe lu lv lw lx b">.</code>，让我们看看现在可以使用什么扩展名:<code class="fe lu lv lw lx b">mjs</code>、<code class="fe lu lv lw lx b">.mjx</code>或带有<code class="fe lu lv lw lx b">.d.cts </code>扩展名的声明。</li><li id="8971" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe lu lv lw lx b">.mjs/.mts/.mtx/d.mts</code>:文件将以ECMAScript模块格式导入，不考虑父<code class="fe lu lv lw lx b">"type"</code>规范。当发出文件时，它将输出其对应的<code class="fe lu lv lw lx b">.mjs</code>、<code class="fe lu lv lw lx b">.mjx</code>或扩展名为<code class="fe lu lv lw lx b">.d.mts</code>的声明。</li></ul><h2 id="1c9e" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">互用性</h2><p id="45d6" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">假设现在您可以通过调优它的文件系统来导入不同的模块类型，那么它们需要协同工作。ES模块很简单，因为它只是一个翻译的问题。对于要导入CommonJS的ES模块，它会将它们视为默认导出。</p><p id="75b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="7f0c" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">package.json中的“exports”属性</h2><p id="2f77" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">我们之前已经看到了如何在<code class="fe lu lv lw lx b">package.json</code>文件中添加一个<code class="fe lu lv lw lx b">type</code>来配置模块默认值。同样，还有一个新的属性可以导出包'<code class="fe lu lv lw lx b">exports</code>。</p><p id="a4d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这个属性，我们就可以微调暴露文件的方式。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5159" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上图中，我们可以看到:</p><ul class=""><li id="465b" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">我们如何定义<code class="fe lu lv lw lx b">ESM</code>或<code class="fe lu lv lw lx b">CommonJS</code>的特定导入</li><li id="74f1" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">我们如何在这些定义中定义特定于类型脚本的定义</li><li id="05c7" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">我们如何为旧版本定义回退</li></ul><h2 id="5edf" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">ES模块集成的收获</h2><p id="9ab8" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">es模块带来了哪些特性？需要注意什么？让我们来看一个摘要列表:</p><ul class=""><li id="379c" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">功能:使用<code class="fe lu lv lw lx b">import/export</code>语句语法</li><li id="92a1" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">特性:顶层等待可用<code class="fe lu lv lw lx b">nodenext</code></li><li id="7d6b" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">互操作:一些像<code class="fe lu lv lw lx b">require</code>这样的全局关键字在ES模块上不起作用</li></ul><h1 id="62c5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">控制模块检测</h1><p id="5ed0" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">在JS生态系统中，文件是一个模块还是一个脚本总是有点模糊。出于这个原因，引入了一个新的编译器选项:<code class="fe lu lv lw lx b">moduleDetection.moduleDetection</code>。它让我们配置如何解析模块。</p><p id="b5d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它可以取这三个值中的一个:</p><h2 id="0121" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">1.汽车</h2><p id="9023" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">这是来自<code class="fe lu lv lw lx b">4.7</code>的新默认值。TypeScript将查找<code class="fe lu lv lw lx b">imports</code>和<code class="fe lu lv lw lx b">exports</code>语句，但也会检查:</p><ul class=""><li id="3880" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">在<code class="fe lu lv lw lx b">package.json</code>中归档的<code class="fe lu lv lw lx b">type</code></li><li id="ed8a" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">如果文件在<code class="fe lu lv lw lx b">--jsx react-jsx</code>下运行</li></ul><h2 id="201f" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">2.遗产</h2><p id="6a14" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">该值的行为与以前的TS版本相同。它查看<code class="fe lu lv lw lx b">import</code>和<code class="fe lu lv lw lx b">exports</code>语句来检查文件是否是模块。</p><h2 id="ed4f" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">3.力</h2><p id="04fb" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">这种模式将强制每个文件被视为一个模块。对于<code class="fe lu lv lw lx b">module</code>、<code class="fe lu lv lw lx b">moduleResolution</code>和<code class="fe lu lv lw lx b">jsx</code>的配置，所有非申报文件将被单独处理。</p><p id="de3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当只针对浏览器时，最好有<code class="fe lu lv lw lx b">moduleDetection: force</code>和<code class="fe lu lv lw lx b">module: esnext</code>。在这种情况下，我们不需要<code class="fe lu lv lw lx b">commonJs</code>模块。</p><h1 id="3556" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">使用<code class="fe lu lv lw lx b">moduleSuffixes</code>进行分辨率定制</h1><p id="7392" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">使用React-Native多态应用程序，我们可以通过更改文件扩展名来选择在每个平台上加载哪个文件。</p><ul class=""><li id="a323" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><code class="fe lu lv lw lx b">index.native.ts</code>:将加载到RN捆扎机中</li><li id="4204" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe lu lv lw lx b">index.ts</code>:将由卷筒纸捆扎机使用</li></ul><p id="7871" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在使用TypeScript时有一个警告。TypeScript编译器不会知道<code class="fe lu lv lw lx b">.native.ts</code>的存在。现在可以通过使用<code class="fe lu lv lw lx b">moduleSuffixes</code>编译选项来实现。</p><pre class="kj kk kl km gt mw lx mx my aw mz bi"><span id="3883" class="na ma it lx b gy nb nc l nd ne">{<br/>    "compilerOptions": {<br/>        "moduleSuffixes": [".ios", ".native", ""]<br/>    }<br/>}</span></pre><p id="8fc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<code class="fe lu lv lw lx b">""</code>需要查看默认的<code class="fe lu lv lw lx b">ts</code>文件。</p><p id="67bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的<code class="fe lu lv lw lx b">React-Native</code>开发者肯定会为这个新特性欢呼雀跃，并争相升级。</p><h1 id="b708" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><em class="og">实例化表达式</em></h1><p id="ea06" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">有时我们想做一些简单的事情，比如从一个通用函数创建一个更具体的函数。目前，这可以通过函数包装器来实现。然而，在这个新的<code class="fe lu lv lw lx b">4.7</code>版本中，我们可以很容易地从通用函数中创建一个别名。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="dec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以像下面这样设置酷类型别名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="015c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个简单而整洁的功能，它将为许多新类型的模式打开大门。</p><h1 id="2aa3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">计算属性的控制流分析</h1><p id="9964" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">此版本中包含了对计算属性的新改进。TypeScript现在将在更广泛的情况下考虑类型保护。</p><p id="37f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c4b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个伟大的事情是<code class="fe lu lv lw lx b">-strictPropertyInitialization</code>将能够包括那些场景检查。</p><h1 id="e262" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包裹</h1><p id="2286" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">综上所述，这是一个伟大的。在<code class="fe lu lv lw lx b">Node</code>中对<code class="fe lu lv lw lx b">ESM</code>模块的支持是一个棘手的问题，很高兴看到它的出现。这并不意味着这个版本没有更多值得喜欢的地方。</p><p id="554b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一些不错的特性，如<code class="fe lu lv lw lx b">groups-aware</code>、组织导入或对象方法片段完成。</p><p id="aec2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h2 id="d5fd" class="na ma it bd mb nf ng dn mf nh ni dp mj lh nj nk ml ll nl nm mn lp nn no mp np bi translated">想多读点？</h2><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/7-typescript-common-mistakes-to-avoid-581c30e514d6"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">要避免的7个打字稿常见错误</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">通过避免这些错误来改进您的TypeScript的代码库</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">better编程. pub</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>