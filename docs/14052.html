<html>
<head>
<title>Implementing Multi-Threaded Shared Memory in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中实现多线程共享内存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/easy-multi-threaded-shared-memory-in-rust-57344e9e8b97?source=collection_archive---------3-----------------------#2022-10-31">https://betterprogramming.pub/easy-multi-threaded-shared-memory-in-rust-57344e9e8b97?source=collection_archive---------3-----------------------#2022-10-31</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="3c6f" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">让共享数据设计模式发挥作用</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/9cc21a040df851b9ba698df14789fe3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OC6GlEDwfqS1xr5f8PgCOQ.jpeg"/></div></div></figure><p id="4fd5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">本文是与在Raspberry Pi上运行的Rust中构建无线恒温器相关的系列文章中的第三篇——尽管这篇文章与Raspberry Pi关系不大，而与任何多线程应用程序更相关。在创建我的应用程序时，我实现了一个简单而有效的设计来控制对共享内存的多线程访问。您可以在这里找到以前的文章:</p><ul class=""><li id="d9b5" class="lo lp ir ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated">第一篇，<a class="ae lx" href="https://medium.com/p/45a5d35196cf" rel="noopener">树莓皮无线温控器在生锈</a></li><li id="688e" class="lo lp ir ku b kv ly ky lz lb ma lf mb lj mc ln lt lu lv lw bi translated">第二个，<a class="ae lx" href="https://medium.com/p/e30fcb233fef" rel="noopener">横编立易</a>。</li></ul><p id="043f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">下面我也有一些代码片段，但是你可以在<a class="ae lx" href="https://github.com/mikehentges/thermostat-pi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的代码库。</p><h1 id="5b78" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">首先，背景故事</h1><p id="e0f4" class="pw-post-body-paragraph ks kt ir ku b kv mv js kx ky mw jv la lb mx ld le lf my lh li lj mz ll lm ln ik bi translated">设计多线程应用程序时，一个核心考虑因素是不同的线程如何共享数据。总有一些东西是线程共享的——毕竟，您正在剥离线程来处理一个共享的问题。如果没有别的，配置数据或数据库连接池必须共享。解决这个问题有两种主要方法:</p><ol class=""><li id="0eee" class="lo lp ir ku b kv kw ky kz lb lq lf lr lj ls ln na lu lv lw bi translated">消息传递——线程之间的通道允许在它们之间发送和接收数据。消息传递是Golang更喜欢的机制，正如Golang文档所述:“不要通过共享内存进行通信；而是通过交流来分享记忆。”Rust支持创建通道；你可以在Rust Book关于<a class="ae lx" href="https://doc.rust-lang.org/book/ch16-02-message-passing.html" rel="noopener ugc nofollow" target="_blank">消息传递</a>的章节中找到更多信息。</li><li id="3cdd" class="lo lp ir ku b kv ly ky lz lb ma lf mb lj mc ln na lu lv lw bi translated">共享状态—标识为共享状态的一组数据。每个线程通过线程安全保护机制访问一个共享数据区——通常是一个<code class="fe nb nc nd ne b">Mutex</code>。数据上的锁允许您安全地访问数据，根据需要读取或更新数据，然后锁被释放。一次只有一个线程可以读取或写入数据。Rust Book的<a class="ae lx" href="https://doc.rust-lang.org/book/ch16-03-shared-state.html" rel="noopener ugc nofollow" target="_blank">共享状态</a>部分描述了这些机制。</li></ol><p id="a430" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这两种方法都有效，Rust在标准库中对这两种机制都有很好的支持。要在它们之间进行选择，请考虑以下因素:</p><ol class=""><li id="07ea" class="lo lp ir ku b kv kw ky kz lb lq lf lr lj ls ln na lu lv lw bi translated">访问模式是什么？线程会主要读数据，主要写数据，还是两者都有？</li><li id="1530" class="lo lp ir ku b kv ly ky lz lb ma lf mb lj mc ln na lu lv lw bi translated">如何避免死锁？避免死锁是多线程应用程序的主要关注点——没有什么比有一堆线程可用来工作更糟糕的了，它们都被困在等待其他线程离开。</li><li id="cae3" class="lo lp ir ku b kv ly ky lz lb ma lf mb lj mc ln na lu lv lw bi translated">性能。虽然为了性能而过度设计是一种常见的错误，但是对您的解决方案的性能需求有一些了解是非常重要的。我是这条规则的忠实粉丝:让解决方案尽可能简单，但不要再简单了。</li></ol><p id="f068" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我决定为我正在创建的应用程序使用共享状态方法。这个决定还意味着我的工作线程将通过轮询工作——定期检查，而不是接收外部消息。这是让我得出这个结论的原因:</p><ol class=""><li id="e2b2" class="lo lp ir ku b kv kw ky kz lb lq lf lr lj ls ln na lu lv lw bi translated">我有三条主线。一个是web界面，允许读/写共享状态(获取温度、获取恒温器设置、设置恒温器设置)。根据定义，web界面是计划外活动的创建者——事情的发生基于外部客户端的动作，不受应用程序的控制。第二，一对后台工作线程对应用程序的环境做出反应。第一个读取温度传感器，第二个计算恒温器是否应该打开或关闭，并控制物理继电器来实现这一点。恒温器在一个单独的线程中，因为当温度超过阈值或者我们从web界面接收到新的恒温器设置时，它可以打开/关闭。</li><li id="8624" class="lo lp ir ku b kv ly ky lz lb ma lf mb lj mc ln na lu lv lw bi translated">我不必担心只有三个线程的争用(假设web界面上只有一个外部客户机)。简单的共享状态方法不会遇到太多线程试图同时访问锁的问题。</li><li id="fded" class="lo lp ir ku b kv ly ky lz lb ma lf mb lj mc ln na lu lv lw bi translated">用于确定恒温器状态的逻辑具有时间成分。我们不希望频繁、短暂的开关，这将冲击熔炉。在切换到另一个状态之前，我们强制规定恒温器打开或关闭的最短时间。准确地对一个信息(温度读数或恒温器数值的变化)做出反应需要知道恒温器变化后有多长时间了。</li></ol><p id="7911" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">基于这些需求，共享状态是有意义的。我的设计强制执行低线程数，所以争用不是问题(共享状态方法的常见问题)。我需要记录时间，所以总是需要一些状态数据。在同一应用程序中实现两种不同的状态数据机制会增加复杂性。由于每个线程都做自己的事情，并独立地获取/设置共享状态，我们将每个线程与其他线程隔离开来。这一选择导致了更简单的整体应用程序设计。</p><p id="73f7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">但是，当我在<a class="ae lx" href="https://doc.rust-lang.org/book/ch16-03-shared-state.html" rel="noopener ugc nofollow" target="_blank">共享状态</a>、<br/>上查看Rust Book的内容时，管理每个线程的访问的复杂性似乎令人生畏。另外，在应用程序中散布线程锁定代码使它变得一团糟——我的好的单一用途函数现在有了互斥锁定逻辑。此外，当通过<code class="fe nb nc nd ne b">Mutex</code>锁访问数据时，跨线程处理Rust的借用检查器被证明是具有挑战性的。</p><h1 id="388b" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">更简单的方法</h1><p id="f8e3" class="pw-post-body-paragraph ks kt ir ku b kv mv js kx ky mw jv la lb mx ld le lf my lh li lj mz ll lm ln ik bi translated">为了便于管理，我使用了以前在C++项目中使用过的方法——将共享数据封装到一个单独的类中，并将所有的<code class="fe nb nc nd ne b">Mutex</code>逻辑推送到该类中。Rust没有类，但是一些结构做到了。</p><p id="cdd8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我创建了一个结构，将所有共享的状态数据保存在一个地方。然后我可以处理对这个结构的单个引用，而不是单独管理每个数据元素。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="390f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后我们定义一个包含一个<code class="fe nb nc nd ne b">Arc</code>指针的结构，这个指针是一个指向保护我们共享数据结构的<code class="fe nb nc nd ne b">Mutex</code>的原子引用计数指针。我们使用这个结构来控制对共享数据的访问。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="d1d8" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们将制作这个指针的许多副本——它们都指向我们的互斥体，这是我们获得共享内存空间的方法。我们通过为<code class="fe nb nc nd ne b">AccessSharedData </code>定制<code class="fe nb nc nd ne b">Clone()</code>方法来做到这一点——看起来如下:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="be12" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为了使用它，我们首先创建我们的<code class="fe nb nc nd ne b">SharedData</code>结构的一个实例(上面没有显示简单的<code class="fe nb nc nd ne b">.new()</code>方法，但是很简单)。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="cf29" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后，我们初始化一个<code class="fe nb nc nd ne b">AccessSharedData</code>的实例。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="1efe" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然后我们给每个线程一个<code class="fe nb nc nd ne b">spawn()</code>结构的克隆副本。克隆调用创建了一个<code class="fe nb nc nd ne b">Arc</code>指针的副本，然后我们将它移动到新线程中。一个类似的方法将一个<code class="fe nb nc nd ne b">AccessSharedData</code>结构的克隆传递给actix_web <code class="fe nb nc nd ne b">HttpServer::new()</code>方法，因此它在HTTP客户端处理程序中也是可用的。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="d0fe" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在每个人都有了一个<code class="fe nb nc nd ne b">Arc</code>指针的副本，我们需要创建一个方法来使用它读/写我们的共享数据结构。我们的结构的每个成员都有一组简单的getter/setter来处理获取锁、获取/设置数据以及自动释放锁的任务。通过将这个逻辑放在get/set周围，并利用方法的结尾作为范围边界来强制释放锁，我们获得了对数据访问的控制。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="501f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">当每个get/set函数返回时，锁被释放。这种方法还意味着对结构的访问不可能出现死锁——所有东西都被锁定并立即释放，并禁止任何其他东西挡路。有了所有的锁定机制，在应用程序的其余部分使用共享数据就变得简单了。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nf ng l"/></div></figure><h1 id="2ce5" class="md me ir bd mf mg mh mi mj mk ml mm mn jx mo jy mp ka mq kb mr kd ms ke mt mu bi translated">概括起来</h1><p id="7de6" class="pw-post-body-paragraph ks kt ir ku b kv mv js kx ky mw jv la lb mx ld le lf my lh li lj mz ll lm ln ik bi translated">这种策略是封装的最好体现。应用程序代码使用对方法的直接调用，在需要时获取/设置共享数据元素。在幕后，我们管理互斥体的锁定，使该访问是线程安全的，并且不会出现死锁。Rust的借用检查器非常高兴我们不允许对共享数据的直接共享可变引用。您可以很容易地扩展这种设计模式来实现更健壮的访问模式。</p><p id="75ef" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">将锁定逻辑放在getter/setter中使我们的共享数据结构能够隐藏多线程访问的复杂性——就像标准库对线程安全集合所做的那样。使用Arc的克隆使得在每个线程中获得共享内存结构的句柄成为可能。这两个概念是使我们的易共享数据设计模式工作的核心思想。</p></div></div>    
</body>
</html>