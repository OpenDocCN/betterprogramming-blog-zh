# 从α到ω的泛函 JS:forEach

> 原文：<https://betterprogramming.pub/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1>

## [α]使用 forEach 作为跳板来理解函数式编程

> 我们通过构建适当隐藏细节的抽象来控制复杂性。
> 
> –SICP，1979 年

![](img/c7ba18dd5490d0267c334e947ef502f9.png)

JR Korpa 在 [Unsplash](https://unsplash.com/search/photos/programming?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText&source=post_page---------------------------) 上拍摄的

> 我们 JavaScript 编码人员有机会实践一种支持函数式编程的多范例语言。
> 
> 你想学习那种力量吗？
> 
> 让我们从 24 课开始，从α到ω，解决我们的日常问题。课程概述: [α。forEach](https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1) ， [β。地图](https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3)，γ.滤镜。

# 简单的列表迭代

考虑以下数据:字符串列表。

JavaScript 不是强类型的，所以大于 *langs* 的集合可能会有问题。让我们假装关心，迭代它，并检查控制台，看看我们得到了什么。

从我们开始编程的第一天起，我们就学会了如何做到这一点。

对我们来说，它看起来像是非常易懂的代码。但真的是这样吗？

这是一种*命令式* 方法，因为它描述了计算机应该如何迭代，而不是人类如何思考迭代。

它不像一个`if`和一个`goto`结合在一起那么必要，但仍然如此。

而且这段代码还包含其他几个固有的缺陷:

*   它不可重用/不干燥(我们必须为每个类似的情况重写所有这些)。
*   不可分解，不可重组，因为它是一个程序代码块
*   不容易维护:错别字可以藏在这里，如果在循环过程中有什么东西改变了 *i* 的值怎么办？这可能会导致错误。
*   扩展性不好，因为嵌套的`for`循环让程序员抓狂

# 句法糖

感谢编码器友好的 ES6，我们现在有一些语法上的好处来编写它，而不用声明一个额外的变量作为计数器。

好吧，这更像是*声明性的*:一个非程序员可能理解这段代码，只是从左到右阅读。

可维护性和可伸缩性也有所提高……但仅限于较低的复杂程度。

# 古老而珍贵

在 ES6 之前五年，JavaScript 就已经指定了一个有用的工具:`forEach`。

`forEach`不是本机控制结构，也不是保留关键字。这是一个数组方法，可以通过任何数组执行，甚至是空数组。

前面的例子会导致错误，因为`forEach`有一个参数。

但不是简单随机的参数:它把一个函数作为参数。

记住在 JS 中，函数是一等公民。

这并不意味着函数是特殊的——事实上，正相反。在 JS 中，函数就像所有其他的值(objects，或 primitives boolean，number & string):我们可以把它们放在变量中，组合它们，作为参数传递它们，返回它们，等等。(在 Haskell 中，甚至像`+`这样的操作符也可以作为参数传递！)

`forEach` 就是函数式程序员所说的*高阶函数*。也没什么复杂的；它只是一个负责运行或返回其他函数的函数。

所以`forEach` 不是魔法；它采用一个声明的函数(未执行！)，但署名如下:`(any) -> void`。它会将这个给定的函数连续应用到数组中的每个元素。

这个`any` 参数代表在迭代中替换当前元素，而`void` 告诉我们这个函数不应该返回任何东西。

前面的代码只是为数组中的每种语言弹出一个警告“hi <language>”。所以现在我们可以用我们所知道的来解决我们的问题。</language>

但是等等。

`console.log`是函数吗？是的。

`console.log` 有`(any) -> void`签名吗？算是吧。

那么两者之间有什么区别呢

简单地说

?

看不出任何区别:包裹功能只是噪音污染，所以…⁴

哦…是的…听起来很奇怪，但是…某种程度上更清楚。

难道是… **那个**？我们现在在做真正的 FP 吗？

不是，只是这个“从 A 到ω”系列的#A。真实的 FP 世界是非常严格的，因为它倾向于只允许可证明的程序和受控的副作用。如果你想达到这个理想，你必须遵循一些规则。

# 纯函数和不变性

如果后面的都不明白，也不要慌。我们将一集一集地深入探讨这一切。试着熟悉一下内容就好了。

你还记得我们可以传递给`forEach`方法的函数的签名吗？是一个不返回任何东西的函数(JS 中所谓的“未定义”)，或者是类型化世界中的`void` 。而`forEach` 本身也是一个返回`undefined` 的方法。

这是带有副作用的函数的明显症状。如果它没有返回任何东西，那么它应该在 return 语句之前，在其他地方做一些影响程序的事情。比如改变某个全局变量的值，或者改变数组本身。

总有一天我们会忘记的事情。而且肯定会导致 bug。总之，它不受控制，而函数式程序员是控制狂。他们总是想知道自己在做什么，甚至想知道为什么。

`forEach` 比`for` *…* `of`更具组合性，因为它采用了自定义函数，但仍然深深地束缚在数组中。我们不能轻易地将`forEach`本身传递给另一个函数。

反正可组合性和可伸缩性也达不到。

所以我们已经知道，如果我们真的想进入 FP 的世界，我们必须定义我们自己的`forEach`。

让我们简单地从在一个全新的函数中隐藏实现细节开始:

但是…！这是绝对必要的！你骗了我们，叛徒！

Mmmh，我从没说过原生`Array.prototype.forEach` JS 方法是怎么实现的。

是的，也许我因疏忽而撒谎了。但是我们现在有了自己的`forEach`，一旦它完全写好了，我们就再也不会钻研这个函数了。它将是有史以来最完美的`forEach` ，我们将在 30 年内照原样使用它。函数只是隐藏命令性的细节，给我们一个声明性的工具。

没有人指望你忘记你在计算机科学中已经学过的所有知识，恰恰相反！

即便如此，也有一种不使用`for`进行迭代的方法。这叫做递归，但那是以后的事，没有 TCO 它会导致新的问题。⁵

如果你想第一时间看到它，这里有一个例子。

让我们完成我们的现实世界`forEach`，做一个*纯函数*。我们稍后会发现它到底是什么。但是现在，只要记住一个纯粹的函数:

*   应该返回一些东西
*   不应修改其范围之外的任何内容，即使是作为 arguments⁶给出的参考

哇哦。这个`forEach`在我看来确实更好，用来发现和消灭副作用。

但是，它显然没有完全解决我们的可维护性/可伸缩性问题。

最近有个朋友想就 FP 争论一下。他了解关于纯功能需求的一切(控制、TDD、可重用性等。)，但他对不变性的要求感到遗憾。我来问一个问题:如果所有的函数都是纯函数，你的程序只由那些函数组成，你什么时候会面临任何可变性需求？从来没有。纯函数，又名*参照透明*，只是从另一个角度看，和不变性是同一个概念。

# Currying

所以让我们从 FP 世界调用另一个有用的工具:currying。

因为我们说过函数是一等公民(就像任何其他值一样)，所以我们知道函数可以返回一个函数，并将父变量值包含在其中。

所以我们最终可以编写一个非常可重用和可组合的`forEach`:

注意`forEach` 参数的新顺序:

*   `func`，这将部分适用
*   然后是阵`arr`

这种新秩序允许我们创造和重用`logEach` 甚至`doubleAndLogEach`。在未来，它将帮助我们用其他功能编写/管道`forEach` 。

由于在 JavaScript 中，对象是通过 reference⁶传递的，所以我们的`forEach` 仍然有一个很大的缺陷:包含对象的数组仍然暴露在突变中。

JavaScript 既不是静态的，也不是强类型的，所以我们可以不断地将不纯的函数甚至坏的数据类型传递给我们的`forEach`(对于那个特殊的问题，使用类似于 [TypeScript](https://www.typescriptlang.org/) 或 [Elm](https://elm-lang.org/) 的替代方法可能是唯一的选择)。

所以我们没有达到承诺的完美:你能在评论中提出你的完美`forEach`吗？

最后一句话，只是为了让你生气。你可能在阅读这篇文章的时候已经发现了:`forEach`的概念本身并不是面向 FP 的。在它自己的定义中确实暗示了副作用。这就是为什么我们的神圣三位一体不会包含`forEach`，而只有`map`、`filter`、**、**和`reduce`，这一点你会在接下来的文章中看到。

感谢您的宝贵时间！

[ ]:事实上，它可以选择接受第二个参数:一个用于`this`的上下文值。

【】:真正的更像`(any, number, any[]) -> void`，其中数字隐式为当前索引，其中`any[]` 为调用数组。例如，如果您需要知道当前元素是否是数组中的最后一个元素，这些其他参数可能会很有用。

[ ]:除了真正的`console.log`签名接受无限数量的可选参数，用逗号分隔，然后返回 false `(any, …any[]) -> false`。

[⁴]:事实上，由于签名的不同， *console.log* 只会显示更多(参见[ ]和[ ]并跳到结论^^).

【⁵]:尾调用优化的先决条件是使用递归来代替`for` 循环。使用递归，调用栈可能会增长太多，直到结束用例，而调用栈是有限的。JavaScript 中不存在 TCO(除了在 Node 6 中)，所以我们暂时被这些循环卡住了。

[⁶]:在 JavaScript 中，对象(包括数组)总是通过引用共享，从不复制。如果你对此感到不确定，你必须花些时间去探索。