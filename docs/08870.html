<html>
<head>
<title>Master Destructuring in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的主析构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/master-destructuring-in-javascript-6871d1fe5f6c?source=collection_archive---------9-----------------------#2021-06-21">https://betterprogramming.pub/master-destructuring-in-javascript-6871d1fe5f6c?source=collection_archive---------9-----------------------#2021-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c79e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习关于在ES6中析构数组和对象的所有知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f397ee66d1cec6c7813201ccc074bf97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lW1gehXaBlVYDl_cGftKPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><h1 id="6c0e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">从ES5迁移到ES6</h1><p id="a8f0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对象和数组析构是我们已经使用了一段时间的东西。我们可能认为这是理所当然的，因为在ES5中，当我们想要将对象属性赋给外部变量时，我们需要这样做:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="4b7f" class="mo kw iq mk b gy mp mq l mr ms">function foo(){<br/>    return {a:1, b:2, c:3};<br/>}</span><span id="ad43" class="mo kw iq mk b gy mt mq l mr ms">var tmp = foo(), a = tmp.a, b = tmp.b, c = tmp.c;</span></pre><p id="ac73" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">我们必须调用函数，然后将属性值赋给新变量。</p><p id="854a" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">随着ES6的出现，我们可以使用析构来简化它。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="a61b" class="mo kw iq mk b gy mp mq l mr ms">var { a, b, c } = foo();</span><span id="ddc3" class="mo kw iq mk b gy mt mq l mr ms">console.log( a, b, c ); // 1 2 3</span></pre><p id="f1a5" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">不需要临时变量，我们可以简单地调用函数，通过一些新的语法，我们能够立即捕获对象的属性值。当然，这也以同样的方式适用于数组:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="7337" class="mo kw iq mk b gy mp mq l mr ms">function foo() {<br/>    return [1,2,3];<br/>}</span><span id="5387" class="mo kw iq mk b gy mt mq l mr ms">var [a, b, c] = foo();</span><span id="bf7c" class="mo kw iq mk b gy mt mq l mr ms">console.log( a, b, c ); // 1 2 3</span></pre><p id="5b35" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">既然我们已经掌握了基础知识，让我们看看如何最大限度地利用析构。</p><h2 id="35e5" class="mo kw iq bd kx mz na dn lb nb nc dp lf lw nd ne lh ma nf ng lj me nh ni ll nj bi translated">值-&gt;目标</h2><p id="3197" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当析构的时候，你必须明白到底发生了什么。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="dc48" class="mo kw iq mk b gy mp mq l mr ms">var { a, b, c } = foo();<br/>console.log(a, b, c); // 1 2 3</span><span id="585c" class="mo kw iq mk b gy mt mq l mr ms"><br/>var { a:a, b:b, c:c } = foo();<br/>console.log(a, b, c); // 1 2 3</span></pre><p id="062c" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">这两种析构方式是相同的。我们可以把它改写成这样:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="9dc3" class="mo kw iq mk b gy mp mq l mr ms">var { a:x, b:y, c:z } = foo();<br/>console.log(x, y, z); // 1 2 3</span></pre><p id="7942" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">当我们声明新对象时，我们这样定义它们:<code class="fe nk nl nm mk b">var o = { a: 1 };</code>。这里<code class="fe nk nl nm mk b">a</code>是我们的目标变量，1是我们分配给该目标的值<em class="nn"> </em>。对于析构来说，情况正好相反:<code class="fe nk nl nm mk b">x</code>是我们的目标，<code class="fe nk nl nm mk b">a</code>变成了我们赋予目标<em class="nn"> </em>的值。因此，解构对象被写成“值:目标”，而不是“目标:值”了解这一点将使我们更好地理解下面几节中的析构语句。</p><h2 id="8d71" class="mo kw iq bd kx mz na dn lb nb nc dp lf lw nd ne lh ma nf ng lj me nh ni ll nj bi translated">默认值</h2><p id="938e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有时候你要析构的对象没有特定的字段。相反，您可能希望给该字段一个特定的值。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="ee4f" class="mo kw iq mk b gy mp mq l mr ms">var { blogId, blogText, blogComments = [] } = getMostRecentBlog();</span></pre><p id="fc11" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">在上面的例子中，如果博客上没有可用的评论，我们将总是析构，以便<code class="fe nk nl nm mk b">blogComments</code>有一个空数组。这在React中很有用，在React中，您可能只想通过调用map函数来呈现列表，而不必确保它不是未定义的！</p><p id="d459" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">我们甚至可以更进一步，例如:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="f641" class="mo kw iq mk b gy mp mq l mr ms">var a = 100, b = 200, c = 300;<br/>var dummyObject = { a : { b : 400}, b : { c : a } };</span><span id="58db" class="mo kw iq mk b gy mt mq l mr ms">( { a: a = { b: b } } = dummyObject );<br/>( { b: c = { b: c } } = dummyObject );<br/>( { c: b = { b: c } } = dummyObject );</span></pre><p id="0001" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">你能算出<code class="fe nk nl nm mk b">a</code>、<code class="fe nk nl nm mk b">b</code>和<code class="fe nk nl nm mk b">c</code>的最终值吗？这个例子表明，有时候析构对于下一个读者来说可能很难理解。重要的是要认识到，析构是为了让一切更具可读性而创建的。然而，在这里，我们可能会说它不是。你是否会在你的代码中使用这样的东西是由你决定的。</p><p id="e988" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">另外，注意析构模式周围的<code class="fe nk nl nm mk b">( .. )</code>。这是必要的，因为否则，花括号会被错误地认为是块语句的开始，而不是对象的开始。</p><p id="51ca" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">如果你花时间计算这些值，结果是<code class="fe nk nl nm mk b">a</code> = <code class="fe nk nl nm mk b">{b: 400}</code>、<code class="fe nk nl nm mk b">b </code> = <code class="fe nk nl nm mk b">{b:{c: 100}}</code>和<code class="fe nk nl nm mk b">c</code> = <code class="fe nk nl nm mk b">{c: 100}</code>。</p><h2 id="42be" class="mo kw iq bd kx mz na dn lb nb nc dp lf lw nd ne lh ma nf ng lj me nh ni ll nj bi translated">未分配的值</h2><p id="b8f2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当我们使用默认值时，是因为我们想确保我们要析构的对象总是返回一个属性值。然而，有时有一些我们不想捕捉其值的属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1ee6" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">如你所见，可以将对象分解成更少的赋值。这让我们可以过滤掉我们不需要的数据。注意，对于数组，我们必须使用逗号来跳过一个元素。</p><p id="1778" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">我们还可以在数组中使用spread运算符来捕获子数组。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="9214" class="mo kw iq mk b gy mp mq l mr ms">var dummyArray = [ 1, 2, 3, 4, 5 ];<br/>var [a, ...b, c] = dummyArray;<br/>console.log(a, b, c); // 1 [2, 3, 4] 5</span></pre><p id="c2c5" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">使用spread操作符，我们能够捕获第一个、最后一个以及中间的所有元素。</p><h2 id="f212" class="mo kw iq bd kx mz na dn lb nb nc dp lf lw nd ne lh ma nf ng lj me nh ni ll nj bi translated">交换变量</h2><p id="9bf1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">析构的许多用途之一是变量的交换。大多数时候，当开发人员需要交换变量时，他们会将其中一个值赋给一个临时变量，然后复制这些值。有了析构，我们可以更容易地做到这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="09bf" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">这是你工具箱里的一个不错的小工具。有一天，我们可能会看到这种情况出现在新的语言中。</p><h2 id="44ea" class="mo kw iq bd kx mz na dn lb nb nc dp lf lw nd ne lh ma nf ng lj me nh ni ll nj bi translated">链接分配</h2><p id="6437" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当析构一个对象时，一个赋值链总是拥有我们要析构的对象/数组的全部值。考虑一下这个:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="785c" class="mo kw iq mk b gy mp mq l mr ms">var arr = [ 1, 2, 3 ];<br/>var a, b, c;</span><span id="262f" class="mo kw iq mk b gy mt mq l mr ms">[a, b] = [c] = [1,2,3];<br/>console.log(a, b, c); // 1 2 3</span></pre><p id="6221" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">通过执行以下操作，对象也可以做到这一点:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="785f" class="mo kw iq mk b gy mp mq l mr ms">var dummyObject = { a:1, b:2, c:3 };<br/>var a, b, c;</span><span id="c7fc" class="mo kw iq mk b gy mt mq l mr ms">{ a } = { b, c } = dummyObject;<br/>console.log(a, b, c); // 1 2 3</span></pre><h2 id="4bc3" class="mo kw iq bd kx mz na dn lb nb nc dp lf lw nd ne lh ma nf ng lj me nh ni ll nj bi translated">嵌套解构</h2><p id="979a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">最后，嵌套我们的析构语句是可能的。考虑这个例子:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="ddd4" class="mo kw iq mk b gy mp mq l mr ms">var dummyObject = { a: { b : 100 } };<br/>var { a : { b: b } } = dummyObject;<br/>console.log(b); // 100</span><span id="1aa5" class="mo kw iq mk b gy mt mq l mr ms">// same as<br/>var { a : { b } } = dummyObject;</span></pre><p id="6e5a" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">还记得我们之前的“价值:目标”符号吗？当您想要深入了解对象的值时，可以使用嵌套。在上面的例子中，我们有我们的值<code class="fe nk nl nm mk b">a</code>，我们将它赋给我们的目标<code class="fe nk nl nm mk b">{ b: b }</code>，这是一个新的析构语句。所以我们将对象的值<code class="fe nk nl nm mk b">a.b</code>赋给一个名为<code class="fe nk nl nm mk b">b</code>的新变量。(速记:这个赋值也可以写成<code class="fe nk nl nm mk b">{ b }</code>。)这有多好听？我们现在可以想去多深就去多深！</p><p id="1fff" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">一个实际的例子是，我们试图获取用户写的第一篇博客的<code class="fe nk nl nm mk b">blogTitle</code>。试着真正理解这个例子。一旦点击，你就可以使用析构来处理任何东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="fca0" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="4803" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在本文中，我们已经讨论了尽可能最好地使用析构的所有知识。永远记住可读性是关键。如果你在阅读你自己的析构赋值时有困难，可能会有一个更好的解决方案。</p><p id="7746" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv lw mw ly lz ma mx mc md me my mg mh mi ij bi translated">我希望你学到了一些东西，其中一些帮助你成为一个更好的JavaScript开发人员。祝你好运！</p></div></div>    
</body>
</html>