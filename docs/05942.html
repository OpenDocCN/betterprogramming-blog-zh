<html>
<head>
<title>How to Access the AppKit API from Mac Catalyst Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Mac Catalyst应用程序访问AppKit API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-access-the-appkit-api-from-mac-catalyst-apps-2184527020b5?source=collection_archive---------7-----------------------#2020-08-19">https://betterprogramming.pub/how-to-access-the-appkit-api-from-mac-catalyst-apps-2184527020b5?source=collection_archive---------7-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f099" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在pure Swift中从Catalyst应用程序访问AppKit的两种技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/878f6b0c642405e1feedf3ca2ebb6dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJnzzCGZwQN08jt56v_qVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="2b1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有一小部分AppKit API可供Mac Catalyst使用，但由于Mac Catalyst应用程序也是macOS应用程序，因此它们在运行时确实可以完全访问AppKit API。他们只是看不到，因为苹果将大多数AppKit类标记为Catalyst应用不可用。</p><p id="6167" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将了解如何从Mac Catalyst应用程序中以两种不同的方式和纯Swift方式访问AppKit API。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="767c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">A.使用<code class="fe mt mu mv mw b">Dynamic</code></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/b2dfe4fe2bf448a0205b518967dc3fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wOfe8xuE5zyiWWbe.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="b3de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae my" href="https://github.com/mhdhejazi/Dynamic" rel="noopener ugc nofollow" target="_blank"> Dynamic </a>是一个库，它允许我们以简单、干净的方式从Swift访问Objective-C代码。我编写这个库是因为我想要一种简单的方法来访问Swift的隐藏和私有API，而不需要创建一个单独的插件或使用使代码更难看、更难理解的消息发送技巧。</p><h2 id="e523" class="mz mc it bd md na nb dn mh nc nd dp ml lh ne nf mn ll ng nh mp lp ni nj mr nk bi translated">1.将动态添加为Swift包依赖项</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/79624295e7658ed64cd0870827a6f104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5X52ZG9Mlg1Hcp04Gjxx0w.png"/></div></div></figure><h2 id="8125" class="mz mc it bd md na nb dn mh nc nd dp ml lh ne nf mn ll ng nh mp lp ni nj mr nk bi translated">2.访问AppKit API</h2><p id="72d4" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">就是这样！现在，您可以使用非常简单明了的语法来访问所有的AppKit API，这与您在API是公共的情况下所做的非常相似。</p><p id="9fd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，这是我们如何从macOS应用程序进入全屏，而不是使用动态的Catalyst:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ec4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您需要调用几个方法或访问一个隐藏的AppKit类，那么Dynamic非常有用。对于更复杂的用例，创建一个macOS插件可能是更好的选择。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f55c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">B.使用插件</h1><p id="baa2" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">由于Mac Catalyst应用也是macOS应用，所以可以嵌入使用AppKit API的macOS插件，并在运行时加载。让我们构建一个非常简单的插件，使用AppKit的<code class="fe mt mu mv mw b">NSAlert</code>显示一条消息。</p><h2 id="bfed" class="mz mc it bd md na nb dn mh nc nd dp ml lh ne nf mn ll ng nh mp lp ni nj mr nk bi translated">1.添加macOS捆绑包目标</h2><p id="a022" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">我们把它命名为MacPlugin吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a285ea0985ae392faac89a867bb10a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNf4PZs4Q30qcN57kPlj2Q.png"/></div></div></figure><h2 id="fc3d" class="mz mc it bd md na nb dn mh nc nd dp ml lh ne nf mn ll ng nh mp lp ni nj mr nk bi translated">2.将插件嵌入应用程序目标，并将“平台”更改为macOS</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/9254d54945acdd380fb1404cb69e6b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvrPP1mnDnSViZOW5udazA.png"/></div></div></figure><p id="1268" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为包是在运行时手动加载的，所以我们不能直接引用它的类。相反，我们将使这些类符合共享协议，这些协议定义了我们的应用程序和插件之间的契约。稍后，当我们从插件加载一个类时，我们将把它转换成共享协议。</p><h2 id="0e82" class="mz mc it bd md na nb dn mh nc nd dp ml lh ne nf mn ll ng nh mp lp ni nj mr nk bi translated">3.创建共享协议“插件”</h2><p id="7bb2" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">确保它包含在两个目标中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/09d51bea37e6efb46e110e8902e00c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEnMmwcmsSfJL258og1sdg.png"/></div></div></figure><p id="cf7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">捆绑包只能加载从<code class="fe mt mu mv mw b">NSObject</code>继承的Objective-C类或Swift类。共享协议通常用Objective-C编写，但是我们也可以使用Swift协议，只要它们继承自<code class="fe mt mu mv mw b">NSObjectProtocol</code>并且只使用与Objective-C运行时兼容的Swift特性(例如，像结构、泛型和enum关联值这样的特性与Objective-C运行时不兼容，因此不受支持)。</p><p id="9b61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你添加Swift代码到插件目标时，Xcode会建议配置一个Objective-C桥接头。这的确是明智的建议——接受吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/6461c37c3b2707e3056221a97a561832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbbAnSKJ-K2QXJvjSpOOKA.png"/></div></div></figure><p id="78c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个方法编写一个简单的协议，显示来自AppKit land的警报。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="230a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们用<code class="fe mt mu mv mw b">@objc(Plugin)</code>对协议进行了注释。这非常重要，因为它确保了在两个目标中，协议的名称在Objective-C运行时看来是相同的。</p><p id="7c6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有注释，运行时将会看到两个名称不同的协议，因为模块名称是默认名称的一部分:<br/><code class="fe mt mu mv mw b">App.Plugin</code>—我们的应用程序中包含的协议<br/><code class="fe mt mu mv mw b">MacPlugin.Plugin</code>—插件中包含的协议</p><p id="7cb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着我们不能将符合<code class="fe mt mu mv mw b">MacPlugin.Plugin</code>的插件类转换为<code class="fe mt mu mv mw b">App.Plugin</code>。</p><p id="2607" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请注意，我们向共享协议添加了一个初始化器。这对于在将插件加载到内存中之后创建插件类的实例是必要的。</p><h2 id="3b72" class="mz mc it bd md na nb dn mh nc nd dp ml lh ne nf mn ll ng nh mp lp ni nj mr nk bi translated">4.编写符合共享协议的类</h2><p id="fd42" class="pw-post-body-paragraph ky kz it la b lb nm ju ld le nn jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">您只需要将它包含在插件目标中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e3646a90db2b2c48e1971da210f67785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pD5E_rWc5j1beFmAyiFqYg.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8494" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现很简单。我们只是使用AppKit的<code class="fe mt mu mv mw b">NSAlert</code>类显示一个警告。</p><h2 id="4e26" class="mz mc it bd md na nb dn mh nc nd dp ml lh ne nf mn ll ng nh mp lp ni nj mr nk bi translated">5.加载插件包并创建一个新的<code class="fe mt mu mv mw b">MacPlugin</code>实例</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0200" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们正在用插件的URL创建一个新的<code class="fe mt mu mv mw b">Bundle</code>实例。插件包应该在主包内的内置插件目录中，因为Xcode会在那里复制它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/ac7d9776c38e2211520c077c656325df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gq18gvnZSYkDbjOJXdbHtw.png"/></div></div></figure><p id="e7ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们调用<code class="fe mt mu mv mw b">bundle.classNamed()</code>，它将指定的类加载到内存中并返回类类型。如果找不到指定的类，该方法返回<code class="fe mt mu mv mw b">nil</code>。请注意，类名必须包含模块名。</p><p id="7429" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注1 </strong>:如果你的插件中只有一个公共类，你可以将<code class="fe mt mu mv mw b">Info.plist</code>文件中的“principal class”属性(<code class="fe mt mu mv mw b">NSPrincipalClass</code>)设置为完整的类名，使其成为插件的principal类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/7f7e2c762bce596665a771198095a62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFbEyXAJSpIQ3QOLoRIUIg.png"/></div></div></figure><p id="99ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，您可以通过调用<code class="fe mt mu mv mw b">Bundle.principalClass</code>来访问该类，而不是搜索该类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6c62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注2 </strong>:我们可以通过调用<code class="fe mt mu mv mw b">bundle.load()</code>显式加载插件，但这并不是真正必要的，因为当我们试图从插件中加载任何类时，插件都会自动加载。</p><p id="492e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">加载类后，我们使用在共享协议中定义的初始化器创建一个新的实例，然后调用<code class="fe mt mu mv mw b">sayHello()</code>。如果一切顺利，您会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/d4c0b54b535651612cfe537987b8c086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hM4rxLelJsuvXNxNazzQOg.png"/></div></div></figure><p id="fb88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="4d4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这有所帮助。如果您有任何问题或反馈，请随时回复。你可以在<a class="ae my" href="https://github.com/mhdhejazi/Catalyst-AppKit" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个简单插件的完整源代码。</p></div></div>    
</body>
</html>