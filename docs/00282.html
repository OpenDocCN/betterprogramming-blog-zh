<html>
<head>
<title>Clock-In/Out System Part 7: Deploy Back End (NestJS) — Docker/Docker-Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下班打卡系统第7部分:部署后端(NestJS)-Docker/Docker-Compose</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=collection_archive---------0-----------------------#2019-02-01">https://betterprogramming.pub/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=collection_archive---------0-----------------------#2019-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS + Angular教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/27028d592125269574905771e8218205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*KhCkmbtORw2Ux3n5WCrtzA.png"/></div></figure><p id="cc29" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这篇文章是我描述上下班打卡系统的系列文章的一部分。如果你想了解更多，你可以阅读以下内容:</p><ul class=""><li id="ace6" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-1-clock-in-out-system-diagram-a0a51bab02a7?source=post_page---------------------------" rel="noopener">上下班打卡系统第1部分:图</a></li><li id="02aa" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-2-clock-in-out-system-basic-backend-i-authmodule-66d4a5c56122?source=post_page---------------------------" rel="noopener">上下班打卡系统第二部分:基础后端— AuthModule </a></li><li id="f56b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-3-clock-in-out-system-basic-backend-ii-usersmodule-a56f42b20f62?source=post_page---------------------------" rel="noopener">上下班打卡系统第3部分:基本后端——用户模块</a></li><li id="570e" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-4-clock-in-out-system-basic-backend-iii-appmodule-850dd17883e?source=post_page---------------------------" rel="noopener">上下班打卡系统第4部分:基础后端— AppModule </a></li><li id="4035" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/better-programming/part-5-clock-in-out-system-seed-database-and-migration-data-cf037be21aac?source=post_page---------------------------" rel="noopener">上下班打卡系统第5部分:种子数据库和迁移数据</a></li><li id="09ca" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-6-clock-in-out-system-basic-frontend-an-7e5f9ed08c3f?source=post_page---------------------------" rel="noopener">上下班打卡系统第6部分:基本前端</a></li><li id="cb20" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-7-deploy-backend-nestjs-docker-docker-compose-2429c0b6aa9c?source=post_page---------------------------" rel="noopener">上下班打卡系统第7部分:使用Docker/Docker-Compose部署后端(NestJS)</a></li><li id="8948" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-8-clock-in-out-system-deploy-frontend-angular-6-using-environments-ad267325d3b6?source=post_page---------------------------" rel="noopener">上下班打卡系统第8部分:使用环境部署前端(角度6+)</a></li><li id="e6a0" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-9-testing-backend-testing-2d021f48403b?source=post_page---------------------------" rel="noopener">上下班打卡系统第9部分:后端测试——服务的单元测试</a></li><li id="9ede" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@ccaballero/part-10-testing-backend-testing-unit-testing-controllers-4177370ef581?source=post_page---------------------------" rel="noopener">上下班打卡系统第10部分:后端测试——控制器单元测试</a></li><li id="ddde" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第11部分:后端测试-e2e测试</li><li id="9c7b" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第12部分:前端测试单元测试</li><li id="701a" class="lm ln it ks b kt lw kw lx kz ly ld lz lh ma ll lr ls lt lu bi translated">上下班打卡系统第13部分:前端测试集成测试</li></ul><p id="8311" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当您开发软件应用程序时，您经常在开发环境中编码。然而，迟早，你将需要在生产环境中部署你的应用，同时在你的开发环境中继续开发。</p><p id="4317" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在node.js中有几种管理环境变量的解决方案，但是最流行的库是<a class="ae lv" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>(可以在<a class="ae lv" href="https://www.twilio.com/blog/2017/08/working-with-environment-variables-in-node-js.html" rel="noopener ugc nofollow" target="_blank"> twilio </a>中阅读简单的教程)。在我们的例子中，我们使用node.js框架<a class="ae lv" href="https://www.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>开发了我们的后端，它有一个使用dotenv ( <a class="ae lv" href="https://github.com/nestjs-community/nestjs-config" rel="noopener ugc nofollow" target="_blank"> NestJS-Config </a>)管理环境变量的模块。然而，我开发了自己的NestJS模块来管理<code class="fe mb mc md me b">NODE</code>的环境变量，而不使用外部库。</p><p id="f19f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，使用<a class="ae lv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker的容器</a>部署我们的代码。我们将从我们的代码和<a class="ae lv" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>中创建一个图像。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b275" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">步骤1:开发EnvModule</h1><p id="d889" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">第一步是开发我们的<code class="fe mb mc md me b">EnvModule</code>,它从一个文件中加载定制变量。知道使用<code class="fe mb mc md me b">NODE_ENV</code>(或任何变量)可以传递什么环境的文件非常重要。</p><p id="e762" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我开发了一个<code class="fe mb mc md me b">EnvModule</code>来配置一个<code class="fe mb mc md me b">environment</code>变量，这个变量可以是<code class="fe mb mc md me b">default</code>或者是<code class="fe mb mc md me b">NODE_ENV</code>内容。下一步是定义一个提供者，它使用一个工厂从环境文件返回<code class="fe mb mc md me b">env</code>变量。此提供程序被导出以在其他模块中使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/7f98362fe9ad25c2dc77c78a8ad2a0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usfDDk54BlZ2YMj5ckTFVw.png"/></div></div></figure><p id="c782" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">文件中使用的接口如<code class="fe mb mc md me b">env/env.ts</code>文件所示。这个配置是关于数据库及其密码的。让开发中的密码不同于生产中的密码非常重要。想象一下，公司里的每个人都知道数据库的root密码，因为错误地使用了同一个密码！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi gj"><img src="../Images/beddf3ea2075a455669514836986291b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDeeyuI4PF21J7h0InQpuQ.png"/></div></div></figure><p id="16b8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mb mc md me b">default</code>环境将是开发环境，<code class="fe mb mc md me b">production</code>将是生产环境。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/e27ff76a184c554fe3e73f6043d8902b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXXdyRfL6v-nIT_NZmK_4w.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/332d2755c3f127c0256e590250ac6622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFVy14mfxR9wARRVrH3gLw.png"/></div></div></figure><p id="ca40" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意在默认环境中,<code class="fe mb mc md me b">DB_HOST</code>变量是经典的<code class="fe mb mc md me b">localhost</code>。当环境被设置为生产时，它的值是包含<code class="fe mb mc md me b">PostgreSQL</code>数据库的机器的名称(这个名称是由容器指定的)。</p><h1 id="4c8d" class="mm mn it bd mo mp np mr ms mt nq mv mw jz nr ka my kc ns kd na kf nt kg nc nd bi translated">步骤2:修改数据库模块</h1><p id="13a3" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">第二步是修改<code class="fe mb mc md me b">DatabaseModule</code>来加载来自<code class="fe mb mc md me b">EnvModule</code>的信息。将使用<code class="fe mb mc md me b">docker-compose</code>传递<code class="fe mb mc md me b">NODE_ENV</code>变量。</p><p id="d34c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mb mc md me b">EnvModule</code>导出<code class="fe mb mc md me b">ENV</code>提供者，该提供者可以由<code class="fe mb mc md me b">DatabaseModule</code>导入，以配置<code class="fe mb mc md me b">databaseProvider</code>。因此，第一个修改是<code class="fe mb mc md me b">DatabaseModule</code>，它导入模块。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nu"><img src="../Images/cb2af0fcc4a78a5f0b7620e4a81177f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9TKhinmGunZCq0dlbTEZQ.png"/></div></div></figure><p id="7598" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因为<code class="fe mb mc md me b">EnvModule</code>正在导出提供者，所以它可以被注入到<code class="fe mb mc md me b">DbConnectionToken</code>提供者中，后者接收<code class="fe mb mc md me b">ENV</code>作为参数。配置不是在提供者中硬编码的，而是由服务提供的(从环境文件中读取)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ca"><img src="../Images/40cfa043a74fa0657fd0e18ec8374425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBoXdSKJTE8JTitGpc5cqA.png"/></div></div></figure><p id="68b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此时，如果您想要在环境之间切换，可以通过运行以下命令来实现:</p><pre class="kj kk kl km gt nv me nw nx aw ny bi"><span id="1a92" class="nz mn it me b gy oa ob l oc od">NODE_ENV=production npm run start:watch</span></pre><h1 id="3449" class="mm mn it bd mo mp np mr ms mt nq mv mw jz nr ka my kc ns kd na kf nt kg nc nd bi translated">步骤3:使用Docker和Docker Compose进行部署</h1><p id="72da" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">这个想法是在开发和生产中使用相同的环境。在这种情况下，Docker是完美的工具，因为它允许我们配置不同的容器，这些容器使用我们的<code class="fe mb mc md me b">EnvModule</code>来切换配置。我们需要建立自己的形象，这将是一个Docker容器。之后，该图像将使用<code class="fe mb mc md me b">docker-compose</code>进行编排。</p><h2 id="2d36" class="nz mn it bd mo oe of dn ms og oh dp mw kz oi oj my ld ok ol na lh om on nc oo bi translated">码头工人</h2><p id="d6d3" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">我们的<code class="fe mb mc md me b">dockerfile</code>文件基于<code class="fe mb mc md me b">node:10-alpine</code>图像，因为项目不需要系统库。这个映像只是复制源代码并安装依赖项(使用<code class="fe mb mc md me b">npm install</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi op"><img src="../Images/b2c568d5797b4e23ed0d0aad99e0fdeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WYEFpJv3wTSYGHlO_CPwg.png"/></div></div></figure><p id="2707" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当您构建Docker映像时，建议使用一个<code class="fe mb mc md me b">.dockerignore</code>文件，就像您使用<code class="fe mb mc md me b">.gitignore</code>一样。</p><pre class="kj kk kl km gt nv me nw nx aw ny bi"><span id="af96" class="nz mn it me b gy oa ob l oc od">node_modules npm-debug.log docker-volumes e2e test</span></pre><h2 id="b445" class="nz mn it bd mo oe of dn ms og oh dp mw kz oi oj my ld ok ol na lh om on nc oo bi translated">docker-撰写</h2><p id="a0f7" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">在我们的项目中，我们有两个不同的<code class="fe mb mc md me b">docker-compose</code>文件。第一个用于我们的开发环境。这是因为<code class="fe mb mc md me b">docker-compose</code>只管理DBMS Postgres，因为代码是使用这个npm脚本在我们的平台上运行的:(<code class="fe mb mc md me b">npm run start:dev</code>)。注意，我们的服务是基于<code class="fe mb mc md me b">postgres:10-alpine</code>的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oq"><img src="../Images/c4937284d87c3d1c82e56ea6b200e086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVFM0iV6dwkcSOcIZX2Ksg.png"/></div></div></figure><p id="ec35" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第二个脚本更复杂。在本例中，我们有一个名为<code class="fe mb mc md me b">clock-backend</code>的基于<code class="fe mb mc md me b">ccaballerog/clock-backend</code>图像的容器，它是在最后一步中构建的。<code class="fe mb mc md me b">clock-backend</code>容器需要知道<code class="fe mb mc md me b">PostgreSQL</code>容器。为此，我们可能需要一个DNS服务器。然而，<code class="fe mb mc md me b">docker-compose</code>通过启用<code class="fe mb mc md me b">networks</code>关键字来简化这个任务。注意，两个容器都定义了相同的网络(<code class="fe mb mc md me b">clock-frontend_clock-net</code>)。</p><p id="4a7f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe mb mc md me b">clock-backend</code>容器有一个环境区域，在这里我们将时区和<code class="fe mb mc md me b">NODE_ENV</code>都定义为production(加载我们的环境文件)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oq"><img src="../Images/0e5515cbeff2e26f96e9d2730c0f4686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nW3oLGUEiAMhDRgaLW6qHw.png"/></div></div></figure><h1 id="bd9d" class="mm mn it bd mo mp np mr ms mt nq mv mw jz nr ka my kc ns kd na kf nt kg nc nd bi translated">步骤4:使用Shell脚本执行</h1><p id="fb91" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">我们流程的最后一步是自动化容器的构造和执行。我有两个脚本来完成这项任务:第一个脚本创建图像(删除图像，如果有的话)，第二个脚本使用<code class="fe mb mc md me b">docker-compose</code>部署代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi or"><img src="../Images/dcc5327dae443572276fff23d6ee02a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAerpYSNPjixJH3gfGXDNQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi os"><img src="../Images/45c7f2e435b62d597f3e4c8d4214b384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9WUfCPHSZZqXr1OxoIjCA.png"/></div></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c144" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="3c3d" class="pw-post-body-paragraph kq kr it ks b kt ne ju kv kw nf jx ky kz ng lb lc ld nh lf lg lh ni lj lk ll im bi translated">在这篇文章中，我解释了如何使用Docker和Docker Compose用NestJS部署后端。这段代码最有趣的特性是我们可以加载自己的环境变量，在开发和生产环境之间切换。</p></div></div>    
</body>
</html>