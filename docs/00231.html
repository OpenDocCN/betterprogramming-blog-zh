<html>
<head>
<title>The Easiest Way to Save Time?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最简单的节省时间的方法？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/want-to-know-the-easiest-way-to-save-time-use-make-eec453adf7fe?source=collection_archive---------0-----------------------#2018-11-19">https://betterprogramming.pub/want-to-know-the-easiest-way-to-save-time-use-make-eec453adf7fe?source=collection_archive---------0-----------------------#2018-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4696" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用“造”！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ad2d8916c1001723ca6276be3e65451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tag_5co_wBrmCdD3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@rawpixel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的“佩戴圆形白色手表的人”</p></figure><p id="d926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们总是在寻找使他们的工作更容易的方法。使用工具和自动化是人类独有的特征还是其他物种共有的，这是一个有争议的问题。事实是，我们试图将最平凡的任务外包给机器——这很好！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1495" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么要自动化？</h1><p id="8452" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">重复往往会导致厌倦和疲劳。无聊是走向倦怠的第一步，而疲劳是错误的主要来源。因为我们不想让我们的同事(或我们自己)筋疲力尽，就像我们不想犯代价高昂的错误一样，我们试图自动化日常任务。</p><p id="ae33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">致力于普通任务自动化的软件似乎越来越多。在节点中。仅JS生态系统，就有(或曾经有)像Bower、Yeoman、Grunt、Gulp和NPM脚本这样的解决方案。</p><p id="a3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是也有一个很好的标准UNIX工具。所谓标准，我的意思是它实际上有健壮的文档，这是许多其他工具似乎已经忘记的。我说的是<code class="fe mz na nb nc b">make</code>。更具体地说，这篇文章关注的是GNU make，它可以在macOS、Windows、Linux和大多数其他操作系统上使用。</p><p id="e9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">make</code>非常标准，你已经安装了。在命令行中输入“make ”,然后自己检查。这款软件于1977年问世，这意味着它基本上经过了实战考验。很古怪吗？是的，即使是70年代的标准。但它做得很好，这是我们对它的全部期望。</p><h1 id="6ec0" class="mc md it bd me mf nd mh mi mj ne ml mm jz nf ka mo kc ng kd mq kf nh kg ms mt bi translated">难道Make不是针对C/C++代码的吗？</h1><p id="2013" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你读到<code class="fe mz na nb nc b">make</code>的时候，你可能会想起过去有这样一个工具来构建C/C++项目。事情是这样的<code class="fe mz na nb nc b">./configure &amp;&amp; make &amp;&amp; make install</code>。是的，我们谈论的是完全相同的工具——它不局限于编译C/C++代码。说实话，它连代码都不会编译。</p><p id="01ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有<code class="fe mz na nb nc b">make</code>理解的都是文件。它知道一个文件是否存在，以及哪个文件是最新的。它的另一半功能是维护依赖图。它并不多，但这两个特性就是它的力量所在。</p><p id="3003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让<code class="fe mz na nb nc b">make</code>真正做任何事情，你要写一套食谱。每个配方由一个目标、零个或多个依赖项以及零个或多个规则组成。目标是您想要获取的文件。依赖项是创建或更新目标所需的文件。这组规则描述了将依赖关系转换为目标的过程。例如，假设您想要在Node.js包中自动安装:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="6102" class="nm md it nc b gy nn no l np nq">node_modules: package.json<br/>	npm install</span></pre><p id="90f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着文件<code class="fe mz na nb nc b">node_modules</code>(是的，目录也是文件)可以通过运行<code class="fe mz na nb nc b">npm install</code>规则从文件<code class="fe mz na nb nc b">package.json</code>中导出。还和我在一起吗？</p><p id="96de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这些依赖项也可以是其他目标。这意味着我们可以链接不同的规则集并创建管道。例如，我们可以让测试结果目录依赖于构建目录，构建目录依赖于<code class="fe mz na nb nc b">node_modules</code>目录，而<code class="fe mz na nb nc b">node_modules</code>依赖于<code class="fe mz na nb nc b">package.json</code>。见鬼，我们甚至可以动态地创建<code class="fe mz na nb nc b">package.json</code>，使它成为另一个规则的目标。还记得我提到的<code class="fe mz na nb nc b">make</code>跟踪哪个文件是最新的吗？这为我们节省了时间。如果没有这个特性，每次我们运行<code class="fe mz na nb nc b">make test</code>(按照上面的例子)我们将不得不从头开始运行整个链(<code class="fe mz na nb nc b">npm install</code>，构建，然后测试)。但是如果什么都没有改变，为什么要再次安装包呢？为什么要建？为什么要进行测试？</p><p id="8ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这才是<code class="fe mz na nb nc b">make</code>真正出彩的地方。在确定作业顺序的同时，它会检查目标和依赖项的时间戳。只有在以下情况下，它才遵循该规则:</p><ul class=""><li id="2215" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">一个或多个依赖项比目标更新</li><li id="3444" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">目标不存在。</li></ul><p id="b712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一件事！由于<code class="fe mz na nb nc b">make test</code>不会实际创建一个名为<code class="fe mz na nb nc b">test</code>的文件，我们需要添加这个目标作为<code class="fe mz na nb nc b">.PHONY</code>目标的依赖——另一个约定。像这样:</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="f06d" class="nm md it nc b gy nn no l np nq">.PHONY: test<br/><br/>test: build<br/>	npm test<br/>	<br/>build: node_modules<br/>	npm build<br/>	<br/>node_modules: package.json<br/>	npm install</span></pre><p id="f3db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们上面的例子中，<code class="fe mz na nb nc b">package.json</code>中的一个单独的改变将导致从头开始构建一切。但是如果我们只改变其中一个测试的代码，<code class="fe mz na nb nc b">make</code>会跳过测试之前的所有步骤，前提是依赖关系写得正确。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7fd7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">但是我使用的语言已经有了自己的构建系统</h1><p id="eb42" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">许多现代编程语言和环境都有自己的构建工具。Java有Ant，Maven，和Gradle，Ruby有它的Rake，Python用setuptools。如果你担心我会把那些玩具拿走，换成<code class="fe mz na nb nc b">make</code>，那你就错了。</p><p id="779e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样来看:把一个人介绍给你的团队并让这个人富有成效需要多少时间？这意味着建立开发环境，安装所有的依赖项，配置每个移动部分，构建项目，运行项目，甚至可能将项目部署到开发环境中。</p><p id="b207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新员工会在几个小时内开始实际工作吗？几天？希望不是几周。记住，在设置过程中浪费的不仅仅是新员工的时间。当事情出错时，有些人也会被许多问题困扰(他们通常会这样)。</p><p id="aa0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢在我的项目中使用一个惯例。因为这是多个项目共有的约定，所以人们可以在它们之间自由迁移。每一个新项目或每一个新介绍的人都需要学习这个惯例，以达到期望的结果。这个约定假设项目有它们自己的Makefiles，带有一组预定义的目标:</p><ul class=""><li id="fb04" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">安装所有可能需要的外部应用程序。通常这是用一个<code class="fe mz na nb nc b">Brewfile</code>和Homebrew/Linuxbrew完成的。由于这一步是可选的，编码人员可以选择自己的安装方法，风险自担。</li><li id="8d3f" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe mz na nb nc b">make dev</code>建立本地开发环境。通常，它构建并调用Docker容器，但是由于<code class="fe mz na nb nc b">make</code>充当了包装器，它可以很容易地被任何需要的东西替代(比如<code class="fe mz na nb nc b">npm serve</code>)。</li><li id="0640" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe mz na nb nc b">make deploy</code>将代码部署到选择的环境中(默认情况下是它的<code class="fe mz na nb nc b">development</code>)。在引擎盖下，它通常运行Ansible。</li><li id="accc" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe mz na nb nc b">make infrastructure</code>这是<code class="fe mz na nb nc b">make deploy</code>的先决条件，因为它首先使用Terraform来创建所述环境。</li><li id="1112" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe mz na nb nc b">make all</code>生产部署所需的所有工件。</li></ul><p id="678b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道这意味着什么吗？这意味着强制性的<code class="fe mz na nb nc b">README.md</code>可以关注项目的业务需求，并概述一些协作过程。我们在最后附上上面的列表，这样每个人都知道这些目标是什么。这意味着当你进入一个新项目时，你所要做的就是<code class="fe mz na nb nc b">make prepare</code>和<code class="fe mz na nb nc b">make dev</code>。几个CPU周期之后，你面前就有了一个工作项目，你就可以开始破解了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="45e4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我有一个持续的集成管道</h1><p id="1304" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一点上，有些人可能会注意到我在说什么。工件、步骤、部署、基础设施。这就是我们的持续集成/持续部署管道所做的。我肯定是这样的！但是请记住，CI/CD不仅仅是在每次弹出新的提交时运行测试。</p><p id="c361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正确实施的CI/CD使重现问题和执行根本原因分析变得更加容易，从而有助于减少调试。怎么会？版本化的工件就是这样一种方法。它们可能有助于找到根本原因，但不一定有助于解决问题。</p><p id="67a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要修复这个bug，你需要修改代码并生成你自己的版本。你明白我的意思吗？如果您的CI/CD管道可以本地镜像，开发人员可以测试和部署微小的更改，而不需要实际使用CI/CD管道，从而缩短周期。使您的CI/CD管道在本地可用的最简单的方法是用一个薄薄的包装器包裹住<code class="fe mz na nb nc b">make</code>。</p><p id="2b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你有一个后端和一个前端，并且你对它们也有一些测试(如果没有，你在没有测试的情况下疯狂的运行CD！).这将产生四个不同的CI任务。他们可以被概括为<code class="fe mz na nb nc b">make backend</code>、<code class="fe mz na nb nc b">make test-backend</code>、<code class="fe mz na nb nc b">make frontend</code>、<code class="fe mz na nb nc b">make test-frontend</code>。或者任何你想遵循的惯例。</p><p id="4308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，无论是在本地机器上还是在CI上，代码都以完全相同的方式构建。涉及完全相同的步骤。进入你的<code class="fe mz na nb nc b">Jenkinsfile</code>或<code class="fe mz na nb nc b">.travis.yml</code>(或其他)的命令越少，你就越不依赖神圣的构建机器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e7fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">好吧，但是真的有人用Make吗？</h1><p id="14fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">事实证明，是的。如果你环顾四周，你会发现像“Makefiles卷土重来的时候了”(Jason Olson)这样的文章。“Makefile的力量”(Ahmad Farag)。“重写我们的部署工具:从Makefile到Bash，然后再回来”(Paul David)。或者“面向Node.js开发人员的Makefile”(Patrick he naise)。这些都是去年的文章，不是上个世纪的回忆。</p><p id="ab92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我不得不承认<code class="fe mz na nb nc b">make</code>很笨重。我知道它的许多缺点和怪异的语言特征。但是给我展示一个更好的实际开发工作流自动化工具，我会很乐意转换。在那之前我会ROTFL看着这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/1d251ef7c10148b8a3a79f0f496d5c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qb7VuJIDBwyg9MOLyh9rUg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://asciinema.org/a/dQb0jENCYWsBOCC9UiKxxKG4x" rel="noopener ugc nofollow" target="_blank">https://asciinema.org/a/dQb0jENCYWsBOCC9UiKxxKG4x</a></p></figure><p id="78c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想驾驶它，可以在GitHub 上找到它。</p><h1 id="13c7" class="mc md it bd me mf nd mh mi mj ne ml mm jz nf ka mo kc ng kd mq kf nh kg ms mt bi translated">酷，现在给我看看代码</h1><p id="0eea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以下是一些摘录，向您展示使用<code class="fe mz na nb nc b">make</code>的可能性。</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="53e9" class="nm md it nc b gy nn no l np nq">.PHONY: dev<br/><br/>.stamps:<br/>	@mkdir -p $@<br/><br/>.stamps/git-hooks.installed: | .stamps<br/>	# This checks whether git-hooks is an executable and installs it with<br/>	# Homebrew/Linuxbrew is possible.<br/>	@if ! command -v git-hooks &gt;/dev/null 2&gt;&amp;1; then \<br/>	  if command -v brew &gt;/dev/null 2&gt;&amp;1; then \<br/>	    brew install git-hooks; \<br/>	  else \<br/>	    echo "You have to install https://github.com/icefox/git-hooks"; \<br/>	    exit 1; \<br/>	  fi; \<br/>	fi<br/>	@touch $@<br/><br/>.git/hooks.old: | .stamps/git-hooks.installed<br/>	git hooks --install<br/><br/>dev: | .git/hooks.old<br/>	pip install -e .[dev]</span></pre><p id="028d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个代码片段建立了一个简单的开发环境。因为我们想确保所有开发人员在使用Git时使用相同的预提交挂钩，所以我们为他们安装了这些挂钩。</p><p id="012a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要安装git-hooks(这是钩子管理器的名字)。我们利用git-hooks将原始钩子移动到<code class="fe mz na nb nc b">.git/hooks.old</code>的知识，因此我们检查这样一个文件的存在，以确定我们是否想要运行<code class="fe mz na nb nc b">git hooks install</code>。</p><p id="e338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用的一个技巧是<code class="fe mz na nb nc b">|</code>来表示仅顺序依赖。如果您只想确定某个东西存在，而不是它比目标修改得更快，那么只有顺序的依赖关系是最好的选择。我想，到目前为止还不错。</p><p id="04df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在假设我们想要构建一个Docker容器，其中包含一个我们不能在源代码中分发的文件。</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="cdea" class="nm md it nc b gy nn no l np nq">WEBAPP_SOURCES = $(sort $(notdir $(wildcard webapp/**/*)))<br/><br/>all: webapp<br/><br/>.stamps: Makefile<br/>	@mkdir -p $@<br/><br/>third-party/top_secret.xml:<br/>	# WEB_USER and WEB_AUTH_TOKEN are variables that should contain credentials<br/>	# required to obtain the file.<br/>	@curl -u "$(WEB_USER):$(WEB_AUTH_TOKEN)" https://example.com/downloads/this_is_a_secret.xml -L -o $@<br/><br/>webapp: .stamps/webapp.stamp<br/>.stamps/webapp.stamp: .stamps webapp/Dockerfile third-party/top_secret.xml $(WEBAPP_SOURCES)<br/>	docker build -t example/webapp -f webapp/Dockerfile webapp<br/>	@touch $@<br/><br/>.PHONY: all webapp</span></pre><p id="041a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们不能使用Docker创建的实际文件(因为图像有严格的权限)，我们只能退而求其次。我们创建一个空文件，表明我们已经在一个时间点成功运行了<code class="fe mz na nb nc b">docker build</code> <em class="nr">。</em></p><p id="d1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种文件的一个常见约定是称它们为“戳记”。我们的Docker图像标记显然依赖于<code class="fe mz na nb nc b">Dockerfile</code>，依赖于源文件和另一个目标，后者运行<code class="fe mz na nb nc b">curl</code>从环境变量中获取文件获取凭证。</p><p id="4813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们不想将凭证打印到输出中，所以我们在命令前面加上了<code class="fe mz na nb nc b">@</code>。这意味着规则本身不会打印到屏幕上。然而，规则的输出并没有消失。如果您想要运行的任何程序有将敏感信息记录到stdout或stderr的倾向，请记住这一点。</p><p id="f5dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好，我们可以设置git挂钩，我们可以建立一些Docker图像。为什么不让开发人员在云中创建他们自己的环境，并在其上部署呢？</p><pre class="kj kk kl km gt ni nc nj nk aw nl bi"><span id="1834" class="nm md it nc b gy nn no l np nq"># We include the previous Makefile so we can build the image<br/>include previous.mk<br/><br/>.stamps/webapp_pushed.stamp: .stamps/webapp.stamp<br/>        docker push example/webapp<br/>        @touch $@<br/><br/>infrastructure: $(INFRASTRUCTURE_SOURCES)<br/>        cd deployment/terraform &amp;&amp; terraform apply<br/><br/>deploy: all infrastructure<br/>        cd deployment &amp;&amp; ansible-playbook -i inventories/hosts deploy.yml<br/><br/>.PHONY: infrastructure deploy</span></pre><p id="5600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为代码和配置管理的实际基础设施超出了本文的范围。我来告诉你，<code class="fe mz na nb nc b">terraform apply</code>管理云资源，<code class="fe mz na nb nc b">ansible-playbook</code>在远程机器上进行配置。你可能知道<code class="fe mz na nb nc b">docker push</code>是做什么的。简而言之，它将本地映像推送到Docker Hub(或任何其他注册表)，因此您可以从任何地方访问它。至此，我相信您可以理解上面的代码片段是做什么的了。</p><h1 id="3169" class="mc md it bd me mf nd mh mi mj ne ml mm jz nf ka mo kc ng kd mq kf nh kg ms mt bi translated">这个工具是给谁用的？</h1><p id="e7da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管DevOps最近越来越受关注，但是在Dev和Ops之间仍然有很大的距离。有些工具仅由开发人员使用，有些仅由运营人员使用。有一点共同点，但能达到多远取决于团队。</p><p id="dee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发包管理、源代码布局和编码指南都是开发的领域。代码、配置管理和编排等基础设施是运营部门的玩具。构建系统和持续集成管道可能在两者之间分开，也可能属于任何一方。你能看到共同点是如何被拉长的吗？</p><p id="5924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改变事物，允许更广泛的合作。因为它服务于开发和运营的目的，所以它是一个共同点。每个人都说它的语言，每个人都可以做出贡献。但是因为它非常容易使用，即使当你想做复杂的事情时(就像在我们上面的例子中)，DevOps的真正力量被赋予了团队中的每个人。每个人都可以运行<code class="fe mz na nb nc b">make test</code>，每个人都可以修改它的规则和依赖关系。每个人都可以运行<code class="fe mz na nb nc b">make infrastructure</code>，为开发或生产提供一个好的集群。毕竟它们是用同一个代码记录的！</p><p id="6f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，当有共同点时，确定谁负责哪个部分是很好的。您最不希望的事情就是开发人员和运营人员重写彼此的工作！但是伟大的团队合作总是依赖于伟大的沟通，所以无论有没有<code class="fe mz na nb nc b">make</code>都可能发生。</p><p id="20b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您使用任何与DevOps相关的新潮技术，都没有关系。你可能不需要也不想要任何Docker，Cloud，Terraform或者Travis。你可以编写桌面应用程序，无论其价值如何，精心编写的<code class="fe mz na nb nc b">Makefile</code>仍然是DevOps的推动者。</p></div></div>    
</body>
</html>