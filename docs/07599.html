<html>
<head>
<title>React Enzyme vs. React Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应酶与反应测试库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-enzyme-vs-react-testing-library-2cac3ad20c52?source=collection_archive---------5-----------------------#2021-02-01">https://betterprogramming.pub/react-enzyme-vs-react-testing-library-2cac3ad20c52?source=collection_archive---------5-----------------------#2021-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ccf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较用于测试React组件的两个对比库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8826f6ef28dabeedda8fa630553a17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1CQJFs-q-Qrlb7H3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯莉·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="53c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很长一段时间，当测试React组件时，我们被<a class="ae ky" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶</a>卡住了。没有其他选择。最近，一个名为<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> React测试库</a>的新玩家加入了前端测试领域。我们已经看到它开始获得一些真正的牵引力。</p><p id="5bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么什么时候应该使用其中一个而不是另一个呢？每一个都有什么作用？让我们比较一下Enzyme和React测试库，看看它们都是关于什么的。我们将通过涵盖以下内容进行适当的比较:</p><ul class=""><li id="ea85" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">基础知识:热身并了解一些关于每个库的知识。</li><li id="1398" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">安装:安装每一个有多容易？</li><li id="e13b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不同的心态:他们对测试有什么看法？</li><li id="64b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">快照测试:它是什么，为什么要关注它？</li><li id="6c82" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">示例:一些反映两个库之间差异的实际代码。</li><li id="3193" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">总结:最后的想法。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9a0d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">酶的基础</h1><p id="1720" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Enzyme是一个专用的React测试工具，用于查看React组件的输出。在某些方面，它可以模拟React应用程序的运行时。它是由Airbnb团队建造的，在一段时间内一直是唯一的解决方案。</p><blockquote class="nn"><p id="2b38" class="no np it bd nq nr ns nt nu nv nw lu dk translated">" Enzyme的API旨在通过模仿jQuery的DOM操作和遍历API来实现直观和灵活."— <a class="ae ky" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶的文档</a></p></blockquote></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bd73" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">React测试库基础</h1><p id="677a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">React测试库构建在Dom测试库之上。它只是添加了API来处理React组件。它在几年前发布，但直到2020年才开始获得真正的关注。</p><blockquote class="nx ny nz"><p id="0270" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">“<code class="fe oe of og oh b">DOM Testing Library</code>是一个非常轻量级的测试DOM节点的解决方案(无论是用<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>默认提供的<code class="fe oe of og oh b"><a class="ae ky" href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank">JSDOM</a></code>模拟还是在浏览器中模拟)。它提供的主要实用工具包括查询DOM中的节点，这种方式类似于用户在页面上查找元素的方式。通过这种方式，库有助于确保您的测试让您对UI代码充满信心。<code class="fe oe of og oh b">DOM Testing Library</code>的首要指导原则是:</p><p id="f0ac" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">你的测试越像你的软件被使用的方式，它们就越能给你信心。”— <a class="ae ky" href="https://testing-library.com/docs/dom-testing-library/intro/" rel="noopener ugc nofollow" target="_blank"> DOM测试库的文档</a></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="baaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React测试库的一个了不起的地方是它是框架无关的。您可以将它与Vue、Preact、Angular和React Native一起使用。除了React Native，它们都是同一个Dom测试库的包装器。学一次，到处用。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d8a0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">酶的设置</h1><p id="2e3d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">酶的设置相对容易。为您想要使用的React版本选择正确的适配器:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="5eb8" class="oo mr it oh b gy op oq l or os">npm i --save-dev enzyme enzyme-adapter-react-16</span></pre><p id="172d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为库配置创建一个<code class="fe oe of og oh b">setup.js</code>文件。将<code class="fe oe of og oh b">Enzyme</code>与先前安装的适配器绑定。</p><p id="9107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，它将是<code class="fe oe of og oh b">react-16</code>:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="d1bc" class="oo mr it oh b gy op oq l or os">import { configure } from 'enzyme';</span><span id="cba6" class="oo mr it oh b gy ot oq l or os">import Adapter from 'enzyme-adapter-react-16';</span><span id="0c75" class="oo mr it oh b gy ot oq l or os">configure({ adapter: new Adapter() });</span></pre><p id="1624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，你就完成了。适配器包含所有特定于React的实现，而<code class="fe oe of og oh b">'enzyme'</code>包包含核心。</p><p id="542f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要执行完整的DOM渲染，你需要确保你设置了一个像<code class="fe oe of og oh b">Jsdom</code>这样的无头浏览器。默认情况下，这是Jest附带的，我推荐使用Jest，因为它很棒。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c0d7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">React测试库的设置</h1><p id="f040" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这种设置更容易。您只需要安装库，就可以开始了:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="53f2" class="oo mr it oh b gy op oq l or os">npm install --save-dev @testing-library/react</span></pre><p id="4339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React测试库也使用<code class="fe oe of og oh b">Jsdom</code>来呈现它的组件。如前所述，<code class="fe oe of og oh b">Jsdom</code>是为测试目的而设计的网络浏览器的一个子集。</p><p id="ed83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用Jest，你已经设置好了。你可以在文档中查看更多关于Jest环境配置<a class="ae ky" href="https://jestjs.io/docs/en/configuration.html#testenvironment-string" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="c9b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他测试提供者可能需要一些进一步的安装，比如<code class="fe oe of og oh b">jasmine</code>:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="0e21" class="oo mr it oh b gy op oq l or os">npm install --save-dev @testing-library/jasmine-dom</span></pre><p id="eed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在使用Jest，你会发现<code class="fe oe of og oh b">testing-library/jest-dom</code>相当有用。它有一大群观察者，会让你的生活更轻松。安装好之后，只需要导入即可。您可以像前面一样创建一个安装文件，并将导入文件放在那里:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="70a5" class="oo mr it oh b gy op oq l or os">import ‘@testing-library/jest-dom’;</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1b8f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">不同的心态</h1><p id="a14c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这两个库可能看起来很相似，但是它们对如何测试组件的理解是不同的。这意味着当使用它们时，你必须接受它们的提议。</p><h2 id="57ff" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">1.适配器与DOM</h2><p id="bb20" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">马上，我们注意到一个关键的区别:酶需要一个适配器来连接特定的反应库。这意味着当我们试图升级到一些React版本时，这个库会阻碍我们。React中的突破性变化将反映在适配器中。那些突破性的变化大多会传播到您的测试中。</p><p id="0f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，React测试库不知道所使用的React版本，甚至不知道React本身。它只是提供了一些薄薄的React包装器来呈现组件。这使得设置和使用更加容易。这使它成为一个轻量级的库。</p><h2 id="3adb" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">2.翻译</h2><p id="8ab1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Enzyme和React测试库都使用无头浏览器来呈现DOM(例如<code class="fe oe of og oh b">Jsdom</code>)。然而，他们的方法不同:</p><p id="4127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Enzyme允许您在浅DOM渲染和全DOM渲染之间进行选择。</p><ul class=""><li id="3dc8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">浅层:这有助于约束自己将组件作为一个单元来测试，并确保您的测试不会间接断言子组件的行为。</li><li id="9a6e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">完整的DOM呈现:<strong class="lb iu"> </strong>这非常适合于这样的用例:您的组件可能会与DOM APIs交互，或者需要测试包装在更高阶组件中的组件。</li></ul><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="7874" class="oo mr it oh b gy op oq l or os">// using shallow or full DOM render</span><span id="c002" class="oo mr it oh b gy ot oq l or os">import { shallow, mount } from 'enzyme';</span></pre><p id="f305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都返回一个附加了组件实例的<a class="ae ky" href="https://github.com/cheeriojs/cheerio" rel="noopener ugc nofollow" target="_blank"> Cheerio </a>包装器。它基本上是一个类似jQuery的工具，用来遍历DOM节点。</p><p id="acfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React测试库将只在<code class="fe oe of og oh b">Jsdom</code>上呈现组件，并为您提供遍历它所需的查询工具。</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="b2b1" class="oo mr it oh b gy op oq l or os">// more similar react api</span><span id="b344" class="oo mr it oh b gy ot oq l or os">import { render } from '@testing-library/react'</span></pre><h2 id="6beb" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">3.模仿与真正的DOM测试</h2><p id="a41c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在浅DOM和全DOM之间进行选择，就像在对组件进行单元测试或集成测试之间做出决定一样。</p><p id="882b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当试图对React组件中的方法进行单元测试时，Enzyme大放异彩。浅层渲染对此非常有用。它允许您以隔离的方式测试该组件。浅层渲染不会渲染目标的任何子组件。如果这是您所追求的，那么这就是您的完美用例。</p><p id="b9af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:浅渲染不会渲染组件的钩子，因为它们本质上是另一个组件。</p><p id="309f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React测试库不相信为单元测试确定组件的范围。恰恰相反。它只关心测试用户和浏览器之间的交互。它不鼓励编写脆弱的单元测试。</p><p id="c563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何复杂的逻辑都不应该存在于组件中，这就是为什么React测试库不关注那个层次的测试。业务逻辑应该从组件中分离出来。通过这样做，您可以仅使用Jest对其进行单元测试。</p><h2 id="f4d6" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">4.组件的状态</h2><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="d7b1" class="oo mr it oh b gy op oq l or os">const component = mount(&lt;LoginForm /&gt;); // LoginForm is a class Component</span><span id="e012" class="oo mr it oh b gy ot oq l or os">expect(wrapper.instance().state.showButton).toBe(true);</span></pre><p id="3883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React测试库的目的不是基于状态进行检查。当用它测试某个东西时，你应该想，“用户关心这个吗？”如果不是，那你也不应该。</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="b4aa" class="oo mr it oh b gy op oq l or os">For example: does the user care about the component's internal state? No. Then you shouldn’t care either when testing.</span></pre><p id="c082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React测试库只关心用户将会体验到什么。它不关心如何做到这一点。</p><h2 id="9353" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">5.钩住</h2><p id="b959" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">有了钩子，你就不能再用酶来断言对抗<code class="fe oe of og oh b">state</code>了。功能组件的<code class="fe oe of og oh b">state</code>道具将始终是<code class="fe oe of og oh b">null</code>。你可以通过嘲讽<code class="fe oe of og oh b">useState</code>来绕过它，但你不想走上那条路。</p><p id="cb57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这证明了将您的测试与库耦合可能会导致灾难。当您将旧的状态组件迁移到钩子时，您将不得不重写您的测试。如果这些是与供应商无关的，那就不会发生了。</p><p id="e2ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何测试钩子呢？推荐的方法是在组件内部呈现这些挂钩，并通过查看DOM来观察它们产生的副作用。Enzyme和React测试库都有一些专用于钩子的库，但是如果可能的话应该避免使用它们。</p><p id="a772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个库的钩子测试方法是相似的:观察副作用。</p><h2 id="ab25" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">6.传统选择器与可访问性</h2><p id="327f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">React测试库确实鼓励您像实际用户一样访问元素:通过文本、类型，甚至通过ARIA可访问性。它确实为那些极端情况提供了一个<code class="fe oe of og oh b">data-testId</code>，但这不是推荐的方式。如前所述，这个想法是为了更贴近用户的体验和交互。</p><p id="1f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过添加更多的ARIA元素来查找您的评论，您增加了应用程序的可访问性。因此，您同时使您的代码更加可靠和易于访问。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="04ea" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">快照测试</h1><p id="a00b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们回顾一下什么是快照测试:</p><blockquote class="nx ny nz"><p id="891b" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">“当您想要确保您的UI不会发生意外变化时，快照测试是一个非常有用的工具。</p><p id="faf9" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">一个典型的快照测试用例呈现一个UI组件，获取一个快照，然后将它与测试旁边存储的一个参考快照文件进行比较。”— <a class="ae ky" href="https://jestjs.io/docs/en/snapshot-testing" rel="noopener ugc nofollow" target="_blank">笑话文档</a></p></blockquote><p id="5fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就像在一个测试上拍一张组件树的照片，并将其与未来的测试进行比较，以确保没有任何意外的变化。</p><p id="bca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个库都通过以下方式支持快照测试:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="6e1d" class="oo mr it oh b gy op oq l or os">const { asFragment } = render(&lt;Login /&gt;);</span><span id="1b1f" class="oo mr it oh b gy ot oq l or os">const html = asFragment();</span><span id="2db2" class="oo mr it oh b gy ot oq l or os">expect(html).toMatchSnapshot();</span></pre><p id="9f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者:</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="eea6" class="oo mr it oh b gy op oq l or os"><em class="oa">const</em> component = shallow(&lt;Login debug /&gt;);<br/> <br/>expect(component).toMatchSnapshot();</span></pre><p id="984a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我不推荐使用快照测试。快照测试背后的意图是好的。然而…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="b0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使人们同意快照测试，他们也同意它是一个例外——不应该被滥用。当进行快照测试时，开发人员经常无法仔细检查更改，只是简单地更新快照，这样测试就能通过。在代码评审过程中，很难验证这些更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="349c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，即使它看起来很棒，也要谨慎使用。否则，这将是一个需要更新的无用测试。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ef80" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">样本测试代码</h1><p id="8cc1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们创建一个简单的<code class="fe oe of og oh b">LoginForm</code>来比较这两种测试方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf oj l"/></div></figure><h2 id="5cfc" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">酶样品测试</h2><p id="9868" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们将看到一个用于遍历DOM的Enzyme工具的例子。它确实把你带回了那些jQuery时代。</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="14d4" class="oo mr it oh b gy op oq l or os">// Traversing the DOM with Enzyme</span><span id="0213" class="oo mr it oh b gy ot oq l or os">wrapper.find('button')<br/>wrapper.find('input[name="password"]')</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf oj l"/></div></figure><p id="189e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到一切都依赖于从<code class="fe oe of og oh b">mount</code>方法返回的<code class="fe oe of og oh b">wrapper</code>。</p><h2 id="5c0c" class="oo mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">反应测试库样本测试</h2><p id="6608" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这个例子中，我们看到了轻量级查询访问器是如何返回的。我们得到类似<code class="fe oe of og oh b">getByLabelText</code>的查询方法。所有这些访问器都专注于ARIA可访问性。在这个例子中，通过添加<code class="fe oe of og oh b">role</code>属性，我们将使我们的代码更易于访问。</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="a1d9" class="oo mr it oh b gy op oq l or os">// Traversing the DOM with React Testing Library</span><span id="cf00" class="oo mr it oh b gy ot oq l or os">// will throw an error if it can't resolve to a node or finds more than one match<br/>getByRole('button');<br/>getByLabelText('password');</span><span id="8f7a" class="oo mr it oh b gy ot oq l or os">// will not throw an error<br/>findByRole('button');<br/>findByLabelText('password');</span></pre><p id="0cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">助手方法有一个更加函数化的方法。像<code class="fe oe of og oh b">fireEvent</code>这样的工具是独立的，这使得它们更直观，更容易使用。这就是为什么使用一些很酷的工具如<code class="fe oe of og oh b">user-event</code>是可能的。</p><pre class="kj kk kl km gt ok oh ol om aw on bi"><span id="8b7d" class="oo mr it oh b gy op oq l or os"><a class="ae ky" href="https://github.com/testing-library/user-event" rel="noopener ugc nofollow" target="_blank">https://github.com/testing-library/user-event</a></span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf oj l"/></div></figure><p id="b234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这种方法看起来比前一种更干净。它看起来更具有声明性和直观性。自定义匹配器(例如<code class="fe oe of og oh b">toHaveFormValues</code>)帮助测试使用更具声明性的方法。它们也减少了测试中的样板文件。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4308" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">包扎</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/af9331398c3f11196ad0cb4932ba731a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qff1ptvXeIDeFWLRFNy5jQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自JS 2020 的<a class="ae ky" href="https://2020.stateofjs.com/en-US/technologies/testing/" rel="noopener ugc nofollow" target="_blank">状态的照片。</a></p></figure><p id="965c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一幅图像有时胜过千言万语。React测试库很快就成功了。它有很多优点。它只要求新用户做一件事:改变心态。</p><p id="ef35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们的组件尽可能的简单，没有业务逻辑，只关心用户如何与它们交互。让我们忘记单元测试组件的方法，开始关注用户将会体验到什么。</p><p id="0840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你真的致力于它，并努力尝试，你可以用这种心态酶。问题是，它不是为使用而建造的。只是碰巧有可能。</p><p id="8677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，您可以在项目中同时使用这两种方法。它们可以共存。但是，你需要了解他们的动机，才能明白他们的闪光点在哪里。</p><p id="ef33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢测试，并且对嘲讽工具如何工作很好奇，可以看看我关于代理的文章。我使用ES6代理特性用普通JavaScript复制了一些Jest API:</p><div class="ph pi gp gr pj pk"><a href="https://medium.com/better-programming/mastering-es6-proxies-ced4253bc661" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">掌握ES6代理</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">用真实的例子实现代理</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">medium.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div><p id="e279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将来会有更多的测试内容。干杯！</p></div></div>    
</body>
</html>