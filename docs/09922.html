<html>
<head>
<title>Get Rid of Excessive If-Else Statements With Lookup and Hash Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用查找表和哈希表去掉过多的If-Else语句</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/get-rid-of-excessive-if-else-statements-with-lookup-and-hash-tables-c7dbed808996?source=collection_archive---------3-----------------------#2021-11-01">https://betterprogramming.pub/get-rid-of-excessive-if-else-statements-with-lookup-and-hash-tables-c7dbed808996?source=collection_archive---------3-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="94da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在所有专业代码库中使用的代码性能实践。通过这些简单的例子学习使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/881fae40008adb811d21bc8441f3904e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*psSuH4jCklAKOEYs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马修·费尼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fdd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">If-else语句是编程的一个主要部分，自从我们开始我们的旅程，我们就学会了使用它们。虽然它们是很好的工具，但并不总是最好的选择。例如，看看这个愚蠢的Python代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的If-else语句序列。</p></figure><p id="be18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个if-else序列不仅不必要的庞大，而且非常低效。此外，如果您不得不执行比调用函数更多的操作，这种代码模式会变得非常混乱。</p><p id="0f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于执行速度，连续检查所有if语句的条件意味着，例如，如果选择的字符是最后一个(龙)，程序将在找到正确的字符之前检查所有其他情况。用<a class="ae ky" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">的大O符号</a>来表示，随着输入大小的增长，用于根据速度或空间需求对算法进行分类，if-else语句序列将被分类为O(n/2)，或简称为O(n)。这意味着，随着要检查的案例数量的增加，执行该代码所需的时间呈线性增长。所以，想象一下有更多的角色可以选择。检查所有这些箱子需要多长时间？不必要的长。</p><h1 id="a0a0" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">什么是查找表和哈希表？</h1><p id="2119" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">查找表和哈希表是可以在运行时用简单的查找代替计算的数据结构，无论是简单的<a class="ae ky" href="https://en.wikipedia.org/wiki/Array_data_structure#Element_identifier_and_addressing_formulas" rel="noopener ugc nofollow" target="_blank">数组索引</a>还是通过<a class="ae ky" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">哈希函数</a>。这种表以内存和执行速度为代价，因为它们已经存储了计算结果。</p><p id="c465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说一下<a class="ae ky" href="https://www.mygreatlearning.com/blog/why-is-time-complexity-essential/#:~:text=Time%20Complexity%20Definition-,Time%20complexity,-is%20the%20amount" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>，索引一个查找表得分是一个常数<a class="ae ky" href="https://en.wikipedia.org/wiki/Lookup_table#:~:text=28%20August%202019.-,Limitations,-%5Bedit%5D" rel="noopener ugc nofollow" target="_blank"> O(1) </a>或者简单的说，不管有多少种情况都有可能，得到结果的时间总是一样的。散列表平均也会得分，<a class="ae ky" href="https://eng.libretexts.org/Courses/Folsom_Lake_College/CISP_430%3A_Data_Structures_(Aljuboori)/07%3A_Hash_Tables/7.01%3A_Time_complexity_and_common_uses_of_hash_tables" rel="noopener ugc nofollow" target="_blank"> O(1) </a>而在最差的情况下，虽然非常罕见，<a class="ae ky" href="https://eng.libretexts.org/Courses/Folsom_Lake_College/CISP_430%3A_Data_Structures_(Aljuboori)/07%3A_Hash_Tables/7.01%3A_Time_complexity_and_common_uses_of_hash_tables" rel="noopener ugc nofollow" target="_blank"> O(n) </a>。随着计算量的增加，这种查找和哈希表比一系列if-else语句更有效。记住if-else序列的时间复杂度是O(n)。</p><h1 id="cc04" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">使用案例和示例</h1><p id="3aea" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">那么，这些数据结构能用来做什么呢？让我们回到前一个例子，if语句的顺序。我们可以用哈希表来代替它们，哈希表在Python中也称为字典，在其他语言中称为映射。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="806d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，代码现在更加清晰了。我已经用角色和他们相应的动作创建了一个Python字典。然后，我在字典中查找给定的字符，如果它存在，就调用它的函数。</p><p id="085f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对if-else和dictionary方法进行基准测试之后，下面是获得每个字符的结果:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="15f9" class="mz ly it mv b gy na nb l nc nd">If statements: 12700 ns<br/>Hash table:    13000 ns</span></pre><p id="bc09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间差看似微不足道，但如果我们增加可能病例的数量呢？以下是可供选择的100和1000个字符的结果:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d7bb" class="mz ly it mv b gy na nb l nc nd"># 100 possible cases<br/>If statements: 561996 ns<br/>Hash table:     60057 ns</span><span id="defc" class="mz ly it mv b gy ne nb l nc nd"># 1000 possible cases<br/>If statements: 32682664 ns<br/>Hash table:      545019 ns</span></pre><p id="bc34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看到了吗？事例的数量越多，哈希表在执行速度方面就越优于if语句。</p><p id="0c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么查找表呢？让我们看看另一个代码示例，这次是用C语言编写的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我定义了一些令牌类型和函数，将给定令牌的类型打印到控制台。这个函数已经很混乱了，但是如果我们要定义许多其他可能的情况，就像在一个成熟的编译器实现中一样，它会很快失去控制。</p><p id="26b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是查找表的用处:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我定义了一个字符串常量数组，它表示要打印的令牌类型的名称。与前面的示例不同，该函数只需检查输入是否在范围内。它利用了枚举的属性，允许我们将它们的元素作为无符号整数使用。这意味着我们可以用枚举元素索引一个数组。不过，重要的是，枚举和对应的数组保持相同的元素顺序。</p><p id="9649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与if-else语句序列的O(n)相比，数组查找的时间复杂度得分为O(1)，这是一个显著的改进。在这种情况下，我不会展示基准，但我会更深入地了解这两种方法实际上生成了什么机器指令。感谢<a class="ae ky" href="https://godbolt.org/" rel="noopener ugc nofollow" target="_blank">编译器浏览器</a>，我们可以毫不费力地获得反汇编C代码的用户友好视图。</p><p id="c9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里你可以看到if-else序列的汇编指令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="cc2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，有许多指令组实际上执行相同的计算。无论是从程序的存储大小还是执行速度来看，这都不是很有效。</p><p id="2810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是查找表方法的组装视图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，在这种情况下，没有无用的重复。用于<code class="fe nf ng nh mv b">printTokenType()</code>功能的指令也明显更少，更重要的是，即使我们添加更多的<code class="fe nf ng nh mv b">TokenType</code>来选择，指令也保持不变。相反，if-else方法的功能将随着可能情况的增加而线性增长。</p><h1 id="b290" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">何时使用if语句</h1><p id="32c0" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">If语句的存在有一个很好的理由:它们简单快捷。如果if-else语句序列足够短，它很可能会比哈希表更快，尽管通常不会比数组查找更快。这意味着，在有限数量的可能情况下，if-else序列优于表。</p><p id="0a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种表的另一个必须考虑的特征是，无论是数字、字符串还是任何哈希数据结构(可以通过哈希函数传递的数据结构)，密钥在编译时都必须是常量和已知的。否则，编译器将不知道如何为？因此，函数的结果或用户输入不能用作键，除非表是在运行时动态构建的(与静态表相比，其性能有所下降)。</p><p id="4b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也有可能将if语句与表格结合起来。因为在少数情况下，if-else序列更快，所以您可以使用if-else序列执行最常见的检查，然后将其余的检查留给具有常数时间查找的表，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="2464" class="lx ly it bd lz ma np mc md me nq mg mh jz nr ka mj kc ns kd ml kf nt kg mn mo bi translated">结论</h1><p id="de61" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在本文中，我们探讨了如何以及何时利用查找表和哈希表，用更省时的算法替换if语句。</p><p id="914d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这些数据结构显然并不总是最好的想法，正如我们在最后一点中所看到的，但它们是供您使用的一个很好的资源。</p><blockquote class="nu"><p id="80be" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">为正确的工作使用正确的工具。</p></blockquote><p id="79f9" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>