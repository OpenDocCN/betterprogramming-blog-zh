<html>
<head>
<title>How to Create a SaaS Application and Host It on Vercel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建一个SaaS应用程序并在Vercel上托管它</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/host-saas-application-for-free-323a830e762?source=collection_archive---------13-----------------------#2022-12-14">https://betterprogramming.pub/host-saas-application-for-free-323a830e762?source=collection_archive---------13-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c76e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速托管、预览和交付多租户SaaS应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d0b4ae907638feaa9efd0bf42515013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T26hJ5DNH2O7ldw2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="55fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代技术增强了我们的日常编码体验。几年前，我们需要大量的能力来实现一个简单的网站和托管它。时至今日，许多人仍然相信，为了构建和交付一个应用程序，我们需要一个多学科的团队。</p><p id="6bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多复杂的场景中确实如此，但是对于许多初创公司和简单的项目，我们使用的方法已经彻底改变了。得益于新技术，拥有基本开发能力的前沿开发人员或专业人员可以创建自己的应用程序。</p><p id="be45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看到如何利用云技术，通过使用Vue.js和几行配置来实现多租户应用程序。换句话说，我们将学习如何创建一个可供多个用户使用的基本SaaS应用程序。此外，该解决方案可以托管在一个Vercel fee层中，启动时无需花费一分钱。</p><p id="f834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这是怎么可能的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8307" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">路线图</h1><p id="c91a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们将讨论许多对理解该解决方案很重要的问题。你可以在GitHub上找到与这个例子相关的所有源代码(文末链接)。演示应用程序是一个笔记本，允许用户在云端写笔记，就像Evernote或One Note等生产力工具一样。</p><p id="a2df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为一行一行地解释所有的源代码是不可能的，所以我将把重点放在最重要的步骤上:</p><ol class=""><li id="036c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">如何在不是后端开发者的情况下实现后端</li><li id="8476" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">实现前端</li><li id="c034" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">如何免费托管应用程序</li></ol><p id="4069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一步一步开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何免费托管应用程序</h1><p id="c296" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个应用程序使用Vercel来托管前端和后端。在我写这篇文章的时候，Vercel有一个免费层来托管任何前端应用程序(参见<a class="ae ky" href="https://vercel.com/pricing#plan-compare" rel="noopener ugc nofollow" target="_blank">价格页面</a>了解限制)。</p><p id="f9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常有趣的部分是对无服务器功能的支持，事实上，这使得应用程序功能齐全。在免费层，我们有100 GB小时的限制(每个请求使用的RAM乘以时间的乘积)，但可以通过购买付费计划来克服。</p><p id="1a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vercel直接连接到您的git存储库，构建源代码并发布它。如果您想了解更多信息，可以阅读文章“<a class="ae ky" href="https://medium.com/better-programming/how-to-deploy-an-existing-application-with-vercel-cfcd314e5396" rel="noopener"> <em class="nn">使用Vercel </em> </a>部署应用程序”。</p><p id="7ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为所有我们需要知道的已经在上面提到的文章中被告知，我将只解释最重要的步骤。</p><ol class=""><li id="68a1" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">首先，你要在Vercel上创建一个项目。完成后，您将看到下一个屏幕:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/8f82866650f13da0fef36855d2b7bdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5XgcbL8wxpmq2-FosZyN4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建项目后。</p></figure><p id="e594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.你必须点击“连接”并选择你的git库。请参见下图</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/38779e742f66b6afd00416e9c568e664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPEvTHnI4jmRM5H3YrDtwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择正确的git存储库</p></figure><p id="5d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.在下一次推送到主分支时，应用程序将被发布。之后，您将在项目面板中看到项目状态、链接和详细信息，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/3d41003f44f613e139c9be268de34b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDg1j_HUu_iE9CHCiKRUFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Vercel中的项目面板</p></figure><p id="918b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们找到了托管的解决方案，让我们看看如何实现后端。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何在不是后端开发人员的情况下实现后端</h1><p id="ab26" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">其中最关键的部分就是开发者的专业化。许多前端开发人员有很好的想法，但当开始实施时，他们发现没有强大的后端体验很难做一些事情。</p><p id="4962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，这种差距可以通过采用无头的低代码平台来填补，如<a class="nr ns ep" href="https://medium.com/u/ace2e82e28e6?source=post_page-----323a830e762--------------------------------" rel="noopener" target="_blank"> Strapi </a>或<a class="nr ns ep" href="https://medium.com/u/5a131a53c7b2?source=post_page-----323a830e762--------------------------------" rel="noopener" target="_blank"> Contentful </a>，但在某些情况下，这可能是一种不必要的依赖。</p><p id="dca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我将向您展示如何通过采用CrudIt(一个通过API包装数据库的轻量级库)来获得一个很好的折衷方案。换句话说，这意味着我们有机会使用REST APIs访问所有数据。此外，<a class="ae ky" href="https://github.com/zeppaman/crudit" rel="noopener ugc nofollow" target="_blank"> CrudIt </a>通过<em class="nn">每用户db</em>策略支持本地多租户环境。这就是我们所需要的！</p><p id="2c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的步骤中，我将描述如何集成它。</p><ol class=""><li id="cd81" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">运行<code class="fe nt nu nv nw b">npm install --save crudit</code>。此命令将在您的项目中安装软件包。</li><li id="106e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在<code class="fe nt nu nv nw b">api</code>文件夹中创建一个名为<code class="fe nt nu nv nw b">handler.mjs</code>的文件。我们本地的路径将是<code class="fe nt nu nv nw b">api/handlre.mjs</code>，而Vercel上的URL将是<code class="fe nt nu nv nw b"><a class="ae ky" href="http://yourpath/api/handler" rel="noopener ugc nofollow" target="_blank">http://yourpath.vercel.io/api/handler</a></code></li><li id="e59a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">添加到<code class="fe nt nu nv nw b">handler.mjs</code>以下代码:</li></ol><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="d81a" class="ob md it nw b be oc od l oe of">import {crudy,database} from 'crudit' ;<br/>import {IncomingMessage, ServerResponse} from 'http'<br/>import crypto from 'crypto'<br/><br/><br/> crudy.config(function(config){<br/>  config.settings.roles=['owner'];<br/>});<br/><br/>export default async function handler(request, response) {  <br/>  return await crudy.run(request,response);<br/>}</span></pre><p id="ef10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这段代码，您就有了一个rest端点，可以自动浏览数据。例如，您可以通过在<code class="fe nt nu nv nw b"><a class="ae ky" href="http://yourpath/api/handler" rel="noopener ugc nofollow" target="_blank">http://yourpath.vercel.io/api/handler</a>?collection=notes</code>上调用<code class="fe nt nu nv nw b">GET</code>请求来列出来自<code class="fe nt nu nv nw b">notes</code>集合的所有数据。</p><p id="b47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照REST标准，您可以发送一个post来插入一个新行，打补丁来更新几个字段等等。这很好，但是安全性呢？让我们在下一节看看</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4450" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">CrudIt中的多租户</h1><p id="d08d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/zeppaman/crudit" rel="noopener ugc nofollow" target="_blank"> CrudIt </a>基于用户和用户角色实现其授权机制，其中您可以逐个实体地指定哪些数据可以看到用户。在这个例子中，我们想为每个用户创建一个数据库，让他看到自己的所有内容。</p><p id="03b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，第一步是实现authenticate方法。假设我们有一个存储用户和用户令牌的集合，我们有这样的东西:</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="6dfd" class="ob md it nw b be oc od l oe of">crudy.authorize(async function(request){<br/>let token=request.headers.authorization ?? request.query.authorization;<br/>let users=await database.aggregate('global','users',[{<br/>    $lookup:<br/>    {<br/>        from: 'tokens',<br/>        localField: '_id',<br/>        foreignField: 'userId',<br/>        as: 'token',<br/>    },<br/>    <br/>}, {<br/>    "$match": {<br/>        "token.token": token<br/>    }<br/>    }]);<br/>if(users==null || users.length!=1) return  null;<br/>let user=users[0];<br/>return {<br/>    name:user.name,<br/>    roles:['owner'],<br/>    database:user.db<br/>};<br/><br/>});</span></pre><p id="0647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，查询从请求中获取身份验证令牌，使用它从数据库中获取数据(查询获取与令牌相关的用户)，并返回包含用户数据的对象。CrudiIt引擎使用该对象来决定用户是否可以访问数据。当然，您可以替换这段代码来支持任何JWT或Oauth2令牌，也可以支持旧式的基于cookie或BasicAuth登录。</p><p id="722a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如何实现登录和注册端点呢？为此，您可以实现一个端点。您可以在CrudIt引擎中注册一个端点，而不是为Vercel创建一个新的处理程序。这还具有可移植性的优点，因为它不会因服务器而改变(在Vercel、express或任何其他Node.js服务器上都是如此)。注册端点可能是这样的:</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="97e1" class="ob md it nw b be oc od l oe of">crudy.request("register", "post",false,async function(request,loggedUser, settings){<br/>    let user=request.body;<br/>    user.password= crypto.createHash('md5').update(user.password).digest('hex');<br/>    //Create a unique and valid db name escaping the username<br/>    user.db=("c_"+user.username??'sdff').normalize('NFD')<br/>            .replace(/[\u0300-\u036f]/g, '')<br/>            .toLowerCase()<br/>            .trim()<br/>            .replace(/[^a-z0-9 ]/g, '')<br/>            .replace(/\s+/g, '-');<br/>    //save it<br/>    user= await database.insert("global","users",user); <br/>    return user;<br/>});</span></pre><p id="d523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的代码片段将该函数绑定到了<code class="fe nt nu nv nw b">POST</code>方法和register动作，因此您将能够通过以下方式调用它:</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="d77d" class="ob md it nw b be oc od l oe of">curl --location --request POST 'http://localhost:3000/api/handler?action=register' \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/>    "password":"mypass",<br/>    "username":"testuser",<br/>    "name":"My Name",<br/>}'</span></pre><p id="bd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个创建新用户散列密码的端点，我们可以如下实现登录:</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="8f8d" class="ob md it nw b be oc od l oe of">crudy.request("login", "post",false,async function(request,loggedUser, settings){<br/>    database.init(process.env.DBURL, {});<br/>    let hash= crypto.createHash('md5').update(request.body.password).digest('hex');<br/>    let user= await database.search("global","users",{username:request.body.username, password:hash});<br/>    if(!user || user.length!=1) throw new Error("Wrong username and password");<br/>    user=user[0];<br/>    let newToken= crypto.randomBytes(64).toString('hex');<br/>    let token={userId: user._id,token: newToken};<br/>    token=await database.insert("global","tokens",token);  <br/>    return {token: newToken};<br/>  });</span></pre><p id="5de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的脚本验证用户名和密码，如果数据正确，它会创建一个令牌并将其返回给用户。该令牌将被传递到身份验证头中，并由身份验证方法进行验证。</p><h2 id="2843" class="og md it bd me oh oi dn mi oj ok dp mm li ol om mo lm on oo mq lq op oq ms or bi translated">细节至关重要:轻松实现多租户</h2><p id="1b8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在上一节中，我们看到了用户如何能够调用API来注册和登录。顺便说一下，有一个小细节使得实现多租户系统成为可能。在注册阶段，会为用户分配一个数据库名称:</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="ddbf" class="ob md it nw b be oc od l oe of">//...<br/>user.db=("c_"+user.username??'sdff')//userneame is used as database name<br/>//...<br/>return {<br/>    name:user.name,<br/>    roles:['owner'],<br/>    database:user.db<br/>};</span></pre><p id="22a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，进入认证阶段，该信息用于在数据库中定义必须完成的CRUD操作。这与<a class="nr ns ep" href="https://medium.com/u/db5cd12199bd?source=post_page-----323a830e762--------------------------------" rel="noopener" target="_blank"> MongoDB </a>能够在添加数据时创建集合和数据库的事实相结合，使得用几行代码创建完全多租户的环境成为可能！</p><p id="8b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不满意，我们可以更深入地了解如何使用后端在Vue中创建一个真正的SPA应用程序。Js！开始读下一节吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1446" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现前端</h1><p id="54f8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这个例子中，我使用了一个Vue.js应用程序，该应用程序使用Vuetify，这是一个实现材料设计模式的框架。不可能讨论所有细节，所以我将只关注最相关的部分:</p><ol class=""><li id="4c63" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">创建连接到后端的服务层</li><li id="ae7b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">自动验证请求</li><li id="dcb3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">实现登录/注册表单</li><li id="3010" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">实现notes功能</li></ol><p id="8fb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是将一些公共方法添加到所有组件中，以便与后端引擎进行交互。在本例中，我创建了一个MixIn，它在Vue中自动包含了所有组件的方法。这个特性由下一段代码完成:</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="d1ff" class="ob md it nw b be oc od l oe of">Vue.mixin({<br/>    methods: {<br/>      insertOrUpdate: async function(entity, data) {<br/>        //omitted for brevity<br/>      },<br/>      patch:  async function (entity, data){<br/>        delete data._meta;<br/>        return  this.simplifyResponse(  await this.apiCall(url,'PATCH',data,{collection: entity}));<br/>  <br/>      },<br/>      remove:  async function (entity, data){<br/>        //omitted<br/>      },<br/>      get:  async function (entity, id){<br/>        //omitted <br/>      },<br/>      search:  async function (entity, filter, projection){<br/>        return  this.simplifyResponse(await this.apiCall(url,'GET',null,<br/>         {collection: entity, <br/>          query: JSON.stringify(filter)??'{}',<br/>          projection: JSON.stringify(projection)??'{}'<br/>        }));<br/>      },<br/>    },<br/>  });</span></pre><p id="1f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个方法都包装了一个对API端点的HTTP调用，我们已经准备好了所有的CRUD操作。</p><p id="c685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们可以对数据库进行操作，我们就可以处理身份验证了。这可以通过添加一个Axios HTTP拦截器来实现。使用下一段代码，如果您得到一个<code class="fe nt nu nv nw b">401</code>(未登录或未授权)，您将被重定向到登录页面。此外，当用户登录时，用户令牌会自动添加到请求中。</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="c9e8" class="ob md it nw b be oc od l oe of">axios.interceptors.request.use(request =&gt; {<br/>  let userToken=localStorage.getItem('userToken');<br/>  if (userToken) {<br/>      request.headers.Authorization = `${userToken}`;<br/>  }<br/>  return request;<br/>});<br/><br/>axios.interceptors.response.use(function (response) {<br/>  return response;<br/>}, function (error) {<br/>  if (error.response &amp;&amp; 401 === error.response.status) {<br/>    document.location.href="/#/login";<br/>  } else {<br/>        return Promise.reject(error);<br/>    }});</span></pre><p id="1c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以实现一个登录表单和注册表单。它们都是简单的Vue组件，所以我在这里只报告登录组件(你可以在GitHub上找到所有的源代码)。我使用的模板如下</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="943c" class="ob md it nw b be oc od l oe of">&lt;v-container&gt;<br/>    &lt;v-row class="text-center"&gt;<br/>      &lt;v-col&gt;<br/>       &lt;h1&gt;login&lt;/h1&gt;<br/>       &lt;v-form&gt;<br/>        &lt;v-text-field v-model="username" type="text" label="login" /&gt;<br/>        &lt;v-text-field v-model="password" type="password" label="Password"/&gt;<br/>        &lt;v-btn @click="save" block &gt;Save&lt;/v-btn&gt;<br/>       &lt;/v-form&gt;<br/>      &lt;/v-col&gt;<br/>    &lt;/v-row&gt;<br/><br/>    &lt;v-row class="text-center"&gt;<br/>      &lt;v-col&gt;<br/>       &lt;v-subheader&gt; Not an user? &lt;a href="#" @click="$router.push({name:'register'})"&gt;Register&lt;/a&gt;&lt;/v-subheader&gt;<br/>      &lt;/v-col&gt;<br/>    &lt;/v-row&gt;<br/>  &lt;/v-container&gt;</span></pre><p id="6e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">javascript部分由下一段javascript描述:</p><pre class="kj kk kl km gt nx nw ny bn nz oa bi"><span id="e31c" class="ob md it nw b be oc od l oe of">export default {<br/>    name: 'Login',<br/>    beforeMount:async function(){<br/>       <br/>    },<br/>    methods:{<br/>        save: async function(data){<br/>            let response=await this.apiCall('/api/handler','POST',{username:this.username, password:this.password},{ action:"login"});<br/>            <br/>            if(response.status !=200 || response.data.hasError)<br/>            {<br/>              this.showError("login failed");<br/>            }<br/>            else<br/>            { <br/>              let user=response.data.data;<br/>              this.showSuccess("Hello "+user.name);<br/>              localStorage.setItem('userToken',user.token);<br/>              this.$router.push({name:'notes'});<br/>            }<br/>        }<br/>    },<br/>     data: () =&gt; ({<br/>      token:"",<br/>      username:"",<br/>      password:"",<br/>      })<br/>  }</span></pre><p id="24ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以使用已经存在的后端来实现我们的应用程序！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c15a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="da75" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">由于现代技术，创建多租户应用程序不再需要成为专家，由于云服务，托管不再痛苦。</p><p id="c9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，当应用程序的需求变得具有挑战性时，我们将需要面对复杂性(云的成本将变得相关，并且您仍然需要团队中不止一个成员)。</p><p id="315c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于一个简单的项目，MVP或初创公司来说，有一个简单的启动方式是非常重要的。随着项目变得越来越苛刻，我们将不得不在可持续发展中扩展应用程序。</p><p id="e496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考资料:</p><ul class=""><li id="ed3d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu os nf ng nh bi translated">CrudIt框架可以在GitHub上获得，由NPM交付。更多信息见项目页面<a class="ae ky" href="https://github.com/zeppaman/crudit" rel="noopener ugc nofollow" target="_blank">https://github.com/zeppaman/crudit</a></li><li id="8f99" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu os nf ng nh bi translated">你可以在官网上了解更多关于<a class="ae ky" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>的信息</li><li id="5faa" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu os nf ng nh bi translated">你可以在这里下载这个例子<a class="ae ky" href="https://github.com/zeppaman/crudit-demo" rel="noopener ugc nofollow" target="_blank">的源代码。</a></li></ul></div></div>    
</body>
</html>