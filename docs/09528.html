<html>
<head>
<title>How To Encode and Decode Any JSON Safely in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中安全地编码和解码任何JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-encode-and-decode-any-json-safely-in-swift-d5b2b8e2e1e3?source=collection_archive---------5-----------------------#2021-09-06">https://betterprogramming.pub/how-to-encode-and-decode-any-json-safely-in-swift-d5b2b8e2e1e3?source=collection_archive---------5-----------------------#2021-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c931" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编码和解码无模式JSON而不失去类型安全性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/92f44d687db012636a38688ae7a165b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GoQBYOckBk-gkfQH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">劳伦·曼克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="002f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发应用或库时，我们可能需要解析没有固定或已知模式的JSON。还可能发生这样的情况，我们需要编写一个API，允许我们的用户向服务发送不同类型的数据。典型的例子是这样的跟踪API:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a317" class="ma mb it lw b gy mc md l me mf">func logEvent(named name: String, metadata: [String: Any])</span></pre><p id="2251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，用户可以在元数据中放入自己想要的<code class="fe mg mh mi lw b">Any</code>东西:<code class="fe mg mh mi lw b">String</code>、<code class="fe mg mh mi lw b">Double</code>、<code class="fe mg mh mi lw b">Boolean</code>甚至更复杂的对象。</p><p id="8c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS自带的一些API可以帮助我们完成这项工作:<code class="fe mg mh mi lw b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/jsonserialization" rel="noopener ugc nofollow" target="_blank">JSONSerialization</a></code>。如果<code class="fe mg mh mi lw b">Data</code>是有效的JSON，这个API可以将<code class="fe mg mh mi lw b">Data</code>转换成<code class="fe mg mh mi lw b">[String: Any]</code>字典，反之亦然。</p><p id="1872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深入研究这个API，我们会发现它并没有我们想象的那么好:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e54c" class="ma mb it lw b gy mc md l me mf">class func jsonObject(with data: <a class="ae ky" href="https://developer.apple.com/documentation/foundation/data" rel="noopener ugc nofollow" target="_blank">Data</a>, options opt: <a class="ae ky" href="https://developer.apple.com/documentation/foundation/jsonserialization" rel="noopener ugc nofollow" target="_blank">JSONSerialization</a>.<a class="ae ky" href="https://developer.apple.com/documentation/foundation/jsonserialization/readingoptions" rel="noopener ugc nofollow" target="_blank">ReadingOptions</a> = []) throws -&gt; Any</span></pre><p id="12be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">JSONSerialization</code>的这个类函数把一些<code class="fe mg mh mi lw b">Data</code>转换成一个对象，对象的类型是<code class="fe mg mh mi lw b">Any</code>。要使用它，我们必须这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提取我们需要的数据，我们必须手动提取和转换JSON的每一层。我们需要预先知道数据类型，结果代码是危险的，或者很难阅读。</p><p id="412b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想使用补充的API，可能会发生更糟糕的事情:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4fd1" class="ma mb it lw b gy mc md l me mf">class func data(withJSONObject obj: Any, options opt: <a class="ae ky" href="https://developer.apple.com/documentation/foundation/jsonserialization" rel="noopener ugc nofollow" target="_blank">JSONSerialization</a>.<a class="ae ky" href="https://developer.apple.com/documentation/foundation/jsonserialization/writingoptions" rel="noopener ugc nofollow" target="_blank">WritingOptions</a> = []) throws -&gt; <a class="ae ky" href="https://developer.apple.com/documentation/foundation/data" rel="noopener ugc nofollow" target="_blank">Data</a></span></pre><p id="72e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数接受一个类型为<code class="fe mg mh mi lw b">Any</code>的对象，然后试图将其转换为某种<code class="fe mg mh mi lw b">Data</code>。然而，如果我们试图将不能直接编码的东西转换成JSON，例如<code class="fe mg mh mi lw b">Date</code>，会发生什么呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ba5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码看起来很合法。事实上，它编译没有错误。然而，当我们试图运行它时，应用程序崩溃，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/e64a31ba6e2d0f995712f69a27aedbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIcPypWzbhg52G5lNZAGmQ.png"/></div></div></figure><p id="7566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们试图将一个不是JSON原语的类型强制放入字典。这是一个合法的操作，因为字典的<code class="fe mg mh mi lw b">Value</code>是<code class="fe mg mh mi lw b">Any</code>，所以我们可以在里面放任何我们想要的东西。然后，我们要求系统将其转换为JSON。尽管在编译时一切看起来都很好，但事实并非如此。一个<code class="fe mg mh mi lw b">Date</code>不能直接编码成JSON类型。</p><p id="3ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们能在编译时捕捉到这些错误，那不是很好吗？幸运的是，我们可以编写一个好的、可扩展的解决方案来实现这一点。让我们看看如何！</p><h1 id="c31a" class="mm mb it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">JSON类型</h1><p id="fe76" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">解决方案是引入一种新的类型，我们称之为<code class="fe mg mh mi lw b">JSON</code>。这种类型严格描述了所有可以转换成JSON的值，并且只允许使用它们。</p><p id="575d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用下面的<code class="fe mg mh mi lw b">enum</code>来实现这样一个类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe mg mh mi lw b">enum</code>描述了我们可以放入JSON的所有合法类型。我想强调三种特殊情况:</p><ul class=""><li id="2e5b" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe mg mh mi lw b">case null</code> : JSON允许属性带有<code class="fe mg mh mi lw b">null</code>值，所以我们需要一种方法来表示它们。在Swift中，我们将这个值转换成一个<code class="fe mg mh mi lw b">nil</code>值。</li><li id="fb53" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mg mh mi lw b">indirect case array</code>和<code class="fe mg mh mi lw b">indirect case object</code> : Swift的枚举是值类型。编译器立即在内存堆栈上分配该值，因为它知道它占用了多少空间。然而，<code class="fe mg mh mi lw b">JSON</code>枚举是一个<strong class="lb iu">递归</strong>枚举。通常，编译器会尝试为一个JSON值分配空间，因为它可以包含另一个JSON值。这个JSON值可以包含另一个JSON值。以此类推，直到内存填满，应用崩溃。Swift需要一种方法来中断这种递归:关键字<code class="fe mg mh mi lw b">indirect</code>打破了这种递归，并允许我们安全地使用这种强大的工具。</li></ul><p id="b32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步就是让<code class="fe mg mh mi lw b">JSON</code>符合<code class="fe mg mh mi lw b">Codable</code>。<code class="fe mg mh mi lw b">JSON</code>包含一些相关值，Swift无法为我们合成<code class="fe mg mh mi lw b">Codable</code>实施。</p><h2 id="5ad5" class="ma mb it bd mn nw nx dn mr ny nz dp mv li oa ob mx lm oc od mz lq oe of nb og bi translated">实现可编码</h2><p id="e26c" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">实现非常简单，代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="06f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到编码部分时，我们预先知道我们想要在编码器的容器中插入的类型。我们可以切换<code class="fe mg mh mi lw b">JSON</code>值，并将相关内容插入到<code class="fe mg mh mi lw b">singleValueContainer</code>中。</p><p id="ef17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们考虑集合的情况(T0和T1)，实现不会改变——T3的T2知道如何编码它自己和它的T4，T6的T5知道如何编码它自己和它的内容。</p><h2 id="4c49" class="ma mb it bd mn nw nx dn mr ny nz dp mv li oa ob mx lm oc od mz lq oe of nb og bi translated"><strong class="ak">实现可解码</strong></h2><p id="3415" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">然后，我们需要实现<code class="fe mg mh mi lw b">Decodable</code>协议。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="024b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们不知道我们将从容器中获取哪种类型。因此，我们需要运行一个试错算法，尝试每一种可能的类型，如果我们失败了，我们继续下一种类型，直到我们找到正确的类型。</p><p id="7c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解码时，我们需要注意为类型选择的顺序。例如，如果我们在尝试使用<code class="fe mg mh mi lw b">Int</code>类型之前尝试将一个恰好是数字的值解码成一个<code class="fe mg mh mi lw b">Double</code>，我们将永远不会从这个过程中获得任何<code class="fe mg mh mi lw b">Int</code>。任何数字都可以放入一个<code class="fe mg mh mi lw b">Double</code>，因此<code class="fe mg mh mi lw b">Int</code>案例永远不会返回任何有意义的内容。如果我们尝试先解码<code class="fe mg mh mi lw b">Int</code>，而这个数字恰好是一个<code class="fe mg mh mi lw b">Double</code>，解码就会失败，因为它放不进一个<code class="fe mg mh mi lw b">Int</code>。算法将转移到下一个类型，成功解码一个<code class="fe mg mh mi lw b">Double</code>。</p><p id="1090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要处理无法解码接收数据的情况。在这种情况下，我们应该解码失败，抛出一个<code class="fe mg mh mi lw b">DecodingError</code>。但是，如果我们认真考虑一下，我们应该永远不会看到这个错误。</p><h2 id="c2db" class="ma mb it bd mn nw nx dn mr ny nz dp mv li oa ob mx lm oc od mz lq oe of nb og bi translated">使用JSON</h2><p id="4c65" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">现在是时候使用我们的枚举了。我们的类型符合Codable，所以我们可以使用标准的<code class="fe mg mh mi lw b">JSONEncoder</code>和<code class="fe mg mh mi lw b">JSONDecoder</code>来获得一个<code class="fe mg mh mi lw b">Data</code>表示或者一个<code class="fe mg mh mi lw b">JSON</code>表示。</p><p id="1c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想将一些<code class="fe mg mh mi lw b">Data</code>解码成JSON时，代码看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="98d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道JSON类型是一个enum。因此，我们可以安全地切换它的类型并提取我们需要的值。这种方法增加了很多代码，但是我们可以简化它。我们可以编写一个带有一些计算属性的扩展来返回一个特定的可选类型。</p><p id="03f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是扩展的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="27b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于可选的链接功能，这25行交换机变成了一行。</p><p id="c739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我们甚至可以做得更好，通过实现几个下标:如果下标的索引是一个<code class="fe mg mh mi lw b">Int</code>，我们可以假设类型是一个数组，我们可以移除所有的<code class="fe mg mh mi lw b">.array</code>类型提取；如果下标索引是一个<code class="fe mg mh mi lw b">String</code>，我们可以移除所有的<code class="fe mg mh mi lw b">.object</code>类型提取，使用反序列化的数据作为字典。最终结果将如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c0ff" class="ma mb it lw b gy mc md l me mf">let age = json["results"]?[0]?["userInfo"]?["age"]?.int</span></pre><p id="3cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看当我们有一个想要转换成<code class="fe mg mh mi lw b">Data</code>的<code class="fe mg mh mi lw b">JSON</code>对象时是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们创建了一个<code class="fe mg mh mi lw b">JSON</code>字典。在其中，我们定义了另一个名为<code class="fe mg mh mi lw b">person</code>的<code class="fe mg mh mi lw b">object</code>，它有两个字段<code class="fe mg mh mi lw b">name</code>和<code class="fe mg mh mi lw b">age</code>。</p><p id="570a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用标准的<code class="fe mg mh mi lw b">JSONEncoder</code>将其编码成一个对象。这就是我们一直在寻找的类型安全。</p><p id="54e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，的API看起来相当冗长，还有改进的空间。我们可以实现另一组扩展来使用文字创建<code class="fe mg mh mi lw b">JSON</code>值。</p><p id="7aee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift提供了一系列我们可以使用的<code class="fe mg mh mi lw b">ExpressibleBy&lt;Type&gt;Literal</code>协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="93a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这些小的扩展，我们可以重写编码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，代码基本上与<code class="fe mg mh mi lw b">[String: Any]</code>字典没有什么区别。我们甚至将不同的类型混合在一起。然而，这个字典是非常类型安全的；如果我们试图添加一个没有出现在<code class="fe mg mh mi lw b">JSON</code>枚举中的类型，它不会编译。</p><h1 id="9c15" class="mm mb it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="b535" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在今天的文章中，我们探讨了如何创建类型安全的<code class="fe mg mh mi lw b">JSON</code>实现。我们还探索了如何改进它的API以使它们更易于使用。</p><p id="b6e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种解决方案也易于扩展。为了支持其他类型，我们可以:</p><ul class=""><li id="2e77" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">在枚举中添加新案例</li><li id="11f6" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">实现一个编码策略</li><li id="8418" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">实施一个解码策略</li></ul><p id="ab70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到解码，我们需要注意解码顺序。如果底层类型是一个数字，记得在<code class="fe mg mh mi lw b">Double</code>之前尝试解码它。如果底层类型是一个具有特定格式的<code class="fe mg mh mi lw b">String</code>，我们应该在尝试将其解码为普通的<code class="fe mg mh mi lw b">String</code>之前尝试解码这个新类型。</p><p id="617e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这种方法，我们可以支持任何定制的数据类型，甚至<code class="fe mg mh mi lw b">URL</code>可以成为JSON的第一公民！</p></div></div>    
</body>
</html>