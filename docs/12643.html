<html>
<head>
<title>Leveraging TypeScript to Create Better Polymorphic React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用TypeScript创建更好的多态React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/polymorphic-react-components-in-typescript-b6ce455ca70e?source=collection_archive---------2-----------------------#2022-06-19">https://betterprogramming.pub/polymorphic-react-components-in-typescript-b6ce455ca70e?source=collection_archive---------2-----------------------#2022-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="99cf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写灵活的组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2782a44f6a84cd0d364892435645a05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WA9_9aYoZ9S3lJvkmxJ3WQ.png"/></div></div></figure><p id="c367" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可重用组件是React中的关键概念之一——您只需编写一个组件，就可以多次重用它们。</p><p id="eb6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，你的组件会接收一些道具，然后在内部使用这些道具，最后渲染一些React元素，这些元素会被转换成相应的DOM元素。</p><p id="bd0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，如果我的组件可以为我提供控制容器元素/节点的灵活性，那又会怎么样呢？这就是所谓多态性模式的起源。</p><h1 id="e4dd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">什么是多态组件？</h1><p id="dacf" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">根据定义，多形性意味着以一种以上的形式存在。</p><p id="8e2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在React组件的世界中，多态组件是可以用不同的容器元素呈现的组件。</p><p id="6bc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">也就是说，即使你以前可能从未听说过多态组件。这是一种代码重用模式，就像定制钩子、高阶组件等。</p><h1 id="faf0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">多态组件是如何工作的？</h1><p id="81db" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">假设我们有一个可共享的<code class="fe mk ml mm mn b">&lt;Box /&gt;</code>组件，我们想决定在两种不同的情况下实际的元素是什么，</p><ul class=""><li id="a732" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm mt mu mv mw bi translated">我们希望将Box组件呈现为具有<code class="fe mk ml mm mn b">href</code>属性的锚元素</li><li id="3afa" class="mo mp iq kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">我们希望Box组件是h1的标题元素。</li></ul><p id="b4b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，有了React中的多态性概念，我们可以通过向组件添加一个<code class="fe mk ml mm mn b">as</code>道具来允许调用者灵活地定义他们选择的HTML标签。</p><pre class="kg kh ki kj gt nc mn nd ne aw nf bi"><span id="2268" class="ng lo iq mn b gy nh ni l nj nk">&lt;Box as="a" href="https://www.linkedin.com/in/chisom-okoye-399112122/"&gt;<br/>   Home page<br/>&lt;/Box&gt;<br/><br/>&lt;Box as="h1"&gt;Main heading&lt;/Box&gt;</span></pre><h1 id="94af" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">基本实现</h1><p id="222a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">构建您的第一个多态组件非常简单，下面是一个基本实现:</p><pre class="kg kh ki kj gt nc mn nd ne aw nf bi"><span id="85d1" class="ng lo iq mn b gy nh ni l nj nk">export const Box =({as, children, ...others})=&gt; {<br/>   let Component = as || "span";</span><span id="88f2" class="ng lo iq mn b gy nl ni l nj nk">   return (<br/>       &lt;Component {...others}&gt;{children}&lt;/Component&gt;<br/>   )<br/>}</span></pre><p id="c20c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里需要注意的一点是，我们将<code class="fe mk ml mm mn b">as</code>道具默认为<code class="fe mk ml mm mn b">span</code>，以防用户不传递道具，它应该使用span作为HTML元素。</p><p id="5057" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，我们不能直接使用<code class="fe mk ml mm mn b">as</code>属性，因为React会认为它是一个HTML标签的名字(<code class="fe mk ml mm mn b">&lt;as&gt;</code>)，而事实并非如此。所以我们需要先把它赋给一个大写的变量，然后渲染它。</p><p id="20c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，<code class="fe mk ml mm mn b">...others</code>很重要，因为我们也将它扩展到了<code class="fe mk ml mm mn b">&lt;Component&gt;</code>中。这允许我们将我们不知道的附加属性或属性传递给底层元素。一个例子是标签<code class="fe mk ml mm mn b">&lt;a&gt;</code>所需的href属性或者用于图像<code class="fe mk ml mm mn b">&lt;img&gt;</code>的alt属性。</p><p id="e7a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是我们构建一个基本多态组件所需要的。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="4e2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，这种方法的问题是，没有办法阻止用户传入不受支持的道具或无效的HTML元素。也就是说，当我们使用这个组件作为<code class="fe mk ml mm mn b">h1</code>时，用户可能会试图传递<code class="fe mk ml mm mn b">href</code>属性，或者用户会为<code class="fe mk ml mm mn b">as</code>属性传递任何不是有效HTML元素的值。</p><p id="5a28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React中类型脚本的好处来了。</p><h1 id="8a9a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">利用Typescript创建更好的多态组件。</h1><p id="3433" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">为了利用typescript来创建一个没有bug、体验更好的多态组件，您需要首先确保react应用程序有typescript。要创建一个react typescript项目，你可以使用命令<code class="fe mk ml mm mn b">npx create-react-app project-name --template typescript</code>或将typescript添加到现有的react应用程序中，可以使用npm或yarn】。然后，随着对typescript中泛型的理解，我们可以收紧传递给组件的道具。</p><p id="3e79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更好的实施</p><pre class="kg kh ki kj gt nc mn nd ne aw nf bi"><span id="713e" class="ng lo iq mn b gy nh ni l nj nk">import { ComponentPropsWithoutRef, ElementType, ReactNode } from "react";<br/><br/>type BoxProps&lt;T extends ElementType &gt; = {<br/>  as?: T;<br/>  children: ReactNode;<br/>};<br/><br/>export const  Box =&lt;T extends ElementType = "span"&gt;({<br/>as, <br/>children, <br/>...others<br/>}: BoxProps&lt;T&gt; &amp; ComponentPropsWithoutRef&lt;T&gt;) =&gt; {<br/>   let Component = as || "span";<br/><br/>   return (<br/>       &lt;Component {...others}&gt;{children}&lt;/Component&gt;<br/>   )<br/>}</span></pre><p id="4651" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里所做的基本上是为Box组件创建一个类型</p><pre class="kg kh ki kj gt nc mn nd ne aw nf bi"><span id="b20e" class="ng lo iq mn b gy nh ni l nj nk">type BoxProps&lt;T extends ElementType&gt; = {<br/>  as?: T;<br/>  children: ReactNode;<br/>};</span></pre><p id="e8cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解释:</p><p id="3e50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中<code class="fe mk ml mm mn b">T extends ElementType</code>是一个泛型类型，说明T是参数的一个特殊变量类型，在我们的例子中参数是<code class="fe mk ml mm mn b">as</code>，那么<code class="fe mk ml mm mn b">extends ElementType</code>意味着我们将泛型约束为一个有效的HTML元素，也就是说<code class="fe mk ml mm mn b">as</code>不能接收不是正确的HTML元素的值。</p><p id="0b7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样值得注意的是，附加到<code class="fe mk ml mm mn b">as</code>的<code class="fe mk ml mm mn b">?</code>操作符使其成为可选的，因此当组件没有接收到<code class="fe mk ml mm mn b">as</code>属性时，typescript不会报告这个错误。而儿童道具应该是<code class="fe mk ml mm mn b">ReactNode</code>型。</p><p id="d1ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在创建<code class="fe mk ml mm mn b">Box</code>组件的时候，你可以看到我们的泛型类型<code class="fe mk ml mm mn b">T</code>被赋给了“span ”,这意味着当用户没有传递任何元素时，<code class="fe mk ml mm mn b">as</code> props的默认元素将是<code class="fe mk ml mm mn b">span</code>。然后我们利用我们创建的<code class="fe mk ml mm mn b">BoxProps</code>类型作为我们期望的参数的类型。</p><p id="3e6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<code class="fe mk ml mm mn b">Box</code>组件的下一个奇怪的语法是<code class="fe mk ml mm mn b">&amp; ComponentPropsWithoutRef&lt;T&gt;</code>。</p><p id="08dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您来自Styled-components，那么您不会对这个语法感到陌生，因为它实际上是用于样式化伪代码的语法格式:</p><pre class="kg kh ki kj gt nc mn nd ne aw nf bi"><span id="e5f0" class="ng lo iq mn b gy nh ni l nj nk">a {<br/>      color : blue;<br/>         &amp;:hover{<br/>            color: red;<br/>        }<br/>   }</span></pre><p id="272c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在TypeScript中，我们提取了这种格式，并引入了所谓的交集，这意味着类型<code class="fe mk ml mm mn b">BoxProps</code>是包含<code class="fe mk ml mm mn b">as</code>、<code class="fe mk ml mm mn b">children</code>的对象类型，并且基于<code class="fe mk ml mm mn b">as</code>属性的类型，我们将返回与传递的字符串属性相关的有效组件属性。</p><h1 id="2714" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="562f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">也就是说，如果我们继续错误地尝试我们的<code class="fe mk ml mm mn b">&lt;Box /&gt;</code>组件，例如通过传递一个有效的<code class="fe mk ml mm mn b">as</code>道具和其他不兼容的道具，你将得到一个错误。</p><pre class="kg kh ki kj gt nc mn nd ne aw nf bi"><span id="1982" class="ng lo iq mn b gy nh ni l nj nk">&lt;Box as="h1" href="https://www.linkedin.com/in/chisom-okoye-399112122/"&gt;<br/>    Main heading<br/>&lt;/Box&gt;</span></pre><p id="ffdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">h1</code>是<code class="fe mk ml mm mn b">as</code>道具的完美HTML元素，但是<code class="fe mk ml mm mn b">h1</code>元素不应该有<code class="fe mk ml mm mn b">href</code>属性。这是错误的，在运行时，typescript将帮助捕捉这个错误，因为:类型上不存在属性<code class="fe mk ml mm mn b">'href'</code>...</p><p id="3648" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很好，因为我们获得了更好的开发者体验和更好的健壮解决方案。</p></div></div>    
</body>
</html>