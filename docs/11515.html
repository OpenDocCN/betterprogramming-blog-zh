<html>
<head>
<title>Combining GraphQL Schemas for Federated Subgraphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组合联邦子图的GraphQL模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/combining-graphql-schemas-for-federated-subgraphs-c50c5e8e9de0?source=collection_archive---------4-----------------------#2022-03-27">https://betterprogramming.pub/combining-graphql-schemas-for-federated-subgraphs-c50c5e8e9de0?source=collection_archive---------4-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6f66" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将多个模式文件转换成一个</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36fabccf2511628a305b3a8f7b373891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FBmwqiNujXjLydKA"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="be5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">TL；DR — </em> <code class="fe lt lu lv lw b"><em class="ls">@graphql-tools/utils</em></code> <em class="ls">导出</em> <code class="fe lt lu lv lw b"><em class="ls">printSchemaWithDirectives</em></code> <em class="ls">函数将您的</em> <code class="fe lt lu lv lw b"><em class="ls">GraphQLSchema</em></code> <em class="ls">对象转换回模式字符串。</em></p><p id="e27b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在计划将一个monolith GraphQL服务器迁移到Apollo Federation时，出现了一个有趣的难题。我们的模式被分割成多个文件，以减轻六个团队在同一个模式上工作的痛苦，我们使用<code class="fe lt lu lv lw b"># import</code>语法将它们连接在一起。</p><p id="7d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇简短的博客中，我将解释我们如何能够将这些多个文件合并成一个文件，然后可以用它来创建一个联邦网关的起始子图。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="abac" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">模式文件</h1><p id="70d0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">出于本文的目的，我已经创建了4个文件来表示分布在多个<code class="fe lt lu lv lw b">.graphql</code>文件中的模式。</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="0cda" class="nf mf iq lw b gy ng nh l ni nj">// schema.graphl</span><span id="99a5" class="nf mf iq lw b gy nk nh l ni nj"># import Post from "posts.graphql"</span><span id="8fdd" class="nf mf iq lw b gy nk nh l ni nj">type Query {<br/>  posts: [Post]<br/>}</span><span id="1805" class="nf mf iq lw b gy nk nh l ni nj">// posts.graphql</span><span id="9d3c" class="nf mf iq lw b gy nk nh l ni nj"># import Comment from 'comments.graphql'</span><span id="19b0" class="nf mf iq lw b gy nk nh l ni nj">"""<br/>A post with comments<br/>"""<br/>type Post {<br/>  comments: [Comment]<br/>  id: ID!<br/>  text: String!<br/>  tags: [String]<br/>}</span><span id="039c" class="nf mf iq lw b gy nk nh l ni nj">// comments.graphql</span><span id="d5ce" class="nf mf iq lw b gy nk nh l ni nj"># import uppercase from './directives.graphql'</span><span id="2ea9" class="nf mf iq lw b gy nk nh l ni nj">type Comment {<br/>  id: ID!<br/>  text: String! <a class="ae kv" href="http://twitter.com/uppercase" rel="noopener ugc nofollow" target="_blank">@uppercase</a><br/>}</span><span id="d834" class="nf mf iq lw b gy nk nh l ni nj">// directives.graphql</span><span id="80b0" class="nf mf iq lw b gy nk nh l ni nj">directive @uppercase on FIELD_DEFINITION</span></pre><p id="0e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些文件展示了各种常见的模式语法，包括嵌套类型(即<code class="fe lt lu lv lw b">Comment</code>)、注释(即<code class="fe lt lu lv lw b">Post</code>)和指令(即<code class="fe lt lu lv lw b">@uppercase</code>)</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="27d8" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">加载模式</h1><p id="a7a0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">graphql-tools为我们提供了将所有这些模式文件加载到单个GraphQLSchema对象中所需的函数，然后我们可以<code class="fe lt lu lv lw b">print</code>取出该对象。如果您继续进行，在您编写模式文件的同一个目录中创建一个新的节点包；</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="3889" class="nf mf iq lw b gy ng nh l ni nj">$ npm init -y<br/>$ npm i -D graphql @graphql-tools/graphql-file-loader @graphql-tools/load</span></pre><p id="cd89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以用这个简短的脚本将模式文件加载到单个对象中</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="2629" class="nf mf iq lw b gy ng nh l ni nj">const { loadSchemaSync } = require("<a class="ae kv" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/load");<br/>const { GraphQLFileLoader } = require("<a class="ae kv" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/graphql-file-loader");</span><span id="dcc5" class="nf mf iq lw b gy nk nh l ni nj">const schema = loadSchemaSync("./schema.graphql", {<br/>  loaders: [new GraphQLFileLoader()],<br/>});</span></pre><p id="c061" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b"># import</code>关键字告诉<code class="fe lt lu lv lw b">loadSchemaSync</code>函数在哪里可以找到所需的类型，只要您的模式文件中没有任何语法错误，这个函数就会正确执行。</p><h1 id="2909" class="me mf iq bd mg mh nl mj mk ml nm mn mo jw nn jx mq jz no ka ms kc np kd mu mv bi translated">打印模式</h1><p id="beb1" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><code class="fe lt lu lv lw b">graphql-tools/utils</code>公开了另一个有用的函数<code class="fe lt lu lv lw b">printSchemaWithDirectives</code>，它构建在<code class="fe lt lu lv lw b">graphql.js</code>包的<code class="fe lt lu lv lw b">printSchema</code>函数之上。使用这个，我们可以添加到我们之前的脚本中，最终将打印的模式写入到一个<code class="fe lt lu lv lw b">combined.graphql</code>模式中。</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="49be" class="nf mf iq lw b gy ng nh l ni nj">const fs = require("fs");</span><span id="e957" class="nf mf iq lw b gy nk nh l ni nj">const { loadSchemaSync } = require("<a class="ae kv" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/load");<br/>const { GraphQLFileLoader } = require("<a class="ae kv" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/graphql-file-loader");<br/>const { printSchemaWithDirectives } = require("<a class="ae kv" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-tools/utils");</span><span id="f048" class="nf mf iq lw b gy nk nh l ni nj">const schema = loadSchemaSync("./schemas/schema.graphql", {<br/>  loaders: [new GraphQLFileLoader()],<br/>});</span><span id="a797" class="nf mf iq lw b gy nk nh l ni nj">fs.writeFileSync("combined.graphql", printSchemaWithDirectives(schema));</span></pre><p id="b128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果文件如下所示；</p><pre class="kg kh ki kj gt nb lw nc nd aw ne bi"><span id="a083" class="nf mf iq lw b gy ng nh l ni nj">// combined.graphql</span><span id="9f02" class="nf mf iq lw b gy nk nh l ni nj">schema {<br/>  query: Query<br/>}</span><span id="e4c2" class="nf mf iq lw b gy nk nh l ni nj">directive <a class="ae kv" href="http://twitter.com/uppercase" rel="noopener ugc nofollow" target="_blank">@uppercase</a> on FIELD_DEFINITION</span><span id="6baf" class="nf mf iq lw b gy nk nh l ni nj">type Query {<br/>  posts: [Post]<br/>}</span><span id="42f7" class="nf mf iq lw b gy nk nh l ni nj">"""A post with comments"""<br/>type Post {<br/>  comments: [Comment]<br/>  id: ID!<br/>  text: String!<br/>  tags: [String]<br/>}</span><span id="7086" class="nf mf iq lw b gy nk nh l ni nj">type Comment {<br/>  id: ID!<br/>  text: String! <a class="ae kv" href="http://twitter.com/uppercase" rel="noopener ugc nofollow" target="_blank">@uppercase</a><br/>}</span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="942b" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="1ef5" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们已经将多个模式文件转换成一个，现在可以通过<code class="fe lt lu lv lw b"><a class="ae kv" href="https://www.apollographql.com/docs/rover/" rel="noopener ugc nofollow" target="_blank">rover</a> </code> CLI工具运行它来生成我们的超图模式。</p><p id="976c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于像我们这样的人来说，这可能是联合一个整体图的第一步，希望这种从GraphQLSchema对象重新创建模式文件的能力在这方面对您有用。</p></div></div>    
</body>
</html>