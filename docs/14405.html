<html>
<head>
<title>Dynamic SVG Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态SVG模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-svg-patterns-1b53c4ed1142?source=collection_archive---------6-----------------------#2022-12-09">https://betterprogramming.pub/dynamic-svg-patterns-1b53c4ed1142?source=collection_archive---------6-----------------------#2022-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d914" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">在React中构建模式生成器</h2><div class=""/><div class=""><h2 id="fe21" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">轻松生成SVG模式以包含在React项目中(带有Figma或Sketch的额外提示)</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/23b7a50138dd633bd0b8cafdbd3e2572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwukEreJgaHb2eXq90OkFg.png"/></div></div></figure><p id="f158" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最近，我一直在处理一些用于图表填充的SVG模式。</p><p id="37c7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我需要创建很多这样的图案，最困难的事情是为各种填充找出正确的颜色和色调，这样页面看起来就平衡了。</p><p id="7dc0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在研究了几个选项后，我发现最好的解决方案是使用图案而不是纯色或渐变填充。</p><p id="2812" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最烦人的问题之一是在Figma中测试模型的困难。我尝试了许多不同的笔画宽度、颜色、线条角度等等，每一种变化在Figma中都花了相当长的时间。我也尝试了不同的插件，但是没有一个足够快或者适合我的目的。</p><p id="35ea" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了解决这个问题，我决定安排一个快速而肮脏的JavaScript应用程序。首先，我从Figma以SVG格式导出了我正在处理的模块，并将其安装在一个web页面上。然后，我将需要填充图案的区域连接到一个简单的脚本，在这个脚本中我可以更改一些参数:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2e5ad59f76f43d757c2affdfa591e2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rF5OQwoody076vI77RgNQ.png"/></div></div></figure><p id="cb12" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这样，我能够在很短的时间内测试模型的许多变体。最后，我将最终的模式带回Figma，完成了我的原型。为了做到这一点，我使用了你可以在右边的灰色方框中看到的瓷砖，但我们稍后将回到这一点。</p><p id="b397" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有可能我可以在Figma中直接做所有的事情，但是我没有时间(或者兴趣)这样做。</p><p id="3233" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面是我用来创建模式的过程，首先是原型，然后是React组件。</p><h1 id="5373" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">第一步:投射图案</h1><p id="ee96" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">根据<a class="ae mt" href="https://en.wikipedia.org/wiki/Tessellation" rel="noopener ugc nofollow" target="_blank">维基百科，镶嵌</a>:</p><blockquote class="mu mv mw"><p id="0b83" class="la lb mx lc b ld le ka lf lg lh kd li my lk ll lm mz lo lp lq na ls lt lu lv ij bi translated"><em class="iq">一个</em> <strong class="lc ja"> <em class="iq">镶嵌</em> </strong> <em class="iq">或</em> <strong class="lc ja"> <em class="iq">平铺</em> </strong> <em class="iq">是一个表面的覆盖，通常是一个平面，使用一个或多个几何形状，称为</em>平铺<em class="iq">，没有重叠也没有间隙。在数学中，镶嵌可以推广到更高维度和各种几何形状。</em></p></blockquote><p id="450c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们需要一种简单的镶嵌，只基于在<em class="mx"> x </em>和<em class="mx"> y </em>轴上的瓷砖的平移。此外，我们需要的模式是一系列简单的线条:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6bdbca918c458d616eb7013ed6626491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*3PxjSUq1_vB1Md9E1W2MSg.png"/></div></figure><p id="3d34" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如你所见，这个图案是绿色瓷砖的复制品。我们要做的就是安排好，让它可以无缝重复。</p><p id="4832" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦我们决定了线之间的距离和角度，我们的目标是确定每个瓷砖的大小。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="ec24" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为此，我们必须处理<a class="ae mt" href="https://en.wikipedia.org/wiki/Triangle" rel="noopener ugc nofollow" target="_blank">三角形</a>和<a class="ae mt" href="https://en.wikipedia.org/wiki/Trigonometry" rel="noopener ugc nofollow" target="_blank">三角学</a>。</p><p id="c2a5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">查看下面的模式，我们可以看到</p><ul class=""><li id="adbb" class="nj nk iq lc b ld le lg lh lj nl ln nm lr nn lv no np nq nr bi translated">线条起点(<strong class="lc ja"> A </strong>)是图块的左上角；</li><li id="1f86" class="nj nk iq lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">这条线(蓝色)实际上是直角三角形的斜边，直角三角形的边是瓷砖的边；</li><li id="403a" class="nj nk iq lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated"><strong class="lc ja"> A-B </strong>侧(<em class="mx"> h </em>)对应于图案线之间的距离。我们知道它，因为它是我们可以设定的参数之一，</li><li id="ee64" class="nj nk iq lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">同样适用于<strong class="lc ja"> 𝛼 </strong>角度。</li></ul><p id="92a7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所以，我们得到<strong class="lc ja"> C </strong>点坐标唯一缺少的值就是<strong class="lc ja"> B-C </strong>边，我们三角形的底边(<em class="mx"> b </em>)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7e4aeb67f7b291358aaef47de1dd6fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*-LrEieyGwvUimy9si9eugQ.png"/></div></figure><p id="0ccb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是我们可以用一个简单的三角公式来确定它。三角形的底边等于另一条边乘以邻角的余切或对角的正切。</p><p id="1a31" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们有了生成SVG模式所需的所有东西。</p><h1 id="1c8d" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">构建模式</h1><p id="6698" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">SVG有一个特定的<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/pattern" rel="noopener ugc nofollow" target="_blank">模式</a>元素。</p><p id="3cad" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一个<code class="fe ny nz oa ob b">pattern</code>元素必须在一个<code class="fe ny nz oa ob b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs" rel="noopener ugc nofollow" target="_blank">defs</a></code>元素中定义，并且可以被添加到任何一个<code class="fe ny nz oa ob b">svg</code>元素中(不仅仅是它们被应用到的那个)。</p><p id="09f5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦定义了模式，就可以用它来填充SVG元素，方式如下:</p><pre class="kp kq kr ks gt oc ob od bn oe of bi"><span id="0f58" class="og lx iq ob b be oh oi l oj ok">&lt;someElement fill="url(#pattern-id)"&gt;...&lt;/someElement&gt;</span></pre><p id="5da2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了将我们的tile定义为SVG模式元素，我们将编写如下代码:</p><pre class="kp kq kr ks gt oc ob od bn oe of bi"><span id="4028" class="og lx iq ob b be oh oi l oj ok">&lt;svg &gt;<br/>  &lt;defs&gt;<br/>    &lt;pattern id="pattern" patternUnits="userSpaceOnUse" width="69.282" height="40"&gt;<br/>      &lt;rect width="69.282" height="40" fill="#dddddd"&gt;&lt;/rect&gt;<br/>      &lt;path d="M0,0 l69.282,40 M-34.641,20 l69.282,40 M34.641,-20 l69.282,40" stroke="#666666" stroke-width="1.5" stroke-opacity="1"&gt;&lt;/path&gt;<br/>    &lt;/pattern&gt;<br/>  &lt;/defs&gt;<br/>&lt;/svg&gt;</span></pre><p id="6699" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ny nz oa ob b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect" rel="noopener ugc nofollow" target="_blank">rect</a></code>元素是平铺背景(在本例中，它填充了浅灰色的<code class="fe ny nz oa ob b">#ddd</code>),<code class="fe ny nz oa ob b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/path" rel="noopener ugc nofollow" target="_blank">path</a></code>描述了我们的线条。</p><p id="672a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了生成我们的模式，我们必须计算它们的<code class="fe ny nz oa ob b">width</code>、<code class="fe ny nz oa ob b">height</code>和<code class="fe ny nz oa ob b">d</code>属性。</p><p id="aa89" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">实际上，我们不需要计算<code class="fe ny nz oa ob b">rect</code>元素的高度，因为它是我们可以选择的参数之一。</p><p id="cb5f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后，给定参数<code class="fe ny nz oa ob b">h</code>(矩形的高度，即线条之间的距离)和<code class="fe ny nz oa ob b">𝛼</code>(线条角度)，矩形底(<code class="fe ny nz oa ob b">b</code>)为:</p><pre class="kp kq kr ks gt oc ob od bn oe of bi"><span id="0c7b" class="og lx iq ob b be oh oi l oj ok">b = Math.tan(((90 - 𝛼) * Math.PI) / 180) * h)</span></pre><p id="114e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因为JavaScript缺少计算余切的原生函数，所以我们必须使用Math的<code class="fe ny nz oa ob b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tan" rel="noopener ugc nofollow" target="_blank">tan</a></code>方法和<code class="fe ny nz oa ob b">𝛼</code>相反的方法(也就是我们的方案中的<code class="fe ny nz oa ob b">𝛽</code>)。我们不知道<code class="fe ny nz oa ob b">𝛽</code>，但是由于所有三角形的角之和是180°，而我们的三角形是rect，所以可以计算为<code class="fe ny nz oa ob b">90 - 𝛼</code>。</p><blockquote class="mu mv mw"><p id="b378" class="la lb mx lc b ld le ka lf lg lh kd li my lk ll lm mz lo lp lq na ls lt lu lv ij bi translated">注意，常数是切线的倒数，所以如果你愿意，可以用<code class="fe ny nz oa ob b">1/Math.tan(𝛼)</code>代替<code class="fe ny nz oa ob b">Math.tan(𝛽)</code>。</p></blockquote><p id="bc68" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所有的<code class="fe ny nz oa ob b">Math</code>三角函数只接受以<a class="ae mt" href="https://en.wikipedia.org/wiki/Radian" rel="noopener ugc nofollow" target="_blank">弧度</a>表示的角度，所以我们必须使用下面的简单方法将角度转换成弧度:</p><pre class="kp kq kr ks gt oc ob od bn oe of bi"><span id="dd0c" class="og lx iq ob b be oh oi l oj ok">angle_in_radians = angle_in_degrees * Math.PI / 180</span></pre><p id="5459" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">其中<code class="fe ny nz oa ob b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/PI" rel="noopener ugc nofollow" target="_blank">Math.PI</a></code>代表数字<code class="fe ny nz oa ob b"><a class="ae mt" href="https://en.wikipedia.org/wiki/Pi" rel="noopener ugc nofollow" target="_blank">π</a></code>。</p><p id="a0c8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们运算的结果很容易有几个小数位。如果您想在保持可接受的精度(比如3)的同时降低它们，可以使用以下方法:</p><pre class="kp kq kr ks gt oc ob od bn oe of bi"><span id="1fa8" class="og lx iq ob b be oh oi l oj ok">b = Math.round((Math.tan(((90 - 𝛼) * Math.PI) / 180) * h) * 1000) / 1000</span></pre><p id="4bf1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们有了<code class="fe ny nz oa ob b">rect</code>元素的<code class="fe ny nz oa ob b">width</code>属性和我们行的结束<code class="fe ny nz oa ob b">x</code>坐标(<code class="fe ny nz oa ob b">C</code>)。最后一步是计算<code class="fe ny nz oa ob b">path</code>元素的<code class="fe ny nz oa ob b">d</code>属性。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="b04b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ny nz oa ob b">d</code>允许我们通过使用一些简单的命令参数来定义任何路径。我们将只使用<code class="fe ny nz oa ob b">M</code>和<code class="fe ny nz oa ob b">l</code>命令，如需完整列表，请查看MDN 上的<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d" rel="noopener ugc nofollow" target="_blank">参考页面。</a></p><p id="a0fc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ny nz oa ob b">d</code>代表<em class="mx">画</em>，所以想象一下你会怎么画我们的线:你会先把笔移到起点，然后画一条线到终点。</p><p id="0868" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这变成<code class="fe ny nz oa ob b">M0,0</code> ( <strong class="lc ja"> M </strong>移至坐标<code class="fe ny nz oa ob b">0,0</code>的点)和<code class="fe ny nz oa ob b">lb,h</code>(画一条<strong class="lc ja"> l </strong>线至坐标<code class="fe ny nz oa ob b">b,h</code>。</p><p id="2922" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe ny nz oa ob b">l</code>命令是小写的，表示其坐标是相对于前一点的。</p><p id="100e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">把所有东西放在一起(已经定义了我们的<code class="fe ny nz oa ob b">b</code>和<code class="fe ny nz oa ob b">h</code>变量:</p><pre class="kp kq kr ks gt oc ob od bn oe of bi"><span id="e7b0" class="og lx iq ob b be oh oi l oj ok">d = `M0,0 l${b},${h}`</span></pre><p id="49eb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这似乎很容易，但不幸的是有一个小问题。</p><p id="656b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">将上面的代码应用到我们的模式中，我们将得到类似这样的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/829577f96114efbd2f93d0cf96c1637a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*_0faPeev2v06L5ipx1GWCw.png"/></div></figure><p id="8e2d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">图案的边缘切断了我们的线条，所以我们在每个瓷砖的开头和结尾都缺少了两个小部分。要解决这个问题，我们必须添加缺失的部分:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi om"><img src="../Images/03f70cd6b8be20866d42584ba62863fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*WDeqpb4pLtKN-86GOZ5LJA.png"/></div></figure><p id="8b48" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最简单的解决方案是绘制两条与第一条类似的线，但从左下方和右上方平移:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi on"><img src="../Images/669f1523c608e559d4099c2dd682d663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*hUnbaNZQ4kz0hOfsZAtgSg.png"/></div></figure><p id="540b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">图案将被裁剪，隐藏线条的不必要部分。所以我们的<code class="fe ny nz oa ob b">d</code>属性变成了:</p><pre class="kp kq kr ks gt oc ob od bn oe of bi"><span id="95d5" class="og lx iq ob b be oh oi l oj ok">d=`M0,0 l${b},${h} <br/>   M${-b / 2},${h / 2} l${b},${h} <br/>   M${b / 2},${-h / 2} l${b},${h}`</span></pre><p id="15d5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们只需要再加两笔，第一笔从<code class="fe ny nz oa ob b">${-b / 2},${h / 2}</code>开始，第二笔从<code class="fe ny nz oa ob b">${b / 2},${-h / 2}</code>开始。<code class="fe ny nz oa ob b">l</code>参数与前一个命令相关，因此它们保持不变。</p><p id="4a39" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一切都用一个非常有用的工具解释清楚了:<a class="ae mt" href="https://svg-path-visualizer.netlify.app/#M0%2C0%20l69.282%2C40%20M-34.641%2C20%20l69.282%2C40%20M34.641%2C-20%20l69.282%2C40" rel="noopener ugc nofollow" target="_blank"> SVG路径可视化器</a>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/f479972f92c00440122cafa011da8db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9D2WLHkxS80weDsyWtbKA.png"/></div></div></figure><p id="e1ee" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">另一个类似的伟大工具是<a class="ae mt" href="https://yqnn.github.io/svg-path-editor/" rel="noopener ugc nofollow" target="_blank"> SVG路径编辑器</a>。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="8e8c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我已经做了一个<a class="ae mt" href="https://massimo-cassandro.github.io/area-test/2022-12-svg-pattern-generator/index.html" rel="noopener ugc nofollow" target="_blank">小演示</a>，在这里你可以改变许多参数来构建你的模式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/54d98928f0026eda3f4c9a08e6e900e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6x1vD1soU-WEq02Cbln-g.png"/></div></div></figure><p id="7df7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是为各种类型的模式创建生成器的更大项目的第一步(然而，我不知道这会如何进行)。</p><h1 id="0210" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">警告</h1><p id="144f" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">该脚本在大约5-10度和70-75度之间的角度下工作良好；使用其他值时，<code class="fe ny nz oa ob b">b</code>参数倾向于<code class="fe ny nz oa ob b">Infinity</code>或<code class="fe ny nz oa ob b">0</code>，使程序无效。这并不难处理，但是由于超出了本文的范围，这里不讨论这些情况。</p><h1 id="674e" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">切换到反应</h1><p id="677c" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">在React中有许多方法可以实现这个过程。为了拥有一个可重用的模式引擎，我选择创建一个能够为每个模式添加一组参数的组件。</p><p id="342b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面的演示展示了应用于一些SVG形状的一系列模式:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oq or l"/></div></figure><h1 id="c422" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">回到图玛或素描</h1><p id="ebd9" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">Figma和Sketch呢？</p><p id="f9f8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我的演示的最后一个框显示了一个不使用模式的独立SVG。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/52cde88148821fab059eebc541aaf83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*kZlwS_S4X-9KZQz6-D0OzA.png"/></div></figure><p id="4196" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">可以通过按钮复制SVG，然后粘贴到Figma或Sketch中；两者都将呈现SVG，因此您可以使用它来为您的模型创建模式。</p><p id="e05b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">整个过程仍然很繁琐，但我找不到更快的方法。</p><p id="ae98" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后，如果您不需要定制模式，您可能会在Michael Semmler的<a class="ae mt" href="https://patterns.helloyes.dev/" rel="noopener ugc nofollow" target="_blank">基本模式库中找到合适的模式</a></p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="d751" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae mt" href="https://medium.com/@massimo.cassandro/my-dev-publications-eacf6727e4a" rel="noopener">查看我的其他与开发相关的文章</a></p></div></div>    
</body>
</html>