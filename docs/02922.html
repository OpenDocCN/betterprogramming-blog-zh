<html>
<head>
<title>The Superpowers of Array reduce()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组的超能力减少()</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-superpowers-of-array-reduce-4b54085bedf?source=collection_archive---------18-----------------------#2020-01-08">https://betterprogramming.pub/the-superpowers-of-array-reduce-4b54085bedf?source=collection_archive---------18-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最强大的高阶函数之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc4a405bf6107a8b1a132acd9ce255d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FMy9K65QXBm-_yBY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">埃斯特万·洛佩兹在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ECMAScript 5在2009年引入了许多令人敬畏的<a class="ae ky" href="https://www.w3schools.com/js/js_es5.asp" rel="noopener ugc nofollow" target="_blank">特性</a>，其中大部分是数组方法，如<code class="fe lv lw lx ly b">isArray</code>、<code class="fe lv lw lx ly b">forEach</code>、<code class="fe lv lw lx ly b">map</code>、<code class="fe lv lw lx ly b">filter</code>、<code class="fe lv lw lx ly b">every</code>、<code class="fe lv lw lx ly b">some</code>。不过还是说说我最喜欢的一个:<code class="fe lv lw lx ly b">reduce</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f6ea" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">该简化方法</h1><p id="1c8a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">reduce</code>方法对数组的每个元素执行一个<code class="fe lv lw lx ly b">reducer</code>回调函数(由用户提供),产生一个输出值。</p><h2 id="35be" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">还原剂</h2><p id="9d26" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">reducer</code>函数有四个参数:</p><ul class=""><li id="7a08" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">蓄能器(acc)</li><li id="19a6" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当前值(当前)</li><li id="94fd" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">当前索引(idx)</li><li id="7f76" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">源阵列(src)</li></ul><p id="7303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的<code class="fe lv lw lx ly b">reducer</code>函数的返回值被分配给累加器，累加器的值在整个数组的每次迭代中被记住，并最终成为最终的单个结果值。</p><p id="56a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要提示:在每次迭代中，您必须<strong class="lb iu"> </strong>返回下一次迭代的累加器值(最终将是最终的返回值)，否则累加器的下一个(也是最终的)值将是<code class="fe lv lw lx ly b">undefined</code>。</p><h2 id="728b" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">初始值</h2><p id="01ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">reduce</code>方法接受第二个可选参数:<code class="fe lv lw lx ly b">initialValue</code>。<strong class="lb iu"> <br/> </strong>如果不提供，累加器的初始值将是数组的第一个元素，第一次迭代将指向第二个元素。如果提供了<code class="fe lv lw lx ly b">initialValue</code> <strong class="lb iu"> </strong>，则为累加器的初始值，第一次迭代指向数组的第一个元素。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2f32" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">例子</h1><h2 id="529b" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">对有/没有初始值的数字求和</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对有/没有初始值的数字求和</p></figure><p id="ac55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有初始值，第一次迭代将有<code class="fe lv lw lx ly b">accumulator</code>指向数组的第一个元素(1)，有<code class="fe lv lw lx ly b">currentValue</code>指向数组的第二个元素(2)。</p><p id="45e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定初始值，第一次迭代将有一个带有给定初始值的值的<code class="fe lv lw lx ly b">accumulator</code>(3)，<code class="fe lv lw lx ly b">currentValue</code>将指向数组的第一个元素(1)。</p><h2 id="2e0a" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">计算数组中出现的次数</h2><p id="f05d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们统计以下单词的出现次数，并将结果存储在一个映射中:</p><p id="085e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果土拨鼠会扔木头，它会扔多少木头？如果土拨鼠会扔木头的话，他会尽可能多地扔木头。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多少只土拨鼠？</p></figure><p id="99f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们初始化一个空的map并使用它作为累加器的初始值，当我们迭代句子中的单词时，初始化或更新每个单词的出现次数。</p><p id="1a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是两个例子，但是现在你一定已经意识到<code class="fe lv lw lx ly b">reduce</code>有多棒了，对吧？</p><p id="429f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它允许你取一个数组，并把它的值简化为基本上任何可以从它保存的数据中导出的值。它还允许您返回任何类型的数据，而不管数组元素的类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c46f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一种方法来统治他们？</h1><p id="b09f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">再看看其他的ES5数组方法，我们可以看到每个方法都在数组上使用给定的回调函数，并返回某种结果。</p><p id="bb6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><ul class=""><li id="f2b5" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">map</code>转换数组的每个元素，返回一个新的<strong class="lb iu"> </strong>数组。</li><li id="5117" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">every</code>检查给定的条件是否适用于数组中的每个元素，返回相应的布尔值。</li></ul><p id="db92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来很眼熟，对吧？</p><p id="0f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用我们已经知道的，让我们试着用<code class="fe lv lw lx ly b">reduce</code>来实现其他的ES5数组方法。</p><p id="e045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:在每个例子中，我们都会将新方法添加到<code class="fe lv lw lx ly b">Array</code>的原型中，其中<code class="fe lv lw lx ly b">this</code>将指向我们正在操作的数组。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e6cd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">地图</h1><p id="34dc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map()</a></code>方法创建一个新数组，其中每个原始元素都由给定的<code class="fe lv lw lx ly b">transformer</code>回调函数转换。</p><h2 id="7b29" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">使用</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="75aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用将数组中的每个数字加倍的transformer回调，我们得到一个新数组，其中每个元素都是其原始值的两倍。</p><h2 id="44be" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">用<code class="fe lv lw lx ly b">reduce</code></h2><p id="cf9b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">map</code>对一个数组进行操作，返回一个新的数组，所以累加器必须是一个数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用reduce绘制地图</p></figure><p id="17dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">reduce</code>，我们从一个空的数组累加器开始，迭代数组。然后，我们对每个元素应用transformer回调，并将其推送到累加数组。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e12d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">过滤器</h1><p id="0ab2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">方法<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">filter()</a></code>创建了一个新的数组<strong class="lb iu"> </strong>，其中所有元素都通过了由所提供的函数实现的测试。</p><h2 id="c970" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">使用</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个过滤掉所有奇数的测试回调，我们得到一个新的数组，其中包含原始数组的所有偶数元素。</p><h2 id="4be5" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">用<code class="fe lv lw lx ly b">reduce</code></h2><p id="309d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">就像前面的例子一样，<code class="fe lv lw lx ly b">filter</code>也操作一个数组并返回一个新的数组，所以累加器必须是一个数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用reduce过滤</p></figure><p id="706a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">reduce</code>，我们从一个空的数组累加器开始，遍历数组。然后，我们使用tester回调来检查每个元素是否应该被推送到累积数组中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8d15" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">每个</h1><p id="58de" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank">every()</a></code>方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。它返回一个布尔值。</p><h2 id="e593" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">使用</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f37f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个测试数组中每个元素的回调函数，我们得到一个布尔值，表明是否所有元素都通过了测试。在这种情况下，所有元素都小于10，因此<code class="fe lv lw lx ly b">every</code>返回<code class="fe lv lw lx ly b">true</code>。</p><h2 id="4ae1" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">用<code class="fe lv lw lx ly b">reduce</code></h2><p id="9198" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">every</code>对数组进行操作并返回布尔值，因此累加器必须是布尔值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="28e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">reduce</code>，我们从一个布尔累加器值<code class="fe lv lw lx ly b">true</code>开始(我们将在后面讨论原因)并迭代数组。然后，我们使用逻辑AND ( <code class="fe lv lw lx ly b">&amp;&amp;</code>)将测试器回调的结果链接到累加器，如果所有元素都通过测试，最终返回<code class="fe lv lw lx ly b">true</code>，否则返回<code class="fe lv lw lx ly b">false</code>。</p><p id="9952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么从<code class="fe lv lw lx ly b">true</code>开始？</p><p id="5cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数组为空，<code class="fe lv lw lx ly b">every</code>返回<code class="fe lv lw lx ly b">true</code>而不管测试回调(即使回调返回<code class="fe lv lw lx ly b">false</code>)。<br/> <br/>否则，如果所有元素都满足条件，使用逻辑AND的初始<code class="fe lv lw lx ly b">true</code>值的链接将最终解析为<code class="fe lv lw lx ly b">true</code>。否则，链接将最终解析为<code class="fe lv lw lx ly b">false</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8971" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一些</h1><p id="2524" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank">some()</a></code>方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。它返回一个布尔值。</p><h2 id="f026" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">使用</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个测试数组中每个元素的回调函数，我们得到一个布尔值，表明是否有任何元素通过了测试。在这种情况下，第四个元素大于3，因此<code class="fe lv lw lx ly b">some</code>返回<code class="fe lv lw lx ly b">true</code>。</p><h2 id="8bb8" class="nd mh it bd mi ne nf dn mm ng nh dp mq li ni nj ms lm nk nl mu lq nm nn mw no bi translated">用<code class="fe lv lw lx ly b">reduce</code></h2><p id="5ca5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">some</code>对一个数组进行操作并返回一个布尔值，所以累加器必须是布尔值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">reduce</code>，我们从布尔累加器值<code class="fe lv lw lx ly b">false</code>开始(稍后我们将讨论原因)并迭代数组。然后，我们使用逻辑OR ( <code class="fe lv lw lx ly b">||</code>)将测试器回调的结果链接到累加器，如果有任何元素通过测试，最终返回<code class="fe lv lw lx ly b">true</code>，否则返回<code class="fe lv lw lx ly b">false</code>。</p><p id="990c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么从<code class="fe lv lw lx ly b"><em class="of">false</em></code>开始？</p><p id="42a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数组为空，则<code class="fe lv lw lx ly b"><em class="of">some</em></code>返回<code class="fe lv lw lx ly b"><em class="of">false</em></code>而不管测试回调(即使回调返回<code class="fe lv lw lx ly b"><em class="of">true</em></code>)。</p><p id="5525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，如果任何元素满足条件，使用逻辑OR的初始<code class="fe lv lw lx ly b"><em class="of">false</em></code>值的链接将最终解析为<code class="fe lv lw lx ly b"><em class="of">true</em></code>。否则，链接将最终解析为<code class="fe lv lw lx ly b"><em class="of">false</em></code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7133" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">免责声明(每个和一些)</h1><p id="86eb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">every</code>方法为数组中的每个元素执行一次回调函数，直到找到回调函数返回一个falsy值(当转换为布尔值时，该值变为<code class="fe lv lw lx ly b">false</code>)的元素。如果找到这样的元素，<code class="fe lv lw lx ly b">every</code>立即返回<code class="fe lv lw lx ly b">false</code>。</p><p id="bdf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，<code class="fe lv lw lx ly b">some</code>方法对数组中的每个元素执行一次回调函数，直到找到回调函数返回一个<em class="of"> truthy </em>值(转换为布尔值时变成<code class="fe lv lw lx ly b">true</code>的值)的元素。如果找到这样的元素，<code class="fe lv lw lx ly b">some</code>立即返回<code class="fe lv lw lx ly b">true</code>。</p><p id="b4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，没有什么好办法让<a class="ae ky" href="https://stackoverflow.com/questions/36144406/how-to-break-on-reduce-method" rel="noopener ugc nofollow" target="_blank">终止</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://stackoverflow.com/questions/36144406/how-to-break-on-reduce-method" rel="noopener ugc nofollow" target="_blank">reduce</a></code> <a class="ae ky" href="https://stackoverflow.com/questions/36144406/how-to-break-on-reduce-method" rel="noopener ugc nofollow" target="_blank">中间循环</a>。<br/>这意味着尽管两个实现(最初的<code class="fe lv lw lx ly b">every/some</code>方法和使用<code class="fe lv lw lx ly b">reduce</code>的相应实现)都有一个运行时<code class="fe lv lw lx ly b">O(n)</code>，但是最初的实现很可能会终止，而不必遍历整个数组，从而使它们更加高效。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b8c7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">过滤器+地图</h1><p id="05d5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">给定一个数字数组，过滤掉所有偶数元素并平方剩余元素的最有效方法是什么(使用ES5方法)？</p><p id="2d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试<code class="fe lv lw lx ly b">filter</code>然后是<code class="fe lv lw lx ly b">map</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个只保留奇数元素的测试函数和一个平方给定元素的转换函数。然后我们在链接<code class="fe lv lw lx ly b">filter</code>和<code class="fe lv lw lx ly b">map</code>方法时使用这两个回调函数，并返回期望的数组。</p><p id="8c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用我们所知道的关于用<code class="fe lv lw lx ly b">reduce</code>实现<code class="fe lv lw lx ly b">filter</code>和<code class="fe lv lw lx ly b">map</code>的知识，只是这一次让我们将它们结合在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="892d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用相同的测试器和转换函数来测试每个元素是否应该保留在数组中，如果应该的话就转换它。</p><p id="f6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法节省了我们创建过滤值的中间数组的需要，并且我们得到了一个稍微更有效的算法，因为我们不必迭代两个不同的数组(原始数组和中间数组)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="99d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="1d9a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这些是如何使用强大的<code class="fe lv lw lx ly b">reduce</code>方法实现其他ES5方法的几个例子。</p><p id="04e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何在日常编码中使用它？分享在评论里！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ef5b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">来源</h1><ul class=""><li id="db3d" class="np nq it lb b lc my lf mz li og lm oh lq oi lu nu nv nw nx bi translated">w3schools的<a class="ae ky" href="https://www.w3schools.com/js/js_es5.asp" rel="noopener ugc nofollow" target="_blank"> ES5特性</a></li><li id="999f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">MDN web docs的Javascript数组方法</a>。<br/>本文中的每个方法文档都来自这里。</li></ul></div></div>    
</body>
</html>