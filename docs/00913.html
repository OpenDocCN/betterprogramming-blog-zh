<html>
<head>
<title>Swift: Beyond Switching on a Result</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift:超越打开结果</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beyond-switch-swift-result-6e4a91cda6b6?source=collection_archive---------4-----------------------#2019-07-27">https://betterprogramming.pub/beyond-switch-swift-result-6e4a91cda6b6?source=collection_archive---------4-----------------------#2019-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5768" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">雨燕。Result </strong>的潜力不仅仅是使用switch子句获得值/错误。让我们看看你能做的几件事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4eaf952d88b72f433e640173b4a17145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QgB30nu3zmyQR73Y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="5f85" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">获取成功值作为可选值</h1><p id="dd00" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在某些情况下，你只需要一个<code class="fe mn mo mp mq b">Result</code>的成功值。有了<code class="fe mn mo mp mq b">func get() throws -&gt; Success</code>，就不需要使用switch子句了。</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="bc8b" class="mv la it mq b gy mw mx l my mz">let resultSuccess = Result&lt;Int, Error&gt;.success(1)<br/>let value = try? resultSuccess.get()<br/>// value is Optional(1)</span><span id="3885" class="mv la it mq b gy na mx l my mz">let resultFailure = Result&lt;Int, Error&gt;.failure(someError)<br/>let value2 = try? resultFailure.get()<br/>// value is nil</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="3d7b" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">将抛出表达式转换为结果</h1><p id="531c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">还有其他情况，当你有一个抛出表达式(例如函数、闭包……)但需要一个<code class="fe mn mo mp mq b">Result</code>来代替。今天是你的幸运日，因为<code class="fe mn mo mp mq b">Result</code>有一个<code class="fe mn mo mp mq b">init</code>捕捉抛出的错误。</p><p id="40c8" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma np mc md me nq mg mh mi nr mk ml mm im bi translated"><code class="fe mn mo mp mq b">init(catching body: () throws -&gt; Success)</code></p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="886f" class="mv la it mq b gy mw mx l my mz">enum RandomError: Error {<br/>  case noNumber<br/>}</span><span id="ca51" class="mv la it mq b gy na mx l my mz">func random() throws -&gt; UInt {<br/>  if Bool.random() {<br/>    return UInt.random(in: 1...20)<br/>  } else {<br/>    throw RandomError.noNumber<br/>  }<br/>}</span><span id="3c49" class="mv la it mq b gy na mx l my mz">let randomResult: Result&lt;UInt, Error&gt; = Result { try random() }</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="febc" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">映射成功类型</h1><p id="678f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时候你从一个函数中得到一个<code class="fe mn mo mp mq b">Result&lt;A, E&gt;</code>，但是你需要一个<code class="fe mn mo mp mq b">Result&lt;B, E&gt;</code>。你可以用一个开关来做，但是与你用<code class="fe mn mo mp mq b">Result</code> map操作所能做的相比，那要多很多代码:</p><p id="b39f" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma np mc md me nq mg mh mi nr mk ml mm im bi translated"><code class="fe mn mo mp mq b">func map&lt;NewSuccess&gt;(_ transform: (Success) -&gt; NewSuccess) -&gt; Result&lt;NewSuccess, Failure&gt;</code></p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="2a9d" class="mv la it mq b gy mw mx l my mz">let resultSuccess = Result&lt;Int, Error&gt;.success(1)</span><span id="b948" class="mv la it mq b gy na mx l my mz">let stringResult: Result&lt;String, Error&gt; = resultSuccess.map { String($0) }</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="f646" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">映射故障类型</h1><p id="5308" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">同样，有时你得到了一个<code class="fe mn mo mp mq b">Result&lt;A, E1&gt;</code>，但需要一个<code class="fe mn mo mp mq b">Result&lt;A, E2&gt;</code>。所以，你猜怎么着，还有另外一个地图操作:</p><p id="df31" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma np mc md me nq mg mh mi nr mk ml mm im bi translated"><code class="fe mn mo mp mq b">func mapError&lt;NewFailure&gt;(_ transform: (Failure) -&gt; NewFailure) -&gt; Result&lt;Success, NewFailure&gt; where NewFailure : Error</code></p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="8e4c" class="mv la it mq b gy mw mx l my mz">enum CustomError: Error { case customErrorA }</span><span id="78dd" class="mv la it mq b gy na mx l my mz">let customErrorResult = Result&lt;Int, CustomError&gt;.failure(.customErrorA)</span><span id="a7ae" class="mv la it mq b gy na mx l my mz">let errorResult: Result&lt;Int, Error&gt; = customErrorResult.mapError { $0 }</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="d001" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">平面图成功类型</h1><p id="c0fa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设您使用一个函数将一个<code class="fe mn mo mp mq b">Result</code>返回到一个<code class="fe mn mo mp mq b">Result.map</code>。你会得到一个漂亮的<code class="fe mn mo mp mq b">Result&lt;Result&lt;Success, Failure&gt;, Failure&gt;</code>。然而，尽管它很漂亮，你可能想要一个简单的<code class="fe mn mo mp mq b">Result&lt;Success, Failure&gt;</code>来代替。这时你可以使用<code class="fe mn mo mp mq b">flatMap</code>:</p><p id="5335" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma np mc md me nq mg mh mi nr mk ml mm im bi translated"><code class="fe mn mo mp mq b">func flatMap&lt;NewSuccess&gt;(_ transform: (Success) -&gt; Result&lt;NewSuccess, Failure&gt;) -&gt; Result&lt;NewSuccess, Failure&gt;</code></p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="75ae" class="mv la it mq b gy mw mx l my mz">enum FooError: Error {<br/>  case noNumber, outOfRange<br/>}</span><span id="c70b" class="mv la it mq b gy na mx l my mz">func random() -&gt; Result&lt;UInt, FooError&gt; {<br/>  if Bool.random() {<br/>    return .success(UInt.random(in: 1...25))<br/>  } else {<br/>    return .failure(FooError.noNumber)<br/>  }<br/>}</span><span id="2043" class="mv la it mq b gy na mx l my mz">func factorial(input: UInt) -&gt; Result&lt;UInt, FooError&gt; {<br/>  if input == 0 || input &gt; 20 {<br/>    return .failure(.outOfRange)<br/>  } else {<br/>    let f = (2…input).reduce(1) { $0 * $1 }<br/>    return .success(f)<br/>  }<br/>}</span><span id="4c98" class="mv la it mq b gy na mx l my mz">// Result&lt;Result&lt;UInt, FooError&gt;, FooError&gt; 👎<br/>let mappedResult: Result&lt;Result&lt;UInt, FooError&gt;, FooError&gt; = random().map { factorial(input: $0) }</span><span id="6aa6" class="mv la it mq b gy na mx l my mz">// Result&lt;UInt, FooError&gt; 👍<br/>let flattenResult: Result&lt;UInt, FooError&gt; = random().flatMap { factorial(input: $0) }</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="613b" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">平面图故障类型</h1><p id="8924" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">Result</code>提供另一种更难应用的操作。假设您想从一个<code class="fe mn mo mp mq b">Result.failure</code>中恢复，保持成功类型但改变失败类型。那么你可能会发现<code class="fe mn mo mp mq b">Result.flatMap</code>很有用。</p><p id="2813" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma np mc md me nq mg mh mi nr mk ml mm im bi translated"><code class="fe mn mo mp mq b">func flatMapError&lt;NewFailure&gt;(_ transform: (Failure) -&gt; Result&lt;Success, NewFailure&gt;) -&gt; Result&lt;Success, NewFailure&gt; where NewFailure : Error</code></p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="1272" class="mv la it mq b gy mw mx l my mz">enum RecoverableError: Error {<br/>  case fooError<br/>}</span><span id="c2d2" class="mv la it mq b gy na mx l my mz">func recoverableOperation() -&gt; Result&lt;Int, RecoverableError&gt; {<br/>  return .failure(.fooError)<br/>}</span><span id="7941" class="mv la it mq b gy na mx l my mz">enum RecoveryError: Error {<br/>  case notRecovered<br/>}</span><span id="19f2" class="mv la it mq b gy na mx l my mz">func recoverFromRecoverableError(_ recoverableError: RecoverableError) -&gt; Result&lt;Int, RecoveryError&gt; {<br/>  return .failure(.notRecovered)<br/>}</span><span id="2d61" class="mv la it mq b gy na mx l my mz">// Result&lt;Int, RecoveryError&gt;<br/>let flattenErrorResult = recoverableOperation().flatMapError { recoverFromRecoverableError($0) }</span></pre></div></div>    
</body>
</html>