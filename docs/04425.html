<html>
<head>
<title>Test and Mock Asynchronous Calls With the Jest Testing Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest测试框架测试和模拟异步调用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-and-mock-asynchronous-calls-with-the-jest-testing-framework-c0efbbbde2c3?source=collection_archive---------4-----------------------#2020-04-13">https://betterprogramming.pub/test-and-mock-asynchronous-calls-with-the-jest-testing-framework-c0efbbbde2c3?source=collection_archive---------4-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何为异步调用建立单元测试用例的详细指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/684393603e47f8c9315c4b0fde80d507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXfQIB4hRpS25ex_XsvEJQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@machec?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Petr macha ek</a>在<a class="ae ky" href="https://unsplash.com/s/photos/calls?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bf37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试隔离程序的每个部分，并验证各个部分是正确的。单元测试用例通常是由开发人员编写和运行的自动化测试。这使得问题能够在开发周期的早期被发现。<a class="ae ky" href="https://github.com/facebook/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>是一个JavaScript测试框架，确保任何JavaScript代码库的正确性。</p><p id="80bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步调用不会阻塞或等待调用返回。发出调用后，程序继续执行。当调用返回时，执行回调函数。由于异步的本质，很难测试异步调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0245" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步调用的陷阱</h1><p id="c6ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是一个异步调用的单元测试用例，<code class="fe mz na nb nc b">setTimeout</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，<code class="fe mz na nb nc b">1</code>不是<code class="fe mz na nb nc b">2</code>，但是测试通过。</p><p id="409d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是异步调用的缺陷。3号线调用<code class="fe mz na nb nc b">setTimeout</code>返回。测试在执行第4行之前结束。在测试退出之前没有发现错误——因此，测试用例通过。</p><p id="b511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，很明显<code class="fe mz na nb nc b">1</code>不是<code class="fe mz na nb nc b">2</code>。然而，对于复杂的测试，您可能不会注意到假阳性情况。</p><p id="0eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何发现问题？</p><h2 id="8b23" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">检测:使用<code class="fe mz na nb nc b">assertions</code></h2><p id="c254" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是Jest对<em class="nr">断言</em>的定义:</p><blockquote class="ns nt nu"><p id="a6c8" class="kz la nr lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">"<code class="fe mz na nb nc b"><em class="it">expect.assertions(number)</em></code>验证在测试过程中调用了一定数量的断言。这在测试异步代码时非常有用，可以确保回调中的断言确实被调用了。”</p></blockquote><p id="8b35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在第3行加上<code class="fe mz na nb nc b">expect.assertions(1)</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cd47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一改变确保了在这个测试用例中将有一个<code class="fe mz na nb nc b">expect</code>被执行。因此，由于在退出之前没有调用<code class="fe mz na nb nc b">expect</code>，测试用例如预期的那样失败。</p><p id="b2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个测试用例中有n条<em class="nr"> n条</em>T0】语句，<code class="fe mz na nb nc b">expect.assertions(n)</code>将确保<code class="fe mz na nb nc b">n</code>期望语句被执行。测试用例中<code class="fe mz na nb nc b">expect.assertions(n)</code>的顺序并不重要。如果把第3行移到第6行，也是一样。</p><p id="c7da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不在乎<code class="fe mz na nb nc b">expect</code>语句执行了多少次，您可以使用<code class="fe mz na nb nc b">expect.hasAssertions()</code>来验证在测试期间至少调用了一个断言。</p><p id="f0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能够通过断言来检测问题。我们如何解决这个问题？</p><h2 id="aba2" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">解决方法:使用“完成”回调</h2><p id="3b0f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过等待<code class="fe mz na nb nc b">setTimeout</code>完成来解决这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将Jest的<code class="fe mz na nb nc b">done</code>回调传递给第2行的测试用例，并等待<code class="fe mz na nb nc b">setTimeout</code>完成。然后我们调用<code class="fe mz na nb nc b">done()</code>告诉Jest它现在可以退出了。在<code class="fe mz na nb nc b">done</code>回调的帮助下，这个测试用例如预期的那样失败了。</p><p id="5938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有断言来确保异步调用得到实际测试总是一个好主意。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b70f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">测试基于承诺的异步调用</strong></h1><p id="7dac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们处理了基于回调的异步调用，比如<code class="fe mz na nb nc b">setTimeout</code>。基于承诺的异步调用怎么样？</p><p id="fd56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的测试用例会通过吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试用例失败，因为<code class="fe mz na nb nc b">getData</code>在承诺解决之前退出。它在第3行断言时失败。</p><p id="4516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何解决这个问题？</p><p id="9f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需在承诺前加上<code class="fe mz na nb nc b">return</code>。由于它返回一个承诺，测试将等待该承诺被解决或拒绝。因此，<code class="fe mz na nb nc b">then</code>和<code class="fe mz na nb nc b">catch</code>方法中的<code class="fe mz na nb nc b">expect</code>语句有机会执行回调。</p><p id="3241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有四种方法可以正确测试异步调用。</p><h2 id="55b9" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">方法1:在承诺的“然后”前加上“返回”,然后抓住电话</h2><p id="67c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过在每个承诺前添加<code class="fe mz na nb nc b">return</code>，我们可以成功测试<code class="fe mz na nb nc b">getData</code> <code class="fe mz na nb nc b">resolved</code>和<code class="fe mz na nb nc b">rejected</code>案例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="9cb2" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">方法2:在“expect”之前添加“return”。解析“和”。拒绝的呼叫</h2><p id="de48" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Jest为<code class="fe mz na nb nc b">expect</code>语句提供了<code class="fe mz na nb nc b">.resolves</code>和<code class="fe mz na nb nc b">.rejects</code>匹配器。这些媒人会等待承诺的解决。当然，你还是需要在每个<code class="fe mz na nb nc b">expect</code>语句前加上<code class="fe mz na nb nc b">return</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="d030" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">方法3:使用不带“return”的“async”和“await”调用</h2><p id="5542" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你也可以使用<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>来做测试，而不需要语句中的<code class="fe mz na nb nc b">return</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2行和第7行，关键字<code class="fe mz na nb nc b">async</code>声明函数返回一个承诺。在第4行和第10行，关键字<code class="fe mz na nb nc b">await</code>让JavaScript等到承诺完成并返回结果。</p><h2 id="e4a0" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">方法4:应用“期望”。解析“和”。拒绝对“异步”和“等待”的调用</h2><p id="0aa0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">expect</code>的<code class="fe mz na nb nc b">.resolves</code>和<code class="fe mz na nb nc b">.rejects</code>同样适用于<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>。语句中也不需要有<code class="fe mz na nb nc b">return</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9112" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模拟功能</h1><p id="ec45" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们想跳过实际的承诺调用，只测试代码逻辑。模拟函数帮助我们实现目标。有两种模仿函数的方法:</p><ul class=""><li id="4715" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">创建一个在测试代码中使用的模拟函数。</li><li id="fd40" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">编写一个手动模拟来覆盖模块依赖。</li></ul><p id="9a19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看看模拟函数。</p><p id="6d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">jest.mock(moduleName, factory?, options?)</code>模仿具有特定名称的模块。<code class="fe mz na nb nc b">factory</code>和<code class="fe mz na nb nc b">options</code>是可选的。我们有一个模块，<code class="fe mz na nb nc b">PetStore/apis</code>，里面有几个承诺调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a4e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在测试套件中模拟它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经成功地模拟了这三个电话。拒绝案例怎么样？</p><p id="fd49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将返回值从<code class="fe mz na nb nc b">Promise.resolve</code>更改为<code class="fe mz na nb nc b">Promise.reject</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要测试一些成功的案例和一些失败的案例呢？</p><p id="a6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，Jest提供了一些方便的方法来模拟promise调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法可以组合起来以任何顺序返回任何承诺调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2行模仿<code class="fe mz na nb nc b">createPets</code>，第一次调用返回成功，第二次调用返回失败。</p><p id="3f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第3–20行模拟<code class="fe mz na nb nc b">listPets</code>，其第一次调用返回一个一项数组，第二次调用返回failed，其余调用返回一个二项数组。</p><p id="782f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第21行模仿<code class="fe mz na nb nc b">showPetById</code>，它总是返回失败。</p><p id="de3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些模拟函数不提供灵活性吗？</p><p id="0d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经模拟了模块<code class="fe mz na nb nc b">PetStore/apis</code>，您可能希望在测试后将其卸载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="253c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jest提供了许多API来清除模仿:</p><ul class=""><li id="468a" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><code class="fe mz na nb nc b">jest.clearAllMocks()</code>:清除所有仿制品的<code class="fe mz na nb nc b">mock.calls</code>和<code class="fe mz na nb nc b">mock.instances</code>属性。</li><li id="038d" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">重置所有模拟的状态。除了<code class="fe mz na nb nc b">jest.clearAllMocks()</code>之外，它还移除任何被嘲笑的返回值或实现。</li><li id="d699" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe mz na nb nc b">jest.restoreAllMocks()</code>:将所有模拟恢复到原始值。除了<code class="fe mz na nb nc b">jest.resetAllMocks()</code>之外，还恢复了原来(非嘲讽)的实现。</li></ul><p id="97d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jest还提供了许多API来设置和拆卸测试。</p><ul class=""><li id="4bbe" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><code class="fe mz na nb nc b">beforeAll(fn)</code>:它在这个文件中的任何测试运行之前运行一个函数。</li><li id="f64a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe mz na nb nc b">afterAll(fn)</code>:该文件中的所有测试完成后运行一个函数。</li><li id="7720" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe mz na nb nc b">beforeEach(fn)</code>:在这个文件中的每个测试运行之前运行一个函数。</li><li id="117b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe mz na nb nc b">afterEach(fn)</code>:它在这个文件中的每个测试完成后运行一个函数。</li></ul><p id="4338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果上面的函数返回一个承诺，Jest会在运行测试之前等待这个承诺得到解决。</p><p id="ae6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe mz na nb nc b">jest.mock()</code>，我们还可以通过<code class="fe mz na nb nc b">jest.spyOn(object, methodName, accessType?)</code>窥探一个函数。它创建了一个类似于<code class="fe mz na nb nc b">jest.fn()</code>的模拟函数，但是也跟踪对<code class="fe mz na nb nc b">object[methodName]</code>的调用。它返回一个Jest模拟函数。<code class="fe mz na nb nc b">jest.spyOn()</code>接受可选的第三个参数<code class="fe mz na nb nc b">accessType</code>，可以是<code class="fe mz na nb nc b">'get'</code>或<code class="fe mz na nb nc b">'set'</code>，如果您想分别监视getter或setter。</p><p id="56ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们已经嘲讽了<code class="fe mz na nb nc b">listPets</code>到<code class="fe mz na nb nc b">jest.fn().mockRejectedValue([])</code>，并且<code class="fe mz na nb nc b">ACallThatInvolveslistPets()</code>在承诺被拒绝之前写了一个<code class="fe mz na nb nc b">console.error</code>，下面的测试就通过了。但是，<code class="fe mz na nb nc b">console.error</code>会被执行，污染测试输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/swlh/6-ways-to-run-jest-test-cases-silently-67d2fead8c11" rel="noopener"> 6种静默运行Jest测试用例的方法</a>中，我们已经讨论了如何关闭<code class="fe mz na nb nc b">console.error</code>。解决办法就是用<code class="fe mz na nb nc b">jest.spyOn()</code>来嘲讽<code class="fe mz na nb nc b">console.error()</code>无所事事。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第3行创建一个间谍，第5行重置它。</p><p id="62e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，间谍可以检查它是否已被调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4行，spy被调用0次，但是在第6行，spy被调用1次。</p><p id="c8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">jest.spyOn()</code>在这种情况下非常有效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6948" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">手动模拟</h1><p id="d97a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，为单个测试用例创建模拟函数太麻烦了。我们可以选择手动模拟来模拟模块。这里，<code class="fe mz na nb nc b">axios</code>被用作手动模仿的例子。</p><p id="b4db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">手动模拟是通过在紧邻模块的<code class="fe mz na nb nc b">__mocks__</code>子目录中编写模块来定义的。如果要模仿的模块是节点模块，那么模仿应该放在与<code class="fe mz na nb nc b">node_modules</code>相邻的<code class="fe mz na nb nc b">__mocks__</code>目录中。</p><pre class="kj kk kl km gt om nc on oo aw op bi"><span id="b140" class="nf md it nc b gy oq or l os ot">&lt;rootDir&gt;<br/>  ├── __mocks__<br/>  │       └── axios.js<br/>  ├── node_modules<br/>  └── ...</span></pre><p id="b0cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个给定的模块存在手动模仿，就像上面的例子，Jest将在显式调用<code class="fe mz na nb nc b">jest.mock('moduleName')</code>时使用那个模块。但是，如果有手动模拟，节点模块会被自动模拟。</p><p id="3b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是一个<code class="fe mz na nb nc b">axios</code>手动模拟的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="85d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它适用于基本的CRUD请求。这是Jest中关于如何测试异步调用的整个过程。类似的过程可以应用于其他基于承诺的机制。</p><p id="f7c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">警告</strong>:尽管对于<code class="fe mz na nb nc b">axios</code>，这个手动模拟对<a class="ae ky" href="https://github.com/axios/axios/issues/511" rel="noopener ugc nofollow" target="_blank">拦截器</a>不起作用。另一种方法是使用jest或NODE_ENV有条件地添加拦截器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9f58" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="1a92" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们介绍了如何用Jest测试框架测试和模拟异步调用的过程。</p><p id="3fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae ky" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>