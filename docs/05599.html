<html>
<head>
<title>How to Create a Reusable Web Scraper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建一个可重复使用的网页刮刀</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-reusable-web-scraper-5a5aa9af62d9?source=collection_archive---------11-----------------------#2020-07-21">https://betterprogramming.pub/how-to-create-a-reusable-web-scraper-5a5aa9af62d9?source=collection_archive---------11-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1336" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">停止不断修改你的网页抓取工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3e12e66439003296f7d61501d38e3449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b-aN9YmOsw47b5D_.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.raconteur.net/sponsored/reduce-reuse-recycle-smart-packaging-to-protect-what-matters" rel="noopener ugc nofollow" target="_blank">讲故事者</a>的照片。</p></figure><p id="2181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网页抓取工具非常有趣。当网页上的元素改变时，不断地修改代码并不有趣。这就是为什么我开始创建一个更好的网络抓取项目——一个可以通过最小的编辑更新抓取新网站的项目。</p><p id="7f84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是将web scraper的每个部分分成独立的逻辑部分:</p><ol class=""><li id="4bab" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">页面请求者</li><li id="de0c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">页面验证器</li><li id="f966" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模板化页面处理器</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="70c8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">页面请求者</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1ed85aadcc966a10f20fc6f13a6159f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*gUnzcgKznbinsJoa.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://toybros.com/should-guests-be-able-to-request-music-at-your-wedding/" rel="noopener ugc nofollow" target="_blank">玩具兄弟</a>。</p></figure><p id="291e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页面请求者有一些锦囊妙计。下载网站时有很多要考虑的。你要确保你的用户代理是随机的，不要太频繁地从同一个域请求。</p><p id="b064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，停下来分析一个页面为什么没有下载的成本可能非常昂贵——尤其是如果您有一个为几个站点一次运行几个小时的刮刀。因此，我们将处理这些请求，并将它们保存为一个文件。</p><p id="b722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将请求保存到文件中还有另一个好处。你不必担心丢失的标签会毁掉你的网页抓取器。如果您的处理器是独立的，并且您已经下载了页面，那么您可以根据自己的需要快速、频繁地处理它们。如果您发现有另一个数据元素需要抓取，该怎么办？别担心。只需添加标签，并在您已经下载的页面上重新运行您的处理器。</p><p id="d249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些示例代码，说明这在实践中是什么样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9b46" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">页面验证器</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c17d023e313bf9249647ebe57a53c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7BSzrpW_zUlqkGMq.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://medium.com/artisans-of-tech/handling-validating-user-input-more-with-sauciness-in-android-with-java-d1bbf10d767" rel="noopener">中</a>。</p></figure><p id="f730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页面验证器检查文件并解开请求。它将读取请求的状态代码，如果请求代码是类似于408(超时)的代码，您可以让它将站点重新排队等待下载。否则，验证器可以将文件移动到实际的web抓取模块进行处理。</p><p id="0f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以收集为什么一个页面没有下载的数据。也许你请求页面太快，被禁止。这些数据可用于调整您的页面下载程序，使其尽可能快地运行，并减少错误。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="12a8" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">模板化页面处理器</h1><p id="af76" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">这是你期待已久的神奇酱。第一步是创建我们的数据模型。我们从我们的网址开始。对于每个不同的站点/路径，可能有不同的数据提取方法。我们从一句格言开始，像这样:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="4104" class="nv mr it nr b gy nw nx l ny nz">models = {<br/>  'finance.yahoo.com':{},<br/>  'news.yahoo.com'{},<br/>  'bloomberg.com':{}<br/>}</span></pre><p id="714c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的用例中，我们希望提取这些网站的文章内容。为此，我们将为仍然包含所有数据的最小外部元素创建一个选择器。例如，下面是finance.yahoo.com的示例页面:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="a62a" class="nv mr it nr b gy nw nx l ny nz">Webpage Sample<br/>&lt;div&gt;<br/>    &lt;a&gt;some link&lt;/a&gt;<br/>    &lt;p&gt;some content&lt;/p&gt;<br/>    &lt;article class="canvas-body"&gt;<br/>        &lt;h1&gt;Heading&lt;/h1&gt;<br/>        &lt;p&gt;article paragraph 1&lt;/p&gt;<br/>        &lt;p class="ad"&gt;Ad Link&lt;/p&gt; <br/>        &lt;p&gt;article paragraph 2&lt;/p&gt;<br/>        &lt;li&gt;list element&lt;li&gt;<br/>        &lt;a&gt;unrelated link&lt;/a&gt;<br/>    &lt;/article&gt;<br/>&lt;/div&gt;</span></pre><p id="6604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们希望将文章作为目标。所以我们将同时使用文章标签和类作为标识符，因为这是包含文章内容的最小包含元素。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="2fcc" class="nv mr it nr b gy nw nx l ny nz">models = {<br/>  'finance.yahoo.com':{<br/>    'root-element':[<br/>            'article', <br/>            {'class': "canvas-body"}<br/>     ]<br/>  },<br/>  'news.yahoo.com'{},<br/>  'bloomberg.com':{}<br/>}</span></pre><p id="3c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将需要确定文章中的哪些元素是垃圾。我们可以看到有一个<code class="fe oa ob oc nr b">ad</code>类(记住现实生活中不会这么简单)。因此，为了指定我们想要删除它，我们将在配置模型中创建一个<code class="fe oa ob oc nr b">unwanted_elements</code>元素:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="5c89" class="nv mr it nr b gy nw nx l ny nz">models = {<br/>  'finance.yahoo.com':{<br/>       'root-element':[<br/>            'article', <br/>            {'class': "canvas-body"}<br/>        ],<br/>        'unwanted_elements': [<br/>            'p',<br/>            {'class': "ad"}<br/>        ]<br/>  },<br/>  'news.yahoo.com'{},<br/>  'bloomberg.com':{}<br/>}</span></pre><p id="2bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经剔除了一些垃圾，我们需要注意我们想要保留哪些元素。因为我们只寻找文章元素，所以我们只需要指定我们想要保留的<code class="fe oa ob oc nr b">p</code>和<code class="fe oa ob oc nr b">h1</code>元素:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="644b" class="nv mr it nr b gy nw nx l ny nz">models = {<br/>  'finance.yahoo.com':{<br/>       'root-element':[<br/>            'article', <br/>            {'class': "canvas-body"}<br/>        ],<br/>        'unwanted_elements': [<br/>            'p',<br/>            {'class': "ad"}<br/>        ]<br/>        'text_elements': [<br/>            ['p'],<br/>            ['li']<br/>        ]  },<br/>  'news.yahoo.com'{},<br/>  'bloomberg.com':{}<br/>}</span></pre><p id="abfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是最后一部分——主聚合器！我将忽略配置文件的解包和加载。如果我写了全部代码，这篇文章将永远不会结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="699d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="9577" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">使用这段代码，您可以创建一个模板，用于从任何网站提取文章文本。你可以看到完整的代码，以及我是如何开始在我的GitHub上实现它的。</p><div class="od oe gp gr of og"><a href="https://github.com/dtaivpp/NewsTicker/blob/master/src/scrape_page.py" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">dtaivpp/NewsTicker</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这个项目抓取网页，并为股票代码创建一个公共舆论行情指示器</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>