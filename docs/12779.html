<html>
<head>
<title>How to Write a Web App in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Rust编写Web应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-web-app-in-rust-part-1-3047156660a7?source=collection_archive---------0-----------------------#2022-07-01">https://betterprogramming.pub/how-to-write-a-web-app-in-rust-part-1-3047156660a7?source=collection_archive---------0-----------------------#2022-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="169f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第一部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a91cdf2251c3e9e95a3f83f111dcd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hdPPFYOUoiYdAY_O"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">科比·门德斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="84cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是关于编写web应用程序的系列文章的第一部分。对于这个系列，我们将在<a class="ae kv" href="https://www.rust-lang.org/learn/get-started" rel="noopener ugc nofollow" target="_blank"> Rust </a>中编写web应用程序，我会向你解释如何自己编写。</p><p id="1aea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您不愿意自己编写代码，我已经创建了一个存储库，其中包含了本系列中编写的所有代码。在本系列的每一部分的结尾，我都提交了一个存储库。</p><h1 id="423d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">本系列的目标</h1><p id="a6d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">框架是强大而有用的工具。他们抽象出了创建web应用程序的许多令人痛苦的细节。理论上，这意味着新开发人员可以更快地帮助开发，老开发人员甚至可以更有效率，因为他们不必通过繁琐的、低级的细节来挖掘。</p><p id="a681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，一个框架最大的优点也是它最大的弱点。从长远来看，那些只知道如何使用框架，而不知道框架抽象出了什么的新开发人员可能效率更低。当使用这个框架时，他们可能并不完全知道他们在做什么。而且，在框架失败的情况下，开发人员可能不知道如何修复它，因为他们根本不知道框架在做什么。</p><p id="62ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我希望通过写这篇文章来解决这个问题。通过使用一个示例项目，我想从头开始构建一个web应用程序，并慢慢将其升级为使用框架的更现代的应用程序。这样做，我们应该能够看到为什么某些设计选择和框架如此普遍，并且应该对我们所依赖的框架获得更大的赞赏。</p><h1 id="b96e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是web app？</h1><p id="3c8d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当做任何大的或复杂的事情时，问几个问题是很重要的。前两个是<em class="mp">为什么</em>和<em class="mp">什么</em>。如果我们知道这些问题的答案，我们的目标和达到目标所需的步骤就会变得更加明显。一旦我们心中有了具体的目标，就很容易一步一步地达到你更大的目标。我们已经讨论了<em class="mp">为什么</em>我们要建立一个网络应用。我刚刚在目标部分提到了这一点，我相信你可以提出许多其他的理由来解释你为什么要建立一个目标。一般来说，是为了解决一些问题。</p><p id="2427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里重要的问题是<em class="mp">什么是</em>网络应用。我们大多数人对其中一个都有相当直观的理解。它是一个网站。比如谷歌、YouTube或网飞。你在浏览器中输入一个网址，它会把你带到一个页面，你可以点击按钮做一些事情。然而，我们希望有一个能帮助我们理解网站技术层面的定义，这个定义太模糊了，不能告诉我们更多关于网络开发的东西。所以，让我们深入研究一下。</p><h1 id="c368" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本的Web应用程序定义</h1><p id="19e2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通过在浏览器中输入URL来进入web应用。运行浏览器的计算机被称为<em class="mp">客户端</em>。这个URL将你连接到另一台名为<em class="mp">服务器</em>的计算机。该服务器向客户端提供内容。然后，客户端将服务器提供的内容显示给用户。通常，客户端还提供不同的表单来输入新数据。这些数据被发送到服务器，服务器向客户端提供新的内容。客户端向服务器发送数据称为<em class="mp">请求</em>，服务器向客户端发回数据称为<em class="mp">响应</em>。如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/6f685937df857d6fb9de790369057a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CsKZHHyvQkhy-SQS.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自Reinvently的<a class="ae kv" href="https://reinvently.com/blog/fundamentals-web-application-architecture/" rel="noopener ugc nofollow" target="_blank">Web应用如何工作——简化的Web应用架构</a></p></figure><p id="501c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们编写的web应用程序运行在服务器上。因此，web应用程序的工作是接收传入的请求，处理它们，并发回包含客户端使用的内容的适当响应。这个“内容”当然是我们的前端。我们的用户在浏览器中看到并用来发送请求的HTML、CSS和JavaScript。因此，当我们说我们要“用Rust编写一个web应用程序”时，我们实际上是在说我们要用Rust编写一个程序，处理传入的请求，并以HTML、CSS和JavaScript的形式发回适当的响应。</p><p id="1050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，并不是所有的响应都是HTML、CSS和JavaScript的形式。回应可以以各种形式出现。好多回复其实都是JSON。最终，这个响应以某种方式变成了可以在浏览器中查看的HTML，但是服务器并不总是直接发送HTML。事实上，如果您在过去几年中编写过web应用程序，您可能已经熟悉JSON响应了。</p><h1 id="96cf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更现代的Web应用程序定义</h1><p id="f7d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">近年来，网络应用的定义已经发生了一些变化。像React这样的框架改变了web应用的结构。有了在<code class="fe mr ms mt mu b">create-react-app</code>中创建的React应用程序，你就有了一个更像下面这样的结构。</p><p id="4ecb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户不是直接连接到服务器，而是连接到一台计算机，该计算机提供使用React编译的前端。当用户发出请求时，这台计算机会将请求发送到包含该服务器的另一台计算机。服务器将数据和React代码一起发送回计算机，然后React代码使用该数据向用户发送响应。(不过，我要提一下，这种情况只有在开发期间使用<code class="fe mr ms mt mu b">create-react-app</code>时才会发生。通常，当您部署React应用程序时，它会回到两台计算机的体系结构，只是将花哨的React编译的JavaScript发送到客户端)</p><p id="1ee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种体系结构中，用户与两台计算机交互。一个持有React前端，另一个持有一些只传递数据的后端。具有前端的计算机使用来自后端的数据来创建发送给用户的响应。</p><p id="b2d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种架构为开发人员带来了一些优势，因为编写前端和后端可以变得容易得多。有时后端基本上只是保存和返回前端告诉它的数据，几乎不处理数据。这就是为什么有些人说现代网站只是数据库的花哨包装。后端基本上可以只是一个数据库，前端只是一个非常复杂的包装器。</p><p id="590c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这个定义对于我们将要编写的web应用程序并不是特别有用，但是由于许多web应用程序最终都是这样构造的，所以我认为它值得一提。</p><h1 id="a311" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于请求和响应的注释</h1><p id="261f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">遗憾的是，在我们深入研究这个例子之前，还有一些技术术语需要理解。正如我在上一节中介绍的，用户向服务器发送请求，服务器返回响应。然而，稍微了解一下这些请求和响应的样子是很重要的。</p><h1 id="9133" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">HTTP协议</h1><p id="bd9a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">服务器和客户端通过HTTP进行通信。它是一个协议，这意味着它是一组确定数据如何传输的规则。用更熟悉的术语来说，它是服务器和客户机同意相互通信的一种方式。</p><p id="0dc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HTTP中的请求如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/5be24cb5a975d40d3f1aaa6f06d7404e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/0*HIw8C7GRWu5juPph.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自MDN的文章:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" rel="noopener ugc nofollow" target="_blank">HTTP概述</a></p></figure><p id="93a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，我们发送一个方法、某个URL(这就是“Path”的含义)、协议的版本、一些向服务器传递信息的头和一个主体(取决于方法。一个<code class="fe mr ms mt mu b">GET</code>方法没有主体，这就是这里没有显示主体的原因。一些API，比如<a class="ae kv" href="https://www.elastic.co/elasticsearch/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>，违背了标准的指定定义，确实要求带有<code class="fe mr ms mt mu b">GET</code>请求的主体，但是，同样，这不是标准的，通常应该避免。通常，用户输入的信息位于主体中，但是用户可能会添加服务器要在路径或头中使用的信息。身体本身可以有许多不同的形式。常见的两种是JSON和x-www-form-urlencoded。无论如何，基于请求中给出的信息，服务器会确定一个合适的响应，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/dc770770868eab3d776312b4b8d82f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fEUNySZFNTpQZc9A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自MDN的文章:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" rel="noopener ugc nofollow" target="_blank">HTTP概述</a></p></figure><p id="dc41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代替方法和路径，我们有一个状态代码和消息，它告诉我们请求发生了什么。我们仍然有协议的版本、报头和主体。大多数时候，在像我们这样结构化的web应用程序中，响应的主体是HTML，浏览器将显示该HTML。</p><p id="23df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是大多数(如果不是全部的话)浏览器发送和接收数据的方式，因此，我们的web应用程序需要适应这种方式。</p><h1 id="731a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">查询语言</h1><p id="6f27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">近年来，一种叫做<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的查询语言变得相当流行。如果您知道上面的部分，您可能会对GraphQL之类的东西是如何工作的感到困惑，因为您发出的请求和响应如下所示:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="ef8e" class="nb lt iq mu b gy nc nd l ne nf">{<br/>  me {<br/>    name<br/>  }<br/>}</span></pre><p id="c178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不知何故，浏览器和服务器仍然能够理解。这是如何工作的？嗯，查询语言基本上是进行HTTP请求和响应的奇特方式。您用类似GraphQL的东西写出一段代码，然后某个程序将它转换成一系列HTTP请求和响应。</p><p id="e561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您继续开发web应用程序，您可能会最终使用或看到查询语言，重要的是要记住，它们仍然在使用相同的技术，但是，就像框架一样，它是一个抽象层，有助于使web开发更容易。</p><h1 id="3c2c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于行话的最后一点</h1><p id="4581" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，在我们继续之前，我只想推荐MDN Web Docs的这篇文章:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" rel="noopener ugc nofollow" target="_blank">HTTP的概述</a>。它涵盖了我刚刚提到的所有内容:服务器、客户机、请求、响应和HTTP。如果你想以稍微不同的方式听到所有这些解释，这可能会帮助你更好地理解它，这是一个伟大的资源。</p><h1 id="bc52" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">放到应用程序上</h1><p id="9942" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后，在1400字的内容之后，我们已经开始实际构建我们的应用程序了。该应用程序将很简单:这将是一个待办事项应用程序。换句话说，我们正在制作一个应用程序，允许用户创建一个待办事项列表，编辑待办事项列表中的任务，并完成待办事项列表中的任务。为什么我们要以Todo app为例？因为大多数web应用程序需要允许用户创建、读取、更新和删除他们有权访问的数据。这非常重要，甚至有了一个很酷的缩写:CRUD(创建、读取、更新、删除)操作。Todo应用程序是一个非常简单的例子，我们可以轻松直观地看到所有的CRUD操作。</p><p id="7a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<a class="ae kv" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>来创建这个应用程序。所以，把它安装好，也许还可以看看<a class="ae kv" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">这本书</a>来熟悉这门语言。我会尽最大努力解释每一步发生了什么，但我不能保证我会解释我们编写的代码的每个小方面。</p><h1 id="a7ab" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建项目</h1><p id="a3cf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们的第一步是创建应用程序的框架，我们将使用Rust的包管理器<code class="fe mr ms mt mu b">cargo</code>来完成这项工作。打开您的终端，转到您想要存储项目的目录，然后运行</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="7734" class="nb lt iq mu b gy nc nd l ne nf">cargo new todo-app</span></pre><p id="7e12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在名为<code class="fe mr ms mt mu b">todo-app</code>的文件夹中创建一个Rust项目，并将该文件夹放在您的工作目录中。这样，您就可以打开这个项目，您会发现下面的文件。</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="2d09" class="nb lt iq mu b gy nc nd l ne nf">todo-app<br/>│   .gitignore<br/>│   Cargo.toml<br/>│<br/>└───src<br/>        main.rs</span></pre><p id="a166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">.gitignore</code>对我们的目的并不重要。<code class="fe mr ms mt mu b">Cargo.toml</code>是我们指定项目中要使用的所有库的地方，而<code class="fe mr ms mt mu b">main.rs</code>是我们的Rust代码要去的地方。</p><h1 id="4bc3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用Rocket制作Web应用程序</h1><p id="ae05" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这样一来，我们将安装一个名为<a class="ae kv" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> Rocket </a>的web框架来创建我们的web应用程序。现在，它的整个目标是从头开始制作一个web应用程序，所以在“从头开始”构建它时使用一个框架似乎有点违背直觉。然而，Rocket不会抽象出对学习更多web应用程序特别重要的任何细节。它基本上只是处理接收和发送我们前面讨论过的HTTP请求和响应。虽然我们可以自己尝试实现HTTP协议，但那会很麻烦，我们也不会学到很多东西。此外，实现协议既困难又乏味，所以我想不惜一切代价避免它。</p><p id="5c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们都在同一页上，让我们建立一个基本的例子。首先在<code class="fe mr ms mt mu b">Cargo.toml</code>中，添加Rocket作为依赖。一旦你这样做了，你的<code class="fe mr ms mt mu b">Cargo.toml</code>应该看起来像这样</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7ff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，转到<code class="fe mr ms mt mu b">main.rs</code>，删除里面的所有内容，替换成下面的代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5a6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码是如何工作的？第一行导入我们从Rocket安装的所有东西，<code class="fe mr ms mt mu b">#[macro_use]</code>意味着我们显式地导入Rocket，所以它的宏(通过写出一个名字调用的代码片段)被全局安装。<code class="fe mr ms mt mu b">#[get("/")]</code>是一个被应用到<code class="fe mr ms mt mu b">index</code>函数的<a class="ae kv" href="https://doc.rust-lang.org/reference/attributes.html" rel="noopener ugc nofollow" target="_blank">函数属性</a>(如果你知道这个东西，很可能是一个<a class="ae kv" href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros" rel="noopener ugc nofollow" target="_blank">属性宏</a>)。这个属性是从Rocket导入的，这意味着如果用路径“/”调用HTTP <code class="fe mr ms mt mu b">GET</code>请求，就会调用<code class="fe mr ms mt mu b">index</code>。</p><p id="4b26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">index</code>，函数，只是返回字符串“Hello，world！”。应用于<code class="fe mr ms mt mu b">rocket</code>函数的<code class="fe mr ms mt mu b">#[launch]</code>属性意味着，当代码运行时，它将通过运行<code class="fe mr ms mt mu b">rocket</code>函数开始。</p><p id="476e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那个launch属性也做了一些代码魔术来设置我们的服务器，但是我们现在忽略它。最后，<code class="fe mr ms mt mu b">rocket::build().mount("/", routes![index])</code>正在向服务器添加我们之前创建的<code class="fe mr ms mt mu b">index</code>函数。仅仅将属性应用到<code class="fe mr ms mt mu b">index</code>是不够的，我们还必须挂载<code class="fe mr ms mt mu b">index</code>。</p><p id="4722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来测试一下！在终端中导航到您的项目目录，并运行以下命令</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="b7af" class="nb lt iq mu b gy nc nd l ne nf">cargo run</span></pre><p id="2f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到一堆正在编译的包，当编译完成时，您应该会得到一条类似如下的消息</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="f236" class="nb lt iq mu b gy nc nd l ne nf">Rocket has launched from <a class="ae kv" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000</a></span></pre><p id="c03e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到那个链接，你会看到一页写着“你好，世界！”。因此，随着软件包的安装，我们已经创建了一个基本的web应用程序。如果你想知道那个链接是什么，<code class="fe mr ms mt mu b">127.0.0.1</code>只是你所在的电脑的名称。因为您在计算机上运行服务器，所以您连接到计算机来查看web应用程序。</p><p id="0239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那串数字的另一个名字是<code class="fe mr ms mt mu b">localhost</code>。将这个web应用程序部署到一台计算机并连接到那台计算机有点棘手，但是，基本上，另一台计算机会有一些号码，您可以像在这里一样连接到它。通常，我们给这些数字命名，这样用户就不必写出一长串数字。这些名称及其相关号码存储在<a class="ae kv" href="https://en.wikipedia.org/wiki/Domain_Name_System" rel="noopener ugc nofollow" target="_blank">域名系统(DNS) </a>中。</p><p id="92c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管怎样，如果您查看终端输出，您会注意到如下所示的内容</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="7898" class="nb lt iq mu b gy nc nd l ne nf">GET / text/html:<br/>   &gt;&gt; Matched: (index) GET /<br/>   &gt;&gt; Outcome: Success<br/>   &gt;&gt; Response succeeded.</span></pre><p id="186f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们的服务器收到了一个HTTP <code class="fe mr ms mt mu b">GET</code>请求(<code class="fe mr ms mt mu b">GET</code>是HTTP方法之一)，并成功发回了一个响应。当我们在浏览器中输入网址时，我们向服务器发送一个<code class="fe mr ms mt mu b">GET</code>请求，服务器调用<code class="fe mr ms mt mu b">index</code>函数，它返回“你好，世界！”。</p><h1 id="7501" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建任务</h1><p id="b6ac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们可以进入CRUD操作的C:创建。我们想要做的是，当一个带有任务数据的<code class="fe mr ms mt mu b">POST</code>请求在<code class="fe mr ms mt mu b">/addtask</code>路径上完成时，应用程序将任务保存在它能记住的地方。</p><p id="c6bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么使用<code class="fe mr ms mt mu b">POST</code>而不是<code class="fe mr ms mt mu b">GET</code>或者许多其他HTTP请求方法中的一种？因为<code class="fe mr ms mt mu b">POST</code>应该专门用于在服务器端创建数据的请求。为什么路径<code class="fe mr ms mt mu b">/addtask</code>？因为用于在web应用程序中执行某些操作的路径应该是不言自明的。当创建一个请求时，如果请求的路径是<code class="fe mr ms mt mu b">/addtask</code>，您知道您可能正在创建一个任务。为什么数据在请求体中？</p><p id="1911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为那通常是数据去的地方。请求中的头通常用于元数据。除非您输入小而简单的数据，否则通常不应该使用参数和其他通过路径本身输入数据的方式。</p><p id="29cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很明显，一旦任务被创建，我们将希望以某种方式存储它们，以便我们可以检索它们来读取、更新或删除它们。但是，我们不希望将数据存储在变量中，因为如果服务器关闭，无论是由于某种错误还是为了维护它，数据都会丢失。此外，随着时间的推移，程序的规模只会继续增长，速度会越来越慢。因此，我们需要使用不同的解决方案来长期存储这些任务。</p><p id="c2b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，由于我们是从零开始构建的，就像我们是制作原始web应用程序的人，并且没有访问某些工具的权限，我们将选择一个在当时有意义的解决方案。那就是将数据存储在一个文件中。文件是一种即使程序停止运行或计算机关闭后仍存在于计算机中的东西，每种编程语言都可以对文件进行某种形式的创建、编辑和删除。</p><p id="08e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住这一点，让我们编写添加任务函数。为添加任务而添加的代码如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="65c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">Task</code>的<code class="fe mr ms mt mu b">struct</code>前面的属性基本上表示从HTTP JSON主体中提取的数据将被放入这个结构中。post属性中的<code class="fe mr ms mt mu b">data="&lt;task&gt;"</code>表示主体数据应该进入<code class="fe mr ms mt mu b">task </code>参数。<code class="fe mr ms mt mu b">task</code>参数采用的<code class="fe mr ms mt mu b">Json&lt;Task&lt;'_&gt;&gt;</code>类型告诉Rocket将主体解析为JSON，并将数据保存到一个<code class="fe mr ms mt mu b">Task</code>结构中。</p><p id="1572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">OpenOptions</code>行将打开或创建一个名为<code class="fe mr ms mt mu b">tasks.txt</code>的文件，并对其进行设置，以便无论何时我们向其写入，我们都是在添加而不是覆盖。<code class="fe mr ms mt mu b">task_item_string</code>和<code class="fe mr ms mt mu b">task_item_bytes</code>从<code class="fe mr ms mt mu b">Task</code>结构中获取数据，并将其转换成可以写入文件的内容。最后，我们将它写入文件，并返回一个字符串，表示我们已经成功完成了任务。</p><p id="89ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在此工作之前，我们需要修改我们的<code class="fe mr ms mt mu b">rocket</code>函数，如下所示:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="6174" class="nb lt iq mu b gy nc nd l ne nf">#[launch]<br/>fn rocket() -&gt; _ {<br/>    rocket::build().mount("/", routes![index, add_task])<br/>}</span></pre><h1 id="0fcd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试我们的创建任务方法</h1><p id="6e09" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有了这个方法，我们想测试这个，但是我们怎么做呢？在本教程中，我们将使用一个名为<a class="ae kv" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>的软件向我们的服务器发送HTTP请求，但是发送请求有多种选择(如<a class="ae kv" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>)。要使用Postman，您需要从网站安装它，创建一个帐户并登录。之后，点击<code class="fe mr ms mt mu b">File&gt;New</code>，在出现的页面上选择HTTP request。从那里，你想让你的请求看起来像这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/642967b78a7f9108f5b469f34ac420cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vzSUVDy1qfGS8LNZgMAfw.png"/></div></div></figure><p id="8800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将方法设置为POST，将URL设置为<a class="ae kv" href="http://127.0.0.1:8000/addtask" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/add task</a>，将主体设置为类型为JSON的<code class="fe mr ms mt mu b">raw</code>，并包含以下JSON</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="5c08" class="nb lt iq mu b gy nc nd l ne nf">{<br/>    "item": "Turn into a dragon"<br/>}</span></pre><p id="4733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，回到你的终端，点击<code class="fe mr ms mt mu b">Ctrl-C</code>结束你正在运行的服务器，再次运行<code class="fe mr ms mt mu b">cargo run</code>启动服务器备份。一旦服务器恢复正常，点击“邮递员发送”。web应用程序应该在终端中给出如下输出:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="2199" class="nb lt iq mu b gy nc nd l ne nf">POST /addtask application/json:<br/>   &gt;&gt; Matched: (add_task) POST /addtask<br/>   &gt;&gt; Outcome: Success<br/>   &gt;&gt; Response succeeded.</span></pre><p id="8cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Postman中的响应框应该显示“任务添加成功”。如果你回到你的项目目录，你会注意到一个名为<code class="fe mr ms mt mu b">tasks.txt</code>的文件已经被创建，它包含以下内容:</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="49df" class="nb lt iq mu b gy nc nd l ne nf">Turn into a dragon</span></pre><p id="8fc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你！我们的webapp现在可以创建任务了。</p><h1 id="8bcd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">阅读任务</h1><p id="d512" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们不能从应用程序中获得任务，那么拥有任务还有什么意义？那个问题是反问句。没有意义。所以，让我们让我们的web应用程序更有用一些，让它返回我们所有的任务。我们将这样做，当一个<code class="fe mr ms mt mu b">GET</code>请求通过路径<code class="fe mr ms mt mu b">/readtasks</code>发送到服务器时，我们将发送回我们存储在<code class="fe mr ms mt mu b">tasks.txt</code>中的所有任务。我们使用一个<code class="fe mr ms mt mu b">GET</code>方法，因为这是从服务器读取数据时的预期方法。所以，让我们跳过所有无聊的东西，直接进入代码！</p><p id="dd39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要修改我们的<code class="fe mr ms mt mu b">task</code>结构，如下所示</p><pre class="kg kh ki kj gt mx mu my mz aw na bi"><span id="2a78" class="nb lt iq mu b gy nc nd l ne nf">#[derive(Deserialize, Serialize)]<br/>#[serde(crate = "rocket::serde")]<br/>struct Task&lt;'r&gt; {<br/>    item: &amp;'r str<br/>}</span></pre><p id="3e74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，对于实际读取任务的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b18e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以使用postman向我们的服务器发送一个<code class="fe mr ms mt mu b">GET</code>请求(在停止之后，将<code class="fe mr ms mt mu b">read_tasks</code>添加到我们的路由并重新运行)，我们可以看到我们得到了一个返回的任务列表</p><h1 id="ac02" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更新任务</h1><p id="3269" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">呼-男孩！既然我们已经完成了创建和读取任务的所有工作，现在我们有一个问题。像现在这样编辑它们，很难也不可能。有什么问题？我们如何告诉计算机我们想要编辑什么任务？到目前为止，唯一的方法是输入完整的原始消息，但是不能保证某人不会有两个完全相同的任务。因此，我们将不得不存储带有附加信息的任务，这些附加信息将用于识别某些任务。这将要求我们编辑我们的<code class="fe mr ms mt mu b">add_task</code>函数和<code class="fe mr ms mt mu b">read_tasks</code>函数，所以让我们进行编辑</p><h1 id="d824" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编辑我们以前的功能</h1><p id="17b0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们要添加哪些附加信息？我们会在每项任务旁边标上数字。我们称之为“id ”,因为它将标识我们的任务。我们如何知道id在哪里结束，任务在哪里开始？我们用逗号将两者分开。然后，稍后，我们可以将它保存为一个<code class="fe mr ms mt mu b">csv</code>文件，并在像Excel这样的软件中非常容易地打开它。记住这一点，让我们为实现这一目标做出改变。首先，在<code class="fe mr ms mt mu b">add_task</code>中，我们使用一个<code class="fe mr ms mt mu b">BufReader</code>来计算文件中的行数。行数是新任务的<code class="fe mr ms mt mu b">id</code>。看起来是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe mr ms mt mu b">read_tasks</code>，我们并不特别关心<code class="fe mr ms mt mu b">id</code>，所以我们只是丢弃了它，如下面的代码所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6ce4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可能会注意到，为了实现这一点，我在最后一行的<code class="fe mr ms mt mu b">map</code>函数中做了很多工作。让我们快速讨论一下。</p><p id="9a47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe mr ms mt mu b">split</code>方法将我们的原始线分成多个部分。然而，split方法将一个<code class="fe mr ms mt mu b">String</code>分割成一串字符串片<code class="fe mr ms mt mu b">&amp;str</code>。这意味着我们没有一个拥有一堆字符串的迭代器，而是有一个对原始字符串的引用的迭代器。当我们将迭代器收集到一个向量中时，我们有一个引用向量(<code class="fe mr ms mt mu b">&amp;str</code>)，而不是一个拥有字符串的向量(<code class="fe mr ms mt mu b">String</code>)。因此，在最后一行中，当我们提取我们想要的片段时，我们使用<code class="fe mr ms mt mu b">to_string()</code>方法创建一个拥有的字符串片段版本，我们可以自由地将它交给<code class="fe mr ms mt mu b">map</code>正在创建的数组。我们不能放弃字符串片段，因为它是对一个变量的引用，一旦我们离开<code class="fe mr ms mt mu b">map</code>，这个变量就会被删除。</p><p id="9f40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，我们对创建和读取函数的所有编辑都完成了，现在我们可以创建一个编辑函数了。</p><h1 id="d76b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编辑功能</h1><p id="b8ae" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这将是一个放在路径<code class="fe mr ms mt mu b">/edittask</code>上的<code class="fe mr ms mt mu b">PUT</code>请求。修改的代码很棒，但它就在这里</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b0fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将该函数添加到<code class="fe mr ms mt mu b">rocket</code>函数的挂载中，删除<code class="fe mr ms mt mu b">tasks.txt</code>重新运行程序，使用Postman发送请求，现在就可以编辑任务了！</p><p id="84e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个函数，它的工作方式并不完全是最佳的，但是可以满足我们演示使用文件存储数据的目的。将数据存储在文件中的问题是很难就地编辑。你可以使用seekers，然后在特定的位置写，并试图删除某些位，但这通常是一种痛苦。因此，我们取而代之的是，一行一行地把我们的文件写入一个临时文件<code class="fe mr ms mt mu b">temp.txt</code>。当我们编写<code class="fe mr ms mt mu b">temp.txt</code>时，我们进行了修改，正如我们在<code class="fe mr ms mt mu b">for...in</code>循环中的<code class="fe mr ms mt mu b">if</code>语句所示。</p><p id="5488" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们写了<code class="fe mr ms mt mu b">temp.txt</code>，我们就删除原来的<code class="fe mr ms mt mu b">tasks.txt</code>，并将<code class="fe mr ms mt mu b">temp.txt</code>重命名为<code class="fe mr ms mt mu b">tasks.txt</code>。当然，随着我们的文件变大，这将花费更长的时间，而且总是担心要正确地复制所有的内容，但是我不知道有多少更好的解决方案。完成后，我们现在可以开始删除任务了。</p><h1 id="24ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">删除任务</h1><p id="f88d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，我们基本上将使用与编辑任务完全相同的过程来执行删除任务。我们将把所有内容写入一个临时文件，删除旧文件，并重命名临时文件。就我们实际的API而言，这将利用一个<code class="fe mr ms mt mu b">DELETE</code>方法，并将拥有<code class="fe mr ms mt mu b">/deletetask</code>路径。一些代码！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将它添加到您的项目中，并使用Postman进行测试，您应该会注意到我们最终删除了我们的任务。万岁！这样，我们就创建了所有的CRUD操作。</p><p id="79bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将结束这一系列的第一部分。在这一部分中，我们了解到，即使我们的应用程序还没有一个合适的前端，我们也可以通过读写文件来执行CRUD操作。<a class="ae kv" href="https://medium.com/@garrettudstrand/how-to-write-a-web-app-in-rust-part-2-2da195369fc1" rel="noopener">在下一部分</a>，我们将看看数据库，以及我们如何使用它们来使我们的CRUD操作更容易实现。</p><p id="99ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读这篇文章。我希望它和它的下一期文章将有助于提高您的web开发技能。</p><h1 id="5517" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="e8c9" class="nj nk iq ky b kz mk lc ml lf nl lj nm ln nn lr no np nq nr bi translated"><a class="ae kv" href="https://www.rust-lang.org/learn/get-started" rel="noopener ugc nofollow" target="_blank">入门— Rust编程语言(rust-lang.org)</a></li><li id="d44b" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://github.com/garrettudstrand/rust-web-app/tree/main" rel="noopener ugc nofollow" target="_blank">本系列的GitHub库</a></li><li id="b0c2" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://reinvently.com/blog/fundamentals-web-application-architecture/" rel="noopener ugc nofollow" target="_blank">网络应用如何工作——网络应用架构简化|彻底改造</a></li><li id="66fd" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">【mozilla.org T4】HTTP-HTTP | MDN概述</li><li id="7e6c" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://www.elastic.co/elasticsearch/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch:官方分布式搜索&amp;分析引擎| Elastic </a></li><li id="b09a" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL |您的API的查询语言</a></li><li id="15ef" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">《Rust编程语言手册》(rust-lang.org)</a></li><li id="fb2b" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://doc.rust-lang.org/reference/attributes.html" rel="noopener ugc nofollow" target="_blank">属性—铁锈参考(rust-lang.org)</a></li><li id="7fbb" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros" rel="noopener ugc nofollow" target="_blank">程序宏-锈蚀参考(rust-lang.org)</a></li><li id="2705" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Domain_Name_System" rel="noopener ugc nofollow" target="_blank">域名系统—维基百科</a></li><li id="d0d8" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮差API平台</a></li></ul></div></div>    
</body>
</html>