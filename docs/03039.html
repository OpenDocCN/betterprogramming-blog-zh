<html>
<head>
<title>What’s the Difference Between Primitive Values and Object References in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原始值和对象引用有什么区别？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/intermediate-javascript-whats-the-difference-between-primitive-values-and-object-references-e863d70677b?source=collection_archive---------6-----------------------#2020-01-16">https://betterprogramming.pub/intermediate-javascript-whats-the-difference-between-primitive-values-and-object-references-e863d70677b?source=collection_archive---------6-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不可变数据和可变数据之间的重要区别</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e16d283b39aae6a2bd4df5ee82d1e2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dDF7PyVFjdRy22b4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·高尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中的所有数据类型都可以归为两类:<strong class="lb iu">原始值</strong>和<strong class="lb iu">对象引用</strong>。</p><p id="96d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始值和对象引用的行为不同。这种行为上的差异会影响变量赋值的方式、等式运算符获得结果的方式以及JavaScript程序的一般运行方式。</p><p id="a9ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解原始值和对象引用之间的区别对于掌握JavaScript这种编程语言至关重要。这篇文章将深入解释和说明这种区别。</p><p id="2ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将涵盖以下细节:</p><ul class=""><li id="1671" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">哪些JavaScript数据类型属于每个类别。</li><li id="5474" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个值和一个参考值之间的差别。</li><li id="51a5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不可变数据和可变数据的区别。</li><li id="d3ea" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">比较原始值和对象引用如何工作的实际例子。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7946" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">对JavaScript的八种数据类型进行分类</h1><p id="9359" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JavaScript目前支持八种不同的数据类型。这包括七个原始值类型和<code class="fe nn no np nq b">objects</code>。这是完整的清单。</p><ul class=""><li id="5518" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b">Boolean</code></li><li id="8bca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">Null</code></li><li id="d2cb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">Undefined</code></li><li id="d7e6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">Number</code></li><li id="478d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">BigInt</code></li><li id="48a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">String</code></li><li id="8114" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">Symbol</code></li><li id="9a62" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">Objects</code></li></ul><p id="cfb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是JavaScript新手，这个列表可能会让您觉得奇怪:<code class="fe nn no np nq b">arrays</code>、<code class="fe nn no np nq b">functions</code>和<code class="fe nn no np nq b">dates</code>都不见了。</p><p id="8399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个错误。<code class="fe nn no np nq b">Arrays</code>、<code class="fe nn no np nq b">functions</code>和<code class="fe nn no np nq b">dates</code>都在JavaScript程序中扮演着重要的角色，但它们实际上只是引擎盖下的对象。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f877" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">值和引用之间的差异</h1><p id="c345" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">原始值和对象引用以不同的方式存储在JavaScript程序中。</p><p id="58a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个原始值被分配给一个变量(如<code class="fe nn no np nq b">let foo = ‘bar’</code>)时，该变量被直接设置为那个<strong class="lb iu">值</strong>。</p><p id="b2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当变量被赋予一个对象时，情况就不同了。该变量包含一个对它的引用，而不是直接包含值。这里有一个例子:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="afd5" class="nv mr it nq b gy nw nx l ny nz">const moe = {<br/>  name: 'Moe Szyslak',<br/>  occupation: 'Bartender',<br/>  voicedBy: 'Hank Azaria'<br/>}</span></pre><p id="d32a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当执行上面的代码时，JavaScript创建对象并将其存储在计算机内存中的某个地方。变量<code class="fe nn no np nq b">moe</code>不直接包含新对象，它包含一个对当前存储该对象的内存地址的引用。</p><p id="3765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点像街道地址不包含与特定住所相关的所有信息，它只包含住所在地理上的位置<strong class="lb iu">。</strong></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dcb9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">不可变数据和可变数据的区别</h1><p id="0e75" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">原始值和对象引用之间的一个关键区别是<strong class="lb iu">可变性</strong>。原始值是不可变的，对象引用是可变的。</p><p id="4ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，这意味着原语值不能改变(或者<em class="oa">突变</em>，但是对象引用<em class="oa">可以改变</em>。</p><p id="1990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这一点，我们来看一些代码。</p><h2 id="3d44" class="nv mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">不可变数据的一个例子</h2><p id="d27c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">首先，我们来看一个<strong class="lb iu">不可变的</strong> <em class="oa"> </em>数据类型——字符串。首先，我们将创建一个变量<code class="fe nn no np nq b">word</code>，并为其赋值。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="b73e" class="nv mr it nq b gy nw nx l ny nz">let word = 'snow'</span></pre><p id="7147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量现在存在于内存中，您可以使用方括号符号来访问字符串中的各个字母。例如，如果我想获得第一个字母，我可以检查<code class="fe nn no np nq b">0</code>索引中的值，并将其记录到控制台。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="4c0d" class="nv mr it nq b gy nw nx l ny nz">console.log(word[0]) // "s"</span></pre><p id="316d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读<em class="oa"> </em>字符串的单个字符是没有问题的。然而你做不到的，是改变<em class="oa"> </em>(或者写)<em class="oa"> </em>这些个别的字。让我们看看当你尝试时会发生什么:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="3191" class="nv mr it nq b gy nw nx l ny nz">word[0] = 'k'<br/>console.log(word) // "snow" (The code above did not change the word)</span></pre><p id="f310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不能改变字符串，因为它是不可变的。</p><p id="b4a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要绕过这个约束，你必须从旧的字符串创建一个新的字符串，并用新的值重新分配变量<code class="fe nn no np nq b">word</code>:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="8dfc" class="nv mr it nq b gy nw nx l ny nz">word = `k${word.slice(1)}`<br/>console.log(word) // "know"</span></pre><h2 id="5099" class="nv mr it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">可变数据的一个例子</h2><p id="e1b6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">接下来，让我们看一个<strong class="lb iu">可变的</strong>数据类型，数组。同样，数组实际上只是JavaScript中的特殊对象。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="5af6" class="nv mr it nq b gy nw nx l ny nz">let letters = ['s', 'n', 'o', 'w']<br/>letters[0] = 'k'<br/>console.log(letters) // (4) ["k", "n", "o", "w"]</span></pre><p id="98bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为数组是可变的，你可以直接改变它们。没有必要给<code class="fe nn no np nq b">letters</code>赋值，因为你可以直接改变现有的数组。</p><p id="e012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="oa">抛开</em> </strong> <em class="oa">:上面写的代码使用了</em> <code class="fe nn no np nq b"><em class="oa">let</em></code> <em class="oa">关键字来创建</em> <code class="fe nn no np nq b"><em class="oa">letters</em></code> <em class="oa">变量，但是你可以用</em> <code class="fe nn no np nq b"><em class="oa">const</em></code> <em class="oa">来定义变量，结果仍然是一样的。</em> <code class="fe nn no np nq b"><em class="oa">const</em></code> <em class="oa">阻止你对</em> <strong class="lb iu"> <em class="oa">重新赋值</em> </strong> <em class="oa">的值，但不阻止你对</em><strong class="lb iu"><em class="oa"/></strong><em class="oa">现有值进行突变。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0477" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">原始值和对象引用如何影响变量赋值</h1><p id="e8f5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">到目前为止，我们已经知道设置为<strong class="lb iu">原始值</strong>的变量包含实际值，设置为<strong class="lb iu">对象引用</strong>的变量只包含引用(或内存地址)。</p><p id="5658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看另一个探究这一事实如何影响变量赋值的例子。这是另一个例子:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="d7a1" class="nv mr it nq b gy nw nx l ny nz">let lead = 'John Lennon'<br/>let coLead = lead<br/>coLead = 'Paul McCartney'<br/>console.log(lead, coLead) // John Lennon Paul McCartney</span></pre><p id="515a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子创建了一个名为<code class="fe nn no np nq b">lead</code>的变量，然后创建了一个名为<code class="fe nn no np nq b">coLead</code>的新变量，并将其设置为包含<code class="fe nn no np nq b">lead</code>的内容。然后，在第三行，<code class="fe nn no np nq b">coLead</code>的值被重新赋值(记住，字符串是<strong class="lb iu">不可变的</strong>，所以它们实际上不能被改变)。</p><p id="39bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记录这些变量表明<code class="fe nn no np nq b">lead</code>和<code class="fe nn no np nq b">coLead</code>的值是<code class="fe nn no np nq b">'John Lennon'</code>和<code class="fe nn no np nq b">'Paul McCartney'</code>。</p><p id="ecd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，尽管我们在第二行将<code class="fe nn no np nq b">lead</code>分配给了<code class="fe nn no np nq b">coLead</code>，但在第三行将<code class="fe nn no np nq b">coLead</code>重新分配后，这两个值仍然不同。</p><p id="6955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们稍微修改一下示例，使用对象引用来代替原始值:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="a692" class="nv mr it nq b gy nw nx l ny nz">let lead = {<br/>  name: 'John Lennon',<br/>  group: 'The Beatles'<br/>}<br/>let coLead = lead<br/>coLead.name = 'Paul McCartney'<br/>console.log(lead, coLead)<br/>// {name: "Paul McCartney", group: "The Beatles"} is logged twice</span></pre><p id="ed6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码与前面的例子非常相似。和前面一样，脚本创建一个名为<code class="fe nn no np nq b">lead</code>的变量，然后创建一个名为<code class="fe nn no np nq b">coLead</code>的新变量，并将其设置为包含<code class="fe nn no np nq b">lead</code>的内容。</p><p id="5b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键区别在于将<code class="fe nn no np nq b">name</code>属性更改为“Paul McCartney”的那一行。我们没有重新分配<code class="fe nn no np nq b">coLead</code>的值，而是让<strong class="lb iu">变异</strong>它现有的对象。</p><p id="c6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将<code class="fe nn no np nq b">lead</code>和<code class="fe nn no np nq b">coLead</code>的值记录到控制台时，我们看到它们现在是相同的(显然Paul McCartney既是主角又是副主角。)怎么回事？</p><ul class=""><li id="f58f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">首先，在计算机内存的某个地方创建了一个具有“约翰·列侬”的<code class="fe nn no np nq b">name</code>属性的对象</li><li id="f60d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">变量<code class="fe nn no np nq b">lead</code>被赋予一个<strong class="lb iu">引用</strong>，或者内存地址，指向新创建对象。</li><li id="0129" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在第二行，创建了一个名为<code class="fe nn no np nq b">coLead</code>的新变量，并赋予它<code class="fe nn no np nq b">lead</code>的内容。但是请记住<code class="fe nn no np nq b">lead</code>没有被设置为直接值——它只是一个参考值。所以<code class="fe nn no np nq b">coLead</code>现在包含了对第一行中创建的同一个对象的第二个引用。</li><li id="b51c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">第三线<code class="fe nn no np nq b">coLead</code>是变异了。由于<code class="fe nn no np nq b">lead</code>和<code class="fe nn no np nq b">coLead</code>引用同一个对象，两个变量似乎都被改变了。</li></ul><p id="d0b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种事情往往是JavaScript程序中的问题。</p><p id="2d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想创建一个<strong class="lb iu">新的</strong>对象，而不是同一个对象的第二个引用(正如我们上面所做的)，你应该使用<code class="fe nn no np nq b">Object.assign</code>来代替:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="37e2" class="nv mr it nq b gy nw nx l ny nz">let lead = {<br/>  name: 'John Lennon',<br/>  group: 'The Beatles'<br/>}<br/>let coLead = Object.assign({}, lead, {<br/>  name: 'Paul McCartney'<br/>})<br/>console.log(lead, coLead)<br/>// {name: "John Lennon", group: "The Beatles"}<br/>// {name: "Paul McCartney", group: "The Beatles"}</span></pre><p id="5599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Object.assign</code>接受的第一个参数是目标对象。在此之后提供的任何参数都是源对象，它们的属性将被复制到目标对象上。</p><p id="29fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，一个新的对象(<code class="fe nn no np nq b">{}</code>)被创建为目标(第一个参数)，然后来自<code class="fe nn no np nq b">lead</code>对象的每个属性被应用到它(第二个参数)，然后一个新的name属性(‘Paul McCartney’)也被应用(第三个参数)。</p><p id="4abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法允许您从一个对象复制另一个对象，同时仍然保持原始对象不变。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4637" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">原始值和对象引用如何影响相等比较</h1><p id="545a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JavaScript程序经常使用<em class="oa">等式</em>运算符来检查两个值是否相同。</p><p id="88d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nn no np nq b">==</code>操作器检查<em class="oa">宽松等式</em>，使用<code class="fe nn no np nq b">===</code>操作器检查<em class="oa">严格等式</em>。</p><p id="1b77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果被比较的两个项目的值相同，松散相等运算符(<code class="fe nn no np nq b">==</code>)将返回<code class="fe nn no np nq b">true</code>。如果被比较的两个对象的值<strong class="lb iu">和</strong>类型相同，则严格相等运算符(<code class="fe nn no np nq b">===</code>)返回<code class="fe nn no np nq b">true</code>。</p><p id="f31f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常建议尽可能使用<code class="fe nn no np nq b">===</code>而不是<code class="fe nn no np nq b">==</code>，以避免可能不期望的行为(例如像<code class="fe nn no np nq b">0 == ‘’</code>)。本教程将专门使用严格等式，但是讨论的概念也适用于宽松等式。</p><p id="782e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为原语包含直接值，所以用它们进行的相等比较的执行方式可能与您预期的一样:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ac66" class="nv mr it nq b gy nw nx l ny nz">'Moe Szyslak' === 'Moe Szyslak' // true<br/>false === false // true<br/>1970 === 1970 // true<br/>undefined === undefined // true</span></pre><p id="eaa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，对象引用不直接包含值，而是包含引用。这导致对象的相等性检查给出的结果对于新开发人员来说可能不是直观的:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="13c9" class="nv mr it nq b gy nw nx l ny nz">{ name: 'Moe Szyslak' } === { name: 'Moe Szyslak' } // false<br/>[] === [] // false<br/>new Date(0) === new Date(0) // false<br/>NaN === NaN // false (NaN is another type of object)</span></pre><p id="2db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的所有四个对象比较检查中，在<code class="fe nn no np nq b">===</code>操作符的左边和右边都创建了一个新对象。尽管左侧的内容与右侧的内容相同，但存储内容的引用或内存地址是不同的。这就是为什么在每种情况下比较都是<code class="fe nn no np nq b">false</code>。</p><p id="cb01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您创建了对同一对象的重复引用，您将会看到等式检查现在为真:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1781" class="nv mr it nq b gy nw nx l ny nz">let lead = {<br/>  name: 'John Lennon',<br/>  group: 'The Beatles'<br/>}<br/>let coLead = lead<br/>console.log(lead === coLead) // true</span></pre><p id="d4ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查两个对象的<em class="oa">内容</em>(不是参考)<em class="oa"> </em>是否相同，您需要:</p><ul class=""><li id="3131" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">遍历对象，检查每个键和值是否匹配。这可能很棘手，因为对象的属性本身可能是一个对象。</li><li id="cd4e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在进行相等性检查之前，将对象转换为合适的原语。</li></ul><p id="9c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子，说明如何将对象文字转换成字符串进行比较。这应该被认为是一种快速和肮脏的方法，但我经常发现它很方便。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="94d0" class="nv mr it nq b gy nw nx l ny nz">const moeA = { name: 'Moe Szyslak' }<br/>const moeB = { name: 'Moe Szyslak' }<br/>moeA === moeB // false<br/>JSON.stringify(moeA) === JSON.stringify(moeB) // true</span></pre><p id="b8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面是如何将日期转换成数字进行比较:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="b818" class="nv mr it nq b gy nw nx l ny nz">const dateA = new Date(0)<br/>const dateB = new Date(0)<br/>dateA === dateB // false<br/>dateA.getTime() === dateB.getTime() // true</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="22d9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="a23c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">JavaScript目前支持八种数据类型。除了<strong class="lb iu">对象引用</strong>之外，所有这些数据类型(<code class="fe nn no np nq b">Booleans</code>、<code class="fe nn no np nq b">Null</code>、<code class="fe nn no np nq b">Undefined</code>、<code class="fe nn no np nq b">Number</code>、<code class="fe nn no np nq b">BigInt</code>、<code class="fe nn no np nq b">String</code>、<code class="fe nn no np nq b">Symbol</code>)都是<strong class="lb iu">原始值</strong>。</p><p id="b1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多常见的数据类型，如数组、函数和日期，都是幕后的对象引用。</p><p id="c250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始值可以直接存储在变量中。另一方面，对象存储为引用。被赋予对象的变量并不直接存储该对象，而是存储该对象所在位置的内存地址。</p><p id="6794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始值是不可变的T21——它们在被创建后不能被改变。然而，对象引用是可变的，可以被改变。</p><p id="224b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为对象是作为引用存储的，所以在复制对象和对对象执行相等检查时必须特别小心。</p><p id="3b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于JavaScript新手来说，理解这些操作是如何工作的可能会很困惑，但是一旦你理解了语言的类型系统是如何工作的，它们就有意义了。</p><p id="f598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深入掌握<strong class="lb iu">原始值</strong>、<strong class="lb iu">对象引用</strong>和<strong class="lb iu">可变性</strong>是超越JavaScript编程初级阶段的关键一步。</p><p id="d58f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些知识将帮助您识别bug，理解编程范例中的关键差异，并帮助您在更深的层次上理解您的代码。</p></div></div>    
</body>
</html>