<html>
<head>
<title>Write Your Kubernetes Infrastructure as Go Code — Getting Started With Cdk8s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的Kubernetes基础设施编写为Go代码Cdk8s入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/write-your-kubernetes-infrastructure-as-go-code-getting-started-with-cdk8s-989725f8af73?source=collection_archive---------5-----------------------#2022-07-14">https://betterprogramming.pub/write-your-kubernetes-infrastructure-as-go-code-getting-started-with-cdk8s-989725f8af73?source=collection_archive---------5-----------------------#2022-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/aa0c154d626b1f56bbc2933878a741d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlHypfWYZXvMu2Ak7CzyYg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">cdk8s.io</p></figure><div class=""/><div class=""><h2 id="cb1f" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">使用Go定义您的Kubernetes应用程序</h2></div><p id="a2cc" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">基础设施即代码(IaC)是一个成熟的范例，指的是处理基础设施(网络、磁盘、存储、数据库、消息队列等)的标准实践。)以与应用程序代码相同的方式，应用一般的软件工程实践，包括源代码控制版本控制、测试等等。例如，<a class="ae lq" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>和<a class="ae lq" href="https://docs.aws.amazon.com/cloudformation/index.html" rel="noopener ugc nofollow" target="_blank"> AWS CloudFormation </a>是广泛采用的技术，它们使用配置文件/模板来表示基础设施组件。</p><h1 id="8cc5" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">基础设施即代码——这是一种不同的思考方式</h1><p id="c7b2" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">假设您有一个应用程序，它由一个API网关作为前端的无服务器功能和一个作为后端的NoSQL数据库组成。而不是用静态的方式定义它(使用JSON，YAML等)。)，可以使用标准的编程语言结构(如类、方法等)来表示这些组件。下面是一个伪代码示例:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7ed4" class="mx ls jf mt b gy my mz l na nb">DBTable table = new DBTable("demo-table");<br/>table.addPrimaryKey("email", Type.String);</span><span id="811e" class="mx ls jf mt b gy nc mz l na nb">Function function = new Function("demo-func");<br/>function.addEnvVars("TABLE_NAME", table.Name());</span><span id="13db" class="mx ls jf mt b gy nc mz l na nb">APIGateway apigw = new APIGateway();<br/>apigw.addFunctionIntegration(function);</span></pre><p id="1940" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">注意(假设的)类<code class="fe nd ne nf mt b">DBTable</code>、<code class="fe nd ne nf mt b">Function</code>和<code class="fe nd ne nf mt b">APIGateway</code>以及它们的使用方式。例如，<code class="fe nd ne nf mt b">function</code>可以引用<code class="fe nd ne nf mt b">table</code>对象并获得其名称——所有这些都在程序运行时实现，并由底层框架/平台的实现细节负责。</p><p id="d2be" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">但是你不必为你的生产基础设施写伪代码！</strong></p><p id="8095" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">…感谢现有的解决方案，如<a class="ae lq" href="https://cdk8s.io/" rel="noopener ugc nofollow" target="_blank"> cdk8s </a>、<a class="ae lq" href="https://docs.aws.amazon.com/cdk/v2/guide/home.html" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>、<a class="ae lq" href="https://www.pulumi.com/" rel="noopener ugc nofollow" target="_blank">普鲁米</a>、<a class="ae lq" href="https://www.terraform.io/cdktf" rel="noopener ugc nofollow" target="_blank"> CDK for Terraform </a> ( <code class="fe nd ne nf mt b">cdktf</code>)等。几乎所有这些解决方案都遵循类似的方法——编写代码来定义基础设施，然后将其转换为配置，例如Kubernetes manifest (YAML)、<a class="ae lq" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/gettingstarted.templatebasics.html#gettingstarted.templatebasics.what" rel="noopener ugc nofollow" target="_blank">AWS cloud formation template</a>、<a class="ae lq" href="https://www.terraform.io/language/syntax/configuration" rel="noopener ugc nofollow" target="_blank"> HCL config </a>等。，然后可以使用标准工具进行应用。</p><p id="2841" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当我们谈到这个话题时，很难不提到Go编程语言及其在云服务和基础设施领域无处不在的存在。它结合了编译语言的安全性和解释语言的速度(如<code class="fe nd ne nf mt b">Python</code>)，有一个<a class="ae lq" href="https://pkg.go.dev/std" rel="noopener ugc nofollow" target="_blank">健壮的标准库</a>并编译成一个二进制文件。这些以及更多的品质催生了大量的云原生软件(IaC、监控、可观察性等。)用围棋写的，比如<a class="ae lq" href="https://github.com/prometheus/prometheus" rel="noopener ugc nofollow" target="_blank">普罗米修斯</a>、<a class="ae lq" href="https://github.com/hashicorp/terraform" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、<a class="ae lq" href="https://github.com/grafana/grafana" rel="noopener ugc nofollow" target="_blank">格拉法纳</a>、<a class="ae lq" href="https://github.com/jaegertracing/jaeger" rel="noopener ugc nofollow" target="_blank">耶格</a>等。</p><blockquote class="ng nh ni"><p id="00f8" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><a class="ae lq" href="https://go.dev/solutions/cloud" rel="noopener ugc nofollow" target="_blank"> <em class="jf">“事实上，云计算基础中超过75%的项目都是用Go编写的。”</em>T24】</a></p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="cb6f" class="lr ls jf bd lt lu nu lw lx ly nv ma mb kl nw km md ko nx kp mf kr ny ks mh mi bi translated">将“基础即代码”的咒语应用于Kubernetes</h1><p id="c4ad" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">在多篇博文中，我将介绍Go开发者如何使用<a class="ae lq" href="https://cdk8s.io/docs/latest/" rel="noopener ugc nofollow" target="_blank">cdk8s</a>(Kubernetes的云开发工具包)项目来定义Kubernetes资源。它是一个开源框架(也是CNCF的一部分),提供高级抽象，可以组合成更大的Kubernetes应用程序。与采用YAML或其他配置/模板驱动的方法不同，<code class="fe nd ne nf mt b">cdk8s</code>支持多种编程语言，这意味着您可以使用熟悉的概念(如类、方法等)使用Kubernetes资源。最终，<code class="fe nd ne nf mt b">cdk8s</code>会生成Kubernetes清单，您可以使用<code class="fe nd ne nf mt b">kubectl</code>来<code class="fe nd ne nf mt b">apply</code>-一切照旧！</p><blockquote class="ng nh ni"><p id="1d69" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">编写时，</em> <code class="fe nd ne nf mt b"><em class="jf">cdk8s</em></code> <em class="jf">支持Go、Typescript、Python和Java </em></p></blockquote><p id="23f8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这篇博客文章将为<code class="fe nd ne nf mt b">cdk8s</code>提供一个温和而实用的介绍。学习结束时，您将熟悉关键概念，并理解如何使用<code class="fe nd ne nf mt b">cdk8s</code>Go API来定义Kubernetes应用程序，部署(使用<code class="fe nd ne nf mt b">kubectl</code>)并测试它。</p><h1 id="3cb6" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">开始之前…</h1><p id="dee8" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">确保您已经安装了<code class="fe nd ne nf mt b">Go</code> ( <a class="ae lq" href="https://go.dev/dl/" rel="noopener ugc nofollow" target="_blank"> v1.16 </a>或更高版本)和<a class="ae lq" href="https://github.com/cdk8s-team/cdk8s-cli" rel="noopener ugc nofollow" target="_blank"> cdk8s CLI </a>。此外，您需要能够访问Kubernetes集群。对于学习和实验，我建议使用本地运行的单节点集群——比如<a class="ae lq" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> minikube </a>、<a class="ae lq" href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation" rel="noopener ugc nofollow" target="_blank"> kind </a>等。</p><blockquote class="ng nh ni"><p id="86a2" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">我一般用</em> <code class="fe nd ne nf mt b"><em class="jf">minikube</em></code> <em class="jf">，所以建立一个集群就像</em> <code class="fe nd ne nf mt b"><em class="jf">minikube start</em></code>一样简单</p></blockquote><p id="69bb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">安装cdk8s CLI。</p><p id="81b7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">您可以从以下选项中选择:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="39eb" class="mx ls jf mt b gy my mz l na nb">#homebrew<br/>brew install cdk8s</span><span id="8a17" class="mx ls jf mt b gy nc mz l na nb">#npm<br/>npm install -g cdk8s-cli</span><span id="e24a" class="mx ls jf mt b gy nc mz l na nb">#yarn<br/>yarn global add cdk8s-cli</span></pre></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="5f18" class="lr ls jf bd lt lu nu lw lx ly nv ma mb kl nw km md ko nx kp mf kr ny ks mh mi bi translated">好吧，让我们开始吧！</h1><blockquote class="ng nh ni"><p id="2c44" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">虽然这篇博文会提供一步一步的说明，但是你可以随时参考Github </em> 上完整的 <a class="ae lq" href="https://github.com/abhirockzz/cdk8s-for-go-developers/tree/master/part1-getting-started" rel="noopener ugc nofollow" target="_blank"> <em class="jf">代码</em></a></p></blockquote><p id="1320" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe nd ne nf mt b">cdk8s</code>让您可以轻松启动和引导您的应用。你不需要猜测和弄清楚如何构建你的项目，设置依赖关系等等。既然<code class="fe nd ne nf mt b">cdk8s init</code>号命令这样做了！</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9f87" class="mx ls jf mt b gy my mz l na nb">cdk8s init go-app</span><span id="599a" class="mx ls jf mt b gy nc mz l na nb">#output<br/>....</span><span id="e6ab" class="mx ls jf mt b gy nc mz l na nb"> Your cdk8s Go project is ready!</span><span id="c9d8" class="mx ls jf mt b gy nc mz l na nb">   cat help      Prints this message  <br/>   cdk8s synth   Synthesize k8s manifests to dist/<br/>   cdk8s import  Imports k8s API objects to "imports/k8s"</span><span id="8168" class="mx ls jf mt b gy nc mz l na nb">  Deploy:<br/>   kubectl apply -f dist/</span></pre><p id="e81d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">完成后，您将得到如下目录结构:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e48a" class="mx ls jf mt b gy my mz l na nb">.<br/>├── cdk8s.yaml<br/>├── dist<br/>│   └── test.k8s.yaml<br/>├── go.mod<br/>├── go.sum<br/>├── help<br/>├── imports<br/>│   └── k8s<br/>│       ├── internal<br/>│       │   └── types.go<br/>│       ├── jsii<br/>│       │   ├── jsii.go<br/>│       │   └── k8s-0.0.0.tgz<br/>│       ├── k8s.go<br/>│       ├── k8s.init.go<br/>│       └── version<br/>└── main.go</span></pre><p id="7482" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">更新generate <code class="fe nd ne nf mt b">go.mod</code>文件，并用下面的代码替换它——这是为了让事情更简单。</p><p id="dcf5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果需要，请随意使用最新版本的模块。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6e82" class="mx ls jf mt b gy my mz l na nb">module getting-started-with-cdk8s-go</span><span id="1b06" class="mx ls jf mt b gy nc mz l na nb">go 1.16</span><span id="5326" class="mx ls jf mt b gy nc mz l na nb">require (<br/>    github.com/aws/constructs-go/constructs/v10 v10.1.42<br/>    github.com/aws/jsii-runtime-go v1.60.1<br/>    github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2 v2.3.29<br/>)</span></pre><h1 id="fe1b" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">您已经准备好编写一些Go代码了！</h1><p id="619a" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">规范的Kubernetes“hello world”将启动并运行一个<code class="fe nd ne nf mt b">nginx</code>服务器。最简单的选择是简单地使用<code class="fe nd ne nf mt b">kubectl run</code>，例如<code class="fe nd ne nf mt b">kubectl run nginx --image=nginx</code>。但是，由于这是必要的，我们切换到声明性的方式，在这里我们定义我们想要的状态(在一个<code class="fe nd ne nf mt b">yaml</code>文件中)并让Kubernetes把事情弄清楚。</p><p id="f154" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">例如，我们可以编写一个<code class="fe nd ne nf mt b">Deployment</code>清单，并使用<code class="fe nd ne nf mt b">kubectl apply -f &lt;name of the yaml file</code> &gt;提交给Kubernetes。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="110c" class="mx ls jf mt b gy my mz l na nb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nginx-deployment<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: hello-nginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello-nginx<br/>    spec:<br/>      containers:<br/>        - image: nginx<br/>          name: nginx-container<br/>          ports:<br/>            - containerPort: 8080</span></pre><h1 id="e87b" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">但我们是来尽量减少噪音的…</h1><p id="30e3" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">因此，打开<code class="fe nd ne nf mt b">main.go</code>文件并复制下面的Go代码。别担心，我会帮你完成的！</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b67e" class="mx ls jf mt b gy my mz l na nb">package main</span><span id="48f4" class="mx ls jf mt b gy nc mz l na nb">import (<br/>    "getting-started-with-cdk8s-go/imports/k8s"<br/>    "github.com/aws/constructs-go/constructs/v10"<br/>    "github.com/aws/jsii-runtime-go"<br/>    "github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2"<br/>)</span><span id="17b7" class="mx ls jf mt b gy nc mz l na nb">type NginxChartProps struct {<br/>    cdk8s.ChartProps<br/>}</span><span id="9189" class="mx ls jf mt b gy nc mz l na nb">func NewNginxChart(scope constructs.Construct, id string, props *NginxChartProps) cdk8s.Chart {<br/>    var cprops cdk8s.ChartProps<br/>    if props != nil {<br/>        cprops = props.ChartProps<br/>    }<br/>    chart := cdk8s.NewChart(scope, jsii.String(id), &amp;cprops)</span><span id="038d" class="mx ls jf mt b gy nc mz l na nb">    selector := &amp;k8s.LabelSelector{MatchLabels: &amp;map[string]*string{"app": jsii.String("hello-nginx")}}</span><span id="dd9d" class="mx ls jf mt b gy nc mz l na nb">    labels := &amp;k8s.ObjectMeta{Labels: &amp;map[string]*string{"app": jsii.String("hello-nginx")}}</span><span id="bba9" class="mx ls jf mt b gy nc mz l na nb">    nginxContainer := &amp;k8s.Container{Name: jsii.String("nginx-container"), Image: jsii.String("nginx"), Ports: &amp;[]*k8s.ContainerPort{{ContainerPort: jsii.Number(80)}}}</span><span id="e5c9" class="mx ls jf mt b gy nc mz l na nb">    k8s.NewKubeDeployment(chart, jsii.String("deployment"),<br/>        &amp;k8s.KubeDeploymentProps{<br/>            Spec: &amp;k8s.DeploymentSpec{<br/>                Replicas: jsii.Number(1),<br/>                Selector: selector,<br/>                Template: &amp;k8s.PodTemplateSpec{<br/>                    Metadata: labels,<br/>                    Spec: &amp;k8s.PodSpec{<br/>                        Containers: &amp;[]*k8s.Container{nginxContainer}}}}})</span><span id="1165" class="mx ls jf mt b gy nc mz l na nb">    return chart<br/>}</span><span id="89f7" class="mx ls jf mt b gy nc mz l na nb">func main() {<br/>    app := cdk8s.NewApp(nil)<br/>    NewNginxChart(app, "nginx", nil)<br/>    app.Synth()<br/>}</span></pre><p id="26a8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当用任何语言编写基于<code class="fe nd ne nf mt b">cdk8s</code>的代码时，你都会遇到一组常见的概念/术语——包括<code class="fe nd ne nf mt b">Construct</code>、<code class="fe nd ne nf mt b">App</code>和<code class="fe nd ne nf mt b">Chart</code>。当我们浏览代码时，我会解释这些。</p><h1 id="980b" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">稍微绕道(代码走查和概念)</h1><p id="c8ca" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">首先从<code class="fe nd ne nf mt b">main</code>函数开始——我们使用<a class="ae lq" href="https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2#NewApp" rel="noopener ugc nofollow" target="_blank"> cdk8s。NewApp </a>创建一个<a class="ae lq" href="https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2#App" rel="noopener ugc nofollow" target="_blank">应用</a>。</p><p id="8d3d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">嗯，一个</strong> <code class="fe nd ne nf mt b"><strong class="kw jg">App</strong></code> <strong class="kw jg">里到底有什么？</strong>它是一个<a class="ae lq" href="https://github.com/aws/constructs" rel="noopener ugc nofollow" target="_blank">构造</a>，你可以把<code class="fe nd ne nf mt b">construct</code> s看作是更高级别的构建块来表示<strong class="kw jg">状态</strong>。需要注意的关键是，这些构造是<strong class="kw jg">可组合的</strong>。这意味着您可以定义这些构造的级别(每个级别提供/公开一个不同的抽象层)并将它们组合起来以创建您想要的最终状态——在这种情况下，它恰好是一个Kubernetes清单，带有诸如<code class="fe nd ne nf mt b">Deployment</code>之类的对象，但是它也可以是其他的东西。</p><blockquote class="ng nh ni"><p id="7c7f" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">例如一个</em><a class="ae lq" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html" rel="noopener ugc nofollow" target="_blank"><em class="jf">AWS cloud formation模板</em> </a> <em class="jf">(如果你要使用</em><a class="ae lq" href="https://docs.aws.amazon.com/cdk/v2/guide/home.html" rel="noopener ugc nofollow" target="_blank"><em class="jf">AWS CDK</em></a><em class="jf">，不要与</em> <code class="fe nd ne nf mt b"><em class="jf">cdk8s</em></code> <em class="jf"> ) </em></p></blockquote><p id="1e4f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">回到<code class="fe nd ne nf mt b">App</code>——<code class="fe nd ne nf mt b">App</code>也是一个构造。事实上，你可以把它看作是结构树(层次结构)中的根。那树上还有什么？请看主函数中的第二行- <code class="fe nd ne nf mt b">NewNginxChart(app, "getting-started", nil)</code> -这调用了一个函数<code class="fe nd ne nf mt b">NewNginxChart</code>，它返回一个<a class="ae lq" href="https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2#Chart" rel="noopener ugc nofollow" target="_blank"> cdk8s。图表</a>层次结构中的下一个组件。AA cdk8s <code class="fe nd ne nf mt b">App</code>可以包含<strong class="kw jg">多个</strong>图表，并且每个图表都可以被转换(或者用准确的cdk8s术语- <strong class="kw jg">合成</strong>)成一个单独的Kubernetes清单文件(您很快就会看到这个动作)。</p><p id="dbc1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">最后，请注意<code class="fe nd ne nf mt b">NewNginxChart</code>功能。它有一堆东西，但是注意对<code class="fe nd ne nf mt b">k8s.NewKubeDeployment</code>函数的调用。这是我们在代码中实际定义Kubernetes <code class="fe nd ne nf mt b">Deployment</code>的地方(在下一节中，我们还将向图表添加一个<code class="fe nd ne nf mt b">Service</code>。)</p><blockquote class="ng nh ni"><p id="9400" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">您可以在一个图表中定义多个Kubernetes组件，如</em><code class="fe nd ne nf mt b"><em class="jf">Pod</em></code><em class="jf"/><code class="fe nd ne nf mt b"><em class="jf">Service</em></code><em class="jf"/><code class="fe nd ne nf mt b"><em class="jf">Ingress</em></code><em class="jf"/><code class="fe nd ne nf mt b"><em class="jf">Job</em></code><em class="jf">等。-在Kubernetes上运行您的应用程序所需的一切。</em></p></blockquote><p id="d0d0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">总结一下，这是我刚才解释的视觉表现——记住一切都是一个<code class="fe nd ne nf mt b">Construct</code> ( <code class="fe nd ne nf mt b">App</code>，<code class="fe nd ne nf mt b">Chart</code>等等。)</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/b5cbe3eac4a8f6ab352cffdf5037250d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rdAAk2nG60lNx8XT.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">cdk8s —构造树</p></figure><p id="02d9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">等等，Kubernetes API依赖关系怎么样？？</p><p id="d733" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果您已经花时间以编程方式访问Kubernetes，这是一个显而易见的(而且非常棒！)问题。如果你要用go处理k8s对象，至少你需要Kubernetes <a class="ae lq" href="https://github.com/kubernetes/client-go/" rel="noopener ugc nofollow" target="_blank"> client-go </a>，<a class="ae lq" href="https://github.com/kubernetes/apimachinery" rel="noopener ugc nofollow" target="_blank">API machine</a>等。猜猜看，<code class="fe nd ne nf mt b">cdk8s</code>也让你在那里得到了满足！</p><p id="1757" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">您实际上不需要引入这些依赖项，因为<code class="fe nd ne nf mt b">cdk8s</code>允许您将这些Kubernetes API对象视为<code class="fe nd ne nf mt b">constructs</code>——记住，一切都是s构造！当您运行<code class="fe nd ne nf mt b">cdk8s init</code>命令时，它们会被<em class="nj">自动导入</em>到您的项目中，但是您也可以使用<a class="ae lq" href="https://cdk8s.io/docs/latest/cli/import/" rel="noopener ugc nofollow" target="_blank"> cdk8s import </a>显式地这样做。产生的API作为<code class="fe nd ne nf mt b">imports</code>文件夹的一部分可用(是的，继续检查一遍！).在<code class="fe nd ne nf mt b">main.go</code>的顶部，检查导入的包——它指的是<code class="fe nd ne nf mt b">imports</code>文件夹。</p><blockquote class="ng nh ni"><p id="369e" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">还有更多的</em> <code class="fe nd ne nf mt b"><em class="jf">cdk8s import</em></code> <em class="jf">虽然。但是你将不得不等待其他的博客文章来看看实际情况——我们才刚刚开始！</em></p></blockquote><h1 id="b153" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">好吧，让我们回到正题…</h1><p id="95ca" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">..并继续实践。是时候生成一些yaml了——不能消除，但至少不用手写！为此，只需运行:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8e66" class="mx ls jf mt b gy my mz l na nb">cdk8s synth</span></pre><p id="5bf8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">一旦完成(应该很快！)，查看<code class="fe nd ne nf mt b">dist</code>目录，查看<code class="fe nd ne nf mt b">cdk8s</code>生成了什么。<br/>为了更容易理解，这里有一个一对一映射的图表(<em class="nj">注意标签1、2、3等。？</em>)与yaml中相应的<code class="fe nd ne nf mt b">cdk8s</code>代码对象/属性之间，例如<code class="fe nd ne nf mt b">spec.replicas</code>、<code class="fe nd ne nf mt b">spec.selector</code>、<code class="fe nd ne nf mt b">template.spec</code>等。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/b5e5556f044ef3e5b9080e2e0e05e599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vgaxMsptwIwFgBUh.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">去和YAML——肩并肩</p></figure><p id="3747" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你现在可以使用传统的<code class="fe nd ne nf mt b">kubectl</code>将它部署到Kubernetes上，因为<code class="fe nd ne nf mt b">cdk8s</code>不会为你这么做，至少现在不会；)</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4ecb" class="mx ls jf mt b gy my mz l na nb">kubectl apply -f dist/<br/>kubectl get pods -w</span></pre><p id="2839" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">一旦<code class="fe nd ne nf mt b">Deployment</code>准备就绪，<code class="fe nd ne nf mt b">Pod</code>应该处于<code class="fe nd ne nf mt b">Running</code>状态。只需使用<code class="fe nd ne nf mt b">port-forward</code>在本地访问<code class="fe nd ne nf mt b">nginx</code>集装箱港口:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="20b2" class="mx ls jf mt b gy my mz l na nb">kubectl port-forward &lt;enter nginx pod name&gt; 8080:80</span></pre><p id="f47d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">要访问<code class="fe nd ne nf mt b">nginx</code>主页，使用浏览器导航至<code class="fe nd ne nf mt b">http://localhost:8080</code></p><blockquote class="ng nh ni"><p id="45b2" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">您也可以使用CLI工具，例如</em> <code class="fe nd ne nf mt b"><em class="jf">curl localhost:8080</em></code> <em class="jf">。</em></p></blockquote><h1 id="c958" class="lr ls jf bd lt lu lv lw lx ly lz ma mb kl mc km md ko me kp mf kr mg ks mh mi bi translated">还没完呢！</h1><p id="39e4" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">让我们通过定义一个<code class="fe nd ne nf mt b">Service</code>资源来使用标准的Kubernetes访问应用程序的方式，而不是端口转发，通常是这样定义的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="548c" class="mx ls jf mt b gy my mz l na nb">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: nginx-service<br/>spec:<br/>  ports:<br/>    - port: 9090<br/>      targetPort: 8080<br/>  selector:<br/>    app: hello-nginx<br/>  type: LoadBalancer</span></pre><p id="3e33" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是你知道规矩——不许手写！所以，在<code class="fe nd ne nf mt b">main.go</code>文件的<code class="fe nd ne nf mt b">NewNginxChart</code>函数中，将这段代码添加到您定义了<code class="fe nd ne nf mt b">Deployment</code>的部分之后:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="853b" class="mx ls jf mt b gy my mz l na nb">k8s.NewKubeService(chart, jsii.String("service"), &amp;k8s.KubeServiceProps{<br/>        Spec: &amp;k8s.ServiceSpec{<br/>            Type:     jsii.String("LoadBalancer"),<br/>            Ports:    &amp;[]*k8s.ServicePort{{Port: jsii.Number(9090), TargetPort: k8s.IntOrString_FromNumber(jsii.Number(80))}},<br/>            Selector: &amp;map[string]*string{"app": jsii.String("hello-nginx")}}})</span></pre><p id="00d7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，删除现有的<code class="fe nd ne nf mt b">Deployment</code> - <code class="fe nd ne nf mt b">kubectl delete -f dist/</code>。然后，再次运行<code class="fe nd ne nf mt b">cdk8s synth</code>，在<code class="fe nd ne nf mt b">dist</code>文件夹中创建新的清单。</p><blockquote class="ng nh ni"><p id="d046" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf"/><code class="fe nd ne nf mt b"><em class="jf">Service</em></code><em class="jf">和</em> <code class="fe nd ne nf mt b"><em class="jf">Deployment</em></code> <em class="jf">都在同一个文件中——这是因为它们都是</em>同一个<em class="jf">图表的一部分。</em></p></blockquote><p id="1d79" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如何访问服务将取决于Kubernetes集群。如果您使用的是云提供商，它可能会在云上提供本地负载平衡器服务，例如AWS中的<a class="ae lq" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html" rel="noopener ugc nofollow" target="_blank">应用负载平衡器</a>。请根据您的设置进行调整。</p><blockquote class="ng nh ni"><p id="fb22" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">对于</em> <code class="fe nd ne nf mt b"><em class="jf">minikube</em></code> <em class="jf">，你可以简单的按照这些指令</em><a class="ae lq" href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access" rel="noopener ugc nofollow" target="_blank"><em class="jf">https://minikube . sigs . k8s . io/docs/handbook/access/# load balancer-access</em></a><em class="jf">-</em>“load balancer类型的服务可以通过<code class="fe nd ne nf mt b">minikube tunnel</code>命令公开。”</p></blockquote><p id="2835" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在终端中，运行以下命令(它作为单独的进程运行):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="33ea" class="mx ls jf mt b gy my mz l na nb">minikube tunnel</span></pre><p id="0d5d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在另一个终端，<em class="nj">删除</em>现有的<code class="fe nd ne nf mt b">Deployment</code>，然后应用新的清单:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3cd4" class="mx ls jf mt b gy my mz l na nb">kubectl apply -f dist/<br/>kubectl get pods -w</span></pre><p id="3123" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">检查<code class="fe nd ne nf mt b">Service</code>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4049" class="mx ls jf mt b gy my mz l na nb">kubectl get svc</span></pre><p id="27a4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">要访问<code class="fe nd ne nf mt b">nginx</code>服务器，导航到外部IP(根据<code class="fe nd ne nf mt b">Service</code>)。在minikube的情况下，您可以简单地使用<code class="fe nd ne nf mt b">localhost:9090</code>或<code class="fe nd ne nf mt b">127.0.0.0:9090</code></p><blockquote class="ng nh ni"><p id="eaf6" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">记住使用端口</em> <code class="fe nd ne nf mt b"><em class="jf">9090</em></code> <em class="jf">，因为那是我们在代码</em>的服务配置中指定的外部端口</p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="0ce2" class="lr ls jf bd lt lu nu lw lx ly nv ma mb kl nw km md ko nx kp mf kr ny ks mh mi bi translated">在总结之前…</h1><p id="070a" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">..我想在<code class="fe nd ne nf mt b">cdk8s</code>中强调一些其他有用的东西。</p><p id="45fa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">参考和重用现有的清单和舵图</strong></p><p id="77e0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">假设您已经在一个<code class="fe nd ne nf mt b">service.yaml</code>文件中定义了一个<code class="fe nd ne nf mt b">Service</code>。你可以将作为你可能有的更大的应用程序/图表的一部分包含在你的<code class="fe nd ne nf mt b">cdk8s</code>中。这里有一个例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d7ec" class="mx ls jf mt b gy my mz l na nb">cdk8s.NewInclude(chart, jsii.String("existing service"), &amp;cdk8s.IncludeProps{Url: jsii.String("service.yaml")})</span></pre><p id="3947" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">同样，也可以包含<code class="fe nd ne nf mt b">Helm</code>图表。说你想加<code class="fe nd ne nf mt b">bitnami/nginx</code>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3c3b" class="mx ls jf mt b gy my mz l na nb">cdk8s.NewHelm(chart, jsii.String("bitnami nginx helm chart"), &amp;cdk8s.HelmProps{<br/>        Chart:  jsii.String("bitnami/nginx"),<br/>        Values: &amp;map[string]interface{}{"service.type": "ClusterIP"}})</span></pre><blockquote class="ng nh ni"><p id="b8e7" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">嗯，你确实需要在本地安装</em> <code class="fe nd ne nf mt b"><em class="jf">helm</em></code> <em class="jf">并且先添加回购</em> <code class="fe nd ne nf mt b"><em class="jf">helm repo add bitnami </em><a class="ae lq" href="https://charts.bitnami.com/bitnami" rel="noopener ugc nofollow" target="_blank"><em class="jf">https://charts.bitnami.com/bitnami</em></a></code></p></blockquote><p id="35e5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">另一个方便的功能是… </strong></p><p id="1a2f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">…能够声明任意两个<code class="fe nd ne nf mt b">cdk8s</code>结构之间的依赖关系。例如，在前面的例子中，我们有一个<code class="fe nd ne nf mt b">Deployment</code>和一个<code class="fe nd ne nf mt b">Service</code>。您可以创建这样的依赖关系:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f385" class="mx ls jf mt b gy my mz l na nb">deployment := k8s.NewKubeDeployment(...)<br/>service := k8s.NewKubeService(...)</span><span id="30b2" class="mx ls jf mt b gy nc mz l na nb">deployment.AddDependency(service)</span></pre><p id="2a64" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">由于有了<code class="fe nd ne nf mt b">AddDependency</code>，产生的清单将是这样的，即<code class="fe nd ne nf mt b">Service</code>被放置在<code class="fe nd ne nf mt b">Deployment</code>对象之前。</p><blockquote class="ng nh ni"><p id="35fd" class="ku kv nj kw b kx ky kg kz la lb kj lc nk le lf lg nl li lj lk nm lm ln lo lp ij bi translated"><em class="jf">依赖是</em>而不是<em class="jf">局限于图表中的单个结构。如果您的</em> <code class="fe nd ne nf mt b"><em class="jf">cdk8s</em></code> <em class="jf">应用程序包含多个图表，您也可以在<em class="jf">图表之间建立</em>依赖关系。</em></p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="ff5f" class="lr ls jf bd lt lu nu lw lx ly nv ma mb kl nw km md ko nx kp mf kr ny ks mh mi bi translated">结论</h1><p id="abb0" class="pw-post-body-paragraph ku kv jf kw b kx mj kg kz la mk kj lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">太棒了。所以你能够“编码”你的方式通过麻烦和忽视YAML。希望你喜欢它！为了简单起见，我演示了一个<code class="fe nd ne nf mt b">Deployment</code>和<code class="fe nd ne nf mt b">Service</code>，但是您可以从其他Kubernetes组件中选择，比如<code class="fe nd ne nf mt b">Ingress</code>、<code class="fe nd ne nf mt b">Job</code>等。它们都使用类似的模式曝光，例如<code class="fe nd ne nf mt b">NewKubeJob</code>、<code class="fe nd ne nf mt b">NewKubeIngress</code>等的NewKube。</p><p id="6948" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是在定义Kubernetes组件时仍然有很多样板代码。编写Go代码听起来比YAML工程好得多(至少对我来说)，看起来好像我们正在将现有的YAML翻译成Go结构(和字段)。在随后的博文中，我们将探讨如何进一步改进这一点。</p><p id="27a3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">编码快乐！</p></div></div>    
</body>
</html>