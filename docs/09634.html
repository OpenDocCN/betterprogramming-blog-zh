<html>
<head>
<title>How I Solved a Challenging Concurrency Bug in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何解决Python中一个具有挑战性的并发错误的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-solved-a-challenging-concurrency-bug-in-python-cbf635d4bea9?source=collection_archive---------9-----------------------#2021-09-20">https://betterprogramming.pub/how-i-solved-a-challenging-concurrency-bug-in-python-cbf635d4bea9?source=collection_archive---------9-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb90" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调查事件循环、信号和锁的基本原理和复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0695fc34fe00907d6448d6154338c57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D9XffjTPvQywGOBE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emilymorter?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="64e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您在生产环境中运行一个Python服务，并且它不时会崩溃并显示以下错误:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3174" class="ma mb it lw b gy mc md l me mf">RuntimeError: cannot release un-acquired lock</span></pre><p id="5e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是几年前我们团队的情况。起初，我们不知道发生了什么，也无法在本地重现该问题。我们甚至不知道它是在我们的代码中还是由库引起的。我们发现了一个所谓的Heisenbug，一个只有在你不看的时候才会出现的bug。</p><p id="e665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们找到并修复了这个错误。它涉及到一个确定性的事件循环框架Gevent，重入锁，信号和一些思考。让我告诉你调查的经过和可能的解决方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/e812b9b77ee2e7ac8f22d6268513fc24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJhaVw8KaMODp9uwMmi0XA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">漫画来自<a class="ae ky" href="https://geek-and-poke.com/geekandpoke/2009/7/8/the-art-of-bugfixing-chapter-2.html" rel="noopener ugc nofollow" target="_blank">geek-and-poke.com</a>，牌照<a class="ae ky" href="https://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank"> CC-BY-3.0 </a></p></figure><h1 id="550c" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">调查</h1><p id="ea63" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在本文中，我用一个最小的例子再现了这个bug。该示例将其归结为几个无限期运行的Gevent线程，获取和释放一个可重入锁。</p><p id="438b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个信号处理程序，它定期触发来获取和释放同一个锁。GitHub 上有代码<a class="ae ky" href="https://github.com/lucas-sonnabend/signals-and-eventloops-gone-wrong" rel="noopener ugc nofollow" target="_blank">，任何人都可以使用。简化的示例如下所示:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="81dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它需要的主库是Gevent，在我们调试这个问题之前，我们必须了解这个库是如何工作的。</p><h1 id="94a3" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Gevent</h1><p id="0c3b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="http://www.gevent.org/intro.html" rel="noopener ugc nofollow" target="_blank"> Gevent </a>是一个开源的Python库，它提供了一个确定性的事件循环。它类似于<a class="ae ky" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> Python asyncio库</a>，但是选择运行下一个协同例程的调度器是确定性的，并且是非抢占式的。</p><p id="2d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定相同顺序的相同事件，两次不同的运行将产生完全相同的结果。这是决定性的部分。</p><p id="25a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非抢占意味着框架只在当前线程结束、显式让步或执行阻塞I/O调用时切换到不同的线程。它还提供了一个<code class="fe nf ng nh lw b">monkey_patch</code>方法来修补常见的I/O操作，比如网络调用，以便与Gevent框架一起工作。</p><h1 id="4c29" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">追溯</h1><p id="fa57" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有了这些背景知识，我们就可以开始了。如果您在GitHub上运行这个例子，运气不好的话，您应该会得到下面的异常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/f1eeb435849a37c6914314ba65c3ebe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_gtmB-0k_5qBpXFXF3niw.png"/></div></div></figure><h1 id="c243" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">重入锁</h1><p id="edc4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">第一个提示是堆栈跟踪，它指向python<a class="ae ky" href="https://github.com/python/cpython/blob/3.8/Lib/threading.py" rel="noopener ugc nofollow" target="_blank">threading . py</a>源代码。更准确地说，它指向可重入锁的<code class="fe nf ng nh lw b">release()</code>方法。</p><p id="3434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可重入锁是一个可以被同一个参与者多次获取的锁，对于防止<a class="ae ky" href="https://en.wikipedia.org/wiki/Deadlock" rel="noopener ugc nofollow" target="_blank">死锁</a>非常有用。想象一个线程获得一个锁，并且当它仍然持有所述锁时，调用一个再次获得它的函数。</p><p id="c677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常的锁会阻塞，导致死锁。但是重入锁跟踪哪个线程获得了锁，并允许同一个线程多次获得锁。</p><p id="d172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在知道异常可能有多种原因。要么是线程释放了一个它从未获得的锁，要么是它释放锁的次数比获得锁的次数多。但是在示例代码中，每个<code class="fe nf ng nh lw b">acquire</code>调用后面都跟着<code class="fe nf ng nh lw b">release</code>，并且在控制流中没有中断。Gevent事件循环的不可抢占性决定了没有其他线程可以干涉。</p><p id="14ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是即使他们可以，其他线程也不能<code class="fe nf ng nh lw b">acquire</code>锁定，所以他们不可能释放它们。根据线程内和线程间的控制流，这种异常不应该发生。</p><h1 id="3983" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">信号</h1><p id="6c81" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们的服务中，我们有另一种机制来改变控制流，即信号处理器。<a class="ae ky" href="https://en.wikipedia.org/wiki/Signal_(IPC)" rel="noopener ugc nofollow" target="_blank">信号</a>是操作系统提供的异步消息系统。一个进程可以向另一个进程发送信号，您可以提供处理程序方法，当一个进程接收到信号时执行这些方法。最常见的信号是SIGINT，您用<code class="fe nf ng nh lw b">CTRL+C</code>将它发送到前台进程。对此的默认处理程序是终止进程。</p><p id="da33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，我们可以创建一个定制的信号处理程序，并注册它以便在特定的信号上调用。在我们的例子中，那就是<code class="fe nf ng nh lw b">SIGALRM</code>。然后，您可以创建一个计时器，以便操作系统以指定的频率触发该信号:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="81a4" class="ma mb it lw b gy mc md l me mf">signal(SIGALRM, signal_handler)</span><span id="0751" class="ma mb it lw b gy nj md l me mf">setitimer(ITIMER_REAL, TIMER_FREQUENCY, TIMER_FREQUENCY)</span></pre><p id="43ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当信号触发时，操作系统执行我们的信号处理程序，不管哪一行是先前执行的。处理程序返回后，执行从程序中进程被中断的相同位置继续。该处理程序也由先前运行的同一线程执行。</p><blockquote class="nk"><p id="43a2" class="nl nm it bd nn no np nq nr ns nt lu dk translated">"当你排除了不可能，剩下的，不管多么不可思议，一定是真相？"——阿瑟·柯南·道尔《四人组》中的夏洛克·福尔摩斯</p></blockquote><h1 id="3711" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz nu ka ms kc nv kd mu kf nw kg mw mx bi translated">真正的Bug</h1><p id="391f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这里，我们改变了控制流！现在我们只需要弄清楚错误时刻的信号是如何导致可怕的异常的。首先，让我们提醒自己获取和释放可重入锁的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://github.com/python/cpython/blob/3.8/Lib/threading.py" rel="noopener ugc nofollow" target="_blank"> /lib/threading.py </a>的简化摘录</p></figure><p id="106e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您必须问自己:如果在某个时候，信号处理程序干涉并开始获取锁，会发生什么？</p><p id="2909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过多次反复试验，我注意到如果一个信号处理器中断了第15行和第16行之间的<code class="fe nf ng nh lw b">acquire</code>功能，它会将<code class="fe nf ng nh lw b">self._owner</code>设置为<code class="fe nf ng nh lw b">None</code>。在控制返回到线程之后，它最终调用<code class="fe nf ng nh lw b">release</code>并触发启动该调查的异常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/45d044afd263c33ed0f74f47c22f5ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxjK8RQyiAzUpNZ0XFlxVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在引发异常的正确时间调用信号处理程序时的控制流</p></figure><h1 id="e78c" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">修复</h1><p id="763b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">显而易见的解决方案是不要在信号处理程序中使用锁。这有点棘手，因为我们没有自己引入锁。它们在标准Python <a class="ae ky" href="https://github.com/python/cpython/blob/3.8/Lib/logging/__init__.py#L941" rel="noopener ugc nofollow" target="_blank">日志处理程序</a>中使用。</p><p id="3ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终为信号创建了一个单独的日志处理程序，它有自己单独的锁。信号处理器不再与主线程共享任何状态，这就解决了问题。</p><p id="9c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更简单的解决办法是使用<code class="fe nf ng nh lw b">asyncio</code>而不是<code class="fe nf ng nh lw b">gevent</code>。不幸的是，这对我们来说是不可能的。这将是一次大规模的重写，我们依赖于Gevent事件循环的确定性。</p><h1 id="1d16" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">现实生活背景</h1><p id="df8c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个示例调查是基于我遇到的一个实际的bug。当然，我们的代码比这个例子复杂得多，我们有充分的理由使用Gevent库和信号。</p><p id="dff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用Gevent是因为我们有一个可重玩的，<a class="ae ky" href="https://microservices.io/patterns/data/event-sourcing.html" rel="noopener ugc nofollow" target="_blank">事件源</a>系统。假设相同的消息进入系统，我们想要完全相同的行为。我们通过这种方式发现了一些错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/afe4a11f9304c6ace76317401d71cd15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xoXr4pJECXp2J6JKAl-AFQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">漫画来自<a class="ae ky" href="https://geek-and-poke.com/geekandpoke/2014/7/3/simply-explained#" rel="noopener ugc nofollow" target="_blank">geek-and-poke.com</a>，牌照<a class="ae ky" href="https://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank"> CC-BY-3.0 </a></p></figure><p id="9f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信号处理器有两个不同的目的。第一个是用于块检测。这将经常检查自事件循环调度程序运行以来已经过了多长时间。如果它在一定时间间隔(1秒)内没有运行，它将发出警告。这表明我们在代码中引入了一些计算密集型部分，服务器不再响应。</p><p id="2d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个用例是对烟囱痕迹进行采样，以创建<a class="ae ky" href="https://www.brendangregg.com/flamegraphs.html" rel="noopener ugc nofollow" target="_blank">火焰图</a>。通常，您只会在开发或测试环境中这样做，因为收集这些分析信息会有一定的开销。但是我们认为我们已经在使用Python，它不是最快的语言，与解释语言的开销相比，这是可以接受的。</p><p id="89e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不知道问题是从什么时候开始出现的，但我记得我们做了什么:什么都没有！在最初的分类之后，很明显它很难调试，它出现的频率不到一个月一次。服务因此而崩溃，但会自动重启，只造成最小的服务中断。花费时间来修复它的成本高于停机时间本身的成本。</p><p id="02fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是后来我们开始扩大我们的服务。服务数量加倍意味着出错的频率加倍。停机的成本仍然很低，但这是一个令人讨厌的警告。您最不希望看到的是一堆不可操作的警报，它们会干扰您的工作，并使您忽略可操作的警报。避免这种警惕性的盲目让我们最终解决了这个问题。</p><h1 id="7cbf" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的想法</h1><p id="c0b5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我希望你喜欢这次调查以及我们在现实生活中如何处理这个bug。也许你也学到了一两件事。这绝对是我遇到的最难也是最有趣的bug之一。</p><p id="56ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些悬而未决的问题仍然存在。您可能已经注意到，解释中没有明确提到Gevent，但是我只成功地再现了运行多个Gevent线程时的异常。这个bug很可能涉及到另一层复杂性。</p><p id="7931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简化代码示例还产生了另外两个异常。它们被记录在<a class="ae ky" href="https://github.com/lucas-sonnabend/signals-and-eventloops-gone-wrong" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中。他们每个人都有自己的故事和解释，他们都有待探索。</p><p id="6fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于并发的另一个真实例子，请查看我的关于Python中异步的危险的文章:</p><div class="nz oa gp gr ob oc"><a rel="noopener  ugc nofollow" target="_blank" href="/the-dangers-of-async-in-python-and-how-to-avoid-them-6e6f98f19f0e"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">Python中异步的危险以及如何避免它们</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">通过一个非抢占式事件循环示例了解Python中的异步陷阱</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">better编程. pub</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><h1 id="8b0b" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><ul class=""><li id="88f6" class="or os it lb b lc my lf mz li ot lm ou lq ov lu ow ox oy oz bi translated"><a class="ae ky" href="http://www.gevent.org/intro.html" rel="noopener ugc nofollow" target="_blank"> Gevent </a></li><li id="63b6" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><a class="ae ky" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> Python asyncio </a></li><li id="0c6a" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><a class="ae ky" href="https://docs.python.org/3/library/signal.html" rel="noopener ugc nofollow" target="_blank"> Python信号文档</a></li><li id="54d9" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><a class="ae ky" href="https://github.com/python/cpython/blob/3.8/Lib/threading.py" rel="noopener ugc nofollow" target="_blank"> Python threading.py源代码</a></li><li id="6611" class="or os it lb b lc pa lf pb li pc lm pd lq pe lu ow ox oy oz bi translated"><a class="ae ky" href="https://www.brendangregg.com/flamegraphs.html" rel="noopener ugc nofollow" target="_blank">火焰图</a></li></ul></div></div>    
</body>
</html>