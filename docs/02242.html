<html>
<head>
<title>The Beginner’s Guide to Creating an Interactive List With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React创建交互式列表的初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-beginners-guide-to-creating-an-interactive-list-with-react-28c8af880f35?source=collection_archive---------2-----------------------#2019-11-16">https://betterprogramming.pub/the-beginners-guide-to-creating-an-interactive-list-with-react-28c8af880f35?source=collection_archive---------2-----------------------#2019-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习创建一个支持拖放的样式列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a6e1bada94371974e79a8dab3c67c96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTsFrFNywgcUqto8qpyKTQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com/s/photos/list?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="c491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TL；DR: <strong class="lb iu"> </strong>这是一个关于如何用<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>创建交互式列表的初级循序渐进教程。我们将:</p><ul class=""><li id="3a53" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=/" rel="noopener ugc nofollow" target="_blank">基础设施-组件</a>设置项目；</li><li id="0d5e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">用<a class="ae ky" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式化组件</a>样式化组件；</li><li id="50e0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://github.com/clauderic/react-sortable-hoc" rel="noopener ugc nofollow" target="_blank"> react-sortable-hoc </a>添加拖放功能。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1c5c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">创建React应用程序</h1><p id="4f8b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">脸书的脚本<code class="fe nn no np nq b"><a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code>是启动React项目的默认方式。但是<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://codeburst.io/is-create-react-app-a-dead-end-5baae1568f89" rel="noopener ugc nofollow" target="_blank">它让你在部署它的时候得不到支持</a>。为此，我们可以使用<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=/" rel="noopener ugc nofollow" target="_blank">基础设施-组件</a>。这些React组件让我们将基础设施架构定义为React应用的一部分，这意味着其他配置如<a class="ae ky" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>、<a class="ae ky" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>或<a class="ae ky" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>不再是必要的。</p><p id="69ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三种方法可以设置项目:</p><ol class=""><li id="9c81" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">从<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=/" rel="noopener ugc nofollow" target="_blank">www.infrastructure-components.com</a>下载定制的样板代码；</li><li id="8299" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">克隆这个<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://github.com/infrastructure-components/singlepage_example" rel="noopener ugc nofollow" target="_blank"> GitHub-repository </a>(模板)或者<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://github.com/infrastructure-components/interactive-list" rel="noopener ugc nofollow" target="_blank">这个repository </a>(本帖完整源代码)；</li><li id="9a36" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">手动安装库。</li></ol><p id="686f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将获得以下文件结构:</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="31ae" class="nw mr it nq b gy nx ny l nz oa">menu/<br/>├── src/<br/>│   └── index.tsx<br/>├── .env<br/>├── .gitignore<br/>├── LICENSE<br/>├── package.json<br/>└── README</span></pre><p id="d70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">package.json</code>指定了项目的所有依赖项。在本教程中，我们使用通过<code class="fe nn no np nq b">npm install</code>安装的以下库:</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="450d" class="nw mr it nq b gy nx ny l nz oa"><strong class="nq iu">"dependencies"</strong>: {<br/>  <strong class="nq iu">"infrastructure-components"</strong>: <strong class="nq iu">"^0.3.1"</strong>,<br/>  <strong class="nq iu">"react"</strong>: <strong class="nq iu">"^16.10.2"</strong>,<br/>  <strong class="nq iu">"react-dom"</strong>: <strong class="nq iu">"^16.10.2"</strong>,<br/>  <strong class="nq iu">"react-sortable-hoc"</strong>: <strong class="nq iu">"^1.10.1"</strong>,<br/>  <strong class="nq iu">"styled-components"</strong>: <strong class="nq iu">"^4.1.3"<br/></strong>},<br/><strong class="nq iu">"devDependencies"</strong>: {<br/>  <strong class="nq iu">"infrastructure-scripts"</strong>: <strong class="nq iu">"^0.3.1"</strong>,<br/>  <strong class="nq iu">"serverless-single-page-app-plugin"</strong>: <strong class="nq iu">"^1.0.2"<br/></strong>}</span></pre><p id="0536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的文件是你的<code class="fe nn no np nq b">src/index.tsx</code>文件。这是你的React应用的入口。在这个文件中，您导出了一个<code class="fe nn no np nq b">&lt;SinglePageApp/&gt;</code>组件。一旦<code class="fe nn no np nq b">src/index.tsx</code>文件准备好了，您就可以开始构建您的项目了(<code class="fe nn no np nq b">npm run build</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个基本的无服务器单页React应用程序的源代码</p></figure><p id="deac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建步骤向您的<code class="fe nn no np nq b">package.json</code>添加一个命令。这个命令以热开发模式启动您的单页面应用程序:<code class="fe nn no np nq b">npm run interactive-list</code>(用您的单页面应用程序的名称替换<code class="fe nn no np nq b">interactive-list</code>)。当您在浏览器中打开<code class="fe nn no np nq b">localhost:3000</code>时，您应该会看到文本“Hello Infrastructure-Components！”到目前为止，一切顺利。</p><p id="6597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个简单的无序列表，在一个新文件中包含三个条目:<code class="fe nn no np nq b">src/list.tsx</code>。每个项目都有一个复选框:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表组件(<code class="fe nn no np nq b">src/list.tsx</code>)</p></figure><p id="30e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在<code class="fe nn no np nq b">list.tsx</code>中<code class="fe nn no np nq b">export default</code>了我们的函数，我们需要从<code class="fe nn no np nq b">index.tsx</code>中的模块导入默认值。我们在第9行这样做。在第22行，我们呈现了导入的组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将清单纳入index.tsx</p></figure><p id="b2df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了我们的列表。目前为止没什么特别的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/be442a2ef1b33046eb3c9d00f561238d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DYn1uH7wl-M9RyPaCEQ9A.png"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dcf2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">互动风格</h1><p id="c6e2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在React中管理样式最方便的方法是借助于<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=styled-components.com" rel="noopener ugc nofollow" target="_blank">样式组件</a>库。样式化组件允许您通过本地CSS文本来样式化React组件。</p><p id="e913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们的第一个样式组件。我们将跳过代码中没有变化的部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目的样式</p></figure><p id="6943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从库中导入默认模块(<code class="fe nn no np nq b">styled</code>)。<code class="fe nn no np nq b">styled</code>模块是<code class="fe nn no np nq b">styled-components</code>库的默认导出。这是一个低级工厂，以<code class="fe nn no np nq b">styled.tagname</code>的形式提供helper方法。</p><p id="60b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">tagname</code>是任何有效的HTML标签。例如，<code class="fe nn no np nq b">styled.li</code>创建一个列表项组件(<code class="fe nn no np nq b">&lt;li/&gt;</code>)。<code class="fe nn no np nq b">styled.li</code>函数接受模板字符串中的CSS定义(用反斜杠<code class="fe nn no np nq b">`...`</code>括起来)。</p><p id="164e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建一个<code class="fe nn no np nq b">Item</code>组件(<code class="fe nn no np nq b">&lt;li/&gt;</code>)并对其应用一个简单的样式。将格式化上下文设置为<code class="fe nn no np nq b">display: block;</code>。在块格式上下文中，组件一个接一个地垂直布局。每个组件的外边缘接触包含块的边缘。简单来说:我们让组件取整行。</p><p id="b30d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个项目的顶部都有一个细(<code class="fe nn no np nq b">1px</code>)、灰色(彩色<code class="fe nn no np nq b">#888</code>)的边框。并且我们去掉了未编号列表元素通常会有的点(<code class="fe nn no np nq b">list-style-type: none;</code>)。</p><p id="b59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">padding: 5px 0;</code>将顶部和底部的(内部)空间区域设置为<code class="fe nn no np nq b">5px</code>，并将组件的左侧和右侧设置为<code class="fe nn no np nq b">0</code>。</p><p id="030d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来添加一些交互风格。<code class="fe nn no np nq b">&amp;:hover { background: #EEE }</code>当用户将鼠标指针悬停在该项上时，将该项的背景设置为浅灰色。</p><p id="5471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们导出的组件中，我们用样式化的<code class="fe nn no np nq b">&lt;Item/&gt;</code>组件替换未样式化的<code class="fe nn no np nq b">&lt;li/&gt;</code>元素。</p><p id="c75b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一步中，我们将样式应用于列表，并向其添加标题，再次跳过未更改的部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">设置列表样式</p></figure><p id="668c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望我们的<code class="fe nn no np nq b">&lt;List/&gt;</code>组件(<code class="fe nn no np nq b">&lt;ul/&gt;</code>)填充浏览器的整个宽度，除了一点点空间。我们通过将<code class="fe nn no np nq b">width</code>设置为<code class="fe nn no np nq b">100%</code>减去我们想要留出的空间:<code class="fe nn no np nq b">20px</code>来实现这一点。(注意:<code class="fe nn no np nq b">calc</code>功能中的“<code class="fe nn no np nq b">-</code>”-符号前后必须有空格)。平均分配剩余的(外部)空间，因此使我们的列表居中。还有其他方法可以达到同样的效果。</p><p id="6091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他风格现在应该不言自明了。</p><p id="34ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们的应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e2b8f29ed6002e95f4fb5ec3624940ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUxe6l8iNYg7td2LUENAKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截图里鼠标不见了…但是我可以确认是在第二个项目上面</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8d38" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">高级用户交互</h1><p id="b932" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">任何React应用程序的视觉和交互功能都不仅仅是将CSS样式应用于组件。拖放手势就是一个例子。拖放是一种在web和移动应用程序中移动和重新排列元素的直观方式。它监听指针(鼠标或触摸)事件，处理数据，并更改DOM。</p><p id="3962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拖放是HTML5的一部分(如这里描述的<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://www.w3schools.com/html/html5_draganddrop.asp" rel="noopener ugc nofollow" target="_blank"/>)。因此，我们可以将这个手势添加到基于低级HTML5 API的应用程序中。然而，有相当多的库将这种手势包装成程序员友好的高级API。<code class="fe nn no np nq b"><a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://github.com/clauderic/react-sortable-hoc" rel="noopener ugc nofollow" target="_blank">react-sortable-hoc</a></code>就是一个很好的例子。它提供了一组高阶的React组件，将任何列表转换成一个动画的、触摸友好的、可排序的列表。</p><p id="d152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="oe">高阶React组件</em> (HOC)是React中重用组件逻辑的高级技术。通常，React组件将属性转换成可见的东西，比如链接、列表或任何其他HTML元素。高阶组件增加了将一个组件改变为另一个组件的功能。</p><p id="25ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用高阶组件<code class="fe nn no np nq b">react-sortable-hoc</code>向我们的组件添加拖放功能。</p><p id="f665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们将拖放功能添加到列表之前，我们需要将布局和数据分开。现在，我们的数据(项目的名称)被混合到可视化的React组件中。每一项都是硬编码的:<code class="fe nn no np nq b">&lt;Item&gt;Hard-coded Item Name&lt;/Item&gt;</code>。这既不灵活也不可扩展。</p><p id="807e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面描述了我们如何分离布局和数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在list.tsx中分离布局和数据</p></figure><p id="eaa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们导出的函数中，我们定义了一个常量<code class="fe nn no np nq b">items</code>。这是一个字符串数组:我们之前在<code class="fe nn no np nq b">&lt;Item/&gt;</code>组件中硬编码的数据。</p><p id="269c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第7行和第11行之间的代码块中，我们将分离的数据(<code class="fe nn no np nq b">items</code>数组)重新整合到<code class="fe nn no np nq b">&lt;Item/&gt;</code>组件中。一个数组提供了<code class="fe nn no np nq b"><a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">map</a></code>的<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">函数</a>。这个函数获取数组中的每一项，根据我们作为参数提供的函数对其进行转换，然后在一个新的数组中返回结果。它不会改变原始数组。</p><p id="791d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们作为参数提供的函数从第8行开始。它是一个匿名函数(没有名字)，遵循箭头符号:<br/> <code class="fe nn no np nq b">(arguments) =&gt; ("returned result")</code>。</p><p id="fdde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用两个参数<code class="fe nn no np nq b">item</code>和<code class="fe nn no np nq b">index</code>。虽然这两种观点的名称由我们决定，但它们的立场很重要。第一个参数是当前项。这是字符串。第二个参数是数组中当前项的索引。</p><p id="86b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为在我们的<code class="fe nn no np nq b">items</code>数组中有三个条目，所以<code class="fe nn no np nq b">map</code>函数调用了提供的函数三次。首先，用参数<code class="fe nn no np nq b">item="First Item"</code>和<code class="fe nn no np nq b">index=0</code>。然后，用参数<code class="fe nn no np nq b">item="Second Item"</code>和<code class="fe nn no np nq b">index=1</code>。最后…我想你可以算一下。</p><p id="5c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数转换这两个参数并返回一个<code class="fe nn no np nq b">&lt;Item/&gt;</code>组件。它将<code class="fe nn no np nq b">{item}</code>指定为可见内容，并将一个字符串(<code class="fe nn no np nq b">"item-0"</code>和<code class="fe nn no np nq b">item-1</code>)指定为<code class="fe nn no np nq b">key</code>属性的值。这是有技术原因的。当我们在JSX中提供一个返回数组的代码块时(就像<code class="fe nn no np nq b">map</code>函数所做的那样)，React要求我们为数组的每个项提供一个唯一的<code class="fe nn no np nq b">key</code>属性。</p><p id="bd2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你运行应用程序，你应该看不到任何区别。但是现在我们的所有数据都在一个没有任何布局的数组中。我们准备通过<code class="fe nn no np nq b">react-sortable-hoc</code>库添加拖放功能。让我们先看看代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加拖放功能</p></figure><p id="8130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2行，我们导入两个高阶组件:<code class="fe nn no np nq b">SortableContainer</code>和<code class="fe nn no np nq b">SortableElement</code>。</p><p id="ad49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">SortableElement</code>函数使一个组件可拖动。在第3行，<code class="fe nn no np nq b">SortableElement</code>将<code class="fe nn no np nq b">Item</code>函数作为参数，并返回一个类似的可拖动函数(注意:这里不要用<code class="fe nn no np nq b">&lt;Item/&gt;</code>将其作为渲染组件提供)。</p><p id="06e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数准备一个父组件来包含可拖动的子组件。我们可以像以前一样将<code class="fe nn no np nq b">List</code>函数传递给它。但是还有另一种方法。让我们看一看。</p><p id="d736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React函数将属性转换成可见的东西，就像这个<br/> <code class="fe nn no np nq b">const Component = (props) =&gt; &lt;div/&gt;</code>。</p><p id="6070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶组件接受组件(<code class="fe nn no np nq b">Component</code>)或其主体(<code class="fe nn no np nq b">(props) =&gt; &lt;div/&gt;</code>)的函数声明(名称)。在第5行，我们使用后一种形式。我们用一个<code class="fe nn no np nq b">&lt;Header/&gt;</code>和映射的<code class="fe nn no np nq b">items</code>数组将<code class="fe nn no np nq b">props</code>转换成<code class="fe nn no np nq b">&lt;List/&gt;</code>。</p><p id="1683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只期望<code class="fe nn no np nq b">props</code>包含<code class="fe nn no np nq b">items</code>。当我们在导出的函数中返回呈现的<code class="fe nn no np nq b">&lt;SortableList/&gt;</code>时，我们提供了<code class="fe nn no np nq b">items</code>数组。结果是一个简洁的导出函数。所有与frag相关的逻辑都保存在<code class="fe nn no np nq b">&lt;SortableList/&gt;</code>组件中。</p><p id="ddd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第11行，我们将<code class="fe nn no np nq b">index</code>属性添加到了<code class="fe nn no np nq b">&lt;SortableFile/&gt;</code>中。这是<code class="fe nn no np nq b">react-sortable-hoc</code>库所需数组中的<code class="fe nn no np nq b">sortableIndex</code>元素。</p><p id="ba8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看应用程序，你现在可以拖动这两个文件。但是一旦你放下它们，它们就会回到原来的位置。他们当然会，因为我们的<code class="fe nn no np nq b">items</code>阵列不会改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/0774b5ed6988db1c9ca4c1b6532be8b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FkP5QTmzlTZsFsU9OAS3gQ.gif"/></div></div></figure><h2 id="293c" class="nw mr it bd ms og oh dn mw oi oj dp na li ok ol nc lm om on ne lq oo op ng oq bi translated">本地组件状态</h2><p id="b200" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当您查看<code class="fe nn no np nq b">react-sortable-hoc</code>的<a class="ae ky" href="https://www.infrastructure-components.com/page?ref=medium_dnd&amp;dest=https://github.com/clauderic/react-sortable-hoc" rel="noopener ugc nofollow" target="_blank">引用</a>时，您会看到<code class="fe nn no np nq b">SortableContainer</code> HOC将<code class="fe nn no np nq b">onSortEnd</code>属性添加到我们的<code class="fe nn no np nq b">&lt;List/&gt;</code>中。该属性将一个函数作为排序结束时调用的参数。它接收被拖动项目的<code class="fe nn no np nq b">oldIndex</code>和<code class="fe nn no np nq b">newIndex</code>。</p><p id="65eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们如何改变我们的<code class="fe nn no np nq b">items</code>数组呢？是不可改变的<code class="fe nn no np nq b">const</code>。将其更改为可变的<code class="fe nn no np nq b">var</code>对我们没有帮助，因为无论React何时渲染组件，它都会重新开始。它不会“记住”变量的值。除非React重新渲染组件，否则我们看不到任何变化。</p><p id="6215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是<code class="fe nn no np nq b">useState</code> React钩子(React 16.8.0起支持)。钩子提供了一种将可重用行为“附加”到组件上的方法。因此，钩子类似于高阶组件。但是，虽然高阶组件需要外部包装器，从而改变了组件层次结构，但是钩子允许您在不改变逻辑的情况下重用逻辑。</p><p id="76db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码向我们的列表添加了一个状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加useState挂钩</p></figure><p id="99d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">useState</code>是函数。我们从<code class="fe nn no np nq b">react</code>导入它，并在第4行使用它。它只需要一个参数。这是初始状态。因此，我们提供先前放入<code class="fe nn no np nq b">items</code>数组的相同数据。</p><p id="8493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">useState</code>返回包含两个元素的数组。第一个元素是当前状态。因为我们没有改变它，所以它是我们的初始状态:我们的<code class="fe nn no np nq b">items </code>数组。我们像以前一样使用它。在第6行，我们将其作为属性提供给<code class="fe nn no np nq b">&lt;SortableList/&gt;</code>组件。</p><p id="ee78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的是二次元。这是一个设置状态的函数。我们可以使用任意的名称；姑且称之为<code class="fe nn no np nq b">setItems</code>。我们在第11行的<code class="fe nn no np nq b">onSortEnd</code>函数中使用这个函数；我们提供了一个新的<code class="fe nn no np nq b">items</code>数组，其中包含更新后的项目顺序。</p><p id="f55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第8行，我们创建了一个新的临时数组，没有被拖动的文件。数组的<code class="fe nn no np nq b">slice</code>函数返回数组的一部分。<code class="fe nn no np nq b">slice</code>的两个参数指定了<code class="fe nn no np nq b">begin</code>和<code class="fe nn no np nq b">end</code>(不包括<code class="fe nn no np nq b">end</code>)的指标。数组的<code class="fe nn no np nq b">concat</code>函数连接两个数组。因此，我们从开始到被拖动的项(排除)取子数组，并将其连接到从被拖动的项之后到结尾的子数组(当用单个参数调用<code class="fe nn no np nq b">slice</code>时，如第9行)。</p><p id="eba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将这个临时数组从开始分割到新的位置，将它与被拖动的项(取自原始的<code class="fe nn no np nq b">items</code>数组)连接起来，并将它与临时数组的其余部分连接起来。这是我们提供给<code class="fe nn no np nq b">setItems</code>函数的重新排序的<code class="fe nn no np nq b">items</code>数组。</p><p id="98de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四行有错误吗？我们将<code class="fe nn no np nq b">items</code>数组声明为<code class="fe nn no np nq b">const</code>。但是你不能换一个<code class="fe nn no np nq b">const</code>！</p><p id="4fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">setItems</code>功能不会改变这些值。它使React使用新值重新呈现用户界面。React用新的替换旧的<code class="fe nn no np nq b">&lt;SortableList/&gt;</code>。新的<code class="fe nn no np nq b">&lt;SortableList/&gt;</code>有自己的不可变的<code class="fe nn no np nq b">items</code>数组。它只知道当前状态；过去的状态并不重要，国家是如何建立的也不重要。</p><p id="15ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看我们的互动列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/aeca0f836545e36431b9e1731086f2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AnrOXxONn37ePIn2vduaDA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行中的交互式列表。</p></figure><p id="ffb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的<code class="fe nn no np nq b">list.tsx</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e3b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在GitHub-repository 中找到完整的源代码。</p><div class="or os gp gr ot ou"><a href="https://medium.com/dailyjs/how-to-build-and-deploy-a-full-stack-react-app-4adc46607604" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">如何构建和部署全栈React-App</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">用Express.js和DynamoDB补充你的React-app。</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://codeburst.io/do-you-want-to-become-a-full-stack-developer-e532dd2b7714" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">你想成为一名全栈开发者吗？</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">然后你需要学习如何防止时间悖论！</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">codeburst.io</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://codeburst.io/why-should-i-even-bother-with-full-stack-development-142b9c4c7c3f" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">我为什么要为全栈开发费心呢？</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">全栈开发不再需要多种编程语言。它需要你像一个…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">codeburst.io</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>