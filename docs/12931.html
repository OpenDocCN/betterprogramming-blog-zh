<html>
<head>
<title>How Does Flutter Communicate With Platform Native Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter如何与平台原生代码通信？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-does-flutter-communicate-with-platform-native-code-2bb002f64121?source=collection_archive---------3-----------------------#2022-07-12">https://betterprogramming.pub/how-does-flutter-communicate-with-platform-native-code-2bb002f64121?source=collection_archive---------3-----------------------#2022-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6570" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索不同的渠道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/88d0bc2358f54651699b61c6ac781cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sxecnqSSLloAk2iK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马文·迈耶在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="daa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flutter在创建跨平台应用程序方面做得非常出色。有了许多现成的插件，访问本机功能和特性很容易，而且花费的时间很少。</p><p id="379f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当插件不能胜任任务时会发生什么呢，对于你正在做的工作还没有插件，或者你需要有你的自定义实现。</p><p id="a706" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，事情是这样的:你需要为你的目标平台编写本地代码，并在本地代码和flutter框架之间来回传递数据。听起来很难？但是不要担心，因为在这篇文章中，你将学会如何无缝地做到这一点。</p><h1 id="22d9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">沟通的平台渠道</strong></h1><p id="ecf8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Flutter使用灵活的消息传递方式在dart代码和应用程序主机的本机代码之间进行通信。Flutter应用程序通过平台通道向其主机发送消息。主机监听平台通道并接收消息，执行本机代码，并向Flutter代码发回响应。所有这些都是异步发生的，以保持应用程序的响应能力。</p><blockquote class="mp mq mr"><p id="9997" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">所有消息在发送之前都被编码成二进制，接收到的二进制结果被解码成Dart值。</p></blockquote><h2 id="db68" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">平台渠道API的类型</strong></h2><p id="72ff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Flutter提供了各种通道来与特定于平台的代码进行通信。根据您的需要，以及您正在交互的特定于平台的代码的类型，您可以选择以下任意一种或混合使用。</p><blockquote class="mp mq mr"><p id="33f5" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">所有通道都需要一个名称传递给它们连接客户端和主机端的构造函数。该名称必须是唯一的，并鼓励命名方案。</p></blockquote><ol class=""><li id="3ac7" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated"><a class="ae kv" href="https://api.flutter.dev/flutter/services/BasicMessageChannel-class.html" rel="noopener ugc nofollow" target="_blank">基础消息通道</a> <br/>使用异步消息传递与平台插件通信的命名通道。</li></ol><p id="292b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是最简单的平台通道，采用一个<a class="ae kv" href="https://api.flutter.dev/flutter/services/MessageCodec-class.html" rel="noopener ugc nofollow" target="_blank">消息编解码器</a>对传递的数据进行编码和解码。Flutter提供了四种编解码器，分别是<a class="ae kv" href="https://api.flutter.dev/flutter/services/StringCodec-class.html" rel="noopener ugc nofollow" target="_blank"> StringCodec </a>、<a class="ae kv" href="https://api.flutter.dev/flutter/services/BinaryCodec-class.html" rel="noopener ugc nofollow" target="_blank"> BinaryCodec </a>、<a class="ae kv" href="https://api.flutter.dev/flutter/services/JSONMessageCodec-class.html" rel="noopener ugc nofollow" target="_blank"> JSONMessageCodec </a>和<a class="ae kv" href="https://api.flutter.dev/flutter/services/StandardMessageCodec-class.html" rel="noopener ugc nofollow" target="_blank"> StandardMessageCodec </a>。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="94ca" class="mw lt iq ns b gy nw nx l ny nz">final messageChannel = BasicMessageChannel&lt;String&gt;(‘platform.testing/sensor_support’, StringCodec());<br/></span></pre><p id="befe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<a class="ae kv" href="https://api.flutter.dev/flutter/services/MethodChannel-class.html" rel="noopener ugc nofollow" target="_blank">方法通道</a> <br/>使用异步方法调用与平台插件通信的命名通道。</p><p id="f15e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是最常见的平台渠道，适合大多数使用案例。它提供了一种在本机代码中执行函数并返回结果的方法。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="ed1e" class="mw lt iq ns b gy nw nx l ny nz">final methodChannel = MethodChannel('platform.testing/method_calls');```</span></pre><p id="489b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<a class="ae kv" href="https://api.flutter.dev/flutter/services/EventChannel-class.html" rel="noopener ugc nofollow" target="_blank"> EventChannel <br/> </a>使用事件流与平台插件通信的命名通道。</p><p id="ac93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它适合于监听本地代码的变化，只要发生变化，本地代码就会更新您的Dart流。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="098f" class="mw lt iq ns b gy nw nx l ny nz"><br/>final eventChannel = EventChannel(‘platform.testing/light_sensor’);</span></pre><p id="c31f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了以上信息，您就可以开始编写一些代码了。我们准备搭建一个app，可以检测一个地方的光线强度(照度)。使用移动设备上的光传感器，我们可以实现这一点。</p><blockquote class="mp mq mr"><p id="a425" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">注意:本文目前只针对Android平台</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="e9ca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">设置提示</strong></h1><p id="e60c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了更好地调试，在编写特定于平台的代码和flutter代码时，我建议您执行以下操作:</p><ul class=""><li id="e7d0" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oc no np nq bi translated">使用VS代码打开Flutter项目。您可以运行应用程序来查看flutter日志和错误。</li><li id="fc39" class="ni nj iq ky b kz od lc oe lf of lj og ln oh lr oc no np nq bi translated">使用android Studio打开Android文件夹。你可以运行应用程序来查看android原生日志以及使用断点。</li></ul><h2 id="8154" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">权限</strong></h2><p id="ce16" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在主清单文件中添加以下内容，向用户请求权限。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="63a1" class="mw lt iq ns b gy nw nx l ny nz">&lt;uses-permission android:name="android.permission.BODY_SENSORS" /&gt;</span></pre><h2 id="e715" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">依赖关系</strong></h2><p id="5163" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在<code class="fe oi oj ok ns b">pubsec.yaml</code>文件中添加这个依赖项来处理权限请求。</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="650e" class="mw lt iq ns b gy nw nx l ny nz">permission_handler: ^10.0.0</span></pre><h2 id="f300" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">颤振平台通道实现</strong></h2><p id="a542" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是dart和flutter代码实现。请通读评论，了解它是如何工作的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol ob l"/></div></figure><h2 id="a8f3" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak"> Android Kotlin实现</strong></h2><p id="fa96" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在你的android源文件夹中创建一个新文件<code class="fe oi oj ok ns b">SensorActivity.kt</code>。将以下内容粘贴到其中。</p><p id="4557" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是处理光传感器变化的代码实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol ob l"/></div></figure><p id="1419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们编辑<code class="fe oi oj ok ns b">MainActivity.kt</code>文件的内容。这是配置FlutterEngine和注册所有插件的地方。平台通道API也在这里处理。</p><p id="a6bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码包含了关于如何操作的注释:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol ob l"/></div></figure><blockquote class="mp mq mr"><p id="684f" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">注意:发送的每条消息都包含来自接收方的异步强制回复。Dart总是希望为其未来的完成而传递的每条消息都有响应。</p></blockquote><p id="5961" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，您已经迈出了将平台本机代码集成到Flutter应用程序中的第一步。你也可以编写和发布你的插件。</p><p id="1cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是工作应用程序的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om ob l"/></div></figure><p id="1e96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止，小点。</p><p id="8be9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p><p id="d4ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再见。</p><h1 id="b2d6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="f546" class="ni nj iq ky b kz mk lc ml lf on lj oo ln op lr oc no np nq bi translated"><a class="ae kv" href="https://medium.com/flutter/flutter-platform-channels-ce7f540a104e" rel="noopener">颤振平台文章</a>作者<a class="oq or ep" href="https://medium.com/u/3568699995b8?source=post_page-----2bb002f64121--------------------------------" rel="noopener" target="_blank"> Mikkel Ravn </a></li><li id="202d" class="ni nj iq ky b kz od lc oe lf of lj og ln oh lr oc no np nq bi translated"><a class="ae kv" href="https://docs.flutter.dev/development/platform-integration" rel="noopener ugc nofollow" target="_blank">颤振文件</a></li><li id="ab44" class="ni nj iq ky b kz od lc oe lf of lj og ln oh lr oc no np nq bi translated"><a class="ae kv" href="https://youtu.be/ht2bDlJd2c4" rel="noopener ugc nofollow" target="_blank">无聊的旋舞秀</a></li></ul></div></div>    
</body>
</html>