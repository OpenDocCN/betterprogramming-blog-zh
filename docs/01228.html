<html>
<head>
<title>Solving the Sliding Maximum Window Problem in O(n) Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">O(n)时间内求解滑动最大窗口问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solving-the-sliding-maximum-window-problem-with-o-n-b43ea3dd871f?source=collection_archive---------4-----------------------#2019-08-24">https://betterprogramming.pub/solving-the-sliding-maximum-window-problem-with-o-n-b43ea3dd871f?source=collection_archive---------4-----------------------#2019-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="897f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">滑动最大窗口面试问题的最优解</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e5db7f5f57b79267d6685d3efa8e718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HkKacS4HkXC04AB8sTe9qQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@ryanquintal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">瑞安·昆塔尔</a>在<a class="ae kv" href="https://unsplash.com/search/photos/computer-queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ffef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你好，咖啡迷们！今天，我将带你解决我最喜欢的问题之一:滑动最大化窗口。</p><p id="ae2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从表面上看，这可能看起来是一个相当简单的问题，事实上，使用暴力方法，你可以在几分钟内完成，或者如果你像我一样有很好的大脑和手指速度协调能力，几秒钟就可以完成。</p><p id="1b10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一会儿我会给你看问题陈述——暂停阅读，如果你愿意，试着自己解决。提示:<em class="ls">A</em><a class="ae kv" href="https://medium.com/@oluwadamilareo_/implementing-a-deque-in-ruby-cf6e9bfd9c3c" rel="noopener"><em class="ls">Deque</em></a><em class="ls">是你的最佳赌注</em>。</p><p id="a43a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要复习或帮助实现，请查看这个关于Deques的教程。</p><h1 id="8e17" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">问题陈述</h1><p id="1489" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于数组中的每k个连续数字，打印最大的数字。这个挑战很容易蛮干，但是要努力找到最优解。</p><ul class=""><li id="acd3" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">简单的解决方案:O(nk)</li><li id="270c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">更好的解决方案:O(n log k)</li><li id="a411" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">最优解:O(n)</li></ul><h1 id="7a38" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">例子</h1><p id="ab1d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">以下是您可以针对您的解决方案运行的一些示例测试案例:</p><p id="bb19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">sliding_maximum(3, [1, 3, 5, 7, 9, 2])</code><br/># # =&gt;【5，7，9，9】</p><p id="5936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b">sliding_maximum(4, [9, 3, 5, 1, 7, 10])</code><br/># # # =&gt;【9，7，10】</p><p id="82cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，对吧？这里有一个大多数人在几秒钟内就能找到解决方案的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">强力解决方案</p></figure><p id="1764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有一个小的数据集，并且不太关心时间复杂性，这可能看起来没问题。事实上，就时间复杂性而言，这个解决方案是蝙蝠侠中的小丑:让它走，它会回来咬你的屁股，因为它给你O(nk)。</p><p id="815f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这篇文章的原因。</p><p id="4bc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题花了我将近12个小时来解决，但这12个小时是值得的，因为我获得的新知识为我如何看待这些天的问题打开了许多精神之门。</p><p id="3fc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们把问题分解一下，想想第一块。我们需要找到一种方法来跟踪特定窗口中的最大值，同时跟踪当前窗口中下一个窗口的潜在最大值。没关系——如果你感到困惑，可以再读一遍。</p><p id="25c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，我们开始明白为什么需要deque了——可以在数据集的后面或前面执行O(1)运算。</p><p id="8309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过将我们的功能分成三个部分来解决基本问题:</p><ul class=""><li id="0262" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">初始化队列和结果向量</li><li id="75c2" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">遍历数组的循环</li><li id="b8ca" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">返回结果</li></ul><p id="6cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将滑动最大值函数分为三个主要部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果你需要帮助设置你的deques类，请看看我之前的关于deques的教程</em><a class="ae kv" href="https://medium.com/@oluwadamilareo_/implementing-a-deque-in-ruby-cf6e9bfd9c3c" rel="noopener"><em class="ls"/></a><em class="ls">。</em></p><p id="aa3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要一个循环来遍历数组。在这种情况下，for循环是我最喜欢的，但是一定要尝试你最喜欢的循环。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0640" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在真正的乐趣开始了！</p><p id="6d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了我称为外部声明的函数定义之外，我们从这一点开始写的所有东西都应该放在循环的内部。</p><p id="e9d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们要考虑的第一件事是在我们的deque中添加一个元素(如果它是空的),这样我们就可以与第一个窗口中的元素进行比较。我们将数组中的第一个元素添加到队列中，因为队列是空的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="13f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个简单的一行程序，用于在我们第一次进入循环时将第一个元素推入deque。</p><p id="de18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:<code class="fe ne nf ng nh b">is_empty?</code>是deque类中的一个方法。查看本<a class="ae kv" href="https://medium.com/@oluwadamilareo_/implementing-a-deque-in-ruby-cf6e9bfd9c3c" rel="noopener">教程</a>了解更多信息。</p><p id="9b8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们希望将当前最大值与给定窗口中的所有其他数字进行比较，因此我们首先需要获得最大值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="52ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还声明了一个外部的<code class="fe ne nf ng nh b">get_max</code>函数。让我们看看它能做什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f2ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它返回队列前面的元素(前面的元素总是给定窗口的最大值)。</p><p id="e496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，对于窗口中的后续数字，我们将它们与当前的最大数字(存储在max变量中的数字)进行比较。如果当前的最大值小于我们得到的值，我们删除旧的最大值并将当前值设置为最大值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="268f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们细分一下<code class="fe ne nf ng nh b">set_max</code>的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b0e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它将双队列和最大值作为参数，并将最大值推到双队列的前面。</p><p id="7ab3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看<code class="fe ne nf ng nh b">remove_max</code>是做什么的。它将deque作为参数，并弹出前端(<em class="ls">删除第一个元素，这是我们的max </em>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ba8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能还需要考虑其他一些事情。如果当前窗口中的下一个窗口有潜在的最大数量，会发生什么？目前，如果它小于我们当前窗口中的最大值，我们的算法将跳过它，但我们不能让它溜走-这可能是我们的下一个赢家！</p><p id="45d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把这些潜在的赢家放在队列的后面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可能想问“如果我们把一个窗口的最大值带到下一个窗口会怎么样？”我们的算法可以将我们结转的值计算为下一个最大值，我们真的不能责怪它，因为算法的智能取决于编写它的人。</p><p id="6c15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望防止这种情况，并使我们的算法更加智能。第一件事是决定如何发现一个元素是否在窗口之外。请看下图对此的解释:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/607737dedfe274867ea7ef8be479bc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NtR111HdEUfdo4ZJhwd9w.png"/></div></div></figure><p id="059e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经确定了超出界限的元素，下一步是将它从我们的队列的最大位置中移除。我们的方法是这项工作的极客。</p><p id="43d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:记得在检查潜在最大值的代码块之前添加这个代码片段</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以得到新的最大值。如果我们的索引大于或等于当前窗口，我们可以说这是给定窗口的最大值，然后将其附加到结果向量中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="3ad5" class="nl lu iq bd lv nm nn dn lz no np dp md lf nq nr mf lj ns nt mh ln nu nv mj nw bi translated">感谢你的到来！</h2><p id="45ae" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这里有一个<a class="ae kv" href="https://github.com/Oluwadamilareolusakin/sliding-maximum-window-with-deque" rel="noopener ugc nofollow" target="_blank">链接指向本教程</a>的代码。</p></div></div>    
</body>
</html>