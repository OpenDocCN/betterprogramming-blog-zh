<html>
<head>
<title>5 React Component Best Practices You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5您应该知道的React组件最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-practices-i-wish-all-react-developers-knew-part-1-ff6cdee0666a?source=collection_archive---------0-----------------------#2021-02-01">https://betterprogramming.pub/best-practices-i-wish-all-react-developers-knew-part-1-ff6cdee0666a?source=collection_archive---------0-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="afd0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">析构道具、命名组件等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de4fede990e3121236aee020f377937f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vjNb49W4vkNLd8uv"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">迈克尔·泽兹奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React是一个非常灵活的软件库，在应用程序结构或设计方面没有明确的最佳实践。然而，开发人员仍然可以使用一些最佳实践和通用规则来编写更好的React代码。</p><p id="554f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于开发人员来说，软件架构意味着高效和灵活。好软件的目标是在需要任何修改或添加时，保持代码库的可维护性和模块化。</p><p id="5821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我收集了一些我为编写良好的React代码而挑选的最佳实践，这些实践已被证明在大大小小的应用程序中都是有效的。</p><p id="edc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，请记住，这些不是规则，这些是我发现的关于编写良好React代码的最佳实践的意见。</p><p id="bb05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把它分成几个部分，以便于理解。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4cf0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">成分</h1><p id="991d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将开始讨论组件及其结构。</p><h2 id="373c" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">命名组件</h2><p id="0034" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">始终命名您的React组件。它使得读取错误堆栈、使用React开发工具和搜索大型代码库变得更加容易。</p><p id="6b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还有助于自动完成找到您想要使用的组件！</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="2f69" class="mw ma iq nj b gy nn no l np nq">// This is an unnamed component. Don't do this<br/>export default () =&gt; &lt;div&gt;...&lt;/div&gt;</span><span id="7d03" class="mw ma iq nj b gy nr no l np nq">// This is a named component :)<br/>export default function Card() { return &lt;div&gt;...&lt;/div&gt; )</span></pre><h2 id="f79d" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">编写一致组织的组件</h2><p id="faac" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">无论您选择哪种风格来编写组件，都要确保在整个代码库中保持一致。这意味着组织，就像你把你的助手函数或者导出放在哪里，或者是相对于lambda函数的<code class="fe ns nt nu nj b">function</code>语法(就像我上面做的)。如果每个文件的代码看起来和感觉起来都一样，那么每个开发人员的生活都会变得更加轻松和高效。</p><h2 id="00fa" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">将常量和帮助器分离到不同的文件中</h2><p id="57a0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我在编写React组件时的目标是将每个文件控制在200行以内。这意味着将<code class="fe ns nt nu nj b">helper</code>函数移动到一个单独的<code class="fe ns nt nu nj b">component.utils.ts</code>文件中，将常量移动到一个<code class="fe ns nt nu nj b">component.constants.ts</code>文件中，以使组件更小，更易于阅读。</p><p id="8159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在处理大型状态对象时特别有效:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d0ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这种结构，理解甚至非常复杂的组件也变得容易得多，因为它们是模块化的，并且被分解成小块。</p><h2 id="5049" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">破坏道具</h2><p id="d753" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">大多数React组件都是基本函数。他们接受一些道具并返回标记。大多数情况下，你直接使用传入的参数，所以析构<code class="fe ns nt nu nj b">props</code>是有意义的，这样就不会到处重复。</p><p id="9b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除非您的组件有托管状态，否则将函数参数分解成单独的键几乎总是有意义的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="05d8" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">不要传递太多的道具</h2><p id="e9fd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">复杂的组件更难阅读和维护。如果你传入了很多道具，真的要考虑它们是否可以被分解成更多的部分。传入的道具数量通常与组件的工作量相关。</p><p id="cc66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我传入了六个以上的道具，我通常知道有某种方法可以将组件分解成更小的块。在某些情况下，像输入，有大量的道具是可以的(它们需要很多值)；否则，提取并模块化。</p><h2 id="83bd" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">避免嵌套渲染函数</h2><p id="2aab" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这是我在审查的代码中最不喜欢看到的做法。当从一个组件中提取标记和逻辑时，不要在另一个组件中创建函数。嵌套组件几乎总是一个坏主意，会使代码难以阅读。</p><p id="524b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将新组件移动到它自己的文件中，并依赖props，而不是使用全局嵌套状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="167e" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">条件渲染实践</h2><p id="5bf1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有几个很好的方法可以进行条件渲染。短路运算符是进行条件渲染的一种非常简单快捷的方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="722d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个关于短路操作符的很棒的<a class="ae kv" href="https://stackoverflow.com/questions/12554578/does-javascript-have-short-circuit-evaluation" rel="noopener ugc nofollow" target="_blank">栈溢出帖子</a>，解释了你可以用这些来写更干净的代码的更多方法。</p><h2 id="5377" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">析构时分配默认属性</h2><p id="6ace" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用默认属性时，可以在组件上使用<code class="fe ns nt nu nj b">defaultProps</code>属性，但不要。这使得组件更难阅读，因为值没有在定义键的地方声明。</p><p id="682e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢在析构属性时指定默认值。这也使得从上到下阅读代码更加容易，而不必跳来跳去地寻找默认的属性，将定义和值放在一起。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="3925" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">喜欢路过的物体</h2><p id="78b9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">限制传递的属性数量的一个好方法是传递一个对象，而不是一组原始值。例如，您可以将用户分组在一起，而不是传递用户的每个方面。接下来，如果用户获得了额外的数据，这个函数不需要修改来适应这种情况。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="134e" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">将列表移动到单独的组件中</h2><p id="b8ad" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">React中最常见的操作之一是使用一个<code class="fe ns nt nu nj b">map</code>函数遍历一个列表来生成组件。然而，在组件中，这会导致一些混乱的代码:额外的标记、缩进和Javascript，这些都无助于可读性。</p><p id="b676" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您需要映射元素时，将它们提取到它们自己的列表组件中。如果父组件只是显示列表，它不需要知道细节，这使得父组件更容易阅读。</p><p id="ac29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果一个组件的主要职责是显示一个列表，那么就保留它。每个组件应该只有一个映射。如果有多个，那么它们都应该被提取到它们自己的组件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="54c3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="6d4e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">请记住，这些只是建议，最佳实践是最适合您的团队的实践。在下一部分，我们将讨论状态管理的最佳实践。</p></div></div>    
</body>
</html>