<html>
<head>
<title>How to Organize Your AWS CDK Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何组织你的AWS CDK项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-organize-your-aws-cdk-project-f1c463aa966e?source=collection_archive---------5-----------------------#2021-01-14">https://betterprogramming.pub/how-to-organize-your-aws-cdk-project-f1c463aa966e?source=collection_archive---------5-----------------------#2021-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f361" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">过去，我会使用Terraform以代码的形式构建我的基础设施。最近，我发现了AWS CDK，并决定尝试一下</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/87cfd28b6d19b4ad4800fb3caffa54ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C6tskh2rGIR_5s8I"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@alain_pham?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿兰·范</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="89fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将与您分享如何组织和调整您的<a class="ae kv" href="https://aws.amazon.com/cdk/" rel="noopener ugc nofollow" target="_blank"> CDK </a>存储库来提供多阶段AWS基础设施。</p><p id="a7fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将构建一个简化版本的基础设施，由一个VPC及其子资源、一个Kubernetes集群和一个<a class="ae kv" href="https://www.elastic.co/elasticsearch/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>集群组成。<br/>这个项目是用Python开发的，源代码可以在<a class="ae kv" href="https://github.com/aftouh/cdk-template" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="63f8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">启动CDK应用程序</h1><p id="52ae" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">第一步是使用以下CDK命令行初始化Python项目:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="068a" class="nb ma iq mx b gy nc nd l ne nf">cdk init sample-app — language python</span></pre><p id="363d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这会生成几个文件和目录。这些是保留的元素:</p><ul class=""><li id="4842" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><code class="fe np nq nr mx b">setup.py</code>:定义Python包(名称、文件、包元数据、运行时依赖等。).</li><li id="87d8" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated"><code class="fe np nq nr mx b">cdk.json</code>:告诉CDK工具包如何执行应用程序。</li><li id="4415" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated"><code class="fe np nq nr mx b">app.py</code>:项目的切入点。</li><li id="aa2c" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated"><code class="fe np nq nr mx b">tests/unit</code>:最后，可以像对任何其他应用程序一样对infra进行单元测试。</li></ul><p id="27d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个CDK <code class="fe np nq nr mx b">sample-app</code>是一个很好的起点，但显然不足以建立一个生产就绪的多阶段基础设施。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b611" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">组织堆栈和构造</h1><p id="9245" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">CDK框架的核心组件是堆栈和构造。<br/>一个<em class="nx">栈</em>是部署的单位。堆栈中定义的所有资源(或结构)都作为一个实体提供或销毁。<em class="nx">构造</em>是定义一个或多个AWS资源的基本构建块。</p><p id="db13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在项目开始时，花点时间考虑如何在CDK应用程序中组织堆栈和构造非常重要。稍后试图重新组织你的应用程序可能会变得混乱，并引入突破性的变化。</p><p id="08bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的环境中，我们最终有三个堆栈:</p><ul class=""><li id="08bd" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">网络堆栈:定义网络资源，如VPC、子网和安全组。</li><li id="48c1" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated">计算堆栈:定义无状态资源，如Kubernetes集群、bastion。</li><li id="9d5e" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated">数据堆栈:定义有状态资源。在我们的上下文中，这是一个弹性搜索集群。</li></ul><p id="8cde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种分裂的主要原因是:</p><ul class=""><li id="8b2f" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">灵活性:如前所述，将所有AWS资源放在一个堆栈中迫使我们一次创建或销毁所有资源。例如，通过这种三堆栈设置，可以销毁数据和计算堆栈，同时保持网络堆栈中定义的弹性IPs和VPC对等配置。</li><li id="b2da" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated">可维护性:这种分离提供了更好的开发人员体验。<br/>例如，如果贡献者正在计算堆栈上工作，他们不需要在短暂的贡献者阶段创建数据堆栈来测试他们的更改。在我们的例子中，我们不需要等待30分钟来创建Elasticsearch集群。</li><li id="d138" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated">成本优化:这种拆分提供了在周末安排删除非生产阶段的计算堆栈的可能性，同时保留我们的数据集。我们仍然可以为数据堆栈设置不同的销毁/创建策略。</li></ul><p id="0ccc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三个堆栈位于<code class="fe np nq nr mx b">stacks</code>目录下，每个都在一个单独的子目录中。在每个堆栈中，我们定义了一个或多个使用一个或多个CDK内置结构的定制结构<strong class="ky ir"> </strong>。例如，<code class="fe np nq nr mx b">Eks</code> <em class="nx"> </em>自定义<em class="nx"> </em>构造<em class="nx"> </em>使用<code class="fe np nq nr mx b">aws_eks.Cluster</code>、<code class="fe np nq nr mx b">aws_eks.NodeGroup</code>、<em class="nx"> </em> <code class="fe np nq nr mx b">aws_iam.Role</code>、<em class="nx"> </em>作为<em class="nx"> </em>内置构造:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="48da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有助于我们代码的可读性和可维护性。在这个层次上，它更多的是关于如何像组织其他应用程序一样组织代码。</p><p id="a5d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了三个栈，我们需要做的就是在<code class="fe np nq nr mx b">app.py</code>文件中实例化它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1314" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">文件配置</h1><p id="edbf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Infra as代码的优势之一是能够为不同阶段(例如开发、生产)复制相同的堆栈。</p><p id="eb75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Python这样的编程语言构建基础架构，让我们有机会像处理其他应用程序一样处理我们的CDK应用程序配置。一种常见的方法是使用YAML文件。在我们的例子中，这些文件存储在<code class="fe np nq nr mx b">config</code>目录中，并使用Python <a class="ae kv" href="https://pypi.org/project/python-benedict/" rel="noopener ugc nofollow" target="_blank"> benedict </a>库进行解析:</p><ul class=""><li id="f8c1" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><code class="fe np nq nr mx b">common.yaml</code>:包含应用于所有阶段的共享配置和默认值。</li><li id="e12a" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated"><code class="fe np nq nr mx b">&lt;stage-name&gt;.yaml</code>:每个阶段都有一个专用的配置文件，该文件定义了特定阶段的输入(AWS帐户、区域、网络CIDR)，并允许覆盖通用配置文件中设置的默认值(实例类型、集群大小等)。).</li></ul><p id="b2ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经设置好了配置，我们可以使用以下命令行之一开始部署阶段:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0641" class="nb ma iq mx b gy nc nd l ne nf"># Deploy the 3 stacks in the prod stage<br/>cdk deploy -c stage=dev '*'</span><span id="3706" class="nb ma iq mx b gy oa nd l ne nf"># Deploy the Network and Compute stacks in the dev stage<br/>cdk deploy -c stage=dev NetworkStack ComputeStack</span></pre><p id="7fa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请看一下<a class="ae kv" href="https://github.com/aftouh/cdk-template/blob/main/Makefile" rel="noopener ugc nofollow" target="_blank"> Makefile </a>以获得关于阶段生命周期命令的更多细节。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dbc9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">其他元素</h1><p id="3dbb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我想在这里提一下这个项目的其他一些要素:</p><ul class=""><li id="61e2" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">如你所料，它存储了应用程序的当前CDK版本。这很有用，因为CDK版本在不同的地方使用(Python依赖、CI等)。).把它放在一个地方真的很有帮助——尤其是对于升级。</li><li id="c682" class="ng nh iq ky b kz ns lc nt lf nu lj nv ln nw lr nl nm nn no bi translated"><code class="fe np nq nr mx b">utils</code>:包含一些在堆栈中使用的util函数(如配置解析器)和标签生成器函数。</li></ul><p id="6949" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这基本上就是我们的CDK存储库的组织方式。它非常适合我们的环境，通过基于GitOps工作流设置可靠的CICD，我们平静地投入生产。</p><p id="5c86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多关于GitOps工作流程的信息，我推荐你阅读<a class="ae kv" href="https://medium.com/better-programming/aws-cdk-continuous-integration-and-delivery-using-travis-ci-ee5dd7549434" rel="noopener">这篇文章</a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bbd8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="fc56" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您习惯于地形，使用CDK构建您的云环境需要不同的思维和组织方式来处理基础架构项目。通过使用Python作为编程语言，我有了处理这个项目的感觉，就像处理任何其他标准Python项目一样。团队中其他不太习惯infra人员的成员也不太愿意为这个项目做贡献，我相信这是因为不需要学习新的“编程”语言。</p><p id="cce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CDK是一个很有前途的工具，可以帮助组织在其DevOps文化中走得更远。</p></div></div>    
</body>
</html>