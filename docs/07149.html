<html>
<head>
<title>Scaling Node.js Applications With Multiprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多处理扩展Node.js应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scaling-node-js-applications-with-multiprocessing-b0c25511832a?source=collection_archive---------1-----------------------#2020-12-11">https://betterprogramming.pub/scaling-node-js-applications-with-multiprocessing-b0c25511832a?source=collection_archive---------1-----------------------#2020-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您可能没有充分利用您的多核服务器环境，甚至不知道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/903cab51867f99f0bcb39365ef405e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vslQFTq6M0L8A0uj"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">赫克托·j·里瓦斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7f3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Node是一个单线程JavaScript运行时环境。单线程有很多好处，它使Node成为许多人的首选后端开发环境。然而，单线程也有它自己的缺点。有了Node，你只有一个线程，主线程<em class="ls">，</em>，你必须确保它总是可用于服务传入的请求。这并不像听起来那么简单，尤其是如果您的应用程序必须服务于大量的请求，或者如果您的应用程序在某些时候必须执行CPU密集型任务。让我们看看如何用多重处理来解决这个问题。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f5ed" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是多重处理？</h1><p id="6486" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">多处理是Node中的一种服务器端扩展技术，允许您运行多个节点实例，理想情况下每个处理器内核运行一个节点实例。对于多个节点实例，您有多个主线程，因此即使其中一个线程被占用或崩溃，您仍然有其他线程来处理传入的请求。这样，您的应用程序就不会像下面这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/9fb100706a3f872b1228f5719f789699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XE06YhjSXImcMXUUQgizlg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没人喜欢没反应的应用。</p></figure><p id="2447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用节点的内置集群模块或其child_process <em class="ls"> </em>模块来实现多处理。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="09ad" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">处理CPU密集型任务</h1><p id="5fed" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果您使用Node已经有一段时间了，那么您一定听说过，如果您的应用程序有CPU密集型任务，Node不是一个好的选择。这是因为，如果您运行一个CPU密集型任务，并且需要相当长的时间来完成，那么Node的单个主线程将被阻塞，并且在任务完成之前，它将无法接受新的请求。</p><p id="4cfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">节点child_process <em class="ls"> </em>模块是这个问题的一个很好的解决方法。当您希望让多个节点实例遵循不同的执行流来完成一个共同的任务时，这是非常理想的。它允许您派生一个新的节点实例(子进程)，最好是在另一个CPU内核中，并将繁重的任务卸载给新派生的子进程。这使得父进程的主线程可以释放新的请求，并且一旦任务完成，卸载的任务的结果可以被传送回父进程。</p><p id="42ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何用一些代码来演示这一点。首先，我写了一个算法，以最低效的方式(模仿CPU密集型任务)检查一个给定的数是否是质数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f63b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我编写了一个简单的节点服务器，一旦调用了相关的API端点，就使用一个新派生的子流程来执行上述功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="14a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我通过使用八个并发连接发送八个请求，使用<a class="ae kv" href="https://github.com/mcollina/autocannon" rel="noopener ugc nofollow" target="_blank">autocanon</a>对服务器进行了基准测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/9bab4f5f9080961e6bf2d0bc33bc1413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXPmny461tAT3NHsG-zeiQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多处理基准测试</p></figure><p id="a543" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，服务器只花了1.02秒来处理请求。最后，我编写了另一个没有使用多处理的服务器，并在上面运行了相同的基准测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/978da2eea8cc8f65645674d779b90000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIOcxFRQg8rV1uDL6LAlHQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不带多重处理的基准测试</p></figure><p id="ec7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，服务器花了74秒来处理相同数量的请求。与之前的多处理实现相比，这是一个巨大的性能下降。</p><p id="1138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存在某些耗时的任务，例如I/O操作、网络操作和加密功能，节点设法以异步非阻塞方式执行这些任务，而不需要手动实现多处理。要了解更多关于Node如何处理异步任务的信息，请查看我的<a class="ae kv" href="https://medium.com/better-programming/single-threaded-and-asynchronous-how-does-node-do-it-d964100766a" rel="noopener">上一篇文章</a>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fff2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">处理大量的请求</h1><p id="b45e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当处理大量请求时，单线程可能会成为一种限制。随着请求数量的增长，服务器的响应时间会变长，因为所有的请求都只使用一个线程来处理。</p><p id="229a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">节点集群模块是这个问题的解决方案。它允许多个节点实例遵循同一个执行流，监听同一个端口，这在处理大量请求时非常理想。让我们写一些代码，看看它是如何工作的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="08a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在集群中，有一个名为<em class="ls">主进程</em>的主进程，它在这个应用程序中所做的就是派生其余的<em class="ls">工作进程</em>，每个可用的CPU内核一个。这些工作进程在同一个端口上侦听请求，当工作进程处于高负载状态时，集群模块的嵌入式负载平衡器会在它们之间分配请求。</p><p id="b5cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我执行了上面的代码，为了衡量集群是否能带来任何性能提升，我在服务器上运行了一个基准测试，模拟来自8个并发连接的100，000个请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/ad7acba4809fdf2cc48a800e2e1da90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfOuDObFjjVGZP-JQqSEOg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集群基准测试</p></figure><p id="6d3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器用6.02秒处理100，000个集群请求。然后，我实现了另一个类似的服务器，但没有集群，并在其上运行相同的基准测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/241759ee7410d262de4162ccfc97b390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkhKhTBn5Na-dnavr_au4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不带聚类的基准测试</p></figure><p id="f3a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，服务器花了12秒多的时间来处理相同数量的请求。与之前的集群实现相比，这是一个显著的性能下降，并且在真实的用例中可能会变得更加显著。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ae6e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">多重处理的缺点</h1><p id="b54d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">多重处理的性能提升是有代价的。实现多处理意味着运行多个节点实例，这会消耗大量内存。因此，您应该始终确保您的服务器环境能够承受多处理可能出现的内存使用高峰。</p><p id="07fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论您使用哪个节点模块，多处理都可能需要在某些应用程序中进行进程间通信，从长远来看，维护起来可能会有点复杂。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="00eb" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="5af0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">使用Node的内置模块可以很容易地实现多处理，它允许您充分利用可用的服务器环境。借助多处理技术，您可以在执行CPU密集型任务或处理大量请求时提升服务器性能，并提高服务器可用性。</p><p id="816e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="81a9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">资源</h1><p id="6293" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><a class="ae kv" href="https://www.freecodecamp.org/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/" rel="noopener ugc nofollow" target="_blank"> Node.js子进程:你需要知道的一切</a></p><p id="c089" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=w1IzRF6AkuI" rel="noopener ugc nofollow" target="_blank">技术演讲:Node.js中的服务器扩展</a></p><p id="0c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=hmTl5Y4ee_Y" rel="noopener ugc nofollow" target="_blank">构建无阻塞多进程Web服务器(Node JS fork示例)</a></p></div></div>    
</body>
</html>