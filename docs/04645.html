<html>
<head>
<title>How to Use UIKit Extensions With iOS Storyboards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS故事板中使用UIKit扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-uikit-extensions-with-ios-storyboards-3a20fdccaac7?source=collection_archive---------12-----------------------#2020-04-27">https://betterprogramming.pub/how-to-use-uikit-extensions-with-ios-storyboards-3a20fdccaac7?source=collection_archive---------12-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="04d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">因为您的用户界面可以使用一些定制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e61f2751286f31f9b59aed3038f081a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jF91p4ffHQH1hEmgpyaiwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="beb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">故事板是制作iOS用户界面的一种原生方式。最近苹果推出了SwiftUI，据称它将取代UIKit(用于故事板)，但目前，大多数iOS应用程序仍使用故事板。</p><p id="854f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">故事板只能在Xcode中编辑；这是一种专有的文件格式。从逻辑上来说，它是一组笔尖，UI的小部分——应用程序屏幕，可重复使用的单元，等等。它们还声明应用程序屏幕之间的连接。</p><p id="381f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用内包故事板编译成<code class="fe lu lv lw lx b">storyboardc</code>文件。它可以让iPhone或iPad快速有效地解析它们。</p><p id="11ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">故事板最大的缺点是只能在Xcode中编辑。与SwiftUI布局不同，故事板不能手动编辑(可以，但是强烈不推荐)。</p><p id="0ed8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个缺点导致了另一个缺点——UI编辑并不完美。有些特性不能在故事板编辑器中编辑，但必须在代码中编辑。比如阴影、渐变、圆角等特征需要在代码中添加或者……先说这个<em class="ly">或者</em>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e349" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">圆角、内容裁剪和边框</h1><p id="6f7b" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">UIKit中的每个视图都是<code class="fe lu lv lw lx b">UIView</code>的子类。每个<code class="fe lu lv lw lx b">UIView</code>都有一层或多层。不能在故事板编辑器中直接编辑层。但是图层恰恰定义了圆角、内容裁剪和边框等属性。</p><p id="31c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要做的就是使用<code class="fe lu lv lw lx b">@IBInspectable</code>属性使它们可编辑。</p><p id="435f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让它与<code class="fe lu lv lw lx b">UIView</code>及其所有子类(这意味着与所有视图)一起工作，我们可以创建一个扩展。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e559" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">CGColor</code>扩展只是一个简单的扩展，允许将其转换为<code class="fe lu lv lw lx b">UIColor</code>而不会有任何麻烦。图层与<code class="fe lu lv lw lx b">CGColor</code>一起工作，但是故事板“更喜欢”<code class="fe lu lv lw lx b">UIColor</code>。</p><p id="28de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b"> UIView</code>扩展允许您编辑:</p><ul class=""><li id="07e7" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">borderWidth</code>定义边框宽度。0(默认值)表示没有边框。任何正值都会创建一个边框(只要定义了<code class="fe lu lv lw lx b">borderColor</code>并且不透明)。</li><li id="a71c" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">borderColor</code>定义边框的颜色。</li><li id="93b9" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">cornerRadius</code>定义了圆角且大于0时。</li><li id="f9b5" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe lu lv lw lx b">masksToBounds</code>层外作物含量。</li></ul><p id="6b6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看几个例子(见下面的截图):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/f00acf89afda8394e8067aaf0e68d1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UmYnzRMqGVgkrXp1ZWypg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">圆角和浅蓝色框架</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/34a95f01bbc0bd4259b835805be5e2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QgWVWMoCZqH8t2BF1etM-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MasksToBounds断断续续</p></figure><p id="7587" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这张图中，有两个<code class="fe lu lv lw lx b">UIImageViews</code>具有相同的透明PNG，但是背景颜色不同，并且<code class="fe lu lv lw lx b">masksToBounds</code>也不同。正如你在前面的截图中看到的，<code class="fe lu lv lw lx b">masksToBounds</code>属性影响内容，但不影响背景。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bfe5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">阴影</h1><p id="a521" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">一个简单的矩形阴影几乎不成问题，但由于我们想要圆角，我们需要使用<code class="fe lu lv lw lx b">UIBezierPath</code>来塑造我们的阴影。</p><p id="a8ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个问题是属性的应用是随机的。嗯，这不是完全随机的，但是在我们创建阴影之前，我们不能确定对象的位置和大小。</p><p id="76ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们先看看代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1946" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的shadow是一个扩展，这意味着我们可以将它应用于任何<code class="fe lu lv lw lx b">UIView</code>子类。在这个例子中，与其说是阴影，不如说是暗光，但是用不同的<code class="fe lu lv lw lx b">shadowOffset</code>看起来会更模糊。</p><p id="1a5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么我们需要<code class="fe lu lv lw lx b">updateShadows</code>方法？当布局改变时更新我们所有的阴影！它可以是屏幕的旋转、动画和动态布局变化、键盘出现/消失等。</p><p id="1998" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使它正确工作，我们需要将下面的代码添加到我们所有的视图控制器中。最简单的方法是为它们创建一些公共基类:</p><pre class="kj kk kl km gt nv lx nw nx aw ny bi"><span id="1e91" class="nz mh it lx b gy oa ob l oc od"><strong class="lx iu">override</strong> <strong class="lx iu">func</strong> viewDidLayoutSubviews() {<br/>    <strong class="lx iu">super</strong>.viewDidLayoutSubviews()<br/>    view.updateShadows()<br/>}</span></pre><p id="7928" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/f34ddcc6d3846d32b014fc1d713d550d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRCIfgpZ1QKUloxuxyYrGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阴影</p></figure><p id="359e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后两点:</p><ul class=""><li id="3bf8" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">阴影与<code class="fe lu lv lw lx b">masksToBounds</code>属性不兼容。遮罩只是从视图中剪切阴影。如果您需要裁剪内容并同时添加阴影，请添加另一个视图，就像上面的截图一样。</li><li id="6e62" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">不要给背景透明或部分透明的视图添加阴影；否则，你会通过你的视角看到它。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7808" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">UITextField填料</h1><p id="9f47" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">如果加上标准样式的<code class="fe lu lv lw lx b">UITextField</code>，左右两边会有一点填充。但是我不记得有哪一个客户给我提供了一个标准外观的设计。一旦我们移除了标准边框，我们就会遇到一个问题——文本字段没有填充。带边框，阴影，圆角，还有其他效果，不好看。更有甚者，圆角可以切割一些文字。</p><p id="c0b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题可以通过改变插图来解决。我们不能用标准的方式改变它们。我们只能创建一个定制类，一个<code class="fe lu lv lw lx b">UITextField</code>的子类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d876" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个类允许你编辑左边和右边的填充。您可以添加顶部和底部填充，但通常没有必要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f785ee978625e0e176c86044c0ebd20b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCVTy5c04aUImRC5hDEhdA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UITextField(左)和TextFieldWithPadding(右)</p></figure><p id="9424" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于故事板，视图子类和扩展是有区别的。在这两种情况下，属性都会出现在“属性”检查器中(Xcode窗口右侧的面板)。但是当你子类化一个视图时，你可能会在故事板编辑器中看到结果，否则只能在应用程序运行时看到。</p><p id="2c01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，自定义视图的预览经常失败。如果你看到的是黑屏而不是你的布局，很可能就是这种情况。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2678" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">UITextView占位符</h1><p id="a321" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated"><code class="fe lu lv lw lx b">UITextField </code>有一个属性叫做<code class="fe lu lv lw lx b">Placeholder</code>。它可以在故事板中改变，只要你不打算改变它的风格，你就不需要写任何代码。与<code class="fe lu lv lw lx b">UITextView </code>的情况不同。</p><p id="f97f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，我们不能在故事板中添加带有占位符的iOS应用程序中的多行可编辑文本字段——除非我们使用自定义视图。</p><p id="da34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了给<code class="fe lu lv lw lx b">UITextView</code>添加一个占位符，我推荐你使用一个库:<a class="ae og" href="https://github.com/devxoul/UITextView-Placeholder" rel="noopener ugc nofollow" target="_blank">https://github.com/devxoul/UITextView-Placeholder</a>。</p><p id="1562" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要安装它，请将这行代码添加到您的pod中:</p><pre class="kj kk kl km gt nv lx nw nx aw ny bi"><span id="fa3d" class="nz mh it lx b gy oa ob l oc od">pod 'UITextView+Placeholder'</span></pre><p id="1344" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该库用Objective-C编写，兼容所有版本的Swift。</p><p id="ced3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它允许您添加一个简单的属性占位符。可以在故事板中添加一个简单的占位符。不要忘记运行<code class="fe lu lv lw lx b">pod install</code>或<code class="fe lu lv lw lx b">pod update</code>，然后在编辑你的故事板之前构建你的项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/bf40280e9a83b2472259d9c1c844f9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UA2jSvilxyjXyaXVFjXvVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有填充和占位符的UITextView</p></figure><p id="3272" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还没有解释如何在<code class="fe lu lv lw lx b">UITextView </code>(及其子类)中进行填充。它类似于<code class="fe lu lv lw lx b">UITextField</code>，但是您需要设置一个值，而不是覆盖一些方法，默认情况下，这个值在故事板中是不可编辑的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6ceb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">梯度</h1><p id="ffe2" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">正如我之前提到的，UIKit中的视图有一层或多层。渐变可以作为附加层来实现。</p><p id="c8d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给所有视图添加渐变没有太大意义。复杂视图中的子视图可能会有问题。让我们创建一个最简单的版本— <code class="fe lu lv lw lx b">GradientView</code>，它是<code class="fe lu lv lw lx b">UIView</code>的一个子类。然后，如果有必要，您可以尝试其他视图。</p><p id="e5a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于梯度我们需要知道的是:</p><ul class=""><li id="e395" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">颜色——至少两种不同的颜色，可能更多</li><li id="76fa" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">方向—水平、垂直或对角</li></ul><p id="0552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来实现一个只有两种颜色(开始和结束)和两个方向选项(水平和垂直)的最小实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d0c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们有了源代码，让我们给我们的项目添加一个渐变背景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/589ab0b577eb6ce3e62d41a616e34487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFb3AMrB7anOXWBwob9PnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">渐变背景</p></figure><p id="d4c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">枚举不能与故事板编辑器集成。这就是为什么我们使用整数常量:0代表水平渐变，1代表垂直渐变。</p><p id="fb37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">丑？绝对的！但是代码是有效的。希望你有比我更好的设计师:)</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="48b7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">快速创建出口和行动</h1><p id="bede" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">本节不需要任何额外的代码，只是提示如何更有效地使用Xcode。很多人都知道，但不是所有人。</p><p id="6654" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Outlets是我们在<code class="fe lu lv lw lx b">UIViewController</code>、<code class="fe lu lv lw lx b">UITableViewCell</code>、<code class="fe lu lv lw lx b">UICollectionViewCell</code>或自定义<code class="fe lu lv lw lx b">UIView </code>子类中的视图的引用。使用outlets，我们可以获取和设置视图的属性。</p><p id="9ca3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">动作是来自交互式视图的回调，例如按钮。动作允许处理按钮点击、文本编辑、更改开关和复选框的值。</p><p id="53f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们把Xcode分成两个水平面板。为此，单击故事板编辑器右上角的“+”按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ac5b5802c1279b4fff4eca6d2d5987fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arN9Ed_hk3gumGLO5FWAzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加额外的面板</p></figure><p id="45c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择与您选择的视图或视图控制器匹配的源代码文件。通常是<code class="fe lu lv lw lx b">UIViewController</code>、<code class="fe lu lv lw lx b">UITableViewCell</code>或<code class="fe lu lv lw lx b">UICollectionViewCell</code>的子类。在我们的例子中，它将是<code class="fe lu lv lw lx b">ViewController</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/5e5d7b9dba38febc7ce19750aef45a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qfBV0uXcs0oOkD4bk5aoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为右侧面板选择文件</p></figure><p id="3a31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">找到您需要的视图，按住鼠标右键(或者Ctrl+按钮，如果您的鼠标只有一个按钮)，将光标移动到源代码文件，然后释放鼠标。通常，Xcode会很好地猜测您需要什么。对于<code class="fe lu lv lw lx b">UITextField</code>，它会创造一个出口。对于<code class="fe lu lv lw lx b">UIbutton</code>，它为<code class="fe lu lv lw lx b">TouchUpInside </code>事件创建一个动作(从技术上来说是点击/轻击)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2e8dff05f5b2870291e393f168550f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gptjne0zPfyEqMiFuRa1OA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创造一个出口</p></figure><p id="45d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对Xcode的选择不满意，您可以随时在弹出式对话框中进行更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/797396f4acb039b75b2a6130330a7611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*039e7iUQSYhox9E0t3CcJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">建立一个出口</p></figure><p id="6803" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">行动也是一样。将一个按钮(或另一个交互式视图)拖到源代码中，您将得到一个操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b2f6b08a25568da312ced76115ef3164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECEbtW_F3hdlSSF8VQYuyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建操作</p></figure><p id="8e61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！您可以设置代理和数据源，并以同样的方式建立其他连接。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ae23" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f1c1" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">有了几个定制的类和扩展，故事板的编辑会容易得多。你可以通过在你的项目中添加一些<a class="ae og" href="https://cocoapods.org" rel="noopener ugc nofollow" target="_blank">豆荚</a>来获得更多。</p><p id="283a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这些技巧，开始在你的iOS项目中使用这些<a class="ae og" href="https://medium.com/better-programming/10-useful-swift-string-extensions-e4280e55a554" rel="noopener"> 10有用的Swift字符串扩展</a>。</p><p id="311e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下次见。编码快乐！</p></div></div>    
</body>
</html>