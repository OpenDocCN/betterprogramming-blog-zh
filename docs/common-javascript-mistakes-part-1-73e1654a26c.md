# 常见的 JavaScript 错误—第 1 部分

> 原文：<https://betterprogramming.pub/common-javascript-mistakes-part-1-73e1654a26c>

## 要记住的好事情

![](img/2738d2a841ff98e52e9b56b36fe46be5.png)

[傅勇华](https://unsplash.com/@hhh13?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

JavaScript 是一种比世界上许多其他编程语言更友好的语言。然而，在编写 JavaScript 代码时，由于误解或忽略我们已经知道的东西，仍然很容易犯错误。通过避免下面的一些错误，我们可以通过防止代码中的错误和错别字来使我们的生活变得更容易，这些错误和错别字会使我们陷入意想不到的结果。

# 括号不匹配

语句和函数相互嵌套意味着每个文件中有多层括号。通常情况下，应用程序非常复杂，所以级别可能会增加。这意味着，如果您使用的文本编辑器不支持语法高亮显示或者不检查不匹配的括号，那么不匹配的括号很容易出现。使用 Visual Studio Code、Atom 和 Sublime 等现代文本编辑器可以很容易地避免这种情况。如果我们想使用更简单的文本编辑器，那么就使用 linters 和代码格式化工具，比如 ESLint 和 Prettier，来检测这些问题。它们还让我们能够自动格式化代码，并检测可能出现的常见样式问题，如引用样式不一致、一行中的字符数、可以缩短的函数等。

# 引号和括号不匹配

JavaScript 允许我们对字符串使用单引号、双引号和反引号。它们是等价的。但是，我们应该以同样的性格来打开和关闭。所以如果我们用单引号开始一个字符串，然后用单引号结束一个字符串。如果我们以双引号或反勾号开始，那么分别用它们来结束字符串。此外，在某些情况下，像引号这样的特殊字符必须转义才能包含在字符串中。如果你用单引号打开一个字符串，并且你也在字符串中使用单引号，那么你必须对它进行转义以将它们包含在字符串中。这也适用于双引号和反斜线。如果你在双引号字符串中使用双引号，那么你必须对它进行转义。如果你在模板字符串中使用反勾号，那么你必须对反勾号进行转义。

在`if`语句中，圆括号总是必须包围整个条件。例如，类似于

```
if (x > y) && (y < 10) {...}
```

行不通。写这句话的正确方法是

```
if ((x > y) && (y < 10)) {...}
```

如果我们想检查两个条件是否都为真。

我们可以通过使用 JavaScript 代码感知文本编辑器(如 Visual Studio 代码)轻松避免这种情况，它会为我们突出显示这些语法错误，以便我们可以修复这些错误并使代码运行。

# 混淆=、==和===运算符

单个等号(=)运算符用于将右侧的数据赋给左侧的变量。不要将它与双等于(==)和三等于运算符(===)混淆，这两种运算符用于比较运算符左侧和右侧的值。在 JavaScript 中，我们可以在一个`if`语句中使用所有三个操作符。然而，在大多数情况下，我们并不打算在`if`语句的条件中使用单个等号运算符。我们实际上想要的是使用 double 或 triple equals 运算符来比较它左边和右边的操作数。

例如，我们不应该写

```
if (x = 1){ ... }
```

因为我们不想在`if`语句中给`x`赋值 1。相反，我们应该使用双倍或三倍等于运算符，如下面的代码所示

```
if (x == 1){ ... }
```

或者

```
if (x === 1){ ... }
```

第一个例子，`if (x = 1){ … }`，总是`true`，因为`x`是真的，因为它被赋值为 1，这是真的。我们实际上想要的是利用条件语句`if`进行比较。

# 在块级别之外使用变量

如果我们使用`var`关键字声明一个变量，它可以在`var`表达式下面的任何地方被引用。例如，假设我们有:

```
for (var j = 0; j < 10; j++) {
  j = j + 1;
}
console.log(j);
```

然后我们可以看到当我们在代码的最后一行运行`console.log`语句时`j`是 10。这就是我们用`let`和`const`关键字来声明变量和常量的原因。它们被限制了作用域，因此不能在块外引用。这意味着我们避免了使用`var`时可能出现的错误，因为变量不能在声明它的块之外被访问。因此，我们不能意外地将它赋给其他任何东西，从而导致我们的代码出现问题。我们可以像下面的例子那样使用`let`，而不是像上面的例子那样使用`var`:

```
for (let j = 0; j < 10; j++) {
  j = j + 1;
}
console.log(j);
```

当我们运行上面的代码时，我们应该得到`ReferenceError: j is not defined`，这是一个好迹象，因为我们不希望`j`在`for`循环之外被引用。如果我们删除`console.log`语句，那么它将运行。

![](img/f4603635a5de4f81f91e8bf71ede5af5.png)

席琳·艺伎回忆录·塔加米在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 将类似数组的可迭代对象视为数组

在 JavaScript 中，我们可以拥有带有数字关键字的属性。它们在被访问之前被自动转换成字符串，因为它们实际上是包含所有数字内容的字符串。像`arguments`和`NodeList`这样的对象不是数组，但是它们的属性像数组一样用整数键存储。很容易把它们误认为数组。数组和类数组对象的区别在于类数组对象不是数组，但它们都有一个以符号`Symbol.Iterator`作为标识符的函数。在这些情况下，我们可以将它们转换成数组。例如，如果我们想用`arguments`对象将参数传递给一个常规函数，我们用 spread 操作符编写如下内容:

```
function f() {
  const args = [...arguments];
  console.log(args);
}
f(1, 2, 3);
```

如果我们运行上面的代码，我们得到`[1,2,3]`。

# 混淆非数组对象和数组

因为我们可以用括号符号访问对象属性和数组条目，这在用于数组和常规对象时看起来是一样的，所以很容易混淆对象和数组。

例如，假设我们有以下代码:

```
const obj = {
  0: 1,
  1: 2,
  2: 3
};
console.log(obj[0]);
```

我们看到`console.log`语句将返回 1。上面的代码有一个常规对象，但是在`console.log`语句中，我们将 0 作为带括号符号的键传入，以获得值`obj[0]`，即 1。

如果我们有一个数组，我们试图通过它的索引来访问一个条目，如下面的代码所示:

```
const arr = [1, 2, 3];
console.log(arr[0]);
```

对于`console.log`语句，我们也得到了 1。它们都使用括号符号来访问它们的值，但它们并不相同。数组是对象，但与常规对象不同，您可以遍历它们。如果您试图用`for...of`循环或`forEach`函数循环遍历一个数组，或者尝试对其使用 spread 操作符，那么带有`obj`对象的示例将会导致错误，因为它不是一个可迭代的对象。我们可以通过添加一个带有符号`Symbol.iterator`的生成器函数来使它可迭代，如下面的代码所示:

```
const obj = {
  0: 1,
  1: 2,
  2: 3,
  [Symbol.iterator]: function*() {
    for (let prop in this) {
      yield this[prop];
    }
  }
};
```

然后，当我们像下面这样用`for...of`循环迭代`obj`对象时:

```
for (let num of obj) {
  console.log(num);
}
```

我们取回了我们使之可迭代的新的`obj`对象的条目。

扩展操作符也可以工作。如果我们有以下代码:

```
console.log([...obj]);
```

我们从`console.log`输出中得到`[1, 2, 3]`。

大多数避免错误的技巧都包含了 ES6 的特性。这是 ES6 发布的一个主要原因。生成器和`let`和`const`关键字都是规范的一部分。ES6 的使用，以及更好的文本编辑器，如 Visual Studio 代码，帮助我们避免了使用旧技术时会犯的错误。这是保持 JavaScript 代码和工具更新的一个很好的理由。ES6 是 2015 年发布的，所以没有理由留在后面。对于像 Internet Explorer 这样的老浏览器，我们可以使用类似 Babel 的东西动态地将其转换为 ES5。或者我们可以使用像 Webpack 这样的模块捆绑器，在构建工件中将 ES6 或更高版本的代码转换成 ES5，这样我们就可以用较新版本的 JavaScript 编写代码。