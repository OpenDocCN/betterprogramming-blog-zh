<html>
<head>
<title>Creating a 3D Tic-Tac-Toe in SceneKit Under SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI下的SceneKit中创建3D井字游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-3d-tic-tac-toe-in-scenekit-under-swiftui-19d08bf752bd?source=collection_archive---------14-----------------------#2022-08-03">https://betterprogramming.pub/creating-a-3d-tic-tac-toe-in-scenekit-under-swiftui-19d08bf752bd?source=collection_archive---------14-----------------------#2022-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d78" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">尝试创造经典的量子游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/845916c26c7ba5c6a510d40062e67733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qtihvyxzYbt85BomHUHNzQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">确认qubic板上的中奖线</p></figure><p id="a86b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">井字游戏可以追溯到很久以前，维基百科告诉我们棋盘出现在古埃及等地。这是一个名为<a class="ae lu" href="https://en.wikipedia.org/wiki/Parker_Brothers" rel="noopener ugc nofollow" target="_blank">帕克兄弟</a>的公司在1964年更新的一个名为Qubic的3D版本的游戏。</p><p id="f178" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在他们的游戏中，你有一个4x4x4的方块，你必须做和井字游戏一样的事情；也就是说，把你的零或者十字连成一条线。</p><p id="da43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，有了3D版本，它会更有挑战性，因为你会有更多可能的玩法。和我一起看看在SwiftUI实现中的SceneKit框架下实现它。一个小项目，具有挑战性，但很有趣。</p><h1 id="4988" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">编码</h1><p id="75cf" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">邦。我想从一个<code class="fe ms mt mu mv b">UIViewRepresentable</code>视图开始，SwiftUI和UIKit之间的媒介。基本代码模板如下所示。我没有选择SwiftUI下可用的SceneView，因为它不直接支持点击手势。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="719e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在UIKit环境中创建一个场景的视图，我可以像这样传递回一些SwiftUI代码。</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="a480" class="nc lw it mv b gy nd ne l nf ng"><strong class="mv iu">struct</strong> ContentView: <strong class="mv iu">View</strong> {<br/>  <strong class="mv iu">var</strong> scene = <strong class="mv iu">SCNScene</strong>(named: "<strong class="mv iu">SceneKitScene.scn</strong>")<br/>  <strong class="mv iu">var body: some View</strong> {<br/>  <strong class="mv iu">SceneView</strong>(<br/>    <strong class="mv iu">scene</strong>: scene!,<br/>    <strong class="mv iu">options</strong>: []<br/>  )<br/>  }<br/>}</span></pre><p id="cf10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里命名的<code class="fe ms mt mu mv b"><strong class="la iu">SceneKitScene</strong></code>无非就是一个基本的*。我在Xcode中创建的scn文件，并添加到项目中。</p><p id="2f6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在现有的<code class="fe ms mt mu mv b">sceneView</code>代码中，我添加了一个代表游戏棋盘的网格和一个手势识别器，它会在每个玩家轮流游戏时将棋子放到我的棋盘上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像这样的网格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e62698fe9443ad2fbcf532ac09e007cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JcToULezuwNU0j8HW1Jx0Q.gif"/></div></div></figure><p id="ab42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4x4x4的网格。请注意，我没有做3x3x3的3D网格，因为在3D版本中这样做会导致第一个玩家总是获胜。理论上，你当然可以创建一个更大的电路板。有了更大的格子，你可以邀请更多的玩家，都是值得思考的；未来版本。</p><h2 id="9b75" class="nc lw it bd lx nh ni dn mb nj nk dp mf lh nl nm mh ll nn no mj lp np nq ml nr bi translated">游戏部分</h2><p id="7703" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">代码中的<code class="fe ms mt mu mv b">tapGesture</code>是指一个方法<code class="fe ms mt mu mv b"><strong class="la iu">handleTap</strong></code> <strong class="la iu">。</strong>该方法的基本代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9c27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码直接来自苹果，它查看我点击了64个节点中的哪一个，并在相同的位置添加了一个立方体或一个球体，在两者之间交替。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35cd8c5a62016d9e0b32e1d6946f4619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_n9smmsD0gADW_1_eD5Ahg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在我的在线量子游戏中选择不同的节点</p></figure><p id="b394" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我没有使用十字或圆形，因为立方体和球体在3D世界中工作得更好——仅用100行代码就取得了令人印象深刻的结果。</p><h1 id="190a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">下一步</h1><p id="9ceb" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当你尝试玩的时候，游戏需要检查格子是否空闲，事实上，理想情况下，如果两个玩家中的一个得到了一条线，游戏也会停止游戏并宣布赢家，但这两个玩家都没有得到。</p><p id="d8a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我曾想用网格坐标来映射一个数据结构，但我不能，因为它们不是小数。为了尽量简单，我扩展了<code class="fe ms mt mu mv b">SCNNode</code>，这样就可以添加索引值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e352" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我可以针对我的节点向每个节点添加一个整数索引，以便在每次播放之后查找序列或获胜节点。接下来，我用这个one-liner创建了一个新结构的数组。</p><pre class="kj kk kl km gt my mv mz na aw nb bi"><span id="23a6" class="nc lw it mv b gy nd ne l nf ng">var board: [[[NewNode?]]] = .init(repeating: .init(repeating: .init(repeating: nil, count: 4), count: 4), count: 4)</span></pre><p id="79c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码添加到<code class="fe ms mt mu mv b">tapGesture</code>方法中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bdd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我添加了一些获胜行的签名和一些代码，以根据所制作的剧本来测试所述签名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2336" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一切看起来都很好；在稍作思考之前，我又添加了24个签名。</p><h1 id="0aa6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">签名</h1><p id="4001" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当我翻阅这些签名时，我逐渐意识到，在大多数情况下，它们之间的区别在于代表坐标的三个数字元组中只有一个数字。</p><p id="48a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想，只要多做一点工程，我就可以只用几个模板来构建这些签名。<br/>我使用了本文描述的联合框架订阅模式来设置一种改变节点颜色的方法，以测试我的新方法。你可以在这里看到它的行动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0378be08fa8cd2780a7572bcc14a5146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XH1RvKx5jW_zgPye57Bh_g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在量子位中测试获胜行的签名</p></figure><p id="dc66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着我继续深入研究，我发现成功的案例比我最初认为的要多得多。我查看了维基百科上关于这个主题的页面，发现应该有76行——当晚我就开始把它们全部删掉。</p><h1 id="a808" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">待续……</h1><p id="f7a7" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在此之前，我清理了代码，并开始研究构建一个能够在游戏中与你对抗的AI的可能性。</p><p id="4dc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我相信，一个主题本身也将是一篇文章——因此，我将在这里结束这篇论文。</p></div></div>    
</body>
</html>