<html>
<head>
<title>Add Firebase Authentication to a Svelte App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给一个苗条的应用添加Firebase认证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/add-firebase-authentication-to-an-svelte-app-6807f7527860?source=collection_archive---------3-----------------------#2022-12-23">https://betterprogramming.pub/add-firebase-authentication-to-an-svelte-app-6807f7527860?source=collection_archive---------3-----------------------#2022-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="283b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Firebase和Svelte实现SSR认证</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4cc7eef69732c2893048aee98dd7cf12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1c67R2OPz7MT0BoJQ7hBA.png"/></div></div></figure><p id="5d91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我开始寻找苗条，我喜欢它至今。然而，我很难做一些事情。我猜这是因为社区比React小，所以没有太多的资源涵盖一切。这是缓解这种情况的一种尝试。</p><p id="f3e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我今天想要实现的是拥有一个应用程序，它可以使用Firebase处理身份验证，并且仍然是服务器端呈现。</p><p id="944f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个小小的免责声明，我在一步一步的指南中叙述了这篇文章，但是每一步都是功能性的。这意味着我创建一个工作示例，只在客户端工作，然后修改它，直到获得SSR版本。如果你想要的是完美的版本，我建议你直接进入总结部分。</p><p id="8c6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在这里提供了一些代码片段，你可以去复制粘贴，但我也建议看看<a class="ae ln" href="https://github.com/JavoByte/svelte-examples" rel="noopener ugc nofollow" target="_blank">我的资源库</a>。特别是第一个PR ，因为它有这篇文章的所有必要代码。</p><p id="2cf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">介绍够了，让我们开始吧。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9a2f" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">将Firebase添加到我们的项目中</h1><p id="0ab6" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我会假设你已经有一个Firebase项目，你多少知道你的仪表板周围的方式。</p><p id="256a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将从单个电子邮件/密码认证开始。Firebase还通过OAuth提供与脸书和谷歌等提供商的集成，但我们不会在这里讨论这些。</p><p id="3141" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，进入Firebase中的身份验证面板，然后转到登录方法选项卡。启用电子邮件/密码登录。<em class="ms">(这也支持注册，但超出了本文的范围)</em></p><p id="9276" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在添加一个WebApp，如果你还没有的话，把firebase添加到你的项目中。这里我将使用<code class="fe mt mu mv mw b">yarn</code></p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="9761" class="nb lw iq mw b be nc nd l ne nf">yarn install firebase</span></pre><p id="7d7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Firebase还提供了一个代码片段来初始化Firebase。复制到<code class="fe mt mu mv mw b">src/lib/client/firebase.ts</code>中。</p><p id="65e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，这个文件会在导入时初始化firebase，而且这个文件也可以添加到服务器端。这是有问题的，因为这个文件只针对客户端。<code class="fe mt mu mv mw b">getAnalytics</code>举个会失败的例子。那么我们需要更多的控制。我们可以把它包装成一个函数，在命令下初始化Firebase。但是，如果实例是预先创建的，我们也想重用它。这可以通过记忆功能来解决。为此，我将使用<code class="fe mt mu mv mw b">lodash</code>。</p><p id="e3a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们同时初始化<code class="fe mt mu mv mw b">auth</code>模块。考虑到这一点，我们将如下重写初始化:</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="cbbe" class="nb lw iq mw b be nc nd l ne nf">import { memoize } from 'lodash';<br/>import { initializeApp } from 'firebase/app';<br/>import { getAnalytics } from 'firebase/analytics';<br/>import { getAuth } from 'firebase/auth';<br/><br/>// ... Firebase Config ...<br/>// Initialize Firebase<br/>export const initFirebase = memoize(() =&gt; {<br/> const app = initializeApp(firebaseConfig);<br/> const analytics = getAnalytics(app);<br/> const auth = getAuth(app);<br/> return { app, analytics, auth }<br/>})</span></pre><p id="b66f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我已经在添加<code class="fe mt mu mv mw b">auth</code>。为此，我们需要<code class="fe mt mu mv mw b">import { getAuth } from 'firebase/auth';</code></p><p id="9ee2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这个，我们现在有办法在我们的应用程序中的其他地方配置<code class="fe mt mu mv mw b">firebase</code>。现在我们只需要导入这个文件。我们将在主布局中这样做。打开(或者创建，如果还没有创建话)文件<code class="fe mt mu mv mw b">src/routes/+layout.svelte</code>并添加这个代码片段</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="2ca3" class="nb lw iq mw b be nc nd l ne nf">&lt;script&gt;<br/>  import { onMount } from 'svelte';<br/>  import { initFirebase } from '$lib/client/firebase';<br/>  <br/>  onMount(initFirebase);<br/>&lt;/script&gt;</span></pre><p id="6a65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于<code class="fe mt mu mv mw b">onMount</code>只在客户端运行，我们可以确定现在firebase只在客户端初始化。</p><p id="1edd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要存储用户的地方。让我们继续创建<code class="fe mt mu mv mw b">src/stores/auth.ts</code>文件来存储我们的用户对象。</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="d110" class="nb lw iq mw b be nc nd l ne nf">import { writable } from 'svelte/store';<br/><br/>type User = {<br/> uid: string;<br/> email: string;<br/>};<br/>export const auth = writable&lt;User | null&gt;(null);</span></pre><p id="9a05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们只需要一种在用户更新时更新商店的方法。现在很容易了，回到<code class="fe mt mu mv mw b">+layout.svelte</code>并加上这个:</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="7f7e" class="nb lw iq mw b be nc nd l ne nf">// ...<br/>import { auth as authStore } from '../stores/auth'<br/><br/>// ...<br/>onMount(() =&gt; {<br/>  const { auth } = initFirebase();<br/>  onAuthStateChanged(auth, authStore.set)<br/>}) </span></pre><p id="a6cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，每当firebase更新认证用户时，我们都会将它存储在我们的存储中。现在我们可以在任何需要的时候从那里得到它。</p><h1 id="261d" class="lv lw iq bd lx ly ng ma mb mc nh me mf jw ni jx mh jz nj ka mj kc nk kd ml mm bi translated">实现登录</h1><p id="99ae" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated"><strong class="kt ir"> <em class="ms">最终</em> </strong>件只是实际的签到和签退。让我们继续创建一个简单的登录页面。我将使用<code class="fe mt mu mv mw b">src/routes/login/+page.svelte</code>我不会详细介绍创建表单的细节，以避免这篇文章变得混乱，但是你可以随时去提供的存储库<a class="ae ln" href="https://github.com/JavoByte/svelte-examples/pull/1/files#diff-5a64e959a03d9659634f86b910a2a444e7d662b17a748f0d352d20ddd7fc6c38" rel="noopener ugc nofollow" target="_blank">全面检查</a>。我将只提到重要的部分。</p><p id="3fed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我添加了一个简单的<code class="fe mt mu mv mw b">onMount</code>函数，用于在登录成功时将用户重定向到主页。</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="0f14" class="nb lw iq mw b be nc nd l ne nf">import { goto } from "$app/navigation";<br/>import { onMount } from "svelte";<br/><br/>onMount(() =&gt; {<br/>  return auth.subscribe((user) =&gt; {<br/>    if (user) {<br/>      goto('/')<br/>    }<br/>  });<br/>});</span></pre><p id="fc86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了进行实际的登录，我使用了来自<code class="fe mt mu mv mw b">firebase/auth</code>的方法<code class="fe mt mu mv mw b">signInWithEmailAndPassword</code>，该方法接收一个<code class="fe mt mu mv mw b">auth</code>实例<em class="ms">(我们已经可以从我们的初始化器或者使用</em><code class="fe mt mu mv mw b"><em class="ms">getAuth</em></code><em class="ms">)</em><code class="fe mt mu mv mw b">email</code>和<code class="fe mt mu mv mw b">password</code>来获得它)。那些我们需要从表单中获取的。</p><p id="298d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，每当用户登录时，我们都需要更新我们的存储。为此，我将在我们的布局上使用另一个<code class="fe mt mu mv mw b">onMount</code>回调，监听auth状态。这将在授权状态改变时在我们的存储中设置用户。</p><p id="8fe8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这种方法存在一些问题。为了更好地展示它们，我在<code class="fe mt mu mv mw b">src/components</code>下创建了组件<code class="fe mt mu mv mw b">AuthStatus.svelte</code>。该组件仅显示某人是否经过身份验证。如果您签出<a class="ae ln" href="https://github.com/JavoByte/svelte-examples/pull/1/commits/4accc86786563a750741b7bba163aeef4c3a636d" rel="noopener ugc nofollow" target="_blank">这个版本</a>，您会注意到在登录后，页面的后续刷新会显示<strong class="kt ir"> <em class="ms">没有人被认证</em> </strong>一秒钟，并在几毫秒后变为<strong class="kt ir"> <em class="ms">认证为… </em> </strong>。发生这种情况是因为当我们从服务器获取页面时，我们没有获得任何授权数据。服务器不知道某人实际上已经过身份验证，因此返回页面，就像一个客人正在访问一样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7bf9a077ffb551ced6db8bc722095982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/1*Nw1pA2Hll9yztC0Hc3YxaQ.gif"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">由于缺少SSR，在显示“无人通过身份验证”图例后，立即显示“身份验证为”</p></figure><h1 id="8525" class="lv lw iq bd lx ly ng ma mb mc nh me mf jw ni jx mh jz nj ka mj kc nk kd ml mm bi translated">添加SSR成分</h1><p id="ea6f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">那么，我们如何给服务器一些我们在客户机上创建的会话的上下文呢？</p><p id="55c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">firebase用户内置了获取令牌的方法，稍后可以在服务器端进行验证。因此，我将编写一个动作，从客户端接收令牌，并要求浏览器将其存储在cookie中:</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="44f9" class="nb lw iq mw b be nc nd l ne nf">// src/routes/login/+page.server.ts<br/>export const actions: Actions = {<br/>  default: async ({ request, cookies }) =&gt; {<br/>    const formData = await request.formData();<br/>    const token = formData.get('token')?.valueOf();<br/>    if (!token || typeof token !== 'string') {<br/>      return fail(400, { message: 'Token is a required field and must be a string' });<br/>    }<br/>    cookies.set(SESSION_COOKIE_NAME, token, {<br/>      httpOnly: true,<br/>      path: '/',<br/>      secure: true<br/>    });<br/>    return { success: true };<br/>  }<br/>};</span></pre><p id="b076" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在从firebase获取用户后，我们将获取令牌并将其发送给此操作:</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="44d6" class="nb lw iq mw b be nc nd l ne nf">formData.set('token', await user.getIdToken());<br/>const response = await fetch(this.action, {<br/>  method: 'POST',<br/>  body: formData,<br/>});<br/><br/>const result = deserialize(await response.text());<br/><br/>if (result.type === 'success') {<br/>  await invalidateAll();<br/>}</span></pre><p id="099e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个片段中，我已经包含了对<code class="fe mt mu mv mw b">invalidateAll</code>的调用。这是因为，潜在地，当我们是(未)认证用户时加载的所有数据都不再有效，比如用户数据、偏好等。这一点过一会儿会变得更有用。</p><p id="2c62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，我们在服务器上接收每个请求的令牌，但是我们不验证它或对它做任何事情。因此，是时候编写一个服务器钩子，并开始在服务器端填充用户了。</p><p id="8139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在服务器端验证来自firebase的令牌，我将使用包<code class="fe mt mu mv mw b">firebase-admin</code>。安装它与</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="3d24" class="nb lw iq mw b be nc nd l ne nf">yarn add firebase-admin</span></pre><p id="fed6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要开始使用它，我们需要给服务器凭证。为此，进入您的firebase仪表板→项目设置→服务帐户选项卡。在这里，您可以选择为Firebase SDK生成一个新的私钥。</p><p id="13c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将下载一个JSON文件。保持这个JSON文件中的数据安全尤其重要，因此不建议您直接将它添加到存储库中。我不会在这里讨论如何保证它的安全，所以为了这篇文章，我将把它字符串化并保存在<code class="fe mt mu mv mw b">.env.local</code>。这个文件不是git跟踪的，这里的变量在<code class="fe mt mu mv mw b">$env/static/private</code>中自动可用</p><p id="7e22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从客户端的例子和你在firebase页面上看到的下载你的私钥，你可以想象如何在服务器上初始化firebase，所以我不会把代码放在这里。</p><p id="1ebd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了初始化，我们还需要一个函数来解码来自firebase的令牌。我们将使用带有一个小包装器的<code class="fe mt mu mv mw b">admin.auth().verifyIdToken(token)</code>来捕捉错误，并在错误发生时返回<code class="fe mt mu mv mw b">null</code>,因此如果令牌过期，体验不会受到影响。</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="7461" class="nb lw iq mw b be nc nd l ne nf">export async function decodeToken(<br/>  token: string<br/>): Promise&lt;DecodedIdToken | null&gt; {<br/>   if (!token) {<br/>     return null;<br/>   }<br/>  try {<br/>    initializeFirebase();<br/>    return await admin.auth().verifyIdToken(token);<br/>  } catch (err) {<br/>    console.error('An error occurred validating token', (err as Error).message);<br/>    return null;<br/>  }<br/>}</span></pre><p id="2eeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了这个函数，我们只需要在每次请求时从cookie中解码令牌。正如我提到的，我将使用服务器钩子。</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="421e" class="nb lw iq mw b be nc nd l ne nf">export const handle = (async ({ event, resolve }) =&gt; {<br/>  const cookies = cookie.parse(event.request.headers.get('cookie') || '');<br/>  const token = cookies[SESSION_COOKIE_NAME];<br/>  if (token) {<br/>    const decodedToken = await decodeToken(token);<br/>    if (decodedToken) {<br/>      event.locals.user = decodedToken;<br/>    }<br/>  }<br/>  return resolve(event);<br/>}) satisfies Handle;</span></pre><p id="4ea7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，我正在将<code class="fe mt mu mv mw b">user</code>添加到<code class="fe mt mu mv mw b">event.locals</code>对象中。像其他挂钩和加载器一样，本地对象是一种跨服务器端函数共享数据的方式。如果你把它复制粘贴到你的<code class="fe mt mu mv mw b">hooks.server.ts</code>文件中，你会得到一个错误，说<code class="fe mt mu mv mw b">user</code>不是<code class="fe mt mu mv mw b">Locals</code>对象的有效属性。要解决这个问题，覆盖<code class="fe mt mu mv mw b">app.d.ts</code>下的<code class="fe mt mu mv mw b">Locals</code>接口。我将按如下方式覆盖它:</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="8789" class="nb lw iq mw b be nc nd l ne nf">declare namespace App {<br/>	// interface Error {}<br/>	interface Locals {<br/>		user: null | {<br/>			uid: string;<br/>			email?: string;<br/>		};<br/>	}<br/>	// interface PageData {}<br/>	// interface Platform {}<br/>}</span></pre><h1 id="8008" class="lv lw iq bd lx ly ng ma mb mc nh me mf jw ni jx mh jz nj ka mj kc nk kd ml mm bi translated">为授权商店补水</h1><p id="cccc" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在，对服务器的每个调用都会解码令牌并设置<code class="fe mt mu mv mw b">event.locals.user</code>。最后一块是使用这个解码的用户。我将开始在主布局文件的加载器中提供它，这样每个人都可以重用它。所以，在<code class="fe mt mu mv mw b">src/routes/+layout.server.ts</code>下我们把这个:</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="8d1a" class="nb lw iq mw b be nc nd l ne nf">import type { LayoutServerLoad } from './$types';<br/>export const load = (async (event) =&gt; {<br/>  const user = event.locals.user;<br/>  return { user }<br/>}) satisfies LayoutServerLoad;</span></pre><p id="562f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，您还记得我们将用户存储在商店中吗？这个存储很奇怪，因为它只是保存一个对象，代表用户，但实际上没有逻辑，但现在，我们在页面存储中有了用户。这听起来更像是我的衍生商店。让我们像这样更新授权存储:</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="a614" class="nb lw iq mw b be nc nd l ne nf">import { page } from '$app/stores';<br/>import { derived } from 'svelte/store';<br/><br/>type User = {<br/>  uid: string;<br/>  email?: string;<br/>};<br/>export const auth = derived&lt;typeof page, User | null&gt;(<br/>  page,<br/>  ($page, set) =&gt; {<br/>    const { user } = $page.data;<br/>    if (!user) {<br/>      set(null);<br/>      return;<br/>    }<br/>    set(user);<br/>   },<br/>   null<br/>);</span></pre><p id="b015" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将自动开始使用我们存储的会话中的用户。现在，尝试刷新应用程序或查看服务器返回的普通HTML。您会注意到，现在，我们有效地实现了从服务器返回的认证数据，因此我们有了完整的SSR。</p><h1 id="af74" class="lv lw iq bd lx ly ng ma mb mc nh me mf jw ni jx mh jz nj ka mj kc nk kd ml mm bi translated">注销</h1><p id="fa65" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">不过还有一件小事。我们现在不能退出。为此，我现在将添加文件<code class="fe mt mu mv mw b">src/routes/logout/+server.ts</code>,并执行一个简单的<code class="fe mt mu mv mw b">POST</code>操作来删除cookie</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="31d9" class="nb lw iq mw b be nc nd l ne nf">import { SESSION_COOKIE_NAME } from '$lib/constants';<br/>import type { RequestHandler } from '@sveltejs/kit';<br/>import cookie from 'cookie';<br/><br/>export const POST = (async () =&gt; {<br/> return new Response('', {<br/>  headers: {<br/>   'set-cookie': cookie.serialize(SESSION_COOKIE_NAME, '', {<br/>    path: '/',<br/>    httpOnly: true,<br/>    maxAge: -1,<br/>   })<br/>  }<br/> });<br/>}) satisfies RequestHandler;</span></pre><p id="0187" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每当用户点击<em class="ms">退出</em>按钮时，我就用<code class="fe mt mu mv mw b">fetch</code>调用它</p><pre class="kg kh ki kj gt mx mw my bn mz na bi"><span id="e74f" class="nb lw iq mw b be nc nd l ne nf">const logout = async () =&gt; {<br/>  const firebaseAuth = getAuth();<br/>  await signOut(firebaseAuth);<br/>  await fetch('/logout', { method: 'POST' });<br/>  await invalidateAll();<br/>}</span></pre><p id="aa00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，调用<code class="fe mt mu mv mw b">invalidateAll</code>更有意义，因为您会注意到，调用它将重新获取用户数据，而不使用令牌。因此，所有数据将在没有会话的情况下重新加载，并相应地更新页面。</p><h1 id="b0a5" class="lv lw iq bd lx ly ng ma mb mc nh me mf jw ni jx mh jz nj ka mj kc nk kd ml mm bi translated">考虑</h1><ul class=""><li id="a246" class="nq nr iq kt b ku mn kx mo la ns le nt li nu lm nv nw nx ny bi translated">现在，登录的唯一方法是通过登录页面，输入用户的电子邮件和密码。如果您想从其他地方登录，比如navbar，和/或与第三方集成，您可能需要更新如何向服务器发送令牌的逻辑。</li><li id="7034" class="nq nr iq kt b ku nz kx oa la ob le oc li od lm nv nw nx ny bi translated">我们存储的用户直接来自服务器！现在是firebase返回的任何内容，但是如果需要，您也可以从任何需要的来源向它加载额外的数据。你在别的地方有存储的头像吗？没问题，只要把它加载到服务器钩子中，客户端就会自动得到它。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="6e70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇文章能帮助你开始使用Firebase和Svelte。我也开始使用Svelte，到目前为止，体验非常好。我将会写一些文章来分享我在Svelte和其他web应用程序开发方面的学习和知识。敬请期待！</p></div></div>    
</body>
</html>