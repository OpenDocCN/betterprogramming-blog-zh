<html>
<head>
<title>Building an Image Downloader With Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建具有多重处理的图像下载器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-an-imagedownloader-with-multiprocessing-in-python-44aee36e0424?source=collection_archive---------1-----------------------#2019-11-10">https://betterprogramming.pub/building-an-imagedownloader-with-multiprocessing-in-python-44aee36e0424?source=collection_archive---------1-----------------------#2019-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b358" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有时下载大量图像需要几个小时——让我们来解决这个问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/afec0658d37f79a95e9bd7709fe63ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4AKT8PDljHLLHaM3Ln4dw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tosshio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贾尼尔·图农</a>在<a class="ae ky" href="https://unsplash.com/s/photos/image?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我明白了——你厌倦了等待你的程序下载图像。当我不得不下载成千上万的图片时，有时要花几个小时，你不可能一直等你的程序下载完这些愚蠢的图片。你有很多重要的事情要做。</p><p id="b4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们构建一个简单的图像下载脚本，它将读取一个文本文件，并以超快的速度下载一个文件夹中列出的所有图像。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ede" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">决赛成绩</h1><p id="a7fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我们最后要建造的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/b9dc1c1ffdea6925bde4e01d6aabc4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIUlM_j5AwMPZjFoQFFFdg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/1aedfffb4e7f122b8019dbae9a736054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RU6FatFVhuD2dShGRX1Gog.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="23d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">安装依赖项</h1><p id="e860" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们安装大家最喜欢的<code class="fe nb nc nd ne b">requests</code>库。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="0117" class="nj md it ne b gy nk nl l nm nn">pip install requests</span></pre><p id="1483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将看到一些下载单个URL的基本代码，并尝试自动找到图像的名称，以及如何使用重试。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="d088" class="nj md it ne b gy nk nl l nm nn">import requests<br/><br/>res = requests.get(img_url, stream=True)<br/>count = 1<br/>while res.status_code != 200 and count &lt;= 5:<br/>    res = requests.get(img_url, stream=True)<br/>    print(f'Retry: {count} {img_url}')<br/>    count += 1</span></pre><p id="b7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们重试下载图像五次，以防失败。现在，让我们尝试自动找到图像的名称并保存它。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="5f19" class="nj md it ne b gy nk nl l nm nn"># import more required library<br/><br/>import io<br/>from PIL import Image<br/><br/># lets try to find the image name<br/>image_name = str(img_url[(img_url.rfind('/')) + 1:])<br/>if '?' in image_name:<br/>    image_name = image_name[:image_name.find('?')]</span></pre><h2 id="7fe2" class="nj md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">说明</h2><p id="86dc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们试图下载的URL是:</p><p id="d994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://instagram.fktm7-1.fna.fbcdn.net/vp/581ba4467732636cab13a38c7bd9f796/5E4C7217/t51.2885-15/sh0.08/e35/s640x640/65872070_1200425330158967_6201268309743367902_n.jpg?_nc_ht=instagram.fktm7-1.fna.fbcdn.net&amp;_nc_cat=111" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://insta gram . fktm 7-1 . FNA . FB cdn . net/VP/581 ba 4467732636 cab 13 a 38 c 7 BD 9 f 796/5e4c 7217/t 51.2885-15/sh 0.08/e35/s640x 640/65872070 _ 1200425330158967 _ 6201201266_ NC _ ht = insta gram . fktm 7-1 . FNA . FBC dn . net&amp;_ NC _ cat = 111</em></a></p><p id="17ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这真是一团糟。让我们来分解一下代码对URL做了什么。我们首先找到最后一个带<code class="fe nb nc nd ne b">rfind</code>的前斜杠(<code class="fe nb nc nd ne b">/</code>)，然后选择其后的所有内容。这是结果:</p><p id="a804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">65872070 _ 1200425330158967 _ 6201268309743367902 _ n . jpg？_ NC _ ht = insta gram . fktm 7–1 . FNA . FBC dn . net&amp;_ NC _ cat = 111</em></p><p id="9f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的第二部分找到一个<code class="fe nb nc nd ne b">?</code>，然后只取它前面的任何东西。</p><p id="2a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们最终的图像名称:</p><p id="f2dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">65872070 _ 1200425330158967 _ 6201268309743367902 _ n . jpg</em></p><p id="69e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结果非常好，并且适用于大多数用例。</p><p id="12b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经下载了我们的图像名称和图像，我们将保存它。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="fed7" class="nj md it ne b gy nk nl l nm nn">i = Image.open(io.BytesIO(res.content))<br/>i.save(image_name)</span></pre><p id="26f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在想，“我到底该怎么使用上面的代码？”那么你的想法是正确的。这是一个非常漂亮的函数，上面我们做的一切都被压扁了。这里，我们还测试了下载的类型是否是图像，以防我们找不到图像名称。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="573b" class="nj md it ne b gy nk nl l nm nn">def image_downloader(img_url: str):<br/>    """<br/>    Input:<br/>    param: img_url  str (Image url)<br/>    Tries to download the image url and use name provided in headers. Else it randomly picks a name<br/>    """<br/>    print(f'Downloading: {img_url}')<br/>    res = requests.get(img_url, stream=True)<br/>    count = 1<br/>    while res.status_code != 200 and count &lt;= 5:<br/>        res = requests.get(img_url, stream=True)<br/>        print(f'Retry: {count} {img_url}')<br/>        count += 1<br/>    # checking the type for image<br/>    if 'image' not in res.headers.get("content-type", ''):<br/>        print('ERROR: URL doesnot appear to be an image')<br/>        return False<br/>    # Trying to red image name from response headers<br/>    try:<br/>        image_name = str(img_url[(img_url.rfind('/')) + 1:])<br/>        if '?' in image_name:<br/>            image_name = image_name[:image_name.find('?')]<br/>    except:<br/>        image_name = str(random.randint(11111, 99999))+'.jpg'<br/><br/>    i = Image.open(io.BytesIO(res.content))<br/>    download_location = 'cats'<br/>    i.save(download_location + '/'+image_name)<br/>    return f'Download complete: {img_url}'</span></pre><p id="ad6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，“这家伙说的多重处理在哪里？”你可能会说。</p><p id="162f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个很简单。我们将简单地定义我们的池，并将我们的函数和图像URL传递给它。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="44f3" class="nj md it ne b gy nk nl l nm nn">results = ThreadPool(process).imap_unordered(image_downloader, images_url)<br/>for r in results:<br/>    print(r)</span></pre><p id="bd6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它放在一个函数里:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="021d" class="nj md it ne b gy nk nl l nm nn">def run_downloader(process:int, images_url:list):<br/>    """<br/>    Inputs:<br/>        process: (int) number of process to run<br/>        images_url:(list) list of images url<br/>    """<br/>    print(f'MESSAGE: Running {process} process')<br/>    results = ThreadPool(process).imap_unordered(image_downloader, images_url)<br/>    for r in results:<br/>        print(r)</span></pre><p id="3349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，你可能会说，“这些都没问题，但是我想马上开始下载我的1000张图片列表。我不想复制和粘贴所有这些代码，并试图找出如何合并一切。”</p><p id="1c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是完整的剧本。它执行以下操作:</p><ol class=""><li id="8c0d" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">将图像列表文本文件和进程号作为输入</li><li id="56de" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">按照你想要的速度下载它们</li><li id="ecfa" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">打印下载文件所花费的总时间</li><li id="5bd3" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">还有一些很好的函数可以帮助我们读取文件名，处理错误等等</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dd58" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">完整脚本</h1><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="06fa" class="nj md it ne b gy nk nl l nm nn"># -*- coding: utf-8 -*-<br/>import io<br/>import random<br/>import shutil<br/>import sys<br/>from multiprocessing.pool import ThreadPool<br/>import pathlib<br/><br/>import requests<br/>from PIL import Image<br/>import time<br/><br/><br/>start = time.time()<br/><br/><br/>def get_download_location():<br/>    try:<br/>        url_input = sys.argv[1]<br/>    except IndexError:<br/>        print('ERROR: Please provide the txt file\n$python image_downloader.py cats.txt')<br/>    name = url_input.split('.')[0]<br/>    pathlib.Path(name).mkdir(parents=True, exist_ok=True)<br/>    return name<br/><br/><br/>def get_urls():<br/>    """<br/>    Returns a list of urls by reading the txt file supplied as argument in terminal<br/>    """<br/>    try:<br/>        url_input = sys.argv[1]<br/>    except IndexError:<br/>        print('ERROR: Please provide the txt file\n Example \n\n$python image_downloader.py dogs.txt \n\n')<br/>        sys.exit()<br/>    with open(url_input, 'r') as f:<br/>        images_url = f.read().splitlines()<br/><br/>    print('{} Images detected'.format(len(images_url)))<br/>    return images_url<br/><br/><br/>def image_downloader(img_url: str):<br/>    """<br/>    Input:<br/>    param: img_url  str (Image url)<br/>    Tries to download the image url and use name provided in headers. Else it randomly picks a name<br/>    """<br/>    print(f'Downloading: {img_url}')<br/>    res = requests.get(img_url, stream=True)<br/>    count = 1<br/>    while res.status_code != 200 and count &lt;= 5:<br/>        res = requests.get(img_url, stream=True)<br/>        print(f'Retry: {count} {img_url}')<br/>        count += 1<br/>    # checking the type for image<br/>    if 'image' not in res.headers.get("content-type", ''):<br/>        print('ERROR: URL doesnot appear to be an image')<br/>        return False<br/>    # Trying to red image name from response headers<br/>    try:<br/>        image_name = str(img_url[(img_url.rfind('/')) + 1:])<br/>        if '?' in image_name:<br/>            image_name = image_name[:image_name.find('?')]<br/>    except:<br/>        image_name = str(random.randint(11111, 99999))+'.jpg'<br/><br/>    i = Image.open(io.BytesIO(res.content))<br/>    download_location = get_download_location()<br/>    i.save(download_location + '/'+image_name)<br/>    return f'Download complete: {img_url}'<br/><br/><br/>def run_downloader(process:int, images_url:list):<br/>    """<br/>    Inputs:<br/>        process: (int) number of process to run<br/>        images_url:(list) list of images url<br/>    """<br/>    print(f'MESSAGE: Running {process} process')<br/>    results = ThreadPool(process).imap_unordered(image_downloader, images_url)<br/>    for r in results:<br/>        print(r)<br/><br/><br/>try:<br/>    num_process = int(sys.argv[2])<br/>except:<br/>    num_process = 10<br/><br/>images_url = get_urls()<br/>run_downloader(num_process, images_url)<br/><br/><br/>end = time.time()<br/>print('Time taken to download {}'.format(len(get_urls())))<br/>print(end - start)</span></pre><p id="9cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将它保存到一个Python文件中，然后让我们运行它。</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="aafc" class="nj md it ne b gy nk nl l nm nn">python3 image_downloader.py cats.txt</span></pre><p id="a6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个到<a class="ae ky" href="https://github.com/nOOBIE-nOOBIE/image_downloader_multiprocessing_python" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>的链接。</p><h2 id="7d9f" class="nj md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">使用</h2><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="228f" class="nj md it ne b gy nk nl l nm nn">python3 image_downloader.py &lt;filename_with_urls_seperated_by_newline.txt&gt; &lt;num_of_process&gt;</span></pre><p id="0807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将读取文本文件中的所有URL，并将它们下载到与文件名同名的文件夹中。</p><p id="f416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">num_of_process</code>是可选的(默认使用10个进程)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0a92" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">例子</h1><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="556e" class="nj md it ne b gy nk nl l nm nn">python3 image_downloader.py cats.txt</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/b9dc1c1ffdea6925bde4e01d6aabc4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIUlM_j5AwMPZjFoQFFFdg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/1aedfffb4e7f122b8019dbae9a736054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RU6FatFVhuD2dShGRX1Gog.png"/></div></div></figure><p id="9358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢任何关于如何进一步改善的回应。</p><p id="6e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>