<html>
<head>
<title>What Does the “Yield” Keyword Do?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“Yield”关键字有什么作用？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-does-the-yield-keyword-do-6b9304149462?source=collection_archive---------4-----------------------#2019-11-05">https://betterprogramming.pub/what-does-the-yield-keyword-do-6b9304149462?source=collection_archive---------4-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7cc2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中的可迭代对象、函数和生成器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80b729672eb512aad43f97c5dd517196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk7-mzOVqXd1s-6CrqVHEw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/photos/H9-EYONVLaY" rel="noopener ugc nofollow" target="_blank"> C在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上烘干</a></p></figure><p id="0120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解关键字<code class="fe lv lw lx ly b">yield</code>，您必须首先熟悉各种其他术语和概念。在我们深入研究所有这些之前，让我们牢记最终目的，并通过<em class="lz">讨论为什么</em> <code class="fe lv lw lx ly b">yield</code>是有益的。</p><p id="86c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">yield</code>将提高内存效率——从而提高速度/性能——当循环遍历一个大的可迭代对象时。对于小型数据集，这些好处不太明显；然而，随着数据的增长，使用<code class="fe lv lw lx ly b">yield</code>的好处也在增加。</p><p id="8831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们来解释一下。简而言之，<code class="fe lv lw lx ly b">yield</code>是对<em class="lz"> return </em>关键字的替换，该关键字从一个函数产生一个<em class="lz">生成器</em>，该生成器用作一次性可迭代函数。如果你和我一样，当我第一次学习这个的时候，你会迷失方向。因此，要解开这个概念，让我们从基础开始，一步步向上。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d663" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">什么是可迭代的？</h1><p id="2ab5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有点开玩笑，但iterable是一种可以迭代的数据类型。澄清一下，它是一种数据类型，其中各个元素是可理解的数据——字符串的各个字符、字典中的术语、列表或元组中的项目等。从功能上讲，如果数据在以下代码片段中有效，则它是可迭代的:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e489" class="ni mi it ly b gy nj nk l nl nm">for x in my_iterable:<br/>   pass</span></pre><p id="20eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，虽然一次只能访问一个元素，但整个iterable仍然存储在内存中。这意味着如果你在一个从0到5，000，000，000的范围内迭代，那么每一个值都会占用资源。即使作为程序员，您在循环中高效地编写了一组重复的命令，应用程序仍然需要存储正在迭代的内容。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0d2a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">什么是函数？</h1><p id="4aec" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">函数是构成定义的一组命令，除非被调用，否则不会被执行。这意味着，即使你的函数的进程占用了大量的内存和资源，那也只会发生在函数被调用的时候。函数的定义本身什么也不做。</p><p id="a387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把一个函数想象成一个黑盒是很有帮助的，它接受输入(参数)并产生预期的输出(返回值)。因此，一个函数很像一个公式或方程式，除了它超越了算术。</p><p id="c480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将函数描述为黑盒，因为函数内部发生的事情对用户来说真的不重要——您只需要知道向函数提供什么是必需的，以及期望输出什么。除了参数之外，该函数不能访问任何其他内容。类似地，除了返回值之外，函数内部的任何东西都不能在函数外部访问。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e261" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">什么是发电机？</h1><p id="3b8f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">生成器是一次性使用的可迭代类型。设计意图是iterable中的元素一旦被消费就不再需要了。因此，生成器不是创建和存储整个iterable，而是一次生成一个元素。这可以节省资源并提高性能。要了解这一点，让我们将列表与生成器进行比较:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="315a" class="ni mi it ly b gy nj nk l nl nm">my_list = [n for n in range(10)]<br/>print(my_list)<br/># [0,1,2,3,4,5,6,7,8,9]</span><span id="a351" class="ni mi it ly b gy nn nk l nl nm">my_generator = (n for n in range(10))<br/>print(my_generator)<br/># &lt;generator object &lt;genexpr&gt; at 0x10daaa480&gt;</span></pre><p id="aae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，语法上的区别是列表理解是用方括号<code class="fe lv lw lx ly b">[]</code>完成的，而生成器理解是用括号<code class="fe lv lw lx ly b">()</code>完成的。注意，当一个生成器指向一个生成器对象时，这个列表就被存储起来并可以随时打印。</p><p id="c929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们看起来不同，但是在一个循环中工作时，它们的行为是相似的。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="dcb5" class="ni mi it ly b gy nj nk l nl nm">for element in my_list:<br/>   print(element)<br/>   """<br/>   0<br/>   1<br/>   2<br/>   3<br/>   ... etc.<br/>   """</span><span id="bed7" class="ni mi it ly b gy nn nk l nl nm">for element in my_generator:<br/>   print(element)<br/>   """<br/>   0<br/>   1<br/>   2<br/>   3<br/>   ... etc.<br/>   """</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="338c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">“Yield”关键字有什么作用？</h1><p id="2320" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最后，解释我们最初的问题。关键字<code class="fe lv lw lx ly b">yield</code>将代替函数定义中的<code class="fe lv lw lx ly b">return</code>来创建一个生成器。然后，可以将它用作普通的可迭代对象，获得生成器和函数的好处。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="4991" class="ni mi it ly b gy nj nk l nl nm">def createGenerator():<br/>   for i in range(100):<br/>   yield i</span><span id="67e2" class="ni mi it ly b gy nn nk l nl nm">my_generator = createGenerator()<br/>print(my_generator)<br/># &lt;generator object createGenerator at 0x102dd2480&gt;</span><span id="2190" class="ni mi it ly b gy nn nk l nl nm">for i in my_generator:<br/>   print(i) # prints 0-99</span></pre><p id="de40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这是如何工作的呢？当返回的生成器第一次被使用时——不是在赋值语句中，而是在<code class="fe lv lw lx ly b">for</code>循环中——函数定义将一直执行到到达<code class="fe lv lw lx ly b">yield</code>语句。在那里，它会暂停(看看为什么叫yield)直到再次被使用。然后，它会从停止的地方继续。在生成器的最后一次迭代中，<code class="fe lv lw lx ly b">yield</code>命令之后的任何代码都将执行。</p><p id="bc59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加一些打印代码来查看事件的顺序:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="bcc8" class="ni mi it ly b gy nj nk l nl nm">def createGenerator():<br/>   print("Beginning of generator")<br/>   for i in range(3):<br/>      yield i<br/>   print("After yield")</span><span id="9527" class="ni mi it ly b gy nn nk l nl nm">print("Before assignment")<br/>my_generator = createGenerator()<br/>print("After assignment")</span><span id="57aa" class="ni mi it ly b gy nn nk l nl nm">for i in my_generator:<br/>   print(i) # prints 0-99</span><span id="6c43" class="ni mi it ly b gy nn nk l nl nm">"""<br/>Before assignment<br/>After assignment<br/>Beginning of generator<br/>0<br/>1<br/>2<br/>After yield<br/>"""</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="a724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，<code class="fe lv lw lx ly b">yield</code>关键字修改一个函数的行为来产生一个生成器，它在迭代过程中的每个<code class="fe lv lw lx ly b">yield</code>命令处暂停。除了迭代之外，该函数不会被执行，这导致了改进的资源管理，并因此带来了更好的整体性能。使用生成器(和生成的函数)来创建用于一次性迭代的大型数据集。</p></div></div>    
</body>
</html>