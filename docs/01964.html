<html>
<head>
<title>How to work with HTTP Interceptors in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中使用HTTP拦截器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-work-with-http-interceptors-in-angular-65c026fff46b?source=collection_archive---------5-----------------------#2019-10-27">https://betterprogramming.pub/how-to-work-with-http-interceptors-in-angular-65c026fff46b?source=collection_archive---------5-----------------------#2019-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb0f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么，为什么你应该使用它们？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dadd92d7b36594ccaa8d5762adbc3ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILIaNMxummSwFPiYj4-PsQ.png"/></div></div></figure><p id="30a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我从事Angular已经有一段时间了，几乎开发过它的每个版本。令人惊讶的是每个版本都有新功能。引起我注意的一个特征是<code class="fe lq lr ls lt b">HttpInterceptor</code> <strong class="kw iu">。</strong>它最初是在Angular 4.3中引入的，非常有用。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a498" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">拦截器简介</h1><p id="9af3" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">拦截器提供了一种拦截传出请求或传入响应的方法。除了前端之外，它们非常类似于中间件，具有类似Express的框架。拦截器对于缓存和日志记录等功能非常有用。</p><blockquote class="my mz na"><p id="4550" class="ku kv nb kw b kx ky ju kz la lb jx lc nc le lf lg nd li lj lk ne lm ln lo lp im bi translated">HttpInterceptor <strong class="kw iu"> </strong>提供了一种方法来拦截HTTP请求和响应，以便在传递它们之前对它们进行转换或处理。</p></blockquote></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d2db" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">基本实现</h1><p id="d0c0" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">创建拦截器非常简单。您必须创建一个<code class="fe lq lr ls lt b">@injectable</code> <strong class="kw iu"> </strong>的类，并实现<code class="fe lq lr ls lt b">HttpInterceptor</code>:</p><pre class="kj kk kl km gt nf lt ng nh aw ni bi"><span id="bc1c" class="nj mc it lt b gy nk nl l nm nn">@Injectable()<br/>export class ApiInterceptor implements HttpInterceptor {  </span><span id="e656" class="nj mc it lt b gy no nl l nm nn">constructor() {}</span><span id="3713" class="nj mc it lt b gy no nl l nm nn">intercept(req: HttpRequest&lt;<strong class="lt iu">any</strong>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<strong class="lt iu">any</strong>&gt;&gt; {<br/>    <strong class="lt iu">const </strong>authReq = req.clone({<br/>        //add original request and/or set/add new headers <br/>    });<br/>});<br/>  <strong class="lt iu">return </strong>next.handle(authReq);<br/> }<br/>}</span></pre><p id="0931" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将<code class="fe lq lr ls lt b">req</code> <strong class="kw iu"> </strong>和<code class="fe lq lr ls lt b">next</code> <strong class="kw iu"> </strong>作为参数，并将<code class="fe lq lr ls lt b">HttpEvent</code> <strong class="kw iu"> </strong>作为可观测值返回。</p><p id="acb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后你需要在<code class="fe lq lr ls lt b">AppModule</code> <strong class="kw iu"> </strong>中这样提供它:</p><pre class="kj kk kl km gt nf lt ng nh aw ni bi"><span id="2c4b" class="nj mc it lt b gy nk nl l nm nn">@NgModule({<br/>  bootstrap: [AppComponent],<br/>  imports: [...],<br/>  providers: [<br/>    {<br/>      provide: HTTP_INTERCEPTORS,<br/>      useClass: ApiInterceptor,<br/>      multi: true<br/>    }<br/>  ]<br/>})<br/>export class AppModule {}</span></pre><p id="6997" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常简单的<code class="fe lq lr ls lt b">HttpInterceptor</code>的基本实现。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4bb7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么应该使用HttpInterceptors？</h1><p id="f04f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><code class="fe lq lr ls lt b">HttpInterceptors</code>可以执行各种任务，从认证到日志记录、设置或添加头、HTTP请求和响应、通知、错误处理，以及在每个HTTP请求上显示加载器。如果没有拦截器，开发人员将不得不为每个HTTP客户端调用手动添加这些任务。</p><h2 id="73a2" class="nj mc it bd md np nq dn mh nr ns dp ml ld nt nu mn lh nv nw mp ll nx ny mr nz bi translated">1.设置标题</h2><p id="6521" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们可以很容易地添加<strong class="kw iu">授权</strong>头，这样我们就不必在每个请求中分别添加它们:</p><pre class="kj kk kl km gt nf lt ng nh aw ni bi"><span id="0e5b" class="nj mc it lt b gy nk nl l nm nn">const addHeaders= req.clone({ <br/>   headers: req.headers<br/>     .set('Authorization', `Bearer $token`)<br/>     .set('Content-Type', 'application/json')<br/>});<br/>return next.handle(addHeaders);</span></pre><p id="d1a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，在拦截器中操作头很简单。</p><h2 id="57af" class="nj mc it bd md np nq dn mh nr ns dp ml ld nt nu mn lh nv nw mp ll nx ny mr nz bi translated">2.显示加载程序</h2><p id="afd5" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们可以在拦截器中为每个请求添加一个加载器。为此，我们添加了一个具有显示和隐藏加载器方法的加载器服务。然后，我们可以显示每个请求的加载程序，并在请求完成时隐藏它:</p><pre class="kj kk kl km gt nf lt ng nh aw ni bi"><span id="69ca" class="nj mc it lt b gy nk nl l nm nn">const loaderService = this.injector.get(LoaderService);<br/><br/>loaderService.show();<br/><br/>return next.handle(req).pipe(<br/>  delay(5000),<br/>  finalize(() =&gt; loaderService.hide())<br/>);</span></pre><p id="03a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个更好的解决方案——我们不必为每个API请求调用加载器服务。</p><h2 id="fdb5" class="nj mc it bd md np nq dn mh nr ns dp ml ld nt nu mn lh nv nw mp ll nx ny mr nz bi translated"><strong class="ak"> 3。通知</strong></h2><p id="58bb" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们可以在每次响应状态为200或201时显示一个通知，这表示成功。</p><p id="ade1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个对象创建的示例:</p><pre class="kj kk kl km gt nf lt ng nh aw ni bi"><span id="af3e" class="nj mc it lt b gy nk nl l nm nn">return next.handle(req).pipe(<br/>  tap((event: HttpEvent&lt;any&gt;) =&gt; {<br/>    if (event instanceof HttpResponse &amp;&amp; event.status === 201) {<br/>      this.toastr.success("Object created.");<br/>    }<br/>  })<br/>);</span></pre><p id="7c2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每当响应状态为201时，这将显示成功烤面包机。这非常有用，因为您不必在每个API请求中显式添加toaster。</p><h2 id="417d" class="nj mc it bd md np nq dn mh nr ns dp ml ld nt nu mn lh nv nw mp ll nx ny mr nz bi translated"><strong class="ak"> 4。错误处理</strong></h2><p id="a0be" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">有多种情况会导致拦截器出错。对于http请求，我们可以在管道函数(它结合了多个函数)中使用retry操作符。</p><p id="ad25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用来自<code class="fe lq lr ls lt b"><strong class="kw iu">RxJS </strong></code>的<code class="fe lq lr ls lt b">Retry</code>来重新订阅可观察值，作为回报，我们得到一个成功的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5448" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以检查错误的状态，并在此基础上决定如何处理它。</p><p id="5554" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，我们在检查异常状态之前使用了<code class="fe lq lr ls lt b">retry</code>操作符。如果状态不是401，那么我们将抛出一个烤面包机错误。这就是我们在拦截器中处理错误的方式。</p><p id="cf57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了<code class="fe lq lr ls lt b">HttpInterceptors</code> <strong class="kw iu">，</strong>我们还可以做其他事情，比如分析、URL操作等等。</p><p id="9cd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">差不多就是这样。</p><p id="5629" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读。希望有帮助！</p></div></div>    
</body>
</html>