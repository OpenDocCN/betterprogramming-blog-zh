# 在 JavaScript 中使用析构赋值语法

> 原文：<https://betterprogramming.pub/using-the-destructuring-assignment-syntax-in-javascript-8ca8af6a0397>

## 清理代码库的语法糖

![](img/d7d023e859c1d6c3cc42f756b6542848.png)

由 [Tracy Adams](https://unsplash.com/@tracycodes?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

析构赋值语法是 2015 版 JavaScript 中引入的 JavaScript 语法功能，它允许我们将数组的值列表或对象的键值对解包到单个变量中。

这对于从数组或对象中检索条目并将它们设置为单个变量的值非常方便。这非常方便，因为另一种方法是从索引中获取一个数组条目，然后将它们设置为数组的变量值。

对于对象，我们从键中获取值，并将它们设置为变量值。

# 数组析构

我们可以在代码中轻松使用析构赋值语法。对于数组，我们可以写:

```
const [a,b] = [1,2];
```

然后，我们得到 1 作为`a`的值，2 作为`b`的值，因为析构语法将数组的条目解包到单独的变量中。

请注意，数组中项的数量不一定等于变量的数量。例如，我们可以写:

```
const [a,b] = [1,2,3]
```

那么`a`仍然是 1，`b`仍然是 2，因为语法只设置了变量，这些变量按照数组中数字出现的顺序排列。因此，1 被设置为`a`，2 被设置为`b`，3 被忽略。

我们还可以使用 rest 操作符来获取没有被设置为变量的剩余变量。例如，我们可以有:

```
const [a,b,...rest] = [1,2,3,4,5,6]
```

那么，`rest`将是`[3,4,5,6]`，而我们将`a`设置为 1，将`b`设置为 2。这让我们可以将剩余的数组条目放入一个变量中，而不用将它们都设置为自己的变量。

我们也可以对对象使用析构赋值语法。例如，我们可以写:

```
const {a,b} = {a:1, b:2};
```

在上面的代码中，`a`被设置为 1，`b`被设置为 2，因为在给变量赋值时，键与变量的名称相匹配。

因为我们将`a`作为键，1 作为相应的值，所以当键名与变量名匹配时，变量`a`被设置为 1。`b`也是如此。我们有一个名为`b`的值为 2 的键，因为我们有一个名为`b`的变量，我们可以将`b`设置为 2。

我们可以在用析构赋值语法给变量赋值之前声明变量。例如，我们可以写:

```
let a, b;
([a, b] = [1, 2]);
```

然后，我们将`a`设置为 1，将`b`设置为 2，因为声明的`a`和`b`与被赋值的相同。

只要变量名相同，JavaScript 解释器就足够聪明来完成赋值，不管它们是否事先声明。

我们需要行上的括号，这样赋值将被解释为一行，而不是中间有等号的单个块，因为同一行上的两个块不是有效的语法。

只有当变量声明发生在析构赋值之前时，才需要这样做。

我们也可以为析构赋值设置默认值。例如:

```
let a,b;
([a=1,b=2] = [0])
```

这是有效的语法。在上面的代码中，我们得到`a`是 0，因为我们给它赋值了 0。`b`是 2，因为我们没有给它赋值。

析构赋值语法也可以用于交换变量，所以我们可以写:

```
let a = 1;
let b = 2;
([a,b] = [b,a])
```

在上述代码的最后一行之后，`b`将变为 1，`a`将变为 2。我们不再需要给临时变量赋值来交换它们，也不需要通过加减来给变量赋值。

析构赋值语法也适用于将函数的返回值赋给变量。

所以，如果一个函数返回一个数组或对象，我们可以用析构赋值语法把它们赋给变量。例如，如果我们有:

```
const fn = () =>[1,2]
```

我们可以写:

```
const [a,b] = fn();
```

使用析构语法将 1 作为`a`获取，将 2 作为`b`获取，因为使用该语法将返回的数组赋给了变量。

同样，对于对象，我们可以写:

```
const fn = () => {a:1, b:2}
const {a,b} = fn();
```

我们可以通过跳过析构赋值中间的变量名来忽略中间的变量。例如，我们可以写:

```
const fn = () => [1,2,3];
let [a,,b] = fn();
```

我们得到值为 1 的`a`和值为 3 的`b`，跳过中间值。

重要的是要知道，如果我们使用带有析构赋值语法的 rest 操作符，我们不能在左边有尾随逗号，因此:

```
let [a, ...b,] = [1, 2, 3];
```

会产生一个`SyntaxError`。

# 对象析构

我们也可以对对象使用析构赋值语法。例如，我们可以写:

```
const {a,b} = {a:1, b:2};
```

在上面的代码中，`a`被设置为 1，`b`被设置为 2，因为在给变量赋值时，键与变量的名称相匹配。

因为我们有`a`作为键，1 作为相应的值，变量`a`被设置为 1，因为键名与变量名匹配。`b`也是一样。我们有一个名为`b`的值为 2 的键，因为我们有一个名为`b`的变量，我们可以将`b`设置为 2。

我们还可以将它分配给不同的变量名，这样我们就不必将键值条目设置为不同的变量名。我们只需在左侧对象的值部分添加我们想要的变量的名称，这就是我们想要为其赋值的变量，如下所示:

```
const {a: foo, b: bar} = {a:1, b:2};
```

在上面的代码中，我们将键`a`的值赋给了`foo`，将键`b`的值赋给了变量`bar`。我们仍然需要`a`和`b`作为左边的键，这样它们就可以与右边的相同键名相匹配，用于析构赋值。

然而，`a`和`b`实际上并没有被定义为变量。它只是用来匹配右边的键-值对，以便它们可以被设置为变量`foo`和`bar`。

对象的析构赋值也可以有默认值。例如，我们可以写:

```
let {a = 1, b = 2} = {a: 3};
```

然后，我们将`a`设置为 3，将`b`设置为 2，这是默认值，因为我们没有一个右侧带有名为`b`的键的键-值对。

如果我们使用析构语法将值赋给与原始对象的键不同名称的变量，也可以提供默认值。所以，我们可以写:

```
const {a: foo=3, b: bar=4} = {a:1};
```

在这种情况下，`foo`将会是 1，`bar`将会是 4，因为我们为左边的条指定了默认值，但是用析构赋值将`foo`指定为 1。

析构赋值也适用于嵌套对象。例如，如果我们有以下对象:

```
let user = {
  id: 42,
  userName: 'dsmith',
  name: {
    firstName: 'Dave',
    lastName: 'Smith'
  }
};
```

我们可以写:

```
let {userName, name: { firstName }} = user;
```

将`displayName`设置为`'dsmith'`，将`firstName`设置为`'Dave'`。对整个对象进行查找，因此，如果左对象的结构与右对象的结构相同，并且键存在，那么析构赋值语法将起作用。

我们还可以使用语法将值解包到单个变量中，同时将对象作为参数传入。

为了做到这一点，我们把我们想要赋值的东西，也就是析构赋值表达式左边的东西，作为函数的参数。

所以，如果我们想把`user`作为变量分解成它的各个部分，我们可以写一个像下面这样的函数:

```
const who = ({userName, name: { firstName }}) => `${userName}'s first name is ${firstName};who(user)
```

因此，我们得到了`userName`和`firstName`，它们将被分别设置为`'dsmith'`和`'Dave'`，因为我们将析构赋值语法应用于`who`函数的参数，该函数是我们之前定义的`user`对象。

同样，我们可以像在参数中析构一样设置默认参数，就像我们对正则赋值表达式所做的那样。所以，我们可以写:

```
const who = ({userName = 'djones', name: { firstName }}) => `${userName}'s first name is ${firstName}`
```

如果我们将`user`设置为:

```
let user = {
  id: 42,
  name: {
    firstName: 'Dave',
    lastName: 'Smith'
  }
};
```

然后当我们调用`who(user)`时，我们得到`'djones's first name is Dave'`，因为我们将`'djones'`设置为`userName`的默认值。

当我们遍历可迭代对象时，我们可以使用析构赋值语法。例如，我们可以写:

```
const people = [{
    firstName: 'Dave',
    lastName: 'Smith'
  },
  {
    firstName: 'Jane',
    lastName: 'Smith'
  },
  {
    firstName: 'Don',
    lastName: 'Smith'
  },
]for (let {
    firstName,
    lastName
  } of people) {
  console.log(firstName, lastName);
}
```

我们得到:

```
Dave Smith
Jane Smith
Don Smith
```

记录，因为析构语法在`for...of`循环中起作用，因为`let`之后的变量是数组的入口。

计算对象属性也可以在析构赋值表达式的左侧。所以，我们可以有这样的东西:

```
let key = 'a';
let {[key]: bar} = {a: 1};
```

这会将`bar`设置为 1，因为`[key]`被设置为`a`，然后 JavaScript 解释器可以匹配两边的键，并对变量`bar`进行析构赋值。

这也意味着左侧的键不必是有效的属性或变量名。但是，左侧冒号后的变量名必须是有效的属性或变量名。

例如，我们可以写:

```
const obj = { 'abc 123': 1};
const { 'abc 123': abc123 } = obj;

console.log(abc123); // 1
```

只要两边的键名相同，我们就可以用字符串中的任意一个键对变量进行析构赋值。

另一件要注意的事情是，析构赋值足够聪明，可以在原型链的同一层上查找键，所以如果我们有:

```
var obj = {a: 1};
obj.__proto__.b = 2;
const {a, b} = obj;
```

当 JavaScript 解释器在原型继承链中寻找`b`并设置键`b`给出的值时，我们仍然将`a`设置为 1，将`b`设置为 2。

正如我们所见，析构赋值是一个非常强大的语法。编写代码将数组条目赋给变量或将对象值赋给它们自己的变量可以节省大量时间。

它还让我们不用临时变量就能交换变量，使代码更简单，更容易理解。它还通过继承工作，因此属性不必在对象本身中，即使属性在它的原型中也可以工作。

```
const fn = () => {a:1, b:2}
const {a,b} = fn();
```