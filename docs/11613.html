<html>
<head>
<title>HTTP/2 and GRPC: The De Facto Standard for Microservices Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP/2和GRPC:微服务通信的事实标准</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/http-2-and-grpc-the-de-facto-for-microservices-communication-84a6bb2a6126?source=collection_archive---------2-----------------------#2022-04-04">https://betterprogramming.pub/http-2-and-grpc-the-de-facto-for-microservices-communication-84a6bb2a6126?source=collection_archive---------2-----------------------#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="362a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">HTTP/2和gRPC允许微服务之间更快、更简单、更健壮的通信。但是你有没有想过为什么我们使用这个技术栈，为什么他们发明了HTTP/2和gRPC？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68ff3241a6c5284603cc695a5844e7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wj7e3HQFjewX8OPn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b7f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，让我们看看HTTP/2与HTTP/1.x的主要区别是什么，它解决了哪些问题，以及gRPC如何在幕后利用HTTP/2，并利用HTTP/2的所有效率。</p><h1 id="ced4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于HTTP协议的背景</h1><p id="7399" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">应用层是开放系统互连(OSI)模型的最高层，即第7层。应用层有许多网络协议，HTTP是其中之一。</p><h2 id="2c96" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">HTTP/1.1</h2><p id="f5bc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">HTTP/1.1于1989年开发，作为万维网的通信标准。HTTP使用类似于<code class="fe ne nf ng nh b">GET</code> <code class="fe ne nf ng nh b">POST</code>或<code class="fe ne nf ng nh b">DELETE</code>的方法来指定客户端想要对资源执行的操作。</p><p id="7cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您正在<code class="fe ne nf ng nh b"><a class="ae ky" href="http://www.example.com." rel="noopener ugc nofollow" target="_blank">www.example.com</a></code> <a class="ae ky" href="http://www.example.com." rel="noopener ugc nofollow" target="_blank">访问一个网站。</a>当您导航到此URL时，网络浏览器会以文本消息的形式发送一个HTTP请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/67a961628a2a37c207fdc8b45ab4df62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFAYfSCnXU93FHgsKnXc5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HTTP/1中的原始请求头</p></figure><p id="538c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为对该请求的响应，web服务器向发出请求的客户机返回一个HTML页面，以及HTML中调用的任何图像、样式表或其他资源。请注意，在第一次调用数据时，并不是所有的资源都返回给客户端。请求和响应将在服务器和客户机之间来回传递，直到web浏览器接收到在屏幕上显示HTML页面内容所需的所有资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/a33761b0636c16781102219f9f515f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBMLgtHWIwkspX8I2Gv1Ng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HTTP/1中的原始响应头</p></figure><h2 id="dffb" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">HTTP/2</h2><p id="e701" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">HTTP/2发布于2015年5月。从技术角度来看，区分HTTP/1.1和HTTP/2的最重要的特性之一是二进制帧层。与将所有请求和响应保持为纯文本格式的HTTP/1.1相反，HTTP/2使用二进制帧层以二进制格式封装所有消息，同时仍然保持HTTP语义，如动词、方法和头。应用程序级API仍然会创建传统HTTP格式的消息，但是底层会将这些消息转换成二进制格式。这确保了在HTTP/2之前创建的web应用程序在与新协议交互时可以继续正常运行。</p><p id="b5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，HTTP/1.1和HTTP/2共享语义，使用类似于<code class="fe ne nf ng nh b">GET</code>和<code class="fe ne nf ng nh b">POST</code>的熟悉方法，确保在这两种协议中的服务器和客户机之间传输的请求和响应以传统格式的消息(带有消息头和消息体)的形式到达目的地。在下一节中，让我们看看HTTP/1.1如何试图通过其交付模型来优化效率，以及由此产生的问题，随后是HTTP/2的二进制帧层的优点，以及它如何对请求进行优先级排序的描述。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/ec26a29b14ddfc755bf4d8466af8ba26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-csMV_4JvOfuELhTUpZrMw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">h2 = HTTP/2</p></figure><h1 id="60ee" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">HTTP/1.1问题</h1><h2 id="0944" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">流水线和行首阻塞</h2><p id="8f00" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">客户端收到的对HTTP <code class="fe ne nf ng nh b">GET</code>请求的第一个响应通常不是完整呈现的页面。相反，它包含所请求页面所需的附加资源的链接。客户端发现，只有在下载页面之后，页面的完整呈现才需要服务器提供这些额外的资源。因此，客户端将不得不发出额外的请求来检索这些资源。在HTTP/1.0中，对于每个新的请求，客户机必须中断并重建TCP连接，这在时间和资源上都是一件昂贵的事情。</p><p id="1e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTTP/1.1通过引入持久连接和管道来解决这个问题。对于持久连接，HTTP/1.1假设TCP连接应该保持打开，除非直接被告知关闭，这大大提高了重新建立TCP连接的成本。通过管道，客户机可以沿着同一连接一个接一个地发送请求，而不必等待每个请求的响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a9f847fdba751c7219a57d55a5d62cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oVfhJubPdrD6BwaP.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HTTP管道——图片来自<a class="ae ky" href="https://www.haproxy.com/blog/http-keep-alive-pipelining-multiplexing-and-connection-pooling/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a></p></figure><p id="b14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，服务器仍然需要按照传入请求的顺序发送响应。所以HTTP/1.1仍然是一个先进先出队列<strong class="lb iu">并且存在这样的情况，即在队列最前面的一个请求不能获得它所需要的资源，它将阻塞它后面的所有请求。这就是所谓的<em class="nl">线头(HOL) </em>阻塞。添加单独的并行TCP连接可能有助于解决这个问题，但是客户端和服务器之间的并发TCP连接数量是有限的，每个新连接都需要大量资源，这与HTTP/1.0存在相同的问题。</strong></p><p id="9444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTTP/2就是为了解决这些问题而产生的。让我们看看如何使用二进制帧层可以解决这些问题。</p><h1 id="eb33" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">HTTP/2和HTTP/1.x之间的主要区别</h1><h2 id="75df" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">二进制帧层</h2><p id="8340" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在一个HTTP/2连接中，有多个数据流。每个流由多条消息组成，这些消息采用熟悉的请求/响应格式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/03ee60759ca0581740cb98b7d8e74e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHf950UekUcuG7RYXLeMIQ.png"/></div></div></figure><p id="8292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些消息中的每一条都被分割成更小的单元，称为帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/85162fa5584ab52c81de8eb6eed987bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Eod99cSIN_525khP.png"/></div></div></figure><p id="a1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最细的层次上，通信信道由一组二进制编码的帧组成，每个帧都标记有一个特定的流。识别标记允许连接在传输过程中交错这些帧，并在另一端重新组合它们。交错的请求和响应可以并行运行，而不会阻塞它们后面的消息，这个过程称为<em class="nl">多路复用</em>。多路复用解决了HTTP/1.1中的行首阻塞问题，它确保没有消息必须等待另一个消息完成。这也意味着服务器和客户端可以并发发送请求和响应，从而实现更好的控制和更高效的连接管理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/0937b12d4d62be8fd52b9672b6643097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t51x0xzkuCDQ_fps-GAtDA.png"/></div></div></figure><p id="23e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于多路复用允许客户端并行构建多个流，因此这些流只需要使用一个TCP连接。通过减少整个网络中的内存和处理空间，每个源拥有一个持久连接对HTTP/1.1进行了改进。这将提高网络和带宽利用率，从而降低总体运营成本。</p><h2 id="8021" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">标题压缩</h2><p id="02f7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每个HTTP传输都带有一组描述传输的资源及其属性的头。在HTTP/1.x中，该元数据总是以纯文本形式发送，每次传输会增加500–800字节的开销，如果使用HTTP cookies，有时会增加数千字节。为了减少这种开销并提高性能，HTTP/2使用HPACK压缩格式压缩请求和响应头元数据。</p><p id="026b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了压缩之外，客户机和服务器还维护一个常见字段及其压缩值的列表。因此，当这些字段重复时，它们仅仅包括对压缩值的引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/0a11375dfa8455e924d28890981bd434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCkN7RwLptkORO3FsZFJFg.png"/></div></div></figure><h2 id="b9b1" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">服务器推送</h2><p id="d4ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除了对原始请求的响应之外，服务器可以将额外的资源推送到客户端，而无需客户端显式地请求每一个资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/17e3c5dc013a6f9742498a97eaf0d8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xYbZ42881eC0177wqET6w.png"/></div></div></figure><p id="92fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当浏览器请求页面时，服务器在响应中发送HTML，然后需要等待浏览器解析HTML并发出对所有嵌入资源的请求，然后才能开始发送JavaScript、图像和CSS。</p><p id="3d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器推送潜在地允许服务器通过将它认为客户机需要的响应“推送”到它的缓存中来避免这种往返延迟。</p><p id="0e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，推送响应并不“神奇”——如果使用不当，会损害性能。服务器推送的正确使用是一个正在进行的实验和研究领域。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="5014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，与HTTP/1.1相比，HTTP/2:</p><ul class=""><li id="452a" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">是二进制的，而不是文本的</li><li id="2998" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">是完全多路复用的，而不是有序和分块的</li><li id="a8b7" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">因此可以使用一个并行连接</li><li id="b9b5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">使用标头压缩来减少开销</li><li id="0a1e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">允许服务器主动将响应“推送”到客户端缓存中</li></ul><p id="6b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于HTTP/2的更多细节可以在HTTP 2规范和T2高性能浏览器网络中找到。</p><p id="b364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能想知道HTTP/2和gRPC之间的关系。gRPC使用HTTP/2作为它的消息协议，因此它具有HTTP/2的所有效率。在下一节中，让我们更详细地了解gRPC提供了哪些特性，并将其与其他通信类型进行比较。</p><h1 id="338f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">微服务之间的通信</h1><p id="c038" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">服务通过消息以同步或异步的方式相互通信。让我们看看服务间通信是如何发展的。</p><h2 id="8486" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">SOAP——简单对象访问协议</h2><ul class=""><li id="492c" class="ny nz it lb b lc mn lf mo li om lm on lq oo lu od oe of og bi translated">客户端和服务器以XML的形式交换数据</li><li id="59cf" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">由于它的XML，它可以跨平台实现，完全独立于语言和平台。</li><li id="b4d0" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">可以在任何协议上运行，如HTTP、SMTP、TCP、UDP。</li><li id="ae80" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">今天仍然存在于许多遗留服务中。</li><li id="9235" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">难以处理，有一套严格的编码规则。</li><li id="1aba" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">协议的冗长、XML解析速度慢以及缺乏标准化的交互模型导致了直接使用HTTP协议的服务占主导地位。比如休息。</li></ul><h2 id="a939" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">REST —表征状态转移</h2><ul class=""><li id="befd" class="ny nz it lb b lc mn lf mo li om lm on lq oo lu od oe of og bi translated">交互(创建、读取、更新、删除)资源的标准方式。</li><li id="e9a5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">将API(URL)公开为资源的访问点。</li><li id="5e86" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">仅使用HTTP。</li><li id="ff17" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">仅公开HTTP方法上的CRUD行为(POST、GET、PUT、PATCH和DELETE)。如果我们的需求与这些定义良好的规则略有不同，我们需要调整这组名称来公开我们的API。</li><li id="c1a8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">不定义严格的接口类型。即使我们有OpenAPI或Swagger规范，它也不受带下划线的体系结构或消息协议的类型限制。</li></ul><h2 id="cd0a" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">gRPC — Google远程过程调用</h2><ul class=""><li id="dc81" class="ny nz it lb b lc mn lf mo li om lm on lq oo lu od oe of og bi translated">Google设计的开源RPC框架。</li><li id="550b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">公开供其他服务远程调用的过程。</li><li id="fee8" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">最大的优点是它与HTTP/2协议一起工作，因此受益于HTTP/2的上述许多效率。</li><li id="d8fd" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">在gRPC中实现协议缓冲区或Protobuf，一种IDL(接口描述语言)。</li></ul><p id="944c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经了解了几个流行的内部通信协议的背景和一般概念。让我们看看利弊，以及为什么我们应该选择gRPC而不是REST进行微服务通信。</p><h1 id="5ba3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">gRPC与REST</h1><h2 id="9584" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">HTTP/1.1与HTTP/2</h2><p id="07b5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">REST APIs遵循请求-响应<strong class="lb iu"> </strong>的通信模型，该模型通常构建在HTTP 1.1之上。不幸的是，这意味着如果微服务接收到来自客户端的多个请求，模型必须一次处理一个请求，从而降低整个系统的速度。然而，REST API也可以构建在HTTP/2上，<strong class="lb iu">但是通信的请求-响应模型保持不变</strong>，这就禁止了REST API充分利用HTTP 2的优势，比如<strong class="lb iu">流通信</strong>和<strong class="lb iu">双向支持</strong>。</p><p id="2bf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gRPC没有面临类似的障碍。它建立在HTTP 2之上，支持双向通信和流通信。gRPC可以通过不断地传输信息来同时处理请求，同时也可以处理“一元”交互，比如构建在HTTP 1.1上的交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f7464b001de00238edebabcf1b3e11e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HWPuAyVrZndcocTF.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">4种gRPC</p></figure><h2 id="d217" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">有效载荷数据结构</h2><p id="eae0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如前所述，gRPC默认使用协议缓冲区来序列化有效负载数据。这种解决方案更轻便，因为它支持高度压缩的格式，并减小了消息的大小。进一步来说，<a class="ae ky" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Protobuf </strong> </a>(或协议缓冲区)是二进制的；因此，它序列化和反序列化结构化数据，以便进行通信和传输。换句话说，<strong class="lb iu">强类型</strong>消息可以自动从Protobuf转换成客户端和服务器的编程语言。</p><p id="5bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以减少从字符串到类型转换的许多错误，例如，客户端发送一个<code class="fe ne nf ng nh b">int64</code>字段类型，它被转换为JSON字符串并发送给服务器，但是服务器期望<code class="fe ne nf ng nh b">int32</code>字段类型，所有类型的错误都可能发生。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/143bb89ba5767f24d0c5cf0e18e8a31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PT97JT3HZDDLQiz3tYZXBA.png"/></div></div></figure><p id="73d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">REST主要依靠JSON或XML格式来发送和接收数据。事实上，尽管JSON没有强制要求任何结构，但它是最流行的格式，因为它具有灵活性和发送动态数据的能力，而不必遵循严格的结构。使用JSON的另一个重要好处是它的可读性，这是Protobuf还无法与之竞争的。</p><p id="7a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，在数据传输方面，JSON并没有那么轻便和快速。原因在于，当使用REST时，JSON(或其他格式)必须被序列化，并转换成客户端和服务器端都使用的编程语言。这给传输数据的过程增加了额外的步骤和开销，从而可能损害性能并可能导致错误。</p><h2 id="4f88" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">构建代码生成功能</h2><p id="457c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与gRPC不同，REST API不提供内置的代码生成功能，这意味着开发人员必须使用像Swagger或Postman这样的第三方工具来为API请求生成代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/16dc732a88db77a305cc721570362c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i2guA5xO4cBz5V_N.png"/></div></div></figure><p id="62db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，gRPC由于其<strong class="lb iu">协议编译器</strong>而具有<strong class="lb iu">本地代码生成</strong>特性，该编译器兼容多种编程语言。这对于集成了用不同语言和平台开发的各种服务的微服务系统尤其有利。</p><h1 id="f16d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="ef49" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们了解了HTTP/2，它为什么诞生，它解决了什么问题，与HTTP/1.x相比的主要区别，以及gRPC如何在幕后利用HTTP/2并利用HTTP/2的所有效率。我们还比较了REST和gRPC，发现gRPC在性能、有效负载数据结构和本地生成代码的能力方面比REST有很多优势。这些原因使得HTTP/2和gRPC完全适合高性能、可靠性和健壮的微服务通信。</p><h1 id="d45d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="5677" class="ny nz it lb b lc mn lf mo li om lm on lq oo lu od oe of og bi translated"><a class="ae ky" href="https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference" rel="noopener ugc nofollow" target="_blank"> HTTP/1.1 vs HTTP/2:有什么区别？</a>(digitalocean.com)</li><li id="0a79" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://blog.netsil.com/http-2-and-grpc-the-next-generation-of-microservices-interactions-aff4ffa6faed" rel="noopener ugc nofollow" target="_blank"> HTTP/2和gRPC——下一代微服务交互</a>(blog.netsil.com)</li><li id="e4c2" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/http2" rel="noopener ugc nofollow" target="_blank">HTTP/2</a>简介(developers.google.com)</li><li id="468f" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://http2.github.io/faq/" rel="noopener ugc nofollow" target="_blank"> HTTP/2常见问题解答</a> (http2.github.io)</li><li id="da65" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="https://www.imaginarycloud.com/blog/grpc-vs-rest/" rel="noopener ugc nofollow" target="_blank">www.imaginarycloud.com GRPC VS REST:比较API架构风格</a></li></ul></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="d2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">感谢您阅读本文！如果你有任何问题，请留言。如果你觉得这篇文章有帮助，请按住鼓掌按钮，让其他人也能发现。请务必在下面注册我的时事通讯，或者在Medium上关注我，以获得更多类似的文章。</em> ☝️👏 😄</p></div></div>    
</body>
</html>