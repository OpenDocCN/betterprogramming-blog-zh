<html>
<head>
<title>An Overview of Next.js 13 Routing System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js 13路由系统概述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-overview-of-next-js-13-routing-system-1dcf73e2429f?source=collection_archive---------5-----------------------#2022-12-01">https://betterprogramming.pub/an-overview-of-next-js-13-routing-system-1dcf73e2429f?source=collection_archive---------5-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba8c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Next.js 13测试版功能的快速概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c2b9128e2fafd5236670165c6e463bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BY0UwnWl0yGilKM-5GcAg.png"/></div></div></figure><p id="fb4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Next.js 13以一种有些令人困惑的方式登陆。增加了许多显著的东西；不过，好的部分还是Beta。尽管如此，Beta特性给了我们关于Next.js的未来将如何形成的重要信号，所以有很好的理由密切关注它们，即使你打算等待采用它们。</p><p id="534e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文是关于Beta特性的系列体验的一部分。今天我们来探索一下新的路由系统。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="9ce8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Next.js 13引入了一个全新的<code class="fe lu lv lw lx b">app</code>文件夹，拥有完全翻新的路由系统。它包括许多改进，其中，最好的礼物是新的布局机制。</p><p id="1afe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要它们的路线不冲突，<code class="fe lu lv lw lx b">app</code>文件夹可以与旧的<code class="fe lu lv lw lx b">pages</code>文件夹共存，这允许你逐步采用。这个故事将涵盖最引人注目的新东西与<code class="fe lu lv lw lx b">app</code>文件夹。</p><h1 id="88e3" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">新文件夹结构</h1><p id="4784" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated"><code class="fe lu lv lw lx b">app</code>文件夹通过要求每条路线都是一个文件夹，使得定义路线更加明确。路由文件夹通常包含以下路由文件(带<code class="fe lu lv lw lx b">.js|.ts|.jsx|.tsx</code>后缀):</p><ul class=""><li id="920d" class="mv mw iq kt b ku kv kx ky la mx le my li mz lm na nb nc nd bi translated"><strong class="kt ir">页面— </strong>提供特定于该路线的用户界面。</li><li id="4ef8" class="mv mw iq kt b ku ne kx nf la ng le nh li ni lm na nb nc nd bi translated"><strong class="kt ir">布局— </strong>为此路线和所有后代路线提供布局UI。</li><li id="f748" class="mv mw iq kt b ku ne kx nf la ng le nh li ni lm na nb nc nd bi translated"><strong class="kt ir">加载— </strong>在加载路由的服务器组件时提供一个加载UI—下一节将详细介绍。</li><li id="d579" class="mv mw iq kt b ku ne kx nf la ng le nh li ni lm na nb nc nd bi translated"><strong class="kt ir">错误— </strong>提供处理该路由内和路由下的错误的UI(除非由后代层中的另一个<code class="fe lu lv lw lx b">error</code>路由处理)。</li></ul><p id="dd56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有关服务器组件的更多信息，请查看下面的故事<a class="ae nj" rel="noopener ugc nofollow" target="_blank" href="/fun-with-next-js-13-server-components-fd5f886c31f3">。</a></p><h1 id="d96f" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">布局和嵌套</h1><p id="7f3f" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">更新的文件夹结构为引入更多基于约定的路线文件奠定了良好的基础。因此，现在在Next.js中创建、共享和嵌套布局比以往更加容易。</p><p id="6b20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看有什么变化。</p><h2 id="f8e1" class="nk lz iq bd ma nl nm dn me nn no dp mi la np nq mk le nr ns mm li nt nu mo nv bi translated">在以前的版本中</h2><p id="690d" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">在Next.js 13之前，官方推荐的创建嵌套布局的方法是每个<code class="fe lu lv lw lx b">Page</code>都“声明”它的布局，组成嵌套，然后在<code class="fe lu lv lw lx b">pages/_app</code>的顶层应用它们。</p><pre class="kg kh ki kj gt nw lx nx bn ny nz bi"><span id="2197" class="oa lz iq lx b be ob oc l od oe">// pages/index.js<br/><br/>export default function Page() {<br/>  return (<br/>    /** Your content */<br/>  )<br/>}<br/><br/>Page.getLayout = function getLayout(page) {<br/>  return (<br/>    &lt;Layout&gt;<br/>      &lt;NestedLayout&gt;{page}&lt;/NestedLayout&gt;<br/>    &lt;/Layout&gt;<br/>  )<br/>}</span></pre><pre class="of nw lx nx bn ny nz bi"><span id="c6ce" class="oa lz iq lx b be ob oc l od oe">// pages/_app.js<br/><br/>export default function MyApp({ Component, pageProps }) {<br/>  // Use the layout defined at the page level, if available<br/>  const getLayout = Component.getLayout || ((page) =&gt; page)<br/>  return getLayout(&lt;Component {...pageProps} /&gt;)<br/>}</span></pre><p id="5c2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这种方法可以获得最佳的性能(因为在改变路由时不会重新安装布局)，但是它很麻烦而且不自然，尤其是与react-router提供的相比。</p><h2 id="edb1" class="nk lz iq bd ma nl nm dn me nn no dp mi la np nq mk le nr ns mm li nt nu mo nv bi translated">使用Next.js 13</h2><p id="7f7d" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">新的路由系统使“布局”成为一等公民。在<code class="fe lu lv lw lx b">app</code>下的任何级别的文件夹中(即任何级别的路由)，您可以使用<code class="fe lu lv lw lx b">layout.tsx</code>来显式定义容器组件。该容器组件将自动环绕该文件夹中的所有页面。如果在不同的层次上有多个<code class="fe lu lv lw lx b">layout.tsx</code>组件，则会自动构建一个包装层次结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/c8cbf1e26fad3937f9e938cb7bf995a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iEaA9IiGWlGwuvXw.png"/></div></div><p class="oh oi gj gh gi oj ok bd b be z dk translated"><a class="ae nj" href="https://beta.nextjs.org/docs/routing/pages-and-layouts" rel="noopener ugc nofollow" target="_blank">https://beta.nextjs.org/docs/routing/pages-and-layouts</a></p></figure><p id="9415" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">比老<code class="fe lu lv lw lx b">getLayout</code>黑的直白多了吧？</p><p id="f51e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“分组”功能也可用于创建页面的“逻辑”组，以共享相同的布局，而无需引入额外的路由层:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/7a7a70572b5e7e3b25fc3b1a8e40c3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LV6zCkO9-vi0ZAbH.png"/></div></div><p class="oh oi gj gh gi oj ok bd b be z dk translated"><a class="ae nj" href="https://beta.nextjs.org/docs/routing/defining-routes#route-groups" rel="noopener ugc nofollow" target="_blank">https://beta . nextjs . org/docs/routing/defining-routes # route-groups</a></p></figure><p id="3366" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，虽然<code class="fe lu lv lw lx b">/about</code>和<code class="fe lu lv lw lx b">/blog</code>不共享相同的路由前缀，但是它们可以通过驻留在相同的路由组中来共享相同的布局。谁不喜欢多一点灵活性呢👻？</p><h1 id="4ec2" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">其他注释</h1><h2 id="c0c0" class="nk lz iq bd ma nl nm dn me nn no dp mi la np nq mk le nr ns mm li nt nu mo nv bi translated">将数据从布局传递到子级</h2><p id="63b7" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">你不能这么做。但是这个问题并没有看起来那么严重，因为Next.js 13中的新数据获取机制具有内置的重复数据删除和缓存，所以在layout及其子组件中重复获取数据并没有什么坏处。</p><p id="a149" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在以后的文章中介绍新的数据获取系统。</p><h2 id="68fe" class="nk lz iq bd ma nl nm dn me nn no dp mi la np nq mk le nr ns mm li nt nu mo nv bi translated">打破布局层次结构</h2><p id="77d6" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">页面没有办法“逃离”路由层次结构中的布局祖先。你必须仔细设计你的路线或路线组。相比之下，SvelteKit确实在这方面提供了更好的灵活性。</p><h1 id="f9da" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">错误处理</h1><p id="8630" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">错误处理是一个小而方便的特性。这个想法很简单:</p><ol class=""><li id="1e1a" class="mv mw iq kt b ku kv kx ky la mx le my li mz lm ol nb nc nd bi translated">React有一个<a class="ae nj" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">错误边界</a>概念，用于以结构化的方式捕获错误。</li><li id="37d2" class="mv mw iq kt b ku ne kx nf la ng le nh li ni lm ol nb nc nd bi translated">Next.js的路由文件夹自然形成了一个组件层次结构。</li><li id="3e3d" class="mv mw iq kt b ku ne kx nf la ng le nh li ni lm ol nb nc nd bi translated">为什么我们不发明一种约定来处理任何级别的路由错误呢？</li></ol><p id="2015" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是<code class="fe lu lv lw lx b">error.tsx</code>文件的作用。这不过是在一个<code class="fe lu lv lw lx b">&lt;ErrorBoundary /&gt;</code>中包装派生组件树的语法糖:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/61faecdcd4a7513e0fc82b4dc4be33eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G8QPQsdzeje9tHMt.png"/></div></div><p class="oh oi gj gh gi oj ok bd b be z dk translated"><a class="ae nj" href="https://beta.nextjs.org/docs/routing/error-handling" rel="noopener ugc nofollow" target="_blank">https://beta.nextjs.org/docs/routing/error-handling</a></p></figure><p id="0f34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，错误被定位到由子路线呈现的UI部分，而不影响任何其他部分的显示和交互性。</p><p id="66c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。</p><pre class="kg kh ki kj gt nw lx nx bn ny nz bi"><span id="a13f" class="oa lz iq lx b be ob oc l om oe">Want to Connect?<br/><br/>I'm the creator of <a class="ae nj" href="https://zenstack.dev/?utm_campaign=medium&amp;utm_medium=organic&amp;utm_content=nextjs_new_routing" rel="noopener ugc nofollow" target="_blank">ZenStack</a>, a toolkit that supercharges<br/>Prisma ORM with a powerful access control layer and<br/>unleashes its full potential for full-stack development.<br/>Our goal is to let you save time writing boilerplate code<br/>and focus on building what matters - the user experience.</span></pre></div></div>    
</body>
</html>