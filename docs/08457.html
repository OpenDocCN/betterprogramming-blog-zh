<html>
<head>
<title>What Are Java Collections? Get Started With the Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Java集合？开始使用框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-java-collections-get-started-with-the-framework-4ea9233c35b5?source=collection_archive---------7-----------------------#2021-05-03">https://betterprogramming.pub/what-are-java-collections-get-started-with-the-framework-4ea9233c35b5?source=collection_archive---------7-----------------------#2021-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e6a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Java实现各种数据结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cfa028cc990a2a405b90fc5aa61db96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lJJ8XsgpCO9zIKQ5Ad5BA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="d8c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每种编程语言中都使用集合。它们是将多个元素组合成一个单元的对象。在<a class="ae lr" href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html" rel="noopener ugc nofollow" target="_blank">集合</a>框架之前，程序员很难写出适用于不同类型集合的算法。Java附带了一些集合类，比如<code class="fe ls lt lu lv b">Vector</code>、<code class="fe ls lt lu lv b">Stack</code>、<code class="fe ls lt lu lv b">Hashtable</code>和<code class="fe ls lt lu lv b">Array</code>，但是它们有自己的缺点。</p><p id="3640" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在JDK 1.2中，Java开发者引入了集合框架，这是一个帮助你实现所有数据操作的重要框架。今天，我们将深入这个框架及其一些组件。</p><p id="654a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是我们今天要讲的内容:</p><ul class=""><li id="88c3" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">什么是Java集合？</li><li id="5fcb" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">ArrayList</code>在爪哇</li><li id="b725" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">LinkedList</code>在Java中</li><li id="e29e" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">HashSet</code>在爪哇</li><li id="3d8e" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">TreeSet</code>在爪哇</li><li id="febb" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">要研究的其他收藏</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="3758" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">什么是Java集合？</h1><p id="7005" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">根据文档的说法，Java集合框架是一个“用于表示和操作集合的统一架构”它包含接口、它们的实现类以及处理存储在集合中的数据的算法。<code class="fe ls lt lu lv b">Collection</code>接口由其他接口扩展，如<code class="fe ls lt lu lv b">List</code>、<code class="fe ls lt lu lv b">Set</code>和<code class="fe ls lt lu lv b">Queue</code>。</p><p id="2109" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="no">注意:也有一个</em> <code class="fe ls lt lu lv b"><em class="no">Map</em></code> <em class="no">接口，但是它没有实现</em> <code class="fe ls lt lu lv b"><em class="no">Collection</em></code> <em class="no">接口，因为它存储键-值对，而集合接口下的类只存储值。</em></p><h2 id="c082" class="np ms iq bd mt nq nr dn mx ns nt dp nb le nu nv nd li nw nx nf lm ny nz nh oa bi translated"><strong class="ak">集合框架和集合之间的差异</strong></h2><ul class=""><li id="d892" class="lw lx iq kx b ky nj lb nk le ob li oc lm od lq mb mc md me bi translated">集合框架是一个接口，而<code class="fe ls lt lu lv b">Collections</code>是一个类。</li><li id="1387" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">Collection</code>接口为<code class="fe ls lt lu lv b">List</code>、<code class="fe ls lt lu lv b">Set</code>和<code class="fe ls lt lu lv b">Queue</code>提供数据结构的标准功能。<code class="fe ls lt lu lv b">Collections</code>类提供了标准的方法，可以用来搜索、排序和协调集合元素。</li><li id="8625" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">Collections</code>是表示一组对象的对象(像<code class="fe ls lt lu lv b">Vector</code>)，而集合框架可以表示和操作集合。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d855" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Java集合框架组件</h1><h2 id="1d4e" class="np ms iq bd mt nq nr dn mx ns nt dp nb le nu nv nd li nw nx nf lm ny nz nh oa bi translated"><strong class="ak">接口</strong></h2><p id="fda6" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">这些接口提供抽象数据类型来表示集合。<code class="fe ls lt lu lv b">java.util.Collection</code>是框架的根接口。它位于框架层次的顶端，包含重要的方法，如<code class="fe ls lt lu lv b">size()</code>、<code class="fe ls lt lu lv b">iterator()</code>、<code class="fe ls lt lu lv b">add()</code>、<code class="fe ls lt lu lv b">remove()</code>和<code class="fe ls lt lu lv b">clear()</code>。</p><p id="c85c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">Iterable</code>接口是整个集合框架的根。它允许迭代器遍历所有集合。所有的类和接口都使用这个接口。<code class="fe ls lt lu lv b">Collection</code>接口扩展了iterable接口，由集合框架中的类执行。<code class="fe ls lt lu lv b">List</code>接口禁止列表类型的数据结构，我们可以在其中存储有序的对象集合。</p><p id="1998" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一些更重要的接口包括:</p><ul class=""><li id="e5a4" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated"><code class="fe ls lt lu lv b">Map</code>界面:<code class="fe ls lt lu lv b">java.util.Map</code></li><li id="903a" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">Set</code>接口:<code class="fe ls lt lu lv b">java.util.Set</code></li><li id="b17e" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">Deque</code>接口:<code class="fe ls lt lu lv b">java.util.Deque</code></li></ul><p id="8d27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="no">注意:</em> <code class="fe ls lt lu lv b"><em class="no">Map</em></code> <em class="no">接口是唯一一个不从</em> <code class="fe ls lt lu lv b"><em class="no">Collection</em></code> <em class="no">接口继承，但是包含在集合框架中的接口。所有框架接口都在</em> <code class="fe ls lt lu lv b"><em class="no">java.util</em></code> <em class="no">包中。</em></p><h2 id="c484" class="np ms iq bd mt nq nr dn mx ns nt dp nb le nu nv nd li nw nx nf lm ny nz nh oa bi translated"><strong class="ak">实现类</strong></h2><p id="4eec" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">框架为集合提供了实现类。您可以使用它们在Java程序中创建不同类型的集合。一些主要的集合类包括:</p><ul class=""><li id="fd48" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated"><code class="fe ls lt lu lv b">ArrayList</code></li><li id="5907" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">LinkedList</code></li><li id="cb0f" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">PriorityQueue</code></li><li id="753b" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">HashMap</code>和<code class="fe ls lt lu lv b">HashSet</code></li><li id="e5cd" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">TreeMap</code>和<code class="fe ls lt lu lv b">TreeSet</code></li></ul><h2 id="6448" class="np ms iq bd mt nq nr dn mx ns nt dp nb le nu nv nd li nw nx nf lm ny nz nh oa bi translated"><strong class="ak">算法</strong></h2><p id="27fd" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">这些算法对集合执行重要的功能，比如排序列表。</p><p id="a7e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">收集框架的层次结构如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/de01b7fd4a71b8e1ed8b652029507c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsoxervLrNAbDsANCqAkXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Java集合框架层次结构</p></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="2f43" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Java中的数组列表</h1><p id="04e6" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><code class="fe ls lt lu lv b">ArrayList</code>是<code class="fe ls lt lu lv b">List</code>接口最常用的实现。它的一些功能包括:</p><ul class=""><li id="40f2" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">按插入顺序存储元素。</li><li id="3ed2" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">允许存储重复的元素。</li><li id="476d" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">支持<code class="fe ls lt lu lv b">null</code>元素。</li></ul><p id="964f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个<code class="fe ls lt lu lv b">ArrayList</code>将数据存储在一个可调整大小的数组中。当你创建一个<code class="fe ls lt lu lv b">ArrayList</code>时，你创建了一个大小为零的数组。当插入第一个元素时，数组大小变为10。这就是所谓的<em class="no">惰性初始化</em>，它节省了大量的内存。在向<code class="fe ls lt lu lv b">ArrayList</code>添加元件之前，检查容量。如果数组已满，则创建一个大小为<em class="no"> (n + n/2 + 1) </em>的新数组。然后旧数组中的元素被复制到新数组中。</p><p id="6bde" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Java中创建<code class="fe ls lt lu lv b">ArrayList</code>有三种方法:</p><ol class=""><li id="0ef0" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq of mc md me bi translated"><code class="fe ls lt lu lv b">no-arg</code>构造函数——这个构造函数没有任何参数，将创建一个大小为零的列表。</li></ol><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="6f5b" class="np ms iq lv b gy ok ol l om on">List list = newArrayList();</span></pre><p id="e086" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.获取初始容量的构造函数——您可以在创建<code class="fe ls lt lu lv b">ArrayList</code>时给出一个初始容量。假设您知道您的<code class="fe ls lt lu lv b">ArrayList</code>将包含最少50个元素。您可以创建大小为50的<code class="fe ls lt lu lv b">ArrayList</code>，减少不断调整大小的需要。</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="20ee" class="np ms iq lv b gy ok ol l om on">List list = newArrayList(50);</span></pre><p id="757f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.现有的<code class="fe ls lt lu lv b">Collection</code> —您可以使用现有的<code class="fe ls lt lu lv b">Collection</code>创建一个<code class="fe ls lt lu lv b">ArrayList</code>，列表将包含原始<code class="fe ls lt lu lv b">Collection</code>中的所有元素，顺序相同。</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="6aaf" class="np ms iq lv b gy ok ol l om on">List list = newArrayList(oldList);</span></pre><p id="115a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个可以用Java执行的<code class="fe ls lt lu lv b">ArrayList</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="5602" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="33b4" class="np ms iq lv b gy ok ol l om on">[1, 2, 3]</span><span id="1778" class="np ms iq lv b gy oq ol l om on">The element at index two is 2</span><span id="442c" class="np ms iq lv b gy oq ol l om on">The size of the List is 3</span></pre><p id="5869" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe ls lt lu lv b">ArrayList</code>可以做很多事情，包括:</p><ul class=""><li id="6663" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">set(int index, E e)</code>方法更新元素。</li><li id="2c74" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">contains(Object o)</code>方法检查元件是否存在。</li><li id="dc51" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">removeAll(Collection&lt;?&gt; c)</code>方法移除给定<code class="fe ls lt lu lv b">Collection</code>内的所有元素。</li><li id="1035" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">replaceAll(UnaryOperator&lt;E&gt; operator)</code>更换所有元件。</li><li id="25d2" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">等等。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="308c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Java中的LinkedList</h1><p id="706d" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><code class="fe ls lt lu lv b">LinkedList</code>类实现了<code class="fe ls lt lu lv b">List</code>和<code class="fe ls lt lu lv b">Deque</code>接口。它的一些功能包括:</p><ul class=""><li id="e2e9" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">按插入顺序存储元素。</li><li id="2f45" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">支持重复元素。</li><li id="3ecf" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">允许任意数量的<code class="fe ls lt lu lv b">null</code>元素。</li></ul><p id="99da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">LinkedList</code>还有一个名为<code class="fe ls lt lu lv b">Node</code>的静态内部类，包含三个字段:</p><ol class=""><li id="0fab" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq of mc md me bi translated"><code class="fe ls lt lu lv b">item</code> —包含当前元素的值</li><li id="8a3a" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq of mc md me bi translated"><code class="fe ls lt lu lv b">next</code> —包含指向下一个元素的指针</li><li id="bed1" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq of mc md me bi translated"><code class="fe ls lt lu lv b">prev</code> —包含指向上一个元素的指针</li></ol><p id="eefd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当一个元素被添加到一个<code class="fe ls lt lu lv b">LinkedList</code>时，它会创建一个新的<code class="fe ls lt lu lv b">Node</code>实例。根据添加新节点的位置设置<code class="fe ls lt lu lv b">prev</code>和<code class="fe ls lt lu lv b">next</code>字段。</p><p id="d80b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Java中创建<code class="fe ls lt lu lv b">LinkedList</code>有两种方法:</p><ol class=""><li id="f44b" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq of mc md me bi translated"><code class="fe ls lt lu lv b">no-arg</code>构造函数——这个构造函数没有任何参数，将创建一个大小为零的列表。</li></ol><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="f9f1" class="np ms iq lv b gy ok ol l om on">List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();</span></pre><p id="457d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.现有的<code class="fe ls lt lu lv b">Collection</code> —您可以使用现有的<code class="fe ls lt lu lv b">Collection</code>创建一个<code class="fe ls lt lu lv b">LinkedList</code>，列表将包含原始<code class="fe ls lt lu lv b">Collection</code>中的所有元素，顺序相同。</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="b48b" class="np ms iq lv b gy ok ol l om on">List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(oldList);</span></pre><p id="df9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个可以用Java执行的<code class="fe ls lt lu lv b">LinkedList</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="e45e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="d6a9" class="np ms iq lv b gy ok ol l om on">[1, 2, 3]</span><span id="d088" class="np ms iq lv b gy oq ol l om on">[10, 1, 2, 3]</span><span id="e661" class="np ms iq lv b gy oq ol l om on">[10, 1, 20, 2, 3]</span><span id="09fb" class="np ms iq lv b gy oq ol l om on">[10, 1, 20, 101, 102, 103, 2, 3]</span></pre><p id="8cde" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以用<code class="fe ls lt lu lv b">LinkedList</code>做更多的事情:</p><ul class=""><li id="8c96" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">get(int index)</code>方法获取特定索引处的元素。</li><li id="ee8e" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">removeLast()</code>方法移除最后一个元件。</li><li id="feb0" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">sort()</code>方法对<code class="fe ls lt lu lv b">LinkedList</code>进行分类。</li><li id="45ab" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">等等。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="7f53" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Java中的HashSet</h1><p id="53fe" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><code class="fe ls lt lu lv b">HashSet</code>是<code class="fe ls lt lu lv b">java.util</code>包中实现<code class="fe ls lt lu lv b">Set</code>接口的一个类。<code class="fe ls lt lu lv b">HashSet</code>的一些功能包括:</p><ul class=""><li id="2742" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">不允许重复元素。</li><li id="7f8e" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">只允许一个<code class="fe ls lt lu lv b">null</code>元素。</li><li id="3be9" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">元素以随机顺序插入。</li><li id="d30c" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">内部由一个<code class="fe ls lt lu lv b">HashMap</code>支持。</li></ul><p id="74dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有四种方法可以在Java中创建HashSet:</p><ol class=""><li id="ec01" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq of mc md me bi translated"><code class="fe ls lt lu lv b">no-arg</code>构造函数——这将创建一个初始容量为16、装载系数为0.75的<code class="fe ls lt lu lv b">HashSet</code>。</li></ol><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="d596" class="np ms iq lv b gy ok ol l om on">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span></pre><p id="bd5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.一个需要初始容量的构造函数——如果你知道你的<code class="fe ls lt lu lv b">HashSet</code>将有超过16个元素，你可以设置一个更高的初始容量来减少调整大小的需要。它将使用默认的加载因子0.75。</p><p id="1d87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.采用初始容量和负载系数的构造函数-您也可以在提供初始容量的同时提供初始负载系数。</p><p id="7c8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.一个将另一个<code class="fe ls lt lu lv b">Set</code>作为参数的构造函数——您可以通过将另一个<code class="fe ls lt lu lv b">Set</code>传递给构造函数来创建一个<code class="fe ls lt lu lv b">HashSet</code>。它将具有与传递的集合相同的大小，并且默认加载因子为0.75。</p><p id="fe83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个可以在Java中执行的<code class="fe ls lt lu lv b">HashSet</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d1c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="1464" class="np ms iq lv b gy ok ol l om on">Inserting 17 in the HashSet: true</span><span id="b8c4" class="np ms iq lv b gy oq ol l om on">Inserting 34 in the HashSet: true</span><span id="8f96" class="np ms iq lv b gy oq ol l om on">Inserting 17 in the HashSet: false</span><span id="bd9a" class="np ms iq lv b gy oq ol l om on">[17, 34]</span></pre><p id="1a87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码展示了将元素插入到<code class="fe ls lt lu lv b">HashSet</code>中的<code class="fe ls lt lu lv b">add(E e)</code>方法。如果插入的元素不在<code class="fe ls lt lu lv b">HashSet</code>中，方法返回<code class="fe ls lt lu lv b">true</code>。如果元素已经在<code class="fe ls lt lu lv b">HashSet</code>中，方法返回<code class="fe ls lt lu lv b">false</code>。</p><p id="c1c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用<code class="fe ls lt lu lv b">HashSets</code>做更多事情，例如:</p><ul class=""><li id="89a1" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">remove(Object o)</code>方法移除元件。</li><li id="585b" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">isEmpty()</code>方法检查<code class="fe ls lt lu lv b">HashSet</code>是否为空。</li><li id="caa1" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">contains()</code>方法从<code class="fe ls lt lu lv b">HashSet</code>中获取一个元素。</li><li id="1e03" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">等等。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9f15" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Java中的树集</h1><p id="9a04" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated"><code class="fe ls lt lu lv b">TreeSet</code>类实现了使用树进行存储的<code class="fe ls lt lu lv b">Set</code>接口。一些功能包括:</p><ul class=""><li id="d95c" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">不允许重复元素。</li><li id="4250" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">不允许使用<code class="fe ls lt lu lv b">null</code>元素。</li><li id="6304" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">快速访问和检索时间。</li><li id="17e4" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">按升序存储的元素。</li></ul><p id="e4a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">TreeSet</code>层级如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/ed3ef7ff9f4b33bcee61498dd40f8bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*OMbv1_ZAY33YS0-KySb5-A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">树形层次结构</p></figure><p id="0c66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一辆<code class="fe ls lt lu lv b">TreeSet</code>和一辆<code class="fe ls lt lu lv b">HashSet</code>有什么不同？</p><p id="3c90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">HashSet</code>允许一个空元素，而<code class="fe ls lt lu lv b">TreeSet</code>不允许任何空元素。</p><p id="20bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">元素在<code class="fe ls lt lu lv b">HashSet</code>中随机排序，而在<code class="fe ls lt lu lv b">TreeSet</code>中按顺序排序。</p><p id="abc4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">HashSet</code>对于<code class="fe ls lt lu lv b">add</code>、<code class="fe ls lt lu lv b">remove</code>、<code class="fe ls lt lu lv b">contains</code>、<code class="fe ls lt lu lv b">size</code>等操作更快。</p><p id="f6bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Java中创建树集有四种方法:</p><ol class=""><li id="9a28" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq of mc md me bi translated"><code class="fe ls lt lu lv b">no-arg</code>构造器。</li></ol><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="52d6" class="np ms iq lv b gy ok ol l om on">Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();</span></pre><p id="b17c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.将<code class="fe ls lt lu lv b">Comparator</code>作为参数的构造函数——如果您存储在<code class="fe ls lt lu lv b">TreeSet</code>中的对象没有实现<code class="fe ls lt lu lv b">Comparator</code>接口，或者如果您需要以降序存储元素，您可以在创建<code class="fe ls lt lu lv b">TreeSet</code>的同时提供一个自定义的<code class="fe ls lt lu lv b">Comparator</code>。这将按照<code class="fe ls lt lu lv b">Comparator</code>的逻辑对元素进行排序。</p><p id="018d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.带有<code class="fe ls lt lu lv b">Collection</code>类型参数的构造函数——您可以从另一个<code class="fe ls lt lu lv b">Collection</code>创建一个<code class="fe ls lt lu lv b">TreeSet</code>。这些元素将以升序存储。</p><p id="d9ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.具有类型<code class="fe ls lt lu lv b">SortedSet</code>参数的构造函数—该构造函数充当复制构造函数，并使用相同的元素和提供的排序集的相同顺序创建一个新的排序集。</p><p id="d0ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个可以用Java执行的<code class="fe ls lt lu lv b">TreeSet</code>的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="2c49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="1399" class="np ms iq lv b gy ok ol l om on">TreeSet elements in ascending order [11, 21, 32, 44, 54]</span><span id="7019" class="np ms iq lv b gy oq ol l om on">TreeSet elements in descending order [54, 44, 32, 21, 11]</span></pre><p id="c7fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用<code class="fe ls lt lu lv b">TreeSet</code>做更多事情，例如:</p><ul class=""><li id="14e1" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">tailSet(E fromElement)</code>方法获取大于给定元素的元素。</li><li id="d3b6" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">使用<code class="fe ls lt lu lv b">subSet(E fromElement, E to Element)</code>方法获取元素的子集。</li><li id="d944" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">等等。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="17de" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">要研究的其他收藏</h1><p id="58fa" class="pw-post-body-paragraph kv kw iq kx b ky nj jr la lb nk ju ld le nl lg lh li nm lk ll lm nn lo lp lq ij bi translated">祝贺您迈出了Java集合框架的第一步！<code class="fe ls lt lu lv b">Collection</code>是Java编程中最重要的主题之一，这个重要的框架将帮助你完成你所有的数据操作。</p><p id="d145" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您可以更深入地研究Java Collections框架，并了解更多主题，例如:</p><ul class=""><li id="47bc" class="lw lx iq kx b ky kz lb lc le ly li lz lm ma lq mb mc md me bi translated"><code class="fe ls lt lu lv b">LinkedHashMap</code>和<code class="fe ls lt lu lv b">LinkedHashSet</code></li><li id="b15d" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">SortedMap</code>和<code class="fe ls lt lu lv b">SortedSet</code></li><li id="90a4" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">toArray()</code></li><li id="0d57" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated"><code class="fe ls lt lu lv b">hasNext()</code></li><li id="4083" class="lw lx iq kx b ky mf lb mg le mh li mi lm mj lq mb mc md me bi translated">等等。</li></ul><p id="4de4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">快乐学习！</p></div></div>    
</body>
</html>