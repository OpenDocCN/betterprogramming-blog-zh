<html>
<head>
<title>React’s Higher-Order Components Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的高阶组件解释</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-higher-order-components-explained-c0f9be638?source=collection_archive---------7-----------------------#2020-02-02">https://betterprogramming.pub/react-higher-order-components-explained-c0f9be638?source=collection_archive---------7-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="097f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通用的、可重用的组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e21438b79ed7a0a867f65c20bb0c1641.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*cYo6rO6ecthVZwmZvKFgww.png"/></div></figure><p id="c174" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在探索高阶组件时要记住的关键思想是，它们旨在支持组件之间的代码重用。就是这样。这就是它们存在的原因。</p><p id="e3e9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，还有一些想法需要记住:</p><ul class=""><li id="4bdd" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">高阶组件之所以如此称呼，是因为它们是消耗并返回另一个组件的组件</li><li id="0e5e" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">名称<em class="ma">高阶组件</em>是对高阶函数的引用；然而，它们与类和<em class="ma"> </em>功能组件一起工作</li><li id="feac" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">它们可能有点笨拙，并因此受到批评(子弹在这里，所以如果你第一次遇到这些事情，你会发现自己在想见鬼，你会知道你并不孤单)</li><li id="ee68" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">它们在框架中使用得相当多，所以它们会在这里存在一段时间</li><li id="9a5f" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">HOC =高阶分量</li></ul></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="dede" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">真实世界的例子:带路由器</h1><p id="9ee6" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">让我们看一个真实世界的例子。</p><p id="b586" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">大多数重要的<a class="ae nf" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>应用使用<a class="ae nf" href="https://www.npmjs.com/package/react-router" rel="noopener ugc nofollow" target="_blank">路由器</a>库。当您将一个组件传递到一个路由中时，例如…</p><p id="46c2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe ng nh ni nj b">&lt;Route path="/foobar" component={FooComponent} /&gt;</code></p><p id="a197" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">……<code class="fe ng nh ni nj b">FooComponent</code>将可以访问<code class="fe ng nh ni nj b">props</code>对象上的<code class="fe ng nh ni nj b">history</code>、<code class="fe ng nh ni nj b">location</code>和<code class="fe ng nh ni nj b">match</code>成员(因此，可以访问路由器特性，如编程导航)。</p><p id="2dc5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是有时候你有一个组件不像这样通过路由直接处理，但是你仍然需要访问<code class="fe ng nh ni nj b">props.history</code>功能——比如说在<code class="fe ng nh ni nj b">NavBar</code>中。</p><p id="eb30" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您如何访问路由器的基础设施？</p><p id="fab8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用<code class="fe ng nh ni nj b">withRouter</code> HOC:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="8d14" class="no mj it nj b gy np nq l nr ns">import { withRouter } from 'react-router-dom';</span><span id="82e0" class="no mj it nj b gy nt nq l nr ns">function NavBar (){ <br/>  // ...DO STUFF...<br/>  // including access props.history, props.location and props.match<br/>  return (/*...*/)<br/>}</span><span id="6dce" class="no mj it nj b gy nt nq l nr ns">export default withRouter(NavBar)</span></pre><p id="4090" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以你可以看到我们的<code class="fe ng nh ni nj b">NavBar</code>功能组件，不是作为导出返回自己，而是返回被<code class="fe ng nh ni nj b">withRouter</code> HOC包装的<em class="ma"> </em>。</p><p id="042c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这是一个基本的想法:获取共享的功能，然后将它放在一个组件中，该组件包装了其他组件，这些组件可以利用通用的特性。</p><p id="99b3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们需要多个hoc，我们该怎么办？</p><p id="6c7b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可以把它们包起来:<code class="fe ng nh ni nj b">withState(withRouter(navBar))</code>。</p><p id="d273" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">(另一个选项是<a class="ae nf" href="https://redux.js.org/api/compose/" rel="noopener ugc nofollow" target="_blank">Redux</a>T12】功能。)</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1aec" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">创建hoc</h1><p id="68d9" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">当应用程序需要跨组件共享功能时，使用HOCs是一种选择(本文结尾提到了其他一些可能会考虑的方法)。</p><p id="5d11" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您想要做的是识别共享的位，并将其提取到一个组件中，该组件将与包装的组件进行通信，其方式是使特设组件和客户端组件尽可能少地了解彼此(这就是松耦合——良好的老式软件设计)。</p><p id="6282" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">实际上，这种工作方式是HOC通过props与客户端组件进行交互。Props是向组件提供所需信息的标准方式，通过它们进行交互，组件可以以完全相同的方式存在，不管它是否被HOC封装。</p><p id="8a3e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所有被包装的组件需要知道的是道具在运行时是可用的。</p><p id="aab7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，我们可以将HOCs视为框架和组件之间的抽象层，这正是它们的本质。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/559d28500347ef5349dc8efd94ec7ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*jJXcanBU4SoyQAVwGizIrw.png"/></div></figure><p id="dac2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您的HOC可以是一个简单的功能组件，其一般形式如下所示(<code class="fe ng nh ni nj b">with*</code>是常规的命名模式):</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="71ae" class="no mj it nj b gy np nq l nr ns">const withSomething = WrappedComponent =&gt; { <br/>  const something = // do something generically useful with something<br/>  return props =&gt; &lt;WrappedComponent something={something} <br/>    {…props}/&gt;; <br/>};</span></pre><p id="0224" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，基本的想法是在您的HOC中执行一些有用的服务，然后通过spread操作符将结果传递给<code class="fe ng nh ni nj b">WrappedComponent</code>以及其余的道具。</p><p id="c987" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这最后一点很重要，因为它使得消费代码所传递的任何其他道具都可用。这使得它对包装的组件是透明的。</p><p id="c0e7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">随着钩子的出现，你的函数式HOC可以做类组件所能做的一切，包括进入生命周期点和处理状态。</p><p id="d605" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">大型应用程序中出现的一个常见模式是将状态提取到HOC中，然后努力获得一个纯粹的表示组件，以响应由HOC管理的状态。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="a82a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">或者也许你应该使用…</h1><p id="a98b" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">除了代码共享的HOC之外，您还应该知道其他选择。</p><h2 id="dc67" class="no mj it bd mk nu nv dn mo nw nx dp ms kz ny nz mu ld oa ob mw lh oc od my oe bi translated">混合(坏)</h2><p id="88c3" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">首先是旧的选择:mixins。Mixins是一种众所周知的JavaScript技术。它们在React中已经失宠，因为它们遇到了一些问题，比如名称空间冲突，以及在复杂场景中它们的功能变得模糊。</p><p id="337f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从HOC的角度来看，后面的批评很有趣:我想知道，HOC不也有同样的问题吗？</p><h2 id="8e75" class="no mj it bd mk nu nv dn mo nw nx dp ms kz ny nz mu ld oa ob mw lh oc od my oe bi translated">继承(不赞成)</h2><p id="24df" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">继承是代码重用的标准OOP风格。对于组件的紧密耦合来说，这被认为是不好的做法。它也不适用于功能组件。</p><p id="c7d2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在现代，即使是OOP专家也倾向于强调组合而不是继承。</p><h2 id="a1fd" class="no mj it bd mk nu nv dn mo nw nx dp ms kz ny nz mu ld oa ob mw lh oc od my oe bi translated">渲染道具</h2><p id="de7e" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">另一个选择是渲染道具。有时渲染道具可以提供更干净的体验。你必须看一看你正在做的事情的细节，以确定更好的选择。</p><h2 id="791a" class="no mj it bd mk nu nv dn mo nw nx dp ms kz ny nz mu ld oa ob mw lh oc od my oe bi translated">钩住</h2><p id="b0d8" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">另一个选择是定义自定义挂钩，如这里的<a class="ae nf" href="https://blog.bitsrc.io/simple-code-reuse-with-react-hooks-432f390696bf" rel="noopener ugc nofollow" target="_blank">所述</a>。</p></div></div>    
</body>
</html>