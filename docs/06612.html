<html>
<head>
<title>Tips for Unit Testing Ethereum Smart Contracts in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity中以太坊智能合约的单元测试技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-few-tips-for-unit-testing-ethereum-smart-contract-in-solidity-d804062068fb?source=collection_archive---------1-----------------------#2020-10-19">https://betterprogramming.pub/a-few-tips-for-unit-testing-ethereum-smart-contract-in-solidity-d804062068fb?source=collection_archive---------1-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6d37" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">撰写更好的智能合同</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/02f0f15aea16c0780111c43f0f373c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeTDmSZ_TYtJOR7csIqQCw.png"/></div></div></figure><p id="a0c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与其他软件程序不同，智能合同一旦部署到特定地址，就不能修改或删除。这种独特的约束使得智能合约中的漏洞比其他漏洞更加危险。所以需要更详尽的测试。</p><p id="5740" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，用于可靠性单元测试的最著名的单元测试工具如下:</p><ul class=""><li id="9db5" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://www.trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript" rel="noopener ugc nofollow" target="_blank">松露智能合约测试框架</a></li><li id="088b" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://remix-ide.readthedocs.io/en/latest/unittesting.html" rel="noopener ugc nofollow" target="_blank"> Remix-IDE单元测试插件</a></li><li id="1dda" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://github.com/OpenZeppelin/openzeppelin-test-environment" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin测试环境</a></li></ul><p id="f740" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">OpenZeppelin测试环境最近才出现，所以看起来验证的还不够，虽然看起来很有希望。Remix是最强大的编辑工具之一。但是单元测试在命令行模式下比在GUI中更合适。所以截至目前，大多推荐松露智能合约测试框架。</p><p id="c237" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下链接是ERC-20智能合约的块菌单元测试程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://github.com/3rdstage/smart-contracts/blob/master/test/token/TestERC20Regular.js"><div class="gh gi mc"><img src="../Images/7bf9bf31a6a7dfe5cbc7ad39cbcb3414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Pi-Qo8S2AsyRdgYusLwIsA.png"/></div></a><p class="md me gj gh gi mf mg bd b be z dk translated">单击查看完整源代码</p></figure><p id="9c19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在测试程序中，使用了一些块菌文件中没有的策略。它们可以使测试程序更加有效和高效，这将在下面解释。如果你不熟悉Truffle测试框架，最好先阅读官方文档。</p><p id="261a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1] <a class="ae lw" href="https://www.trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript" rel="noopener ugc nofollow" target="_blank"> Truffle:用JavaScript编写测试</a></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="c99f" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">分组测试用例</h1><p id="7bdf" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">松露测试框架采用了著名的摩卡。稍微扭曲一下Mocha测试的基本结构，Truffle测试程序从<code class="fe nl nm nn no b">contract()</code>函数开始，并在其中包含<code class="fe nl nm nn no b">it()</code>函数作为测试用例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">块菌单元测试骨架</p></figure><p id="5fd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一个智能契约有几十个单元测试，那么像上面这样的线性结构就很难阅读、维护和更新。Mocha允许测试用例嵌套到中间的<code class="fe nl nm nn no b">describe()</code>函数中，所以Truffle测试用例可以使用嵌套的<code class="fe nl nm nn no b">describe()</code>函数来对测试用例进行分组，以提高可读性。</p><p id="43fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的测试程序中，根据令牌的顶层概念，测试用例被分为<code class="fe nl nm nn no b">Initial State</code>、<code class="fe nl nm nn no b">Minting</code>、<code class="fe nl nm nn no b">Transfer</code>、<code class="fe nl nm nn no b">Approval</code>、<code class="fe nl nm nn no b">Delegated Transfer</code>、<code class="fe nl nm nn no b">Burning</code>和<code class="fe nl nm nn no b">Circuit Breaker</code>。这些组是<code class="fe nl nm nn no b">describe()</code>函数，它们包含<code class="fe nl nm nn no b">it()</code>函数作为下面的测试用例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8968" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于大量的测试用例，如果所有现有的测试用例每次都被执行，那么测试新添加的测试用例会非常低效。将测试用例分成几个测试程序来避免这种情况，会引起对一致性和可维护性的其他关注。您可以使用<code class="fe nl nm nn no b">only()</code>函数只运行您想要用Mocha框架测试的选定测试用例。</p><p id="65e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果执行下面的测试程序，将只运行<code class="fe nl nm nn no b">Transfer</code>类别下的测试用例，其中<code class="fe nl nm nn no b">describe()</code>函数标有<code class="fe nl nm nn no b">only()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d393" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以将<code class="fe nl nm nn no b">only()</code>应用于<code class="fe nl nm nn no b">it()</code>函数，以进一步缩小执行范围。一个测试程序中可以标记多个<code class="fe nl nm nn no b">describe()</code>或<code class="fe nl nm nn no b">it()</code>功能<code class="fe nl nm nn no b">only()</code>。</p><p id="cb30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">执行下面的测试程序，只运行两个以<code class="fe nl nm nn no b">it.only</code>开始的测试用例，跳过所有其他测试用例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e74c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1] <a class="ae lw" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>:功能丰富的JavaScript测试框架<br/>【2】<a class="ae lw" href="https://www.trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript" rel="noopener ugc nofollow" target="_blank">JavaScript中的松露测试</a><br/>【3】<a class="ae lw" href="https://mochajs.org/#exclusive-tests" rel="noopener ugc nofollow" target="_blank">摩卡/独占测试</a></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="3067" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">大数字</h1><p id="e653" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">以太坊更喜欢大数。以太坊的隐含单位是卫，最具代表性的以太是10卫。</p><p id="92b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中，原始数字类型的最大整数值大约是2⁵ (~ 10 ⁶)。因此，要用JavaScript处理以太坊，需要另一种用于大数字的数字类型。<code class="fe nl nm nn no b"><a class="ae lw" href="https://github.com/ethereum/web3.js/" rel="noopener ugc nofollow" target="_blank">web3.js</a></code>，以太坊最基本的小玩意之一使用<code class="fe nl nm nn no b"><a class="ae lw" href="https://github.com/indutny/bn.js/" rel="noopener ugc nofollow" target="_blank">bn.js</a></code> ⁴和<code class="fe nl nm nn no b"><a class="ae lw" href="https://github.com/MikeMcl/bignumber.js/" rel="noopener ugc nofollow" target="_blank">bignumber.js</a></code> ⁵.<code class="fe nl nm nn no b"><a class="ae lw" href="https://web3js.readthedocs.io/en/v1.2.4/web3-eth.html#sendtransaction" rel="noopener ugc nofollow" target="_blank">web3.eth.sendTransaction()</a></code>函数中的<code class="fe nl nm nn no b">value</code>参数和<code class="fe nl nm nn no b">gasPrice</code>参数的数据类型说明了这一点。虽然不清楚<code class="fe nl nm nn no b">web3.js</code>为什么支持两种不同类型的巨数，但是考虑到<code class="fe nl nm nn no b"><a class="ae lw" href="https://web3js.readthedocs.io/en/v1.2.4/web3-utils.html#bn" rel="noopener ugc nofollow" target="_blank">web3.utils.BN()</a></code>和<code class="fe nl nm nn no b"><a class="ae lw" href="https://web3js.readthedocs.io/en/v1.2.4/web3-utils.html#tobn" rel="noopener ugc nofollow" target="_blank">web3.utils.toBN()</a></code>，似乎还是首选<code class="fe nl nm nn no b">BN</code> ( <code class="fe nl nm nn no b">bn.js</code>)。</p><p id="f616" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在测试程序中更容易地处理大数字，在开始时定义对<code class="fe nl nm nn no b">web3.utils.toBN()</code>函数的引用。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="6569" class="nv mp iq no b gy nw nx l ny nz">const toBN = web3.utils.toBN;</span></pre><p id="b54b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nl nm nn no b">BN</code> ( <code class="fe nl nm nn no b">bn.js</code> ) API包含各种函数，包括算术运算、比较运算和位运算。一些函数以后缀<code class="fe nl nm nn no b">n</code>命名，这意味着操作数应该是原始数字类型。</p><p id="ef41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的示例代码中，<code class="fe nl nm nn no b">add()</code>、<code class="fe nl nm nn no b">div()</code>、<code class="fe nl nm nn no b">sub()</code>、<code class="fe nl nm nn no b">eq()</code>等正常命名的函数采用<code class="fe nl nm nn no b">BN</code>类型操作数，而<code class="fe nl nm nn no b">addn()</code>、<code class="fe nl nm nn no b">divn()</code>、<code class="fe nl nm nn no b">muln()</code>、<code class="fe nl nm nn no b">eqn()</code>等以后缀<code class="fe nl nm nn no b">n</code>命名的函数采用本原数类型操作数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="823b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1] <a class="ae lw" href="https://ethdocs.org/en/latest/ether.html" rel="noopener ugc nofollow" target="_blank">以太</a><br/>【2】<code class="fe nl nm nn no b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" rel="noopener ugc nofollow" target="_blank">Number.MAX_SAFE_INTEGER</a></code><br/>【3】<a class="ae lw" href="https://github.com/ethereum/web3.js/" rel="noopener ugc nofollow" target="_blank">web 3 . js</a>:以太坊javascript API<br/>【4】<a class="ae lw" href="https://github.com/indutny/bn.js/" rel="noopener ugc nofollow" target="_blank">bn . js</a>:纯JavaScript中的BigNum<br/><a class="ae lw" href="https://mikemcl.github.io/bignumber.js/" rel="noopener ugc nofollow" target="_blank">【bignome . js</a>:任意精度算术的JavaScript库</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="40f4" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">随机测试数据</h1><p id="88c1" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">增加测试覆盖率和避免意外测试结果的最简单方法之一是使用随机测试数据。</p><p id="56b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个测试用例，用于检查在构造函数中指定的名称和符号是否设置正确，以及是否查询了令牌协定。如果令牌契约用硬编码值“RGB”设置名称字段，尽管这肯定是一个缺陷，但下面的测试用例无法找到它。测试用例意外地使用相同的文字“RGB”作为测试数据，因此测试不会失败。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0250" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了防止这样的意外结果，我们可以使用随机测试数据，如下例所示。⁴是一个JavaScript库，可以生成各种格式和约束的随机数据。一些随机函数被用来产生随机的句子和单词，或者从一个数组中选择一个元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="73c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一个示例中，随机生成用于将金额设置为mint ( <code class="fe nl nm nn no b">balance</code>)、将金额设置为transfer ( <code class="fe nl nm nn no b">delta</code>)以及将账户设置为sender和receiver(<code class="fe nl nm nn no b">sender</code>、<code class="fe nl nm nn no b">recipient</code>)。对于要转移的金额，<code class="fe nl nm nn no b">chance.bool({likelihood: 10})</code>用于边界条件(零金额)，在大约10%中进行尝试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ef7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Chance提供了超过80种不同类型或格式的功能，包括<code class="fe nl nm nn no b">number</code>、<code class="fe nl nm nn no b">text</code>、<code class="fe nl nm nn no b">date-time</code>、<code class="fe nl nm nn no b">location</code>等等。在每个函数中，可以通过选项设置详细的方面或约束。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bf7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1] <a class="ae lw" href="https://docs.microsoft.com/en-us/dynamics365/business-central/dev-itpro/developer/devenv-random-test-data" rel="noopener ugc nofollow" target="_blank">随机测试数据</a>(MSDN)<br/>【2】<a class="ae lw" href="https://en.wikipedia.org/wiki/Random_testing" rel="noopener ugc nofollow" target="_blank">随机测试</a>(维基百科)<br/>【3】<a class="ae lw" href="http://fluxens.com/unittesting.html" rel="noopener ugc nofollow" target="_blank">单元测试指南</a><br/>【4】<a class="ae lw" href="https://chancejs.com/index.html" rel="noopener ugc nofollow" target="_blank"/>:随机字符串、数字等的极简生成器。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="82bc" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">还原，事件</h1><p id="efe2" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">智能合约与外部系统异步交互，因此事务的结果不能由返回值传递。相反，会触发事件并发出交易收据。为了更彻底地确认智能协定是否按预期运行，智能协定测试应该验证触发的事件。智能合约测试还应该在失败的情况下检查设计的或预期的恢复，例如无效的输入值、权限不足、余额不足等等。</p><p id="e112" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要检查恢复或事件，发送交易后需要处理交易收据。代码可能有点冗长，所以如果有一个方便的函数会很有用。令我惊讶的是，Truffle测试框架没有提供。但是我们可以使用下面的库。</p><ul class=""><li id="a58a" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><a class="ae lw" href="https://github.com/rkalis/truffle-assertions" rel="noopener ugc nofollow" target="_blank">松露断言</a></li><li id="5766" class="ln lo iq kt b ku lx kx ly la lz le ma li mb lm ls lt lu lv bi translated"><a class="ae lw" href="https://github.com/OpenZeppelin/openzeppelin-test-helpers" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin测试助手</a></li></ul><p id="e350" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，这两个库提供了相似的特性。由于<a class="ae lw" href="https://openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>的名称值，首选后者。</p><p id="cfff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要使用OpenZeppelin测试助手⁴，需要导入<code class="fe nl nm nn no b"><a class="ae lw" href="https://www.npmjs.com/package/@openzeppelin/test-helpers" rel="noopener ugc nofollow" target="_blank">@openzeppelin/test-helpers</a></code>模块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="561c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe nl nm nn no b"><a class="ae lw" href="https://docs.openzeppelin.com/test-helpers/0.5/api#expect-revert" rel="noopener ugc nofollow" target="_blank">expectRevert</a>.unspecified()</code>函数来确认事务已经被一个失败的测试用例恢复。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="33cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要验证通过测试用例的事件，使用<code class="fe nl nm nn no b"><a class="ae lw" href="https://docs.openzeppelin.com/test-helpers/0.5/api#expect-event" rel="noopener ugc nofollow" target="_blank">expectEvent()</a></code>函数。可以确认包括参数名称和值的事件变元。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c4af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以指定索引，而不是事件参数名。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dbfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1]<code class="fe nl nm nn no b"><a class="ae lw" href="https://web3js.readthedocs.io/en/v1.2.9/web3-eth.html#gettransactionreceipt" rel="noopener ugc nofollow" target="_blank">web3.eth.getTransactionReceipt</a></code><br/>【2】<a class="ae lw" href="https://codeburst.io/deep-dive-into-ethereum-logs-a8d2047c7371" rel="noopener" target="_blank">深入以太坊日志</a><br/>【3】<a class="ae lw" href="https://github.com/OpenZeppelin/openzeppelin-test-helpers" rel="noopener ugc nofollow" target="_blank">open zeppelin测试助手源项目</a><br/>【4】<a class="ae lw" href="https://docs.openzeppelin.com/test-helpers/0.5/api" rel="noopener ugc nofollow" target="_blank">open zeppelin测试助手API参考</a></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="05b4" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">ECMAScript 8 (2017)</h1><p id="4661" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">JavaScript从诞生到现在已经有相当一段时间了，而且还在快速进化。JavaScript由ECMAScript标准化，自2015年以来，每年都发布新版本的规范。</p><p id="6db8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了更有效地处理Truffle测试程序，选择包含有用测试特性的正确JavaScript版本是很重要的。</p><p id="694a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript本质上是异步的。大多数框架和库，包括web3.js和<a class="ae lw" href="https://www.trufflesuite.com/docs/truffle/reference/contract-abstractions" rel="noopener ugc nofollow" target="_blank"> Truffle契约抽象</a>，都是异步运行的。用异步进程处理回调或承诺的编程流可能对性能有益，但它们可能更复杂和困难。对于测试程序来说，可读性和易用性可能比优化或性能更重要。</p><p id="12fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nl nm nn no b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function" rel="noopener ugc nofollow" target="_blank">async</a></code> / <code class="fe nl nm nn no b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">await</a></code> ⁴语句支持异步函数的同步流，因此代码可以避免回调堆栈。<code class="fe nl nm nn no b">await</code>语句仅在<code class="fe nl nm nn no b">async</code>块中有效。在Truffle测试的情况下，<code class="fe nl nm nn no b">it()</code>函数的第二个参数将是<code class="fe nl nm nn no b">async</code>函数，然后在测试函数内部进行<code class="fe nl nm nn no b">await</code>调用。</p><p id="b6bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的示例显示了对令牌契约(<code class="fe nl nm nn no b">Token.new</code>、<code class="fe nl nm nn no b">token.mint</code>、<code class="fe nl nm nn no b">token.totalSupply</code>、<code class="fe nl nm nn no b">token.transfer</code>)的所有调用都是在<code class="fe nl nm nn no b">async</code>函数(<code class="fe nl nm nn no b">async() =&gt; {}</code>)内的<code class="fe nl nm nn no b">await</code>。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="feac" class="nv mp iq no b gy nw nx l ny nz">it("...", <strong class="no ir">async() =&gt; {<br/>  </strong>const chance = new Chance();<br/>  const admin = chance.pickone(accounts);<br/>  const token = <strong class="no ir">await Token.new</strong>('Color Token', 'RGB', {from: admin})<strong class="no ir">;</strong></span><span id="1457" class="nv mp iq no b gy oa nx l ny nz">  let balance = 0;<br/>  for(const acct of accounts){<br/>    balance = toBN(1E19).muln(chance.natural({min:1,max:100}));<br/>    <strong class="no ir">await token.mint</strong>(acct, balance, {from: admin});<br/>  } </span><span id="c93a" class="nv mp iq no b gy oa nx l ny nz">  const total = <strong class="no ir">await token.totalSupply</strong>();<br/>  <br/>  const loops = 20;<br/>  let sender = 0, recipient = 0, delta = 0;<br/>  for(let i = 0; i &lt; loops; i++){<br/>    sender = chance.pickone(accounts);<br/>    recipient = chance.pickone(accounts);<br/>    delta = toBN(1E13).muln(chance.natural({min:0,max:100}));</span><span id="70f0" class="nv mp iq no b gy oa nx l ny nz">    <strong class="no ir">await token.transfer</strong>(recipient, delta, {from: sender});<br/>    assert.isTrue((<strong class="no ir">await token.totalSupply</strong>()).eq(total));<br/>  }<br/>});</span></pre><p id="d74d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中，使用<code class="fe nl nm nn no b">var</code>关键字的变量声明具有不寻常的语义，比如函数作用域和hoisting⁵.这在其他编程语言中并不常见，即使是简单的代码也会让非本地JavaScript程序员感到沮丧。ECMAScript 6于2015年发布，引入了<code class="fe nl nm nn no b">const</code> ⁶和<code class="fe nl nm nn no b">let</code> ⁷语句来补偿<code class="fe nl nm nn no b">var</code>的那些意外影响。使用<code class="fe nl nm nn no b">const</code>和<code class="fe nl nm nn no b">let</code>的变量声明有块作用域，没有hoisting⁸.在scene⁹.后面，吊装实际上可能更复杂但是<code class="fe nl nm nn no b">const</code>和<code class="fe nl nm nn no b">let</code>与<code class="fe nl nm nn no b">var</code>相比几乎没有提升。因此，如果打算进行功能范围或提升，强烈建议使用<code class="fe nl nm nn no b">const</code>和<code class="fe nl nm nn no b">let</code>。</p><p id="d353" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使变量声明和使用更不容易出错，还建议使用严格模式⁰。在<code class="fe nl nm nn no b">contract()</code>函数的开始行添加<code class="fe nl nm nn no b">'use strict'</code>文字就足够了。这条简单的线将删除许多容易出错的旧功能，让您感觉更舒服。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="5145" class="nv mp iq no b gy nw nx l ny nz"><strong class="no ir">contract</strong>("ERC20Regular Contract Test Suite", async accounts =&gt; {<br/>  <br/>  <strong class="no ir">"use strict";</strong><br/>  <br/>  if(accounts.length &gt; 8){  // avoid too many accounts<br/>    accounts = (new Chance()).pickset(accounts, 8);<br/>  }</span><span id="017a" class="nv mp iq no b gy oa nx l ny nz">  ...<br/>)};</span></pre><p id="a04b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ECMAScript 8中增加了<code class="fe nl nm nn no b">async</code> / <code class="fe nl nm nn no b">await</code>语句，ECMAScript 6中增加了<code class="fe nl nm nn no b">const</code> / <code class="fe nl nm nn no b">let</code>语句。支持ECMAScript 8的Node.js 9.11.2或更高版本几乎完全推荐使用这些语句。</p><p id="5fb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1] <a class="ae lw" href="https://en.wikipedia.org/wiki/ECMAScript#Versions" rel="noopener ugc nofollow" target="_blank"> ECMAScript版本</a><br/>【2】<a class="ae lw" href="https://www.w3schools.com/js/js_versions.asp" rel="noopener ugc nofollow" target="_blank">JavaScript版本</a><br/>【3】<code class="fe nl nm nn no b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function" rel="noopener ugc nofollow" target="_blank">async</a></code><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function" rel="noopener ugc nofollow" target="_blank">语句</a><br/>【4】<code class="fe nl nm nn no b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">await</a></code><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">语句</a><br/>【5】<a class="ae lw" href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" rel="noopener ugc nofollow" target="_blank">JavaScript作用域和提升</a><br/>【6】<code class="fe nl nm nn no b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">const</a></code><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">语句</a><br/>【7】<code class="fe nl nm nn no b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank">let</a></code><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank">语句</a><br/>【8】</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="0d55" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">加纳切CLI</h1><p id="6b12" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">单元测试可能会非常乏味，所以一个快速执行的测试环境是必要的。特别是以太坊，需要一个尽可能与mainnet相同的环境，但是需要一个一致的算法而不是PoW。智能契约单元测试基本上独立于共识算法。作为测试环境，最好使用带有PoA的测试网，如Rinkeby或Kovan，或者本地独立以太坊客户端(节点)实现，如<a class="ae lw" href="https://github.com/trufflesuite/ganache" rel="noopener ugc nofollow" target="_blank"> Ganache </a>或<a class="ae lw" href="https://github.com/trufflesuite/ganache-cli" rel="noopener ugc nofollow" target="_blank"> Ganache CLI </a>。</p><p id="84f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Ganache CLI开发时间长，运行速度快，并提供各种可配置选项，这使得它在测试环境中非常有用。</p><p id="c58f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下命令行将启动适用于智能合约单元测试的Ganache CLI实例。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="217b" class="nv mp iq no b gy nw nx l ny nz">ganache-cli --networkId 31 \<br/>    --host '127.0.0.1' --port 8545 \<br/>    --gasPrice 2.5E10 --gasLimit 4E8 \<br/>    <strong class="no ir">--deterministic</strong> \<br/>    <strong class="no ir">--defaultBalanceEther 10000</strong> <strong class="no ir">--accounts 10</strong> --secure \<br/>    --unlock 0 --unlock 1 --unlock 2 --unlock 3 --unlock 4 \<br/>    --hardfork 'petersburg' \<br/>    <strong class="no ir">--blockTime 0</strong> \<br/>    --db '/var/lib/ganache-cli/data' &gt;&gt; /var/log/ganache.log 2&gt;&amp;1</span></pre><p id="2fc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">[1] <a class="ae lw" href="https://github.com/trufflesuite/ganache-cli#options" rel="noopener ugc nofollow" target="_blank"> Ganache CLI选项</a></p></div></div>    
</body>
</html>