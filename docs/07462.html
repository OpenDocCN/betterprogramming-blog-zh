<html>
<head>
<title>How To Create Custom Classes in Python Without Going Meta</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不使用元的情况下用Python创建自定义类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-custom-classes-in-python-without-going-meta-5e8bfa97be6e?source=collection_archive---------2-----------------------#2021-01-18">https://betterprogramming.pub/how-to-create-custom-classes-in-python-without-going-meta-5e8bfa97be6e?source=collection_archive---------2-----------------------#2021-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在不使用元类的情况下使用Python元类的能力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eae73bd289751e52c29cf6ccd8c00bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z3zoN804DKWzRxMz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@z734923105?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张杰瑞</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="24a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Python元类非常强大，可以让你做非常漂亮的事情。其中一件很棒的事情就是定制类的创建。通过定制的类创建，你可以，例如，实现一个插件系统或者动态设置属性的默认值。</p><p id="8cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，使用元类不仅非常强大，而且是Python的一个更高级(有时也很乏味)的概念。而且，即使您是Python之神，您可能仍然会遇到元类的问题，并且会这样想…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">糊涂狗的Gif。</p></figure><p id="f3bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，从具有不同元类的多个类继承是行不通的，因为这会导致元类冲突。解决元类冲突的唯一方法是通过人工干预，这可能非常困难——就像脑外科手术一样。如果您正在使用的库的新版本中引入了元类，情况会变得更糟。突然间，什么都不能工作了，你必须深入库代码的细节来解决这个冲突。这听起来不太好。</p><p id="392c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，问题是:库开发人员和Python新手开发人员如何享受定制类创建的好处，而不用担心破坏东西？</p><p id="d0bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.python.org/dev/peps/pep-0487/" rel="noopener ugc nofollow" target="_blank"> PEP-487 </a>和Python 3.6+来救场。</p><p id="92bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将向您简要介绍PEP-487中介绍的python中的定制类创建，并提供一个如何使用它创建简单插件系统的小示例。</p><p id="47b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你准备好了吗？让我们开始吧。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="56c0" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">定制类创建</h1><p id="fd20" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">假设您想要构建一个应用程序，在该应用程序中，人们可以与不同种类的云数据仓库(DWH)进行对话，如<a class="ae ky" href="https://cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>、<a class="ae ky" href="https://aws.amazon.com/reshift" rel="noopener ugc nofollow" target="_blank"> Redshift </a>或<a class="ae ky" href="https://www.snowflake.com/" rel="noopener ugc nofollow" target="_blank"> Snowflake </a>。对于这个例子，假设所有的DWH都有不同的建立连接的方式，这对于每个DWH来说是非常特定的。用户应该能够从所有可用的列表中选择他们想要连接的DWH。</p><h2 id="1822" class="nb mf it bd mg nc nd dn mk ne nf dp mo li ng nh mq lm ni nj ms lq nk nl mu nm bi translated">不太好的解决方案</h2><p id="eca3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">实现这一点的一种方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn lw l"/></div></figure><p id="2e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里做了什么？我添加了一个<code class="fe no np nq nr b">warehouse </code>基类，它实现了泛型方法，并强制子类实现connect方法。使用它，我实现了<code class="fe no np nq nr b">BigQuery</code>、<code class="fe no np nq nr b">Redshift</code>和<code class="fe no np nq nr b">Snowflake</code>的子类。我把这些类类型作为值放入字典，它们各自的名字作为键。最后，<code class="fe no np nq nr b">get_connected_warehouse</code>方法获取用户想要连接的<code class="fe no np nq nr b">warehouse</code>的名称，在字典中查找，并返回连接的<code class="fe no np nq nr b">warehouse</code>。完成了。</p><p id="6b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案当然有效，但是它有两个缺点。</p><ol class=""><li id="e490" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">当有人想要添加一种新类型的数据仓库时，他们必须知道必须将它添加到<code class="fe no np nq nr b">warehouses</code>字典中。</li><li id="24c0" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">当我们通过一个库提供这个功能时，扩展这个字典变得更加麻烦。</li></ol><p id="1e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们可以自动注册新的仓库子类而不是手动添加它们，那不是很好吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">男性尖叫的Gif，“是！”</p></figure><p id="a6eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是定制类创建发挥作用的地方。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="8a70" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">更好的解决方案</h1><p id="7bd3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">让我们从上面重写代码。记住，我们的目标是以某种方式自动注册我们的子类。事不宜迟，我们可以这样做。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn lw l"/></div></figure><p id="2f68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里改变了什么？首先，我在<code class="fe no np nq nr b">Warehouse </code>基类中添加了一个<code class="fe no np nq nr b">registry </code>作为类变量。这个<code class="fe no np nq nr b">registry </code>最终将包含<code class="fe no np nq nr b">Warehouse</code>的所有子类。为了方便起见，我还添加了一个类方法<code class="fe no np nq nr b">get</code>，通过名称从<code class="fe no np nq nr b">registry </code>中检索类对象。但是子类如何进入注册表呢？</p><p id="c585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际的魔法发生在类方法<code class="fe no np nq nr b">__init_subclass__</code>中。当您的Python解释器第一次读取您的类定义代码时，这个方法被调用一次。当您导入类本身或导入定义它的模块时，就会出现这种情况。因为它是一个类方法，所以它获取<code class="fe no np nq nr b">class </code>对象作为参数。因此，这是一个完美的地方来做一些你想在每种类上运行一次的逻辑。</p><p id="5f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们来说，这意味着我们可以将参数<code class="fe no np nq nr b">cls</code>给出的<code class="fe no np nq nr b">class </code>对象添加到我们的注册表中。我们还强迫开发人员给这个类起一个某种类型的名字，你可以从关键字参数中看到。这是不必要的，因为我们也可以使用类似于<code class="fe no np nq nr b">cls.__name__</code>的东西来标识我们的<code class="fe no np nq nr b">Warehouse </code>类型。然而，我想展示的是，您还可以向<code class="fe no np nq nr b">__init_subclass__</code>传递更多的关键字参数，您可以使用它们来设置/添加类属性。最后，请注意，您不必显式地将类方法<code class="fe no np nq nr b">decorator </code>添加到该函数中。这是为你含蓄地做的。</p><p id="26c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。如果您只想运行一些小的<code class="fe no np nq nr b">pre init</code>代码，就不需要为元类而烦恼。现在你可以做你想做的:使用多重继承，潜在地为更高级的东西添加一个元类，等等。所有这些都不用担心会遇到冲突或元类冲突。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跳舞漫画的Gif。</p></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="e76b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">包裹</h1><p id="f2ea" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在本文中，我介绍了如何使用Python中的<code class="fe no np nq nr b">__init_subclass__</code>在创建类之前轻松执行逻辑，而不必使用元类。</p><p id="0f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与使用元类相比，这种方法的优势在于:</p><ol class=""><li id="88c2" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">更容易理解和学习</li><li id="514e" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">避免元类冲突和麻烦</li></ol><p id="1cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您关注这篇文章。一如既往，如有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>