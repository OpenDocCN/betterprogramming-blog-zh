<html>
<head>
<title>How To Use AutoML on Google Cloud’s Vertex AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Google Cloud的Vertex AI上使用AutoML</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-automl-on-google-clouds-vertex-ai-27f8778239ea?source=collection_archive---------8-----------------------#2021-06-17">https://betterprogramming.pub/how-to-use-automl-on-google-clouds-vertex-ai-27f8778239ea?source=collection_archive---------8-----------------------#2021-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7244" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定制培训的替代方案:AutoML——从头构建一个伟大的模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7f24184c590a836fd8c2242d7b8f420d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*aeXlwnOS3DvVHiMVgBZbpQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">顶点AI(来源:<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">谷歌云</a>)</p></figure><h1 id="2b7c" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">顶点AI教程系列</h1><ol class=""><li id="a87d" class="ln lo it lp b lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330">在谷歌云的顶点人工智能上训练模型的逐步指南</a></li><li id="57de" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595">在谷歌云的顶点人工智能上调整模型的逐步指南</a></li><li id="1b38" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-operationalize-a-model-on-google-clouds-vertex-ai-53298b530703">如何在谷歌云的顶点人工智能上操作模型</a></li><li id="1553" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated">如何在谷歌云的Vertex AI上使用AutoML(本文)</li><li id="23fd" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-bigquery-ml-on-google-clouds-vertex-ai-23b1ca0b635">如何在Google Cloud的Vertex AI上使用big query ML</a></li><li id="e657" class="ln lo it lp b lq mf ls mg lu mh lw mi ly mj ma mb mc md me bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-pipeline-on-google-clouds-vertex-ai-863b429c811f">如何在Google Cloud的Vertex AI上使用Pipeline</a></li></ol><h1 id="e61f" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">背景</h1><p id="66de" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">在本系列的<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-train-a-model-on-google-clouds-vertex-ai-47faafae1330"> part 1 </a>、<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595"> part 2 </a>和<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-operationalize-a-model-on-google-clouds-vertex-ai-53298b530703"> part 3 </a>中，我们从零开始，训练了一个自定义模型，对其进行了优化，并将其部署在<a class="ae ku" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank"> Vertex AI </a>上，以服务于在线预测。这是一个相当长的旅程，但仍然相对简单。然而，在现实中，我们可能会在模型训练和优化阶段停留数月，因为为现实世界的问题找到最佳的模型结构和训练方案可能非常具有挑战性。</p><p id="0057" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">AutoML 是谷歌云解决这一挑战的尝试。AutoML允许用户以无代码的方式引导模型创建。它基于典型数据类型和机器学习任务的预训练模型，如图像分类、文本实体提取、视频对象跟踪、表格回归等。用户只需提供训练数据，并指示AutoML对预训练模型进行微调，以“适应”它们。</p><p id="1514" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">在本文中，我们将探索使用AutoML来解决我们在以前的文章中已经解决的相同的图像分类问题。简单回顾一下，我们一直在使用的数据集是<a class="ae ku" href="https://www.tensorflow.org/datasets/catalog/cifar10" rel="noopener ugc nofollow" target="_blank"> CIFAR10 </a>，它包含10个类的60，000张32x32的图像。</p><h1 id="a27b" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">准备数据</h1><p id="1d60" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">首先，我们需要准备数据。与第一篇文章一样，我们需要以一种易于下游消费的形式获取数据。我们还需要将它放在谷歌云存储(GCS)上，以便Vertex AI可以访问它。对于AutoML，普通的JPEG图像就可以了。但是我们需要一个元数据文件来告诉AutoML这些图像的GCS位置、它们的标签和它们的分割。这里的一个额外问题是，来自Tensorflow数据集目录的CIFAR10数据集是在TFRecords中编码的。所以我们需要把它们提取出来，保存为普通的JPEG图像。</p><p id="3a30" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">有关详细信息，请参见下面的代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">数据准备代码</p></figure><p id="0fd4" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">除了提取和保存JPEG图像，上面的代码还创建了一个<code class="fe ne nf ng nh b">metadata.jsonl</code>文件，其中包含如下记录。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="231f" class="nm kw it nh b gy nn no l np nq">{“imageGcsUri”:”GCS_PATH_FOR_DATA/train_123.jpeg”, “classificationAnnotation”: {“displayName”: “horse”}, “dataItemResourceLabels”: {“aiplatform.googleapis.com/ml_use”: train}}</span><span id="4c07" class="nm kw it nh b gy nr no l np nq">{“imageGcsUri”:”GCS_PATH_FOR_DATA/validation_456.jpeg”, “classificationAnnotation”: {“displayName”: “ship”}, “dataItemResourceLabels”: {“aiplatform.googleapis.com/ml_use”: validation}}</span><span id="847c" class="nm kw it nh b gy nr no l np nq">{“imageGcsUri”:”GCS_PATH_FOR_DATA/test_789.jpeg”, “classificationAnnotation”: {“displayName”: “truck”}, “dataItemResourceLabels”: {“aiplatform.googleapis.com/ml_use”: test}}</span></pre><p id="d9a0" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated"><strong class="lp iu">这里要非常小心:</strong>写的时候顶点AI <a class="ae ku" href="https://cloud.google.com/vertex-ai/docs/datasets/prepare-image" rel="noopener ugc nofollow" target="_blank">文档</a>错了。这个字段叫做<code class="fe ne nf ng nh b">classificationAnnotation</code>，根据他们的模式，它是一个单一的对象字段。但是文档上提供的例子说它叫做<code class="fe ne nf ng nh b">classificationAnnotations</code>，它是一个对象列表。在遵循文档中的例子时，我得到了一个<code class="fe ne nf ng nh b">Cannot find field: classificationAnnotations</code>错误。这个错误给我造成了一个小时的调试时间。</p><p id="bdc4" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">一旦创建了JPEG图像和元数据，使用<code class="fe ne nf ng nh b">gsutil</code>将它们上传到<code class="fe ne nf ng nh b">GCS_PATH_FOR_DATA</code>位置。请注意，您可能无法使用通配符匹配在一个命令中上传所有这些内容，因为这超过了参数长度<code class="fe ne nf ng nh b">gsutil</code>。您可能需要多次运行<code class="fe ne nf ng nh b">gsutil</code>命令，手动选择要上传的文件子集。</p><h1 id="f010" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">实例化顶点人工智能数据集</h1><p id="5139" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">现在数据在Google云存储上，我们需要创建一个相应的数据集。这一步很简单。</p><p id="a6f5" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">直接调用Vertex AI的Dataset API来创建一个空数据集，该数据集返回一个数据集ID，我们将在后续命令中用到它。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="6eba" class="nm kw it nh b gy nn no l np nq">curl -X POST \<br/>-H "Authorization: Bearer "$(gcloud auth application-default print-access-token) \<br/>-H "Content-Type: application/json; charset=utf-8" \<br/>-d '{"display_name": "cifar10","metadata_schema_uri": "gs://google-cloud-aiplatform/schema/dataset/metadata/image_1.0.0.yaml"}' \<br/>https://us-central1-aiplatform.googleapis.com/v1/projects/PROJECT_ID/locations/us-central1/datasets</span></pre><p id="f23e" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">然后将我们在GCS中准备的数据导入到这个数据集，它返回一个导入操作ID。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="6596" class="nm kw it nh b gy nn no l np nq">curl -X POST \<br/>-H "Authorization: Bearer "$(gcloud auth application-default print-access-token) \<br/>-H "Content-Type: application/json; charset=utf-8" \<br/>-d '{"import_configs":[{"gcs_source":{"uris":"GCS_PATH_FOR_DATA/metadata.jsonl"},"import_schema_uri":"gs://google-cloud-aiplatform/schema/dataset/ioformat/image_classification_single_label_io_format_1.0.0.yaml"}]}' \<br/>https://us-central1-aiplatform.googleapis.com/v1/projects/PROJECT_ID/locations/us-central1/datasets/DATASET_ID:import</span></pre><p id="5fab" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">进口需要半个小时。我们可以使用以下命令来轮询导入状态。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="4baa" class="nm kw it nh b gy nn no l np nq">curl \<br/>-H "Authorization: Bearer "$(gcloud auth application-default print-access-token) \<br/>https://us-central1-aiplatform.googleapis.com/v1/projects/PROJECT_ID/locations/us-central1/datasets/DATASET_ID/operations/IMPORT_OPERATION_ID</span></pre><p id="03ee" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们还可以在UI上检查状态，但是当我们在导入过程中遇到错误时，上面的命令行会变得非常有用。上述命令将从导入中返回示例错误消息。在撰写本文时，没有其他方法可以获得详细信息。我用它发现了前面提到的<code class="fe ne nf ng nh b">classificationAnnotations</code> bug。尽管有这些错误，导入仍然被标记为成功，但是数据集实际上是空的，因为所有元数据实例都无法解析。</p><p id="1879" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">修复错误后，我们能够导入数据集。我们可以在UI: Vertex AI -&gt; Dataset上检查数据集是否在那里，并且附加了导入结果。当我们点击导入结果时，我们看到我们的数据在那里。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/c86d03bcbd3b9f0675180d8e513b5515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zs2WTbb-N-pQHH8uK47skQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">数据集概述</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nx"><img src="../Images/ac0fbd023bd067fd8bcffa42d7cb5819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n__3Z7iuX82Oo6RoQm4wng.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">数据集导入结果</p></figure><h1 id="9fa9" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">启动培训</h1><p id="f0c2" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">我们现在可以开始AutoML培训了。我们使用下面的curl命令启动训练管道。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="c731" class="nm kw it nh b gy nn no l np nq">curl -X POST \<br/>-H "Authorization: Bearer "$(gcloud auth application-default print-access-token) \<br/>-H "Content-Type: application/json; charset=utf-8" \<br/>-d @automl.json \<br/>https://us-central1-aiplatform.googleapis.com/v1/projects/PROJECT_ID/locations/us-central1/trainingPipelines</span></pre><p id="3a3f" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">请求的核心内容在<code class="fe ne nf ng nh b">automl.json</code>文件中，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">自动请求</p></figure><p id="4c3e" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">大多数自动化要求都是机械性的。关键部分是<code class="fe ne nf ng nh b">filterSplit</code>，它详细描述了数据集用于训练、验证和测试的部分。它对应于之前在准备数据部分介绍的<code class="fe ne nf ng nh b">dataItemResourceLabels</code>。值得注意的一件有趣的事情是，即使我们在数据准备中将训练的<code class="fe ne nf ng nh b">aiplatform.googleapis.com/ml_use</code>标签设置为“训练”，我们实际上需要过滤“训练”否则，管道找不到训练数据集。</p><p id="62d6" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">另一个值得注意的领域是<code class="fe ne nf ng nh b">budgetMilliNodeHours</code>。它决定了花费在该训练上的计算预算。我把它设置为16000。培训管道在30分钟内完成。</p><p id="6870" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">我们导航到UI:Vertex AI-&gt; Training-&gt; Training Pipeline查看管道，并单击管道转到已训练的模型。训练好的模型也会上传到Vertex AI。所以我们可以在UI中找到它:顶点AI -&gt;模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ny"><img src="../Images/a5b75f854eddc1dc841f73d5546df63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Su-c-Z8uKuXrOGDXYROBnQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">自动管道</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nz"><img src="../Images/8febaaad85ed96e72cd05c0e4a79c972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YTBQcyoKmAeLSegTp6m_GA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">模型训练30分钟的结果</p></figure><p id="25e0" class="pw-post-body-paragraph mk ml it lp b lq mx ju mm ls my jx mn lu mz mp mq lw na ms mt ly nb mv mw ma im bi translated">经训练的模型报告在精确度/召回率和混淆矩阵方面的表现。由于数据集是完全平衡的，所以精度只是混淆矩阵中对角线元素的平均值。模型精度(平均对角线值)为85%，这比我们在之前的<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/a-step-by-step-guide-to-tune-a-model-on-google-clouds-vertex-ai-afd2e72af595"> part 2文章</a>中获得的定制模型(精度:74%)要好得多。这一点也不奇怪，因为我预计在AutoML培训中会用到很多先进的技术。我们还可以指定更大的计算预算，并训练具有更好性能的模型(准确率:93%)。吸取的教训:不要重新发明轮子；总是先尝试AutoML。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oa"><img src="../Images/045d2091b18330c209e669607ee9c3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D187IUq58Ag_AAxFqryphg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">模型训练24小时的结果</p></figure><h1 id="72f8" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">包裹</h1><p id="b4b8" class="pw-post-body-paragraph mk ml it lp b lq lr ju mm ls lt jx mn lu mo mp mq lw mr ms mt ly mu mv mw ma im bi translated">我们已经展示了如何以(几乎)无代码的方式从AutoML获得一个训练好的模型。我们可以按照<a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-operationalize-a-model-on-google-clouds-vertex-ai-53298b530703">第三部分文章</a>部署模型进行在线预测。这里就不赘述了。再见，下次见。</p></div></div>    
</body>
</html>