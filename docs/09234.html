<html>
<head>
<title>Write Better Swift Code With With()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用With()编写更好的Swift代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-swift-with-with-4b071b5ac394?source=collection_archive---------0-----------------------#2021-08-01">https://betterprogramming.pub/better-swift-with-with-4b071b5ac394?source=collection_archive---------0-----------------------#2021-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9098" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将类似Kotlin的功能模式引入您的Swift工具包</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9aa34c83f7eed0c43ed6055e7f5a793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZlrQCBg54IwppWUD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·沃德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eaea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都写过需要一些函数来创建和返回一个配置好的对象的代码。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="de2d" class="ma mb it lw b gy mc md l me mf">func makeButton(_ title: String?) -&gt; UIButton {<br/>    let button = UIButton()<br/>    button.translatesAutoresizingMaskIntoConstraints = false<br/>    button.titleLabel?.text = title<br/>    button.titleLabel?.font = .headline<br/>    button.setTitleColor(.red, for: .normal)<br/>    return button<br/>}</span></pre><p id="3fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模式是一样的。用我们需要的东西创建一个变量。配置它。然后返回变量。</p><p id="e18b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是上面代码中的<code class="fe mg mh mi lw b">button</code>变量和返回语句很大程度上是样板文件，在每一行中指定<code class="fe mg mh mi lw b">button</code>实际上只是视觉噪音，因为它倾向于隐藏代码实际设置的实际配置选项。</p><p id="9fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能做得更好吗？</p><h1 id="4c32" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">科特林来救援了。</h1><p id="da33" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">Kotlin在语言中有一个<code class="fe mg mh mi lw b">with</code>构造，可以让你用lambdas做以下事情...</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9b7f" class="ma mb it lw b gy mc md l me mf">return with(Obj()) {<br/>   objMethod1()<br/>   objMethod2()<br/>   this<br/>}</span></pre><p id="5237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，最后一行中的<code class="fe mg mh mi lw b">this</code>语句是完成我们想要的任务所必需的，否则，lambda将返回最后一个执行的语句返回的任何结果，在本例中是<code class="fe mg mh mi lw b">objMethod2</code>。</p><p id="0941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都很酷。而且干净。唯一的问题是，我们不在Swift编译器团队中，我们不能简单地到处给Swift添加新的语句类型。</p><h1 id="0214" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用()</h1><p id="0c18" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们不能添加自己的语句，但是我们<em class="nf">可以</em>添加自己的函数。</p><p id="7c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们定义一个全局函数，它接受我们想要配置的对象，用配置闭包修改它，然后返回结果，会怎么样？</p><p id="b666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的函数会让我们做这样的事情…</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3857" class="ma mb it lw b gy mc md l me mf">func makeButton(_ title: String?) -&gt; UIButton {<br/>    with(UIButton()) {<br/>        $0.translatesAutoresizingMaskIntoConstraints = false<br/>        $0.titleLabel?.text = title<br/>        $0.titleLabel?.font = .headline<br/>        $0.setTitleColor(.red, for: .normal)<br/>    }<br/>}</span></pre><p id="0148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当接近，尽管我们仍然需要未命名的参数<code class="fe mg mh mi lw b">$0</code>来让Swift高兴。</p><p id="b14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将参数命名如下，但是出于某种原因，我发现未命名的参数版本更容易阅读。你自己看吧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3591" class="ma mb it lw b gy mc md l me mf">func makeButton(_ title: String?) -&gt; UIButton {<br/>    with(UIButton()) { b in<br/>        b.translatesAutoresizingMaskIntoConstraints = false<br/>        b.titleLabel?.text = title<br/>        b.titleLabel?.font = .headline<br/>        b.setTitleColor(.red, for: .normal)<br/>    }<br/>}</span></pre><p id="38b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用按钮名称作为前缀，您必须在思想上将点左侧的文本与点右侧的文本分开，而对于未命名的参数，我似乎在思想上“忽略”了<code class="fe mg mh mi lw b">$0</code>，这反过来使方法和函数文本名称更加突出。</p><p id="b3f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论哪种方式，我认为配置块都很突出，并且更容易看到和理解对象本身实际上设置了什么值。</p><h1 id="1df4" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">该功能</h1><p id="ef3f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><code class="fe mg mh mi lw b">with()</code>全局函数本身足够简单。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0271" class="ma mb it lw b gy mc md l me mf">@discardableResult<br/>@inlinable<br/>func with&lt;V&gt;(_ value: V, _ mutate: ((_ v: inout V) -&gt; Void)) -&gt; V {<br/>    var mutableValue = value<br/>    mutate(&amp;mutableValue)<br/>    return mutableValue<br/>}</span></pre><p id="0a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们接受一个通用值作为参数，将其传递给我们的配置函数，然后返回最终结果，这样用户就可以根据需要分配或返回它。</p><p id="2a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个变体使用了一个<code class="fe mg mh mi lw b">inout</code>参数，所以它同样适用于结构。如果您只打算在类中使用它，那么编写自己的性能更好的版本就足够简单了。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bd61" class="ma mb it lw b gy mc md l me mf">@discardableResult<br/>@inlinable<br/>public func With&lt;T:AnyObject&gt;(_ value: T, _ mutate: ((_ v: T) -&gt; Void)) -&gt; T {<br/>    mutate(value)<br/>    return value<br/>}</span></pre><p id="c43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将<code class="fe mg mh mi lw b">class</code>版本大写，以便与基于值的版本区分开来。如果你只是想简单地使用<code class="fe mg mh mi lw b">with</code>来配置一个现有的对象，那么这个函数的结果也是可以丢弃的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f263" class="ma mb it lw b gy mc md l me mf">with(myButtonOutlet) {<br/>   $0.titleLabel?.text = title<br/>   $0.titleLabel?.font = .headline<br/>   $0.setTitleColor(.red, for: .normal)<br/>}</span></pre><p id="501c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果这不是您计划使用的模式，您可以放弃它。</p><h1 id="1f97" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">作为函数参数内联</h1><p id="b3ff" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">您已经看到它被用作函数返回类型，但是当您需要创建并修改函数参数时,<code class="fe mg mh mi lw b">with</code>也很有用。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a41b" class="ma mb it lw b gy mc md l me mf">stackView.addArrangedSubview(with(UIButton()) {<br/>    $0.translatesAutoresizingMaskIntoConstraints = false<br/>    $0.titleLabel?.text = "My Button Title"<br/>    $0.titleLabel?.font = .headline<br/>    $0.setTitleColor(.red, for: .normal)<br/>})</span></pre><p id="d580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，不需要创建临时变量，这样就可以在将它作为参数传递之前修改它。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c1b0" class="ma mb it lw b gy mc md l me mf">let button = UIButton()<br/>button.translatesAutoresizingMaskIntoConstraints = false<br/>button.titleLabel?.text = title<br/>button.titleLabel?.font = .headline<br/>button.setTitleColor(.red, for: .normal)<br/>stackView.addArrangedSubview(button)</span></pre><h1 id="0656" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">不可变的值</h1><p id="f9e8" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">另一个用例是将一个完全配置的值赋给一个字母，这样它就不可改变了。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="638d" class="ma mb it lw b gy mc md l me mf">let user = with(User.mock) {<br/>    $0.addPhoneNumber("303-555-8686")<br/>}</span></pre><h1 id="4c86" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">主题变奏曲</h1><p id="1994" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">前面我提到过为对象编写自己的版本，但事实证明，直通配置函数模式在其他地方也很方便。</p><p id="b193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下返回UITableView中的单元格的代码。(这些行很长，为了清楚起见，我换成了gists。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="763f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们为<code class="fe mg mh mi lw b">UITableView</code>添加了一个扩展，使得正确类型的单元出列、适当地配置它们并在需要时返回它们变得容易。不需要临时变量或难看的类型转换来将出队类型转换为正确的配置类型。</p><p id="fa69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里唯一需要注意的是，单元格必须在单元格配置函数中显式类型化为<code class="fe mg mh mi lw b">MyTableViewCell</code>。它满足扩展函数本身所需的一般约束。</p><p id="87fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下所述。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="288a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果您的单元格不是传递的类型，您将得到一个未配置的单元格。但是，如果您手动将单元格出队并有条件地将<code class="fe mg mh mi lw b">UITableViewCell</code>强制转换为特定的单元格类型，您也会遇到同样的问题，在我看来这基本上是一种浪费。</p><p id="7b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样效果都一样。</p><h1 id="24e3" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">建设者</h1><p id="5616" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我还发现with模式在<a class="ae ky" href="https://github.com/hmlongco/Builder" rel="noopener ugc nofollow" target="_blank"> Builder </a>中很有帮助，这是我正在开发的基于UIKit的SwiftUI的替代方案，用于我还没有向有问题的视图添加特定修饰符的情况。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fd24" class="ma mb it lw b gy mc md l me mf">Label("Some text")<br/>    .font(.headline)<br/>    .color(.red)<br/>    .with {<br/>        $0.isUserInteractionEnabled = true<br/>    }</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="333e" class="mj mb it bd mk ml np mn mo mp nq mr ms jz nr ka mu kc ns kd mw kf nt kg my mz bi translated">完成块</h1><p id="2f90" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如前所述，passthrough配置函数模式是随手可得的一点代码。</p><p id="e7ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天就到这里吧。如果你觉得这有用，或者有其他很酷的用例，请告诉我。</p></div></div>    
</body>
</html>