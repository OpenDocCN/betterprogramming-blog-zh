<html>
<head>
<title>Part 1: Kotlin Coroutines for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第1部分:面向初学者的Kotlin协程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-coroutines-for-beginners-a54d7fedb206?source=collection_archive---------8-----------------------#2019-10-14">https://betterprogramming.pub/kotlin-coroutines-for-beginners-a54d7fedb206?source=collection_archive---------8-----------------------#2019-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6a9685b6f2f2192e2cf71e956598cfd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-aIFH0qMFFbcPcMJovHkA.png"/></div></div></figure><h2 id="7c4a" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph"># 100日代码的第27天</h2><div class=""/><div class=""><h2 id="aa69" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">管理后台线程的新方法</h2></div><figure class="lc ld le lf gt iv"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="e0e5" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">科特林协程是给开发者的礼物。它们通过减少对回调的需求来简化代码。它们是通过将异步回调从长时间运行的操作(如写入数据库)转换来实现的。</p><p id="71b9" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你来自其他编程背景，那么你可以联想到类似的东西是<code class="fe me mf mg mh b">async-await</code>的模式。</p><p id="434a" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看看下面的代码。我们使用回调，我们的代码在这里异步工作。<strong class="lk jo"> </strong>回调做工作，但它们并不完美。差远了。</p><ul class=""><li id="800e" class="mi mj je lk b ll lm lo lp lr mk lv ml lz mm md mn mo mp mq bi translated">当你可能在做一些嵌套的异步调用操作时，事情变得混乱，这很容易导致所谓的<em class="mr">回调地狱</em>。我看过，真的很丑。</li><li id="a5d0" class="mi mj je lk b ll ms lo mt lr mu lv mv lz mw md mn mo mp mq bi translated">如果不编写一些额外的代码，它们不会帮助您处理错误。</li></ul><p id="314d" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Kotlin协程解决了这些问题。</p><pre class="lc ld le lf gt mx mh my mz aw na bi"><span id="f622" class="nb nc je mh b gy nd ne l nf ng"><em class="mr">// Async callbacks</em><br/>networkRequest { response -&gt;<br/>   <em class="mr">// Successful network request</em><br/>   databaseSave(response) { rows -&gt;<br/>     <em class="mr">// Result saved</em><br/>   }<br/>}</span></pre><p id="cea5" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用协程，您可以将这种异步代码转换成顺序代码。</p><pre class="lc ld le lf gt mx mh my mz aw na bi"><span id="afad" class="nb nc je mh b gy nd ne l nf ng"><em class="mr">// The same code with coroutines</em><br/>val response = networkRequest()<br/><em class="mr">// Successful network request</em><br/>databaseSave(response)<br/><em class="mr">// Result saved</em></span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="63e4" class="no nc je bd np nq nr ns nt nu nv nw nx kt ny ku nz kw oa kx ob kz oc la od oe bi translated">为什么要担心主线程？</h1><p id="2052" class="pw-post-body-paragraph li lj je lk b ll of ko ln lo og kr lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">非常重要的是，我们永远不要阻塞Android中的主线程，因为主线程负责处理所有与UI相关的操作，如更新屏幕上的内容或处理用户交互。</p><p id="8fd5" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">主线程必须在不到16ms的时间内完成所有这些操作，以保持60FPS的屏幕刷新率，为用户提供流畅的体验。</p><p id="753b" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你阻塞主线程，UI会冻结，如果你阻塞的时间足够长，应用程序甚至会向用户显示应用程序没有响应的消息。你不会想参与的。</p><p id="85e0" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是Kotlin协程的伟大之处，它们使您的代码<em class="mr">是主安全的。</em>直接从主线程中随意调用任何长时间运行的操作，比如网络请求，而不必担心阻塞主线程。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="cd6d" class="no nc je bd np nq nr ns nt nu nv nw nx kt ny ku nz kw oa kx ob kz oc la od oe bi translated">协程在内部是如何工作的？</h1><p id="945d" class="pw-post-body-paragraph li lj je lk b ll of ko ln lo og kr lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">先来看看大图。</p><p id="30e7" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Kotlin使用挂起函数，可以在不阻塞主线程的情况下挂起。这和封杀有什么区别？</p><p id="3b29" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当某个进程由于某种外部原因而无法重新启动时，它就会被阻塞；例如，I/O设备不可用或信号量文件被锁定。</p><p id="f6d5" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个进程被挂起意味着操作系统已经停止执行它，但这可能只是为了时间片(多任务)。这并不意味着这个过程不能立即恢复。</p><p id="d8b1" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们使用<code class="fe me mf mg mh b">suspend</code>关键字使一个函数成为挂起函数。这里，举以下例子:</p><pre class="lc ld le lf gt mx mh my mz aw na bi"><span id="7e66" class="nb nc je mh b gy nd ne l nf ng">suspend fun getLatestData() {<br/>    val latestUpdates = networkRequest()<br/>    display(latestUpdates)<br/>}</span><span id="437c" class="nb nc je mh b gy ok ne l nf ng">suspend fun networkRequest() {<br/>    ...<br/>}</span></pre><p id="0df7" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">getLatestData()</code>和<code class="fe me mf mg mh b">networkRequest()</code>都被定义为暂停功能，因为<code class="fe me mf mg mh b">getLatestData()</code>必须等待<code class="fe me mf mg mh b">networkRequest()</code>返回响应。因此，你可以注意到一个挂起函数只能被另一个挂起函数调用。</p><p id="1b76" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你的主线程调用<code class="fe me mf mg mh b">networkRequest()</code>时，它将挂起主线程的<code class="fe me mf mg mh b">networkRequest()</code>，因此主线程将继续执行它的任务。每当<code class="fe me mf mg mh b">networkRequest</code>结果准备好了，主线程将继续顺序执行函数，而不是发送传统的回调到主线程。</p><p id="3e67" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">suspend</code>和<code class="fe me mf mg mh b">resume</code>正在取代回调的需要。因此，这就是挂起函数不阻塞主线程的工作方式。另外，<code class="fe me mf mg mh b">suspend</code>关键字没有指定代码应该在哪个线程上运行。它可以是主线程，也可以是后台线程。</p><p id="587d" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们回到他们内部是如何工作的。</p><p id="3a88" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">回到例子:</p><pre class="lc ld le lf gt mx mh my mz aw na bi"><span id="fd46" class="nb nc je mh b gy nd ne l nf ng">suspend fun getLatestData() {<br/>    val latestUpdates = networkRequest()<br/>    display(latestUpdates)<br/>}</span><span id="553e" class="nb nc je mh b gy ok ne l nf ng">suspend fun networkRequest() {<br/>    ...<br/>}</span></pre><p id="c419" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的主线程点击第<code class="fe me mf mg mh b">getLatestData()</code>行，并将其添加到主线程中，就像任何其他顺序函数一样。然后，它按顺序执行函数内部，直到任何其他挂起函数出现。</p><p id="477f" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此时，我们点击了<code class="fe me mf mg mh b">networkRequest()</code>暂停功能。现在，<code class="fe me mf mg mh b">getLatestData()</code>作为挂起函数被Kotlin挂起，直到其结果准备好，并且<code class="fe me mf mg mh b">getLatestData()</code>的当前状态的副本被保存在存储器中以供将来参考。现在在主线程上，Kotlin点击了<code class="fe me mf mg mh b">networkRequest()</code>，它也挂起了。我们的主线程总是保持空闲。</p><p id="8f66" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">科特林知道如何恢复这些暂停的功能。首先，它将通过恢复先前保存的状态来恢复最新的<code class="fe me mf mg mh b">networkRequest()</code>。然后，它将通过恢复其状态来恢复<code class="fe me mf mg mh b">getLatestData()</code>,从而在不阻塞主线程的情况下继续顺序执行程序。永远不会。</p><p id="406c" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们得到了更简单、更易读的代码。谢谢你协程。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="b9a4" class="no nc je bd np nq nr ns nt nu nv nw nx kt ny ku nz kw oa kx ob kz oc la od oe bi translated">将回调转换成协程</h1><p id="0931" class="pw-post-body-paragraph li lj je lk b ll of ko ln lo og kr lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">记住回调使你的代码更难阅读和推理，如果不写额外的代码，它们对处理错误没有帮助。</p><p id="42aa" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">协程允许您按顺序编写所有代码，这使得代码更容易阅读，并且具有异常等功能来处理错误。</p><p id="45e3" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们举下面的例子:</p><pre class="lc ld le lf gt mx mh my mz aw na bi"><span id="5fb9" class="nb nc je mh b gy nd ne l nf ng"><em class="mr">// Annotation signifies which thread it should execute on</em><br/>@UiThread<br/>fun makeNetworkRequest() {<br/>    <br/>    slowFetch { result -&gt;<br/>        <em class="mr">// When the result is ready, this callback will get it</em><br/>        show(result)<br/>    }<br/>    <em class="mr">// makeNetworkRequest() exits after calling slowFetch without waiting for the result</em><br/>}</span></pre><p id="03e8" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，这段代码可以写成:</p><pre class="lc ld le lf gt mx mh my mz aw na bi"><span id="c5d5" class="nb nc je mh b gy nd ne l nf ng"><em class="mr">// Annotation signifies which thread it should execute on</em><br/>@UiThread<br/>suspend fun makeNetworkRequest() {<br/>    val result : Response = slowFetch()<!-- --> <br/>    // makeNetworkRequest will be suspended<br/>    // Until result is ready<br/>}</span><span id="850f" class="nb nc je mh b gy ok ne l nf ng">suspend fun slowFetch() : Response {<br/>    ...<br/>}</span></pre><p id="b258" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们的代码变得有顺序性，所以链接多个长时间运行的操作非常容易。</p><p id="98c1" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似于<code class="fe me mf mg mh b">async-await</code>模式，当我们调用suspend函数时，不会直接调用<code class="fe me mf mg mh b">await()</code>。Kotlin使用用于等待结果的<code class="fe me mf mg mh b">Deferred.await()</code>。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="a692" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天到此为止。在第27天，我们将继续这方面的更多内容。敬请关注。</p><p id="80c4" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编辑:这是第2部分的链接，在这里您可以了解到CoroutineScope、SuspendCoroutines以及一些代码示例。</p><div class="is it gp gr iu ol"><a href="https://medium.com/better-programming/kotlin-coroutines-for-beginners-4ba32909b509" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd jo gy z fp oq fr fs or fu fw jn bi translated">第2部分:面向初学者的Kotlin协程</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">通过实践代码学习</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ja ol"/></div></div></a></div><p id="6177" class="pw-post-body-paragraph li lj je lk b ll lm ko ln lo lp kr lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您的阅读，您一如既往地令人惊叹！</p></div></div>    
</body>
</html>