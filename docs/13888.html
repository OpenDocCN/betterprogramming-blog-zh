<html>
<head>
<title>TypeScript: Any vs Unknown vs Never</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:任何vs未知vs从不</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-any-vs-unknown-vs-never-9d0eb7416b2b?source=collection_archive---------2-----------------------#2022-10-10">https://betterprogramming.pub/typescript-any-vs-unknown-vs-never-9d0eb7416b2b?source=collection_archive---------2-----------------------#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究这三种有趣的类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a1cded13a8bef59ae2b0a142089907c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxiwCv3fcOYmT10Wt99nlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="aa0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">any</code>、<code class="fe lu lv lw lx b">unknown</code>、<code class="fe lu lv lw lx b">never</code>有什么区别？我们应该在什么时候使用其中的每一个？它的缺点和优点是什么？</p><p id="4117" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TypeScript最近已经十年了。为了庆祝它的周年纪念，我想探索和玩这些类型的复杂性。</p><p id="4419" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将帮助您理解和学习它们的内部原理。有了这个清晰的概念，你就能很容易地确定在每种情况下应该使用哪一种。</p><h1 id="1d29" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">任何的</h1><p id="9747" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">在这三者中，<code class="fe lu lv lw lx b">any</code>是我们倾向于首先学习的一个。你可以把它看作是TypeScript类型系统的一个出口。例如，当声明一个变量为<code class="fe lu lv lw lx b">any</code>时，你可以把这个值赋给它的任何值。禁用TypeScript并将责任转移给开发人员是一个编译器指令。</p><p id="5c09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常情况下，它会制造更多的问题，而不是解决问题。</p><p id="9795" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，当类型注释缺失且无法推断时，编译器将默认为<code class="fe lu lv lw lx b">any</code>类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="abd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这被认为是一种不好的做法，有一个简单的解决方法。我们可以启用<code class="fe lu lv lw lx b">strict</code>模式<code class="fe lu lv lw lx b">on</code>让上面的代码失效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a010" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TypeScript <code class="fe lu lv lw lx b">strict</code>模式将启用罩下的<code class="fe lu lv lw lx b">noImplicitAny</code>、<code class="fe lu lv lw lx b">noImplicitThis</code>、<code class="fe lu lv lw lx b">alwaysStrict,</code>、<code class="fe lu lv lw lx b">strictBindCallApply</code>、<code class="fe lu lv lw lx b">strictNullChecks</code>、<code class="fe lu lv lw lx b">strictFunctionTypes</code>和<code class="fe lu lv lw lx b">strictPropertyInitialization</code>。</p><p id="2ef0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<code class="fe lu lv lw lx b">any</code>类型的隐式用法时,<code class="fe lu lv lw lx b">noImplicitAny</code>将引发错误。除了启用<code class="fe lu lv lw lx b">strict</code>之外，您可以选择仅启用该选项。</p><p id="69ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然不会禁止显式<code class="fe lu lv lw lx b">any</code>的使用。这会导致一些严重的错误。</p><p id="c5ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个虚拟的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="210b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然我们已经将参数<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>声明为数字，但是我们可以通过首先将变量声明为<code class="fe lu lv lw lx b">any</code>来执行带有<code class="fe lu lv lw lx b">string</code>的函数。这个错误很难发现，因为您实际上是在那些变量上选择了不使用TypeScript类型安全。</p><p id="38f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何防止这种情况发生？通过使用一些林挺规则，比如<code class="fe lu lv lw lx b">typescript-eslint</code>和启用<code class="fe lu lv lw lx b">no-explicit-any</code>规则。</p><p id="1d01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该规则可以帮助您阻止这些显式用法。然而，有时候，没有办法，使用<code class="fe lu lv lw lx b">any</code>可能是唯一的解决方案。对于这些例外情况，您可以禁用该行的内衬规则。</p><h1 id="a26a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">未知的</h1><p id="8508" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe lu lv lw lx b">unknown</code>型很简单，但有时也是最难掌握的一种。它只是所有类型的父代。在直接进入之前，让我们检查一下TypeScript <code class="fe lu lv lw lx b">4.8</code>的一个新特性。</p><p id="2b6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当使用<code class="fe lu lv lw lx b">--strictNullChecks</code>选项时，空对象<code class="fe lu lv lw lx b">{}</code>现在是除<code class="fe lu lv lw lx b">null</code>和<code class="fe lu lv lw lx b">undefined</code>之外的所有类型的超类型。为什么这很重要？有助于我们理解<code class="fe lu lv lw lx b">unknown</code>的定义。</p><p id="3f8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe lu lv lw lx b">{}</code>是除了<code class="fe lu lv lw lx b">null</code>或<code class="fe lu lv lw lx b">undefiend</code>之外的所有类型的超类型，因此很容易创建我们定制的<code class="fe lu lv lw lx b">unknown</code>等价类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="dccd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们怎么知道上面的作品？让我们创建一个映射类型来测试我们定义的类型是否确实匹配<code class="fe lu lv lw lx b">unknown</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2d49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么重要？为什么上面的很酷？因为从<code class="fe lu lv lw lx b">4.8</code>开始，我们现在可以缩小未知类型的范围，而无需显式提供类型断言。这将全部由控制流分析来完成。</p><p id="7bcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e200" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">建议使用<code class="fe lu lv lw lx b">unknown</code>替代<code class="fe lu lv lw lx b">any</code>。它让我们定义更广泛的类型，同时保持安全的类型检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a917" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">unknown</code>的一个常见用途是用作旁路打字的桥梁。编译器利用了开发人员的打字责任。也就是说，应该谨慎使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f9d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，<code class="fe lu lv lw lx b">unknown</code>是<code class="fe lu lv lw lx b">any</code>的首选替代，可以用来更好地表达一般类型。可以通过控制流分析或类型断言来缩小范围。</p><h1 id="9c63" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">从不</h1><p id="447a" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><code class="fe lu lv lw lx b">never</code>是一个简单但起初相当混乱的类型。它是一种类型，表示没有任何东西可以分配给它。这是一种不应该出现或被赋予的类型。</p><p id="583e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来看看编译器是如何利用这种类型更好地表达自己的。假设我们想将一个类型表示为<code class="fe lu lv lw lx b">string</code>和<code class="fe lu lv lw lx b">number</code>的交集。我们知道这是不可能的，因为没有可能的交集，但我们可以从句法上表达出来。</p><p id="7b86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看当我们尝试这样做时会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fcd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到,<code class="fe lu lv lw lx b">x</code>的类型变成了<code class="fe lu lv lw lx b">never</code>,因为这种情况永远不会发生。</p><p id="0a87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们试着从一个<code class="fe lu lv lw lx b">function</code>返回<code class="fe lu lv lw lx b">never</code>会怎么样？我们得到一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d249" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让上面的代码工作，这个方法应该永远不会结束，有一种方法可以做到这一点——通过抛出一个异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="29f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以<code class="fe lu lv lw lx b">never</code>类型是一个很棒的工具，我们可以用它来表达我们代码的语义。</p><p id="f5b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个有趣的方法记录器，它可以接受除日期之外的任何东西。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6fd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们创建了一个<code class="fe lu lv lw lx b">log</code>函数，它可以接受除<code class="fe lu lv lw lx b">Date</code>之外的任何类型。这是如何实现的？通过映射类型将<code class="fe lu lv lw lx b">Date</code>映射到<code class="fe lu lv lw lx b">never</code>。</p><h1 id="8dd2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">包裹</h1><p id="06a5" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我们已经看到了使用所有这些类型的复杂性和细微差别。它们都是这种语言的重要方面，但是有不同的用例。</p><p id="d488" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一言以蔽之，应该尽量避免<code class="fe lu lv lw lx b">any</code>而偏向<code class="fe lu lv lw lx b">unknown</code>。然而，在<code class="fe lu lv lw lx b">unknown</code>对您不起作用的某些情况下使用它是没问题的。</p><p id="13dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">never</code>类型有助于我们表达类型限制和识别语言的类型限制。</p><p id="5d0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯！</p><div class="mx my gp gr mz na"><a rel="noopener  ugc nofollow" target="_blank" href="/5-typescript-libraries-to-improve-your-codebase-d26f74a5c3"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">5个类型脚本库来改进您的代码库</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">增加你对静态打字的信心</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">better编程. pub</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ks na"/></div></div></a></div></div></div>    
</body>
</html>