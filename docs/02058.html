<html>
<head>
<title>How To Prevent Native Race Conditions With React’s Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React的上下文API防止本地竞争情况</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/prevent-native-race-conditions-with-reacts-context-api-50ff6a64e09e?source=collection_archive---------9-----------------------#2019-11-03">https://betterprogramming.pub/prevent-native-race-conditions-with-reacts-context-api-50ff6a64e09e?source=collection_archive---------9-----------------------#2019-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">把你自己从不得不调试编程提供的一些最讨厌的错误中解救出来</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e0fe3e2138f14c001fac77c11c23a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qe_Yto83-YMv8LgiHSOX-g.jpeg"/></div></div></figure><p id="1e07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在流服务团队，我们很高兴与各种客户合作，并每天解决令人兴奋的挑战。</p><p id="7b2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇博客文章通过强调用JavaScript构建原生应用程序的复杂性，以及支持多种编程语言必然会出现的创造性解决方案，提供了一个窥视这种情况的机会。</p><p id="3a94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个小背景(看我在那里做了什么)，我们最近与<a class="ae lq" href="https://branch.io/" rel="noopener ugc nofollow" target="_blank">分支</a>的优秀人员合作，为一个客户实现了一个深度链接和导航功能。</p><p id="c9f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想法很简单:使用Branch dashboard创建与特定数据有效负载的深度链接，并在我们的客户端应用程序的深度链接属性负载上，访问各种用例的数据。</p><p id="5d8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">听起来很简单，直到你知道构建Branch代码的本地方法并不总是与React本地/JavaScript代码库同步运行。</p><p id="1ef2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的应用程序中，本机代码和JavaScript之间的异步性在尝试读取和使用深度链接有效负载时产生了一系列意想不到的后果，从多屏幕重新呈现到空白页呈现，再到直接的错误消息。</p><p id="c055" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们很快了解到Branch的本地方法不会遵循React本地组件的生命周期。由于本机代码立即运行，无论我们将Branch的深层链接侦听器函数嵌套得多深，数据有效负载都只在初始加载时可用。</p><p id="9753" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它不能被我们的JavaScript手动获取。为了解决这个问题，我们必须设计一种在加载时读取和保存深度链接数据有效载荷的方法。然后，当我们的应用程序需要导航和其他用例的特定值时，我们将调用这些数据。</p><p id="c9bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从<a class="ae lq" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>到prop drilling，在这个时代，有很多方法可以保存和分享数据。经过深思熟虑，我们选定了<a class="ae lq" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React的上下文API </a>作为适合我们使用的工具。</p><p id="198a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">脸书的Sebastian Markbage是Hooks和Context的教父，他说Context最适合“低频率、不太可能的更新”和“静态值”</p><p id="9d77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，深度链接键-值对对象的一次性接收完全符合要求。</p><p id="b03a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的例子在较高的层次上详细描述了我们如何能够在属性化条目进入我们的应用程序时读取、保存和使用包含在深层链接中的数据。</p><p id="c180" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的示例应用程序的第一步是创建一个React上下文，我们将使用它来存储通过我们的分支深度链接传入的数据负载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="2d62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在该文件中，我们完成了以下工作:</p><ul class=""><li id="9378" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">创建一个React上下文来跟踪我们的深层链接数据。</li><li id="01a3" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">创建一个消费者组件，该组件可以将上下文状态中保存的特定值传递给子组件。</li><li id="8019" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">创建一个提供者组件，使其子组件能够被包装在消费者组件中，并接收数据作为道具。</li></ul><p id="d684" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你还会注意到我们正在利用本地状态的<a class="ae lq" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React的钩子API </a>，特别是<code class="fe mh mi mj mk b">useState</code>钩子。从<code class="fe mh mi mj mk b">useState</code>函数返回的第二个值给了我们重置第一个值的能力。</p><p id="ca1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，传递给<code class="fe mh mi mj mk b">setContextData</code>函数的任何参数都将覆盖<code class="fe mh mi mj mk b">contextData</code>的值。大多数情况下，我们用少得多的代码行运行旧的基于类的<code class="fe mh mi mj mk b">setState</code>方法。</p><p id="1cfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">稍后，您将看到这个setter函数是如何派上用场的。</p><p id="e4b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将特定于上下文的代码添加到我们的<code class="fe mh mi mj mk b">App.js</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8a15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在该文件中，我们完成了以下工作:</p><ul class=""><li id="ad50" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">将我们的应用程序包装在一个提供者组件中，用于上下文访问。</li><li id="a4de" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">将我们的应用程序包装在一个消费者组件中，并通过props传递上下文设置器函数。</li><li id="d956" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">在应用程序加载时激活分支深层链接监听器。</li><li id="bddd" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">使用Context setter函数保存分支监听器获取的任何深层链接参数。</li></ul><p id="35d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们的应用程序加载时，<code class="fe mh mi mj mk b">useEffect</code>钩子中的回调函数运行，分支深度链接监听器激活。希望现在您看到了在我们的上下文中使用<code class="fe mh mi mj mk b">useState</code>钩子的好处。</p><p id="03e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果分支监听器获得一个深度链接，我们通过上下文消费者传递到我们的应用程序组件的<code class="fe mh mi mj mk b">useState</code> setter函数将深度链接数据保存到我们的<code class="fe mh mi mj mk b">BranchContext</code>中的<code class="fe mh mi mj mk b">contextData</code>变量。</p><p id="0bdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们获得了这些数据，我们包装在<code class="fe mh mi mj mk b">BranchConsumer</code>组件中的任何组件都可以通过props访问<code class="fe mh mi mj mk b">contextData</code>。</p><p id="0a68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们应用程序中的最后一个文件显示了如何访问保存在上下文中的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="da6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在该文件中，我们完成了以下工作:</p><ul class=""><li id="ca7c" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">将我们的组件包装在消费者组件中，并将任何保存的上下文数据作为道具传递。</li><li id="f7a2" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">允许我们的组件访问分支深度链接中嵌入的任何键值对。</li></ul><p id="f232" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将我们的功能性React组件包装在消费者组件中，<code class="fe mh mi mj mk b">DataConsumer</code>现在可以访问分支深度链接监听器在应用程序加载时获取的相同数据对象。</p><p id="554e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，我们主要将这些数据用于路由目的，以及到特定内容的深度链接导航，例如营销影响者的个人资料页面。</p><p id="66b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管用例的潜力是无限的，因为可以保存在JavaScript对象中的任何数据都是可访问的。</p><p id="5cb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上下文API避免了未经验证的深层链接点击，特别是当注销或潜在用户点击分支链接时。当用户登录后，立即阅读深层链接并导航到内容是有意义的。</p><p id="419b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，在用户登录之前尝试导航到特定的应用程序屏幕可能会引发权限错误。</p><p id="fb89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将深度链接数据保存在<code class="fe mh mi mj mk b">BranchContext</code>中使我们能够引导用户通过标准认证过程，并在成功登录后，导航到分支深度链接中指定的内容。</p><p id="99fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实证明，这对于营销影响者尤其有用，他们将关注者引导到我们的应用程序，并希望他们在注册后登陆特定的个人资料页面。</p></div></div>    
</body>
</html>