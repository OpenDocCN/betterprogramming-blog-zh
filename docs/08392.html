<html>
<head>
<title>Understand Python Decorators in 3 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3分钟了解Python Decorators</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-python-decorators-in-3-minutes-ec48fdc8e2cf?source=collection_archive---------5-----------------------#2021-04-26">https://betterprogramming.pub/understand-python-decorators-in-3-minutes-ec48fdc8e2cf?source=collection_archive---------5-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5828" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用decorators扩展方法和类的功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd3ab07aa2141b853cbc6bc56c326cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVbQdoRS3Iue74xW_mSuNg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="e5f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://www.codingem.com/what-are-python-decorators/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">装饰器</em> </a>提供了一种可读的方式，让<em class="lv">从外部扩展</em>一个函数、方法或类的功能。当修饰(即扩展)相似的函数来做完全相同的事情而不在代码中增加不必要的重复时，使用decorators特别有用。</p><p id="80f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个如何用装饰器扩展函数的例子:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1645" class="mb mc it lx b gy md me l mf mg">@guard_zero<br/><strong class="lx iu">def</strong> divide(x, y):<br/>    <strong class="lx iu">return</strong> x / y</span></pre><p id="6ace" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mh mi mj lx b">@guard_zero</code>装饰器扩展了<code class="fe mh mi mj lx b">divide</code>方法的功能，以确保<code class="fe mh mi mj lx b">0</code>不会进行分割。然而，在这一点上，没有所谓的<code class="fe mh mi mj lx b">guard_zero</code>，因为你还没有实现它。在下一节中，我将向您展示具体的操作方法。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d44c" class="mr mc it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何用Python创建装饰器</h1><p id="3846" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">演示decorators的最佳方式是创建并使用它。让我们实现<code class="fe mh mi mj lx b">@guard_zero</code>装饰器。</p><p id="9f48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在开始时，你只有这种除两个数的方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="37cd" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">def</strong> divide(x, y):<br/>    <strong class="lx iu">return</strong> x / y</span></pre><p id="0961" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法的问题是没有检查值<code class="fe mh mi mj lx b">y</code>是否为<code class="fe mh mi mj lx b">0</code>。很明显，你可以通过一点点<code class="fe mh mi mj lx b">if</code>检查来解决这个问题。但是有一个替代:<em class="lv">装修工</em>。</p><p id="918b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从创建一个<code class="fe mh mi mj lx b">guard_zero</code>装饰器开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5667" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰器就像Python中的常规函数。它所做的只是接受<code class="fe mh mi mj lx b">operate</code>函数作为参数。然后，它通过创建一个内部函数并在那里添加扩展行为来扩展<code class="fe mh mi mj lx b">operate</code>的功能。最后，它返回<code class="fe mh mi mj lx b">inner</code>函数，这是<code class="fe mh mi mj lx b">operate</code>函数的新版本。</p><p id="1675" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，<code class="fe mh mi mj lx b">guard_zero</code>装饰器已经准备好了。您现在可以像这样扩展(即装饰)<code class="fe mh mi mj lx b">divide</code>函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="643c" class="mb mc it lx b gy md me l mf mg">divide = <!-- -->guard_zero<!-- -->(divide)</span></pre><p id="8250" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这看起来像给变量添加一个新值。但是在这种情况下，您向现有功能添加了新功能。</p><p id="c398" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是应用装饰器有一个更Pythonic化的约定。您可以在定义函数之前添加装饰器，而不是像上面那样用新版本更新函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="7bff" class="mb mc it lx b gy md me l mf mg">@<!-- -->guard_zero<br/><strong class="lx iu">def</strong> divide(x, y):<br/>    <strong class="lx iu">return</strong> x / y</span></pre><p id="7f82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得事情更具可读性，信息也更清晰:扩展<code class="fe mh mi mj lx b">divide</code>方法以防止被<code class="fe mh mi mj lx b">0</code>除。</p><p id="b583" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在您可以用不同的输入测试<code class="fe mh mi mj lx b">divide</code>方法，看看装饰器做了它应该做的事情:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d832" class="mb mc it lx b gy md me l mf mg">print(divide(5, 0))<br/>print(divide(5, 2))</span></pre><p id="12bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="12f4" class="mb mc it lx b gy md me l mf mg">Cannot divide by 0.<br/>None<br/>2.5</span></pre><p id="96d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意输出中的<code class="fe mh mi mj lx b">None</code>。这是因为当<code class="fe mh mi mj lx b">y</code>的值为<code class="fe mh mi mj lx b">0</code>时，<code class="fe mh mi mj lx b">guard_zero</code>装饰器返回<code class="fe mh mi mj lx b">None</code>。</p><p id="6417" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了方便起见，这里列出了所有代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c296" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">概括一下，decorator方法<code class="fe mh mi mj lx b">guard_zero</code>将函数<code class="fe mh mi mj lx b">divide</code>作为它的参数，并创建了它的扩展版本。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="fa66" class="mr mc it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么时候应该用装修工？</h1><p id="b808" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">基于这个例子，你可能仍然想知道，“为什么这么麻烦？”显然，通过在<code class="fe mh mi mj lx b">divide</code>函数中编写一个简单的<code class="fe mh mi mj lx b">if</code>检查，可以节省一些代码。</p><p id="061c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你可以避免与装饰者重复时，装饰者的力量是显而易见的。</p><p id="f42e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，有十种相互类似的方法。在每个方法中，您必须确保第二个参数不是<code class="fe mh mi mj lx b">0</code>。在这种情况下，您可以:</p><ul class=""><li id="3bb8" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">花时间分别为每个方法写十个相同的<code class="fe mh mi mj lx b">if</code>检查。</li><li id="4f2c" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">创建一个装饰器，在每个函数前写<code class="fe mh mi mj lx b">@zero-guard</code>。</li></ul><p id="fe0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，后一种方法是更好的方法，因为您可以在一个地方编写装饰器，并在任何地方添加<code class="fe mh mi mj lx b">@zero-guard</code>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="114d" class="mr mc it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="66fc" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在Python中，可以使用decorators从外部扩展函数、方法或类的功能。</p><p id="81f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您可以编写一个<code class="fe mh mi mj lx b">guard_zero</code>装饰器来确保<code class="fe mh mi mj lx b">0</code>不会进行分割。然后，通过在方法定义前添加装饰器，您可以在代码的任何地方使用装饰器:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a3c5" class="mb mc it lx b gy md me l mf mg">@<!-- -->guard_zero<br/><strong class="lx iu">def</strong> divide(x, y):<br/>    <strong class="lx iu">return</strong> x / y</span></pre><p id="76c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是什么时候应该使用装饰者呢？基本上，当你能避免相似方法之间的重复时。不用对多个方法进行完全相同的更改，您可以进行一次更改，然后用它来修饰每个方法。</p><p id="f4ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望你觉得这很有用。</p></div></div>    
</body>
</html>