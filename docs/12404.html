<html>
<head>
<title>Mastering Concurrency In Go — With Select, Goroutines, and Channels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Select、Goroutines和Channels掌握Go中的并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/concurrency-with-select-goroutines-and-channels-9786e0c6be3c?source=collection_archive---------1-----------------------#2022-06-03">https://betterprogramming.pub/concurrency-with-select-goroutines-and-channels-9786e0c6be3c?source=collection_archive---------1-----------------------#2022-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="20ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写并发代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/640ef71c5c854f11453bf829257a2425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTexhywlIndISSifV3jwxg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f0e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将讨论如何在Golang中结合select、goroutines和channels来构建并发程序。</p><p id="d5b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我建议先阅读这两篇文章，熟悉并发性、通道和goroutines的概念。</p><ul class=""><li id="6c2e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><a class="ae md" href="https://levelup.gitconnected.com/concurrency-in-golang-goroutines-and-channels-explained-55ddb5e1881" rel="noopener ugc nofollow" target="_blank">Golang、Goroutines和Channels中的并发性解释</a></li><li id="a279" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/file-processing-using-concurrency-with-golang-9e08920fab63">使用GoLang并发处理文件</a></li></ul><h1 id="e953" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">挑选</h1><p id="55df" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">从Go tour文档中:</p><blockquote class="ng nh ni"><p id="8d66" class="ky kz nj la b lb lc ju ld le lf jx lg nk li lj lk nl lm ln lo nm lq lr ls lt im bi translated">“<code class="fe nn no np nq b">select</code>语句让一个goroutine等待多个通信操作。</p><p id="8d62" class="ky kz nj la b lb lc ju ld le lf jx lg nk li lj lk nl lm ln lo nm lq lr ls lt im bi translated">一个<code class="fe nn no np nq b">select</code>阻塞，直到它的一个案例可以运行，然后它执行那个案例。如果多个都准备好了，它会随机选择一个。"</p></blockquote><h2 id="1b8f" class="nr mk it bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">API服务器响应</h2><p id="861b" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们将研究如何使用<code class="fe nn no np nq b">select</code>从最快的API调用中获取响应。让我们深入一些代码来理解<code class="fe nn no np nq b">select</code>及其强大的特性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4a94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的实现着重强调了select将如何等待，直到它的一个案例运行。</p><p id="5482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，理解不同的部分很重要，所以让我们一个一个地看。</p><p id="4e5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们查看选择逻辑之前，让我们检查一下API调用是如何进行的。</p><p id="00cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b">Function</code>结构代表一个单一的API调用，它的属性是一个函数<code class="fe nn no np nq b">f</code>，它接受一个类型为<code class="fe nn no np nq b">News</code>的通道，注意这个函数的签名是如何强制这个通道被当作一个<code class="fe nn no np nq b">send-only</code>通道，第二个属性是一个类型为<code class="fe nn no np nq b">News</code>的通道，一旦API调用被执行，响应被解析，这个通道将被用来发送结果。</p><p id="2976" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结构是保存文章的对象，以及它们来自哪个源。</p><p id="4be4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第43行，我们初始化了一片<code class="fe nn no np nq b">Function</code>，有两个元素，第一个有<code class="fe nn no np nq b">googleNews</code>函数并使用<code class="fe nn no np nq b">google</code>通道，第二个使用<code class="fe nn no np nq b">freeNews</code>函数并使用<code class="fe nn no np nq b">free</code>通道。</p><p id="8bfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为两个API调用都将获取新闻，所以通道是相同类型的，但是每个函数有一个通道。</p><p id="1cd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第69行和第102行，我们有这两个API的实现。每个都向各自的URL发出HTTP请求并解析响应，一旦完成，新闻就通过各自的通道发送出去。</p><p id="f662" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们来关注一下<code class="fe nn no np nq b">quickestApiResponse</code>方法。该方法的目的是将文章变量设置为最快的API的响应。在第54行，通过调用<code class="fe nn no np nq b">Run</code>方法来执行每个函数。此方法在函数上启动一个新的goroutine，并传递通道。需要注意的是，这些API调用需要在单独的goroutine中运行，因为我们不想顺序运行它们。</p><p id="f4a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，选择将等待<code class="fe nn no np nq b">google</code>或<code class="fe nn no np nq b">free</code>通道发送响应。一旦任何API调用通过各自的通道发送响应，select将执行该情况下的代码并忽略另一个。这将有效地将文章设置为来自最快API调用的响应。</p><p id="1d6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们运行程序来查看输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/97d288cdad96dcb371f071cb5edc1095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBA2dNCXYt0k7S67zF6wXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API服务器响应输出</p></figure><p id="1fcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那辆<code class="fe nn no np nq b">FreeNewsApi</code>跑得更快了！。</p><p id="17e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个逻辑可以应用于许多其他用例，允许程序运行多个goroutines，使用通道进行通信，并使用select来等待它们。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="8b6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中我们可以实现的另一件事是强制某种超时，如果API调用超过了限制，我们就让文章为空。下面的代码通过向选择中添加一个案例来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="efff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nn no np nq b">time.After</code>返回一个<code class="fe nn no np nq b">time.Time</code>类型的通道，一旦指定的时间过去，它将发送当前时间。请注意，这里我们没有将该通道的值赋给变量，这是因为我们不关心通道将发送的数据，我们只关心信号的接收。如果我们在两个API上都休眠三秒钟，我们将看到超时的情况被执行，而其他两个情况被忽略。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/92260e83ef07763d407cee50aee9840a.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*VhOzajVzHxGtbsAe1RYffA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API服务器响应超时</p></figure><h2 id="95a9" class="nr mk it bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">超时的上下文</h2><p id="7e02" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">上下文几乎总是出现在程序中，我们可以使用上下文对象为特定的高开销任务设置超时。下面的例子展示了如何使用<code class="fe nn no np nq b">context.WithTimeout</code>来限制程序等待一个昂贵任务响应的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="186a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的例子使用<code class="fe nn no np nq b">context.Background()</code>作为父上下文，但是在更真实的设置中，上下文已经存在了。超时上下文返回一个上下文，当指定的持续时间过去时，该上下文将通过<code class="fe nn no np nq b">ctx.Done</code>通道发送一个信号。</p><p id="fd38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第13行，一个昂贵的任务在一个单独的goroutine中运行，上下文和信号通道作为参数传递。昂贵的任务休眠6秒来模拟延迟，但是上下文超时5秒。</p><p id="d67c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">select有两种情况，要么等待<code class="fe nn no np nq b">ctx.Done</code>运行，要么等待昂贵的任务发送一个指示它已经完成的信号。</p><p id="02a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，运行此示例将产生以下输出:</p><pre class="kj kk kl km gt oo nq op oq aw or bi"><span id="4b05" class="nr mk it nq b gy os ot l ou ov">Expensive task took too long to complete</span></pre></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="39ac" class="nr mk it bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">运行循环流程</h2><p id="7b3c" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">让我们看看如何使用<code class="fe nn no np nq b">select</code>来运行一个循环流程。对于该计划，我们将有以下场景:</p><p id="6dc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该程序需要让我们通过任何函数作为循环过程，当该过程应该开始运行时，以及每次运行之间的间隔时间。</p><p id="d7c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我们有了初始代码，让我们来看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fb1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码反映了我们想要运行的任务。我们有两个主要功能<code class="fe nn no np nq b">collectNewUsersNotifications</code>和<code class="fe nn no np nq b">handlePendingUsersNotifications</code>。第一个是为了收集所有新用户通知，理想的实现是这个函数在数据库中寻找未读通知，但是为了这个例子，我们模拟为某些用户获取随机通知。</p><p id="1029" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通知是使用只有两个字段的<code class="fe nn no np nq b">Notification</code>结构创建的，一个用于内容，一个用于用户id。</p><p id="a19e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">collect函数使用<code class="fe nn no np nq b">PendingUserNotifications</code>类型来存储通知。这个类型是一个映射，其中键是一个表示用户id的整数，值是一个片<code class="fe nn no np nq b">Notification</code>。</p><p id="b21a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们收集了所有的通知之后，我们希望使用<code class="fe nn no np nq b">handlePendingUserNotifications</code>函数来遍历通知，并对每个通知运行一个处理函数。在我们处理每个用户的通知后，它们将从地图中删除。我们将在这种情况下使用的处理程序是<code class="fe nn no np nq b">sendUserBatchNotificationsEmail</code>。它的目的是向用户发送一封包含所有待定通知的电子邮件，以便他们可以查看。</p><p id="d7bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们关注如何使用<code class="fe nn no np nq b">select</code>以循环方式运行这个任务。正如我之前提到的，我们必须考虑以下几点:</p><ul class=""><li id="62a8" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">允许通过一个间隔时间</li><li id="098d" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">允许传递流程的开始时间</li><li id="49c2" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">允许呼叫者在需要时取消/停止循环过程</li></ul><p id="cea4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码显示了如何实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="382f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们引入了一个新的结构来表示一个循环过程<code class="fe nn no np nq b">RecurringProcess</code>。此结构包含以下字段:</p><ul class=""><li id="d498" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nn no np nq b">name </code> —流程的名称</li><li id="24ac" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b">interval </code> —每次运行之间的间隔时间</li><li id="e8a4" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b">startTime </code> —流程开始的时间</li><li id="af7c" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b">handler </code> —每次运行时调用的处理函数</li><li id="9dad" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b">stop </code> —停止进程的通道</li></ul><p id="a78c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nn no np nq b">pendingNotificationsProcess</code>函数中，我们分别在第30行和第31行初始化一个新的循环流程和通知。我们将使用的处理函数是一个内部同时具有<code class="fe nn no np nq b">collectNewUsersNotifications</code>和<code class="fe nn no np nq b">handlePendingUsersNotifications</code>函数的函数。注意这里我们将流程传递给了<code class="fe nn no np nq b">handlePendingUsersNotifications</code>,因为需要它来停止流程。</p><p id="912e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还指定了间隔和开始时间。</p><p id="862b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们调用<code class="fe nn no np nq b">createRecurringProcess</code>，这个函数创建循环流程并启动它。让我们关注第88行，这里我们使用一个goroutine来启动这个过程。</p><p id="b2d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第40行中，我们通过从stop通道读取来阻塞主goroutine，这意味着主goroutine将被阻塞，直到有消息被发送到该通道。</p><p id="92cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看第93行的<code class="fe nn no np nq b">Start</code>函数，它包含了运行循环过程的所有逻辑。</p><p id="5bf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该功能使用<code class="fe nn no np nq b">startTicker</code>变量，通过开始时间启动循环过程。如果开始时间已经过去，该过程将立即开始。</p><p id="160a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当指定的持续时间过去后,<code class="fe nn no np nq b">time.NewTimer</code>将在其通道上发送当前时间，这将允许我们开始该过程。这就是为什么第一种情况是选择等待通道接收信号。</p><p id="ff69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在第95行还有一个<code class="fe nn no np nq b">ticker</code>变量，它是一个<code class="fe nn no np nq b">time.Ticker</code>。go中的收报机将在指定的时间间隔在通道上发送滴答。一旦<code class="fe nn no np nq b">startTicker.C</code>通道发送了信号，我们在第106行给<code class="fe nn no np nq b">ticker</code>变量分配一个带有间隔的新跑马灯，并且调用处理函数。</p><p id="4f74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此之后，<code class="fe nn no np nq b">ticker</code>将在第二个选择案例上开始接收滴答，并且每次它接收一个滴答时，也会调用处理函数。</p><p id="cbde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在select的最后一种情况下，我们通过返回来等待，直到发出停止进程的信号。</p><p id="ab11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<code class="fe nn no np nq b">select</code>是如何在无限<code class="fe nn no np nq b">for</code>循环中的。这是因为我们希望一直循环下去，直到其中一个案例显式地中断循环。每次我们收到一个tick，第二个case将被执行，然后它将再次进入同一个循环，select将再次等待它的一些case运行。</p><p id="044f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了停止这个过程，我们在第55行添加了一些逻辑，我们计算通知的数量，如果在任何时候都没有未决的通知，程序就会取消这个过程。<code class="fe nn no np nq b">Cancel</code>功能关闭停止通道，程序结束。</p><p id="5c81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们运行这个程序，看看它是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/633d7a319c10e43641a49fa81337be96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDBMDVhcAlfocQU4Y501Hg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">程序输出</p></figure><p id="3be4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了，程序按预期运行。这只是如何运行循环流程的一个示例。这可以是实现更复杂的东西的基础代码。你可以用<code class="fe nn no np nq b">select</code>构建复杂的程序。</p><h2 id="8898" class="nr mk it bd ml ns nt dn mp nu nv dp mt lh nw nx mv ll ny nz mx lp oa ob mz oc bi translated">结论</h2><p id="eec7" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">构建并发程序在开始时可能具有挑战性，尤其是当您努力理解goroutines、channels和select是如何工作的时候。</p><p id="4ebb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望通过这篇文章，您不会感到困惑，并且您已经找到了一些可以使用<code class="fe nn no np nq b">select</code>的用例。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="95f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nj">感谢您的阅读，敬请期待更多内容。</em></p></div></div>    
</body>
</html>