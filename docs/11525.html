<html>
<head>
<title>Getting Started with Netflix Conductor in .NET using SuperSimpleConductor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网飞指挥入门。使用超简单导体的网络</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-netflix-conductor-in-net-using-supersimpleconductor-ed8a02120c1?source=collection_archive---------7-----------------------#2022-03-28">https://betterprogramming.pub/getting-started-with-netflix-conductor-in-net-using-supersimpleconductor-ed8a02120c1?source=collection_archive---------7-----------------------#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4bc2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在网飞指挥系统中运行您的第一个工作流程的分步指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e04e46203404c6f4928ef3078f2bfd33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*yAZChXS_ewJANjohH49hUw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">网飞指挥家GitHub资料库中的网飞指挥家徽标。</p></figure><h1 id="8a3c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">关于这篇文章</h1><p id="af72" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">网飞指挥的两个关键概念是工人和任务。Workers是包含任务实现的微服务，由Conductor作为工作流的一部分来执行。任务是工作流的构建块，即由工作流所表示的流程执行的步骤。</p><p id="210f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">实现工人和任务的库可用于各种编程语言，最著名的是Go、Java和Python。在本文中，我将介绍一个。名为<a class="ae mn" href="https://github.com/erikbrgr/supersimpleconductor" rel="noopener ugc nofollow" target="_blank"> SuperSimpleConductor </a>的网络，是我开发并维护的。</p><p id="a670" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在本文中，我将使用SuperSimpleConductor库来展示使用. NET开始使用网飞指挥器是多么容易</p><h1 id="0cb4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是网飞指挥家？</h1><p id="dae4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">网飞指挥是一个工作流程编排引擎，由网飞创建，用于“编排基于微服务的流程”(来源:<a class="ae mn" href="https://netflix.github.io/conductor/" rel="noopener ugc nofollow" target="_blank">网飞指挥文档</a>)。网飞指挥的完整功能列表位于<a class="ae mn" href="https://netflix.github.io/conductor/" rel="noopener ugc nofollow" target="_blank">这里</a>，但一些关键功能是:</p><ul class=""><li id="28ae" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">工作流和任务定义以JSON格式实现。这允许版本控制和对定制工具的简单支持，以创建和管理工作流和任务。</li><li id="026f" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">任务和工作者，即分别构成工作流和承载它们的微服务的构建块，是完全语言不可知的，这允许以最适合任务的语言来完成实现。</li><li id="e132" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">数据库架构是可插拔的，这意味着我们可以选择我们想要用于Conductor的数据库。Conductor附带了许多现成的插件，支持Dynomite(也是网飞开发的)、MySQL和PostgreSQL。</li><li id="4f89" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">网飞指挥配备了一个(可选)用户界面，允许洞察和控制工作流程，如(重新)开始，暂停，停止。</li><li id="457a" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">整个项目是开源的，并且正在被积极地开发和支持。</li></ul><p id="72ac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">简而言之，网飞指挥允许您自动化和管理由多个任务组成的流程(这些任务本身可能就是流程)，这些任务可能需要以可靠、一致和可扩展的方式按顺序执行。</p><p id="a14f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我目前的项目中，我们使用网飞Conductor和PostgreSQL来运行预定的ETL过程、创建报告、下载和上传文件，以及进行监控和报警。我们还研究了如何使用Conductor来自动提供用户帐户和其他基础设施。</p><h1 id="30ce" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">在本地运行网飞指挥</h1><p id="3478" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了按照本文编写代码，您需要一个运行中的Conductor实例。最简单的方法是使用Docker在本地运行Conductor。使用我下面写的文章，您应该在几分钟内就可以开始运行了。</p><div class="nc nd gp gr ne nf"><a rel="noopener  ugc nofollow" target="_blank" href="/running-netflix-conductor-3-in-docker-using-elasticsearch-7-and-postgresql-b415988dd74a"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">使用Elasticsearch 7和PostgreSQL在Docker中运行网飞导体3</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">所有这些都包含在一个简单、可重复和可维护的过程中</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">better编程. pub</p></div></div><div class="no l"><div class="np l nq nr ns no nt ko nf"/></div></div></a></div><p id="9b13" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果您遵循了本文中的步骤，您应该能够访问位于<a class="ae mn" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000/ </a>的Conductor UI和位于<a class="ae mn" href="http://localhost:8080/swagger-ui/index.html" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger-UI/index . html</a>的Conductor服务器API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/2236ab9c0915fc63ee453307700f1f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDyhfUqINLgZHtZov9fWEg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">导体UI和服务器API并行运行。</p></figure><p id="26e9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们已经启动并运行了Conductor，让我们开始使用它吧！</p><h1 id="8f09" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建任务</h1><p id="24d7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们的第一步是向Conductor注册任务。我们的任务定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="92bb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里我们正在创建<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>任务。</p><p id="9c1d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我已经尽可能保持了最小的定义。关于你还能做什么的详细信息，你可以参考文档<a class="ae mn" href="https://netflix.github.io/conductor/configuration/taskdef/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="7b09" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了注册任务，我们使用Conductor服务器API的<code class="fe ob oc od oe b">/api/metadata/taskdefs</code>端点。</p><p id="3a46" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们将使用Swagger接口来调用端点。注意，端点需要一个JSON数组，所以我们用<code class="fe ob oc od oe b">[ ]</code>包装我们的定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi of"><img src="../Images/692d950c3f2ca4b2643565fdd314afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFb1HnL2y9a9CoaDd69kfA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">使用Conductor服务器API注册任务。</p></figure><p id="8999" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">点击<strong class="lo iu">执行</strong>后，我们可以看到任务出现在指挥界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi og"><img src="../Images/aa141903890fd2c422d2a5cdb2a2e028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WS1V9Ax4RX7UxH7dRTTsQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Conductor UI中的任务定义。</p></figure><h1 id="6ae2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建工作流</h1><p id="6851" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">然后，我们使用<code class="fe ob oc od oe b">api/metadata/workflow</code>端点在Conductor中创建工作流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3d94" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">同样，我已经尽可能保持了最小的定义。有关您可以使用的其他属性的详细信息，您可以参考<a class="ae mn" href="https://netflix.github.io/conductor/configuration/workflowdef/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oh"><img src="../Images/98fff6d03ef0b4258ff0be207ecea46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9nS-AnJcZ10YkRxv8Qvzg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">使用Conductor服务器API注册工作流。</p></figure><p id="bfb8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">并检查<code class="fe ob oc od oe b">SimpleSampleWorkflow</code>是否出现在指挥界面中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oi"><img src="../Images/3f5b04d2fe8fac9d20bdfdda3e3746c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZ0z7_0ACO4KJXES_cJt9w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Conductor UI中的工作流定义。</p></figure><p id="3ee6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们已经注册了我们的工作流，我们可以使用<code class="fe ob oc od oe b">api/workflow/{name}</code>端点运行它的一个实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oj"><img src="../Images/e32fdf2f90172cff4ffc1e603a6540af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*heN6uXnzpYGKh_t1dx76Ag.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">在Conductor UI中运行的工作流。</p></figure><p id="fdbd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">太好了！工作流现在正在运行，等待一个工作人员拾取第一个任务，即<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>。</p><p id="17d3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们将实现Worker进程。</p><h1 id="be02" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建工人</h1><p id="2c78" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用SuperSimpleConductor，创建一个Worker非常简单(看到我在那里做了什么吗？).</p><p id="aa08" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，我们创建一个新的后台工作程序项目。</p><pre class="kj kk kl km gt ok oe ol om aw on bi"><span id="76b2" class="oo kv it oe b gy op oq l or os">mkdir conductor-worker<br/>cd conductor-worker<br/>dotnet new worker -f net5.0</span></pre><p id="1190" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">请注意，我正在使用。这里是网5。超简单导体支架。NET Standard 2.1或更高版本，所以您在这里选择的任何满足该要求的都可以。</p><p id="cf3d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们不需要<code class="fe ob oc od oe b">Worker.cs</code>文件，所以删除它是安全的。</p><p id="5f11" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，我们添加NuGet的超级简单导体包。</p><pre class="kj kk kl km gt ok oe ol om aw on bi"><span id="5fbf" class="oo kv it oe b gy op oq l or os">dotnet add package SuperSimpleConductor.ConductorClient<br/>dotnet add package SuperSimpleConductor.ConductorWorker</span></pre><p id="154a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">并用以下代码替换<code class="fe ob oc od oe b">Program.cs</code>类中的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="cc9a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用<code class="fe ob oc od oe b">dotnet run</code>运行worker会产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ot"><img src="../Images/5621153ea0a8e362f71d6b0461d562be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGQXwFBnDdfgKumrUwrTTQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">运行工作线程。</p></figure><p id="7cef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意，我更改了<code class="fe ob oc od oe b">appSettings.Development.json</code>中的日志设置以获得更好的输出(默认情况下，它被设置为只记录<code class="fe ob oc od oe b">Information</code>消息):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6a25" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以看到发生的情况是工人轮询指挥队列并找到2个任务:任务<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>和任务<code class="fe ob oc od oe b">_deciderQueue</code>。后者是一个系统任务，所以工人跳过它。</p><p id="a9c2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它还通知我们<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>没有向这个worker注册。那是因为我们还没有这样做。</p><p id="2800" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">那么我们如何做到这一点呢？</p><p id="d1dd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">按照这篇文章的主题，这也是超级简单的。</p><p id="0acf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在<code class="fe ob oc od oe b">Program.cs</code>中，行</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7172" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">加载指定的程序集(在这种情况下只有<code class="fe ob oc od oe b">conductor-worker</code>程序集)，并向worker注册从<code class="fe ob oc od oe b">IWorkflowTask</code>接口派生的任何类。</p><p id="9e4d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这意味着我们现在需要做的就是实现<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>类。</p><h1 id="df9d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建工作任务</h1><p id="6ec4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要实现<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>，创建一个新文件</p><pre class="kj kk kl km gt ok oe ol om aw on bi"><span id="8032" class="oo kv it oe b gy op oq l or os">touch SimpleSampleWorkerTask.cs</span></pre><p id="6288" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">并粘贴以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6ea9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，使用<code class="fe ob oc od oe b">dotnet run</code>运行worker向我们展示了<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>被拾取并执行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ou"><img src="../Images/74d2986555d9546d23af1206ca1324dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q17zgkppzQV-LVISFa8orA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">运行添加了任务的工作线程。</p></figure><p id="d784" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，Conductor UI中的工作流程显示为<code class="fe ob oc od oe b">Completed</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ov"><img src="../Images/df7102aabb8bf266f73acfe410b396ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRbWvVwrIcMCyOSzXyicaA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">工作流在Conductor UI中完成。</p></figure><p id="09ba" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">就是这样！现在剩下的就是用一个实际的实现替换<code class="fe ob oc od oe b">SimpleSampleWorkerTask</code>类中的日志调用。</p><p id="0fdc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当然，向工作流程中添加额外的任务应该像重复上述步骤一样简单。Conductor可以使用并行任务、决策树和各种其他优点来支持非常复杂的工作流。</p><p id="927e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">唯一的限制是你的想象力。</p><h1 id="0c6d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最后</h1><p id="0823" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一开始，开始使用网飞指挥家可能会令人望而生畏。但是使用正确的库，开始实际上会变得非常简单。</p><p id="6c04" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">作为SuperSimpleConductor项目的一部分，GitHub 上的<a class="ae mn" href="https://github.com/erikbrgr/supersimpleconductor" rel="noopener ugc nofollow" target="_blank">提供了<code class="fe ob oc od oe b">TestWorker</code>类和上述所有源代码。</a></p><p id="d2f1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">编码快乐！</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><p id="6313" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">本文中的所有代码片段都是使用<a class="ae mn" href="https://levelup.gitconnected.com/create-beautiful-embedded-code-without-the-hassle-of-creating-github-gists-fe6ce2fa0109" rel="noopener ugc nofollow" target="_blank"> gistbuilder </a>创建的。如果您觉得这篇文章很有用，您可能会对我们如何在项目中安排工作流感兴趣:</p><div class="nc nd gp gr ne nf"><a href="https://levelup.gitconnected.com/cron-docker-the-easiest-job-scheduler-youll-ever-create-e1753eb5ea44" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">Cron + Docker =你将创建的最简单的作业调度程序</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">最大功率和灵活性的两个组件。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="no l"><div class="pd l nq nr ns no nt ko nf"/></div></div></a></div></div></div>    
</body>
</html>