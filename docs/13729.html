<html>
<head>
<title>Build a NoSQL Database From Scratch in 1000 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用1000行代码从头开始构建一个NoSQL数据库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-nosql-database-from-the-scratch-in-1000-lines-of-code-8ed1c15ed924?source=collection_archive---------0-----------------------#2022-09-21">https://betterprogramming.pub/build-a-nosql-database-from-the-scratch-in-1000-lines-of-code-8ed1c15ed924?source=collection_archive---------0-----------------------#2022-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b751" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍LibraDB，这是我用Go创建的一个工作数据库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4fa10cff10b8c7073dc256a66ea74cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5GEu7ALdCR8yy-DBK11KHg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由Pixabay拍摄</p></figure><h1 id="e4a4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第一章</h1><p id="faf3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我是个人项目的粉丝。这些年来，我有幸撰写了多个与数据库相关的博客/GitHub项目。现在，我决定用一个项目来统治他们！</p><p id="0208" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我已经在Go中实现了我的数据库，并决定通过写一篇描述所有步骤的博客来分享我的知识。这篇文章很长，所以我原本打算是一个7部分系列。最终，我决定把它保存在一篇分成7个部分的长文里。这样，你可以停下来，轻松地回到每一章。</p><p id="f535" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">数据库有意地简单和最小化，所以最重要的特性将适合，但仍然使代码简短。</p><p id="8cc1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">代码在Go里，但并不复杂，不熟悉的程序员也能看懂。如果你知道围棋，我鼓励你继续努力！</p><p id="15f4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">整个代码库都在GitHub 上，当你完成后，还有大约50个测试要运行。<a class="ae mo" href="https://github.com/amit-davidson/Building-a-NoSQL-database-from-zero" rel="noopener ugc nofollow" target="_blank">在第二次回购</a>中，代码被分成7个逻辑部分，每个部分放在不同的文件夹中。</p><p id="a6f5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将在Go中创建一个简单的NoSQL数据库。我将介绍数据库的概念，以及如何使用它们在Go中从头开始创建一个NoSQL键/值数据库。我们将回答以下问题:</p><ul class=""><li id="4d23" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi mu mv mw mx bi translated">什么是NoSQL？</li><li id="5f17" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">如何在磁盘上存储数据？</li><li id="35ac" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">基于磁盘的数据库和内存数据库的区别</li><li id="fd12" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">索引是如何制作的？</li><li id="e352" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">什么是ACID，事务是如何工作的？</li><li id="92c5" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">如何设计数据库以获得最佳性能？</li></ul><p id="4f64" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第一部分将首先概述我们将在数据库中使用的概念，然后实现一个写入磁盘的基本机制。</p><h2 id="f055" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">SQL与NoSQL</h2><p id="23b4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">数据库分为不同的类别。与我们相关的是关系数据库(SQL)、键值存储和文档存储(这些被认为是NoSQL)。最突出的区别是数据库使用的数据模型。</p><p id="0765" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">关系数据库将数据组织到由列和行组成的表(或“关系”)中，用唯一的键标识每一行。行表示实体的实例(例如“商店”)，列表示属于该实例的值(例如“收入”或“支出”)。</p><p id="8180" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在关系数据库中，业务逻辑可能分布在整个数据库中。换句话说，单个对象的各个部分可能出现在数据库的不同表中。我们可能有不同的收入和支出表，因此要从数据库中检索整个商店实体，我们必须查询这两个表。</p><p id="d666" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">键值存储和文档存储是不同的。单个实体的所有信息都集中保存在集合/桶中。以前面的例子为例，商店实体在一个实例中包含收入和支出，并驻留在商店集合中。</p><p id="0d07" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">文档存储是键值存储的子类。在键值存储中，数据被认为对数据库是固有的不透明的，而面向文档的系统依赖于文档的内部结构。<br/>例如，在一个文档存储中，可以通过一个内部字段(如收入)查询所有商店，而键值只能通过它们的id来获取商店。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/40c24c80e490840baaedbd21f74818d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsFP25iw5K-J5oUcuCxB2A.png"/></div></div></figure><p id="3512" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这些是基本的区别，尽管在实践中，有更多的数据库类型和更多的理由来选择一个。</p><p id="9836" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们的数据库将是一个<strong class="lp ir">键值</strong>存储(<strong class="lp ir">而不是文档存储</strong>)，因为它的实现是最简单和最直接的。</p><h2 id="60eb" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">基于磁盘的存储</h2><p id="9222" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">数据库在<em class="nq">数据库页面</em>中组织它们的数据(集合、文档……)。页面是数据库和磁盘交换数据的最小单位。有一个固定大小的工作单元很方便。此外，将相关数据放在附近是有意义的，这样就可以一次获取所有数据。</p><p id="f26d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="nq">数据库页面</em>连续存储在磁盘上，以最小化磁盘寻道。继续我们之前的例子，考虑8个商店的集合，其中一个页面被2个商店占据。在磁盘上，它看起来像下面这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/739e068a875819b446a7c15dba2f58ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*G2r18bhMFmPmIVYShG5N_g.png"/></div></figure><p id="31ef" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae mo" href="https://dev.mysql.com/doc/refman/5.6/en/innodb-file-space.html" rel="noopener ugc nofollow" target="_blank"> MySQL </a>默认页面大小为16Kb，<a class="ae mo" href="https://www.postgresql.org/docs/current/storage-page-layout.html" rel="noopener ugc nofollow" target="_blank"> Postgres </a>页面大小为8Kb，<a class="ae mo" href="https://db.apache.org/derby/docs/10.0/manuals/tuning/perf24.html#Tune+the+size+of+database+pages" rel="noopener ugc nofollow" target="_blank"> Apache Derby </a>页面大小为4Kb。</p><p id="63b7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">更大的页面尺寸会带来更好的性能，但是它们也有损坏页面的风险。一种场景，其中系统在单个写事务的多个数据库页的写入过程中崩溃。</p><p id="4726" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在实际数据库中选择页面大小时，需要考虑这些因素。这些考虑与我们的数据库无关，所以我们将任意选择数据库页面的大小为4KB。</p><h2 id="8877" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">底层数据结构</h2><p id="7611" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如前所述，数据库跨许多页面存储其内部数据，这些数据存储在磁盘上。数据库使用数据结构来管理页面的数量。</p><p id="437a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">数据库使用不同的数据结构来组织磁盘上的页面，主要是<a class="ae mo" href="https://en.wikipedia.org/wiki/B-tree" rel="noopener ugc nofollow" target="_blank"> B </a> / <a class="ae mo" href="https://en.wikipedia.org/wiki/B%2B_tree" rel="noopener ugc nofollow" target="_blank"> B+ </a>树和<a class="ae mo" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希桶</a>。每种数据结构都有自己的优点:读/写性能、支持更复杂的查询(如排序或范围扫描)、易于实现等等。</p><p id="62da" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将使用B树，因为它易于实现，但它的原理接近于现实世界中的数据库。</p><h2 id="1c38" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">我们的数据库</h2><p id="9877" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们的数据库将是一个键值存储。它的底层数据结构是B树，每页的大小是4KB。它将具有以下架构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d8a6c4f2196e1ed5eadf02e877397b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*OR_C71FsFmL_hMX99_zLYw.png"/></div></figure><p id="e62d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">数据库</strong>管理我们的程序，并负责编排事务——那些是读写操作的序列。它还面对使用数据库的程序员，并为他们的请求服务。</p><p id="15ee" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">数据访问层(DAL) </strong>处理所有磁盘操作以及数据在磁盘上的组织方式。它负责管理底层数据结构，将数据库页面写入磁盘，并回收空闲页面以避免碎片。</p><h2 id="7ed2" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">开始编码</h2><p id="71c8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将自下而上构建我们的数据库，从<strong class="lp ir">数据访问层(DAL) </strong>组件<strong class="lp ir">开始。</strong>我们将通过为它创建一个文件来开始编码。我们将有一个结构、一个构造函数和一个关闭方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="75f5" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">数据库页面</h2><p id="309a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">DAL将管理数据库页面的读写。我们将在<code class="fe nv nw nx ny b">dal.go</code>中为<code class="fe nv nw nx ny b">page</code>类型添加一个结构。它将包含一个作为唯一ID的数字，但它的作用更大。那个数字被用来访问带有指针算法的页面，比如(<code class="fe nv nw nx ny b">PageSize*pageNum</code>)。我们还将为<code class="fe nv nw nx ny b">dal</code>添加<code class="fe nv nw nx ny b">PageSize</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3b5c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，我们将添加一个构造函数并对其进行读写操作。注意，在第12行和第25行，给定页面大小和页码，文件中正确的偏移量是如何计算的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="61db" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">自由列表</h2><p id="55d9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">管理页面是一项复杂的任务。我们需要知道哪些页面是免费的，哪些页面被占用了。如果页面变空，它们也可以被释放，所以我们需要回收它们以备将来使用，从而避免碎片化。</p><p id="1090" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所有这些逻辑都由<code class="fe nv nw nx ny b">freelist</code>管理。该组件是DAL的一部分。它有一个名为<code class="fe nv nw nx ny b">maxPage</code>的计数器，保存着迄今为止分配的最高页码，还有一个名为<code class="fe nv nw nx ny b">releasedPages</code>的属性，用于跟踪释放的页面。</p><p id="6b78" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">分配新页面时，首先评估<code class="fe nv nw nx ny b">releasedPages</code>是否有空闲页面。如果列表为空，则计数器递增，并给出新的一页，增加文件大小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/180c08d28fee53869abb7ccac606154a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M83vZHQDbXfpHxCsn237kw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">被占用的页面是灰色的。免费页面是白色的。</p></figure><p id="305d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将首先创建文件<code class="fe nv nw nx ny b">freelist.go</code>，为<code class="fe nv nw nx ny b">freelist</code>定义类型，并添加一个构造函数<code class="fe nv nw nx ny b">newFreeList</code>。然后，我们需要添加<code class="fe nv nw nx ny b">getNextPage</code>和<code class="fe nv nw nx ny b">releasePage</code>。我们的数据库使用第一页来存储元数据(这将在下一章中解释)，所以我们只能分配编号大于0的新页。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b86c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，我们将在dal结构中嵌入<code class="fe nv nw nx ny b">freelist</code>,并在打开数据库时创建一个实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="642e" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">第一章结论</h2><p id="2402" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">到目前为止，我们的数据库支持读写页面。为了测试我们的工作，我们可以创建一个main函数，编写一个页面，看看数据是如何存储的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9973" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">命令<code class="fe nv nw nx ny b">hexdump</code>和<code class="fe nv nw nx ny b">-C</code>标志一起用于显示二进制文件的内容。</p><p id="22b8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">前4096个字节(左边的1000个十六进制字节)是为元数据保留的，我们的数据就在它后面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/b948a32dfd0f380d51c61fc016a42b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZOWSgiwyFoR7W8e2gLzqZw.png"/></div></div></figure><p id="cdbe" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">只要程序在运行，我们的数据库就在运行。如果程序被杀死，我们就无法知道哪些页面是空的，哪些包含实际数据。首先，这意味着需要将<code class="fe nv nw nx ny b">freelist</code>持久化到磁盘上。这将是我们下一章的主题。</p><p id="77d4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可以在这里查看<a class="ae mo" href="https://github.com/amit-davidson/Building-a-NoSQL-database-from-zero/tree/master/Part%201" rel="noopener ugc nofollow" target="_blank">这部分代码的完整版本</a>。</p><h1 id="7aa7" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated"><strong class="ak">第二章</strong></h1><p id="0ace" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们继续建立我们的数据库。在上一章中，我们看了数据库的一般架构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d8a6c4f2196e1ed5eadf02e877397b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*OR_C71FsFmL_hMX99_zLYw.png"/></div></figure><p id="bf9f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后我们实现了处理磁盘操作的数据访问层。到目前为止，它支持:打开和关闭数据库文件，将数据写入和读取到磁盘页面，还可以使用<code class="fe nv nw nx ny b">freelist</code>管理空的和被占用的页面。</p><p id="ef58" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在这一章中，我们将实现磁盘持久性。将数据库状态保存到磁盘是非常重要的，这样它就可以在重新启动之间正常运行。DAL将对此负责。</p><p id="48f6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将从把<code class="fe nv nw nx ny b">freelist</code>的状态提交到磁盘开始。</p><h2 id="8093" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">开始编码</h2><p id="749b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了保存<code class="fe nv nw nx ny b">freelist</code>的状态，我们希望将它作为数据库页面写入磁盘。在数据库中，有一个保存数据库元数据的页面是很常见的。</p><p id="1952" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在我们的例子中，它可以是基本页面的页码- <code class="fe nv nw nx ny b">freelist</code>。它还可以保存幻数——一个用于标识文件格式的常量数值或文本值(我们将在最后一章中遇到它)。对我们来说，两者都是。</p><p id="c0e8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了跟踪<code class="fe nv nw nx ny b">freelist</code>页码，我们将添加一个名为<code class="fe nv nw nx ny b">meta</code>的新页面。这是一个特殊的页面，因为它固定在0号上。这样，在重启时，我们可以从页码0开始读取元页面，并跟随它加载<code class="fe nv nw nx ny b">freelist</code>内容。</p><h2 id="b1d5" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">元页面持久性</h2><p id="811f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们数据库中的一个典型模式是定义<code class="fe nv nw nx ny b">serialize</code>和<code class="fe nv nw nx ny b">deserialize</code>方法，用于将实体转换成适合单个页面的原始数据。并用返回实体本身的读写方法包装它们。</p><p id="fb8d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将创建一个名为<code class="fe nv nw nx ny b">meta.go</code>的新文件，定义一个新的类型<code class="fe nv nw nx ny b">meta</code>和一个构造函数。</p><p id="2032" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们需要将<code class="fe nv nw nx ny b">meta</code>序列化为<code class="fe nv nw nx ny b">[]byte</code>，这样我们就可以将它写入磁盘。不幸的是，如果不使用<code class="fe nv nw nx ny b">Unsafe</code>包(出于显而易见的原因，我们不会使用它), Go不支持像C语言那样简单地将结构转换成二进制，所以我们必须自己实现它。</p><p id="a9a4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在每个方法中，我们将有一个位置变量(<code class="fe nv nw nx ny b">pos</code>)来跟踪缓冲区中的位置。它类似于文件中的光标。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7a71" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将创建一个新文件<code class="fe nv nw nx ny b">const.go</code>来保存大小，并声明一个新的常量<code class="fe nv nw nx ny b">pageNumSize</code>。它包含页码的大小(以字节为单位)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3e2e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">文件<code class="fe nv nw nx ny b">const.go</code>回答<strong class="lp ir">如何为每个变量存储多少字节，序列化和反序列化负责<strong class="lp ir">将它保存在页面内。</strong></strong></p><p id="229e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，我们将使用前面的元序列化/反序列化和读/写页面方法添加方法<code class="fe nv nw nx ny b">writeMeta</code>和<code class="fe nv nw nx ny b">readMeta</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="5bbe" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">自由列表持久性</h2><p id="32c6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们已经定义了元页面，所以我们知道在哪里找到数据。现在，我们需要添加读/写<code class="fe nv nw nx ny b">freelist</code>本身的方法。和以前一样，我们将添加序列化和反序列化的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9f94" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，我们将把<code class="fe nv nw nx ny b">meta</code>嵌入到<code class="fe nv nw nx ny b">dal</code>结构中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9dd2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">使用位于<code class="fe nv nw nx ny b">meta</code>结构中的页码添加读写<code class="fe nv nw nx ny b">freelist</code>页面的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6542" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，更新<code class="fe nv nw nx ny b">dal</code>构造函数来检查数据库是否存在。如果没有，就创建一个新的<code class="fe nv nw nx ny b">meta</code>文件，并初始化<code class="fe nv nw nx ny b">freelist</code>和<code class="fe nv nw nx ny b">meta</code>页面。如果是的话，读取<code class="fe nv nw nx ny b">meta</code>页来找到<code class="fe nv nw nx ny b">freelist</code>页码并反序列化它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="a552" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">第二章结论</h2><p id="a477" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">好吧！我们有毅力。我们可以创建一个新的数据库，关闭它，然后再打开它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bcce" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">注意第0页上的元页面(从第1行开始)包含第1个<code class="fe nv nw nx ny b">freelist</code>页面。</p><p id="9f9b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">正下方(第三行)是<code class="fe nv nw nx ny b">freelist</code>。我们有四个一个四个。前4个数字表示分配的最大页数。1显示了已发布页面列表的长度，最后4位表示唯一已发布的页面。</p><p id="7060" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，我们有了数据，正如您在右栏中看到的，它在数据库重新启动后表现正常。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/176ea48edaf4929954f9d091738533a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vW1wkQD9Z3PR-mpQz0q0eQ.png"/></div></div></figure><p id="fe24" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在下一集，我们将开始探索B树，它是数据库的主要明星。我们需要几集才能完全覆盖它。我们将讨论它们如何帮助我们组织数据以及如何将它们存储在磁盘上。</p><p id="0ffd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可以点击<a class="ae mo" href="https://github.com/amit-davidson/Building-a-NoSQL-database-from-zero/tree/master/Part%202" rel="noopener ugc nofollow" target="_blank">这里</a>查看这部分代码的完整版本。</p><h1 id="9f59" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第三章</h1><p id="9df4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在前两章中，我们完成了数据库在磁盘上的持久化。这意味着我们的数据库可以在两次重启之间恢复到以前的状态。它还支持对磁盘的读写，但是我们必须负责数据的簿记。换句话说，当从数据库中获取一个项目时，我们必须记住它被插入的位置。</p><p id="b4ae" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">今天，我们将谈论B树，数据库的主要明星。我们将看到它们如何帮助我们组织数据，这样用户就不必跟踪每个对象在磁盘上的位置。</p><h2 id="dbb0" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">二叉查找树</h2><p id="b2d0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">二叉查找树(也称为BST)是一种用于以有序方式存储数据的数据结构。树中的每个节点都由一个键、一个与该键相关联的值和两个指向子节点的指针(因此命名为binary)来标识。不变量声明左侧子节点必须小于其直接父节点，右侧子节点必须大于其直接父节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d60b04fff057699bf3651b87503faf2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/0*2wv3HvfmFPFXtQIu.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">二叉查找树</p></figure><p id="8daa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这样，通过查看每个节点的值和相应的下降，我们可以很容易地找到元素。如果搜索到的值小于当前值，则下降到左边的子节点；如果更大，就下降到右边。</p><p id="3f4e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">二叉查找树允许快速查找、添加和移除数据项，因为BST中的节点被布置成使得每次比较跳过剩余树的大约一半。</p><h2 id="b24f" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">动机</h2><p id="b3e3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为什么我们首先需要一棵树？一种简单的方法是创建一个文本文件，然后按顺序写入数据。写入速度很快，因为新数据被附加到文件的末尾。另一方面，读取特定项目需要搜索整个文件。如果我们的文件变大，读取将需要很长时间。</p><p id="de1c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">显然，它不适合许多现实生活中的应用程序。与前面的方法相比，BST提供了更慢的书写速度，有利于更好的阅读。这种平衡的方法是通用数据库的理想选择。</p><p id="5e6c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">另一个考虑因素是磁盘访问。它的成本很高，因此在设计驻留在磁盘上的数据结构时，必须将它保持在最低限度。</p><p id="4670" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一个二叉树节点有2个子节点，因此，例如，拥有2⁵=32项将导致一个有5层的树。在最坏的情况下，在树中搜索一个项目将需要下降5层，依次地，每层需要5次磁盘访问。5不算多，但我们能做得更好吗？</p><h2 id="f4ff" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">b树</h2><p id="630e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">b树是二叉查找树的推广，允许节点有两个以上的子节点。每个节点都有介于<em class="nq"> k </em>到<em class="nq"> 2k </em>键-值对和<em class="nq"> k+1 </em>到2 <em class="nq"> k+1 </em>子指针之间的子指针，只有少至<em class="nq"> 2 </em>子节点的根节点除外。</p><p id="5811" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">通过在每个节点中有更多的孩子，树的高度变得更小，因此需要更少的磁盘访问。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/2561e62f03fd3370e4c1195d41b60747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjlR1redNFBuaVfJA6zBKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">K-V表示一个键值对。p表示子指针</p></figure><h2 id="2510" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">编码</h2><p id="1274" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将从创建一个新文件<code class="fe nv nw nx ny b">node.go</code>开始，并为B树节点的<code class="fe nv nw nx ny b">Node</code>和代表键值对的<code class="fe nv nw nx ny b">Item</code>定义新的类型。</p><p id="5d98" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将为<code class="fe nv nw nx ny b">Node</code>和<code class="fe nv nw nx ny b">Item</code>添加<code class="fe nv nw nx ny b">isLeaf</code>和一个构造函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="4f9b" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">节点页面结构</h2><p id="b6fb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们想在磁盘上存储<code class="fe nv nw nx ny b">Node</code>内容。一种简单的方法是“键值-子指针”三元组的串联，但是它有一个明显的缺点。</p><p id="86e7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">项包含不同大小的键和值。这意味着迭代键值对成为一项重要的任务，因为我们不知道游标每次迭代应该前进多少字节。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/51c5fd424ebbf4f00430dcb681753071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00oOqlIKlV8Pq7h1pfyE2Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">页面用<strong class="bd of"> p表示，</strong>键用<strong class="bd of"> k，</strong>表示，值用v表示</p></figure><p id="2db2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了解决这个问题，我们将使用一种叫做<em class="nq">的技术。该页面被分成两个存储区域。页面末尾是键和值，而开头是对记录的固定大小的偏移。</em></p><p id="d1de" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将添加一个包含页面中记录数量的标题和一个指示页面是否为叶子的标志(因为叶子没有子指针)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c8039f0e0cdd918d6ab9885b8dd10be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*yI8_0O5-0zquW0NFEYnNHA.png"/></div></figure><p id="851a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这种设计允许以最小的努力对页面进行更改。通过对单元格偏移量进行排序来保持逻辑顺序，因此不必重新定位数据。</p><p id="e384" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">每个节点都被序列化为一个页面，但是理解两者之间的区别很重要。</p><p id="4954" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nv nw nx ny b">Node</code>只包含键-值对，在更高的层次上使用。<code class="fe nv nw nx ny b">Page</code>另一方面，工作在存储级，保存任何类型的数据，只要它的大小是4KB。它可以包含以<em class="nq">开槽页面</em>结构组织的键值对，也可以包含以不太严格的形式放置的<code class="fe nv nw nx ny b">freelist</code>和<code class="fe nv nw nx ny b">meta</code>。</p><h2 id="8bc3" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">节点持久性</h2><p id="0d2e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">正如我们在前面章节中所做的，我们将添加数据库节点的序列化和反序列化。这些方法将数据从开槽页面格式转换成开槽页面格式。</p><p id="6616" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">实现是冗长的和技术性的，上面的细节没有什么新东西。最好关注上面描述的一般设计，而不是实现本身(尽管我鼓励您阅读代码)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b845" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将添加<code class="fe nv nw nx ny b">getNode</code>、<code class="fe nv nw nx ny b">writeNode</code>和<code class="fe nv nw nx ny b">deleteNode</code>来返回一个节点。<br/>前两个方法返回<code class="fe nv nw nx ny b">node</code>结构本身，因此它们与我们对<code class="fe nv nw nx ny b">freelist</code>和<code class="fe nv nw nx ny b">meta</code>所做的相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/557d0724efe4d23de8b26cdbc8a2300b.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*i3kwm31_-xmGnSPXEdyM_w.png"/></div></figure><p id="dc9b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nv nw nx ny b">deleteNode</code>向<code class="fe nv nw nx ny b">freelist</code>发信号通知可以删除一个节点，因此它的页面id可以标记为已释放。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="303e" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">搜索、插入和删除</h2><p id="3f7b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在实现搜索、插入和删除算法之前，假设我们会多次调用接收和写入节点是安全的。<br/>我们将使用自己的层来包装对<code class="fe nv nw nx ny b">dal</code>的调用。在未来的部分，这将派上用场。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="30c0" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">搜索</h2><p id="232f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">使用二分搜索法来搜索B树。该算法从根节点开始，遍历所有键，直到找到第一个大于搜索值的键。然后，我们使用相应的子指针下降到相关的子树，并重复这个过程，直到找到值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/73c910b94f4c11b4544992c8d4123561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B--xjy9noLDOpIYOrcCevQ.png"/></div></div></figure><p id="9252" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在示例中，提供了20。在第一级中，没有一个键与20完全匹配，所以该算法下降到正确的范围内——所有大于13的数字。在第二层中最右边的节点上重复该过程</p><p id="efc0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">函数<code class="fe nv nw nx ny b">findKeyInNode</code>在节点内搜索一个键，如上图所示。它将搜索到的关键字与每个级别中的关键字进行比较。如果找到匹配，那么函数返回。如果键不存在，则返回正确的范围。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5ca1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在我们想遍历整个树，并在搜索每个节点时使用前面的函数。我们将执行类似于二分搜索法的搜索。唯一的区别是搜索是对许多子节点而不是两个子节点执行的，如上图所示。</p><p id="33ba" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nv nw nx ny b">findKey</code>功能是围绕<code class="fe nv nw nx ny b">findKeyHelper</code>的包装器，在这里执行重物提升。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5851" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如前所述，搜索是从给定的节点(通常是根节点)开始递归进行的。每个节点都可以从它的父节点到达，但是因为根节点没有父节点，所以我们通过在元页面中保存它的页码来到达它。</p><p id="93ca" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nv nw nx ny b">root</code>属性被添加到元结构中，<code class="fe nv nw nx ny b">serialize</code>和<code class="fe nv nw nx ny b">deserialize</code>也将处理这个字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="70b0" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">第三章结论</h2><p id="6d4d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们测试一下我们的搜索方法。我们的数据库在B树中执行搜索，因此它希望数据库页面以B树格式放置。</p><p id="419a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还没有办法创建一个，所以我添加了一个名为<code class="fe nv nw nx ny b">mainTest</code>的模拟文件，它已经用这种方式构建好了。该文件包含一个键值对。键是“Key1”，值是“Value1”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/3eb53bc0240ecc0b5e19d0bf23a62b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*_jRI_16VaYBaWba1rkPl1Q.png"/></div></figure><p id="3bb7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在接下来的两章中，我们将实现对数据库的写入和删除。你可以在这里找到这部分<a class="ae mo" href="https://github.com/amit-davidson/Building-a-NoSQL-database-from-zero/tree/master/Part%203" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><h1 id="38da" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第四章</h1><p id="5859" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在上一章中，我们讨论了B树。它们是二叉查找树的推广，允许节点有两个以上的子节点。树的高度被最小化，从而减少了磁盘访问。</p><p id="7490" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还讨论了开槽页面。一种布局，通过在开头放置固定大小的偏移量，在结尾放置实际数据本身来组织不同大小的键值对。</p><p id="a0ae" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，我们开始在B树上实现基本操作:搜索、插入、删除。在前一章中，我们实现了搜索操作。我们将在这一个中做插入。</p><h2 id="44a9" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">问题</h2><p id="85d1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">插入新项目可能会导致节点包含太多项目。例如，当所有新对都插入到同一个节点中时。</p><p id="32a5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这使得操作速度变慢，因为每次访问节点时我们都要迭代更多的条目。除此之外，它还会导致一个更严重的问题。节点被转换成固定大小的<em class="nq">数据库页面，</em>因此基于键值对的总大小，每个节点中的键值对的数量是有限制的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/da460845dd67aeb34ab52ef5b66c01d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1G9BhfAccDk2sqxtanyLg.png"/></div></div></figure><p id="7c5f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">删除也有类似的问题。从同一个节点中删除键值对可以收缩一个节点，所以它包含的键值对非常少。此时，最好以某种方式将这些对重新分配到不同的节点。</p><p id="b43b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">要知道一个节点是达到最大值还是使用率不足，我们必须首先定义它。我们将添加一个上限和下限，即页面大小的百分比。</p><p id="08a8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在代码中，我们引入了<code class="fe nv nw nx ny b">Options</code>，它将由用户初始化并在我们的DB init函数中使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1165" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将为<code class="fe nv nw nx ny b">dal</code>和<code class="fe nv nw nx ny b">node</code>添加新的方法，用于计算节点大小(以字节为单位)并将其与阈值进行比较。<code class="fe nv nw nx ny b">elementSize</code>计算给定索引处的单个键值子三元组的大小。<code class="fe nv nw nx ny b">nodeSize</code>对节点头大小以及所有键、值和子节点的大小求和。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="5855" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">解决办法</h2><p id="f693" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当树中的一个节点有太多的键值对时，解决方案是将它分成两个节点。</p><p id="689e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">拆分是通过分配一个新的节点，将一半的键-值对转移到那里，并将它的第一个键和指向该节点的指针添加到父节点来完成的。如果它是一个非叶节点，那么拆分点之后的所有子指针也将被移动。</p><p id="222d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第一个键和相应的指针被移动到父项，从而增加了它的占用率。该过程可能导致溢出，因此必须沿树向上递归重复重新平衡。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/7afd9f24a41a2cf6cce22f8e37b78a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/0*qKU4YlBX_ch89BNq.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">插入4和7时会进行拆分。图片取自维基百科</p></figure><h2 id="b379" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">插入</h2><p id="4f24" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">插入项目的算法如下:</p><ol class=""><li id="d87f" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi om mv mw mx bi translated">搜索树以找到应该插入新元素的叶节点并添加它。</li><li id="77c3" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">如果节点超过最大占用率，如上所述重新平衡树:<br/> a .找到分裂索引<br/> b .小于分离值的值留在现有节点中，大于分离值的值放入新创建的右节点中。<br/> c .分离值被插入到节点的父节点中。</li><li id="a99a" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">重复步骤2，从插入节点开始到根节点。</li></ol><h2 id="46cc" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">辅助方法</h2><p id="a6a8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将从算法的第一步开始。方法<code class="fe nv nw nx ny b">addItem</code>在给定的索引处添加一个键值对，然后移动所有的键值对和子键值。这个简单的方法可以很容易地与标准库一起提供。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6e96" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于步骤2，我们将添加四种方法来确定节点是否达到最大占用率。(或删除所需的最小占用率)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cd4f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将为<code class="fe nv nw nx ny b">node</code>添加相应的方法进行解耦，这将在后面对我们有所帮助。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2c7f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">既然我们已经知道了重新平衡是否必须发生，我们将编写重新平衡本身。关注2.a，<code class="fe nv nw nx ny b">getSplitIndex</code>根据元素大小和最小节点大小计算应该拆分节点的索引。它以字节为单位对键值对的大小求和。一旦积累到足够的数量，就返回索引。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="696a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，我们将添加<code class="fe nv nw nx ny b">split</code>来处理步骤2.b和2.c。它在一个节点上被调用，并接收它的一个子节点和它在<code class="fe nv nw nx ny b">childNodes</code>列表中的索引。</p><p id="395a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如前所述，首先确定分裂指数。拆分索引左侧的对保持不变，而右侧的对被移动到一个新节点。如果存在子指针，后半部分也会被移动。</p><p id="4bf3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">拆分索引中的对被移动到父节点，指向新创建的节点的指针被添加到父节点中的正确位置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="a273" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">把它们放在一起</h2><p id="4c23" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在我们将上述方法结合到插入函数之前，我们将引入集合<em class="nq">的概念。一个<em class="nq">集合</em>是一组键值对。一个<em class="nq">集合</em>相当于一个RDBMS表。<em class="nq">集合</em>中的键值对有类似的用途。</em></p><p id="5da3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将在后面的文章中回到集合的概念。现在，我们将添加一个名为<code class="fe nv nw nx ny b">Collection</code>的结构以及<code class="fe nv nw nx ny b">Find</code>和<code class="fe nv nw nx ny b">Put</code>方法。</p><p id="f182" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">集合本身就是B树。因此，每个集合都有一个名称和一个标记树根节点的根页面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bf9d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nv nw nx ny b">Find</code>方法加载集合根节点，并在该节点上执行<code class="fe nv nw nx ny b">findKey</code>来定位键。如果没有找到键，则返回<code class="fe nv nw nx ny b">nil</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="75aa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">本章总结了我们在这一章中所做的所有工作。它从用户那里接收一个键值对，并将其插入到集合的B树中。</p><p id="f0d2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在第9–23行，该方法检查一个根节点是否已经初始化或者它的第一次插入，因此必须创建一个新的根节点。</p><p id="a961" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在第26–36行，我们搜索应该插入的树。<code class="fe nv nw nx ny b">findKey</code>返回应该插入的节点和索引。如果我们需要重新平衡树，它还返回指向修改节点的路径中的节点(作为索引——每个节点都可以从其父<code class="fe nv nw nx ny b">childNodes</code>数组中检索)。</p><p id="bd01" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在第31–41行，我们执行实际的插入。我们首先检查密钥是否已经存在。如果是这样，我们只用新值覆盖它。如果没有，我们插入它。由于B树的工作方式，新项目只能添加到叶节点。这意味着我们不需要照顾孩子。</p><p id="bec1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，如果需要，我们在第49–56行和第59–71行重新平衡。第一个块重新平衡了插入路径，不包括根。第二个块重新平衡根并更新集合的根指针。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="6292" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">第四章结论</h2><p id="39d2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这一部分的重点是插入数据库。现在，我们可以像用户一样在数据库中插入和查找项目。</p><p id="570a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在下面的代码中，我们用<code class="fe nv nw nx ny b">MinFillPercent</code>和<code class="fe nv nw nx ny b">MaxFillPercent</code>创建了一个新的数据库，当一个节点有六个或更多条目时，这将导致一个节点被分割。我们创建一个新的集合，将DB根页面指定为集合根页面。最后，我们模拟一个实际的用户操作，向集合中添加新的条目并搜索它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/5f13106f41b221c23a1b67fbb39b1d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*ZvW2AWa0Iv6IoR-AmrtlAA.png"/></div></figure><p id="31b5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在我们的文件上运行<code class="fe nv nw nx ny b">hexdump</code>,我们可以观察到发生了分割。我们有一个包含4的根节点。然后，我们有两个子节点，一个节点包含对1–3，另一个节点包含键5–6。</p><p id="1942" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">此外，由于节点被设计为分槽页，请观察上下地址是如何写在每页上的，并且中间的空间保持为空。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9edc4c987bfa1ecd69c1a9ce0702ecaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZeZZSgoeWXR4mD-c8aD2w.png"/></div></div></figure><p id="a41a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在下一部分中，我们将重点讨论删除。它不会像这一部分那么密集，因为我们在这一部分中添加的许多函数将在以后使用。</p><p id="20cd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你可以在这里查看这部分<a class="ae mo" href="https://github.com/amit-davidson/Building-a-NoSQL-database-from-zero/tree/master/Part%204" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><h1 id="9002" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第五章</h1><p id="19de" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在前两部分中，我们讨论了B树并实现了查找和插入方法。在这一部分，我们将实现删除操作，并结束对B树的讨论。</p><h2 id="b866" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">删除</h2><p id="73f0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">删除项目的算法如下:</p><ol class=""><li id="b933" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi om mv mw mx bi translated">找到要删除的项目。</li><li id="7e43" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">删除项目:<br/> a如果值在叶节点中，只需从节点中删除即可。<br/> b否则，(值在内部节点中)，选择一个新的分隔符——左子树中最大的元素，将其从所在的叶节点中删除，并用新的分隔符替换要删除的元素</li><li id="7f0f" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">重新平衡树，从叶节点或根据上述情况选择分隔符的节点开始。</li></ol><h2 id="fb84" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">删除实现</h2><p id="fe92" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将关注第二点。</p><p id="5e4e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们需要处理两种情况。第一个(2.a)是从叶节点中删除一个节点。这种情况很简单，因为我们只需要将它从节点中移除。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4a8a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">另一方面，如果我们遇到一个内部节点(2.b ),我们需要定位它的前身并使它成为新的分隔符。在第15行，我们选择左边的子树，并在第20–27行下降到最右边的子树，得到左边子树中包含最大项目的节点。</p><p id="478e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在第30–32行，我们用它的前身——左子树中最右边的一对——替换要删除的项，并将其从它所在的叶节点中删除。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="e00a" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">为…修复平衡</h2><p id="3ffc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将关注第三点。</p><p id="6c88" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当向一个节点输入一个新项时，可能会导致其中一个节点溢出，导致树失去平衡。删除会导致下溢，所以我们必须立即重新平衡树。</p><p id="6b3f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">与插入不同，在插入中，重新平衡只能通过拆分节点来完成，删除操作后的重新平衡可以是合并或旋转节点。</p><p id="cb4a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">可以向右或向左旋转，这取决于哪个节点有备用项目。例如，右旋转是通过将分隔符从父节点复制到下溢节点的开始，并用其左兄弟节点的最后一个元素替换分隔符来完成的。当旋转非叶节点时，左兄弟的最后一个子指针被移动到不平衡节点的开始。当执行向左旋转时，采用类似的方法。</p><p id="6c0e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在下面的示例中，删除了15，导致右边的孩子拥有的项目太少。这导致右旋转。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/adb19f10a5997208f05804a2d944836c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U44xKwRNxHWt2npMz7hU7A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向右旋转</p></figure><p id="f329" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果没有兄弟节点可以保留一个元素，那么有缺陷的节点必须与兄弟节点合并。合并会导致父级丢失分隔符元素，因此父级可能会变得不足，需要重新平衡。再平衡可能会一直持续到根本。</p><p id="a126" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在这种情况下，15被删除。向右旋转是不能进行的，因为这会使左边的孩子处于赤字状态。因此，解决方案是将这些节点合并成一个节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/2720edd08093e4de5f8da53010606d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOllP1YxYUhBU4Ijq_MPGg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">合并</p></figure><p id="c053" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">与前一章类似，我们将开始添加一些辅助函数，并将它们组合成一个位于<code class="fe nv nw nx ny b">collection</code>结构下的函数。</p><p id="ae6d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们的前两个函数是左右旋转。这两个函数几乎相同，所以让我们来看看向右旋转的情况。</p><p id="7a6b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">旋转是按照注释中的解释完成的。给定节点A，我们删除它的最后一项。我们将它替换为父节点中正确索引中的项目，并将最初在父节点中的项目放入B节点中。</p><p id="8921" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">正确的索引是父节点中这两个节点之间的项目的索引。如果存在任何子指针，它们也会被移动。</p><p id="132f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">两种旋转的代码是相似的。区别在于受影响的节点和被移动的键值对。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6783" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">接下来，是<code class="fe nv nw nx ny b">merge</code>。merge函数接收一个节点及其索引。然后，它将该节点与其左边的兄弟节点合并，传输其键值对和子指针。该函数完成后，它会删除该节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="24e3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，我们将编写<code class="fe nv nw nx ny b">reblanceRemove</code>来决定当树失去平衡时应该应用什么算法。</p><p id="917b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在每次旋转中(第9–19行和第22–32行)，我们确保不平衡节点不在边上，因此它有一个左/右兄弟节点。我们还确保兄弟元素可以保留一个元素，这意味着它的兄弟元素在操作后不会下溢。如果两个条件都为真，则选择旋转。</p><p id="f916" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果两个条件都不成立，那么我们执行一个合并(第36–45行)。merge函数将一个节点与其左边的兄弟节点合并。如果我们在最左边的兄弟节点上，使用右边的一个节点，这就是第36行的<code class="fe nv nw nx ny b">if</code>条件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="20a2" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">把它们放在一起</h2><p id="42a4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将添加一个新方法<code class="fe nv nw nx ny b">Remove</code>到集合中。在第8–11行，加载根节点，然后在第13–16行，我们执行算法中的步骤1，定位要删除的项目。如果它不存在，我们在第18–20行返回。</p><p id="8d5b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在第22–30行，我们根据算法中的步骤2删除项目。我们扩展我们的祖先列表来跟踪可能受叶节点移除影响的任何节点。</p><p id="69d1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，在第32–47行，我们跟踪<code class="fe nv nw nx ny b">ancestorsIndexes</code>列表中可能受到影响的节点，并在需要时重新平衡它们。</p><p id="7b9e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，在第51–53行，如果根节点是空的(例如，如果它原来有一个项目，但被删除了)，那么我们忽略它，并将其子节点指定为新的根节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="22dc" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">结论</h2><p id="849b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在下面的代码中，我们用第29行的remove操作扩展了上一章的程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="95d9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">运行它，我们得到预期的移除后的<code class="fe nv nw nx ny b">nil</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/13b08ef1d66fe40b431fdf3414db3737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*I5c0utv7olCEkJgLESMC9A.png"/></div></figure><p id="ca7a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">请记住，在上一部分中，在插入6之后出现了拆分。您可以在下图的左侧查看它的状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/1bb845cf60813cb2b13cdb6de5f20e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-0l_NkTwAABMo9mkUwQzQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">删除键1导致合并</p></figure><p id="d76e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">移除操作之后，树会失去平衡。右边的兄弟只有两个项目，不足以执行左旋转。因此，选择了合并平衡策略。合并操作后的树在右边。</p><p id="e48f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">运行<code class="fe nv nw nx ny b">hexdump</code>，我们如预期的那样到达第3页(从<code class="fe nv nw nx ny b">00002000</code>开始)。所有对都在同一个节点上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/57f88bb68426bd1077ef3468335d13e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BU4Yq9gxu9kAy1k-KOjYIg.png"/></div></div></figure><p id="ed23" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">需要注意的是，这个过程并没有就此结束。请记住，在合并过程中，会删除一个节点。该节点被<code class="fe nv nw nx ny b">freelist</code>标记为空闲。当更新的<code class="fe nv nw nx ny b">freelist</code>被提交时，它被写入第5页，在第5页中，5和6在<code class="fe nv nw nx ny b">Insert</code>操作后驻留(查看前一部分末尾的文件状态)。</p><p id="378f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">提交<code class="fe nv nw nx ny b">freelist</code>是笨拙的，但却是必要的，还有在一系列读/写操作之后应该执行的其他操作。</p><p id="dee0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在下一章，我们将介绍数据库事务的概念。一个工作单元由对数据库执行的一系列操作组成。他们将处理在一系列操作开始和结束之前需要执行的工作，以及许多其他工作。</p><h1 id="7f9c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第六章</h1><p id="f866" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在前三部分，我们讨论了B树。我们实现了B树方法，如查找、插入和删除。这些方法接近于磁盘级别，因为它们定义了哪些布局页面应该保存在磁盘上。</p><h2 id="ce0a" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">处理</h2><p id="5e79" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">今天，我们介绍交易的概念。事务是一个更高层次的概念。事务是一个工作单元，由对数据库执行的一系列操作组成。</p><p id="b539" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">例如，从账户A向账户B转账包括:</p><ol class=""><li id="0524" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi om mv mw mx bi translated">读取账户a的余额。</li><li id="cdf1" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">从那笔金额中扣除50美元，写回账户a。</li><li id="c3ba" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">读取账户b的余额。</li><li id="25ac" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">在这个数额上加50美元，它又回到b账户。</li></ol><p id="2ca7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所有这些操作合在一起就是一个事务。</p><h2 id="9f5b" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">酸</h2><p id="c6c4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">酸代表原子性、一致性、隔离性和持久性。它是数据库的一组属性，保证事务得到可靠的处理。</p><ul class=""><li id="8d8e" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi mu mv mw mx bi translated"><strong class="lp ir">原子性</strong>意味着要么所有事务都成功，要么都不成功。它确保数据库不会处于未定义的状态。<br/>我们的数据库不是原子的，因为如果事务中途失败(如果数据库崩溃)，事务的一部分被提交，而另一部分没有。<br/>我构建了数据库，以便可以轻松扩展来支持它，但这也涉及更多代码，超出了我们数据库的范围。</li><li id="397c" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">一致性</strong>确保在事务完成后，根据所有定义的规则，写入数据库的数据必须有效。例如，银行账户的余额必须是正数。</li><li id="4eaa" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">隔离</strong>是衡量事务如何彼此隔离发生的尺度。换句话说，交易对他人的影响到什么程度。在下一节中，我将更多地关注这一点。</li><li id="148f" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated"><strong class="lp ir">持久性</strong>意味着一旦事务被提交，即使在系统出现故障的情况下，数据也会被保留。<br/>我们的数据库是持久的，因为数据库持久存储在磁盘上。与内存(RAM)数据库不同，崩溃后数据仍保留在磁盘上。</li></ul><h1 id="d1cf" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">隔离</h1><p id="fed1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先，我们将描述当多个事务同时运行<strong class="lp ir">和</strong>时可能发生的三种异常。</p><h2 id="2fb6" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated"><strong class="ak">脏读</strong></h2><p id="c1c7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当允许事务从已被另一个正在运行的事务修改但尚未提交的行中读取数据时，就会发生<em class="nq">脏读</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/38626eb39b2007ac3b095e412c57100b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*KujjYTFtRUx5UJn6op8muQ.png"/></div></figure><h2 id="9346" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">不可重复读取</h2><p id="d3b7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="nq">不可重复读取</em>发生在事务过程中，当一行被检索两次，并且行内的值在两次读取之间不同时。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/7415d499ffc0c19bf903469d4776b570.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*yhAfZrjJiovqRv2AppoHtA.png"/></div></figure><h2 id="e431" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">幻像读取</h2><p id="3f47" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="nq">幻像读取</em>发生在事务过程中，当另一个事务向正在读取的记录中添加或删除新行时。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ef3f2d9bbaae09a1e5d3e3bb5f57a644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*tKBTtr7LbS2yIjz--lhrnQ.png"/></div></figure><p id="b1e6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="nq">脏读</em> <strong class="lp ir"> </strong>从另一个事务读取<strong class="lp ir">未提交的</strong>数据。<br/> <em class="nq">不可重复读取</em> <strong class="lp ir"> </strong>从另一个事务的<strong class="lp ir">更新</strong>查询中读取<strong class="lp ir">提交的</strong>数据。<br/> <em class="nq">幻影读取</em>从另一个事务的<strong class="lp ir">插入</strong>或<strong class="lp ir">删除</strong>查询中读取<strong class="lp ir">提交的</strong>数据。<br/> <em class="nq">虚拟读取</em>是<em class="nq">不可重复读取</em>的更复杂变体。<em class="nq">幻像读取</em>涉及范围扫描，因此问题不像<em class="nq">不可重复读取</em>那样出现在单个文档中，而是出现在多个文档中。</p><h2 id="e3f5" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">隔离级别</h2><p id="eca5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">SQL标准根据以下现象定义了四个隔离级别:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/ee1e5301ab1aface2b0682ef969782a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCQeQG1uBEh1jA7ZY6KrQg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">摘自维基百科</p></figure><p id="2829" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在我们的数据库中，我们将有一个<em class="nq">可序列化的</em>隔离级别。每个事务在下一个事务开始之前执行完毕。</p><p id="1f5b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将通过在事务开始前获取一个RW锁，并在事务结束时释放它来实现这一点。一个RW锁可以由任意数量的读取器或单个写入器持有。</p><p id="3a31" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这意味着我们的数据库可以在任何给定时间支持单个写入者或多个读取者，但不能同时支持两者。</p><h1 id="71a8" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">开始编码</h1><h2 id="8e76" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">分贝</h2><p id="cf93" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将创建一个名为<code class="fe nv nw nx ny b">db.go</code>的新文件。我们将添加一个名为<code class="fe nv nw nx ny b">DB</code>的新结构以及方法<code class="fe nv nw nx ny b">Open</code>和<code class="fe nv nw nx ny b">Close</code>。<code class="fe nv nw nx ny b">DB</code>包含<code class="fe nv nw nx ny b">dal</code>和一个RW锁。如上所述，它管理对磁盘的访问，并确保并发事务不会导致任何异常。</p><p id="f241" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nv nw nx ny b">DB</code>是面向用户的，所以我们将使用公共方法包装<code class="fe nv nw nx ny b">dal</code>层。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d310" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将添加两个方法<code class="fe nv nw nx ny b">ReadTx</code>和<code class="fe nv nw nx ny b">WriteTx</code>，用于打开事务和获取锁。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="7fd3" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">处理</h2><p id="3516" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将添加一个名为<code class="fe nv nw nx ny b">tx.go</code>的新文件。我们将添加一个新的<code class="fe nv nw nx ny b">tx</code>结构和构造函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a0a2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nv nw nx ny b">write</code>标志表示交易是否为只读。当只读事务试图进行更改时，我们将向<code class="fe nv nw nx ny b">const.go</code>添加一个新的错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="efa4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后在前面几集的<code class="fe nv nw nx ny b">Put</code>和<code class="fe nv nw nx ny b">Remove</code>方法中使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3227" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一旦事务开始，它要么提交并保存所有修改的数据，要么回滚并忽略所有更改。提交更改很容易，正如我们在前面的部分中已经做的那样，但是回滚更复杂。</p><p id="d803" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一种更简单的方法不是在执行回滚时恢复更改，而是将修改后的节点临时存储在RAM中，然后一次将它们传播到磁盘。然后要执行回滚，我们必须什么都不做，因为数据没有提交。</p><p id="175b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为此，<code class="fe nv nw nx ny b">dirtyNodes</code>持有已修改的节点，等待提交。<code class="fe nv nw nx ny b">pagesToDelete</code>保存等待删除的页面。并且<code class="fe nv nw nx ny b">allocatedPageNums</code>保存我们在事务期间由<code class="fe nv nw nx ny b">freelist</code>分配的任何新的<code class="fe nv nw nx ny b">pageNums</code>。</p><p id="496c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果事务被读取，执行回滚很简单，因为只需要释放互斥体。如果是写事务，我们必须释放由<code class="fe nv nw nx ny b">freelist</code>给出的页面，将片标记为<code class="fe nv nw nx ny b">nil</code>并释放互斥体。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="502a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">执行<code class="fe nv nw nx ny b">Commit</code>也很简单。在读事务中，只有互斥体必须被释放。在写操作中，将保存修改的节点，删除删除的节点，并标记所有获取的页面。最后，互斥体被释放。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b2c2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在我们想把我们在前面几集添加的读/写/删除操作重定向到<code class="fe nv nw nx ny b">dirtyNodes</code>和<code class="fe nv nw nx ny b">pagesToDelete</code>而不是磁盘。这意味着我们必须检查代码，将对<code class="fe nv nw nx ny b">dal</code>的访问替换为对<code class="fe nv nw nx ny b">tx</code>的访问。</p><p id="0925" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">例如，进行以下更改:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cbed" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">或者集合文件中的以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1ef5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这个过程很漫长，但是你可以在<a class="ae mo" href="https://github.com/amit-davidson/Building-a-NoSQL-database-from-zero/tree/master/Part%206" rel="noopener ugc nofollow" target="_blank"> Github </a>上检查所有的改动。</p><p id="eba1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">重要的是要注意，一旦我们写一个节点，它实际上不是写到磁盘，而是写到一个临时缓冲区。如果系统中途失败，我们将无法从崩溃点继续交易。</p><p id="5b89" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了解决这个问题，可以使用<em class="nq"> WAL </em>来跟踪变更。它代表<em class="nq">预写日志</em>，用于提供原子性和持久性。它通常被实现为一个只附加的日志文件，记录对数据库的更改。</p><p id="b162" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，每次调用(或删除)write node方法时，我们可以在单独的日志文件中记录更改(而不是在B树中！).如果系统崩溃，我们可以从最后一次调用中恢复数据库。</p><p id="1a02" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这也超出了我们数据库的范围，但是我们的数据库是专门构建的，因此可以很容易地通过这种改进进行扩展。</p><h2 id="cf05" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">第六章结论</h2><p id="c503" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这一部分，我们不会展示我们的新功能，但是在下一部分，我们将有一个自底向上的工作数据库。我们将添加新的方法来处理集合，这将总结我们数据库的所有关键特性。</p><h1 id="45b6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第七章</h1><p id="5020" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这一部分，我们将完成数据库。我们将深入了解之前已经看过的系列。这部分也将是我们的最后一集。</p><h2 id="7026" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">收集</h2><p id="48f9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们已经介绍了集合的概念。它们存储具有类似目的的键值对，相当于RDBMS表。</p><p id="d45e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们讨论了在给定的集合中添加/移除/搜索<strong class="lp ir">，但是我们没有讨论如何<strong class="lp ir">创建</strong>它们。</strong></p><p id="1ab9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这个想法是有一个主集合来保存其他集合(<em class="nq">根集合</em>)。它将包含键值对，其中<strong class="lp ir">键</strong>是集合名称。</p><p id="7925" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在B树中，每个节点都是子B树的根，因此每个集合本身就是B树，并且是整个B树的子B树。<strong class="lp ir">值</strong>将指向作为集合子树的根的页码。</p><p id="32aa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">记住,<code class="fe nv nw nx ny b">meta</code>页面保存了B树根的页码。<code class="fe nv nw nx ny b">root</code>字段将指向<em class="nq">根集合</em>的根页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/aa671d13b7f88ae1a922841232849b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DJlkPpcLGVgSGWOKe5DGQ.png"/></div></div></figure><p id="5718" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在数据库中搜索键值对的实际流程如下:</p><ol class=""><li id="3321" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi om mv mw mx bi translated">首先检索要在其中执行搜索的所需存储桶。数据库将在<em class="nq">根集合</em>中搜索给定的集合。</li><li id="eda0" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">获取集合子树根页面</li><li id="0caf" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi om mv mw mx bi translated">从根页面开始，在集合子树中找到所需的元素。</li></ol><p id="90d9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第1步和第3步都使用了我们在第4部分中实现的<code class="fe nv nw nx ny b">Find</code>方法。不同之处在于搜索到的集合。下图显示了流程，其中每个箭头对应流程中的一个步骤。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/06d68ebaf3e2a123f6a6849481763a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rebSSZYOpjGhx_NgglVxXw.png"/></div></div></figure><h2 id="6673" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">开始编码</h2><p id="2d25" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将从实现检索根集合的方法开始。关键部分是将它的根页面分配给整个数据库的根页面。</p><p id="7e75" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后我们会像上面讨论的那样加上<code class="fe nv nw nx ny b">GetCollection</code>。在根集合中搜索集合名称，反序列化内容，并返回。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="943b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">创建和删除集合是相似的。在<em class="nq">根部集合</em>上涂抹<code class="fe nv nw nx ny b">Put</code> / <code class="fe nv nw nx ny b">Remove</code>。此外，确保调用事务是写事务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="a048" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">神奇的数字</h2><p id="7d3a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将添加最后一个不错的特性。幻数是用于标识文件格式的常量数值或文本值。程序在第一个字节中存储一个标识符，比如<code class="fe nv nw nx ny b">CA FE BA BE</code>(例如Java类文件)。当程序加载时，它将第一个字节与预期的签名进行比较，并确保它们相等。</p><p id="96e4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将把我们的幻数定义为<code class="fe nv nw nx ny b">D00DB00D</code>(但它可以是您选择的任何值)。在将元页面写入磁盘时，我们将包括幻数。当数据库启动时从磁盘加载它时，我们会将文件内容与预期的签名进行比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="4384" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">第七章结论</h2><p id="a398" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是一个漫长的旅程，但我们的数据库现在已经完成。如果你跟着我走到这一步，你应该感到欣慰。</p><p id="00a6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">要测试我们的数据库，您可以使用在<a class="ae mo" href="https://github.com/amit-davidson/LibraDB" rel="noopener ugc nofollow" target="_blank"> Github </a>上完成的测试中的一个，或者编写您的场景。并发或非并发的读/写操作的任意组合都可以工作。</p><h1 id="731f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">总结和结束语</h1><p id="e100" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在第1章中，我们介绍了一些宽泛的术语，如SQL与NoSQL、数据结构和基于磁盘的存储。我们讨论了我们的数据库，特别是<em class="nq"> dal </em>层及其组件，例如<em class="nq"> freelist </em>和<em class="nq">数据库页面。</em></p><p id="682b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">第2章</strong>是关于磁盘的持久性。我们在文件的第一页引入了一个特殊的页面，叫做<em class="nq"> meta。它保存了我们的数据库正确启动所需的所有信息。我们还增加了写入磁盘的方法，比如:<em class="nq"> meta </em>和<em class="nq"> freelist </em>页面的<code class="fe nv nw nx ny b">serialize</code> / <code class="fe nv nw nx ny b">deserialize</code>和<code class="fe nv nw nx ny b">read</code> / <code class="fe nv nw nx ny b">write</code>。每当有新的实体添加到数据库中时，这些方法就会重新出现。</em></p><p id="7c23" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第3、4和5章是关于B树的。在第3章中，我们介绍了二分搜索法树，并讨论了数据库中B树的基本原理。我们决定使用<em class="nq">开槽页面。</em>一种在磁盘上组织数据的技术，将数据存储在每页的末尾，并将固定大小的指针指向数据的开头。</p><p id="261d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，我们开始编写B树，并通过搜索操作完成了这一部分。</p><p id="0044" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">在第4章</strong>中，我们使用B树对数据库进行编码插入。我们首先看到了保持B树平衡的重要性，并增加了确定树是否失去平衡的方法——节点中的元素是否过多/过少。然后我们编写了处理再平衡的<code class="fe nv nw nx ny b">split</code>方法和插入方法本身。我们也第一次看到了<code class="fe nv nw nx ny b">collection</code>实体。</p><p id="4d27" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">在第5章</strong>，我们通过实现删除和适当的平衡方法——左/右旋转和合并，完成了B树的编码。</p><p id="ecda" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">第6章不同于之前的部分，因为我们没有处理磁盘操作。我们提出了事务的主题——一个由对数据库执行的一系列操作组成的工作单元。</p><p id="a0d8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们讨论了ACID——可靠处理事务的一组属性。我们还仔细研究了隔离，并使用锁来确保并发事务不会相互干扰。</p><p id="66ae" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">最后，在第7章</strong>，我们添加了收集机制，这是数据库运行的最后一部分，以及完全封闭它的幻数。</p><p id="e59d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">下面你可以看到我们的数据库的一般架构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/d6e0eb7f169cd9046df7c50a2e9beffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NziZHy0960OJdRFdQLoyfA.png"/></div></div></figure></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><p id="3833" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">从我开始写数据库到文章完成已经一年了。我希望你喜欢读我的帖子，就像我喜欢为你写一样。请务必在<a class="ae mo" href="https://github.com/amit-davidson/LibraDB" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看名为LibraDB的完整数据库。</p></div></div>    
</body>
</html>