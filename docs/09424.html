<html>
<head>
<title>Object-Oriented Programming in Python vs. Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python与Java中的面向对象编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/object-oriented-programming-in-python-vs-java-e3b2c5fe38e0?source=collection_archive---------1-----------------------#2021-08-24">https://betterprogramming.pub/object-oriented-programming-in-python-vs-java-e3b2c5fe38e0?source=collection_archive---------1-----------------------#2021-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fef1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python的神奇之处</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63db2e6e01e04600d04fafeed5996ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pObqZjcyGVB_Jw--"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布鲁斯·沃林顿在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的OOP(面向对象编程)可能与您可能习惯的其他编程略有不同。从Java来看，这两者似乎几乎没有关联。</p><p id="b60f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将从Java的角度来看Python的OOP。随着Java成为最流行的面向对象编程语言之一，这将使它适用于所有这些Python例子。</p><p id="9e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先看一个标准的Java类，代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码中，您可以看到这是您的标准Java类。这是一个学生班。它有三个属性:<code class="fe lx ly lz ma b">school</code>、<code class="fe lx ly lz ma b">name </code>和<code class="fe lx ly lz ma b">age</code>。这些都是私有属性。我们应该知道，私有属性的目的是为了封装。这是只允许通过方法(通常是getter和setter)修改属性的原则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python来了。</p><p id="8aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经用Python创建了一个Java类的等效版本。您可能会注意到语法上的一些差异，但都是一样的。</p><h1 id="48fb" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">构造器</h1><h2 id="9764" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Java </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/5d7908bbe75ec0c86490d6493e0d5b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RaYXtiOZLQni4XHp1_pMQ.png"/></div></div></figure><p id="afda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Java，您可以使用类名来创建您的构造函数<code class="fe lx ly lz ma b">public <strong class="lb iu">Student</strong>(String name, int age)</code>。<code class="fe lx ly lz ma b">this</code>指该类的当前实例。因此使用<code class="fe lx ly lz ma b">this.&lt;variable name&gt;</code>指的是在Java代码顶部声明的属性。</p><h2 id="e86b" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Python </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c8d51a72bef4f3064774ea106a4c9e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3x-hSPw1QAwph9pPKBc4w.png"/></div></div></figure><p id="288d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Python，我们对构造函数使用<code class="fe lx ly lz ma b">__init__</code>方法。您稍后会注意到一种趋势，方法的两端都有双下划线。</p><p id="cebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到位于构造函数开头的<code class="fe lx ly lz ma b">self</code>参数。<code class="fe lx ly lz ma b">self</code>告诉Python这是一个方法。它让方法的其余部分可以访问该类的实例变量和方法。当您调用该方法时，Python自动将第一个参数作为<code class="fe lx ly lz ma b">self</code>传递。</p><p id="1e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造函数内部，我们分配了两个实例变量。<code class="fe lx ly lz ma b">__name</code>和<code class="fe lx ly lz ma b">__age</code>。注意，我们必须使用<code class="fe lx ly lz ma b">self</code>来指定它是一个实例变量，不像Java，我们不必事先声明变量，因为Python是一种动态类型语言。</p><h1 id="da73" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">属性</h1><h2 id="1ed5" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Java </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/1930896df95127c4892c8677fb6de16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auRndJ9g7f2Bt3_YP1gpig.png"/></div></div></figure><p id="d619" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Java，您将希望属性拥有的特定访问类型放在声明变量的开头。有三种类型的访问修饰符:<code class="fe lx ly lz ma b">public</code>、<code class="fe lx ly lz ma b">private</code>和<code class="fe lx ly lz ma b">protected</code>。</p><ul class=""><li id="17df" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">公共—可以从任何地方访问。</li><li id="82ac" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">private只能在当前类中访问。</li><li id="428e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">受保护-只能由当前类及其子类访问。</li></ul><p id="497f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的类中，所有的属性(<code class="fe lx ly lz ma b">age</code>、<code class="fe lx ly lz ma b">name</code>、<code class="fe lx ly lz ma b">school</code>)都是私有的。</p><h2 id="2105" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Python </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/99d517f310c576b4ce138df432709618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sbpw81x1LyIdMLyqMzkcDw.png"/></div></div></figure><p id="b0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Python，没有明确的方法来强制私有或受保护的访问修饰符。一切永远是公开的。然而，Python有通用的约定，无论什么时候看到你都能立刻知道具体的访问修饰符。</p><p id="e64c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python使用下划线<code class="fe lx ly lz ma b">_</code>来表示不同类型的访问。在上面的代码中，由于开头有双下划线，所以访问当前为<code class="fe lx ly lz ma b">private</code>。</p><ul class=""><li id="4a52" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">公共-无下划线。</li><li id="b1af" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">受保护-单下划线。</li><li id="7b55" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">私有-双下划线。</li></ul><p id="8fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面显示不同访问类型的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/ebe06463758030ec26ff9d472832ca5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ziZHXI7u9AnInnejkfaZw.png"/></div></div></figure><p id="b522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了方便起见，我将这些变量初始化为<code class="fe lx ly lz ma b">None</code>。这是完全可选的，因为正如我前面所说的，Python是一种动态语言，变量可以在构造函数中定义。</p><p id="e7fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实例化我们的对象，看看这些访问约定。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="e496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到<code class="fe lx ly lz ma b">health</code>和<code class="fe lx ly lz ma b">_magic</code>都很容易通过调用它们各自的变量来访问。<code class="fe lx ly lz ma b">health</code>成为公共的通常可以被访问，但是<code class="fe lx ly lz ma b">_magic</code>通常被保护的不应该被轻易访问，因为只有类或者它的子类可以访问它。单个下划线' _ '告诉试图访问的人，这应该只由该类及其子类访问。</p><p id="51c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于私有访问(双下划线)，Python的处理略有不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，当我试图访问<code class="fe lx ly lz ma b">__name</code>时，我得到了一个错误。这是因为Python试图隐藏这个变量以防止被访问。然而，正如我之前所说的，Python中的所有变量都是公共的，可以被访问。</p><p id="8f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看为什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d21c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以看到我们能够访问我们的价值。但是由于某种原因，变量名变了。这是Python展示这个值不应该在类之外被访问的方式(<em class="ny">是私有的，所有的</em>)。这是通过将名称改为<code class="fe lx ly lz ma b">_&lt;class name&gt;__&lt;variable name&gt;</code>来实现的。</p><p id="cea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为变量分配访问权限的相同原则也适用于方法。</p><h1 id="46bf" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">字符串表示</h1><h2 id="de55" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Java </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/55d7ebd69b989a231a4222764b96a030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fy0cdfPrb00qDNHDLNYNCg.png"/></div></div></figure><p id="2896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Java，<code class="fe lx ly lz ma b">toString</code>继承自<code class="fe lx ly lz ma b">Object</code>类，默认情况下，每个Java类都继承自该类。默认情况下，<code class="fe lx ly lz ma b">toString</code>方法返回对象的类名和散列码。这通常不是很有用，因此我们使用它的覆盖来产生更有价值的输出。</p><pre class="kj kk kl km gt oa ma ob oc aw od bi"><span id="d814" class="mt mc it ma b gy oe of l og oh">Student student = new Student("Jordan", 22);</span><span id="c3ee" class="mt mc it ma b gy oi of l og oh">System.out.println(student);</span></pre><p id="3e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt oa ma ob oc aw od bi"><span id="684e" class="mt mc it ma b gy oe of l og oh">Student [age=22, name=Jordan, school=Jordan High]</span></pre><h2 id="8627" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Python </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/424439728b1aff888ee81dca79876c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLjFuydPuUQCIYN5tenkAA.png"/></div></div></figure><p id="8fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了产生相同的效果，Python使用了<code class="fe lx ly lz ma b">__repr__</code>(另一种两端带有双下划线的方法)。<code class="fe lx ly lz ma b">__repr__</code>也是所有Python对象继承的默认类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="34e4" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Getter和Setter函数</h1><p id="3eef" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">虽然我们创建了getters和setters，但是Python有自己的创建方式。</p><p id="ee09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前的实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/bd7166324349705f8051c8d00cd6c83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUuME6r57W0ltUlovxC6rA.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="207b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蟒道:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/2bf32b3a1d85aa9f833460ae90b74756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J42PNrfI57JP2GMxTPNJSw.png"/></div></div></figure><p id="5bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将<code class="fe lx ly lz ma b">@property</code>装饰器添加到一个方法中，它将被指定为一个getter。在指定之后，您将使用该方法的名称(成为decorator)来分配相应的setter。这是通过添加<code class="fe lx ly lz ma b">&lt;name&gt;.setter</code>来完成的。</p><p id="557a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让我们的setter更有意义，让我们给它添加一个约束。每当年龄将被设置为低于0时，我们将引发一个异常。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ac9c8d6f717f16fb740b20e785c0d3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKZxceylIWBfZdPGi2VxUg.png"/></div></div></figure><p id="e6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码现在实现了这一点。让我们试一试，以确保:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="e24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以像访问普通属性一样访问它。通过调用<code class="fe lx ly lz ma b">age</code>属性，我们只是通过访问私有变量<code class="fe lx ly lz ma b">__age</code>来创建我们的对象。</p><p id="5d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来让我们试试我们的setter:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过直接给它赋值一个变量来设置我们的<code class="fe lx ly lz ma b">age</code>，类似于一个普通的变量，我们也可以保留它的约束。</p><p id="bf8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，每当我们试图将-1赋给<code class="fe lx ly lz ma b">age</code>时，它所经历的属性都是一个异常。</p><p id="0018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，我们仍然可以通过使用<code class="fe lx ly lz ma b">_&lt;class name&gt;__&lt;variable name&gt;</code>来访问我们的私有变量<code class="fe lx ly lz ma b">__age</code>、<code class="fe lx ly lz ma b">__name</code>和<code class="fe lx ly lz ma b">__school</code>。</p><p id="30e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们在OOP ( <em class="ny">面向对象编程</em>)中使用getters和setters的原因是封装。我们将变量保持私有，以确保访问和修改它们的唯一方式是通过getters和setters。有了这个，我们可以控制它们是如何被看到和修改的。</p><p id="ebe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象你有一门课。它有一个<code class="fe lx ly lz ma b">cardnumber</code>属性，因为卡号是非常敏感的数据。每当我们调用getter时，它总是屏蔽掉卡号的所有部分，只保留最后四(4)位。我们只允许我们的setter允许16位数的卡号，因为这是卡号的正常长度。</p><p id="747b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将所有的getters转向Pythonic方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ac72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持一致，让我们用对age setter所做的更改来修改Java类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="11df" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">静态方法</h1><p id="969a" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">是的，静态方法。至于静态变量，Python不支持(据我所知)。</p><p id="574c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态方法是无需实例化类就可以调用的方法。从类名本身直接调用它们。静态方法通常用于不需要实例化的方法，例如平方根函数。</p><p id="2c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法由<code class="fe lx ly lz ma b">&lt;name of class&gt;.&lt;static method&gt;</code>访问。</p><h2 id="e6d0" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Java </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/838e6acdcd3a09bcdc56a809c8bd5e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcWkSUiGQI45OrPQOooLCA.png"/></div></div></figure><p id="9db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Java，需要将<code class="fe lx ly lz ma b">static</code>修饰符添加到方法定义中。</p><h2 id="ebe3" class="mt mc it bd md mu mv dn mh mw mx dp ml li my mz mn lm na nb mp lq nc nd mr ne bi translated"><strong class="ak"> Python </strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/f83751051d625fe27be371c3c30f0b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ofig2b2FTxvKulhlPjeo0g.png"/></div></div></figure><p id="ab9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Python，需要在方法中添加<code class="fe lx ly lz ma b">staticmethod</code>修饰。不需要<code class="fe lx ly lz ma b">self</code>参数。这是因为<code class="fe lx ly lz ma b">self</code>将方法绑定到类的当前实例，并提供对实例变量和方法的访问。这些都是我们不需要的。</p><p id="c3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ny">提醒</em> </strong>:在整篇文章中，我一直对Java方法和变量使用camel case( <code class="fe lx ly lz ma b">calculateGPA</code>)，对Python函数和变量使用snake case( <code class="fe lx ly lz ma b">calculate_gpa</code>)。这是两种语言的标准命名约定。</p><p id="dec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请点击下面的链接，通过它的文档了解更多关于Python的命名约定。</p><p id="64c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/#method-names-and-instance-variables" rel="noopener ugc nofollow" target="_blank">关于命名约定的Python文档</a>。</p><h1 id="0c4c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">魔法方法</strong></h1><p id="c911" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">Python魔术方法是抽象常见Python操作的特殊内部方法。这些方法发生在幕后。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="08dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段显示了两(2)个数字之间的简单加法。这是一个简单的操作，在内部被一个神奇的方法修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="e032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的片段显示了内部真正发生的事情。每当执行添加时，Python都使用<code class="fe lx ly lz ma b">__add__</code>方法。请注意双下划线。这些被称为<strong class="lb iu">魔法方法</strong>。或者，它们也被称为<strong class="lb iu"> Dunder </strong>方法(<strong class="lb iu">D</strong>double<strong class="lb iu">Under</strong>score)。</p><p id="e341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我们使用了不少这种神奇的方法。<code class="fe lx ly lz ma b">__init__</code>和<code class="fe lx ly lz ma b">__repr__</code>就是其中的一些方法。请注意，我们实际上从未具体调用过这些方法，但它们在内部使用过。</p><p id="689e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的加法示例，<code class="fe lx ly lz ma b">num1</code>和<code class="fe lx ly lz ma b">num2</code>都是整数，都继承自<code class="fe lx ly lz ma b">int</code>类。</p><p id="3d5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来看<code class="fe lx ly lz ma b">int</code>班。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数显示了一个对象或类的所有方法和变量。你也可以在这里看到许多其他的魔法方法。所有这些神奇的方法都抽象了一些在后台发生的操作。乘法、除法和乘方的每一个运算都是用魔法方法完成的。</p><p id="db3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以将这些方法添加到我们的自定义类中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/51d9f48361345d926b75a9488ca8d1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-idNJ0_FEOEburuLLJbRng.png"/></div></div></figure><p id="d666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个存储账户余额的<code class="fe lx ly lz ma b">Account</code>类。我们添加了神奇的方法<code class="fe lx ly lz ma b">__add__</code>，它将允许我们根据余额对<code class="fe lx ly lz ma b">Account</code>对象执行加法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们能够用加号(+)操作符添加两(2)个Account对象。相当于<code class="fe lx ly lz ma b">a.__add__(b)</code>。</p><p id="35f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不限于加法。有许多不同的魔术运营商，你可以在你的业余时间尝试。其中一些包括但不限于以下内容:</p><ul class=""><li id="7608" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe lx ly lz ma b">__mul__</code></li><li id="0791" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe lx ly lz ma b">__sub__</code></li><li id="d910" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe lx ly lz ma b">__pow__</code></li></ul><p id="3ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个操作都有一个神奇的方法。许多Python内置函数甚至使用神奇的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们使用了Python内置函数<code class="fe lx ly lz ma b">len</code>。这个函数只是调用<code class="fe lx ly lz ma b">.__len__()</code>方法的抽象。再一次，所有这些神奇的方法都在幕后工作。</p><p id="319c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上例中的name变量继承自string ( <code class="fe lx ly lz ma b">str</code>)类。看下面<code class="fe lx ly lz ma b">str</code>类的内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c5df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到<code class="fe lx ly lz ma b">__len__</code>方法以及许多其他您已经习惯的字符串方法。对变量名运行<code class="fe lx ly lz ma b">dir</code>会产生类似的结果。</p><p id="51d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外一个我个人比较喜欢的魔术方法是<code class="fe lx ly lz ma b">__call__</code>法。这允许对象像函数一样工作。这意味着你可以像调用函数一样调用你的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/20dc8883901e77980f7f009791d61ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5jbOlFYa2GX5euQJQYi8Q.png"/></div></div></figure><p id="1b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用上面的调用方法实现了一个类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="08f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先将对象实例化为<code class="fe lx ly lz ma b">add</code>变量。在类定义中没有设置任何构造函数或参数，因此在构造函数中没有放置任何参数。实例化之后，我们将该对象用作一个函数。</p><p id="b576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe lx ly lz ma b">add(10,20)</code>对10和20进行加法运算，并存储在变量<code class="fe lx ly lz ma b">value</code>中。这种行为就像一个函数。</p><p id="ee8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它比作一个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/8210e456069e7617172271e43dd104ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyPkTNneQ_x6J4Ray7QG2Q.png"/></div></div></figure><p id="9968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实现了上一个类例子的功能版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="fa1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，它们的工作原理是一样的。</p><p id="13f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的许多内置类都是这样的。我们经常混淆它们的功能，但它们不是。<code class="fe lx ly lz ma b">int</code>和<code class="fe lx ly lz ma b">str</code>都遵循这个原则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见<code class="fe lx ly lz ma b">str</code>和<code class="fe lx ly lz ma b">int</code>都是类。它们都具有将值转换为其类型的功能。</p><h1 id="dbe7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">摘要</h1><p id="f4d2" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">在这里，您可以看到Python类的所有细微差别，以及它与Java实现的细微差别。Python魔术方法可以让你更好地理解Python是如何在幕后工作的。当谈到魔法方法及其真正的能力时，我所展示的只是皮毛。</p></div></div>    
</body>
</html>