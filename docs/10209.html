<html>
<head>
<title>Working With Actors and Concurrency in Swift 5.5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5.5中使用参与者和并发性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/working-with-actors-and-concurrency-in-swift-5-5-b013f78b6b2a?source=collection_archive---------7-----------------------#2021-12-13">https://betterprogramming.pub/working-with-actors-and-concurrency-in-swift-5-5-b013f78b6b2a?source=collection_archive---------7-----------------------#2021-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="646f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看苹果新的并发原语</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff2853fdef8529214c2b2be553351f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8g9KdaZhm3aLAMj12FF6Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Silicon_Village_(9540184355).jpg" rel="noopener ugc nofollow" target="_blank"> commonswikimedia </a>公共领域</p></figure><p id="400e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">距离苹果公司宣布M1芯片让许多人大吃一惊已经过去一年多了。虽然当时大多数经验丰富的技术专家对性能改进的说法持保留态度，但毕竟大多数硬件制造商每年都提出同样的说法。</p><p id="a1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在今年夏天的WWDC2021上，另一口秘密的井出现了。在那次事件中，他们悄悄地对swift语言进行了一些改变游戏规则的修改。苹果公司利用硬件和软件团队之间的协同作用进行的变革；充分利用这些新的M1芯片。</p><p id="b585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">秘密揭示了一个新的并发模型Swift 5.5中的语言特性。该模型旨在取代swift中用于管理并发性的现有结构，即GCD。引入跨语言重大变化的并发编码能力的变化，你可以在这里找到<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10254" rel="noopener ugc nofollow" target="_blank">背后的技术细节</a>。和我一起阅读这篇文章，了解更多信息——</p><p id="92e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并发编码很难，因为它有自己的词汇表，是一个真正的挑战。内核是指芯片上的CPU，在这些内核上运行着线程。</p><p id="887f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当你有不止一个线程时，你有时会发现自己在等待另一个线程，只要那个线程不在等待你，这就不是问题——死锁。有时，您在两个不同的线程上更新相同的资源，这是一种竞争情况。有时，您忙于多任务处理，以至于创建的线程比您拥有的内核还多，而且，您最终在这些线程之间切换的时间比您执行有用工作的时间还要多——线程爆炸或系统颠簸。</p><p id="c7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了应对这些挑战，苹果已经与iOS和OSX建立了他们所谓的运行时合同，以便将应用程序中的上下文切换(众所周知)保持在绝对最低限度，并且在运行代码之前，在编译器级别处理死锁、竞争危险和线程爆炸等问题。</p><blockquote class="lv"><p id="d592" class="lw lx it bd ly lz ma mb mc md me lu dk translated">苹果在这里提到的一个非常重要的警告是，你不能混合n-match并发语言特性</p></blockquote><p id="6aaa" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">不过，好吧——这一周你想的理论已经够多了，让我们来做点实际的吧。</p><h1 id="8a2d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">竞争条件和死锁</h1><p id="6e7c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">一个<strong class="lb iu">竞争条件</strong>是当你有一个共享资源在你的代码中不止一个地方被更新时你得到的东西。这可能是一个很难找到并解决的问题。</p><p id="2d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复有时同样具有挑战性，因为如果您没有正确编码，您可能会以一个不同但同样糟糕的问题——死锁而告终。代码中的线程可能会挂起您的应用程序。</p><p id="871a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们开始之前，这里有一个我所说的视觉展示。它显示了由两个进程更新的计数器的值——因此是一个共享资源——但是存在竞争危险，因为两个线程同时更新计数器。你可以从这个动画GIF中看到结果是什么——虽然计数器在增加——但它有一个小故障，一直在后退。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/823093c09d53debdd13b48d9557fe25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dfZ9Z4HrW9ozXObvmrY3sA.gif"/></div></div></figure><p id="6ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我应该承认，代码设计有一个小故障来解决这个问题——在商业代码中，它可能要微妙得多。我不想排队张贴，因为我想把重点放在新的语言功能上，苹果希望这将是解决方案。</p><h1 id="3532" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">解决方案:一个演员</h1><p id="0453" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Swift 5.5中的actor是一种新类型，其中所有变量都受到保护，不会被外部访问。Swift 5.5通过第二个关键字await控制对参与者上可写资源的访问。您可以在下面的代码中看到SwiftUI声明中的访问，使用独立的任务，在这些任务中有一个await。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c7ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">counter方法更新其中的计数器值，并将新值保存到一个数组中。因为它所在的代码是一个“参与者”，编译器保证它的访问是独占的。</p><p id="8e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI I access中，该方法只能使用await关键字，简单地说，它锁定该方法，防止在代码中的其他地方调用，直到它返回。</p><p id="da42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我同时调用方法increment两次来强制发布，从GIF中可以看到，它的访问得到了很好的管理。当然，这并不是完整的代码——要得到它，你需要<a class="ae ky" href="https://bitbucket.org/wizard1066/concurrentcode/src/master/" rel="noopener ugc nofollow" target="_blank">进入bitbucket </a>,在那里你也可以找到BarView方法。</p><p id="6214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，作为一个参与者，来看看这段代码的可视化表示。您现在可以看到计数器在增加，没有毛刺。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/edfe95a3c7caf55655289fae65260d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1MioJkci5aA-rExxFrRbQQ.gif"/></div></div></figure><p id="8196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多——但是请等待，因为我们还没有完全完成，如果您开始与actor打交道，您很快就会发现访问actor外部的变量可能是一个挑战，即使您的变量是一个let语句，所以是只读的。</p><p id="7860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，不让您访问一个只读变量是不合理的，所以您可以这样做——但是您必须通过将方法标记为非隔离来在actor中明确这一要求/请求。我用identity方法添加了一个例子。</p><p id="b82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做可以免除指定await的要求；这种设计的美妙之处在于，如果你将变量改为var，也就是可写的，编译器会报错，这样就省去了你在运行时查找错误的麻烦。潜在的运行风险正在形成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/99eb8c394d2b5d064068d73e18f55e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9N8LqhaFbaIQ8yT1GGJdtw.png"/></div></div></figure><h1 id="7ed4" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">新协议</h1><p id="4f3b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了帮助你设计不会遭受种族危险的代码，苹果还定义了一个新的协议，Sendable。因为structs和now actors都是值类型，所以它们符合Sendable协议，但是默认情况下类不符合。</p><p id="ac85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，尽管编译器目前没有这样做，但WWDC <a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10133" rel="noopener ugc nofollow" target="_blank">演示中的演示者</a>警告我们，未来Swift将阻止我们共享不符合<code class="fe nl nm nn no b">Sendable</code>协议的资源、方法&amp;数据。毫无疑问，目标是让每个人都开始编写代码，编译器可以检查代码中没有竞争危险。</p><h1 id="9b1b" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">特殊演员</h1><p id="2e1d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">还有一件事，一个叫做<code class="fe nl nm nn no b">@MainActor</code>的特殊演员，你可能在最近的其他文章中看到过我使用它。这个构造与关键字<code class="fe nl nm nn no b">DispatchQueue.main.async </code>相同——只是它确保异步代码在主线程上运行。当然，使用了新的语法——您还记得，与您通常可以逐段添加的其他新功能不同，并发不是一种共享功能。</p><p id="237f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说够了……我将在那时结束这篇已达到我的1000字限制的论文——但我还没有完成——实际上是我的一个提要，以了解更多关于Swift 5.5中添加的新的并发语言功能。</p></div></div>    
</body>
</html>