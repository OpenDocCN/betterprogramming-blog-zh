# 像 Node.js 中的专家一样将回调转换为承诺

> 原文：<https://betterprogramming.pub/converting-callbacks-to-promises-like-a-pro-in-node-js-f5d4d466a1a7>

![](img/da2caacf52db60316a9ad282ec7370f8.png)

马科斯·迈尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在 Node 中，默认情况下异步处理 I/O 操作，Node 处理异步调用的最初方式是使用回调。

回调只是作为参数传递给其他函数的函数。

```
const fs = require('fs');fs.readFile('someFilePath', (err, data) => {
  if(err){
  //do something when  error occurred while reading file
  }
  //do something here with the file data
})
```

在上面的代码中，我们异步读取一个文件，并根据是否发生错误来执行某些操作。

在 Node 中，有一个使用错误优先回调的约定(即，传递给回调函数的第一个参数是错误对象)，之后，只传递其他参数(参见上面的代码示例)。

**注意:**回调并不意味着代码中的异步调用。

代码 1

在上面的代码中，我们使用了一个回调函数，而且是完全同步的。所以回调并不一定意味着我们代码中的异步

# 使用回调

我们将举一个异步的例子，然后使用回调来编写它，然后我们将它转换成基于承诺的代码。

假设我们有一个文件，里面的数字是按行写的。

现在我们要做的是使用`node` `fs`模块从`num.txt`文件中读取所有的数字，然后将它们转换成一个数组。然后，我们将使用基于回调的编码方式过滤出那些偶数。

代码 2

输出:

```
Even Numbers :  [ '102', '104', '106' ]
```

# 利用承诺

从 ES5 开始，JavaScript 就有了对承诺的原生支持，我个人觉得承诺是比回调更好的处理异步代码的方式。在回调中，我们会陷入一种叫做*回调地狱、*的东西，这真的会让我们的代码更难阅读和理解。

promises 允许我们分别处理成功和错误，并允许我们链接多个异步调用而不是嵌套它们，这基本上防止了回调地狱，而不是将回调作为参数传递并在同一位置处理错误。

代码 3

输出:

```
Even Numbers :  [ '102', '104', '106' ]
```

所以我们在这里也取得了同样的结果，而且是以一种更简单的方式。

但是在 Node 中处理异步代码的传统方式是通过回调。此外，成千上万的库是使用这种风格编写的，使用您的库的开发人员可能会认为您在他们使用您的库之前为他们提供了错误优先的回调接口。

所以更好的方法是给用户两个界面——传统的回调和新的承诺——这样他们可以两个都用，或者用他们更舒服的一个。

# 回电和承诺

我们要做的是将回调参数标记为可选的，这样如果用户通过了回调，他或她将被调用，并带有错误和数据。否则，一个承诺被解决或拒绝，然后我们必须处理它。

代码 4

输出:

```
Even Numbers :  [ '102', '104', '106' ]
Odd Numbers :  [ '101', '103', '105' ]
```

在上面的代码中，我们在函数`readFileAsArray`中将默认值赋给回调函数，每当我们使用 Promise 时，我们不传递那个回调函数。然后使用默认回调函数，这对我们没有用。

但是当传递回调函数时，我们传递的值会覆盖默认的回调值。然后调用这个传递的回调函数，我们可以在回调函数中操作数据。

我们在基于承诺的呼叫中打印偶数，在基于回拨的呼叫中打印奇数。