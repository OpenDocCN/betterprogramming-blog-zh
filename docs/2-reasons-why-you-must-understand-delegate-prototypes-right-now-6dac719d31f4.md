# 构建性能库的秘密

> 原文：<https://betterprogramming.pub/2-reasons-why-you-must-understand-delegate-prototypes-right-now-6dac719d31f4>

## 你*需要*理解 JavaScript 中委托原型的两个关键原因

![](img/fac5a2cce2d2f6845177747e40992b98.png)

照片由 [Fabian Irsara](https://unsplash.com/@firsara) @ Unsplash 拍摄

我正在读一本关于 JavaScript 的书，我遇到了一个问题(也是这个问题产生的概念的力量),我想写下来。我认为这对 JavaScript 新手特别有帮助——即使你很有经验，你也可能学到一些新东西！

本文将讨论一个已知的具有委托原型的反模式。如果您是 React 用户，您可能对这种反模式的概念很熟悉。我们还将看看如何使用这个概念来大大提高应用程序的性能——就像今天大多数 JavaScript 库所做的那样。

所以，如果你想用 JavaScript 创建一个库，我强烈建议你学习如何通过委托原型来优化你的应用。这被称为[飞锤模式](https://www.dofactory.com/javascript/flyweight-design-pattern)，将在本文中解释。

如果你不知道什么是原型，它们是 JavaScript 用来建模其他对象的对象。你可以说它们类似于类，因为它们可以构造对象的多个实例，但是它们本身也是对象。

在 JavaScript 中，所有对象都有一些对委托原型的内部引用。当通过属性或方法查询对象时，JavaScript 首先检查当前对象。如果不存在，则继续检查对象的原型，哪个*是委托原型*，然后继续该原型的原型，依此类推。当它到达原型链的末端时，最后一站在根`Object`原型处结束。创建对象会在根级别附加根`Object`原型。您可以用 Object.create()设置不同的直接原型来分支对象。

让我们看看下面的代码片段:

我们这里有两个工厂功能。其中一个是`makeSorceress`，它以一个女巫`type`作为参数，并返回一个女巫能力的对象。另一个是`makeWarrior`，它以一个战士的`type`作为参数，返回一个战士能力的对象。

我们实例化了一个类型为`knight`的 warrior 类的新实例，以及一个类型为`fire`的女巫。

然后，我们使用`Object.create`为 bob、joe 和 lucy 创建新的对象，另外为每个对象委派原型对象。

Bob、joe 和 lucy 在实例中以他们的名字命名，因此我们要求并期待他们自己的属性。最后，鲍勃用`bash`攻击露西，降低她 10 点生命值。

乍一看，这个例子似乎没有什么问题。但是实际上有一个问题。我们希望鲍勃和乔有他们自己的属性和方法副本，这就是为什么我们使用了`Object.create`。当 bob 猛击 lucy 并将最后一个目标名称插入到`this.lastTargets.names`数组中时，该数组将包含新目标的名称。

我们可以注销并亲自查看:

这种行为是意料之中的，但是当我们*还记录了`joe`的最后一个目标名字*时，我们会看到:

这说不通吧？攻击露西的人是鲍勃，从上面可以清楚地看到。但是为什么乔会参与其中呢？那一行代码显式地写了`bob.bash(lucy)`，仅此而已。

所以问题是 bob 和 joe 实际上共享了*相同的状态*！

但是等等，这没有任何意义，因为当我们使用`Object.create`的时候，我们应该已经创建了他们自己单独的副本…或者我们是这样假设的。

甚至 MDN 的[文档也明确说 Object.create()方法创建了一个*新对象*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) 。它确实创建了一个新对象——它确实创建了——但这里的问题是，如果您在*原型*属性上改变对象或数组属性，这种改变将*泄漏*,并影响原型链上与该原型有某种链接的其他实例。相反，如果您替换原型上的整个属性*，那么实例上只会发生*的变化。**

例如:

如果您更改了`this.lastTargets.names`属性，它将会被链接到原型的其他对象所反映。然而，当您更改原型的属性(`this.lastTargets`)时，它将只为那个实例覆盖那个属性*。对于一个新的开发者来说，这可能有点难以理解。*

我们中一些经常使用 React 开发应用程序的人在管理整个应用程序的状态时经常会遇到这个问题。我们可能从来没有注意到这个概念是如何通过 JavaScript 语言本身产生的。所以，更清楚地说，这是 JavaScript 语言本身的问题，它是一个反模式。

但是为什么这甚至是一个反模式呢？不能是好事吗？

在某些方面，它*可能*是一件好事，因为你可以通过委托方法来优化你的应用程序，从而节省内存资源。毕竟，每个对象只需要*一个方法的副本*，并且方法可以在所有实例中共享，除非该实例需要覆盖它以获得额外的功能。

例如，让我们回头看看`makeWarrior`函数:

由所有原型共享`battleCry`函数可能是安全的，因为除了在实例化时已经设置的`hp`属性之外，它不依赖于任何条件来正确运行。这个函数新创建的实例不一定需要自己的`battleCry`副本，而是可以委托给最初定义这个方法的原型对象。

在同一个原型的实例之间共享数据是一种反模式，因为意外改变共享属性或不应该改变的数据会变得非常容易。这一直是 JavaScript 应用程序常见的错误来源。

事实上，这种做法的使用是有充分理由的。看看流行的[请求](https://github.com/request/request)包是如何在[这个源代码](https://github.com/request/request/blob/master/lib/har.js)中实例化`Har`函数的:

那么为什么`Har.prototype.reducer`不这样定义呢？

如前所述，如果要实例化新的实例，实际上会降低应用程序的性能，因为这会(在每次实例化时重新创建新方法)，这就是`reducer`函数。

当我们有单独的`Har`实例时:

我们实际上在内存中创建了 *5 个单独的* `*this.reducer*` *副本，因为该方法是在实例级定义的。如果 reducer 是直接在原型上定义的，那么`Har`的多个实例将*将*的`reducer`功能委托给原型上定义的方法！*

这是一个如何利用委托原型并提高应用程序性能的例子。