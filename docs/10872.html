<html>
<head>
<title>How to Use GraphQL for Microservices Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用GraphQL进行微服务通信</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graphql-for-microservices-communication-d40e04956818?source=collection_archive---------10-----------------------#2022-02-01">https://betterprogramming.pub/graphql-for-microservices-communication-d40e04956818?source=collection_archive---------10-----------------------#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="22d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">GraphQL无疑是微服务之间最好的通信系统吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/83154b8d7136ca299a1403181f289d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VqwdAskJUGiSbijv"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@kazuend?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> kazuend </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2e3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们都很清楚松散耦合的可独立维护、可测试、可部署的微服务越来越受欢迎。但是这种非常流行的架构也总是带来一个众所周知的问题——服务之间的通信。这就是为什么在设计微服务架构时，每个架构师都会提前考虑通信媒介。</p><p id="943f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将重点关注一种可以在服务之间使用的通信类型——graph QL。这里我举了两个基本的微服务的例子，它们解决了单个的业务问题，以及GraphQL是如何在这些服务之间进行通信的。GraphQL也可以用作APIGateway，我们将在以后的博客中讨论。</p><h1 id="dca0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">使用GraphQL通信的优势</strong></h1><p id="0a7d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在基于GraphQL的通信中，服务之间会发出HTTP POST请求。该请求包含查询表达式，该表达式定义了要在响应中返回的数据。通过这种方式，我们可以准确地获取我们需要的数据，不会出现数据提取不足或过量的情况。</p><p id="a161" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraphQL可用于在单个请求中聚合来自多个来源的数据。</p><p id="f343" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraphQL不像REST APIs那样有不同的端点或者不同的版本，只有一个版本和一个端点/graphql。</p><p id="c4ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们预先声明了字段的类型，所以通过捕捉与类型相关的错误对我们有好处。</p><h1 id="0f0b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">实施</strong></h1><p id="d5be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用户服务负责与<code class="fe mp mq mr ms b">User</code>和<code class="fe mp mq mr ms b">Post</code>相关的查询和变异，服务包括与用户的<code class="fe mp mq mr ms b">Posts</code>相关的查询和变异。我相信服务名称和我在这里试图实现的目标是不言自明的，并且非常适合微服务架构。</p><p id="2e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户<code class="fe mp mq mr ms b">typeDef</code>包含id、姓名、电子邮件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="83ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">帖子<code class="fe mp mq mr ms b">typeDef</code>包含id，<code class="fe mp mq mr ms b">postDescription</code>，userId。这里，userId充当用户和文章之间的链接字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="71a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户服务需要来自Posts服务的部分信息，则处理请求，反之亦然，在这种情况下，服务之间将发生通信，GraphQL将在单个请求中聚合来自不同源/服务的数据。</p><p id="23bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，最简单的例子是获取一个特定用户的帖子详细信息——我们需要使用下面的代码片段中显示的user-id查询Posts服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="38a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查询中的动态参数——在本例中，<code class="fe mp mq mr ms b">userID</code>可以作为变量在HTTP post请求的主体中传递。</p><h1 id="b6a6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="1317" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">GraphQL无疑是微服务之间最好的通信系统吗？当然不是。</p><p id="c0fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在根据业务需求、响应类型应该是同步还是异步等来决定在服务之间使用哪种通信介质之前，需要考虑多个因素。</p><p id="e863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与REST的流行相比——graph QL的社区正在成长，它还有很长的路要走。但是正如我之前讨论的那样，GraphQL有其自身的优势，考虑到所有因素，如果GraphQL可以用于您的微服务通信，那为什么不呢！</p><p id="b3dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://github.com/aindrila-choudhuri/graphql-microservices-communication" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的源代码。</p></div></div>    
</body>
</html>