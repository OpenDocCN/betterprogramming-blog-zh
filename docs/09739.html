<html>
<head>
<title>How To Customise the Behaviour of UINavigationController in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS中自定义UINavigationController的行为</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-customise-the-behaviour-of-uinavigationcontroller-in-ios-f6424300f58?source=collection_archive---------3-----------------------#2021-10-05">https://betterprogramming.pub/how-to-customise-the-behaviour-of-uinavigationcontroller-in-ios-f6424300f58?source=collection_archive---------3-----------------------#2021-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6bf9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们在UINavigationController中覆盖导航</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71f8d71a10f9680cca42320b48d050f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kjFFyu7pyFDwTsN5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@williambout?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威廉·布特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="81fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有一个像UIKit这样成熟的框架通常是一件非常好的事情。我们可以相信这些组件会像描述的那样工作。我们有大量的资源，很可能其他人已经有了类似的问题，并且有解决方案。</p><p id="1216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，尽管有这些美好的事实，有时现有的组件使得编写最简单的函数变得困难。例如，本周我不得不拦截<code class="fe lv lw lx ly b">UINavigationController</code>中的导航，以便在导航到前一个屏幕之前向用户显示警告。在继续弹出动画之前，我们需要询问用户是否确定要中止当前流程。</p><p id="94a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎是一个简单的任务，但令人惊讶的是，在Swift中没有办法轻松拦截用户点击默认后退按钮的事件。</p><p id="0e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你进行快速搜索，你会发现许多不同的解决方案:从在<code class="fe lv lw lx ly b">viewWillDisappear</code>方法中编写一些代码来检测应用程序是否正在离开当前VC，到实现一个自定义的后退按钮。</p><p id="3566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我们将探讨如何通过一个客户<code class="fe lv lw lx ly b">UINavigationController</code>以适当的方式实现这种行为。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6de2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">该应用程序</h1><p id="6f6d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于本文的内容，我们将使用一个简单的应用程序。它允许我们保存信用卡的详细信息。出于安全原因，在用户确认详细信息之前，我们不想在本地存储这些信息。</p><p id="b48e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在点击后退按钮时，我们想警告用户，如果他们继续向后导航，所有的信息都将丢失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/77e8a256fb1c004b8cc12446a8974297.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*FfW62sIvcLg2mi1S1PoOwA.gif"/></div></figure><h1 id="9e15" class="mg mh it bd mi mj ne ml mm mn nf mp mq jz ng ka ms kc nh kd mu kf ni kg mw mx bi translated">控制导航</h1><p id="c365" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了实现这个解决方案，我们依赖于实现一个特殊的委托:<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uinavigationbardelegate" rel="noopener ugc nofollow" target="_blank">UINavigationBarDelegate</a></code>。这个委托让我们截取了四个非常有趣的事件:</p><ul class=""><li id="2c2e" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uinavigationbardelegate/1624941-navigationbar" rel="noopener ugc nofollow" target="_blank">func navigationBar(_:shouldPush:) -&gt; Bool</a></code>:在导航控件试图按下特定的<code class="fe lv lw lx ly b">UINavigationItem</code>之前调用。如果我们返回<code class="fe lv lw lx ly b">false</code>，导航停止。</li><li id="450e" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uinavigationbardelegate/1624964-navigationbar" rel="noopener ugc nofollow" target="_blank">func navigationBar(_:didPush:)</a></code>:在<code class="fe lv lw lx ly b">UINavigationItem</code>被推入堆栈后调用。</li><li id="5bbe" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uinavigationbardelegate/1624944-navigationbar" rel="noopener ugc nofollow" target="_blank">func navigationBar(_:shouldPop:) -&gt; Bool</a></code>:在导航控件试图弹出一个特定的<code class="fe lv lw lx ly b">UINavigationItem</code>之前调用。如果我们返回<code class="fe lv lw lx ly b">false</code>，航行就停止了。</li><li id="2c14" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uinavigationbardelegate/1624948-navigationbar" rel="noopener ugc nofollow" target="_blank">func navigationBar(_:didPop:)</a></code>从堆栈中弹出<code class="fe lv lw lx ly b">UINavigationItem</code>后调用。</li></ul><p id="bca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe lv lw lx ly b">UINavigationController</code>都自动成为自己<code class="fe lv lw lx ly b">navigationBar</code>的<code class="fe lv lw lx ly b">navigationBar.delegate</code>。如果我们试图手动将<code class="fe lv lw lx ly b">delegate</code>属性设置为任何值，甚至是<code class="fe lv lw lx ly b">self</code>，我们会得到这个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f5abfd213b2d2d86fe86b6d1e8cf6941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ac4FSbxTx_7xC_Z4Jq2dNw.png"/></div></div></figure><p id="affa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有一种方法可以实现这个委托:</p><ol class=""><li id="13a8" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu ny np nq nr bi translated">创建<code class="fe lv lw lx ly b">UINavigationController</code>的子类</li><li id="f2b6" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu ny np nq nr bi translated">使子类符合<code class="fe lv lw lx ly b">UINavigationBarDelegate</code>并实现我们需要的方法。</li></ol><h2 id="0c26" class="nz mh it bd mi oa ob dn mm oc od dp mq li oe of ms lm og oh mu lq oi oj mw ok bi translated">创建UINavigationController子类</h2><p id="e1cf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">第一步是定义一个定制的<code class="fe lv lw lx ly b">UINavigationController</code>子类。</p><p id="e974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一部分非常容易。我们不需要在子类中实现任何代码，我们只需要一个自定义代码来使它符合委托。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="b8e3" class="nz mh it bd mi oa ob dn mm oc od dp mq li oe of ms lm og oh mu lq oi oj mw ok bi translated">实现UINavigationBarDelegate方法</h2><p id="51a7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">第二步是实际实现委托的方法。<code class="fe lv lw lx ly b">UINavigationBarDelegate</code>是一个Objective-C协议，它的所有方法都是可选的。这有两层含义:</p><ol class=""><li id="87f5" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu ny np nq nr bi translated">所有符合协议的实体必须从<code class="fe lv lw lx ly b">NSObject</code>继承，或者它们也必须符合<code class="fe lv lw lx ly b">NSObjectProtocol</code>。这已经满足了，因为我们的一致性类型扩展了一个扩展了<code class="fe lv lw lx ly b">NSObject</code>的<code class="fe lv lw lx ly b">UINavigationController</code>。</li><li id="b0aa" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu ny np nq nr bi translated">我们可以在代码中只实现我们需要的方法，因为它们都是可选的。</li></ol><p id="a0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，我们只需要实现<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uinavigationbardelegate/1624944-navigationbar" rel="noopener ugc nofollow" target="_blank">func navigationBar(_:shouldPop:) -&gt; Bool</a></code>方法。请注意以下事项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段由两个方法组成:委托方法实现和一个显示确认警告的函数。</p><p id="eaab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">警报控制器代码是一个标准代码:我们创建视图控制器，包括标题、消息和动作，然后呈现它。当用户按下<code class="fe lv lw lx ly b">Yes, cancel</code>时，我们手动调用<code class="fe lv lw lx ly b">popViewController</code>方法。否则，我们什么也不做。</p><p id="c481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">委托方法的实现更有趣。目前，这种伪代码是行不通的。不幸的是，没有直接的方法将<code class="fe lv lw lx ly b">UINavigationItem</code>与相应的<code class="fe lv lw lx ly b">UIViewController</code>联系起来。如果我们检查<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uinavigationitem" rel="noopener ugc nofollow" target="_blank">UINavigationItem</a></code>文档，我们唯一可以使用的就是标题。但是，正如我们所知，弦并不那么可靠。</p><h2 id="5849" class="nz mh it bd mi oa ob dn mm oc od dp mq li oe of ms lm og oh mu lq oi oj mw ok bi translated">将NavigationItem链接到ViewController</h2><p id="f9d3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我发现有两种优雅的方式将这两种元素联系起来。第一个是使用一个被遗忘的名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiview/1622493-tag" rel="noopener ugc nofollow" target="_blank">tag</a></code>的Objective-C变量。正如我们从文档中看到的，所有的<code class="fe lv lw lx ly b">UIView</code>都有这个属性，它被用来在运行时标识一个特定的视图。其默认值为<code class="fe lv lw lx ly b">0</code>。</p><p id="e01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要做的是用我们所有的事例定义一个枚举。我们可以称之为<code class="fe lv lw lx ly b">ViewControllerTag</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ab1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要使用它。首先，在我们的<code class="fe lv lw lx ly b">ViewController</code> s的<code class="fe lv lw lx ly b">viewDidLoad</code>方法中，我们可以访问<code class="fe lv lw lx ly b">navigationItem</code>对象。然后，我们可以尝试设置<code class="fe lv lw lx ly b">tag</code>属性。</p><p id="a152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们尝试这样做，我们可以看到这个属性对于<code class="fe lv lw lx ly b">UINavigationItem</code>来说是不存在的。这是因为Swift试图隐藏那些稍微不安全的API，以提高我们代码的质量。</p><p id="c95d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用一种叫做<a class="ae ky" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/" rel="noopener ugc nofollow" target="_blank">键值编码</a>的技术，在运行时仍然可以访问这些属性。所有的<code class="fe lv lw lx ly b">NSObject</code>都有几个方法来设置特定键的值并检索该值。这就是<code class="fe lv lw lx ly b">setValue(_:forKey:)</code>方法和<code class="fe lv lw lx ly b">value(forKey:)</code>方法。</p><p id="a316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了这种技术，我们可以为<code class="fe lv lw lx ly b">UINavigationItem</code>编写这个小扩展。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="520f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个扩展中，我们创建了一个私有属性来设置和检索<code class="fe lv lw lx ly b">tag</code>。然后，我们创建一个助手，以更具描述性的方式获取和设置<code class="fe lv lw lx ly b">ViewControllerTag</code>。</p><p id="ddf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建链接的另一种方法是使用关联对象而不是标签。如你所知，扩展中不能有任何存储变量，我们也不能修改<code class="fe lv lw lx ly b">UINavigationItem</code>的原始代码。然而，如果我们从Objective-C运行时扩展一个对象，我们可以在运行时创建一个存储变量。如果您想使用这种方法，我们可以创建这个扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="94cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们创建一个键，通过使用<code class="fe lv lw lx ly b">objc_getAssociatedObject</code>和<code class="fe lv lw lx ly b">objc_setAssociateObject</code>，我们可以添加一个存储变量来链接<code class="fe lv lw lx ly b">UINavigationItem</code>和相应的<code class="fe lv lw lx ly b">UIViewController</code>。</p><p id="34aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种技术都访问Objective-C运行时，为了创建链接，我们牺牲了一点类型安全。</p><p id="9f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">独立于所选择的技术，我们现在可以更新我们的<code class="fe lv lw lx ly b">ViewController</code>来创建链接。在他们的<code class="fe lv lw lx ly b">viewDidLoad</code>方法中，我们可以如下设置<code class="fe lv lw lx ly b">viewControllerTag</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="3110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们应用程序中的每个<code class="fe lv lw lx ly b">UIViewController</code>都在其导航项目中设置了一个合适的标签。让我们更新我们<code class="fe lv lw lx ly b">NavigationController</code>的代码来使用它吧！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">navigationBar</code>委托方法中，我们从导航项中检索标签。如果标签不存在，我们可以返回<code class="fe lv lw lx ly b">true</code>允许正常导航。否则，我们切换标签来决定如何处理导航，一个视图控制器接一个视图控制器。</p><p id="39c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:从技术上讲，我们可以只为那些需要修改导航的控制器设置一个标签。</p><h1 id="0eab" class="mg mh it bd mi mj ne ml mm mn nf mp mq jz ng ka ms kc nh kd mu kf ni kg mw mx bi translated">标签的替代物</h1><p id="a06a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当前的解决方案运行良好，并且在恒定时间内有效。我们访问标签并做出决定。</p><p id="ad86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，它需要修改每个视图控制器的代码来添加标签。有些情况下，我们无法更改视图控制器代码。在这些情况下，我们可以使用不同的解决方案:我们可以在<code class="fe lv lw lx ly b">NavigationController</code>的<code class="fe lv lw lx ly b">viewControllers</code>属性中搜索<code class="fe lv lw lx ly b">last</code>视图控制器，它的<code class="fe lv lw lx ly b">navigationItem</code>是传递给委托的那个。</p><p id="6a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个标记协议<code class="fe lv lw lx ly b">PopRequiresConfirmation</code>，我们可以让所有的<code class="fe lv lw lx ly b">ViewController</code>都符合该协议。每当我们发现一个标有该协议的<code class="fe lv lw lx ly b">ViewController</code>并且对应于<code class="fe lv lw lx ly b">navigationItem</code>时，我们就要求用户确认。</p><p id="0c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="67a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码片段的第一部分，我们声明了<code class="fe lv lw lx ly b">PopRequiresConfirmation</code>并标记了需要特定行为的<code class="fe lv lw lx ly b">ViewController</code>。在我们的例子中，那只是<code class="fe lv lw lx ly b">AddCreditCardVC</code>。</p><p id="7854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们实现<code class="fe lv lw lx ly b">UINavigationBarDelegate</code>方法。在那里，我们将<code class="fe lv lw lx ly b">navigationItem</code>传递给一个helper方法，该方法在<code class="fe lv lw lx ly b">NavigationController</code>的<code class="fe lv lw lx ly b">viewControllers</code>列表中搜索具有该<code class="fe lv lw lx ly b">navigationItem</code>的<code class="fe lv lw lx ly b">last</code>。</p><p id="4351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们搜索<code class="fe lv lw lx ly b">last</code>元素是因为我们从栈顶弹出它:如果你的应用程序允许多次推送相同的<code class="fe lv lw lx ly b">ViewController</code>，你可能会观察到一些奇怪的行为。</p><p id="89d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们检查我们找到的viewController是否符合<code class="fe lv lw lx ly b">PopRequiresConfirmation</code>协议。如果是，我们返回<code class="fe lv lw lx ly b">true</code>。否则，我们返回<code class="fe lv lw lx ly b">false</code>。</p><p id="5379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案的美妙之处在于，我们不必定义额外的枚举，也不必使用任何额外的状态变量来创建<code class="fe lv lw lx ly b">viewController</code>和<code class="fe lv lw lx ly b">navigationItem</code>之间的链接。对于具有深度或无限导航的应用程序，这种实现可能会变得昂贵。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0e7c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="dbea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在今天的文章中，我们探讨了如何控制应用程序中的导航。为了实现这一点，我们需要创建一个定制的导航控制器，并且我们需要实现一些来自<code class="fe lv lw lx ly b">UINavigationBarDelegate</code>的委托方法。</p><p id="4c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用它时，我们发现UIKit没有提供<code class="fe lv lw lx ly b">UINavigationItem</code>和<code class="fe lv lw lx ly b">UIViewController</code>之间的直接链接。我们使用Objective-C运行时、KVC技术或相关对象创建了这个链接。</p><p id="7140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还探索了使用标记协议和在视图控制器列表中搜索的替代方法。这种解决方案需要线性时间，但不需要篡改现有的视图控制器。你可以在<a class="ae ky" href="https://github.com/cipolleschi/BlockingNavigation" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中找到最终的项目。</p><p id="0171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当我们实际上可以创建<code class="fe lv lw lx ly b">UINavigationController</code>的自定义子类时，这种方法才有效。当我们不能时，也许因为我们正在创建一个库，我们需要使用应用程序传递的<code class="fe lv lw lx ly b">UINavigationController</code>，我们需要使用其他技术，比如覆盖后退按钮行为。</p><p id="da61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案更加优雅，需要更少的UI恶作剧，并且应该涵盖80%的我们创建自己的应用程序的情况。</p></div></div>    
</body>
</html>