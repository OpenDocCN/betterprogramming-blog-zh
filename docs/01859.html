<html>
<head>
<title>Extend Your React Electron Desktop App With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript扩展您的React电子桌面应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/extend-your-react-electron-desktop-app-with-typescript-e71af04fe2f?source=collection_archive---------16-----------------------#2019-10-17">https://betterprogramming.pub/extend-your-react-electron-desktop-app-with-typescript-e71af04fe2f?source=collection_archive---------16-----------------------#2019-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">借助类型脚本支持加速您的开发流程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f95aae747661e0d8ef1da6c3af6d53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPquwDmtvO2Te5r3jxWLmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@igormiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊戈尔·米斯克</a>在<a class="ae ky" href="https://unsplash.com/@igormiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cb47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的一篇文章中，我讲述了使用<a class="ae ky" href="https://electronjs.org/docs" rel="noopener ugc nofollow" target="_blank"> Electron </a>创建桌面应用软件的步骤。这篇文章将从克隆repo并扩展它以支持TypeScript开始，以便我们在开发桌面应用程序时获得类型检查功能。</p><p id="1ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript可以通过通知您代码中的类型错误来帮助提高您的应用程序质量，因此如果您还没有开始将它集成到您的开发流程中，这是一个好主意。</p><p id="1d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，这不是一个延续教程，但我们将使用repo来扩展它，以便像你我这样的用户可以在开发桌面应用程序时开始利用TypeScript特性。</p><p id="79f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧！(注:如果您想要一份我们将要构建的最终回购的副本，请访问<a class="ae ky" href="https://github.com/jsmanifest/electron-react-typescript-app" rel="noopener ugc nofollow" target="_blank">此链接</a>)</p><p id="c831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事是<a class="ae ky" href="https://github.com/jsmanifest/electron-react-app" rel="noopener ugc nofollow" target="_blank">克隆回购</a>。</p><p id="b58e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，进入目录并使用CLI安装依赖项:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ed1f" class="ma mb it lw b gy mc md l me mf">npm install</span></pre><p id="fd77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成应用程序的安装，让我们通过在开发模式下启动它来确保我们有一个工作项目:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b3ad" class="ma mb it lw b gy mc md l me mf">npm start</span></pre><p id="a25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成功，您应该会看到以下窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/c9b9e4d0b4c193ae5acfce02fb50558f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rKSqKdtgoIcZnVqR.jpg"/></div></div></figure><p id="17c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这启动了我们React应用程序的实时热可再加载web服务器。</p><p id="1e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在继续运行电子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="be36" class="ma mb it lw b gy mc md l me mf">npm run electron</span></pre><p id="4b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成功，您应该会看到以下窗口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/0bb038b1210b6d744fffae07e4657dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7Ce6YfNWQBb8_v9M.jpg"/></div></div></figure><p id="cec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在我们知道我们有一个工作的应用程序，让我们继续将TypeScript安装到项目中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6fd1" class="ma mb it lw b gy mc md l me mf">npm i -D typescript</span></pre><p id="943e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(注:<code class="fe mi mj mk lw b">-D</code>只是<code class="fe mi mj mk lw b">--save-dev</code>的别名)</p><p id="84d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们要安装ESLint。你可能会奇怪，既然ESLint主要关注林挺JavaScript，我为什么还要为它费心。</p><p id="0a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TSLint <a class="ae ky" href="https://eslint.org/blog/2019/01/future-typescript-eslint" rel="noopener ugc nofollow" target="_blank">背后的团队在今年早些时候发布了一个公告</a>，宣布他们的下一步计划，并决定TSLint将被弃用，转而支持ESLint。结果，工具最终向前发展，允许开发者一起使用ESLint和TypeScript。</p><p id="705a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mi mj mk lw b"><a class="ae ky" href="https://github.com/typescript-eslint/typescript-eslint" rel="noopener ugc nofollow" target="_blank">@typescript-eslint/parser</a></code>是一个解析器，它将我们的源代码转换成抽象语法树(AST ),通过利用TypeScript编译器使ESLint能够与TypeScript一起使用。你可以在GitHub上了解更多信息。</p><p id="ba07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要安装<code class="fe mi mj mk lw b">@typescript-eslint/eslint-plugin</code>。</p><p id="2414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将列出我在React项目中经常使用的包。你不需要安装所有的软件，但是<code class="fe mi mj mk lw b">eslint </code>和下面五个是你最想在你的项目中使用的:</p><ul class=""><li id="3ad8" class="ml mm it lb b lc ld lf lg li mn lm mo lq mp lu mq mr ms mt bi translated">埃斯林特</li><li id="ee93" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">eslint-config-airbnb</li><li id="6e8e" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">eslint-config-appeller</li><li id="8eb2" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">eslint-插件-导入</li><li id="ed69" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">eslint-plugin-jsx-a11y</li><li id="fc4c" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">eslint-插件-更漂亮</li><li id="ab4a" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">eslint-plugin-react</li><li id="f359" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">eslint-plugin-react-hooks</li><li id="1051" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">@typescript-eslint/parser</li><li id="ab70" class="ml mm it lb b lc mu lf mv li mw lm mx lq my lu mq mr ms mt bi translated">@ typescript-eslint/eslint-plugin</li></ul><p id="3328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们继续安装<code class="fe mi mj mk lw b">eslint</code>和所有其他的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9e34" class="ma mb it lw b gy mc md l me mf">npm install -D eslint eslint-config-airbnb eslint-config-prettier eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/parser @typescript-eslint/eslint-plugin</span></pre><p id="516c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也不要忘记<code class="fe mi mj mk lw b">typescript</code>本身:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3728" class="ma mb it lw b gy mc md l me mf">npm install -D typescript</span></pre><p id="bc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在根目录下创建一个<code class="fe mi mj mk lw b">.eslintrc.js</code>文件。这是我的<code class="fe mi mj mk lw b">.eslintrc.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们在一个电子项目中实现TypeScript时，事情变得有点棘手。<a class="ae ky" href="https://www.typescriptlang.org/index.html" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>是JavaScript的类型化超集，将代码编译成普通的JavaScript，这就是我们想要的。但实际上，在用电子方式构建应用程序时，可能会有一个问题，我们乍一看可能没有意识到，特别是如果我们刚刚开始使用电子方式。</p><p id="05b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，在电子中实际上有两种类型的过程。一个被称为主进程，另一个是渲染器进程。当Electron创建网页时，它们被创建为呈现器进程(本质上是生活在浏览器环境中)。Electron可以同时创建和运行多个渲染器进程，但最终只能有一个主进程。</p><p id="2069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为渲染器进程是网页，所以它们被阻止调用本地GUI APIs，因为允许它们管理GUI资源将是一个巨大的安全问题。电子通过利用<a class="ae ky" href="https://electronjs.org/docs/api/ipc-main" rel="noopener ugc nofollow" target="_blank"> ipcMain </a>、<a class="ae ky" href="https://electronjs.org/docs/api/ipc-renderer" rel="noopener ugc nofollow" target="_blank"> ipcRenderer </a>或<a class="ae ky" href="https://electronjs.org/docs/api/remote" rel="noopener ugc nofollow" target="_blank"> remote </a>在渲染器和主进程之间启用单向通信隧道。</p><p id="4574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这种限制，我们必须以这样一种方式分割目录，即我们独立于渲染器进程为主进程开发代码，以便我们让TypeScript单独编译它们。这样我们就不会在编译他们的代码时在软件中产生问题。</p><p id="51ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们的目录结构，看看我们有什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/fefa49b68057fb8781b956914806c3bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/0*sKpyv--C6zByF7s1.jpg"/></div></figure><p id="3b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来我们有<code class="fe mi mj mk lw b">start.js</code>，它是主进程，和渲染器进程的代码(<code class="fe mi mj mk lw b">App.js</code>、<code class="fe mi mj mk lw b">index.js</code>、<code class="fe mi mj mk lw b">index.css</code>等)生活在同一个目录下。所以我们必须把它们分成这样的东西:</p><p id="ec89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我重命名了截图中的文件，使它们成为类型脚本文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/60608b6a6bb8f3cb4e7521ab2029dd9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/0*qkP4_AX4PBUy8fQZ.jpg"/></div></figure><p id="ad6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个好的开始。然而，当我们配置typescript配置文件时，我们必须指定一个glob，TypeScript将使用它来包含在编译中匹配的所有文件中，包括将它们输出到哪里。我们仍然停留在以前的问题上，所以我们要做的是将当前根目录作为父目录，它将保存主<em class="nd"> </em>和渲染器进程代码。</p><p id="48f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将使它们都成为独立的回购协议，这样我们就可以获得只需要暴露于特定流程的<code class="fe mi mj mk lw b">npm install</code> ing包的好处，反之亦然。这将有助于我们在将来更容易地调试，因为我们的目录更加抽象和有组织。</p><p id="d591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的是将除主目录之外的所有内容移动到渲染器目录。我们这样做的原因是因为这个项目是由<a class="ae ky" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>引导的，它本质上已经是渲染器进程中的一个环境:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d5840fdaff0d6053351771a3a73ed8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/0*8yEVpN3nM0pf-DTF.jpg"/></div></figure><p id="3615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经解决了renderer repo的问题，让我们将主流程变成它自己的repo:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b985" class="ma mb it lw b gy mc md l me mf"># step into the main directory<br/>cd main</span><span id="16e0" class="ma mb it lw b gy nf md l me mf"># initialize npm<br/>npm init</span></pre><p id="0039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要按下回车键就可以了。现在打开<code class="fe mi mj mk lw b">package.json</code>，你应该会看到一个几乎空的<code class="fe mi mj mk lw b">package.json</code>文件:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a219" class="ma mb it lw b gy mc md l me mf">{<br/>  "name": "main",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "author": "",<br/>  "license": "ISC"<br/>}</span></pre><p id="99d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们需要改变的是<code class="fe mi mj mk lw b">"main"</code>部分，不是因为它不是一个类型脚本文件，而是因为这是一个电子文件，当我们稍后运行build命令时，我们将把它放入我们的输出目录中。当我们构建应用程序时，我们将在渲染器目录中启动它，因此我们需要一个更清晰的名称:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9513" class="ma mb it lw b gy mc md l me mf">{<br/>  "name": "main",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "./src/electron.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "author": "",<br/>  "license": "ISC"<br/>}</span></pre><p id="f1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会感到困惑，为什么我们没有以类似于<code class="fe mi mj mk lw b">.ts</code>的TypeScript扩展名结尾。这是因为我们将创建一个<code class="fe mi mj mk lw b">electron.ts</code>文件，我们将让TypeScript将它传输到同一个目录中的<code class="fe mi mj mk lw b">.js</code>。当我们稍后在渲染器目录中运行build命令时，我们将以编程方式复制该文件，并将其发送到渲染器的输出目录，该目录将是<code class="fe mi mj mk lw b">build</code>。</p><p id="9bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让TypeScript编译这个文件，我们将在主repo中安装TypeScript:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="157b" class="ma mb it lw b gy mc md l me mf">npm install -D typescript</span></pre><p id="c6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将在它的根目录下创建一个<code class="fe mi mj mk lw b">tsconfig.json</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d183" class="ma mb it lw b gy mc md l me mf">{<br/>  "compilerOptions": {<br/>    "target": "es5",<br/>    "lib": ["dom", "dom.iterable", "esnext"],<br/>    "allowJs": true,<br/>    "skipLibCheck": true,<br/>    "esModuleInterop": true,<br/>    "allowSyntheticDefaultImports": true,<br/>    "strict": true,<br/>    "forceConsistentCasingInFileNames": true,<br/>    "module": "esnext",<br/>    "moduleResolution": "node",<br/>    "resolveJsonModule": true,<br/>    "isolatedModules": true,<br/>    "noEmit": true,<br/>    "jsx": "preserve"<br/>  },<br/>  "include": ["src"]<br/>}</span></pre><p id="5056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把这作为一个典型的开发回购，因为我们不希望在两者之间来回切换造成任何不必要的混乱，所以我们将创建一个<code class="fe mi mj mk lw b">src</code>目录并将<code class="fe mi mj mk lw b">start.ts</code>文件直接移入其中。</p><p id="d13f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe mi mj mk lw b">start.ts</code>文件就是将被编译成<code class="fe mi mj mk lw b">electron.js</code>的<code class="fe mi mj mk lw b">electron.ts</code>文件。</p><p id="9f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，不要忘记安装<code class="fe mi mj mk lw b">electron</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="926d" class="ma mb it lw b gy mc md l me mf">npm install electron &amp;&amp; npm install -D @types/electron electron-is-dev</span></pre><p id="adff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们将安装<code class="fe mi mj mk lw b">nodemon</code>包，这样当我们将它与<code class="fe mi mj mk lw b">electron-reload</code>结合时，我们就获得了<code class="fe mi mj mk lw b">auto restart</code>功能(当我们对它进行更改时，电子重新加载用于重新启动主进程):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2c3c" class="ma mb it lw b gy mc md l me mf">npm install --save-dev nodemon electron-reload</span></pre><p id="be4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将把<code class="fe mi mj mk lw b">start</code>命令添加到脚本部分:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f9f1" class="ma mb it lw b gy mc md l me mf">{<br/>  "name": "main",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "./src/electron.js",<br/>  "scripts": {<br/>    "start": "cross-env NODE_ENV=dev nodemon --exec \"electron src/electron.js\" &amp;&amp; tsc ./src/electron.ts -w"<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "electron": "^6.0.12"<br/>  },<br/>  "devDependencies": {<br/>    "@types/electron": "^1.6.10",<br/>    "concurrently": "^5.0.0",<br/>    "cross-env": "^6.0.3",<br/>    "electron-is-dev": "^1.1.0",<br/>    "electron-reload": "^1.5.0",<br/>    "nodemon": "^1.19.3",<br/>    "typescript": "^3.6.4"<br/>  }<br/>}</span></pre><p id="800d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的<code class="fe mi mj mk lw b">electron.ts</code>文件:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4fc6" class="ma mb it lw b gy mc md l me mf">import { app, BrowserWindow } from 'electron'<br/>import * as path from 'path'<br/>import * as isDev from 'electron-is-dev'<br/>import 'electron-reload'</span><span id="3979" class="ma mb it lw b gy nf md l me mf">let mainWindow</span><span id="5569" class="ma mb it lw b gy nf md l me mf">function createWindow() {<br/>  mainWindow = new BrowserWindow({<br/>    width: 800,<br/>    height: 600,<br/>    webPreferences: {<br/>      nodeIntegration: true,<br/>    },<br/>  })</span><span id="9675" class="ma mb it lw b gy nf md l me mf">  mainWindow.loadURL(<br/>    isDev<br/>      ? 'http://localhost:3000'<br/>      : `file://${path.join(__dirname, '../build/index.html')}`,<br/>  )</span><span id="f020" class="ma mb it lw b gy nf md l me mf">  mainWindow.on('closed', () =&gt; {<br/>    mainWindow = null<br/>  })<br/>}</span><span id="a02c" class="ma mb it lw b gy nf md l me mf">app.on('ready', createWindow)</span><span id="0a4d" class="ma mb it lw b gy nf md l me mf">app.on('window-all-closed', () =&gt; {<br/>  if (process.platform !== 'darwin') {<br/>    app.quit()<br/>  }<br/>})</span><span id="8f26" class="ma mb it lw b gy nf md l me mf">app.on('activate', () =&gt; {<br/>  if (mainWindow === null) {<br/>    createWindow()<br/>  }<br/>})</span></pre><p id="1485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在，当我们运行<code class="fe mi mj mk lw b">npm start</code>时，我们的主进程应该成功运行，此外还会根据更改自动将<code class="fe mi mj mk lw b">electron.ts</code>重新编译为<code class="fe mi mj mk lw b">electron.js</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f948313ea1cec1d8ae83b21d40e5645b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JZkC0divYY6uMF9Q.jpg"/></div></div></figure><p id="bc6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到渲染器目录，因为我们还有几件事要做。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ceb4" class="ma mb it lw b gy mc md l me mf"># move back out to the parent directory<br/>cd ..</span><span id="9d44" class="ma mb it lw b gy nf md l me mf"># move into the renderer directory<br/>cd renderer</span></pre><p id="684e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:如果您缺少一个<code class="fe mi mj mk lw b">tsconfig.json</code>文件，请创建它:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="225f" class="ma mb it lw b gy mc md l me mf">{<br/>  "compilerOptions": {<br/>    "allowJs": true,<br/>    "allowSyntheticDefaultImports": true,<br/>    "esModuleInterop": true,<br/>    "forceConsistentCasingInFileNames": true,<br/>    "isolatedModules": true,<br/>    "jsx": "preserve",<br/>    "lib": ["dom", "dom.iterable", "esnext"],<br/>    "module": "esnext",<br/>    "moduleResolution": "node",<br/>    "noEmit": true,<br/>    "skipLibCheck": true,<br/>    "strict": false,<br/>    "target": "es5",<br/>    "resolveJsonModule": true<br/>  },<br/>  "include": ["src"]<br/>}</span></pre><p id="b081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，我们现在应该有两个工作流程！</p><p id="59a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入你的渲染器进程目录并运行<code class="fe mi mj mk lw b">npm start</code>,你会看到一个正常运行的服务器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/b7e3543817d29152162d5fe1465c60a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wGhlWcCud6f77tCh.jpg"/></div></div></figure><p id="e7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，打开另一个终端，进入主进程目录并运行<code class="fe mi mj mk lw b">npm start</code>。它应该也能工作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/21540f262053995ff2ce949fdd23f419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dkYN9NMFRHBl6cVo.jpg"/></div></div></figure><p id="ba16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万岁！我们终于做到了！我们现在几乎可以开始开发了！等等，什么？</p><p id="ed4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，没错。我们还没有完全完成。你有没有注意到当你修改主程序代码时，电子程序没有重新加载？我们将需要<a class="ae ky" href="https://github.com/jeffbski/wait-on" rel="noopener ugc nofollow" target="_blank">等待</a>包来决定何时执行<code class="fe mi mj mk lw b">electron.js</code>文件。这完美地解决了我们的问题，因为它会等到HTTP请求返回一个<code class="fe mi mj mk lw b">200</code>代码，然后当应用程序准备好继续运行时，它会继续执行脚本。</p><p id="5385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将同时使用<a class="ae ky" href="https://github.com/kimmobrunfeldt/concurrently" rel="noopener ugc nofollow" target="_blank">和</a>，这样我们就可以同时运行我们的命令，因为它们可以单独运行:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f979" class="ma mb it lw b gy mc md l me mf">{<br/>  "name": "main",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "./src/electron.js",<br/>  "scripts": {<br/>    "start": "concurrently \"tsc ./src/electron.ts -w\" \"cross-env NODE_ENV=dev nodemon --exec \"\"wait-on http://localhost:3000 &amp;&amp; electron src/electron.js\"\""<br/>  },<br/>  "author": "",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "electron": "^6.0.12"<br/>  },<br/>  "devDependencies": {<br/>    "@types/electron": "^1.6.10",<br/>    "concurrently": "^5.0.0",<br/>    "cross-env": "^6.0.3",<br/>    "electron-is-dev": "^1.1.0",<br/>    "electron-reload": "^1.5.0",<br/>    "nodemon": "^1.19.3",<br/>    "typescript": "^3.6.4",<br/>    "wait-on": "^3.3.0"<br/>  }<br/>}</span></pre><p id="f5c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你达到这一点，你就可以开始开发你喜欢的应用程序代码了。记住，你可以独立于你的渲染进程开发主进程，但是当你用<a class="ae ky" href="https://github.com/electron-userland/electron-builder" rel="noopener ugc nofollow" target="_blank">electronic-builder</a>打包它们时，它们会被打包在一起。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="5587" class="no mb it bd np nq nr ns nt nu nv nw nx jz ny ka nz kc oa kd ob kf oc kg od oe bi translated">结论</h1><p id="1d4a" class="pw-post-body-paragraph kz la it lb b lc of ju le lf og jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">这部分就结束了。我希望您发现这是有价值的，并且它帮助您对如何将TypeScript集成到其他项目中有了更多的了解。以后多找找！</p></div></div>    
</body>
</html>