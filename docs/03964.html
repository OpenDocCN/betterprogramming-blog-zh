<html>
<head>
<title>Algorithms: Solving the Fibonacci Sequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:求解斐波那契数列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-solving-the-fibonacci-sequence-9aee63a7a946?source=collection_archive---------10-----------------------#2020-03-16">https://betterprogramming.pub/algorithms-solving-the-fibonacci-sequence-9aee63a7a946?source=collection_archive---------10-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="37cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">递归地、记忆地、迭代地解决它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5d3c70c7884e66d359c5026c73c84e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MZxqoBb3PMrxFP_c.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>在<a class="ae kv" href="https://pixabay.com/illustrations/fibonacci-spiral-science-golden-3210944/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="3099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能听说过斐波那契数列是“黄金比例”。这个名字是由于数字之间的比例为1.618034。</p><p id="ac66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">据说，当我们看到树木的生长点或花瓣，或我们的身体部位(一个鼻子，两个眼睛，每只手五个手指)时，它会在自然界中表达出来。</p><p id="892a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会讨论斐波那契背后的理论，而是用JavaScript函数解决它的两种半方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b043" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是斐波那契数列？</h1><p id="a9b3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">斐波那契数列以意大利数学家莱昂纳多·比萨的名字命名，是一个数字序列，其中前两个数字之后的每个数字都是前面数字的总和。下面我们来看看。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1860" class="nb ma iq mx b gy nc nd l ne nf">Fibonacci Sequence:<br/>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...</span><span id="3fe0" class="nb ma iq mx b gy ng nd l ne nf">Such that:  <br/>1 + 1 = 2; <br/>2 + 3 = 5; <br/>3 + 5 = 8;<br/>8 + 13 = 21;<br/>13 + 21 = 34;<br/>21 + 34 = 55;<br/>34 + 55 = 89;<br/>and so on to infinity</span></pre><p id="4b91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以把数字想象成一个树状的数据结构。如果我们将序列组织成一棵树，我们就可以计算该位置上任何数字的斐波那契值。</p><p id="30c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从底部开始向上，我们可以添加子对并向上到达<code class="fe nh ni nj mx b">fib(5)</code>，这里的值实际上是5。我们可以看到<code class="fe nh ni nj mx b">fib(1), fib(2), fib(3)</code>被多次重复。</p><p id="d294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个序列的一种方法是使用动态编程。我们可以通过寻找重复来将问题分解成更小的块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/7adc5c9df4b151191ec720c128d1f53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rSPHwU8mJxezLa2Dbz4IA.png"/></div></div></figure><p id="71bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题的一些方法是使用递归、记忆或迭代。正如我们将看到的，它们都有自己的时间复杂性。让我们深入其中，用JavaScript编写斐波那契函数。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="daf4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">天真的解决方案——o(2^n)</h1><p id="f46a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果<code class="fe nh ni nj mx b">fib(1) = 1</code>和<code class="fe nh ni nj mx b">fib(2) = 1</code>，那么我们可以算<code class="fe nh ni nj mx b">fib(n) = fib(n-1) + fib(n-2)</code>。因此，我们可以使用递归来编写一个解决方案，如下所示:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="eb96" class="nb ma iq mx b gy nc nd l ne nf">function fibRecursion(n) {<br/>   if(n &lt;= 2) return 1;<br/>   return fib(n-1) + fib(n-2);<br/>}</span></pre><p id="6c5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数接受一个整数<em class="nl"> n </em>。在第1行，我们有一个基本情况，即小于或等于2的整数<em class="nl"> n </em>将给出起始数1，因为我们想从第三个数开始计数。</p><p id="c640" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在最后一行，我们递归地调用函数。这种解决方案被认为是幼稚的，因为尽管它完成了工作，但不是最佳的。这个函数的big-O时间复杂度是O(2^n) <strong class="ky ir"> </strong>非常慢。</p><p id="022d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们回头看树，这个解决方案会让我们一遍又一遍地检查每个孩子，即使我们已经计算了值。</p><p id="a9de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nh ni nj mx b">fib(5)</code>的例子中，还不太清楚这个函数会如何运行缓慢，但是当我们开始使用更大的输入值时，树会快速增长，运行起来会变得非常昂贵。</p><p id="3af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看一个更好的解决方案，仍然使用递归。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="909b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">递归和记忆解— O(n)</h1><p id="5f5c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">简单解决方案的一个问题是有许多重复的函数调用。对此进行优化的一种方法是记住之前计算的值并存储这些值。这个概念被称为<em class="nl">记忆</em>。</p><p id="4fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记忆化是一种优化技术，它通过在重复相同输入时存储结果来加快运行时间。我们可以将数据存储或记忆在数据结构中，如数组或对象。</p><p id="6c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们这样做，并将计算出的值存储到一个数组中。这一次，我们的函数将采用两个参数:<code class="fe nh ni nj mx b">n</code> <em class="nl"> </em>和<code class="fe nh ni nj mx b">memo=[]</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在2号线又有了基本情况。在第1行，我们说如果索引为<code class="fe nh ni nj mx b">n</code>的memo数组不是未定义的，我们想要返回值。</p><p id="2f05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">var <code class="fe nh ni nj mx b">res</code>被分配递归函数调用。<code class="fe nh ni nj mx b">memo[n]</code>将被重新分配给<code class="fe nh ni nj mx b">res</code>的值。该函数最终将返回位置<em class="nl"> n </em>处序列的整数。</p><p id="1739" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种解决方案最终比简单的解决方案要快得多，因为随着<em class="nl"> n </em>的增长，运行的时间也会增长。因此，这种递归和记忆的解决方案具有O(n)的大时间复杂度。</p><p id="7fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">空间复杂度也不是很大。随着<em class="nl"> n </em>的增长，内存化占用了相当大的空间，所以这个解决方案的<em class="nl">空间复杂度</em>也是O(n)。</p><p id="16eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解决方案遵循一种<em class="nl">自上而下的方法</em> <strong class="ky ir"> </strong>从树根开始，一直到孩子。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e112" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">迭代解法:制表，又名“自下而上”——O(n)</h1><p id="6c02" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我提到了对两个半解决方案的关注，而不是三个，因为记忆解决方案包括递归。</p><p id="89aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看另一种用迭代求解斐波那契的方法。您可能知道，迭代包括一次又一次的循环，直到满足某些条件。像memoization一样，我们将存储每个位置的值，但我们将使用“表”而不是“备忘录”。</p><p id="93a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，“表”也是一种数据结构，就像数组或对象一样。这种迭代方法被称为<em class="nl">制表</em>。制表在O(1)处比记忆化具有更好的空间复杂度<strong class="ky ir"> </strong>，然而，大O时间复杂度仍然是O(n)。</p><p id="8d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fde7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在1号线又有了基本情况。在第2行，我们建立了我们的“表”,它是前两个数字的数组。因为我们从索引1开始，所以索引0可以设置为0或者未定义。</p><p id="ca72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们从索引3开始循环，直到到达<em class="nl"> n </em>。最后，我们只返回第n个索引<em class="nl">的值。就是这样！我们只是从桌子的“底部”开始向上爬。</em></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="238c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="16c7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我个人认为迭代更容易理解。乍一看，代码比递归简单得多。</p><p id="f983" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的斐波那契数列的例子中，如果我们要优化时间和空间的复杂性，迭代似乎是一种方法。</p><p id="2091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归、记忆和列表/迭代都是动态编程的一部分。这里有一些资源，你可以看看，以了解更多！快乐编码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e675" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><div class="no np gp gr nq nr"><a href="https://frontendmasters.com/courses/practical-algorithms/introducing-dynamic-programming/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">了解动态编程简介JavaScript算法实用指南</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Bianca讨论了动态编程，这是一种数据优化技术。动态方法将值缓存到…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">frontendmasters.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://www.tutorialspoint.com/dynamic-programming-in-javascript" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">JavaScript中的动态编程</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">动态编程将问题分解成越来越小的可能的子问题。这些子问题是…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of kp nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://www.freecodecamp.org/news/demystifying-dynamic-programming-24fbdb831d3a/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">揭开动态编程的神秘面纱</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">通过Prajwal M揭秘动态编程图像信用…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.freecodecamp.org</p></div></div><div class="oa l"><div class="oh l oc od oe oa of kp nr"/></div></div></a></div></div></div>    
</body>
</html>