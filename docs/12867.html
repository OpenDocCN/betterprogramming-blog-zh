<html>
<head>
<title>Building the Rust Web App — How to Use Object-Relational Mapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Rust Web应用程序—如何使用对象关系映射器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-the-rust-web-app-how-to-use-object-relational-mapper-3af2084555b6?source=collection_archive---------6-----------------------#2022-07-07">https://betterprogramming.pub/building-the-rust-web-app-how-to-use-object-relational-mapper-3af2084555b6?source=collection_archive---------6-----------------------#2022-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="971c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最大限度地利用容器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65a62982027a98e6bb676326cc9b2295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v5TEreWRhusVimDN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@landscapeplaces" rel="noopener ugc nofollow" target="_blank">费德里科·博托斯</a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6bb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是关于编写web应用程序的系列文章的第三部分。对于这个系列，我们将在<a class="ae kv" href="https://www.rust-lang.org/learn/get-started" rel="noopener ugc nofollow" target="_blank"> Rust </a>中编写web应用程序，我将向您解释如何自己编写它。</p><p id="b5ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您不愿意自己编写代码，我在这里<a class="ae kv" href="https://github.com/garrettudstrand/rust-web-app/tree/main" rel="noopener ugc nofollow" target="_blank">创建了一个包含本系列所有代码的库。在本系列的每一部分的结尾，我都提交了一个存储库。</a><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-a-web-app-in-rust-part-2-2da195369fc1">在前一部分</a>中，我们介绍了使用数据库使CRUD操作变得更加容易。在这一部分中，我们将讨论如何使用对象关系映射器，或简称ORM，来使数据库的使用变得更加容易。</p><h1 id="b5fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">ORMs</h1><p id="bbd2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射</a>是一种在面向对象编程语言的类型系统之间转换数据的技术。<a class="ae kv" href="https://stackoverflow.com/questions/1279613/what-is-an-orm-how-does-it-work-and-how-should-i-use-one" rel="noopener ugc nofollow" target="_blank">为了简化</a>，它是一种将类及其数据转换成可供其他程序使用的数据的技术。不过，一般来说，当有人提到“一个ORM”时，他们讨论的是使用这种技术的库。</p><p id="e9c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ORM几乎总是与数据库一起使用。ORM将接受一个类中的对象或一个结构的实例，并在数据库中为其创建一个条目。所以，我们可以只给ORM一个我们的<code class="fe mp mq mr ms b">Task</code>结构的实例，它会为我们在<code class="fe mp mq mr ms b">tasks</code>表中创建一个条目，而不是要求我们自己写<code class="fe mp mq mr ms b">sql</code>。</p><p id="6214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，ORM基本上是一种减少样板代码的方法。我们没有写一堆重复的<code class="fe mp mq mr ms b">sql</code>代码，而是让ORM根据我们的结构和我们留在这些结构中的代码来生成<code class="fe mp mq mr ms b">sql</code>代码。除此之外，ORM经常实现一些方法来创建数据库中可用的表。这些被称为“迁移”</p><p id="6c2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们的数据库驱动程序让我们能够在数据库上运行<code class="fe mp mq mr ms b">sql</code>命令。它只是允许与我们的数据库进行交互。ORM允许我们用自己选择的语言编写，而不是运行<code class="fe mp mq mr ms b">sql</code>命令来与数据库交互。</p><p id="86ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照我们配置Rocket的方式，它应该使用异步ORM。目前Rust中最流行的异步ORM是<a class="ae kv" href="https://github.com/SeaQL/sea-orm" rel="noopener ugc nofollow" target="_blank"> SeaQL/sea-orm </a>，所以这是我们将在代码库上实现的。</p><p id="f28b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，修改你的<code class="fe mp mq mr ms b">Cargo.toml</code>,如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e3d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至此，我们已经安装了<code class="fe mp mq mr ms b">sea-orm</code>和其他一些我们需要的库，并移除了现在多余的库。现在，我们要做的第一件事是创建我之前提到的那些迁移。我们将使用<code class="fe mp mq mr ms b">sea-orm</code>在我们的数据库中创建表格，所以我们不必手工完成。</p><h1 id="2925" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">迁移</h1><p id="db6c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在您的终端中，运行以下命令:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="8673" class="mz lt iq ms b gy na nb l nc nd">cargo install sea-orm-cli</span></pre><p id="0d75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将安装一个<a class="ae kv" href="https://www.techtarget.com/searchwindowsserver/definition/command-line-interface-CLI" rel="noopener ugc nofollow" target="_blank">命令行界面(CLI) </a>，因此我们可以在我们的终端上运行某些命令。可以想象，这些命令使得用<code class="fe mp mq mr ms b">sea-orm</code>做某些事情变得更加容易。使用我们新安装的CLI，我们将通过运行以下命令来创建保存迁移的目录:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="fbf8" class="mz lt iq ms b gy na nb l nc nd">sea-orm-cli migrate init</span></pre><p id="3400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我当前版本的<code class="fe mp mq mr ms b">sea-orm</code>中，这会产生一个稍微错误的<code class="fe mp mq mr ms b">Cargo.toml</code>。确保您的<code class="fe mp mq mr ms b">migration</code>目录中的<code class="fe mp mq mr ms b">Cargo.toml</code>具有为<code class="fe mp mq mr ms b">sea-orm-migration</code>启用的<code class="fe mp mq mr ms b">sqlx-postgres</code>和<code class="fe mp mq mr ms b">runtime-tokio-native-tls</code>特性，并且按照如下方式导入<code class="fe mp mq mr ms b">async-std</code>和Rocket(<code class="fe mp mq mr ms b">async-std</code>的导入是以<code class="fe mp mq mr ms b">[dependencies.async-std]</code>开始的代码块)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8b13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将通过运行以下命令来创建新的迁移:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="2d58" class="mz lt iq ms b gy na nb l nc nd">sea-orm-cli migrate generate create_tasks_table</span></pre><p id="57c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你转到<code class="fe mp mq mr ms b">migration/src</code>，你会看到一个以<code class="fe mp mq mr ms b">m</code>开头的文件，有一些数字，结尾有<code class="fe mp mq mr ms b">create_tasks_table</code>。对我来说，它以<code class="fe mp mq mr ms b">m20220623_084419_create_tasks_table</code>结束，但这个数字取决于时间，所以对你来说会有所不同。不管怎样，打开那个文件。现在，将以下代码放入该文件。</p><p id="1d7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:在<code class="fe mp mq mr ms b">impl MigrationName...</code>下，保持字符串与文件名相同。这不应该是我的名字。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b4e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">删除前面有数字的另一个文件并修改<code class="fe mp mq mr ms b">lib.rs</code>,这样它只使用您的迁移:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="68dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，确保<code class="fe mp mq mr ms b">migration/src</code>中的<code class="fe mp mq mr ms b">main.rs</code>如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在终端运行时</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="05fb" class="mz lt iq ms b gy na nb l nc nd">cargo new entity</span></pre><p id="9e6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mp mq mr ms b">entity</code>的<code class="fe mp mq mr ms b">Cargo.toml</code>修改如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe mp mq mr ms b">[lib]</code>下面的<code class="fe mp mq mr ms b">name</code>和<code class="fe mp mq mr ms b">path</code>值是默认值。但是这些只是放在那里以防缺省值改变。我们真正需要的是<code class="fe mp mq mr ms b">[lib]</code>来声明Cargo有一个库目标。</p><p id="581f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mp mq mr ms b">entity/src/main.rs</code>重命名为<code class="fe mp mq mr ms b">lib.rs</code>。我们将确保用一些可以导入的代码来替换它。</p><p id="3f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们最初的<code class="fe mp mq mr ms b">src</code>，<code class="fe mp mq mr ms b">sea-orm</code>将会取代我们之前在例子中使用的数据库驱动。它在很大程度上是相同的数据库驱动程序，但是它有一些额外的特性和其他特殊的东西来使它与<code class="fe mp mq mr ms b">sea-orm</code>一起工作。</p><p id="8d6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，我们只是将允许我们连接到数据库的代码视为不需要理解的样板文件。我们将把这个样板文件放到它自己的文件中，然后将需要的部分导入到<code class="fe mp mq mr ms b">main.rs</code>中。因此，在<code class="fe mp mq mr ms b">src</code>中，用下面的代码创建一个名为<code class="fe mp mq mr ms b">pool.rs</code>的新文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="23dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将更改我们的主要功能，以连接到我们更新、更好的数据库，并运行我们正在创建的迁移。因此，进入<code class="fe mp mq mr ms b">main.rs</code>并改变<code class="fe mp mq mr ms b">rocket</code>功能，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="925b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这样做很痛苦，但是<code class="fe mp mq mr ms b">main.rs</code>中的这些代码都不再有目的了，所以我们要删除它。删除<code class="fe mp mq mr ms b">Task</code>结构、<code class="fe mp mq mr ms b">TaskItem</code>结构、<code class="fe mp mq mr ms b">TaskId</code>结构、<code class="fe mp mq mr ms b">TodoDatabase</code>结构、<code class="fe mp mq mr ms b">DatabaseError</code>结构、<code class="fe mp mq mr ms b">Database Error</code>、<code class="fe mp mq mr ms b">add_task</code>、<code class="fe mp mq mr ms b">read_tasks</code>、<code class="fe mp mq mr ms b">edit_task</code>和<code class="fe mp mq mr ms b">delete_task</code>的两个实现。当该说的都说了，该做的都做了，我们的<code class="fe mp mq mr ms b">main.rs</code>又几乎焕然一新了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e27b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在Postgres中，登录到<code class="fe mp mq mr ms b">todo</code>数据库，用下面的命令删除预先存在的<code class="fe mp mq mr ms b">tasks</code>表:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="7d47" class="mz lt iq ms b gy na nb l nc nd">DROP TABLE tasks;</span></pre><p id="a168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些都完成后，您可以再次在终端中运行<code class="fe mp mq mr ms b">cargo run</code>，它将使用我们的迁移来创建一个<code class="fe mp mq mr ms b">tasks</code>表。它还将创建一个名为<code class="fe mp mq mr ms b">seaql_migrations</code>的表，该表将跟踪我们的迁移信息。</p><h1 id="b30a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实体</h1><p id="2d75" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">实体是我们用来从数据库中提取数据和将数据放入数据库的奇特结构。使用SeaORM，可以选择在运行迁移后从数据库中生成实体。但是通常最好只运行一次，并且手工编写大部分实体。</p><p id="953c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主要是因为我们将编辑这些实体，以便在我们的项目中更好地工作，并且运行实体生成命令会覆盖我们所做的更改。因此，我只是给你我们制作的实体的代码，但是请记住，如果你发现有必要或者有很好的用途，你可以从现有的数据库中生成实体。</p><p id="a4cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在<code class="fe mp mq mr ms b">entity/src</code>中创建一个名为<code class="fe mp mq mr ms b">tasks.rs</code>的文件，并输入以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，您可能注意到我们的<code class="fe mp mq mr ms b">id</code>字段应用了属性<code class="fe mp mq mr ms b">#[field(default = 0)]</code>。这使得在处理我们的数据时，如果没有给定值，<code class="fe mp mq mr ms b">id</code>将默认为0，因此可以输入没有<code class="fe mp mq mr ms b">id</code>的<code class="fe mp mq mr ms b">Task</code> s。</p><p id="b835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样一来，在<code class="fe mp mq mr ms b">entity/src</code>中创建一个名为<code class="fe mp mq mr ms b">lib.rs</code>的文件，并在其中输入以下代码:</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="baa3" class="mz lt iq ms b gy na nb l nc nd">pub mod tasks;</span></pre><p id="a378" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将允许在任何导入<code class="fe mp mq mr ms b">entity</code>库箱的包中使用<code class="fe mp mq mr ms b">tasks.rs</code>中的<code class="fe mp mq mr ms b">Model</code>结构(用这段代码创建一个名为<code class="fe mp mq mr ms b">entity</code>的文件夹允许我们在本地创建一个名为<code class="fe mp mq mr ms b">entity</code>的库)。如果你想了解更多关于Rust如何处理文件和项目间共享代码的信息，请查看Rust书籍的第7章，其中有一些很好的细节)。</p><p id="4a8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，就我们的代码而言，我们现在可以使用导出的<code class="fe mp mq mr ms b">tasks</code>模型作为获取输入数据的结构。注意，模型实现了<code class="fe mp mq mr ms b">FromForm</code>，所以我们现在将输入数据为<code class="fe mp mq mr ms b">x-www-form-urlencoded</code>而不是JSON。考虑到我们的基本参数数量很少，这个切换很有意义。</p><p id="0753" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在Rocket中，默认情况下表单解析是宽松的，所以如果有缺失、重复或额外的字段，它仍然会解析。考虑到我们有些地方可能得到一个<code class="fe mp mq mr ms b">id</code>，但是没有条目，一个条目，但是没有id，或者两者都有，这将减少我们以前必须编写的额外代码。</p><p id="fb4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，让我们通过ORM重新实现我们所有的CRUD操作。您会注意到，我主要使用模型在数据库中查找条目，并使用模型的结构将我整理的条目添加到数据库中。这就是ORM的力量。我现在不用写<code class="fe mp mq mr ms b">sql</code>；我可以用Rust写出函数。</p><p id="2bb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们开始吧！首先是重写创建操作。下面是代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们再次使用了<code class="fe mp mq mr ms b">DatabaseError</code>作为来自数据库的实际错误的包装器，这样我们就可以返回这些错误。在<code class="fe mp mq mr ms b">add_task</code>中，<code class="fe mp mq mr ms b">into_inner</code>函数从我们拥有的变量中提取我们想要的数据。</p><p id="c09c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在SeaORM中，要使用一个模型来更新或创建一个项目，它需要是一个<code class="fe mp mq mr ms b">ActiveModel</code>，所以我们必须使用我们已经拥有的数据来创建一个<code class="fe mp mq mr ms b">ActiveModel</code>版本。最后，最后一行当然是将商品插入数据库。</p><p id="5de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来是更简单的读取操作。我已经包含了这个函数中使用的一个变量的导入，因为它是一个命名的导入，否则您将无法正确地导入它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4d84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个也很简单。使用数据库查找所有任务，并按id升序排列。</p><p id="024b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，<code class="fe mp mq mr ms b">edit_task</code>有点复杂，但仍然很简单。我们找到我们试图更新的任务，<code class="fe mp mq mr ms b">task_to_update</code>，修改我们想要的字段，然后调用<code class="fe mp mq mr ms b">update</code>来更新数据库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5f76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe mp mq mr ms b">delete_task</code>是唯一一个稍微改变了API的。由于我从SeaORM只得到一个<code class="fe mp mq mr ms b"><a class="ae kv" href="https://docs.rs/sea-orm/latest/sea_orm/struct.DeleteResult.html" rel="noopener ugc nofollow" target="_blank">DeleteResult</a></code>，我现在只返回删除了多少任务，而不是删除的任务。</p><p id="98fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，因为我不能确保任务表单中给出了一个<code class="fe mp mq mr ms b">id</code>，并且我接受的唯一值是一个<code class="fe mp mq mr ms b">id</code>，所以我将<code class="fe mp mq mr ms b">id</code>作为URL的一个参数，在这种情况下效果很好。因此，它看起来不同，但基本上做同样的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="602f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，整体的<code class="fe mp mq mr ms b">main.rs</code>看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="71f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们再次实现了CRUD操作，这一次使用了ORM。然而，我们在代码库中添加了很多代码，并且在<code class="fe mp mq mr ms b">main.rs</code>中只保存了大约三行。让我们谈谈那个。</p><h1 id="6f4f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">过度设计一个问题</h1><p id="e238" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于任何软件问题，我们可以增加复杂性来增加灵活性。换句话说，我们可以添加更多的代码，使我们的解决方案变得更加复杂，这样就更容易改变我们解决方案的某些方面，或者向它添加新的特性。</p><p id="79ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，我们希望我们的代码有一定的灵活性。由于编程是迭代的，几乎可以肯定有人会看到你写的东西，并决定对它进行修改或添加新功能。如果你的代码是灵活的，无论开发人员要做什么，都会容易得多。</p><p id="4b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，复杂性的增加使得理解你的代码变得更加困难。此外，解决方案越复杂，就越容易出现错误。很难预料或注意到的小问题或错误。</p><p id="8490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，更复杂的代码更难维护。需要维护的代码越来越多，代码做的事情越来越复杂，需要更加小心地维护，而且，假设这个更复杂的代码使用了更多的函数库函数或特性，那么当某个函数库更新时，它更容易崩溃。</p><p id="cedc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，对于任何解决方案，您都必须小心谨慎。一个非常灵活的解决方案也将非常复杂，并且将是一场噩梦，尽管最初的意图是使它更容易使用。另一方面，一个非常简单的解决方案将没有灵活性，因此每当需要添加新功能时，它可能都必须从头开始重新编写。两个极端都不理想。</p><p id="1995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您“过度设计”一个问题时，这意味着您已经使您的代码过于灵活，并且，在这个过程中，使它比它应该的要复杂得多。当然，一个解决方案是否真的被过度设计是一个主观看法的问题。这取决于开发者的品味和感受。</p><p id="012e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，就像任何主观的事情一样，在某些情况下大多数人都同意。我相信大多数人都会同意，为我们正在做的项目实现ORM是过度工程化的。</p><p id="2b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ORM使得创建包含大量关系的大量表格以及处理大型数据库中的数据变得非常容易。当你有几十或几百张桌子时，这是一个工具。在我们的例子中，当我们完成这个应用程序时，我们只有两个表。虽然直接通过<code class="fe mp mq mr ms b">sql</code>维护它们更困难，但它也需要更少的代码复杂性，并且对于少量的表是可管理的。</p><p id="ddee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我为什么要实现ORM呢？正如我在本文开始时所说的，我的目标是展示现代web应用程序和框架使用的各种库和概念，以便您可以更好地理解它们。虽然ORM对这个应用程序来说不是一个好主意，但它是我想要展示的一个概念，因为ORM在后端框架中几乎无处不在。</p><p id="9eb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还会有很多其他事情，解决方案最终会增加很多复杂性，而对应用程序的好处却很少，这是因为我试图展示现代web开发中使用的概念，即使不是所有的概念对于我们正在制作的特定应用程序都是完美的。</p><h1 id="88d7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">集装箱化</h1><p id="9c12" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可能已经注意到了我们当前数据库的一个有趣的问题。事实上，我们必须在我们的机器上安装和设置一个应用程序来使我们的代码工作。当只有一个开发人员在一个项目中工作时，这很好。然而，在多个开发人员可能在这个项目上工作的情况下，这会带来许多挑战。</p><p id="c8bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个问题是安装软件是乏味的，没有乐趣，而且经常容易出错。第二，并不是所有的应用程序都能在所有的操作系统上使用。虽然postgres可以在Windows、Mac和Linux上使用，但对于许多软件来说，这种交叉兼容性并不是必然的。</p><p id="ef38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更进一步，让我们假设一个从事这个项目的开发人员想在家里使用postgres。为多个项目使用相同的postgres安装是可能的，但是很麻烦。除此之外，很难确定将软件运行所需的配置分布到哪里。</p><p id="0539" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那是在自述文件上完成的吗？在空闲时作为消息发送？放入文本文件？如果这些配置更新或更改，会发生什么情况？你如何通知人们？最后，本地安装很容易被开发人员机器上运行的其他东西破坏或搞乱。</p><p id="e57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有一种安装postgres的方法可以避免所有这些问题，那就太好了。既然我提出来了，你知道有。这些问题的答案是集装箱化。集装箱化是如何工作的？我们不是直接在我们的操作系统上运行应用程序，而是在另一个操作系统上运行应用程序。</p><p id="bedd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使操作系统尽可能小，加上做一些其他优化，这可以足够快，并在开发环境中工作良好。更好的是，大多数容器(其中的操作系统和应用程序)可以通过某些文件进行配置。因此，我们可以对postgres这样的应用程序的配置进行版本控制。</p><p id="2e1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们希望安装的容器和应用程序的设置由配置文件控制，开发人员不必担心手动安装软件。大多数容器化应用也是跨平台的，这意味着你可以在一个容器中运行通常不跨平台的应用。</p><p id="4a0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，在大多数容器化应用程序中，你可以拥有任意多的容器，因此如果你愿意，你可以为工作安装postgres，为家庭安装postgres。除此之外，当配置改变时，开发者不再需要被通知，容器化软件将只接受改变的配置并应用它们。</p><p id="05ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，由于我们的应用程序运行在一个完全独立的操作系统中，我们不必担心它被我们机器上的其他应用程序搞乱或破坏。</p><p id="11d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住所有这些，让我们使用容器使我们的postgres安装更容易操作。有各种各样的应用程序提供容器化，但我们将使用<a class="ae kv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。近年来，很多人开始不喜欢Docker的定价模式，因此，如果你打算在未来使用集装箱化，你可能需要考虑其他选择。但是对于我们的玩具示例来说，Docker会工作得很好。所以，去网站，创建一个账户，安装Docker作为桌面应用。</p><p id="fb30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，从这里开始，我们将使用<a class="ae kv" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">Postgres——官方形象</a>来制作我们的容器。什么是图像？它只是安装了应用程序的操作系统。容器是运行图像的实例。因此，我们将使用一个图像来运行一个上面有postgres的容器。</p><p id="0e32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将如何运行这个图像？我们将使用命令行工具<a class="ae kv" href="https://github.com/docker/compose" rel="noopener ugc nofollow" target="_blank"> docker/compose </a>，它与docker的桌面安装一起安装。<code class="fe mp mq mr ms b">docker-compose</code>获取一个名为<code class="fe mp mq mr ms b">docker-compose.yml</code>的文件，并使用它来决定运行什么映像以及使用什么配置。</p><p id="bd7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，作为一个注意，<code class="fe mp mq mr ms b">Dockerfile</code> s可以用来修改现有的图像，让您建立自己的图像，更好地满足您的目的。幸运的是，我们可以只使用基本postgres映像，但是<code class="fe mp mq mr ms b">Dockerfile</code>在开发环境中经常使用，所以我认为应该提到它。</p><p id="4078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，我们将在与<code class="fe mp mq mr ms b">Cargo.toml</code>相同的目录下创建一个名为<code class="fe mp mq mr ms b">docker-compose.yml</code>的文件。在它里面将会有下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您转到<code class="fe mp mq mr ms b">todo-app</code>目录，并运行<code class="fe mp mq mr ms b">docker-compose up</code>，您的数据库将会启动。随着数据库的运行，您可以打开另一个终端并运行您的应用程序。但是，还有一个问题。</p><p id="1fc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为postgres安装在您的机器上，所以它一直在运行一个使用<code class="fe mp mq mr ms b">port 5432</code>的服务。因此，当我们访问<code class="fe mp mq mr ms b">port 5432</code>时，我们将访问我们的本地应用，而不是容器中的应用。</p><p id="2a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关闭或卸载postgres安装，以便连接到容器化的数据库。一旦你这样做了，你会发现什么都没有改变，数据库还是一样的工作。只是现在配置和使用更容易了。</p><h1 id="c0a2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们需要<code class="fe mp mq mr ms b">docker-compose</code>吗？</h1><p id="ccd0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不，我们没有。我们可以通过命令行或桌面应用程序使用适当的设置运行映像。但是，使用<code class="fe mp mq mr ms b">docker-compose</code>允许我们留下一个有用的配置文件，它详细描述了用于使我们的应用程序工作的所有配置。而且，如果我们希望我们的应用程序运行多个容器，我们可以在<code class="fe mp mq mr ms b">docker-compose.yml</code>中列出所有容器的配置。</p><p id="e616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我自己从来没有这样做过，但是你也可以使用<code class="fe mp mq mr ms b"><a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code> <a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">的</a>功能来配置你的图像。因此，如果您出于某种奇怪的原因想要使用<code class="fe mp mq mr ms b">docker-compose</code>，这可能是一种选择。在任何情况下，使用Docker都有很多方法，但我相信这种方法可以最大限度地发挥容器化应用程序的优势，因此我们在本系列中使用它。</p><p id="2224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，这就是我今天的全部内容。在下一部分中，我们将采用我们当前的应用程序，并解决它目前存在的许多问题，如错误处理能力差和前端不存在。</p><p id="ddb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读这篇文章。我希望这个系列能够继续帮助您提高web开发技能。</p><h1 id="b2f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="3403" class="ne nf iq ky b kz mk lc ml lf ng lj nh ln ni lr nj nk nl nm bi translated">【rust-lang.org】Rust编程语言(T4)</li><li id="0859" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://github.com/garrettudstrand/rust-web-app/tree/main" rel="noopener ugc nofollow" target="_blank">本系列的GitHub库</a></li><li id="9046" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象-关系映射-维基百科</a></li><li id="f48d" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://stackoverflow.com/questions/1279613/what-is-an-orm-how-does-it-work-and-how-should-i-use-one" rel="noopener ugc nofollow" target="_blank">数据库——什么是ORM，它是如何工作的，我应该如何使用它？—堆栈溢出</a></li><li id="222b" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://github.com/SeaQL/sea-orm" rel="noopener ugc nofollow" target="_blank"> SeaQL/sea-orm:🐚一个针对Rust(github.com)的异步&amp;动态ORM</a></li><li id="6067" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">什么是命令行界面(CLI)？(techtarget.com)</li><li id="25eb" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html" rel="noopener ugc nofollow" target="_blank">用包、板条箱和模块管理成长中的项目Rust编程语言(rust-lang.org)</a></li><li id="0b8f" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://docs.rs/sea-orm/latest/sea_orm/struct.DeleteResult.html" rel="noopener ugc nofollow" target="_blank">删除sea _ ORM-Rust(docs . RS)中的结果</a></li><li id="a0cc" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">国内码头工人</li><li id="0cc8" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"> Postgres —官方图片| Docker Hub </a></li><li id="bce3" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://github.com/docker/compose" rel="noopener ugc nofollow" target="_blank"> docker/compose:使用Docker(github.com)定义和运行多容器应用程序</a></li><li id="6d67" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">Docker文件参考| Docker文档</a></li></ul></div></div>    
</body>
</html>