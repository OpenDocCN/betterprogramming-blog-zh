<html>
<head>
<title>Build a Verifiably Random Lottery Smart Contract on Ethereum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在以太坊上建立一个可验证的随机彩票智能合约</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-verifiably-random-lottery-smart-contract-on-ethereum-c1daacc1ca4e?source=collection_archive---------5-----------------------#2020-06-01">https://betterprogramming.pub/build-a-verifiably-random-lottery-smart-contract-on-ethereum-c1daacc1ca4e?source=collection_archive---------5-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9cf5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何创建以太坊彩票</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db8cd9e8b193492675ead5dd6cf1554e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApApJllf65Em_KUtIEhEEw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dylan_nolte?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迪伦·诺尔特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/lottery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ce75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">编者按:本文仅供娱乐和教育之用，不构成或包含理财建议。你从这篇文章的内容中采取的任何行动完全是你自己的。</em></p><p id="fa32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正的随机性在以太坊几乎是不可能的。这是因为交易需要经过网络上多个节点的验证才能确认。如果智能合约函数是真正随机的，那么使用该函数验证交易的每个节点都会得出不同的结果，这意味着交易永远不会被确认。</p><p id="5b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/" rel="noopener ugc nofollow" target="_blank">以太坊生态系统中最大的玩家之一最近发布的公告</a>引起了人们对这个问题的兴奋。使用一个叫做<em class="lv">可验证随机函数(VRF)的系统，</em>以太坊智能合约现在可以生成随机数。</p><p id="b5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着那些看起来与智能合约完美契合但却无法实现的概念，因为它们需要随机数，现在可以实现了。</p><p id="51ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个这样的概念是彩票。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6689" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建彩票智能合约</h1><p id="9e2b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们的彩票将有三个阶段。第一个是<em class="lv"> open，</em>任何人支付少量费用就可以提交新号码。第二个是<em class="lv">关闭，</em>不能提交新的数字，随机数正在生成。第三个是<em class="lv">完成，</em>其中号码已经生成，获胜者已经得到报酬。</p><p id="0422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有人中奖，彩票合同可以滚动，增加头奖。</p><h2 id="57fb" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">定义阶段</h2><p id="77cd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">阶段应该限制操作，以便只能执行允许的操作。例如，应该允许新提交的唯一阶段是开放阶段。如果抽奖结束或结束，合同应该禁止新的提交。</p><p id="3254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nm nn no np b">enum</code>，我们可以定义任意多的阶段。姑且称之为<code class="fe nm nn no np b">LotteryState</code>。在我们的状态变量中，我们定义了以下内容:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="55ac" class="na me it np b gy nu nv l nw nx">enum LotteryState { Open, Closed, Finished }<br/>LotteryState public state;</span></pre><p id="09c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然已经定义了枚举，我们可以在函数中设置规则(<code class="fe nm nn no np b">require</code>语句)，确保契约的当前<code class="fe nm nn no np b">state</code>是我们所期望的。</p><p id="613d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于这些<code class="fe nm nn no np b">require</code>语句在整个合同中可能看起来相似，让我们将其最小化。我们可以定义一个修饰符来执行<code class="fe nm nn no np b">require</code>语句，并且我们可以把它赋给任何我们想要的函数。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="bc07" class="na me it np b gy nu nv l nw nx">modifier isState(LotteryState _state) {<br/>    require(state == _state, "Wrong state for this action");<br/>    _;<br/>}</span></pre><p id="062d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们定义函数时，我们可以添加这个修饰符来确保彩票的当前状态是我们所期望的。</p><h2 id="7475" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">提交数字</h2><p id="dee4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">任何人都应该被允许提交一个数字，只要支付最低报名费。但是，每个参赛者不能提交同一个号码超过一次。应该允许新提交的唯一状态是开放状态。</p><p id="c50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们的<code class="fe nm nn no np b">submitNumber</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:提交数字</p></figure><p id="825f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1行定义了名称、单个<code class="fe nm nn no np b">_number</code>参数以及它是<code class="fe nm nn no np b">public</code>和<code class="fe nm nn no np b">payable</code>的事实。它还添加了<code class="fe nm nn no np b">isState</code>修饰符来确保彩票是公开的。</p><p id="5c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2行确保已经支付了正确的报名费，第3行确保消息的发送者还没有提交该数字，并将其添加到流程中的条目中。</p><p id="50aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe nm nn no np b">entries</code>指的是定义猜测数字和输入该数字的一组地址的映射。它是这样定义的:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="82eb" class="na me it np b gy nu nv l nw nx">mapping(uint =&gt; EnumerableSet.AddressSet) entries;</span></pre><p id="cb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">AddressSet</code>是指<a class="ae ky" href="https://docs.openzeppelin.com/contracts/2.x/api/utils#EnumerableSet" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a> <code class="fe nm nn no np b"><a class="ae ky" href="https://docs.openzeppelin.com/contracts/2.x/api/utils#EnumerableSet" rel="noopener ugc nofollow" target="_blank">EnumerableSet</a></code> <a class="ae ky" href="https://docs.openzeppelin.com/contracts/2.x/api/utils#EnumerableSet" rel="noopener ugc nofollow" target="_blank">契约，为原语类型</a>提供了附加功能。</p><p id="7f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦检查完成，接下来的四行将数字添加到猜测中，支付所有者提成的一小部分，并发出一个<code class="fe nm nn no np b">NewEntry</code>事件。</p><h2 id="5299" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">抽号码</h2><p id="ce96" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你读过这篇关于如何使用VRF的文章，那么你会知道生成一个随机数并不像调用一个函数那么简单(就像JavaScript中的<code class="fe nm nn no np b">Math.random()</code>)。</p><p id="0dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要生成一个随机数，您必须从VRF协调器请求随机性，并实现一个VRF可以用响应回调的函数。为此，我们需要定义一个VRF消费者(创建VRF消费者的细节可以在这里找到)，在图2中我们称之为<code class="fe nm nn no np b">RandomNumberGenerator</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:“RandomNumberGenerator”扩展“VRFConsumer”</p></figure><p id="80fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的彩票将采取这个合同的地址作为一个注入参数时，建设。当抽取数字时，它会调用<code class="fe nm nn no np b">request</code>函数。这要求VRF提供随机性，反过来，它在第18行提供对<code class="fe nm nn no np b">filfullRandomness</code>的响应。您可以在图2调用中看到，这是对我们与<code class="fe nm nn no np b">numberDrawn</code>的<code class="fe nm nn no np b">Lottery</code>合同的回调。让我们来定义这些函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:图纸编号</p></figure><p id="112c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">drawNumber</code>只能由我们定义的第1行中彩票的所有者调用，并且只能在彩票处于开奖状态时调用。</p><p id="8f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第7行的<code class="fe nm nn no np b">numberDrawn</code>是一旦随机数被VRF接收到后<code class="fe nm nn no np b">fulfillRandomness</code>调用的函数。它确保<code class="fe nm nn no np b">request-id</code>是从请求中返回的ID，发出一个事件，支付赢家，并将彩票的状态更改为<code class="fe nm nn no np b">Finished</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e026" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">完整的代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:彩票合同</p></figure><p id="c870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个原始的实现，但它展示了区块链上可验证随机性的出现是如何降低像彩票这样的合同的复杂性的。以前的赌博契约需要使用哈希机制、基于时间的机制、基于块的机制等，所有这些机制都是易受攻击的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8baf" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">进一步阅读</h1><p id="58f5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你对区块链开发感兴趣，我会写一些关于如何开始和建立投资组合的教程、演练、提示和技巧。</p></div></div>    
</body>
</html>