<html>
<head>
<title>Monads Are Just Fancy Semicolons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单子只是花哨的分号</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/monads-are-just-fancy-semicolons-ffe38401fd0e?source=collection_archive---------11-----------------------#2020-02-03">https://betterprogramming.pub/monads-are-just-fancy-semicolons-ffe38401fd0e?source=collection_archive---------11-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a14b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">单子可能会令人害怕——把它们当作花哨的分号来对待会让它们变得有趣！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/307ac09f060e65e6a8c329e884bce97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_Cz1KF_b00th0tAffUrtA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:Marcel Moosbrugger</p></figure><p id="8c05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">单子是可编程的分号。就是这样。对于程序员来说，monad提供了允许对动作进行排序的功能。此外，在每两个后续操作之间，会执行一个特定的代码片段。</p><p id="4ad7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">所以，单子是分号——但是你可以配置它的确切行为。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad27" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">让我们后退一步，慢慢开始</h1><p id="a6a5" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在C或Java这样的命令式语言中，分号被用来表示一系列操作。分号前面的代码在分号后面的代码之前执行。在像Haskell这样的语言中，一切或多或少只是一个表达式，乍一看，如何对程序的两个部分进行排序并不明显。</p><blockquote class="mz na nb"><p id="4e81" class="ky kz lu la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated"><strong class="la iu">很高兴知道:</strong>单子来源于一个叫做“范畴理论”的数学领域为了在Haskell中使用和理解单子，没有必要知道这个数学学科的定义和定理。</p></blockquote><p id="50b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">那么，如果测序在其他语言中更容易做到，那么Haskell的设计是不是很糟糕？</strong></p><p id="3910" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">没有，一点也没有。有人可能会说，测序变得更加困难是故意的。Haskell被设计成引用透明的，这只是一种奇特的说法，即每个函数调用都可以用它的返回值替换。</p><p id="a779" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您有一个名为<code class="fe nf ng nh ni b">doCalculation</code>的函数，它接受一个数字，进行一些计算并返回一个数字。在Haskell中，表达式<code class="fe nf ng nh ni b">doCalculation(x) + doCalculation(x)</code> <em class="lu"> </em>可以替换为<code class="fe nf ng nh ni b"><em class="lu">2 * doCalculation(x)</em></code>，我们可以确信程序的行为不会改变。在Java中，一般来说这种替换是不可能的，因为不能保证<code class="fe nf ng nh ni b">doCalculation</code> <em class="lu"> </em>在每次调用时都返回相同的结果。例如，该方法可以只调用一个随机数生成器，并总是返回不同的结果。此外，在像Java这样的语言中,<code class="fe nf ng nh ni b">doCalculation</code>可能会包含一些常见的副作用，比如写入数据库或退出控制台。</p><p id="347b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">引用透明有很多好处。参考透明语言的编译器更容易优化。此外，并行可以在一定程度上实现自动化。然而，所有这些特征都伴随着更难测序的代价。但就此而言，我们可以利用单子。</p><h1 id="b176" class="mc md it bd me mf nj mh mi mj nk ml mm jz nl ka mo kc nm kd mq kf nn kg ms mt bi translated">让我们成为一个单子</h1><p id="a478" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">这样的分号怎么编程和使用？让我们用一个例子来回答这个问题:创建和编辑购物清单。购物清单被表示为字符串列表。我们可以实现一些功能，允许向购物列表中一个接一个地添加项目，以及删除列表中的第一个项目。此外，我们希望计算购物清单被操作(添加和删除商品)的次数。</p><p id="c73d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们必须定义一个新的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7392" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类型<code class="fe nf ng nh ni b">Counter</code>由一个名为<code class="fe nf ng nh ni b">counter</code>的整数和一个任意元素组成。对于我们的购物清单，元素将是一个字符串列表。计数器将表示对该列表进行的操作的次数。</p><p id="d643" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们进入重要的部分。为了编程我们的分号，启用序列，我们做如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3679" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是所有奇迹发生的地方。从更简单的函数开始，<code class="fe nf ng nh ni b">return</code>只是为给定的元素构造一个新的<code class="fe nf ng nh ni b">Counter</code>。它可以用来构建一个新的<code class="fe nf ng nh ni b">Counter</code>，从给定购物清单的<code class="fe nf ng nh ni b">0</code>操作开始。</p><p id="71a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">&gt;&gt;=</code> <strong class="la iu">是“可编程分号”</strong>。和Haskell中的所有东西一样，这只是另一个函数。在我们的例子中，它的类型是<code class="fe nf ng nh ni b"><em class="lu">Counter a -&gt; (a -&gt; Counter b) -&gt; Counter b</em></code>(对于我们的具体购物列表，a和b都是字符串列表)。</p><p id="f929" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们慢慢来。</p><p id="83fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nf ng nh ni b">&gt;&gt;=</code>得到一个带有元素的<code class="fe nf ng nh ni b">Counter</code>(代码中称为<em class="lu"> x </em>)。它用一个给定的函数操纵元素，这个函数再次返回一个<code class="fe nf ng nh ni b">Counter</code>。最后，<code class="fe nf ng nh ni b">&gt;&gt;=</code>返回一个新的<code class="fe nf ng nh ni b">Counter</code>，其中代表操作次数的整数是给定<code class="fe nf ng nh ni b">Counter</code>的整数加上给定函数返回的<code class="fe nf ng nh ni b">Counter</code>的整数加上<code class="fe nf ng nh ni b">1</code>。</p><p id="ef95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的可编程分号的定义中至关重要的是，第二个参数中给出的函数之前的<code class="fe nf ng nh ni b">Counter</code> <em class="lu"> </em>是已知的<em class="lu"> </em>，可以进行求值。因此，如果第一个参数中的<code class="fe nf ng nh ni b">Counter</code>(在<code class="fe nf ng nh ni b">&gt;&gt;=</code>之前)只是一个产生具体<code class="fe nf ng nh ni b">Counter</code>的表达式，我们可以确定这个表达式将在第二个参数中给出的函数(在<code class="fe nf ng nh ni b"><strong class="la iu">&gt;&gt;=</strong></code>之后)被调用之前被求值。</p><p id="c372" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了能够在购物清单中添加和删除商品，我们需要再定义两个函数，这两个函数都是一行程序。此外，我们定义了我们的第一个购物清单——即空购物清单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b22a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至此，我们已经准备好创建一个典型的购物清单，一次一个项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="89e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行代码会产生以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0456" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里发生了什么？</p><p id="8b2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从空的购物清单开始，其中没有任何元素，它的计数器被初始化为<code class="fe nf ng nh ni b">0</code>。我们的可编程分号<code class="fe nf ng nh ni b">&gt;&gt;=</code>获取一行产生的列表，并将其传递给下一行的函数。</p><p id="0ade" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">空购物清单本质上是通过线传递的，并且在每个阶段都被操纵。中心点是，我们可以确定，例如，“面包”加在“黄油”之前。如上所述，这要感谢我们的可编程分号的定义。</p><p id="e583" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是请注意，我们的“一元行为”中的一切都是由函数组成的。每一行都是匿名函数(第一行除外)，还有<code class="fe nf ng nh ni b">&gt;&gt;=</code>。总之，我们已经实现了一种以纯函数方式对动作进行排序的方法。</p><p id="389a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Haskell提供了很多语法上的好处，允许以更强调顺序属性的方式编写上面的一元操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d23c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个定义是完全等价的。最后，用哪一个是一个品味的问题。不过，首先，建议使用显式形式，以提醒您在幕后发生了什么。</p><p id="6487" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于操纵的计数还有一个重要的事实。一旦在可编程分号中定义，计数在一元操作中是完全不可见的。神奇的事情发生在我们的分号里面，<code class="fe nf ng nh ni b">&gt;&gt;=</code>。因为这个函数的功能可以自由定义，所以它是隐藏各种东西的好地方。例如，预定义的maybe monad隐藏了对其可编程分号中的<code class="fe nf ng nh ni b">null</code>的检查，并在<code class="fe nf ng nh ni b">null</code>出现时跳过所有后续行。而且，日志可以以一元的方式实现，隐藏在<code class="fe nf ng nh ni b">&gt;&gt;=</code>中。解析器是另一个应用程序，它利用了状态单子——但那是另一回事了。</p><p id="d8e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，单子在很多情况下都是有用的。最终，它们只是可编程的分号<strong class="la iu">。</strong></p></div></div>    
</body>
</html>