<html>
<head>
<title>How to Write a RegEx Worthy of Passing Code Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何写一个值得通过代码评审的正则表达式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-regex-worthy-of-passing-code-review-68b9a25c013a?source=collection_archive---------6-----------------------#2022-04-22">https://betterprogramming.pub/how-to-write-a-regex-worthy-of-passing-code-review-68b9a25c013a?source=collection_archive---------6-----------------------#2022-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们再次让正则表达式变得酷起来</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/72fc9b772a607473167ad51ba1fd5214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVOB0nnkKk_K4QbXRrT3PA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的图片</p></figure><p id="cabb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到这样的正则表达式，您会作何反应:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="cb2d" class="lz ma it lv b gy mb mc l md me">/^([0-9]{5}([\s]+|,)+)*([0-9]{5})$/</span></pre><p id="11f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码审查中？</p><p id="b9fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是否清楚这个表达式试图做什么，不做什么，或者如何测试？可悲的是，一个典型的正则表达式要么太简单以至于毫无用处，要么太复杂以至于只有编写它的工程师才能理解。</p><p id="aa72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不一定要这样！您可以仅用一些基本知识编写有效的正则表达式，并使它们对其他工程师来说是可读的，甚至是那些发誓永远不使用它们的固执己见的工程师。</p><p id="270c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让下面的内容成为理解、利用和维护正则表达式的实用指南。</p><h1 id="d235" class="mf ma it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">快速背景</h1><p id="2a1d" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">正则表达式(RegEx)为匹配和解析字符串提供了一种简洁的、与语言无关的格式。在理论计算机科学中，可以证明任何<a class="ae nb" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">有限状态机</a>都有一个等价的正则表达式。实际上，这意味着一个正则表达式可以代表一个完整的数据处理算法，所有这些都在一个简单的字符串中。</p><p id="b307" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，正则表达式应该像其他代码一样对待。它应该写得干净易读，这样任何人都可以轻松地回来维护它。请继续阅读，了解我们如何将编程最佳实践应用于正则表达式(附示例)。</p><h1 id="f218" class="mf ma it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">示例1:邮政编码</h1><p id="e1fb" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">这里有一个正则表达式，它将匹配任何包含5个数字的字符串，除此之外没有其他内容，例如美国邮政编码:</p><p id="9d05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nc nd ne lv b">^[0-9]{5}$</code></p><p id="7b22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是所有这些符号的含义:</p><ul class=""><li id="95d7" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">^</code> —匹配字符串的开头</li><li id="74e4" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">[0-9]</code> —匹配任何数字(特别是集合<code class="fe nc nd ne lv b">{0,1,2,3,4,5,6,7,8,9}</code>中的一个字符)</li><li id="b35e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">{5}</code> —精确应用<code class="fe nc nd ne lv b">[0-9]</code>5次</li><li id="5deb" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">$</code> —匹配字符串的结尾</li></ul><p id="0151" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，我们的正则表达式将匹配任何只有5个数字的字符串，前面没有，后面没有。让我们运行它，并将其复杂性与自制的字符串解析解决方案进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1877" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">似乎有用。这是我得到的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="5d93" class="mf ma it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">示例2:许多邮政编码</h1><p id="9deb" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">现在，让我们用一个更难的解析问题来使事情变得有趣。假设我们想要验证一个表示邮政编码列表的字符串，每个邮政编码由逗号或空格分隔。我们可以检查字符串是否匹配这个(丑陋的)正则表达式:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="fbfc" class="lz ma it lv b gy mb mc l md me">^([0-9]{5}([\s]+|,)+)*([0-9]{5})$</span></pre><p id="18df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一切意味着什么:</p><ul class=""><li id="0180" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">([0–9]{5})</code>匹配一个邮政编码(如例1所示，括号处理分组)</li><li id="691b" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">[\s]+</code>匹配一个或多个空格字符，如空格、制表符等。</li><li id="35ad" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">|</code>匹配前面的图案<em class="nv">或后面的图案</em></li><li id="f111" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">,</code>匹配一个逗号</li><li id="7956" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">([\s]+|,)+</code>匹配一个或多个空格或逗号，一次或多次(这代表一个有效的分隔符或一系列分隔符)</li><li id="9712" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">([0–9]{5}([\s]+|,)+)*</code>匹配邮政编码，后跟空格或逗号分隔符，零次或多次</li><li id="2a0f" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">^([0–9]{5}([\s]+|,)+)*([0–9]{5})$</code>匹配前面有分隔符分隔的邮政编码序列的单个邮政编码，在整个序列之前或之后没有其他内容</li></ul><p id="07e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们编写代码，通过一些测试来看看它是否有效(我们稍后将回到这些测试):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6302" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们得到的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="69b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷，它的工作！这个正则表达式简洁高效，据我所知，它是正确的。但是，~唉~</p><p id="39fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个表情——<code class="fe nc nd ne lv b">^([0–9]{5}([\s]+|,)+)*([0–9]{5})$</code>就是<strong class="la iu"> <em class="nv">丑。</em> </strong></p><p id="ce98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍一看，完全不清楚这是要做什么。在我看来，这不会通过严格的代码审查。所以，我们来清理一下吧！</p><h1 id="d0f5" class="mf ma it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">例子3:许多邮政编码，但可读</h1><p id="a11e" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">编写真正有效的正则表达式需要与编写任何有效代码相同的最佳实践。这里有一些你可能认识的规则，但是当涉及到正则表达式时，这些规则并不明显:</p><h2 id="0302" class="lz ma it bd mg nw nx dn mk ny nz dp mo lh oa ob mq ll oc od ms lp oe of mu og bi translated">干(不重复)</h2><p id="47ed" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">如果相同的模式在正则表达式中出现多次，将其重构为自己的变量/常量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="6b0f" class="lz ma it bd mg nw nx dn mk ny nz dp mo lh oa ob mq ll oc od ms lp oe of mu og bi translated">为清晰起见，使用中间变量</h2><p id="0b69" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">使用中间变量在技术上是不必要的，并且不会使代码更具功能性或计算效率。然而，它可以通过提高代码的可读性来节省大量最昂贵的资源(时间)。我们的正则表达式如何与下面的改进一起工作已经变得很明显了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2ff3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能看起来没有必要，也很迂腐，但是请记住，许多人并不经常使用正则表达式，所以过分清晰也无妨。</p><h2 id="fae3" class="lz ma it bd mg nw nx dn mk ny nz dp mo lh oa ob mq ll oc od ms lp oe of mu og bi translated">写测试！！</h2><p id="d624" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">所有代码都值得测试，正则表达式也不例外。对于常规代码来说，拥有接近100%的分支覆盖率总是好的。简单来说，每个条件表达式(<em class="nv"> if，else，while，for，… </em> ) <em class="nv"> </em>都应该有一个条件为真的测试，以及一个条件为假的测试。因此，每一个可能的代码“分支”都会被测试。</p><p id="4d69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似的原则也适用于正则表达式，因为它们只是有限状态机的紧凑表示(基本上，是有限的分支/循环算法)。一些将分支视为测试对象的令牌示例:</p><ul class=""><li id="79f5" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">{5}</code>(又名量词<em class="nv">)—编写一个测试用例，其中有5个前面的标记，以及除5个前面的标记之外的其他标记。例如，测试用例<code class="fe nc nd ne lv b">“12345”</code>测试一个5位数的有效zip，而<code class="fe nc nd ne lv b">“123456”</code>测试一个6位数的无效zip</em></li><li id="6a04" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">|</code>(又名an <em class="nv">或</em>表达式)—为or表达式左右两边的标记编写一个测试用例，如下所示。例如，在我们的<code class="fe nc nd ne lv b">ZIP_CODE_LIST</code>表达式中，测试用例<code class="fe nc nd ne lv b">“12345,67890”</code>测试<code class="fe nc nd ne lv b">|</code>前的逗号标记，而<code class="fe nc nd ne lv b">“12345 67890”</code>测试<code class="fe nc nd ne lv b">|</code>前的空格标记</li><li id="972e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nc nd ne lv b">+</code>和<code class="fe nc nd ne lv b">*</code>(又名<em class="nv">一对多</em>o<em class="nv">r</em>z<em class="nv">ero-or-many</em>表达式)——编写测试用例，其中在这些表达式之一之前有零个、一个和多个标记。例如，<code class="fe nc nd ne lv b">“1234567890”</code> <code class="fe nc nd ne lv b">”12345 67890"</code>和<code class="fe nc nd ne lv b">“12345(space)(space)67890”</code> and都用零个、一个和两个分隔两个邮政编码的空格符来测试我们表达式的<code class="fe nc nd ne lv b">[\s]+</code>部分。</li></ul></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="28a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这些例子和策略在您的正则表达式编程冒险中有用。我希望这能作为写作、阅读和复习正则表达式的有用参考！如果你曾经在代码审查中看到一个丑陋的正则表达式(没什么不好意思的，我已经写了很多了)，请随意留下这篇文章的链接。</p></div></div>    
</body>
</html>