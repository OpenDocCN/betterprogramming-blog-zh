<html>
<head>
<title>Time Profiling in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的时间分析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/time-profiling-in-node-js-7f82a95d6a9a?source=collection_archive---------7-----------------------#2019-07-18">https://betterprogramming.pub/time-profiling-in-node-js-7f82a95d6a9a?source=collection_archive---------7-----------------------#2019-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee61" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何跟踪并返回函数的执行次数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a1f6de40424b7a46cdff7ad60d95371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMawjZXo_te0lD_NBMsArQ.png"/></div></div></figure><p id="cc71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在最近的一个项目中，我的任务是为多个函数创建一个报告，并记录它们的执行时间。这似乎是一个微不足道的任务，但是一旦您开始使用V8 profiler进行概要分析，您将会迷失在大量的异步、匿名函数和其他内部方法中。这些需要时间，而你的函数(那些函数的唯一调用方)需要几毫秒。从V8 profiler获得合理的结果可能相当具有挑战性。</p><p id="83c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我想:“好吧，肯定有成吨的<code class="fe lq lr ls lt b">npm</code>包裹能让我免受这种痛苦。”</p><p id="5064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我去谷歌上试着找些东西。我很惊讶，没有什么真正适合我的情况。我发现有几篇文章建议在函数的开头和结尾添加一些日志，然后只计算差值。如果我的票的范围不是数百个函数，这就好了。</p><p id="255a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其他人推荐使用异步挂钩并监听事件的前后。然而，这创建了与V8 profiler相同的树结构，我需要跟踪我的函数的所有子函数，并尝试计算时间。对于一些并行运行的承诺，这变得更加困难。它只适用于异步调用，而我的解决方案需要使用同步和异步函数进行计算。</p><p id="ef69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过长时间的搜索，我找到了一个包，它并没有做我真正需要的事情，但它背后有一个非常有趣的概念。写这篇文章时，我再也找不到它了。如果有人知道，请发给我，我会在这里链接。</p><p id="f13b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该包劫持了模块编译方法，以添加一些额外的代码来做一些跟踪。我的想法是使用这种方法为所需模块中的每个函数添加一个包装器，以跟踪该函数的调用及其完成时间。这将使我可以选择将所有函数包装在我需要跟踪的模块中。所以，我决定牺牲半天的时间来创造一个原型。</p><p id="eca6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有下面的应用程序。我们有<code class="fe lq lr ls lt b">index.js</code>，它需要一个包并从包中调用函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="20a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们看看如何劫持模块编译方法。这很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="7f7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，您可以访问文件的内容和文件名。这使您有机会做一些过滤，只对选定的文件名进行更改。我使用了<code class="fe lq lr ls lt b">minimatch</code>包，只在一些选定的文件上应用profiler，而不是在所有的文件上。过滤掉<code class="fe lq lr ls lt b">node_modules</code>特别有用。</p><p id="7578" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我们来说重要的是内容。如果您尝试将其注销，您将会看到它是一个字符串，包含文件中编写的全部源代码。我们可以更改源代码，然后提供这个更改后的源代码，由原来的编译方法进行编译。</p><p id="e60c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么我们如何做时间分析呢？让我们有一个简单的分析存储工具，它有两个方法:一个用于存储函数的持续时间，另一个用于返回所有数据。</p><pre class="kj kk kl km gt lw lt lx ly aw lz bi"><span id="0930" class="ma mb it lt b gy mc md l me mf">const profile = {};<br/>module.exports.add = (name, duration) =&gt; profile[name] = duration;<br/>module.exports.get = (name) =&gt; profile[name];</span></pre><p id="e2e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，在实际的应用程序中，我们可能会有更好的实现。但是，对于这一块，这应该是好的。</p><p id="a4f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在需要在每次函数结束时用正确的函数名调用<code class="fe lq lr ls lt b">profiler.add</code>。要做到这一点，我们可以创建一个简单的<code class="fe lq lr ls lt b">wrapFunction</code>，将真正的函数包装到<code class="fe lq lr ls lt b">Promise</code>链中，该链将调用带有正确值的分析器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="d4fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我将<code class="fe lq lr ls lt b">moment</code>和<code class="fe lq lr ls lt b">profiler</code>命名为注入。那是因为我们将使用<code class="fe lq lr ls lt b">hijacker</code>中的函数来包装实函数。要运行这段代码，我们需要在所有被劫持的文件中导入<code class="fe lq lr ls lt b">moment</code>和<code class="fe lq lr ls lt b">profiler</code>。我决定将其命名为injected，这样它就不会与已经导入的<code class="fe lq lr ls lt b">moment</code>或<code class="fe lq lr ls lt b">profiler</code>(如果实现中有)冲突。</p><p id="78a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将如何在劫机者中使用这个包装功能？简单。一个重要的方法是创建能够匹配我们文件中函数的<code class="fe lq lr ls lt b">regex</code>。对于这件作品:</p><pre class="kj kk kl km gt lw lt lx ly aw lz bi"><span id="6f74" class="ma mb it lt b gy mc md l me mf">/function ([\w]+)[\s]?\([\w, ]*\)[ ]?{/gm </span></pre><p id="e099" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就够了。但是，对于您的代码，您可能需要使用更复杂的提取器。当在我的项目中实现它时，对我来说更容易改变一些声明，然后用<code class="fe lq lr ls lt b">regex</code>来匹配函数声明中的每一个细微差别。</p><p id="c566" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="e0f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，这是劫持编译方法的扩展实现。首先，我们在所有文件中导入moment和profiler，以便它们可以在我们之前展示的<code class="fe lq lr ls lt b">wrapFunction</code>中使用。</p><p id="a10f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意我用的是<code class="fe lq lr ls lt b">require(‘./profiler’)</code>。如果有一些文件夹结构，您可能需要使用绝对路径。或者，只是创建一些私有的npm包，你不需要关心路径。</p><p id="1dea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我开始遍历找到所有函数声明的<code class="fe lq lr ls lt b">regex</code>的所有匹配。使用<code class="fe lq lr ls lt b">changedContent</code>，我们用我们的<code class="fe lq lr ls lt b">wrapFunction</code>替换每一个函数声明，它被重命名为它所替换的函数。</p><p id="72ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数的真正实现封装在第二个函数中，这个函数叫做<code class="fe lq lr ls lt b">_nameOfTheFunction</code>。假设我们的函数是<code class="fe lq lr ls lt b">hello()</code>，那么它将被替换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="cbda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。该函数被包装，并且应该将其持续时间发送给分析器。现在，当我们在一切完成后调用<code class="fe lq lr ls lt b">index.js</code>中的<code class="fe lq lr ls lt b">profiler.get</code>时，我们应该得到函数运行所花费的时间。</p><p id="97b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得一提的是，我们只能在分析器改变模块编译后包装需要的模块。这就是为什么我们必须在<code class="fe lq lr ls lt b">index.js</code>开始时要求我们的侧写员。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="80ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以检查节点<code class="fe lq lr ls lt b">index.js</code>返回什么:</p><pre class="kj kk kl km gt lw lt lx ly aw lz bi"><span id="106f" class="ma mb it lt b gy mc md l me mf">Error<br/>done<br/>someFunctionToTrack took 1010 ms to finish.</span></pre><p id="db1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我之前写的，这个侧写和劫持者相当简单。我们可以扩展它来存储更复杂的数据，或者只过滤一些被劫持的文件。除了profiler之外，您还可以考虑这种方法的其他一些应用。你可以在评论中写下你对这次劫持的看法。随意看看<a class="ae mg" href="https://repl.it/@PavolKogler/ScaredFluidGigahertz" rel="noopener ugc nofollow" target="_blank">这个应用的完整源代码</a>。</p><p id="978c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读:)干杯！</p></div></div>    
</body>
</html>