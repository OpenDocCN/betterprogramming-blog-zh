<html>
<head>
<title>14 Beneficial Tips to Write Cleaner Code in React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用中编写更简洁代码的14个有益技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/14-beneficial-tips-to-write-cleaner-code-in-react-apps-a167798fa1ba?source=collection_archive---------1-----------------------#2019-08-17">https://betterprogramming.pub/14-beneficial-tips-to-write-cleaner-code-in-react-apps-a167798fa1ba?source=collection_archive---------1-----------------------#2019-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6909" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过书写清洁器成为卫生编码员</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24e4b5fc46b50c4432cf4625c508c8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DUYWHTRPa3WimfpBZcB6w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Kobu Agency在Unsplash上拍摄</p></figure><p id="0696" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在你职业生涯的某个阶段，写干净的代码是必须的，尤其是当你试图获得你的第一份开发工作的时候。</p><p id="c4ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是让你成为一名团队成员的基本要素，在求职面试中，你可以成功，也可以失败。你如何写代码是他们在做出雇佣决定之前想要考虑的事情之一。你的代码应该是人类可以理解的，而不仅仅是机器。</p><p id="d59b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的项目越大，这篇文章中列出的东西就越适用，对于小项目来说<em class="lu">可能</em>就没必要了。用你最好的判断力。</p><p id="b2c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是在React应用中编写更简洁代码的14个有益技巧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e9de" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.摧毁你的道具</h1><p id="46e7" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">析构你的道具是一个很好的方法，有助于使你的编码器更干净，更易维护。这是因为您清楚地定义或声明了某个东西(如组件)正在使用什么。</p><p id="52ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它不强迫开发人员通读组件的实现来找出与组件相关的所有道具。</p><p id="bbcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还让您能够声明默认值。您可能已经多次见过默认值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7e1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript中关于析构的最酷的事情之一是它允许你支持不同的参数变化。</p><p id="cc52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设您有一个<em class="lu"> authenticate </em>函数，该函数使用一个<code class="fe nb nc nd ne b">token</code>作为参数来认证用户。</p><p id="d13a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，由于新的服务器响应结构，您希望它接收<code class="fe nb nc nd ne b">jwt_token</code>。您可以轻松地支持这两个参数，而无需对代码做太多更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0d6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当代码到达<code class="fe nb nc nd ne b">token</code>时，<code class="fe nb nc nd ne b">jwt_token</code>将被求值，因此如果<code class="fe nb nc nd ne b">jwt_token</code>是有效令牌，而<code class="fe nb nc nd ne b">token</code>是<code class="fe nb nc nd ne b">undefined</code>，那么<code class="fe nb nc nd ne b">token</code>的值将成为<code class="fe nb nc nd ne b">jwt_token</code>的值。</p><p id="992c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe nb nc nd ne b">token</code>已经是某个真值(一个真实的令牌)，它将保持自己。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e97" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.文件夹化您的组件</h1><p id="ac80" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们看看下面的目录结构:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="be30" class="nj md it ne b gy nk nl l nm nn">src<br/>  components<br/>    Breadcrumb.js<br/>    CollapsedSeparator.js<br/>    Input<br/>      Input.js<br/>      index.js<br/>      utils.js<br/>      focusManager.js<br/>    Card<br/>      Card.js<br/>      index.js<br/>      CardDivider.js<br/>    Button.js<br/>    Typography.js</span></pre><p id="3361" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">众所周知，面包屑作为其核心功能之一，与某种分隔符相关联。<code class="fe nb nc nd ne b">CollapsedSeparator</code>组件是在<code class="fe nb nc nd ne b">Breadcrumb.js</code>内部导入的，所以我们知道它们都与实现相关。</p><p id="42a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，不了解这些信息的人可能会认为<code class="fe nb nc nd ne b">Breadcrumb</code>和<code class="fe nb nc nd ne b">CollapsedSeparator</code>是两个完全独立的组件，彼此之间没有任何关系。</p><p id="1716" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe nb nc nd ne b">CollapsedSeparator</code>没有提供任何与面包屑相关的明确指示，例如前缀为<em class="lu">的面包屑</em> ( <code class="fe nb nc nd ne b">BreadcrumbCollapsedSeparator.js</code>)，情况尤其如此。</p><p id="e591" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">知道它们是相关的，我们可能会问为什么它们不在像<code class="fe nb nc nd ne b">Input</code>和<code class="fe nb nc nd ne b">Card</code>这样的文件夹中。我们可能会开始做出奇怪的假设，比如:“我想知道是否有人把它放在那里，看看我是否会成为一个好撒玛利亚人，然后把它拿出来……”</p><p id="7402" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干净代码实践的效果应该是相反的——开发人员应该能够阅读您的代码，并很快理解这种情况！</p><p id="cac4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">文件夹化</em>面包屑看起来像这样:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="591c" class="nj md it ne b gy nk nl l nm nn">src<br/>  components<br/>    Breadcrumb<br/>      Breadcrumb.js<br/>      index.js<br/>      CollapsedSeparator.js</span><span id="b329" class="nj md it ne b gy no nl l nm nn">    Input<br/>      Input.js<br/>      index.js<br/>      utils.js<br/>      focusManager.js<br/>    Card<br/>      Card.js<br/>      index.js<br/>      CardDivider.js<br/>    Button.js<br/>    Typography.js </span></pre><p id="aa44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，不管此后创建了多少与面包屑相关的组件，只要它们位于同一个目录中，我们就知道它们与<code class="fe nb nc nd ne b">Breadcrumb</code>相关:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="0968" class="nj md it ne b gy nk nl l nm nn">src<br/>  components<br/>    Breadcrumb<br/>      Breadcrumb.js<br/>      index.js<br/>      CollapsedSeparator.js<br/>      Expander.js<br/>      BreadcrumbText.js<br/>      BreadcrumbHotdog.js<br/>      BreadcrumbFishes.js<br/>      BreadcrumbLeftOvers.js<br/>      BreadcrumbHead.js<br/>      BreadcrumbAddict.js<br/>      BreadcrumbDragon0814.js<br/>      BreadcrumbContext.js</span><span id="62de" class="nj md it ne b gy no nl l nm nn">Input<br/>      Input.js<br/>      index.js<br/>      utils.js<br/>      focusManager.js<br/>    Card<br/>      Card.js<br/>      index.js<br/>      CardDivider.js<br/>    Button.js<br/>    Typography.js</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e48d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用标准命名约定</h1><p id="a9e9" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">使用标准约定命名组件使得其他开发人员更容易阅读您的代码。</p><p id="195f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，<a class="ae np" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶元件</a>通常以<code class="fe nb nc nd ne b">with</code>为前缀，大多数人习惯于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e854" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你决定做一些不同的事情，比如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1246" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是完全有效的JavaScript，这样命名没有任何问题。但是，<code class="fe nb nc nd ne b">use</code>已经有了一个标准的命名约定，它已经和<a class="ae np" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">的React钩子</a>一起出现了。</p><p id="15da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只是在分享代码时要小心，尤其是在寻求帮助时。人们可能已经适应了每天看到约定俗成的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dd83" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.避免布尔陷阱</h1><p id="b519" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在决定输出时，要格外小心原始布尔，它用于确定某些东西的输出值。</p><p id="2ce5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">众所周知，这是一种代码味道，它迫使开发人员查看组件的源代码/实现，以便能够对结果做出准确的假设。</p><p id="c1de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设我们声明了一个排版组件，它采用了这些可用选项:<code class="fe nb nc nd ne b">'h1'</code>、<code class="fe nb nc nd ne b">'h2'</code>、<code class="fe nb nc nd ne b">'h3'</code>、<code class="fe nb nc nd ne b">'h4'</code>、<code class="fe nb nc nd ne b">'h5'</code>、<code class="fe nb nc nd ne b">'h6'</code>、<code class="fe nb nc nd ne b">'title'</code>、<code class="fe nb nc nd ne b">'subheading'</code>。</p><p id="3c1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当它们像这样传入时，你怎么知道它们将如何被应用？</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="795d" class="nj md it ne b gy nk nl l nm nn">const App = () =&gt; (<br/>  &lt;Typography <em class="lu">color</em>="primary" <em class="lu">align</em>="center" <em class="lu">subheading</em> <em class="lu">title</em>&gt;<br/>    Welcome to my bio<br/>  &lt;/Typography&gt;<br/>)</span></pre><p id="a5c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那些对React(或者更恰当地说，JavaScript)更有经验的人可能已经猜到<code class="fe nb nc nd ne b">title</code>将会超越<code class="fe nb nc nd ne b">subheading</code>。订单的工作方式是，最后一个订单会覆盖前一个订单。</p><p id="d26a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但问题是，如果不看源代码，我们将无法真正说出<code class="fe nb nc nd ne b">title</code>或<code class="fe nb nc nd ne b">subheading</code>会应用到什么程度。</p><p id="d16b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bbd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使<code class="fe nb nc nd ne b">title</code>在这种情况下获胜，<code class="fe nb nc nd ne b">text-transform: uppercase</code> CSS行仍然不会被应用。这是因为<code class="fe nb nc nd ne b">subheading</code>在其实现中用<code class="fe nb nc nd ne b">text-transform: none !important;</code>声明了更高的特异性。</p><p id="5378" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们不够小心，调试样式问题可能会变得非常困难，特别是当它不会向控制台显示任何警告/错误时。这可能会使组件的签名复杂化。</p><p id="e4de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里只是一个更干净的替代方案的例子，它重新实现了解决这个问题的<code class="fe nb nc nd ne b">Typography</code>组件:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="7059" class="nj md it ne b gy nk nl l nm nn">const App = () =&gt; <br/>&lt;Typography <em class="lu">variant</em>="title"&gt;Welcome to my bio&lt;/Typography&gt;</span></pre><p id="ebe6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">排版:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="00d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，当我们在<code class="fe nb nc nd ne b">App</code>组件中传递<code class="fe nb nc nd ne b">variant="title"</code>时，我们将确信只有<code class="fe nb nc nd ne b">title</code>会被应用。它省去了我们必须查看源代码来确定结果的麻烦。</p><p id="2eb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你也可以做一个简单的if/else来计算道具:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b9fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这样做的最大好处是，您可以只做这个简单、干净的一行程序，然后就可以收工了:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="bf94" class="nj md it ne b gy nk nl l nm nn">const result = styles[variant]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5483" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.使用粗箭头函数</h1><p id="a8f9" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">使用粗箭头函数是在JavaScript中声明函数的一种更短、更简洁的方式。在这种情况下，将它们命名为<em class="lu">函数表达式</em>更合适。</p><p id="face" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，有些时候你不想在函数表达式上使用粗箭头函数，比如当你需要提升的时候。</p><p id="7959" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在React中，同样的概念也适用。但是，如果不需要提升，使用箭头语法是一个更好的替代方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1359" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在这个例子中，您很难看出它的好处…当您使用简单的一行程序时，arrow函数的魅力大放异彩:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f24e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">俏皮话让每个人都开心！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d354" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.把独立的函数放在你的定制钩子之外</h1><p id="8d7f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我看到一些人在他们的自定义钩子中声明不需要的函数。</p><p id="68f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得定制钩子变得有点臃肿，随着它变得越来越长，越来越难阅读，因为一些开发人员可能会开始质疑钩子是否真的依赖于钩子内部的函数。</p><p id="4f56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有，最好把它移到外面，这样就能清楚地知道什么依赖于钩子，什么不依赖于钩子。</p><p id="3219" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0413" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看这个例子，<code class="fe nb nc nd ne b">removeFalseyImages</code>不需要在定制钩子里面。相反，它可以被提取出来，并且仍然可以在钩子内部使用，不会有任何问题，因为它不与它的状态交互。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="73a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.保持一致</h1><p id="b509" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">保持一致也是JavaScript中普遍推荐的方法。</p><p id="6fb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于React，保持一致:</p><ol class=""><li id="f034" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">进出口。</li><li id="bd97" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">命名组件、挂钩、悬挂夹具、<code class="fe nb nc nd ne b">classNames</code>。</li></ol><p id="fe5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在导入和导出组件时，当我想在两者之间进行导出时，我有时喜欢使用以下语法:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="3008" class="nj md it ne b gy nk nl l nm nn"><em class="lu">import</em> App <em class="lu">from</em> './App'</span><span id="308b" class="nj md it ne b gy no nl l nm nn"><em class="lu">export</em> { <em class="lu">default</em> <em class="lu">as</em> Breadcrumb } <em class="lu">from</em> './Breadcrumb'</span><span id="bc73" class="nj md it ne b gy no nl l nm nn"><em class="lu">export</em> <em class="lu">default</em> App</span></pre><p id="a4dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，我同样喜欢这个语法:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="2da8" class="nj md it ne b gy nk nl l nm nn"><em class="lu">export</em> { <em class="lu">default</em> } <em class="lu">from</em> './App'</span><span id="8645" class="nj md it ne b gy no nl l nm nn"><em class="lu">export</em> { <em class="lu">default</em> <em class="lu">as</em> Breadcrumb } <em class="lu">from</em> './Breadcrumb'</span></pre><p id="3d05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论你喜欢哪一个，只要确保你坚持为每个项目选择一个，这样就简单了。</p><p id="ea5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与命名约定保持一致也是一条非常重要的规则。</p><p id="0b33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你定义一个钩子，比如<code class="fe nb nc nd ne b">useApp</code>，重要的是用前缀<code class="fe nb nc nd ne b">use</code>命名你的下一个钩子，比如<code class="fe nb nc nd ne b">useController</code>。</p><p id="92e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不这样做，你最终会这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9ce9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">导入两个挂钩:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ce90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不太明显的是，<code class="fe nb nc nd ne b">basicController</code>是一个定制的React挂钩，就像<code class="fe nb nc nd ne b">useApp</code>一样，迫使开发人员查看代码内部以找出真相。</p><p id="a196" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们保持一致，我们可以让它变得明显:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="4eb9" class="nj md it ne b gy nk nl l nm nn">const app = useApp()</span><span id="8659" class="nj md it ne b gy no nl l nm nn">const controller = useBasicController()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf09" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.组件化重复元素</h1><p id="8d70" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">组件化只是将重复元素转换成可重用组件的一种花哨说法。</p><p id="8b55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都有在React中编写重复代码的理由，无论是有意还是无意。</p><p id="891d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不管是什么原因，不要让大量的二拍子保持原样是个好主意。</p><p id="8d3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，你可能会养成重复做的习惯，因为你不在乎之前的重复代码。你这样做是如何成为一名团队成员的？</p><p id="674a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将来你会给你的队友增加负担，因为他们可能会因为看到重复的元素而感到沮丧。他们甚至可能会感到困惑，尤其是当他们被安排去做编辑的时候。</p><p id="713b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更糟糕的是，你的队友可能会因为重复的代码而受到批评，而他们甚至没有写代码。当他们这么做的时候，他们只是代表你为团队做了一件事。通过避免将来的重复来回报他们！</p><p id="84aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看下面的代码，并将重复的部分组件化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果有人告诉你将网格尺寸从<code class="fe nb nc nd ne b">xs={12} sm={6}</code>改为<code class="fe nb nc nd ne b">xs={12} sm={4}</code>，这将是一个麻烦，因为你必须改变它们四次。</p><p id="4e47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">组件化的美妙之处在于，您只需做出一个更改，它就会反映到所有的网格中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f12f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最基本的提取层面上，这对于人类来说变得更容易阅读和维护，同时仍然保持正常的实现！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="62e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">9.保持你的组件简单</h1><p id="09ba" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我在制作web应用时学到的不是保持组件简单，而是避免让组件变得复杂。</p><p id="961d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个不必要复杂的组件示例:</p><p id="149f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">ConfirmAvailability.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="babb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该组件原本是一个简单的组件，但是由于逻辑是紧密耦合的，所以它负责多种事情。</p><p id="46bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编写这段代码的时候，React钩子还没有发布，但是仍然有高阶组件和渲染道具。</p><p id="ebe2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们将仅使用其中一种模式来简化这一点，以演示如何使您的组件更简单(而不改变功能):</p><p id="4a09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">SelectTimeZone.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="45e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd ne b">TimeZonePicker.js</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a59d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有了一个更清晰的方法，我们从它的对应表示中提取了逻辑。对这些组件进行单元测试现在变得容易多了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe3e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">10.如果使用状态变得复杂，请使用useReducer</h1><p id="a696" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当跟踪多个状态时，使用<code class="fe nb nc nd ne b">useState</code>开始变得难以管理。</p><p id="2579" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="41f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你把它转换成一个<code class="fe nb nc nd ne b">useReducer</code>，这将变得更容易管理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="49da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以说，当你看的时候，这可能不会比<code class="fe nb nc nd ne b">useState</code>方法更干净。然而，当您使用<code class="fe nb nc nd ne b">useReducer</code>版本实现定制挂钩时，管理起来更容易。</p><p id="f3ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您不必担心在钩子的多个部分跟踪状态更新，因为您将在<code class="fe nb nc nd ne b">reducer</code>中的一个地方定义所有的状态更新。</p><p id="0d4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在还定义了一组官方规则，说明如何在<code class="fe nb nc nd ne b">reducer</code>函数中操作<code class="fe nb nc nd ne b">state.frogs</code>。我们也有一个直接的，更清晰的逻辑分离。</p><p id="5084" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，如果我们继续使用<code class="fe nb nc nd ne b">useState</code>，将不会有预定义的实体。这与<code class="fe nb nc nd ne b">useReducer</code>不同，在<code class="fe nb nc nd ne b">useReducer</code>中，所有的逻辑都放在<code class="fe nb nc nd ne b">reducer</code>中。</p><p id="df3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe nb nc nd ne b">useState</code>版本中，我们必须在钩子内部声明函数来计算状态的下一部分。</p><p id="f9a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是编写逻辑之外的工作。而在<code class="fe nb nc nd ne b">useReducer</code>版本中，我们不必这样做。相反，我们将它们移到了<code class="fe nb nc nd ne b">reducer</code>函数中。</p><p id="a3b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只需要调用动作的类型，这就是它需要担心的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e1d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">11.在枯燥的地方使用函数声明</h1><p id="0118" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">一个很好的例子是<code class="fe nb nc nd ne b">useEffect</code>清理处理器:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="575b" class="nj md it ne b gy nk nl l nm nn">React.useEffect(() =&gt; {<br/>  setMounted(true)</span><span id="a591" class="nj md it ne b gy no nl l nm nn">return () =&gt; {<br/>    setMounted(false)<br/>  }<br/>}, [])</span></pre><p id="be75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为React开发者，我们知道这是做什么的，所以这不是问题。</p><p id="df76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果你假设其他人会阅读你的代码，那么在使用函数声明时，像这样明确地使用代码是一个好主意，因为我们可以根据自己的优势来命名它们。</p><p id="5bcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="0ae1" class="nj md it ne b gy nk nl l nm nn">React.useEffect(() =&gt; {<br/>  setMounted(true)</span><span id="7f75" class="nj md it ne b gy no nl l nm nn">return function cleanup() {<br/>    setMounted(false)<br/>  }<br/>}, [])</span></pre><p id="8f43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这更清楚地描述了当你返回函数时会发生什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2a84" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">12.使用更漂亮的</h1><p id="cbcf" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><a class="ae np" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>帮助你和你的团队保持代码格式的一致性。它节省了时间和精力，并减少了在代码评审中讨论风格的需要。</p><p id="cebb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还强制执行干净的代码实践，您可以根据感觉什么是正确的，什么是不正确的来配置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0e54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">13.在大片段上使用小片段</h1><p id="0ec6" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">小片段:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="bc72" class="nj md it ne b gy nk nl l nm nn">const App = () =&gt; (<br/>  &lt;&gt;<br/>    &lt;FrogsTable /&gt;<br/>    &lt;FrogsGallery /&gt;<br/>  &lt;/&gt;<br/>)</span></pre><p id="ca87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大片段:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="cf03" class="nj md it ne b gy nk nl l nm nn">const App = () =&gt; (<br/>  &lt;React.Fragment&gt;<br/>    &lt;FrogsTable /&gt;<br/>    &lt;FrogsGallery /&gt;<br/>  &lt;/React.Fragment&gt;<br/>)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b32" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">14.把东西整理好</h1><p id="487c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">写代码时我喜欢做的一件事是把事情按顺序排好，比如导入文件时(除了<code class="fe nb nc nd ne b">react</code>导入):</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="a055" class="nj md it ne b gy nk nl l nm nn">import React from 'react'<br/>import { useSelector } from 'react-redux'<br/>import styled from 'styled-components'<br/>import FrogsGallery from './FrogsGallery'<br/>import FrogsTable from './FrogsTable'<br/>import Stations from './Stations'<br/>import * as errorHelpers from '../utils/errorHelpers'<br/>import * as utils from '../utils/'</span></pre><p id="1c44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你们中的一些人可能会想，这甚至没有按照字母顺序排列。这只是这个订购方案的一部分。</p><p id="a5fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢以一种干净的方式订购我的进口产品，按照优先顺序使用这些指南:</p><ol class=""><li id="f92d" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated">反应导入。</li><li id="5dc2" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">库导入(按字母顺序)。</li><li id="c793" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">从项目绝对导入(按字母顺序)。</li><li id="1b26" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated">相对进口(按字母顺序排列)。</li><li id="f76d" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe nb nc nd ne b">import * as</code></li><li id="30d1" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><code class="fe nb nc nd ne b">import './&lt;some file&gt;.&lt;some ext&gt;'</code></li></ol><p id="fdc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而且，我还喜欢用其他方式给变量排序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e7cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遵循指南有助于创建更干净的代码库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6bc5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="e602" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">这就结束了！我希望你发现这是有用的，继续关注更多！</p></div></div>    
</body>
</html>