<html>
<head>
<title>Observables vs. Promises — Which One Should You Use?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可观察与承诺——你应该使用哪一个？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/observables-vs-promises-which-one-should-you-use-c19aef53c680?source=collection_archive---------0-----------------------#2021-10-12">https://betterprogramming.pub/observables-vs-promises-which-one-should-you-use-c19aef53c680?source=collection_archive---------0-----------------------#2021-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="163c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较可观察和承诺的关键特征</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25a6853a9b0e2487687f34505bca0905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCjtaz-rWJ_mS4VdpOV7zQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d285" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript是一种单线程、非阻塞、异步的并发语言。这意味着JavaScript的引擎不会等待语句结束。而是移动到下一条语句。</p><p id="1c75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何依赖异步函数的结果？在早期阶段，回调是唯一可用的方法。然而，他们使得代码难以阅读，这导致了众所周知的回调地狱。</p><p id="ca44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">观察和承诺就是为了精确解决这个问题而诞生的。它们的实现帮助我们以更简洁的方式处理异步代码。它们有不同的API，动机也略有不同。</p><p id="504d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何知道哪一个适合我们？在这里，我们将看到每个实现之间的差异。这将帮助我们为正确的工作选择正确的工具。</p><h1 id="382e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">主要差异</h1><p id="9c30" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如前所述，承诺和可观察有完全不同的方法来处理异步代码。在这里，我们将检查四个最显著的差异。</p><p id="4e18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了跟随示例，您可以使用<a class="ae mr" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> rxjs web dev </a>浏览器web控制台。</p><h2 id="8517" class="ms lv it bd lw mt mu dn ma mv mw dp me lh mx my mg ll mz na mi lp nb nc mk nd bi translated">1.一个值与多个值</h2><p id="822f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">最大的区别在于，承诺一旦兑现就不会改变其价值。它们只能发出(拒绝、解析)一个值。另一方面，可观测量可以产生多种结果。订阅者将收到结果，直到观察者完成或取消订阅。下面的代码向您展示了这些差异:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bad0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得Observables成为监听数据流的绝佳工具。甚至还有一种双向的可观察性:<code class="fe ng nh ni nj b">Subjects</code>。一个完美的用例是<code class="fe ng nh ni nj b">web sockets</code>。<code class="fe ng nh ni nj b">RxJS</code>库在web套接字上附带了一个薄薄的包装。</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="1c9b" class="ms lv it nj b gy no np l nq nr">import { webSocket } from "rxjs/webSocket";</span></pre><h2 id="8793" class="ms lv it bd lw mt mu dn ma mv mw dp me lh mx my mg ll mz na mi lp nb nc mk nd bi translated">2.可观察订阅是可取消的；承诺不是</h2><p id="faeb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">一旦你开始承诺，你就不能取消它。传递给<code class="fe ng nh ni nj b">Promise</code>构造器的<code class="fe ng nh ni nj b">callback</code>将负责解决或拒绝承诺。订户是被动的；一旦被激发，它只能对结果做出反应。</p><p id="f114" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可观察的不那么被动。一旦创建了订阅者，它可以随时退出观察器。这使得它们在我们对反应不再感兴趣的情况下很有用。例如，当用户离开页面时。</p><p id="d184" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多方法可以取消/完成订户。让我们来看看最常见的三种:</p><ul class=""><li id="8bd7" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">unsubscribe</code>:手动取消观察对象的订阅</li><li id="19aa" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">take</code>:取X个元素并取消订阅的运算符</li><li id="b355" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">takeUntil</code>:一直取值直到被传递的可观测值发出任何值的算子。</li></ul><p id="2ed3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看上述每一项的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="834f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可观测的算子是必不可少的。它们让我们以声明的方式组合复杂的异步操作。在上面的例子中，很明显<code class="fe ng nh ni nj b">take</code>和<code class="fe ng nh ni nj b">takeUntil</code>操作符是多么的重要和易读。</p><p id="5d43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时候，它们并不是微不足道的。为了更好地理解它们，有必要看看它们的大理石图形表示。您可以在此找到所有运营商的陈述<a class="ae mr" href="https://rxmarbles.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="48e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们检查一下<code class="fe ng nh ni nj b">take</code>操作员表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/cc685101604fa588100769e9de82e36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvTSGsxtU6CyWHjksKWFHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从rxmarbles.com俘获</p></figure><p id="85fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有一个运算符流的<code class="fe ng nh ni nj b">input</code>和<code class="fe ng nh ni nj b">output</code>的表示。</p><h2 id="b81b" class="ms lv it bd lw mt mu dn ma mv mw dp me lh mx my mg ll mz na mi lp nb nc mk nd bi translated">3.渴望与懒惰的执行</h2><p id="3079" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">观察和承诺的执行方式是不同的。承诺被热切地执行，而可观察的东西被懒散地执行。那是什么意思？</p><p id="552e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Eagar: </strong>承诺回调将在构造函数级别立即执行。</p><p id="45a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">懒惰:</strong>生产者功能只有在为可观察对象创建了订阅后才会触发。否则，它将处于闲置状态。</p><p id="3a3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看两者的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6331" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们可以看到记录的语句<code class="fe ng nh ni nj b">1. Callback execution</code>和<code class="fe ng nh ni nj b">1. Execution of observable body</code>是如何以不同的顺序出现的。</p><h2 id="00db" class="ms lv it bd lw mt mu dn ma mv mw dp me lh mx my mg ll mz na mi lp nb nc mk nd bi translated">4.运行时执行</h2><p id="d6af" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">ES承诺，一旦解决，将在微任务队列中对回调进行排队。这意味着它们将在当前宏任务完成后执行。</p><p id="25b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3531" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上行为你是改变不了的。</p><p id="4fcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了Observables，您可以使用调度器来微调运行时执行。计划程序控制订阅开始的时间和通知传递的时间。</p><ul class=""><li id="82d4" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">null</code>:默认情况下，通知是同步递归传递的。</li><li id="8aaf" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">queueScheduler</code>:当前事件帧中队列上的调度。</li><li id="185e" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">asapScheduler</code>:微任务队列上的调度。与承诺使用的队列相同。</li><li id="c19d" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">asyncScheduler</code>:类似于使用<code class="fe ng nh ni nj b">setInterval</code>调度任务。因此，它将被安排在宏任务队列中。</li><li id="de9d" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated"><code class="fe ng nh ni nj b">animationFrameScheduler</code>:依赖<code class="fe ng nh ni nj b">requestAnimationFrame</code> API。</li></ul><p id="5c1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个<code class="fe ng nh ni nj b">asapScheduler</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="919b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">互用性</h1><p id="d815" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">鉴于他们之间有相当多的差异，他们可以一起工作吗？我们必须在他们中选择一个吗？绝对不行。</p><p id="a35d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以从承诺中创造出可观的结果，也可以将可观的结果转化为承诺。然而，在后一种情况下，由于承诺只接受一个值，您必须选择是将第一个值还是最后一个值转储到承诺中。<code class="fe ng nh ni nj b">rxjs</code>库为那个特定的用例提供了一个<code class="fe ng nh ni nj b">firstValueFrom</code>和<code class="fe ng nh ni nj b">lastValueFrom</code>。</p><p id="c756" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="2ae8" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">最后的想法</h1><p id="634c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们已经看到了两者之间的差异。何时使用其中一个是偏好和用例的问题。两者都擅长解决JavaScript中的异步范式。</p><p id="cc90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要知道，可观是有代价的。浏览器本身不支持它们。最常用的库实现是RxJS。其束尺寸可达<code class="fe ng nh ni nj b">17.4kb</code>。因为它可以摇树，你肯定会看到比这少的东西。这不是一个很大的捆绑包，但是承诺本身得到了支持。这意味着你将为自己省下一笔可观的税费。</p><p id="2e76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。</p><p id="2ec6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不是中等会员？支持我<a class="ae mr" href="http://dioxmio.medium.com/membership" rel="noopener">成为这里的一员</a>。</p><h1 id="e9f0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">有关系的</h1><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-write-readable-code-bf1fa656673e"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">如何写出可读的代码？</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">提高代码可读性的6个技巧</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-es2021-a-look-at-the-new-features-7d5770288648"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">JavaScript ES2021:看看新特性</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">新ES12规格概述</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>