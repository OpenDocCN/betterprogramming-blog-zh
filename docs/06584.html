<html>
<head>
<title>Ktor in Server-Side Development: The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端开发中的Ktor:基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ktor-in-server-side-development-the-basics-81ce4bbba878?source=collection_archive---------4-----------------------#2020-10-15">https://betterprogramming.pub/ktor-in-server-side-development-the-basics-81ce4bbba878?source=collection_archive---------4-----------------------#2020-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">服务器端Kotlin入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1db0b1f1c85fa860f85da24e4ca7f4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgm57R57yMdlVzmC4ZYVsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="17a9" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">从文章中摘录</h1><p id="f1b6" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">在本文中，您将学习如何使用Ktor实现具有基本路由的端点。之后，我们将在本地托管并测试它。然后，我们将使用Kotlin独有的特性(如扩展)优化代码，使其可扩展到大型项目。您还可以找到GitHub资源库的链接，并在本文末尾提供一个示例。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="3486" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">Ktor是什么？</h1><p id="b55f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">据其官方网站称，“Ktor是一个开源框架，使用强大的Kotlin编程语言在互联系统中构建异步服务器和客户端。”Ktor使用协程来执行异步操作，由<a class="ae mt" href="https://www.jetbrains.com/" rel="noopener ugc nofollow" target="_blank"> JetBrains </a>制造。</p><p id="7644" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们可以使用Ktor做的一件有趣的事情是使用Kotlin编写web服务。有兴趣的话，Ktor也有安卓专用神器；你可以从这篇<a class="ae mt" href="https://medium.com/better-programming/how-to-use-ktor-in-your-android-app-a99f50cc9444" rel="noopener">文章</a>中了解一下。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="c63c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">项目设置</h1><p id="681f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">要开始使用，需要安装并打开<a class="ae mt" href="https://www.jetbrains.com/idea/download/#section=windows" rel="noopener ugc nofollow" target="_blank">Intellij IDEA</a>；我用的是社区版。安装完成后，打开IDEA并点击Create New Project选项。然后你会看到下面的弹出窗口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/232ef4899f8f96158ef1194e276be83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTZcYkoHMwpthxOpAkIA-g.png"/></div></div></figure><p id="250f" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">首先，在左侧面板中选择Ktor选项；如果它没有显示在您的工具中，请单击“取消”返回。这将带您回到主屏幕，然后您可以如下所示进行导航:</p><p id="1552" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated"><strong class="lz iu">配置&gt;插件&gt;搜索Ktor &gt;安装</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/7b7e245292ca242d98f8246eba620a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qEUTOF4zZk8Eg7eWJ4CCCA.gif"/></div></div></figure><p id="13b3" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">一旦你完成了Ktor插件的安装并点击创建新项目，你将会看到之前的弹出窗口。让我们看看弹出窗口中的一些选项:</p><ul class=""><li id="06fc" class="nb nc it lz b ma mu md mv mg nd mk ne mo nf ms ng nh ni nj bi translated"><strong class="lz iu">项目:</strong>通过这个选项，我们可以选择Gradle、Maven或GradleKotlinDSL项目。现在，我们将使用默认选项(Gradle)。</li><li id="b0e4" class="nb nc it lz b ma nk md nl mg nm mk nn mo no ms ng nh ni nj bi translated"><strong class="lz iu"> Ktor版本:</strong>选择最新的版本，在我写这篇博客的时候是1.4.1。</li><li id="b849" class="nb nc it lz b ma nk md nl mg nm mk nn mo no ms ng nh ni nj bi translated"><strong class="lz iu">服务器&amp;客户端标签:</strong>这是我们可以导入某些功能的地方，比如认证类型、序列化库，比如Jackson、Gson等。这些是一些高级特性，所以我们将它们保留为默认值。</li></ul><p id="3e5b" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">然后单击弹出窗口底部的“下一步”按钮，这将带您进入下一步。在这里，我们必须输入我们的GroupId、ArtifactId和版本号。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/363998023faa541347d6ae919c2df1bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYg0NBsxOgZSXuBdFyYaFg.png"/></div></div></figure><p id="eaea" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">单击“下一步”按钮，将带您进入下一步，我们可以在本地磁盘中输入项目和位置。完成后，单击Finish，Intellij将开始构建项目。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="ba50" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">探索项目</h1><p id="a4b3" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">一旦项目成功同步，我们就可以开始使用Ktor构建Rest端点了。在开始编码之前，让我们看一下项目结构。</p><p id="8126" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们需要注意的第一件事是包含项目全部配置的<code class="fe np nq nr ns b">build.gradle</code>文件。在这里你可以看到某些已经集成的插件、源集和Ktor依赖项；这是因为我们一开始用的是Ktor插件。</p><p id="7652" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">然后我们可以看到项目下的两个主目录，<code class="fe np nq nr ns b">resources[main]</code>和<code class="fe np nq nr ns b">src[main]</code>。<code class="fe np nq nr ns b">src[main]</code>是我们主要用来编写Kotlin代码的目录。</p><p id="0137" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">在<code class="fe np nq nr ns b">src</code>目录中，你可以看到一个<code class="fe np nq nr ns b">Application</code> Kotlin文件，其中我们有一个关于Ktor <code class="fe np nq nr ns b">Application</code>类的模块扩展函数。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b39a" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">Ktor应用程序是一个监听一个或多个端口并包含已安装功能的模块的程序；在这种情况下，是<a class="ae mt" href="https://netty.io/" rel="noopener ugc nofollow" target="_blank"> Netty </a>。</p><p id="be5e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">接下来，为了理解本地的工作方式，请转到<code class="fe np nq nr ns b">resources[main]</code>目录中的配置文件，在其中您可以找到我们要连接的端口和要部署的模块(除了<code class="fe np nq nr ns b">src[main]</code>中的Ktor应用程序模块之外，什么也不是)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="6b81" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">开始编码</h1><p id="ad76" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">在应用程序模块中，我们需要实现身份验证、登录、安全性等功能，定义路由，就像我们在本例中要做的那样，以简化端点处理等。</p><p id="e75e" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">我们需要开始使用routing lambda函数向模块函数内部的服务添加路由，以定义端点的行为。路由只是简化请求处理的一个特性。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ktor路由声明</p></figure><h2 id="4f5b" class="nv lg it bd lh nw nx dn ll ny nz dp lp mg oa ob lr mk oc od lt mo oe of lv og bi translated">获取请求</h2><p id="ace0" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">为了简单起见，我们将使用lambda的<code class="fe np nq nr ns b">get</code>函数在根路径添加一条路由。在lambda块中作出回应，我们可以使用Ktor <code class="fe np nq nr ns b">ApplicationCall</code>。</p><p id="28a5" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">在<code class="fe np nq nr ns b">get</code>函数内部，我们将通过调用call对象上的<code class="fe np nq nr ns b">respondText</code> <em class="oh"> </em>函数，用一个简单的文本进行响应。我们需要传递消息和内容类型，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ktor获取请求</p></figure><p id="5cb9" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">要测试这个实现，点击main函数旁边的run按钮，然后您会在Intellij底部面板的run选项卡中看到下面的日志。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ec1aecc504c8eb58c5c4d4bffcb8f4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHRUCe1g8z4O-LjILTVmqg.png"/></div></div></figure><p id="6acc" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">现在，点击网址(<a class="ae mt" href="http://0.0.0.0:8080" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:8080 </a>)或者在浏览器中输入localhost:8080；它应该显示“来自Ktor”的消息。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/494efa78fac9cc9ada2401d2214f38d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*cspTFVEXa_A5iJrJBEmArw.png"/></div></figure><h2 id="04ba" class="nv lg it bd lh nw nx dn ll ny nz dp lp mg oa ob lr mk oc od lt mo oe of lv og bi translated">发布请求</h2><p id="7491" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">现在我们已经成功地实现了get request，让我们构建一个简单的<code class="fe np nq nr ns b">post</code>请求，在这个请求中，我们将读取请求体，并用请求体和“received data”字符串进行响应。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ktor发布请求</p></figure><p id="4d20" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">这里我们必须在Kotr <code class="fe np nq nr ns b">ApplicationCall</code>对象上使用带有期望类型的<code class="fe np nq nr ns b">receive function</code>。我们必须将响应与“已接收数据”标签连接起来，并使用<em class="oh"/><code class="fe np nq nr ns b">respondText</code><em class="oh"/>函数<em class="oh">将其发送回去。</em></p><p id="3465" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">要对此进行测试，请单击main函数旁边的run按钮。成功执行后，打开IDE底部面板中的“终端”选项卡，并运行以下命令:</p><pre class="kj kk kl km gt ok ns ol om aw on bi"><span id="700a" class="nv lg it ns b gy oo op l oq or">curl -X POST -d “sample data” localhost:8080</span></pre><p id="2d94" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">如果您遇到任何问题，请尝试将URL从localhost:8080更改为http://<a class="ae mt" href="http://0.0.0.0:8080/" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:8080/</a>。这显示了下面一行的输出。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="9d9c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">创建一个端点</h1><p id="30c1" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">现在我们已经在根级别完成了基本的<code class="fe np nq nr ns b">get</code>和<code class="fe np nq nr ns b">post</code>请求，让我们用名称颜色创建一个端点，然后作为响应，我们将发送一个颜色数组。</p><p id="728b" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">第一步是创建颜色数组作为JSON对象。看一看:</p><pre class="kj kk kl km gt ok ns ol om aw on bi"><span id="66f5" class="nv lg it ns b gy oo op l oq or">private val <em class="oh">colors </em>= "{\"Colors\": [\"Red\",\"Blue\",\"Green\"]}"</span></pre><p id="1fdc" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">然后我们需要像以前一样创建一个<code class="fe np nq nr ns b">get</code>函数，并将端点称为<code class="fe np nq nr ns b">colors</code>。在里面我们得到了一个颜色数组的响应。看一看:</p><pre class="kj kk kl km gt ok ns ol om aw on bi"><span id="3b2b" class="nv lg it ns b gy oo op l oq or">private val <em class="oh">colors </em>= "{\"Colors\": [\"Red\",\"Blue\",\"Green\"]}"<br/>get("/colors")<strong class="ns iu">{<br/>    </strong><em class="oh">call</em>.<em class="oh">respondText</em>(<em class="oh">colors</em>)<br/><strong class="ns iu">}</strong></span></pre><p id="9d79" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">为了检查输出，我们需要运行应用程序并将“/colors”添加到浏览器的现有URL中。看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/6f39fa500a26510069ce91302f3cab64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9NNqmac4wymsK3-0DF81g.png"/></div></div></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="fac8" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">代码优化</h1><p id="177f" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">如果看到模块功能，路由块会增长；最终，我们将在端点中添加更多的逻辑，这将导致无法维护的巨大路由块。</p><p id="7ef9" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">克服这个问题的一个方法是利用Kotlin中扩展的功能来封装逻辑部分。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">路由扩展</p></figure><p id="716d" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">现在可以在路由块中使用这些扩展功能。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在路由块中使用扩展名</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="1513" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">GitHub项目</h1><p id="56d9" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">您可以随意使用GitHub资源库中我们在这里探索的所有功能。</p><div class="ot ou gp gr ov ow"><a href="https://github.com/SG-K/KtorServerSideIntro" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">SG-K/KtorServerSideIntro</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">在GitHub上创建一个帐户，为SG-K/KtorServerSideIntro的开发做出贡献。</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="7847" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">奖金</h1><p id="2891" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">要了解更多关于Kotlin的信息，请阅读Kotlin高级编程系列:</p><ul class=""><li id="3dd9" class="nb nc it lz b ma mu md mv mg nd mk ne mo nf ms ng nh ni nj bi translated"><a class="ae mt" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“使用Kotlin进行高级编程—第二部分</a>”</li></ul><p id="4238" class="pw-post-body-paragraph lx ly it lz b ma mu ju mc md mv jx mf mg mw mi mj mk mx mm mn mo my mq mr ms im bi translated">就这些了，希望你能学到一些有用的东西，感谢阅读。</p></div></div>    
</body>
</html>