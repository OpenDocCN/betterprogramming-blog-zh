# Swift 中的自动引用计数研究

> 原文：<https://betterprogramming.pub/a-look-into-automatic-reference-counting-b17e9539d34f>

## 高效管理应用的内存使用

![](img/33243f745e50f433d9e8d9e7e89cbfcf.png)

照片由[托马什·斯坦尼斯拉夫斯克](https://unsplash.com/@tomstanislavsky?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

自动引用计数(ARC)是一种内存管理解决方案，它确保为您创建的不同对象和函数正确分配和释放内存，以便运行代码的设备不会耗尽内存。

为了更好地理解 ARC，让我们通过理解我们作为程序员所做的事情来给这个讨论一个框架。

我们在编写代码时定义变量和函数。这些变量和函数需要存储在设备的内存中，以便我们可以使用它们，一旦我们不再需要它们，它们就会从内存中删除，或者换句话说，它们需要有一个生命周期。当我们希望它们存在时，它们就会存在。然后，它们执行自己的任务，当不再被使用时就死去，这样它们占用的内存就可以被释放出来，让新的变量和函数出现。

创作部分很简单。你通常`init`这些函数和变量，但是你怎么决定它们应该什么时候死呢？

有两种方法可以指定这些变量和函数应该何时终止:

1.  作为一名程序员，你说他们什么时候到了生命的尽头，什么时候需要死去。

2.你让某人为你管理它。

第一个是使用一个叫做*引用计数*的进程完成的，第二个叫做*垃圾收集。*

我们将重点关注本文中的第一个问题。

# 什么是引用计数？

引用计数是维护对特定实例的强引用计数的过程(稍后将详细介绍，但现在只需记住它们是强引用)。

因此，无论何时创建一个实例，都会得到一个引用计数为 1 的实例，这基本上意味着指向该实例的变量在说，“嘿！我是这个实例的所有者，在我不再允许它被释放之前，它需要保持活动状态”

所以当你开始让不同的强变量指向它时，它的引用计数就增加 1。当引用被设置为`nil`时，该引用类型的实例的引用计数减 1。

**注意:**一旦引用计数变为 0，就调用该特定实例的`deinit`。

您可以使用`CFGetRetainCount`功能检查变量的引用计数。

**注意:**引用计数只是为了管理引用类型(如类和闭包)的内存。

# 背景:手工-保留-发布管理

在上一节中，我们了解到有一个计数是根据对特定实例的引用数量来维护的。

现在，第一个观察是，在我们的日常生活中，无论何时我们创建一个实例(即，在它的`init`中)或当它被设置为`nil`时减少它，我们都不会编写代码来增加任何计数。因此，我们应该得出结论，系统必须为我们管理所有这一切。

虽然所有这些现在都过时了，但它会帮助你理解为什么事情会这样。你不必完全记住下面的部分，但一定要浏览一下。

无论如何，让我们回到我们的问题:这是如何发生的？

要回答这个问题，我们需要回到 Objective-C 是 iOS/macOS 代码库的唯一编程语言的时候。在 ARC 之前，曾经有一个叫*手动引用计数的东西，*程序员要自己写“*引用计数*”递增/递减代码。

他们使用以下命令实现了这一点:

*   `alloc init`、`new`、`copy`:创建一个引用计数为 1 的新对象
*   `retain`:引用计数加 1，返回对象本身
*   `release`:将引用计数减 1 并返回 nil
*   `autorelease`:当该实例的池将被清空时，将该实例标记为自动释放

在手动引用计数管理世界中，作为一名程序员，你有责任确保在你创建的每个类中实现了一个`dealloc`方法(对于所有 Swift 开发人员，想象一下为你创建的每个类编写一个`deinit`函数)。

然后，您必须确保您在该类的每个实例变量上调用了`release`，以确保那些变量的引用计数被减少——否则，那些变量占用的内存将永远不会被释放，并且您会以僵尸对象结束(也称为*内存泄漏*)。

您还必须处理其他样板代码。例如:

*   您必须为每个必须更改的变量实现 setters。在 setter 中，您必须`release`先前的值并设置这个新变量。
*   如果一个特定的变量要在函数本身的范围内使用，那么你必须在函数结束之前`release`它——否则，就会有内存泄漏(除非变量被标记为`autorelease`，并且你的方法在一个`autoreleasepool`内)。

> 为了确保事情顺利运行，程序员必须遵守一套规则，以确保你的代码在内存方面是高性能的。

# 手工发放保留管理规则

## 你拥有你创造的对象

如果您在任何类或实例上调用`alloc init`、`new`或`copy`，您将获得一个引用计数为 1 的新实例，现在您拥有该特定实例的所有权。

基本上，这是 Obj-C 世界中使用的惯例——即使你创建了一个`init`函数，你也必须确保该特定类实例中的所有变量都被正确地`init`或`retain`处理。

你必须假设任何不遵守这个命名约定的函数都应该是一个`autorelease`对象；否则，它可以随时`release`它，这可能是不安全的。

因此，如果你把它放在一个`autoreleasepool`中是可以的，或者如果你想在任何地方使用它，你可以使用下面提到的规则 2 来获得它的所有权，这样即使原始类在对象上调用`release`，你也可以继续安全地使用它。

## **你可以通过使用** `**'retain'**`获得对象的所有权

假设您想在`ClassB`的实例中使用一个类`ClassA`中的变量。理想情况下，您可以对变量调用`retain`来获得该对象的所有权。

## **你必须拥有** `**release'**` **对象**

你应该只在两种类型的对象上调用`release`。

*   您已经使用`alloc init`、`copy`或`new`创建了一个实例
*   你实际上已经在一个特定的引用上调用了`retain`

## **你不应该在你不拥有的对象上调用'** `**release’**`

**这种情况基本上是说，你不应该对从不以`alloc init`、`copy`或`new`开头的函数中检索到的对象调用`release`(也就是说，这些函数完全遵循规则 1 中前面提到的约定)，唯一的原因是你不拥有它们。如果你想管理他们的所有权，你必须给他们打电话`retain`。**

**这里还要注意的一点是，如果你正在编写一个返回一个对象的函数，而不想转移该对象的所有权，你需要`alloc init`该对象并将其标记为`autorelease.`**

# **自动释放和`@autoreleasepool`**

**正如我前面提到的，在进行手动-保留-释放管理时，有一些惯例需要遵循，比如确保在对象上调用`release`或者`alloc init`或者`retain`。或者通过确保您从不以`alloc init`开头的方法返回的计算对象，等等。是自动释放的，并且您不会对它们调用`retain`,因为调用者不会是返回实例的所有者。**

****注意:**`autorelease`的基本定义是，你正在标记一个你正在创建但不会释放的对象(这违背了我们最初的规则)。你是在把责任或者把那个对象交给别人。**

**`@autoreleasepool`是一个块，它在完成时将`release`所有创建时带有`autorelease`的对象。不会释放在池外创建的自动释放对象。**

# **人工保留-释放管理的缺点**

**从上面的解释中可以看出，以这种方式编写的代码充满了程序员必须记住的约定，如果他们忘记了不正确地使用`retain`、`release`或`autorelease`对象，他们会有两种结局:**

1.  **内存泄漏——当你调用了`retain`或者创建了一个对象却忘了调用`release`时就会发生这种情况。它们会一直存在，直到你真正关闭应用程序。**
2.  **悬空指针——如果你拥有不属于你的对象，你最终会创建悬空指针，当被其他真正的所有者访问时，会导致访问失败— `EXC_BAD_ACCESS`。**

# **自动引用计数**

**因此，我们现在知道，整个计数递增/递减过程是一个手动过程，如果管理不当，会在内存方面产生严重后果，尽管您可能已经注意到，所有这些都是在每个程序员都必须遵守的一组规则内完成的。**

**因此，在一个晴朗的日子里，我们决定将编写`retain`、`release`和`autorelease`的过程自动化，并在代码编译期间完成。**

****在编译期间**，编译器会根据几个“关键字”在适当的地方进行这些调用，这些关键字会标识如何引用该引用类型。**

> **因此，如果有人问你 ARC 是运行时进程还是编译时进程，你应该明确地回答它是两者的混合。引用计数“关键字”是在编译时放入的，但实际的计数和内存分配/取消分配是在运行时进行的**

# **参考类型**

**用最基本的术语来说，引用类型(例如类和闭包)告诉编译器需要如何管理变量的引用计数。Swift 中有三种参考类型:**

1.  **`strong`:每当一个新的引用指向它时，引用计数就加 1——例如，当你添加一个新的变量指向一个引用时，编译器就添加一个`retain`调用**
2.  **`weak`:不增加参考计数**
3.  **`unowned`:不增加参考计数**

**因此，当您用这些标识符指定变量时，编译器在将代码实际编译成机器码之前，会在代码中放入所需的`retain`和`release`调用。**

# **`'strong'`**

**关键字`strong`声明每当一个强变量引用一个引用类型，该实例的引用计数就增加 1。**

> **当没有指定任何内容时，这是任何变量的默认引用类型。**

# **参考周期**

**当两个强变量指向对方时，就会出现参考循环。这会导致这两个变量的实例保持活动状态，即使它们在理想情况下不应该保持活动状态。让我们举个例子:**

**在上面的例子中，你可以看到在第 20 行之后，`a`和`b`都应该被取消分配，因为我们已经使它们都成为了`nil`，但是彼此之间的内部引用创建了一个引用循环，禁止系统调用它们的`deinit`方法，因此造成了内存泄漏。**

**现在，有时对象的引用计数永远不会达到零；在启用 ARC 的项目中，唯一可能发生这种情况的情况是存在引用周期。**

**我已经展示了一种解决引用循环的方法(第 21-24 行)。解决引用循环的另一种方法是确保你可以引用一个变量而不增加它的引用计数，这就引出了我们的其他关键词:`weak`和`unowned`。**

# **`'weak’`和`'unonwned'`**

**将其中一个变量设为`weak`(或`unowned`)变量可以解决参考循环问题。**

**这是因为`weak`和`unowned`都没有增加它们所指向的对象的引用计数，所以问题自然出现了:为什么我需要两个关键字？**

**使用`weak`和`unowned`有一个微妙的区别，即`weak`变量用于指向在持有对象/原始引用的生命周期内不需要可用的对象，而`unowned`变量用于指向在持有对象/原始引用的整个生命周期内必须可用的变量。**

****注意:**`weak`变量总是可选的，而`unowned`变量可以是可选的(+隐式展开可选)或者非可选的。**

**就实现而言，这意味着当一个`weak`变量的引用变成`nil`时，`weak`变量本身也变为零。**

**而在`unowned`的情况下，如果引用变成`nil`，那么`unowned`变量仍然可用，但是指向一个`nil`内存地址，这可能会导致崩溃或不可预测的行为等问题。**

**`unowned`有两种口味:**

1.  **`unonwed(safe)`:当你试图使用引用一个已释放变量的`unonwed`变量时，这确实会使程序崩溃**
2.  **`unonwed(unsafe)`:当引用一个取消分配的变量时，这不会可靠地使应用崩溃，并且可能导致不可预知的行为。我认为这种情况仍然存在于 Swift 中的原因可能是因为 LLVM 中仍然存在`__unsafe_unretained`所有权。这基本上意味着你需要手动管理这些变量的内存，因为它们不是由编译器管理的。**

**我将在这里澄清几个问题，让我们更好地理解`weak`和`unowned`:**

## ****`**'weak'**`**和** `**'unowned'**` **选装件有什么区别？******

****答案并不简单。可选性基本上意味着变量可以是`nil`。但是在`weak`和`unowned`可选变量的情况下，有一个微妙的区别，如下面的代码片段所示。****

****现在，如果变量`b`是`weak`而不是`unowned`，那么任何一个`print`语句都不会崩溃。****

****这给我们带来了一个解释，即`weak`选项可以是`nil`，访问它们不会引起任何问题。另一方面，`unowned` optionals 也可以是`nil`，但是不能指向变成`nil`的引用。****

## ******你什么时候会用** `**'unowned'**` **胜过** `**weak’**` **？******

*   ****当你希望一个变量不是可选的，但又不想要一个`retain`循环时****
*   ****您希望确保持有者和被持有者的寿命相互匹配。例如:****

****在上面的例子中，我们将`person`设为变量`unonwed`，因为`ID`需要与`Person`一起存在。如果一个`Person`实例存在，那么它的`ID`一定存在，但是当`Person`实例被解除分配后，对应于那个`Person`的`ID`也应该不存在了。****

****如果当`Person`对象被释放时，你试图访问`ID`的`Person`，你的程序会崩溃。您可以在开发阶段推断出这种情况正在发生，并且需要修复。****

## ******你什么时候会使用可选的** `**'unowned’**` **变量？******

****当您想要避免`retain`循环，并且想要确保当它所指向的引用被移除时，变量被正确地设置为`nil`，以便两个实例的生命周期相互匹配。****

## ******一个隐式展开的** `**'weak'**` **可选变量和一个可选的** `**'unowned'**` **变量有什么区别，如果两个变量都为‘nil’时会崩溃？******

****这里又有一个微妙的区别。非可选的在被访问时总是会崩溃，但是可选的`unowned`只有当它的引用变成`nil`时才会崩溃，而不是当它本身被设置为`nil`时。****

# ****闭包中的参考循环****

****Swift 中的闭包也是引用类型。因此，您在一个闭包内使用的任何引用类型变量都被那个特定的闭包强引用，如果那些变量也引用这个闭包，这可能会导致一个引用循环。****

****避免闭包中引用循环的答案是一个捕获列表。在这些捕获列表中，您指定将要使用的变量为`strong`、`weak`或`unowned`，这样编译器就可以正确地管理它们。****

****使用引用类型的相同规则也适用于这里。理想情况下，你应该尽量避免`strong`，因为那会产生一个参考循环。基于被引用变量的生命周期，你应该使用`weak`或`unowned`。捕获列表示例:****

****这里有另一个例子来更好地理解它。如果需要，将这段代码复制并粘贴到操场上，并应用断点来运行代码以更好地理解它:****

****这里值得一提的是，捕获列表对于值类型的作用略有不同(尽管本文主要是关于引用类型)。****

****如果在闭包中捕获一个值类型，就会创建该变量的新副本，对原始值的任何更改都不会反映在这个新副本中。但是如果您没有捕获原始变量，但仍然在闭包中使用它(即，没有在捕获列表中指定它)，那么编译器实际上会持有对它的引用。对原始值的任何更改也会反映在闭包内的变量中。****

# ****你如何识别参考周期？****

****假设我们现在知道了引用循环以及它们如何影响每个值类型和引用类型，那么当我们查看一些代码时，我们必须知道如何找出引用循环。****

****这个技巧——虽然令人困惑——实际上非常简单。绘制链接！****

****让我们尝试几个例子来更好地理解它:****

1.  ****简单的参考循环****

****2.让我们看一个包含闭包的引用类型的例子:****

****3.值类型中的引用循环🤔****

****更多信息[请阅读此处](https://neelbakshi.medium.com/classes-vs-structs-basics-and-memory-management-4707714d82e7)****

****4.一个更真实的例子——实际上没有**参考循环！******

****在上述所有例子中，解决引用循环的答案是，如果变量是引用类型，就将它们捕获为`weak`或`unonwed`，如果它们是值类型，就捕获变量本身。****

# ****使用`'weak’` 和`'unowned'`的性能影响****

****除了仅仅是语义上的原因之外，是否还有其他原因可以解释为什么应该使用其中一个而不是另一个？当您知道`unowned`变量的生命周期≤原始参考的生命周期时，使用`unowned`会带来一些微妙的性能优势。原因是管理`weak`引用的方式。****

****`weak`引用实际上是一个叫做 ***归零弱引用*** *的东西。*这意味着运行时使用一个表跟踪你对一个引用(原始引用)的所有弱引用。当原始引用变成`nil`时，所有这些其他的`weak`引用就在取消分配它之前变成`nil`。这样，当你试图调用一次`weak` 引用上的东西时，原始引用将被设置为`nil`。它将是安全的，并且根据它是否是可选的来表现。****

****在`unowned`的情况下，不需要做这种事情。对于`unowned(safe)`，可能需要一个检查来确保它引发异常，但是对于`unowned(unsafe)`，不需要这种检查，因为它的行为是不可预测的。****

****因此，我们可以看到，正确使用`weak`和`unonwed`可能会带来某种性能影响。****

# ****来源****

*   ****[内存管理规则](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-BAJHFBGH)****
*   ****[铿锵电弧文件](https://clang.llvm.org/docs/AutomaticReferenceCounting.html#semantics)****
*   ****[迅捷的弧线](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)****