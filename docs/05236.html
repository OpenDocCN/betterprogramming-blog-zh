<html>
<head>
<title>Say Goodbye to SceneDelegate in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">告别SwiftUI中的SceneDelegate</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/say-goodbye-to-scenedelegate-in-swiftui-444173b23015?source=collection_archive---------3-----------------------#2020-06-23">https://betterprogramming.pub/say-goodbye-to-scenedelegate-in-swiftui-444173b23015?source=collection_archive---------3-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">17行代码如何替换两个完整的文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a87cf514bf68338aaa0683814484663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JH0WML_bNqQ3iPkQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jonathan Kemper 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="14ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI是构建应用程序的好方法。它简单、简洁、快速。UIKit中的内容可以在SwiftUI中用一半的代码重新创建。过去需要几周的事情现在只需要几个小时。但是直到今天，它<em class="lv"> um </em> … <em class="lv"> </em>还是依赖于UIKit。</p><p id="88e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要显示用SwiftUI创建的视图，您必须将它包装在一个<code class="fe lw lx ly lz b">UIHostingController</code>中，这个<code class="fe lw lx ly lz b">UIHostingController</code>必须包装在一个<code class="fe lw lx ly lz b">UIWindow</code>中，这个<code class="fe lw lx ly lz b">UIWindow</code>必须在<code class="fe lw lx ly lz b">SceneDelegate</code>中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个为简单性和性能而设计的框架来说，所有这些代码都没有意义。为什么要写30行代码来定义一个视图呢？！</p><p id="bdc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天在WWDC20上公布了一个解决方案:<code class="fe lw lx ly lz b">App</code>。</p><p id="b2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，<code class="fe lw lx ly lz b">App</code>？是的，<code class="fe lw lx ly lz b">App</code>。<code class="fe lw lx ly lz b">App</code> <em class="lv"> </em>协议。简单到说了几次就觉得怪怪的。</p><p id="6138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Xcode 11.5到<a class="ae ky" href="https://developer.apple.com/download/" rel="noopener ugc nofollow" target="_blank"> Xcode 12 beta </a>中，你会在创建SwiftUI app时看到一个新选项:“SwiftUI App。”</p><p id="ee47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么，苹果是想给Xcode加个回声发生器吗？不尽然——它实际上是“生命周期”的两个选项之一:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/511ba3234fdd9a17de363c931a360a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFtnlCRtnqEL0KXrBnA1_A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/2f8dc4e751a0c99f2fb76d7daf2eecf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*fQUL9AnMvqHMggVkquqjgw.png"/></div></figure><p id="63f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“生命周期”指的是应用程序的状态，通常是“活动”、“非活动”或“后台”我们用它在启动时显示用户界面，并在退出时保存用户数据。</p><p id="bb04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前，这是在<code class="fe lw lx ly lz b">AppDelegate</code>和<code class="fe lw lx ly lz b">SceneDelegate</code>中处理的，这使得管理应用程序状态变得很麻烦——它分散在两个文件中！两个。文件。荒谬！</p><p id="4a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，如果你选择“SwiftUI App”并创建项目，你会注意到<code class="fe lw lx ly lz b">AppDelegate</code> <em class="lv">和</em> <code class="fe lw lx ly lz b">SceneDelegate</code>都不见了！取而代之的是一个名为<code class="fe lw lx ly lz b">&lt;App Name&gt;App</code>的文件来代替它们！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/172f302a9feeffe50767e3b26c84442f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*xwIF4aV0xWzC7oR8NCLAag.png"/></div></figure><p id="88ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想知道<code class="fe lw lx ly lz b">HelloWorldApp</code>里有什么？你不会相信的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！怎么会？苹果用什么魔法把两个完整的<em class="lv">文件</em>代码替换成了17行(包括注释)？</p><p id="9dba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然“生命周期”事件听起来很重要，但大多数人只会碰一两次<code class="fe lw lx ly lz b">AppDelegate</code>或<code class="fe lw lx ly lz b">SceneDelegate</code>。代码清理、状态更改和大多数其他重要事件都是自动处理的。你不需要担心这些。和保存数据？一个好的应用程序可以即时保存，而不是在其生命周期结束时保存。生命周期中唯一需要手动修改的部分是入口点。Xcode需要知道你想要显示什么。</p><p id="a33c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果对<code class="fe lw lx ly lz b">App</code>协议所做的就是将生命周期剥离到单一的、最基本的元素——入口点。每个附加的生命周期都是可选的，您可以在以后添加它。</p><p id="8e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，如果您熟悉SwiftUI，我们的入口点语法并不是什么新东西。它是在一个结构中声明的，这在提高性能的同时也使它易于阅读。</p><p id="4033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下面的代码为例，它呈现了一些文本“Hello World！”：</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="aa0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来和我们的<code class="fe lw lx ly lz b">HelloWorldApp</code> struct非常非常相似！但是，也有一些不同之处:</p><ul class=""><li id="d77f" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><code class="fe lw lx ly lz b">@main</code>告诉Xcode下面的结构<code class="fe lw lx ly lz b">HelloWorldApp</code>将是应用程序的入口点。只能用此属性标记一个结构。</li><li id="d7b0" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">根据<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/app" rel="noopener ugc nofollow" target="_blank">文档</a>，<code class="fe lw lx ly lz b">App</code>是一个“代表应用程序的结构和行为”的协议<code class="fe lw lx ly lz b">HelloWorldApp</code>符合这一点。这就像你的应用程序的基本视图——不，是应用程序本身。您实际上是在这个结构中写出了您的应用程序的外观。</li><li id="9a3f" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe lw lx ly lz b">Scene</code>—swift ui<code class="fe lw lx ly lz b">View</code>的主体必须是<code class="fe lw lx ly lz b">View</code>类型。类似地，SwiftUI <code class="fe lw lx ly lz b">App</code>的主体必须是类型<code class="fe lw lx ly lz b">Scene</code> …</li></ul><p id="2b00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，什么？不应该是类型<code class="fe lw lx ly lz b">App</code>吗？嗯，其实，<code class="fe lw lx ly lz b">Scene</code>在这里更有意义:</p><blockquote class="mt"><p id="29cb" class="mu mv it bd mw mx my mz na nb nc lu dk translated">“每个场景都包含一个视图层次的根视图，并且有一个由系统管理的生命周期。”— <a class="ae ky" href="https://developer.apple.com/documentation/swiftui/app" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="b65f" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">场景就像是视图的容器，可以自动管理:</p><blockquote class="ni nj nk"><p id="2123" class="kz la lv lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">“系统决定何时以及如何以适合平台的方式在用户界面中呈现视图层次结构，并取决于应用程序的当前状态。”— <a class="ae ky" href="https://developer.apple.com/documentation/swiftui/scene" rel="noopener ugc nofollow" target="_blank">苹果开发者</a></p></blockquote><p id="44af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为像macOS和iPadOS这样的平台支持多窗口，将应用程序的所有视图包装在一个<code class="fe lw lx ly lz b">Scene</code>中使得重用更容易，同时还允许包括活动、非活动和背景状态的“场景阶段”。</p><ul class=""><li id="71a3" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><code class="fe lw lx ly lz b">WindowGroup</code>是一个包装视图的<code class="fe lw lx ly lz b">Scene</code>。我们想要呈现的景色<code class="fe lw lx ly lz b">ContentView</code>，是一个<code class="fe lw lx ly lz b">View</code>——而不是一个场景。<code class="fe lw lx ly lz b">WindowGroup</code>让我们将它们包装成SwiftUI可以识别和显示的单个<code class="fe lw lx ly lz b">Scene</code>。</li></ul><p id="0cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是所有的新语法！</p><p id="3fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你<em class="lv">需要</em>去观察那些可选的生命周期事件，比如用户退出应用程序的时候，该怎么办呢？在旧的<code class="fe lw lx ly lz b">SceneDelegate</code>中，它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="81d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这还不算太糟，但是每个生命周期事件都有独立的函数，这使得我们的代码很难管理。</p><p id="f494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在新的<code class="fe lw lx ly lz b">App</code>协议中，苹果确保了即使是生命周期的可选部分——那些没有多少人会使用的部分——仍然非常容易实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先创建一个属性<code class="fe lw lx ly lz b">scenePhase</code>，它从系统中获取活动的当前状态。反斜杠(<code class="fe lw lx ly lz b">\</code>)表示我们使用的是<a class="ae ky" href="https://www.hackingwithswift.com/example-code/language/what-are-keypaths" rel="noopener ugc nofollow" target="_blank"> keypath </a>，这意味着我们引用的是属性本身，而不是它的值。每当属性值改变时，就会调用<code class="fe lw lx ly lz b">onChange</code>修饰符，在这里我们可以获得生命周期状态！</p><p id="16f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="5732" class="nv nw it bd nx ny nz oa ob oc od oe of jz og ka oh kc oi kd oj kf ok kg ol om bi translated">结论</h1><p id="284b" class="pw-post-body-paragraph kz la it lb b lc on ju le lf oo jx lh li op lk ll lm oq lo lp lq or ls lt lu im bi translated">你还会回到<code class="fe lw lx ly lz b">SceneDelegate</code>和<code class="fe lw lx ly lz b">AppDelegate</code>吗？如果我有选择，我不会。</p><p id="5b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，新的<code class="fe lw lx ly lz b">App</code>协议只适用于使用SwiftUI的应用程序——那些使用UIKit的应用程序不会得到它。而且SwiftUI在功能上还是比不上UIKit你得不到集合视图，基于坐标的动画，视觉效果视图等等。</p><p id="73f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，有时候你还是需要<code class="fe lw lx ly lz b">AppDelegate</code>(对于Firebase和主屏幕快速动作之类的东西)。在这种情况下，您可以继续使用<code class="fe lw lx ly lz b">App</code>协议——只需用<code class="fe lw lx ly lz b"><a class="ae ky" href="https://gist.github.com/aheze/6998b4bae660c8dade8ba6a75687772c" rel="noopener ugc nofollow" target="_blank">@UIApplicationDelegateAdaptor</a></code>扩展它。</p><p id="aa54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的WWDC20上，我们得到了很多我们想要的东西，但我们还需要再等几年才能得到所有的东西。</p><p id="51c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！祝编码愉快，并享受WWDC的其余部分！</p></div></div>    
</body>
</html>