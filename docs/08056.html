<html>
<head>
<title>The Practical Implications of Python Objects’ Callability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python对象可调用性的实际含义</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-practical-implications-of-python-objects-callability-50ec2f54e24a?source=collection_archive---------6-----------------------#2021-03-19">https://betterprogramming.pub/the-practical-implications-of-python-objects-callability-50ec2f54e24a?source=collection_archive---------6-----------------------#2021-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d73" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过汇集相关主题来提高您的Python知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1fddedd6694162e8db6dc7ce6289ef41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fwptkSRxeN9zQEjy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@dan_stark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹·斯塔克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="3552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上讲，Python是一种面向对象的编程(OOP)语言。就实现而言，Python将其构建块(如包、模块、类、函数和数据)组织为不同种类的对象。因此，理解对象的特征对于编写更好的、错误更少的Python代码至关重要。</p><p id="31b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将重点关注Python对象的一个具体特征:可调用性。除了基本概念之外，我想讨论一下它的实际含义，您可以在Python项目中实际使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6a54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本概念</h1><p id="646d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可调用性是指对象是否可以被调用。像大多数其他现代语言一样，调用一个对象是通过使用一对括号来实现的(被一些人称为调用操作符)。所以如果一个对象可以和调用操作符一起使用，我们说它是可调用的。如果不能，我们说它不可赎回。</p><p id="826a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用呼叫接线员</p></figure><p id="2bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，函数是可调用的，您可以通过调用它来调用函数。然而，<code class="fe nb nc nd ne b">list</code>对象是不可调用的。Python类是可调用的，使用它是我们创建实例对象的方式。我们可以使用内置的<code class="fe nb nc nd ne b">callable()</code>函数来检查Python对象的可调用性，而不是尝试直接调用对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们对这些对象使用call操作符时，返回的布尔值与上面显示的行为一致。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7016" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实践含义1:类与函数</h1><p id="87fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一个含义是理解类和函数之间的细微差别。作为可能是最基本和最常用的一组函数，有将近70个<a class="ae ky" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank"> Python内置函数</a>。</p><p id="9e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，严格来说，这些函数很多都不是函数。相反，它们实际上是类，如<code class="fe nb nc nd ne b">bool()</code>、<code class="fe nb nc nd ne b">int()</code>、<code class="fe nb nc nd ne b">list()</code>和<code class="fe nb nc nd ne b">dict()</code>，而不是<code class="fe nb nc nd ne b">sum()</code>、<code class="fe nb nc nd ne b">callable()</code>和<code class="fe nb nc nd ne b">hash()</code>，它们是函数。</p><p id="e932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道这种区别在语法上当然不重要，但是从语义的角度来看，这种区别是很明显的。当我们调用类时，我们期望得到相应类的实例对象。虽然我们可以设置任何适用的参数，但是我们知道返回的对象将总是属于与“函数”同名的类，例如<code class="fe nb nc nd ne b">int</code>、<code class="fe nb nc nd ne b">list</code>、<code class="fe nb nc nd ne b">dict</code>和<code class="fe nb nc nd ne b">set</code>。</p><p id="3085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，实函数并不直接与任何底层类相关联。因此，您永远不会期望通过调用这些函数来获得同名的实例对象。例如，你不会期望通过调用<code class="fe nb nc nd ne b">sum()</code>得到一个<code class="fe nb nc nd ne b">sum</code>对象，或者通过调用<code class="fe nb nc nd ne b">callable()</code>得到一个<code class="fe nb nc nd ne b">callable</code>对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e031" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实践含义2:重新访问地图和过滤器</h1><p id="0034" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管被打上了OOP语言的烙印，Python还是有函数式编程的特性。一个这样的特性是高阶函数的集成(两个常见的是<code class="fe nb nc nd ne b">map</code>和<code class="fe nb nc nd ne b">filter</code>)。以下代码片段向您展示了这两个函数的一些简单用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">高阶函数:映射和过滤</p></figure><p id="eb58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您检查<code class="fe nb nc nd ne b">map</code>和<code class="fe nb nc nd ne b">filter</code>，您会发现以下情况:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="466c" class="nj md it ne b gy nk nl l nm nn">&gt;&gt;&gt; map<br/>&lt;class 'map'&gt;<br/>&gt;&gt;&gt; filter<br/>&lt;class 'filter'&gt;</span></pre><p id="dca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们许多人可能认为的不同，<code class="fe nb nc nd ne b">map</code>和<code class="fe nb nc nd ne b">filter</code>实际上都是类。这种误解可能源于这样一种假设，即类通常采用非功能对象来构造实例。但是别忘了Python的函数都是对象。因此，<code class="fe nb nc nd ne b">map</code>和<code class="fe nb nc nd ne b">filter</code>类的特殊之处在于它的构造包含了函数的传递。</p><p id="2017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我并不是说我们应该停止调用<code class="fe nb nc nd ne b">map</code>和<code class="fe nb nc nd ne b">filter</code>高阶函数。我们应该简单地认识到它们是作为Python中的类来实现的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a7a9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实际含义3:关键参数</h1><p id="a019" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">几个Python函数包含一个名为<code class="fe nb nc nd ne b">key</code>的参数，该参数通常在函数执行一些排序或比较操作时使用。独立于函数的指定功能，<code class="fe nb nc nd ne b">key</code>参数具有相同的要求:一个函数。</p><p id="ec20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段向您展示了我们如何在<code class="fe nb nc nd ne b">sorted()</code>函数中使用常规函数和lambda函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在sorted()中使用函数</p></figure><p id="1215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们应该明白，我们可以向<code class="fe nb nc nd ne b">key</code>参数发送任何调用。考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在sorted()中使用类</p></figure><p id="9d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们创建了一个名为<code class="fe nb nc nd ne b">PokerSorter</code>的定制类。它所做的只是将非数字卡片映射到它们相应的数值上。通过将这个类应用于<code class="fe nb nc nd ne b">sorted()</code>函数，我们能够按照预期对卡片进行排序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e3e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实践含义4:使用类作为装饰者</h1><p id="a63f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一般来说，装饰器是高阶函数，它修改被装饰的函数，而不影响被装饰的函数的预期操作。这就是为什么我们可以说一个高阶函数修饰了另一个函数。</p><p id="aec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码向您展示了我们如何创建一个装饰函数并装饰另一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><ul class=""><li id="dfca" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nb nc nd ne b">logging_time</code>函数是decorator函数，它将一个函数作为其参数。</li><li id="c7e2" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">这个函数包含一个名为<code class="fe nb nc nd ne b">logger</code>的内部函数，在这个函数中发生与装饰相关的操作。在本例中，我们记录了函数调用和完成之间的时间差。</li><li id="2000" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">decorator函数返回内部函数<code class="fe nb nc nd ne b">logger</code>作为输出值。</li><li id="ab26" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">为了使用装饰器，我们把它放在要装饰的函数上面，在装饰器函数名前面加一个<code class="fe nb nc nd ne b">@</code>符号。大家可以看到，装饰之后，调用<code class="fe nb nc nd ne b">calculate_sum_n</code>就会产生这个函数的运行时间。</li></ul><p id="13ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于到目前为止已经讨论过的类和函数之间的相似性，您可能会猜测使用类来实现修饰特性是可能的。让我们看看它是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作为装饰者的类</p></figure><ul class=""><li id="ad85" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">我们创建一个名为<code class="fe nb nc nd ne b">TimeLogger</code>的定制类。一个显著的特性是这个类的构造函数接受一个参数，这个参数就是要修饰的函数。</li><li id="8537" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">在初始化方法(即<code class="fe nb nc nd ne b">__init__</code>)中，我们创建了与装饰函数相同的函数(即<code class="fe nb nc nd ne b">logger</code>)。不同之处在于，我们现在将它保存为实例的属性。</li><li id="ef8e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">我们可以使用相同的语法来修饰这个类的函数。但是，需要注意的是，修饰函数不再是函数。相反，它是<code class="fe nb nc nd ne b">TimeLogger</code>类的实例对象。</li></ul><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="013b" class="nj md it ne b gy nk nl l nm nn">&gt;&gt;&gt; calculate_sum_n_cls<br/>&lt;__main__.TimeLogger object at 0x110105340&gt;</span></pre><ul class=""><li id="fa92" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">为了使这个实例对象的行为像一个函数，我们必须覆盖<code class="fe nb nc nd ne b">__call__</code>特殊方法，在该方法中我们调用<code class="fe nb nc nd ne b">_logger</code>函数的属性。</li></ul><p id="2687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么我们想要使用类作为装饰者。有几个原因:</p><ul class=""><li id="fd30" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">您可以实现更复杂的接受参数的装饰器。使用类更容易提供这种灵活性。</li><li id="db20" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">我们可以向实例对象添加其他属性。例如，我们可以保存计算结果的记录作为对象的属性，这样当一些昂贵的计算发生多次时，我们可以节省大量时间。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc76" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="3153" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文讨论了Python对象可调用性的概念。我们讨论了可赎回性的四个实际含义。本质上，类和函数在Python中都是可调用的，这就在它们之间创造了很多相互交流的可能性。因此，当我们考虑到可调用性时，我们可以编写更灵活的代码。</p></div></div>    
</body>
</html>