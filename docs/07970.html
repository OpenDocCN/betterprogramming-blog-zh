<html>
<head>
<title>Frustrated With JavaScript? You’re Not Alone — These Are the 4 Most Confusing Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对JavaScript感到沮丧？你并不孤单——这是4个最令人困惑的特征</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/frustrated-with-javascript-youre-not-alone-these-are-the-4-most-confusing-features-1488ca5f0f38?source=collection_archive---------5-----------------------#2021-03-10">https://betterprogramming.pub/frustrated-with-javascript-youre-not-alone-these-are-the-4-most-confusing-features-1488ca5f0f38?source=collection_archive---------5-----------------------#2021-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f725" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何避免为它们疯狂</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86d07735187a26384e2cc5cd0f5d46d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wx4CuU3gI-1pbX2O"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="b1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种非常灵活的语言，它允许您从非常不同的角度处理同一个问题。与此同时，其周围的庞大社区也在不断发布新的想法和工具供开发者使用。</p><p id="c059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于web开发行业快速向前发展。这也是为什么在一个不断发展的行业中如此广泛使用的技术对新手以及更有经验的开发人员来说如此令人沮丧的原因。</p><p id="8926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抛开那些你可以通过阅读<a class="ae ky" href="https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/" rel="noopener ugc nofollow" target="_blank">规范</a>发现的关于操作符优先或强制规则的奇怪现象(例如，执行<code class="fe lv lw lx ly b">"2" + 2 = 22</code> vs. <code class="fe lv lw lx ly b">"2" — 2 = 0</code>，然后抱怨它)，我想涵盖我见过的新开发人员在第一次接触该语言时遇到的四个棘手问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fd85" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4种声明函数的方法——它们都做同样的事情吗？</h1><p id="d314" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">学习一门新语言时，首先要做的事情之一是理解如何声明将在代码中使用的最基本的构造。</p><p id="5175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用JavaScript，当您开始摆弄函数时，您会发现所有这些选项都有相同的结果(至少乍一看是这样):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ecb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真的，JavaScript？我真的需要四种不同的方法来做同一件事吗？</p><p id="64b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，他们不会做同样的事情，但是如果没有人告诉你，你怎么能自己发现呢？</p><h2 id="254e" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">使用<code class="fe lv lw lx ly b">function</code>关键字</h2><p id="3cf1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是定义函数的最基本的方法，它包含了上面代码片段中的前两个例子。就特性和功能而言，这两个功能完全相同。事实上，你可以用完全相同的方式引用它们。</p><p id="29cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将函数赋给一个变量(它必须是用<code class="fe lv lw lx ly b">let</code>而不是<code class="fe lv lw lx ly b">const</code>声明的变量)的唯一好处是，您有可能将它重新赋给别的变量。本质上，您可以重新定义函数，如果您使用普通的<code class="fe lv lw lx ly b">function name()</code>语法，这是无法做到的。</p><h2 id="899c" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">使用函数构造函数</h2><p id="f145" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">不是每个人都知道<code class="fe lv lw lx ly b">Function</code>构造函数，它允许你用一串代码定义一个新函数。</p><p id="cc72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果呢？是的，它与前面的语法相同。然而，这个构造函数允许你在运行时用来自任何地方的代码定义一个函数。</p><p id="20b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这安全吗？见鬼不！作为<code class="fe lv lw lx ly b">eval</code>函数的近亲，使用这个构造函数，你必须格外小心你要转换成函数的字符串的内容。它可能有潜在的恶意逻辑。然而，它在执行过程中也给了你很大的灵活性。</p><p id="c366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是表演吗？不如在解析阶段解析函数的性能好。然而，如果您使用这个构造函数，您需要在运行时发生这种情况，所以让我们把它标记为“也许，取决于您使用它的次数。”</p><h2 id="1465" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">现在你也有了箭头函数(= &gt;)</h2><p id="f09b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">JavaScript函数空间的最新成员是箭头函数。这些是一种特殊类型的函数。它们的工作方式与前面的不完全相同，您应该意识到这些差异，因为它们不仅仅是语法糖:</p><ul class=""><li id="3403" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">箭头函数没有自己的<code class="fe lv lw lx ly b">this</code>绑定。通常，函数有办法访问执行上下文(比如全局范围、<code class="fe lv lw lx ly b">window</code>对象等等)。然而，箭头函数不会。这意味着它们不能作为对象方法使用，当在其他函数中定义时(例如作为回调)，它们可以安全地使用指向父函数的<code class="fe lv lw lx ly b">this</code>引用，不会有任何问题。</li><li id="91f9" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">他们没有一个<code class="fe lv lw lx ly b">arguments</code>对象。在普通函数中，您可以访问<code class="fe lv lw lx ly b">arguments</code>对象，这允许您迭代参数。这对于创建参数数量可变的函数非常有用。箭头函数不是这样工作的。但是，您可以使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank">剩余参数</a>获得相同的结果。</li><li id="2eae" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">不能和<code class="fe lv lw lx ly b">bind</code>、<code class="fe lv lw lx ly b">call</code>或<code class="fe lv lw lx ly b">apply</code>一起使用。这也是由于缺少<code class="fe lv lw lx ly b">this</code>绑定，这些方法要求您指定绑定。</li><li id="fc4a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">它们不能用作发电机。是啊，发电机功能也是一个东西。但是，您不能将箭头函数用作生成器，因为<code class="fe lv lw lx ly b">yield</code>关键字在它们内部不起作用。</li></ul><p id="5d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">箭头函数就像普通函数的轻量级版本，正因为如此，它们非常适合某些场景——特别是作为回调函数或快速的单行函数，它们可以被简化并有助于使代码更具可读性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7dc5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">可供选择的方案太多了</h1><p id="6a1c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">就像函数一样，JavaScript的生态系统有时会让人感到不知所措。你想进入前端开发领域吗？你打算选择哪个框架？它会是反应，Vue，还是有棱角的？</p><p id="cb44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在找一个捆绑者呢？Webpack？Rollup？Vite？</p><p id="113d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的包经理是什么样的？是npm还是纱？有什么区别？其他选择呢？</p><p id="28a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">老实说，如果我今天必须开始学习JavaScript，我不会只是不知所措。我也会非常疲惫。</p><p id="b74a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于JavaScript的一个笑话是，在你眨眼之间，已经发布了三个新框架。听着，我不是来说这不是真的。但是你也不需要担心他们。</p><p id="2658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在JavaScript的环境中，一个框架或工具要成为新的规范，也需要时间。当然，总有一些早期采用者会一看到新框架就跳起来，但你不必那样。你可以等一等，现在选择一个大玩家，关注一段时间，然后开始寻找。</p><p id="8d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解替代品也能帮助你更好地使用你已经在使用的产品。我们这个行业的一切都是如此。随着时间的推移，您将开始看到框架、工具甚至语言之间的重复模式，从而更容易掌握新技术。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1f37" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">可变范围——尤其是var——非常令人困惑</h1><p id="eb11" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你正在使用<code class="fe lv lw lx ly b">var</code>来声明你的变量，现在停止。别说了。<code class="fe lv lw lx ly b">var</code>的工作方式太普通了，会导致混乱。</p><p id="dafb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你一定要知道，<code class="fe lv lw lx ly b">var</code>要么在函数的范围内工作，要么在全局范围内工作。这意味着如果你在函数中的任何地方声明了一个变量，那么这个变量在函数中的任何地方都是可访问的。如果你在外面声明它，它将是全局的。</p><p id="c3ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些人认为用<code class="fe lv lw lx ly b">var</code>声明的变量总是全局的(我在多次采访中听说过这一点)。事实并非如此，这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="648c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一段非常愚蠢的代码，但它证明了我的观点。注意如何访问在非常清晰的上下文中定义的两个变量(<code class="fe lv lw lx ly b">gVar</code>是因为它是在<code class="fe lv lw lx ly b">for</code>循环中声明的，<code class="fe lv lw lx ly b">i</code>是因为它是该循环的索引)。理想情况下，您不应该能够访问这些变量。</p><h2 id="e1e8" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">const和let呢？</h2><p id="0f8f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是啊，那些才是你想合作的。它们都帮助你定义你的变量，它们都使用块作用域。换句话说，只有在声明它们的最严格的块中，它们才是可见的和可访问的。</p><p id="4b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个函数的<code class="fe lv lw lx ly b">for</code>循环块内的<code class="fe lv lw lx ly b">if</code>语句块内声明一个带有<code class="fe lv lw lx ly b">let</code>的变量，你的变量将只存在于<code class="fe lv lw lx ly b">if</code>内。</p><p id="bacf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的道理也适用于<code class="fe lv lw lx ly b">const</code>变量。这些变量和用<code class="fe lv lw lx ly b">let</code>声明的变量之间唯一的区别是你不能重新分配这些变量。它们是常量。</p><p id="9bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，请注意我使用的语言:我没有说，“他们的价值观不能改变。”我说，“他们不能被重新分配。”这是一个重要的区别，因为虽然它们对于基本类型(如数字、字符串和布尔值)来说是一样的，但对于复杂类型(如对象)来说就不一样了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您期望您的对象是不可变的，因为您将它们声明为<em class="of">常量</em>，那么请三思。上面的代码片段表明您确实可以更改常量引用的<em class="of">值</em>。这段代码的输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c20d7be9b09f62e21527ebd5a07ae1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*Ag7TvRfbD8lm3Z3bOZEDLA.png"/></div></figure><p id="95a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您不能给<code class="fe lv lw lx ly b">myConstant</code>赋值，但是您可以看到对<code class="fe lv lw lx ly b">const</code>的误解可能导致的潜在问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1631" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">混合异步代码的错误处理</h1><p id="88be" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一般来说，异步代码是一个刚接触JavaScript的人并不总是能理解的概念。我明白。当我开始处理<a class="ae ky" href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noopener ugc nofollow" target="_blank"> AJAX </a>时，我花了相当长的时间将我的PHP知识映射到JavaScript(是的，我有那么老)。</p><p id="174d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">捕获异步发生的错误并不总是简单的——尤其是当您考虑到至少有三种方法可以编写异步代码时:</p><ul class=""><li id="aedb" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">使用回调函数。这是最古老的方法，也可能是最难发现的。内部进行异步调用的函数不能抛出错误作为异常，所以你的标准<code class="fe lv lw lx ly b">try/catch</code>块不能工作。检查这些函数的返回值也是不可能的，因为它们不返回任何东西。你必须依靠回调和<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/javascript-tips-3-convert-error-first-callback-functions-to-promises-f2561d2aaefd">错误优先模式</a>。这意味着确保回调函数的第一个参数总是异步调用的错误。如果参数为空，则没有错误。否则，请采取相应措施。这不是一个非常干净的模式，回调通常会导致代码非常难读——这没有帮助。</li><li id="6b19" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">利用承诺。承诺要求你使用一种特定的与承诺相关的方法来捕捉错误:<code class="fe lv lw lx ly b">catch</code>。同样，除非你来自一个类似的异步友好的技术栈，否则承诺需要你去适应和以不同的方式思考。然而，需要注意的是，承诺内部有一个隐式的<code class="fe lv lw lx ly b">try/catch</code>块，所以在承诺体中抛出的任何异常都将触发拒绝。请看下面的例子:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><ul class=""><li id="0df5" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">使用<code class="fe lv lw lx ly b">async/await</code>。现在，更重要的是，新的<code class="fe lv lw lx ly b">async/await</code>语法将异步代码变成了看起来同步的代码，并允许使用<code class="fe lv lw lx ly b">try/catch</code>块来捕获异步函数抛出的异常。多亏了这个新语法，我说的所有用回调和承诺不可能实现的事情现在都可以实现了。耶，一点也不困惑！</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到<code class="fe lv lw lx ly b">try/catch</code>块是如何捕获由<code class="fe lv lw lx ly b">test</code>函数抛出的错误的。这种选择无疑是最容易解决的，最容易阅读的，也是新手开始使用的最佳选择。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b1be" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="dd57" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">JavaScript有时会令人沮丧，但这只是因为我们倾向于将它过于简化——尤其是当我们刚刚开始尝试的时候。关于这门语言有很多东西需要学习，虽然它提供了很大的灵活性，但也有很多规则需要记住。</p><p id="2ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不用担心。请记住，掌握一门语言需要时间，虽然你遇到的错误可能是由于不合逻辑的行为，但一切都有合理的解释。</p><p id="2bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你呢？你发现JavaScript最令人沮丧的是什么？</p></div></div>    
</body>
</html>