# Java 10 中的局部变量类型推理

> 原文：<https://betterprogramming.pub/local-variable-type-inference-in-java-10-cb4967dd6eb0>

## 更简洁的代码和更简单的变量声明

![](img/f36c97d925a04fde31fd18677dcccb5b.png)

异盐@ Ponshukan，JR 新潟站|作者拍摄

Java 经常被批评为过于冗长。促成这种特征的一个方面是明确指定每种类型的要求，这导致了许多额外的[噪声](https://codeburst.io/signal-to-noise-ratio-a45ae45c3545)。

用 JDK 10 和 [JEP 286](https://openjdk.java.net/jeps/286) : *局部变量类型推断*给了我们一种新的更少杂乱的声明局部变量的方法。

```
**TABLE OF CONTENTS**[General Concept](#e55c) [Reading Vs. Writing Code](#f684) [Explicit Context](#389b) [Implicit Context](#94aa)
[Caveats](#80c1)
[Conclusion](#1afb)
[Resources](#be7b)
```

# 一般概念

名称本身完美地描述了该功能的核心及其局限性:

## **局部变量**

*   仅支持局部变量
*   没有方法参数
*   没有返回类型
*   没有字段
*   没有兰姆达斯

## **类型推断**

Java 编译器会自动为我们检测正确的类型。

实际上，这对于 JDK 来说并不是一个全新的功能。钻石运算符`<>` (JDK 7)已经支持推断类型，lambdas 可以推断它们的参数类型(JDK 8):

这并不意味着 Java 突然变成了动态类型化的。所有类型都将在编译时推断，而不是在运行时，为我们提供了与以前相同的安全性。

## 如何使用'`var'`

基本思想很简单:当我们初始化一个局部变量时，我们可以用新引入的反向类型名`var`代替显式声明的左手类型。推断类型的所有信息必须由初始值设定项提供(例如，构造函数、文字、方法返回值):

由于`var`不是关键字，我们也可以使用`final`使变量不可重新赋值。

## 可能会有一些限制

变量的类型在初始化时必须是可推断的，所以`null`是不允许的:

Lambdas 也不能用`var`表示，至少在没有显式强制转换的情况下不能。由于 lambdas 是由幕后的具体函数接口表示的，因此在没有附加上下文的情况下无法推断其类型:

通过将它强制转换成一个显式接口，我们也许能够让编译器满意。但是这种令人厌恶的行为并不符合`var`的本意。

# 阅读与编写代码

我们的代码被阅读的次数会比被编写的次数多得多。

在编写代码时，所有的上下文仍然在那里。无论何时有人阅读我们的代码，甚至是我们自己，我们都需要能够用它来推理。

> "程序是要被人类阅读的，只是偶尔让计算机执行."—唐纳德·克努特

Java 的冗长可能是一种精神负担，因为它让我们面对比理解它实际所需更多的代码。有助于减少这些额外的、通常是多余的信息。但并不是所有被它删除的代码都是多余的。它可能会消除更大背景下的任何指标。

用代码进行推理意味着理解它的上下文和影响。如果我们删除显式类型信息，我们需要确保上下文可以通过其他方式推导出来。仅仅因为编译器可以推断出正确的类型并不意味着我们人类也可以这样做。

我们应该总是能够理解局部范围内的代码，而不知道围绕它的完整的更大的画面。这就是为什么不是每个局部变量声明都应该使用`var`的原因。

# 显式上下文

`var`的优秀用例是已经包含显式上下文的构造:构造函数、文字和静态工厂方法。

## 构造器

构造函数是由它们的类型组成的，所以不可能有更多的信息:

不需要额外的上下文。

## 文字

如果我们遵守它们的特殊符号，文字可以提供推断正确类型所需的所有上下文:

如果我们不遵守，文字可能被推断为另一种类型。实际上，由于隐式转换，它们仍然可能工作。但是实际类型可能是错误的:

文字`byte`和`short`没有特殊的指示符，所以它们总是被推断为`int`。

## 静态工厂方法

许多类型包含静态工厂方法，通过类名或工厂方法名提供与构造函数一样多的信息:

# 隐含语境

`var`的另一个方面是替换不必要信息的能力。

## 中间值

局部变量是一种在狭窄范围内存储中间值的简单而廉价的方法。为了理解上下文，这些变量的实际类型可能没有它们的名称和它们的环境那么重要:

通过使用更好的变量名，我们可以依靠`var`并且仍然掌握上下文:

## 环

如前所述，使用`var`可以简化循环。通常，周围的上下文提供了足够的信息，所以我们不再需要显式类型:

## '用资源尝试'

一个`try-with-resources` 块可能非常冗长。但是多亏了`var`，我们可以让它们更简洁:

## 无商标消费品

特别是泛型类型声明，可能会很冗长。一个简单的`Iterator`可以复杂到:

知道了`Map`是什么类型，我们就不需要考虑迭代器或条目的显式类型:

这是更容易的眼睛，仍然像以前一样容易理解。

# 警告

除了过度使用`var`和破坏有价值的信息之外，还有许多警告需要注意。

## 菱形算子

如前所述，菱形运算符`<>`已经为我们提供了类型推断。编译器根据左边的声明推断右边的类型:

使用`var`，我们不再拥有这些信息，必须在初始化器中自己提供:

但是，这并不意味着我们不能使用 diamond 操作符。如果初始化器由于其他情况提供了足够的信息，编译器可以推断出正确的类型:

## 接口与具体类型

通常，我们针对接口而不是具体的实现进行编码:

这种抽象为我们未来的变化提供了很大的灵活性。但是使用类型推断，我们*只*得到初始化器的类型，而不是它的接口:

由于只对局部变量可用，这应该不会造成太大的问题。我们仍然应该针对公共接口的抽象进行编码。但在局部范围内，这并不重要。

## 文字

如前所述，文字需要通过特定于类型的指示符的附加上下文才能被正确推断:

```
 **TYPE**   | **INDICATOR**
------- | ------------------------------------
 String | double-quoted
 char   | single-quoted
 int    | whole number
 long   | whole number ending with "L/l"
 float  | decimal number ending with "f/F"
 double | decimal number, optional "d/D"
 byte   | no indicator, always inferred to int
 short  | no indicator, always inferred to int
```

# 结论

更多的类型推断是 Java 的一大亮点。静态编译时类型安全与更少的输入和更简洁的代码是双赢的。省略显式类型可以减少混乱，只要我们有其他信息来推断上下文。

但是不仅仅是不加区别地用`var` 替换现有的类型声明。代码必须根据其周围的环境进行推理。

我们可以通过选择更好的变量名和缩小中间值的范围来改善这种上下文。如果使用类型推断仍然损害可理解性，这可能是更深层次结构问题的一个指标，并且`var`可能不是最好的方法。

```
**You like my ramblings about Java? Check out my upcoming book!**
[https://belief-driven-design.com/book/](https://belief-driven-design.com/book/)
```

# 资源

*   [JEP-286](https://openjdk.java.net/jeps/286) (OpenJDK)
*   [局部变量类型推断:常见问题解答](https://openjdk.java.net/projects/amber/LVTIFAQ.html) (OpenJDK)
*   [局部变量类型推断:样式指南](http://openjdk.java.net/projects/amber/LVTIstyle.html) (OpenJDK)
*   [Var with Style:Stuart Marks 的 Java 10 中的局部变量类型推理](https://www.youtube.com/watch?v=786iemaCJHU) (YouTube)