<html>
<head>
<title>A Deep Dive Into the Java Volatile Keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究Java Volatile关键字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-the-java-volatile-keyword-7e1b9f9df604?source=collection_archive---------4-----------------------#2021-12-28">https://betterprogramming.pub/a-deep-dive-into-the-java-volatile-keyword-7e1b9f9df604?source=collection_archive---------4-----------------------#2021-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0cfa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">想彻底了解volatile吗？想知道什么时候用volatile吗？然后阅读这篇文章，揭开Java volatile隐藏的奥秘。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9dfd52a7427085fec760fb3359729ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUIPe-rUOGG5Lz5IYLAM8w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="1742" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能已经读过很多关于volatile变量的文章，讨论了它们是如何被用来阻止处理器优化的，或者它是如何告诉编译器它的值不应该被缓存的。</p><p id="dd82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，问题是这些陈述并不能帮助我们深入理解什么是volatile，以及何时应该使用它。看完这篇文章，你会对这方面有很深的了解。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="035d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在试图理解什么是volatile之前，让我们先来理解一下我们在多线程环境中面临的一些基本问题。下面是JVM中“long”数据类型的表示(double也是如此)。它大小为64位。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/de76e995ac511424e03860fb6d3bbc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*GbNRmbYvKTZ4smVhGpMoFw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JVM上long的表示。图片来源:作者</p></figure><p id="236a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你看到了JLS(Java语言规范)，它并没有对如何在内部实现写操作加以限制。</p><p id="9ecc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我说得更清楚一点——在32位机器上，它被实现为两个32位写操作的组合。在64位机器上，它可以实现为单个64位写操作，也可以是两个32位写操作的组合。JLS对内部实现只字未提。这完全取决于JVM实现者。</p><h1 id="9e32" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">文字撕裂</h1><p id="34ae" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">基于以上理解，如果你对一个long/double变量进行写操作，并且如果JVM已经将写操作实现为两个32位写操作的组合，那么这个操作本质上不是原子的。</p><p id="586c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为它将花费不止一个CPU周期来写入长。如果这个变量在多个线程(T1和T2)之间共享，那么就有可能——当T1写完A段(32位)时，CPU被拿走交给T2，T2写了B段(32位)。</p><p id="2026" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将导致您程序从T1读取32位，从T2读取另外32位。这叫撕字。</p><p id="3ef4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以像下面这样的简单代码在多线程环境中变得很危险:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="81ac" class="nb ma iq mx b gy nc nd l ne nf">void assign(long value) {<br/>    <em class="ng">// This is risky in multi threaded environment.<br/>    </em>someSharedLongValue = value; <br/>}</span></pre><p id="9d92" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两个线程可以写它的一半，程序将有一个难以检测的并发错误。</p><p id="3ae8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了字撕裂之外，还有另一个问题，如果T1写第一个32位并被抢占，同时，其他线程t 3来执行读操作。它会读取一个半生不熟的值。不是吗？现在，这就是<code class="fe nh ni nj mx b">volatile</code>出现的原因。</p><p id="3163" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Volatile说<em class="ng">“volatile long和double值的读写总是原子的。”</em></p><blockquote class="nk nl nm"><p id="7d52" class="kv kw ng kx b ky kz jr la lb lc ju ld nn lf lg lh no lj lk ll np ln lo lp lq ij bi translated">所以，这里的volatile解决了单词撕裂和原子性的问题。</p></blockquote><blockquote class="nq"><p id="f4b5" class="nr ns iq bd nt nu nv nw nx ny nz lq dk translated">不要假设声明任何类型volatile都会使它原子化。对于long/double基元类型来说也是如此。</p></blockquote><p id="a48f" class="pw-post-body-paragraph kv kw iq kx b ky oa jr la lb ob ju ld le oc lg lh li od lk ll lm oe lo lp lq ij bi translated">让我们继续我们的深潜…</p><h1 id="74ef" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">volatile提供的保证</h1><h2 id="bcf1" class="nb ma iq bd mb of og dn mf oh oi dp mj le oj ok ml li ol om mn lm on oo mp op bi translated">1.能见度</h2><p id="3d2e" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">所有对易失性变量的读/写都将发生在主存储器中。这些值不会缓存在CPU中。</p><p id="38e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们知道，CPU可以有多个内核，每个内核都有自己的L1缓存，因此当您的代码正在执行时，CPU很可能会缓存一些值来提高性能，因为从主内存读取/写入数据是非常昂贵的。</p><p id="cc77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样做的结果是，当CPU认为合适时，每个内核都会定期将同一个变量的副本写回主内存。这通常不是一个问题，但是当我们处理高争用情况时，就成了一个问题。</p><p id="3f9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以我们之前使用的方法为例:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b5f7" class="nb ma iq mx b gy nc nd l ne nf">long someLongValue = 0L;<br/>void assign(long value) { // Executed by T1<br/>    <em class="ng">// This is risky in multi threaded environment.<br/>    </em>someLongValue = value;<br/>}<br/><br/>long get() { // Executed by T2<br/>    return someLongValue;<br/>}</span></pre><p id="70e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有可能<code class="fe nh ni nj mx b">someLongValue</code>的值是缓存在CPU中的，所以线程是在处理缓存的值(当线程在CPU上执行时，它不知道该值是来自缓存还是主存。这是在CPU级别抽象的)，当T1给它赋值时，只有CPU缓存被更新，其他线程不知道，T2从内存中读取旧值，从而导致错误。</p><p id="526a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们创建变量<code class="fe nh ni nj mx b">volatile</code>时，值总是从主内存中读取并写入主内存，因此它对其他线程是可见的。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="2fcf" class="nb ma iq mx b gy nc nd l ne nf">volatile long someLongValue = 0L;<br/>void assign(long value) { <em class="ng"><br/>    </em>someLongValue = value; // Writes are made to main memory<br/>}<br/><br/>long get() { <br/>    return someLongValue; // Value is read from the main memory<br/>}</span></pre><blockquote class="nk nl nm"><p id="60a4" class="kv kw ng kx b ky kz jr la lb lc ju ld nn lf lg lh no lj lk ll np ln lo lp lq ij bi translated">如果你正在处理一个在多个线程间共享的变量，并且这个变量不是同步的，你可能不得不使它变得不稳定，原因我们刚刚已经讨论过了。如果对它的访问由synchronised保护，那么就不需要它，它会被处理掉。</p></blockquote><p id="321e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是JVM架构师发现仅仅使变量易变并不总是足够的。在一些情况下，事情仍然可能出错。让我们看一个例子:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="81d3" class="nb ma iq mx b gy nc nd l ne nf">volatile long someLongValue = 0L;<br/>long someDependency = 1;<br/>long someOtherDependency = 3;</span><span id="a0dd" class="nb ma iq mx b gy oq nd l ne nf">void assign(long value) { // T1 executes this<em class="ng"><br/>    </em>someDependency = 3;<br/>    someOtherDependency = 22;<br/>    someLongValue = value + someDependency + someOtherDependency;<br/>}</span><span id="0bc1" class="nb ma iq mx b gy oq nd l ne nf">long get() { // T2 executes this<br/>    if(someDependency == 1) {<br/>        return someLongValue;<br/>    } else {<br/>        return someLongValue*2;<br/>    }<br/>}</span></pre><p id="caf3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，<code class="fe nh ni nj mx b">assign()</code>被调用，所有的变量都用新值更新，<code class="fe nh ni nj mx b">volatile someLongValue</code>被更新并被写回主内存。但是，<code class="fe nh ni nj mx b">someDependency</code>和<code class="fe nh ni nj mx b">someOtherDependency</code>不会被更新到主存储器，它们的值保留在CPU缓存中。</p><p id="55ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当T2进来时，它看不到<code class="fe nh ni nj mx b">someDependency</code> <em class="ng"> </em>的更新值(3)，因为它不是易失性的，并且将<code class="fe nh ni nj mx b"> if(someDependency == 1)</code> <strong class="kx ir"> </strong>评估为真。</p><p id="aaf0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是错误的！但这在现实中并没有发生。为什么？这就是可见性保证的第二部分。上面写着，</p><blockquote class="nk nl nm"><p id="71f1" class="kv kw ng kx b ky kz jr la lb lc ju ld nn lf lg lh no lj lk ll np ln lo lp lq ij bi translated">如果一个可变变量被刷新到主内存中，那么此时线程可见的所有共享变量将和可变变量一起被刷新。</p></blockquote><p id="cb3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，另外两个非易失性变量也将被刷新到主内存中。</p><h2 id="0e62" class="nb ma iq bd mb of og dn mf oh oi dp mj le oj ok ml li ol om mn lm on oo mp op bi translated"><strong class="ak">指令重新排序</strong></h2><p id="07f1" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">在我们理解下一个保证之前，我们应该理解指令重新排序。</p><p id="99a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们编写的Java代码被转换成字节码，其中包含JVM在机器上执行的指令。因此，编译器有时会对相互不依赖的指令进行重新排序，以创建最佳的字节代码，这样处理器在执行它们时就不需要进行预测。我们可以用一个例子来看:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="dfa0" class="nb ma iq mx b gy nc nd l ne nf">int a = 1;<br/>int b = 2;<br/><br/>a++;<br/>b++;</span></pre><p id="e479" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果处理器认为可以的话，指令可以像这样重新排序，而不会改变代码的结果。但是为什么会这样呢？这是因为，重新排序可以在更少的CPU周期、更少的内存读写等方面带来一些性能优势。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="d3b1" class="nb ma iq mx b gy nc nd l ne nf">int b = 2;<br/>b++;</span><span id="d53f" class="nb ma iq mx b gy oq nd l ne nf">int a = 1;<br/>a++;</span></pre><h2 id="0141" class="nb ma iq bd mb of og dn mf oh oi dp mj le oj ok ml li ol om mn lm on oo mp op bi translated">2.发生在担保之前</h2><p id="2e2a" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">它对其他非易失性变量的读、写和说，在重新排序后，<strong class="kx ir">发生在</strong>写易失性变量之前，保证<strong class="kx ir">发生在</strong>写易失性变量之前。迷茫？</p><p id="a79a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">见下图。它没有易变变量，因此处理器可以以任何方式对指令进行重新排序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/6b125005e0f3f1864941e8d82a3b5940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*ymDl4jQ2wJCG9r3rWe7U0g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在非易失性存储器中重新排序是可能的。图片来源:作者</p></figure><p id="3515" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，当一个变量被声明为volatile时，其他指令的相对顺序不能相对于volatile变量而改变。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d11e8ce5342dc806a4bd1ba8d016fec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*8WFqNuK1YbaAIgoz2GrPLQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">wrt volatile的相对排序不能更改。图片来源:作者</p></figure><p id="29d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样做是因为，当访问volatile时，在它之前访问的其他变量也被刷新到主存储器，并且如果它们相对于volatile变量被重新排序，则准确的值可能不会被刷新到主存储器，并且程序可能行为不正确。</p><p id="5e1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这防止了相对于volatile变量的重新排序，你可以说这发生在这里作为排序保证之前。</p><h2 id="a6da" class="nb ma iq bd mb of og dn mf oh oi dp mj le oj ok ml li ol om mn lm on oo mp op bi translated">又一个表现</h2><p id="1d9b" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">“发生在之前”语义表示，对volatile的每次写操作都将发生在后续读操作之前。这意味着，只有写操作发生在读操作之前，一个线程写操作的结果才能被另一个线程看到。</p><h1 id="4af0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">个案研究</h1><h2 id="5acf" class="nb ma iq bd mb of og dn mf oh oi dp mj le oj ok ml li ol om mn lm on oo mp op bi translated">一个</h2><p id="a65d" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">让我们举个例子，试着理解为什么在那里使用volatile。一个非常常见的例子是使用双重检查锁定创建的单例。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3feb" class="nb ma iq mx b gy nc nd l ne nf">public class MySingleton {<br/>    private static <strong class="mx ir">volatile</strong> MySingleton <em class="ng">instance</em>;<br/>    public static MySingleton getInstance() {<br/>        if (<em class="ng">instance </em>== null) {<br/>            synchronized (MySingleton.class) {<br/>                if (<em class="ng">instance </em>== null) {<br/>                    <em class="ng">instance </em>= new MySingleton();<br/>                }<br/>            }<br/>        }<br/>        return <em class="ng">instance</em>;<br/>    }<br/><br/>    <em class="ng">// Other methods...<br/></em>}</span></pre><p id="ebab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么这里需要volatile，我就不在这里解释DCL的细节了，让我们看看如果实例没有声明volatile会发生什么。</p><p id="54a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设T1已经创建了单例，下一个线程T2进入getInstance()。我们知道实例的可见性没有保证。它可能会也可能不会看到实例(T2可能会将其视为空)，因为调用“<code class="fe nh ni nj mx b">return instance;</code>”在<code class="fe nh ni nj mx b">synchronised</code>块之外。添加<code class="fe nh ni nj mx b">volatile</code>保证了线程间的可见性。</p><h2 id="9706" class="nb ma iq bd mb of og dn mf oh oi dp mj le oj ok ml li ol om mn lm on oo mp op bi translated">但是，如果我们像这样声明一个单例:</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="8f30" class="nb ma iq mx b gy nc nd l ne nf">public class MySingleton {<br/>    private static MySingleton <em class="ng">instance</em>;<br/>    <strong class="mx ir">public static synchronized</strong> MySingleton getInstance() {<br/>        if (<em class="ng">instance </em>== null) {<br/>            <em class="ng">instance </em>= new MySingleton();<br/>        }<br/>        return <em class="ng">instance</em>;<br/>    }<br/><br/>    <em class="ng">// constructor &amp; methods ...<br/></em>}</span></pre><p id="4d95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里方法是同步的，所以我们不需要声明<code class="fe nh ni nj mx b">volatile</code>,因为<code class="fe nh ni nj mx b">synchronized</code>已经提供了volatile提供的所有保证——所有调用这个方法的线程都将访问<code class="fe nh ni nj mx b">synchronized</code>保护伞下的所有东西。</p><p id="3c33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Volatile是一个非常简单的关键字，但是对它的深入理解可以让你在编写超级高效的代码时获得优势，这些代码在激烈的竞争下也能正常工作。</p><p id="2010" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我以此结束这篇文章。感谢阅读。</p></div></div>    
</body>
</html>