<html>
<head>
<title>How to Use CIFilters and Metal to Make a Custom Camera in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在iOS中使用CIFilters和Metal制作自定义相机</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-cifilters-metal-to-make-a-custom-camera-in-ios-c76134993316?source=collection_archive---------1-----------------------#2020-05-28">https://betterprogramming.pub/using-cifilters-metal-to-make-a-custom-camera-in-ios-c76134993316?source=collection_archive---------1-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="729f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用金属和核心图像为应用的摄像头实现快速高效的滤镜</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cc9e3aa55c77be7516a016b431cf9ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJpG8Egt5PyoQwBoiOPooA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="58a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们都在iOS中见过这样或那样的定制相机。通常情况下，你会希望自己实现一个个人用户界面，而不是使用苹果的内置摄像头选项。但是我们如何让定制相机更进一步呢？过滤器！许多应用程序在相机上使用滤镜来扩展功能。</p><p id="b3ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本教程中，我们将讨论如何给你的相机添加滤镜。本教程旨在向您展示一种快速有效的方法来过滤您的摄像机实时视频和它拍摄的照片。</p><p id="ca57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本教程假设您对如何在iOS中设置相机有一个实用的理解。不是这样？不用担心，你可以看看我之前的教程。事实上，本教程直接建立在该教程的成品代码之上:“<a class="ae lr" href="https://medium.com/@barbulescualex/making-a-custom-camera-in-ios-ea44e3087563" rel="noopener">在iOS </a>中制作自定义相机。”</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e9a7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">起始代码</h1><p id="afbf" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">启动程序代码可以在我的GitHub上找到:<a class="ae lr" href="https://github.com/barbulescualex/iOSMetalCamera" rel="noopener ugc nofollow" target="_blank">barbulesculex/IOs metal camera</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/7baa20ead04d2d42dfce25eaf477c13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fysiGWqpzuFRfjir6NRWw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="796b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你运行应用程序，你会看到我们有一个非常基本的相机设置。我们对前后摄像头都使用标准的<code class="fe mx my mz na b">wideAngleCamera</code>。采集会话使用照片预置，采集设备本身没有配置。我们使用预览层来显示来自捕获会话的实时提要。最后，我们使用从视频数据输出对象获取的视频帧来拍摄照片。</p><p id="34f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你从未使用过<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/avfoundation/avcapturevideodataoutput" rel="noopener ugc nofollow" target="_blank">AVCaptureVideoDataOutput</a></code>，它所做的只是从捕获会话中返回视频帧，当用户拍照时，你可以用它来转换成<code class="fe mx my mz na b">UIImage</code>。</p><p id="714d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">UI设置发生在<code class="fe mx my mz na b">ViewController+Extras.swift</code>，所有主要逻辑发生在<code class="fe mx my mz na b">ViewController.swift</code>。花几分钟时间试验一下，看看代码设置。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="07dd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">背景思维</h1><p id="bad1" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">有两种方法可以从捕获会话中拍照。第一种方法是使用<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/avfoundation/avcapturephotooutput" rel="noopener ugc nofollow" target="_blank">AVPhotoCaptureOutput</a></code>，这是一个输出对象，它使得从相机拍摄照片变得非常容易。第二种方法是使用一个<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/avfoundation/avcapturevideodataoutput" rel="noopener ugc nofollow" target="_blank">AVCaptureVideoDataOutput</a></code>,我们从中获取原始视频数据，并从中拍摄一张照片，即捕捉一帧。</p><p id="f942" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们想一想。当前的设置使用<code class="fe mx my mz na b">AVCaptureVideoDataOutput</code>获取原始视频数据，我们还使用<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/avfoundation/avcapturevideopreviewlayer" rel="noopener ugc nofollow" target="_blank">AVCaptureVideoPreviewLayer</a></code>向用户显示摄像机看到的内容。</p><p id="4f58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本教程中，我们希望将自定义滤镜应用于相机。当然，这可以在用户按下相机按钮后完成，但是您希望用户能够通过相机看到效果。这里我们唯一的选择是不依赖于<code class="fe mx my mz na b">AVCaptureVideoPreviewLayer</code>，而是依赖于<code class="fe mx my mz na b">AVCaptureVideoDataOutput</code>来处理带有我们的效果的帧，并将它们实时呈现给用户。</p><p id="e59e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，当您真正需要的只是一个自定义的相机用户界面时，标准的预览层+照片捕捉输出是很好的。但是当您需要实际处理和应用效果到摄像机时，使用视频数据输出来接管这两个角色是很好的。</p><h2 id="0af8" class="nb ma iq bd mb nc nd dn mf ne nf dp mj le ng nh ml li ni nj mn lm nk nl mp nm bi translated">过滤器+金属与全金属</h2><p id="f524" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">如果你不熟悉<a class="ae lr" href="https://developer.apple.com/metal/" rel="noopener ugc nofollow" target="_blank"> Metal </a>，它是在Cocoa设备上使用GPU的框架。一个<em class="nn">金属视图</em>可以被认为是显示GPU渲染内容的视图。现在，iOS上的所有视图都使用GPU进行渲染，但金属视图很特殊，因为你可以在更低的级别上控制渲染内容。</p><p id="7285" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你不熟悉<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/coreimage/cifilter" rel="noopener ugc nofollow" target="_blank">CIFilter</a></code> <a class="ae lr" href="https://developer.apple.com/documentation/coreimage/cifilter" rel="noopener ugc nofollow" target="_blank"> s </a>，它们实际上只是将滤镜应用于图像的对象(是的，就是这么简单！).</p><p id="6f6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么我们如何应用效果呢？有多种方法可以做到这一点。</p><ul class=""><li id="1b1a" class="no np iq kx b ky kz lb lc le nq li nr lm ns lq nt nu nv nw bi translated">使用预定义的<code class="fe mx my mz na b">CIFilter</code> s。这些是内置的插件和插件对象。</li><li id="fdaa" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated">使用<a class="ae lr" href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf" rel="noopener ugc nofollow" target="_blank">金属着色语言</a>创建你自己的<code class="fe mx my mz na b">CIFilter</code>。这与内置过滤器相同，只是您实际上自己编写了过滤器的代码。Metal着色语言是你如何编写自己的指令，供Metal框架中的GPU使用。</li><li id="d250" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated">使用金属制作你自己的纹理。这与上面的概念相同，但是随着范围的扩大，您可以做更多的事情，而不仅仅是添加过滤器。</li></ul><p id="c3c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">两种方式(<code class="fe mx my mz na b">CIFilter</code> s或Metal)都将纹理渲染到金属视图中。区别在于你处理图像的方式。<code class="fe mx my mz na b">CIFilter</code> s是一个更简单的高级抽象，预装了大量过滤器。但是正如我提到的，你可以创造你自己的。使用全金属会给你更多的灵活性，在你需要在图像上渲染东西的应用中会更有用(而不是仅仅给图像添加一个滤镜)。</p><p id="a074" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就性能而言，我们想从中获得什么？我们希望所有的处理都在GPU上进行。显而易见，全金属方法固有地给我们带来了这一点，但<code class="fe mx my mz na b">CIFilter</code>s+金属方法将带给我们几乎相同的性能。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="df72" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第一部分。通过MetalKit显示框架</h1><p id="2ff5" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">在第一部分中，我们将离开<code class="fe mx my mz na b">AVCaptureVideoPreviewLayer</code>，自己显示结果。</p><p id="3092" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们考虑一下我们正在用这些数据框做什么。当用户按下相机按钮时，我们从该帧中创建一个<code class="fe mx my mz na b">UIImage</code>。一种简单的显示帧的方法是用一个<code class="fe mx my mz na b">UIImageView</code>来更新每一帧的图像。这显然对性能非常不利。这样的显示管道走的是CPU(我们拿回来的帧)- &gt; GPU ( <code class="fe mx my mz na b">CIImage</code> ) - &gt; CPU ( <code class="fe mx my mz na b">UIImage</code>)。这就是为什么<code class="fe mx my mz na b">MetalKit</code>视图是处理这个问题的最佳方式。</p><p id="e862" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不会在这里解释金属超级深入，因为我已经有一个教程，如果你有兴趣了解更多:“<a class="ae lr" href="https://medium.com/better-programming/making-your-first-circle-using-metal-shaders-1e5049ec8505" rel="noopener">如何使用金属着色器</a>制作你的第一个圆。”</p><h2 id="0b1a" class="nb ma iq bd mb nc nd dn mf ne nf dp mj le ng nh ml li ni nj mn lm nk nl mp nm bi translated"><strong class="ak">第一节。设置金属视图</strong></h2><p id="78e7" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们有一个使用标准预览层的相机应用程序的基本模板。我们现在想要为我们将使用的不同类型的视图删除它，一个<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metalkit/mtkview" rel="noopener ugc nofollow" target="_blank">MTKView</a></code>。</p><blockquote class="oc od oe"><p id="1a54" class="kv kw nn kx b ky kz jr la lb lc ju ld of lf lg lh og lj lk ll oh ln lo lp lq ij bi translated">"<code class="fe mx my mz na b">MTKView</code>类提供了一个金属感知视图的默认实现，你可以用它来使用金属渲染图形并在屏幕上显示它们。"</p></blockquote><p id="aa2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您可以从描述中推断的那样，我们实际上将把过滤后的帧渲染到这个视图中。</p><p id="89cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe mx my mz na b">ViewController.swift</code>中，我们将移除<code class="fe mx my mz na b">setupPreviewLayer()</code>，并添加一个实例变量来存储我们的金属视图。最后，要在应用程序内部使用Metal，您需要导入<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metalkit" rel="noopener ugc nofollow" target="_blank">MetalKit</a></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="05c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe mx my mz na b">ViewController.swift+Extras.swift</code>中，我们只是将金属视图添加到视图层次中，并使其横跨整个屏幕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e26b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意它只是<code class="fe mx my mz na b">UIView</code>的一个子类。将它添加到UI中不需要特别考虑。</p><p id="4fdf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，如果你运行应用程序，你仍然可以像一切正常一样拍照；我们只是没有预览层了。</p><p id="5280" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们需要实际设置金属视图本身。</p><p id="b9c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">连接到设备的GPU </strong></p><p id="87cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一步是metal视图通过渲染内容来工作，并使用GPU将内容渲染到屏幕上。<code class="fe mx my mz na b">MetalKit</code>框架中的GPU由<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metal/mtldevice" rel="noopener ugc nofollow" target="_blank">MTLDevice</a></code>表示，类似于<code class="fe mx my mz na b">AVFoundation</code>框架中的摄像头或麦克风由<code class="fe mx my mz na b">AVCaptureDevice</code>表示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="585e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">告诉MTKView如何自我更新</strong></p><p id="6199" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可以在<code class="fe mx my mz na b">MTKView</code>文档中的“<a class="ae lr" href="https://developer.apple.com/documentation/metalkit/mtkview" rel="noopener ugc nofollow" target="_blank">配置绘图行为</a>”<em class="nn"/>下找到。每次有新的帧要显示时，我们都要更新<code class="fe mx my mz na b">MTKView</code>。所以我们将使用“显式绘制”选项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0be9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">创建一个命令队列</strong></p><p id="e074" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了将指令发送到GPU进行处理，我们需要一个向下发送指令的管道。这条管道是由一个<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metal/mtlcommandqueue" rel="noopener ugc nofollow" target="_blank">MTLCommandQueue</a></code>创建的。</p><blockquote class="oc od oe"><p id="d368" class="kv kw nn kx b ky kz jr la lb lc ju ld of lf lg lh og lj lk ll oh ln lo lp lq ij bi translated">"一个<code class="fe mx my mz na b">MTLCommandQueue</code>对象用于为一个<code class="fe mx my mz na b">MTLDevice</code>执行的命令缓冲区的有序列表排队。"</p></blockquote><p id="7613" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您从<code class="fe mx my mz na b">MTLDevice</code>对象创建这个命令队列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f8e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">向GPU发送指令</strong></p><p id="4a0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了一个直接到GPU的队列，我们如何向它发送命令呢？我们向它发送命令到哪里？嗯，<code class="fe mx my mz na b">MTKView</code>有一个<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metalkit/mtkviewdelegate" rel="noopener ugc nofollow" target="_blank">MTKViewDelegate</a></code>，它的目的是响应视图的绘制事件。我们就是在这里发出命令的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9c7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们遵循的第一个函数告诉我们金属视图的可绘制性已经改变。什么是可画的？</p><p id="e805" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metal/mtldrawable" rel="noopener ugc nofollow" target="_blank">MTLDrawable</a></code></p><blockquote class="oc od oe"><p id="7be0" class="kv kw nn kx b ky kz jr la lb lc ju ld of lf lg lh og lj lk ll oh ln lo lp lq ij bi translated">“可显示的资源，可以呈现或写入…能够在屏幕上显示内容。当你想用金属渲染图像并把它们呈现在屏幕上时，你可以使用可绘制对象。”</p></blockquote><p id="ec32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">金属视图将有一个默认的可绘制对象，我们很快就会看到，我们可以将我们的<code class="fe mx my mz na b">CIImage</code>(我们从相机中获取的视频帧制作)渲染到其中。</p><p id="71a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果您有使用Metal的经验，通常下一步将是使用渲染过程描述符和命令编码器制作一个管道，以便能够将指令编码到缓冲区中。因为我们使用的是<code class="fe mx my mz na b">CIImage</code> s，所以我们可以使用<code class="fe mx my mz na b">CIContext</code>将命令写入缓冲区，耶！</p><h2 id="c247" class="nb ma iq bd mb nc nd dn mf ne nf dp mj le ng nh ml li ni nj mn lm nk nl mp nm bi translated"><strong class="ak">第二节。通过MTKView显示摄像机画面</strong></h2><p id="f12b" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">这勾起了我的回忆。早在2018年，我就在Stack Overflow上发表了这篇文章，当时我使用了一个<code class="fe mx my mz na b">UIImageView</code>来显示相机馈送，并错误地使用了<code class="fe mx my mz na b">CIFilter</code>s:“<a class="ae lr" href="https://stackoverflow.com/questions/51922595/confusion-about-cicontext-opengl-and-metal-swift-does-cicontext-use-cpu-or-g" rel="noopener ugc nofollow" target="_blank">关于CIContext、OpenGL和Metal (SWIFT)的混淆。CIContext默认使用CPU还是GPU？</a></p><p id="11e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如堆栈溢出用户DFD在他的回答中提到的，一个<code class="fe mx my mz na b">CIImage</code>(我们从视频帧中创建的东西)只是一个图像的配方，每当我们转换到<code class="fe mx my mz na b">CGImage</code>和<code class="fe mx my mz na b">UIImage</code>时，我们都会遇到CPU，所以我们希望只有在必要时才这样做。对我们来说，只有当用户实际拍摄图像时才有必要。我们将存储一个对我们已经创建的<code class="fe mx my mz na b">CIImage</code>的引用，并在我们的金属视图上调用<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metalkit/mtkview/1535943-draw" rel="noopener ugc nofollow" target="_blank">draw</a></code>来接管并渲染金属视图中的图像。</p><p id="b72b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/coreimage" rel="noopener ugc nofollow" target="_blank">CoreImage</a></code>是一个图像处理和分析框架。它有自己的图像表示，称为<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/coreimage/ciimage" rel="noopener ugc nofollow" target="_blank">CIImage</a></code>，这是一个图像的配方。在这个图像配方上，你可以应用<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/coreimage/cifilter" rel="noopener ugc nofollow" target="_blank">CIFilter</a></code> <a class="ae lr" href="https://developer.apple.com/documentation/coreimage/cifilter" rel="noopener ugc nofollow" target="_blank"> s </a>，这将在下一部分中进行。CoreImage框架的第三个基本类是<code class="fe mx my mz na b">CIContext</code>。</p><p id="4750" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/coreimage/cicontext" rel="noopener ugc nofollow" target="_blank">CIContext</a></code></p><blockquote class="oc od oe"><p id="385d" class="kv kw nn kx b ky kz jr la lb lc ju ld of lf lg lh og lj lk ll oh ln lo lp lq ij bi translated">"用于<strong class="kx ir">渲染图像处理结果</strong>并执行图像分析的评估上下文."</p></blockquote><p id="d378" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个关键点是我们真正感兴趣的，也就是渲染图像。事实证明，我们可以直接渲染金属纹理。什么是金属质感？我们很快会谈到这一点。</p><p id="3819" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先让我们创建一个。有多种方法可以初始化<code class="fe mx my mz na b">CIContext</code>。其中一种方法是使用金属。这实际上是告诉它使用什么GPU设备来实现其内置的处理和评估功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="fa62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们需要在我们的类中存储一个对每个框架的引用，这样当我们在metal视图上调用draw时，它就知道需要使用什么框架。</p><p id="3768" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何将<code class="fe mx my mz na b">CIImage</code>渲染到我们的金属视图中？<code class="fe mx my mz na b">CIContext</code>有一整组渲染图像的函数，其中，我们遇到一个可以用的。</p><pre class="kg kh ki kj gt ok na ol om aw on bi"><span id="ae21" class="nb ma iq na b gy oo op l oq or"><a class="ae lr" href="https://developer.apple.com/documentation/coreimage/cicontext/1438026-render" rel="noopener ugc nofollow" target="_blank">func</a> render(_ image: <a class="ae lr" href="https://developer.apple.com/documentation/coreimage/ciimage" rel="noopener ugc nofollow" target="_blank">CIImage</a>, <br/>         to texture: <a class="ae lr" href="https://developer.apple.com/documentation/metal/mtltexture" rel="noopener ugc nofollow" target="_blank">MTLTexture</a>, <br/>      commandBuffer: <a class="ae lr" href="https://developer.apple.com/documentation/metal/mtlcommandbuffer" rel="noopener ugc nofollow" target="_blank">MTLCommandBuffer</a>?, <br/>             bounds: <a class="ae lr" href="https://developer.apple.com/documentation/coregraphics/cgrect" rel="noopener ugc nofollow" target="_blank">CGRect</a>, <br/>         colorSpace: <a class="ae lr" href="https://developer.apple.com/documentation/coregraphics/cgcolorspace" rel="noopener ugc nofollow" target="_blank">CGColorSpace</a>)</span></pre><p id="e692" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们剖析它的参数，这样我们就知道如何继续。</p><ul class=""><li id="d2df" class="no np iq kx b ky kz lb lc le nq li nr lm ns lq nt nu nv nw bi translated"><code class="fe mx my mz na b">image</code> —那很简单；这是我们为每一帧创建的<code class="fe mx my mz na b">CIImage</code>。</li><li id="2939" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated"><code class="fe mx my mz na b">texture</code> —我说我们正在通过金属视图将它渲染到屏幕上，并提到我们将使用它的可绘制性。我们实际上“画”到的是金属视图是住房的可画的纹理。GPU意义上的纹理是用于映射到对象上的图像。想想视频游戏中的纹理包。</li><li id="2869" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated"><code class="fe mx my mz na b">commandBuffer </code> —之前我们创建了一个命令队列，以便向GPU发送指令。这些“指令”被表示为命令缓冲区，并从命令队列中创建。</li><li id="a420" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated"><code class="fe mx my mz na b">bounds</code> —这是在纹理上绘制图像的<code class="fe mx my mz na b">GCRect</code>。</li><li id="f240" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated"><code class="fe mx my mz na b">colorSpace</code> —这告诉<code class="fe mx my mz na b">CIContext</code>如何解释来自<code class="fe mx my mz na b">CIImage</code>的颜色信息。对我们来说，它只是标准的RGB颜色。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="dcb0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里发生了很多事情。</p><p id="a693" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，在我们获取视频帧的输出捕获中，如果用户没有按下相机按钮，我们不会立即返回，而是先存储<code class="fe mx my mz na b">CIImage</code>，然后在我们的metal视图上调用draw。</p><p id="30be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在draw函数中，我们所做的正是我们之前讨论过的。我们从命令队列中创建一个命令缓冲区来编码指令。我们确保我们有一个图像和金属视图的可绘制性。然后，我们调用上下文中的render函数，传递必要的参数。之后，我们告诉命令缓冲区在哪里显示结果，并提交执行。</p><p id="d031" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，在setup metal中，我们将属性<code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/metalkit/mtkview/1535998-framebufferonly" rel="noopener ugc nofollow" target="_blank">framebufferOnly</a></code>设置为<code class="fe mx my mz na b">true</code>，这允许我们直接写入metal视图的可绘制对象的纹理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/c53fb18ce998feb5287a2da3076d97ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nak5qC6t_jDdDEEbmR8T9w.png"/></div></div></figure><p id="f9aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果我们运行它，我们将得到我们的帧渲染到屏幕上，最好的部分是它的速度很快！从资源利用率来看，我们看到它的性能非常好。有一个小的UI问题:视频流没有正确居中。它粘在底部了。这可以很容易地通过向上移动原点<em class="nn"> y </em>来改变，使其居中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/edaa8cb31afb67956111c1297916559e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMgSS1vjpnI3DfgnQWF9cQ.png"/></div></div></figure><p id="3904" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在已经使用金属完美地复制了<code class="fe mx my mz na b">AVVideoPreviewLayer</code>，而没有牺牲任何性能。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="56d8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">第二部分。添加过滤器</h1><p id="7afa" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">下一部分相当短——建立金属视图是最难的部分。到目前为止，我们从相机到屏幕的步骤是<code class="fe mx my mz na b">CMSampleBuffer</code>(从<code class="fe mx my mz na b">AVVideoCaptureDateOutput</code>回调)- &gt; <code class="fe mx my mz na b">CIImage</code> - &gt; <code class="fe mx my mz na b">MTLTexture</code>。</p><p id="b3e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从视频帧创建的<code class="fe mx my mz na b">CIImage</code>既用于我们自己使用Metal定制的视频预览，也用于保存用户拍摄的图像。如果我们想要应用过滤器，我们所要做的就是在使用<code class="fe mx my mz na b">CIImage</code>渲染到屏幕上之前和/或在用户拍照时保存之前应用它们。</p><p id="67ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mx my mz na b"><a class="ae lr" href="https://developer.apple.com/documentation/coreimage/cifilter" rel="noopener ugc nofollow" target="_blank">CIFilter</a></code></p><blockquote class="oc od oe"><p id="8af0" class="kv kw nn kx b ky kz jr la lb lc ju ld of lf lg lh og lj lk ll oh ln lo lp lq ij bi translated">通过处理一个或多个输入图像或通过产生新的图像数据来产生图像的图像处理器。</p><p id="4f9d" class="kv kw nn kx b ky kz jr la lb lc ju ld of lf lg lh og lj lk ll oh ln lo lp lq ij bi translated">"<code class="fe mx my mz na b">CIFilter</code>类产生一个<code class="fe mx my mz na b">CIImage</code>对象作为输出."</p></blockquote><p id="2db6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一步再简单不过了。是为图像添加滤镜的高级抽象类，并且已经有了大量的预烘焙选项！</p><p id="0c67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个过滤器接受至少一个参数(一个<code class="fe mx my mz na b">CIImage</code>)。一些过滤器具有额外的输入参数，例如强度、半径等。由于这些过滤器有如此多的选项，所有的参数都接受描述使用哪个过滤器和想要改变什么输入的字符串。</p><p id="a376" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://cifilter.io" rel="noopener ugc nofollow" target="_blank">核心图像过滤参考</a> <strong class="kx ir"> </strong>包含了你需要的所有信息。它拥有所有可用的预定义过滤器，因此您可以按名称创建过滤器。它也有每个过滤器的所有输入选项，所以你可以设置它们。</p><p id="f2ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了向您展示它有多简单，将只有一个代码片段，然后我们就完成了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="19fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，我们只做了很少的改动。我们声明了两个过滤器，并在设置我们的<code class="fe mx my mz na b">CIContext</code>时设置了它们。然后，我们声明了一个新函数，它接受一个<code class="fe mx my mz na b">CIImage</code>并将两个滤波器链接在一起，方法是将图像设置为滤波器的输入，然后从滤波器中获取滤波后的图像。在<code class="fe mx my mz na b">captureOutput</code>回调函数中，我们用一个过滤过的函数替换了之前使用的<code class="fe mx my mz na b">CIImage</code>。</p><p id="bd05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我选择结合一个渐变滤镜和一个棕褐色滤镜来创建一个漂亮的复古色调。</p><p id="4b96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你运行这个应用程序，你现在在iOS中就有了自己的快速高效的定制相机。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/4da4dbf4630b241a6acbc8507546d2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9QZCaKUA8K8O8EonkPmuw.png"/></div></div></figure><p id="42c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整的零件代码可以在我的GitHub上找到:<a class="ae lr" href="https://github.com/barbulescualex/iOSMetalCamera" rel="noopener ugc nofollow" target="_blank">barbulesculex/IOs metal camera</a>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="50c9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">后续步骤</h1><p id="8cc4" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">从这里你能去哪里？</p><ul class=""><li id="a2cc" class="no np iq kx b ky kz lb lc le nq li nr lm ns lq nt nu nv nw bi translated">建立一个用户界面来改变过滤器。这可以是从使用预定义的输入参数选择不同的过滤器到使用滑块来更改过滤器参数。</li><li id="3388" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated">视频！我们从摄像机中获取的每一帧图像，我们都会过滤并显示在金属视图中。捕捉视频虽然不简单，但也不太难。它所暗示的是，你把视频帧捆绑在一起成为一个文件。这也是探索在iOS中使用音频设备的绝佳机会。</li><li id="1557" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated">如果你对苹果的产品不满意，为什么不自己做呢？</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6742" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="ea1e" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">如果你喜欢这个教程，并想了解更多关于金属的知识，请查看我对使用金属着色器的介绍，“<a class="ae lr" href="https://medium.com/better-programming/making-your-first-circle-using-metal-shaders-1e5049ec8505" rel="noopener">如何使用金属着色器</a>制作你的第一个圆。”</p><p id="f26b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">已经熟悉金属，但想看看如何利用它做一些很酷的事情？查看我的音频可视化教程，“Swift中的音频可视化使用Metal和Accelerate(第1部分)”</p><p id="a57d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一如既往，如果你有任何问题或意见，请在下面留下。</p></div></div>    
</body>
</html>