<html>
<head>
<title>Type Yoga</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">瑜伽类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/type-yoga-typing-flexible-functions-with-typescripts-advanced-features-b5a282878b74?source=collection_archive---------3-----------------------#2019-07-17">https://betterprogramming.pub/type-yoga-typing-flexible-functions-with-typescripts-advanced-features-b5a282878b74?source=collection_archive---------3-----------------------#2019-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5582" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用TypeScript的高级功能键入灵活的函数</h2></div><p id="4c10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个月前，我决定在我的库中添加TypeScript绑定。如果您不熟悉，<em class="lc"> shades </em>提供了一种快速和声明性地描述对象路径的方法，可以用来提取它的值，甚至不变地“修改”它(通过创建一个值已更改的新对象)。如果你想更多地了解这些坏男孩(我认为你应该了解)，你可以看看我在Reactathon的演讲。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="a797" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们如何输入如此灵活的函数呢？例如，<code class="fe lk ll lm ln b"><a class="ae lb" href="https://github.com/jamesmcnamara/shades#get" rel="noopener ugc nofollow" target="_blank">get</a></code> <em class="lc"> </em>可以将代表路径的可变数量的不同输入输入到一个对象中，并且仍然推断出该路径末端的输出类型:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/0efbaa8efade7e25dbcf7e040dfdc174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5BNT1MvGCXXZ2pMZYhbMw.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">魔法</p></figure><p id="daf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图中，<code class="fe lk ll lm ln b">get</code> <em class="lc"> </em>正在创建一个函数，该函数获取一个<code class="fe lk ll lm ln b">User</code>对象，提取其<code class="fe lk ll lm ln b">friends</code> <em class="lc"> </em>属性，过滤出仅具有<code class="fe lk ll lm ln b">goldMember</code> <em class="lc"> </em>状态为<code class="fe lk ll lm ln b">true</code>的用户，并从该列表中传递并选择出每个黄金会员的姓名。那最终的结果是什么？一个<code class="fe lk ll lm ln b">string[]</code>。</p><p id="1282" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更重要的是，<code class="fe lk ll lm ln b">get</code>在传入 a <code class="fe lk ll lm ln b">User</code> <strong class="kh ir"> </strong>之前创建了完成所有<strong class="kh ir">的函数。这意味着它不知道它将对一个<code class="fe lk ll lm ln b">User</code>进行类型检查。事实上，任何具有<code class="fe lk ll lm ln b">friends</code>属性的对象，即具有<code class="fe lk ll lm ln b">goldMember</code> <em class="lc"> </em>和<code class="fe lk ll lm ln b">name</code> <em class="lc"> </em>属性的对象列表，都将使用新的getter函数，并生成该新对象上的<code class="fe lk ll lm ln b">name</code>内容列表。</strong></p><p id="77c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们如何给如此普通的东西赋予一个有意义的类型呢？嗯，如果我们看看这种新型吸气剂，它有点吓人。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lz"><img src="../Images/f78f032f092300f2c35de323b2d6a1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEZanuCP8ChWJUwejrlccw.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">Wowzers</p></figure><p id="1c25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请继续关注我几分钟，我们将构建这个函数类型的完整版本，包括所有的附加功能。如果你从未用过<em class="lc">墨镜，也不用担心。我们将从头开始构建一切，我们将慢慢进入这个池，这样我们就不会失去任何人。您所需要的只是熟悉TypeScript及其一些特性。</em></p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="7a5d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">婴儿学步</h1><p id="ba87" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们将从创建一个简化版本的<code class="fe lk ll lm ln b">get</code>开始。这个<code class="fe lk ll lm ln b">get</code>只接受代表键的字符串，并产生一个新函数，该函数可以接受某个对象并从该对象中提取路径。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8b294204f6752f4a068ec21605fbeb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*wtfltQ1lRuejA6NupeBwow.png"/></div></figure><p id="16cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始输入之前，我们将创建一个名为<code class="fe lk ll lm ln b">HasKey</code>的助手类型，这样就不会太混乱了。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/32ed05854a09cc7f56d31bca66b5151b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*W6eikZBSguQrzqOODnurNg.png"/></div></figure><p id="9763" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">HasKey</code> <strong class="kh ir"> </strong>是<a class="ae lb" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" rel="noopener ugc nofollow" target="_blank">映射类型</a>。它表示一个给定的字符串<code class="fe lk ll lm ln b">K</code>映射到某个值的对象。注意，它带有第二个可选参数<code class="fe lk ll lm ln b">V</code>，让我们在<code class="fe lk ll lm ln b">K</code>指定类型，但它默认为<code class="fe lk ll lm ln b">any</code>。</p><p id="91dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们想要定义一个类型<code class="fe lk ll lm ln b">HasName</code> <strong class="kh ir"> </strong>，它有一个<code class="fe lk ll lm ln b">name</code>属性映射到一个<code class="fe lk ll lm ln b">string</code> <strong class="kh ir">，</strong>我们可以这样做:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/04d441be5e9876879535e398027f36fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*FIz2dBuHVCDLjTPw9b1u6A.png"/></div></figure><p id="a869" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">HasKey</code>是一个很一般的类型，一开始看起来不是特别有用。诀窍是我们可以在函数中使用它作为约束来保证我们的输入有我们需要的键。有了这些，我们就可以编写我们的第一个<code class="fe lk ll lm ln b">get</code> <em class="lc"> </em>函数了。</p><h2 id="bcf0" class="nh mi iq bd mj ni nj dn mn nk nl dp mr ko nm nn mt ks no np mv kw nq nr mx ns bi translated">V1:线一直往下</h2><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/075c39365ca4accb950e76172fbadb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*PK0lg_SDdoZmYpOZ0IL7mg.png"/></div></figure><p id="8837" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的函数接受一个字符串<code class="fe lk ll lm ln b">K</code>并产生一个新函数，该函数接受任何对象，只要该对象将<code class="fe lk ll lm ln b">K</code>作为键。这就是<code class="fe lk ll lm ln b">HasKey</code>的神奇之处；我们可以用它作为一个<code class="fe lk ll lm ln b">extends</code>子句的一部分，来强制我们得到的任何东西都有我们想要的密钥。那么结果类型就是<code class="fe lk ll lm ln b">S</code>上<code class="fe lk ll lm ln b">K</code>键的类型。</p><p id="bbb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以将这些堆叠在一起，得到嵌套的访问器:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c427585541f76f4c769c07e4b8509de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*3d6zaqN_INARbOfZjD6HuQ.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">嵌套玩偶</p></figure><p id="7fec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意我们现在如何使用可选的第二个参数<code class="fe lk ll lm ln b">HasKey</code>？我们指定我们的输入<code class="fe lk ll lm ln b">S</code>必须是一个带有某个键<code class="fe lk ll lm ln b">K1</code>的对象，它本身是一个带有某个键<code class="fe lk ll lm ln b">K2</code>的对象<em class="lc"> </em>。我们可以不断重复这个过程，以保证任何数量的关键点和任何深度路径。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="de59" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">s[现在怎么办？]</h1><p id="a175" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">返回类型中的那个<code class="fe lk ll lm ln b">S[K]</code>可能不熟悉。它被称为索引类型。这是TypeScript的一个内置特性，它允许我们在事先不知道某个对象的键的情况下一般地引用该键的类型。虽然它在我们上面的例子中工作得很好，但坏消息是当我们开始将更多抽象路径如<a class="ae lb" href="https://github.com/jamesmcnamara/shades#traversals" rel="noopener ugc nofollow" target="_blank">遍历</a>和<a class="ae lb" href="https://github.com/jamesmcnamara/shades#virtual-lenses" rel="noopener ugc nofollow" target="_blank">虚拟透镜</a>混合到我们的getters中时，它将无法处理。</p><p id="dc71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好消息是，TypeScript为我们提供了滚动我们自己的索引类型所需的工具，这些索引类型将与我们需要的任何值组合一起工作。银弹是<a class="ae lb" href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types" rel="noopener ugc nofollow" target="_blank">条件类型</a>。</p><p id="3dad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">条件类型就像类型的if语句。事实上，他们正是如此。它们让你问一个关于类型的问题，并根据答案返回不同的类型。我们可以用它来创建我们自己的索引类型<code class="fe lk ll lm ln b">KeyAt</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nu"><img src="../Images/b96a0722e61d4c4e1b3c8b4f368dd8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*19iwlmI0vEep1ArvBCey3w.png"/></div></div></figure><p id="e582" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">KeyAt</code>接受一个对象和一个字符串，如果<em class="lc"> </em>该对象将该字符串作为键，则返回该键的类型。如果没有，它只是返回<code class="fe lk ll lm ln b">never</code>，一个(顾名思义)永远不可能存在的内置类型。当密钥丢失时，<code class="fe lk ll lm ln b">KeyAt</code>仍然可以做<strong class="kh ir">某事，</strong> <em class="lc"> </em>这一事实将允许我们在这样的情况下使用它:我们知道一个对象将有正确的密钥，但是TS在没有一点帮助的情况下无法证明它。这将是编写更复杂的<code class="fe lk ll lm ln b">get</code>函数的关键。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/5e69a55e87bc039fcba85a0694c911b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*MS0Brx-y06K9NBNXuhdyrw.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">KeyAt的作用类似于类型的函数</p></figure><h2 id="58c1" class="nh mi iq bd mj ni nj dn mn nk nl dp mr ko nm nn mt ks no np mv kw nq nr mx ns bi translated">V2:打他们</h2><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nx"><img src="../Images/9a9dd27252afa5a691784d93ce0077f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUndGfTd6FfrvGoRV1w7yw.png"/></div></div></figure><p id="33da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个版本几乎相同，除了它使用了我们在新的<code class="fe lk ll lm ln b">KeyAt</code>中使用的<code class="fe lk ll lm ln b">HasKey</code>的嵌套技巧。<strong class="kh ir"> </strong>注意嵌套发生在相反的方向:我们询问什么对象是<code class="fe lk ll lm ln b">KeyAt&lt;S, K1&gt;</code>，从结果中，我们将提取<code class="fe lk ll lm ln b">K2</code>。</p><p id="d886" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经创建了一个函数，它接受一个或两个字符串，并产生一个访问器函数，该函数可以接受任何具有给定键的对象，并从中提取正确的类型。我们已经创造了一些相当灵活和真实的世界，我们应该给自己拍一下背。</p><p id="6ab1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们到了真正要开始用煤气做饭的时候了。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="e263" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak">遍历</strong></h1><p id="d7a7" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated"><a class="ae lb" href="https://github.com/jamesmcnamara/shades#traversals" rel="noopener ugc nofollow" target="_blank"> Traversals </a>表示一种方法，用于过滤我们沿途遇到的对象集合，并继续从集合中的单个对象中提取值，将结果汇总到输出的集合中。例如，在我们的intro中，<code class="fe lk ll lm ln b">matching</code>是一个遍历，它将<code class="fe lk ll lm ln b">friends</code>列表过滤为仅具有黄金会员身份的用户，然后我们能够将他们所有的名字提取到一个列表中。这种行为在<em class="lc">阴影</em>中是最引人注目的，所以我们肯定想看看如何键入它。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/79f59aa4cf91d8b6c53e11dca2fd3e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*_4lHUFDGFLgwd39vYEP6Fw.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">什么是<strong class="bd nw">遍历</strong>？嗯这只是一个<strong class="bd nw">遍历</strong></p></figure><p id="84b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">Traversal</code>描述一个遍历对象的形状。奇怪的是，我们实际上并不需要它来容纳任何东西。它只是作为一个标记，给<code class="fe lk ll lm ln b">get</code>一个信号，表明路径中的这个位置将是<code class="fe lk ll lm ln b">Item</code>的集合。正因为如此，我们将能够使用同一个对象来处理任何集合类型(比如一个<strong class="kh ir">数组</strong>、一个<strong class="kh ir">对象</strong>、ES2015 <strong class="kh ir">映射</strong> s和<strong class="kh ir">集合</strong> s，甚至是不可变的. js集合)。对于我们的例子，我们将只使用数组来保持简单(目前)。</p><h2 id="60e5" class="nh mi iq bd mj ni nj dn mn nk nl dp mr ko nm nn mt ks no np mv kw nq nr mx ns bi translated">V3:遍历和字符串进入酒吧</h2><p id="8fd7" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">让我们从一个激励人心的例子开始。我们将把用户的<code class="fe lk ll lm ln b">friends</code>过滤到那些拥有五个以上朋友的人，然后将他们的名字提取到一个列表中。我们将使用函数<code class="fe lk ll lm ln b">matching</code>进行过滤，该函数从<code class="fe lk ll lm ln b">A</code>到<code class="fe lk ll lm ln b">boolean</code>接受一个过滤函数，并产生一个<code class="fe lk ll lm ln b">Traversal&lt;A&gt;</code>:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/3831098c8ee4dd7a1f2bd4df913125f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*INRwlshRrbOIHjNXjbEyyQ.png"/></div></figure><p id="aa42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，让我们考虑一下这个问题。我们首先要遍历我们的集合，这意味着我们以某种方式过滤数组。但是过滤根本不会改变输出类型，所以到目前为止，一帆风顺。但是接下来我们要提取出名字，所以我们会得到一个字符串列表。这方面的天真尝试会遇到问题:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e92f613577024b9859507edb0b951295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*LAes4mFmIsKP0T7MRp-kZw.png"/></div></figure><p id="a59a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从返回类型中的<code class="fe lk ll lm ln b">KeyAt</code>得到一个<code class="fe lk ll lm ln b">never</code>类型。这是因为<code class="fe lk ll lm ln b">S</code>并不代表<code class="fe lk ll lm ln b">User</code>对象。这是一个<code class="fe lk ll lm ln b">User[]</code>。我们能从中提取的唯一密钥是类似于<code class="fe lk ll lm ln b">length</code>、<code class="fe lk ll lm ln b">map</code>等的东西。我们可以用一些技巧来解决这个问题:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/cbe1f8031142bdc3d511b3c40cf365ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*mQbitDLvAnZlVvjd_FR5hQ.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">如果没有类型签名，沃尔多在哪里</p></figure><p id="124c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你看出区别了吗？我们改变了我们的类型约束<code class="fe lk ll lm ln b">S</code>来约束集合的<em class="lc">元素</em>，然后我们说我们的输入将是一个<code class="fe lk ll lm ln b">S</code>的数组。</p><p id="2c90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们知道一个容器将要拥有的结构(在本例中是一个数组)，并且我们想要约束或引用元素类型时，这种方法非常好用。然而，它有一个很大的缺点，更重要的是，我已经在最后一句话中说过了。它要求我们知道容器的结构。我们希望能够编写通用函数，能够同时处理许多不同类型的容器，比如映射、集合、数组和对象。为此，我们需要拿出大枪。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="f1dc" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">拆包和收集</h1><p id="bd0d" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">还记得我们之前讨论过的那些条件类型吗？我们可以使用它们来创建一个非常强大的实用程序类型，称为<code class="fe lk ll lm ln b">Unpack</code>:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/02ead42361bf6fb32070d9107d9d27ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*Wj8FOWub6OIpaDpscYnoSw.png"/></div></figure><p id="f45b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你首先想到的可能是<code class="fe lk ll lm ln b">infer</code>关键词。这是为我们工作的秘方。当我们问一个条件类型的问题时，例如“这是给定的<code class="fe lk ll lm ln b">F</code>一个<code class="fe lk ll lm ln b">A</code>的数组吗？”我们可能不知道确切的类型<code class="fe lk ll lm ln b">A</code>。让我们给我们不知道但TypeScript知道的内部类型起个名字。因此<code class="fe lk ll lm ln b">Unpack</code> <strong class="kh ir"> </strong>所做的是允许我们询问一个给定的对象是否是任意数量的集合类型(数组、集合、映射、承诺等)中的一个。)，并找出集合中的类型。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/80fef3b61723e3ea33bf856b43187ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*tIK-KuSH0PGB7vJAs85Jwg.png"/></div></figure><p id="3f66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的<code class="fe lk ll lm ln b">get</code>函数接受多种类型的容器作为输入的第一步。接下来，让我们创建一个<strong class="kh ir">容器</strong>类型，它将包含我们可能想要遍历的所有集合。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/82fb9a21edb16bd0cf26c51ed5a569cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*1AxCpsSsAuFkVVOdlOjNtw.png"/></div></figure><p id="745f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在，如果我们回到我们的原始V3，用集合替换我们所有的数组，并放入一个精心放置的<code class="fe lk ll lm ln b">Unpack</code>，我们几乎就有了可以工作的东西。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi of"><img src="../Images/4ba0135a5196a7080f5f02d61709ee07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2ZXaC9FGza4LSoeIRI8iw.png"/></div></div></figure><p id="1da3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你能看出我们结果的问题吗？</p><p id="40fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TS只知道我们的输出是一个<code class="fe lk ll lm ln b">Collection&lt;string, any&gt;</code>，但是我们知道它实际上应该是一个<code class="fe lk ll lm ln b">string[]</code>。这个错误是因为，这正是我们告诉它的。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="f2d8" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">高等类型</h1><p id="afdc" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">先来个简短的题外话，说说为什么上面是个问题。想象一下，你正在编写一个版本的<code class="fe lk ll lm ln b">Array::map</code>，它适用于各种不同的类型，比如<code class="fe lk ll lm ln b">A[] =&gt; B[]</code>和<code class="fe lk ll lm ln b">Map&lt;K, A&gt; =&gt; Map&lt;K, B&gt;</code>。你会怎么做？(嘶！如果你想要这个，它的<a class="ae lb" href="https://github.com/jamesmcnamara/shades#map" rel="noopener ugc nofollow" target="_blank">可用</a>在<em class="lc">阴影</em>。传统的面向对象方法是创建一个接口<code class="fe lk ll lm ln b">Mappable</code>，然后我们为所有的容器类实现<code class="fe lk ll lm ln b">Mappable</code>。但是有一个大问题:这将产生与上面相同的问题。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/52ba997c585b6e13cada7d656d76f1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*S90sK9AA8vkWr9MK79tCnw.png"/></div></figure><p id="cd7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接口<code class="fe lk ll lm ln b">Mappable</code>不知道它将要实现的容器类的类型，所以它只是说函数<code class="fe lk ll lm ln b">map</code>将返回一个<code class="fe lk ll lm ln b">Mappable&lt;B&gt;</code>。当我们在我们的<code class="fe lk ll lm ln b">List</code> <strong class="kh ir"> </strong>容器类上实现它时，我们将类型签名与我们的接口相匹配，我们的<code class="fe lk ll lm ln b">List::map</code>也返回一个<code class="fe lk ll lm ln b">Mappable&lt;B&gt;</code>。但是这意味着我们丢失了类型信息！<code class="fe lk ll lm ln b">List::map</code>可以返回任何其他实现<code class="fe lk ll lm ln b">Mappable</code>的类。</p><p id="f7e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更重要的是，这意味着TS不知道<code class="fe lk ll lm ln b">out</code>是一个列表，所以我们不能在我们的输出上调用任何列表方法，或者将它传递给一个期望列表的函数。如果我们想在列表、映射、集合等数据容器上有公共接口，这是一个真正的麻烦。(注意，精通TS的用户可能会注意到，这个确切的用例实际上是可以修复的，但是一般来说，TS不能处理像<code class="fe lk ll lm ln b">map</code>这样的功能，我们将把重点放在那些更一般的问题上。)我们真正想要的是这样的东西:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oh"><img src="../Images/0bd9effa4a097d3c85c5b4eda5a60c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1d-5arF4ayPvk2u_PU_VVw.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">对容器进行抽象</p></figure><p id="dca4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种能够说<code class="fe lk ll lm ln b">F</code>是某种通用容器并且我们的函数返回<code class="fe lk ll lm ln b">F&lt;A&gt;</code>的想法被称为<em class="lc">更高级的多态性</em>，并且是Scala和Haskell等语言的关键部分。唉，TS不支持(<a class="ae lb" href="https://github.com/microsoft/TypeScript/issues/1213" rel="noopener ugc nofollow" target="_blank">还没</a>)。</p><p id="4e8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们要假装。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="b6e0" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">函子</h1><p id="fbb6" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">最常见的高级类型是Functor，它就是上面的<code class="fe lk ll lm ln b">Mappable&lt;F, A&gt;</code>:它接受某个类型<code class="fe lk ll lm ln b">F&lt;A&gt;</code>，一个<code class="fe lk ll lm ln b">(a: A) =&gt; B</code>函数，并返回一个<code class="fe lk ll lm ln b">F&lt;B&gt;</code>，不管那个<code class="fe lk ll lm ln b">F</code>是什么。它实际上只是代表了一种你可以调用<code class="fe lk ll lm ln b">map</code>的类型。如上所述，我们实际上不能在TS中实现这一点，但我们可以选择我们可能想要映射的所有类型，并编写一个处理其中任何一种类型的Functor版本。怎么会？我们的老朋友，有条件的类型:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oi"><img src="../Images/444f061b8cce411b73bcbb4a646995e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*f3XWC4zMGmEU7YS_i7XptQ.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">穷人的函子</p></figure><p id="ed7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用我们的类型<code class="fe lk ll lm ln b">F</code>并依次询问它是否是这些容器中的任何一个:数组、对象、集合等等。如果我们得到一个命中结果，我们就可以拼出正确的<code class="fe lk ll lm ln b">F&lt;B&gt;</code>返回类型。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="f630" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak">最终草案</strong></h1><p id="cf94" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">好吧，这是一个漫长的过程，你一直很有耐心。让我们重温一下V3，用我们的仿函数增强它:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oj"><img src="../Images/a324d437eef8821954952c789c0ac2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzNsZtJMPfD4UMaahBZLIg.png"/></div></div></figure><p id="497f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有用！</p><p id="0a8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看到底发生了什么变化。我们没有返回一个集合，而是使用我们的仿函数类来精确地计算出我们想要返回的集合。仿函数需要两个参数:</p><ol class=""><li id="e5e6" class="ok ol iq kh b ki kj kl km ko om ks on kw oo la op oq or os bi translated">我们正在转换的整个集合对象:<code class="fe lk ll lm ln b">S</code>。</li><li id="d152" class="ok ol iq kh b ki ot kl ou ko ov ks ow kw ox la op oq or os bi translated">集合的新成员类型。这和以前是一样的；我们想要提取位于<code class="fe lk ll lm ln b">S</code>的成员项上的键<code class="fe lk ll lm ln b">K</code>的类型。我们使用我们的伙伴<code class="fe lk ll lm ln b">Unpack</code>来提取集合<code class="fe lk ll lm ln b">S</code>中的任何内容，然后使用<strong class="kh ir"> </strong> <code class="fe lk ll lm ln b">KeyAt</code>来获得正确的密钥。</li></ol><p id="0ed5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们后退一步；我们已经逐步做到了这一点，所以它可能看起来还不是很酷。我们有一个函数<code class="fe lk ll lm ln b">get</code>，它可以获取一些通用的遍历<strong class="kh ir"> </strong>对象和一个随机字符串，并将它们解释为到一些未知对象的抽象路径。我们得到一个函数，它将接受任何匹配抽象路径的对象，解释该路径对这个对象的意义，并为这个用例构造一个精确而有用的返回类型。</p><p id="c9bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它甚至会捕捉细微的错误！例如，如果我们输入<code class="fe lk ll lm ln b">namez</code>而不是<code class="fe lk ll lm ln b">name</code>会怎么样？TS将捕获它，并彻底分析出了什么问题:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oy"><img src="../Images/b4ca7668409f23cbb8ca82fa11d7e4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkkC3QMSceQMAO0a3t1YCQ.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">你不能冒险</p></figure><p id="c46f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TS做了大量的工作，创建了一个足够灵活的类型系统来处理我们JavaScript程序员使用的所有奇怪的技巧。我们只需要舒服地驾驭它那令人敬畏的力量。</p></div></div>    
</body>
</html>