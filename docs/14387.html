<html>
<head>
<title>Clean Architecture With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React清洁架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-architecture-with-react-cc097a08b105?source=collection_archive---------2-----------------------#2022-12-07">https://betterprogramming.pub/clean-architecture-with-react-cc097a08b105?source=collection_archive---------2-----------------------#2022-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c19a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">干净的架构使您的应用程序易于维护和扩展。但是我们的代码往往会受到各种框架驱动的编码风格的影响。在本文中，我想展示如何将基于react的代码转换(转化)成干净的架构。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e476ad797ed5f45a949ef4aaa65ba44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*idcPkWsv0q6kBvQi"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@therealslimshadyiltun?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">i̇ltun·胡塞恩利</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bf7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净的架构</a>定义了垂直堆叠的几层，每一层代表软件的不同领域。上层代表应用程序的基本策略，而下层代表机制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/5ccc5c371b38cc21ff83c5aa4c2f0303.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*6d2zszJFKp47WlZUF95yPQ.png"/></div></figure><p id="97bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使这个架构工作的首要规则是<em class="lt">依赖规则</em>。这条规则说<em class="lt">源代码依赖</em>只能指向上。有了层和依赖规则，您可以设计耦合性非常低的应用程序，并且独立于技术实现细节，例如数据库和框架。</p><p id="63c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了本文中<a class="ae kv" href="https://paulallies.medium.com/clean-architecture-typescript-and-react-8e509098abfe" rel="noopener">定义的层，定义如下:</a></p><p id="3404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">域</strong>层描述了您的项目或应用程序做什么。领域层的代码应该独立于平台和框架。</p><ul class=""><li id="d40c" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated"><strong class="ky ir">模型</strong>代表与问题相关的现实世界对象。</li><li id="ac43" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><strong class="ky ir">储存库</strong>提供访问模型的接口。</li><li id="54bc" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><strong class="ky ir">用例</strong>包括应用程序的所有业务逻辑。</li></ul><p id="48d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">表示层</strong>描述了你的应用程序如何与外界交互。</p><p id="93fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据层描述了你的应用如何管理数据。</p><p id="99ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主层(最底层)提供引导代码，负责将其他层中的所有软件组件编织成一个应用程序。</p><p id="6643" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在实际应用中，控制流并不总是向上的。比如<code class="fe mi mj mk ml b">UseCase</code>层的业务逻辑使用了存储库层的一个接口，存储库(上层)需要访问数据层(下层)管理的数据。见下图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/f4eb025d6ebc23e693c43c1e42a06779.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*9ks3aD8UfwmXKaUQNhy_0A.png"/></div></figure><p id="d528" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这种违反依赖规则的情况，我们通常使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则。</a>我们安排接口(例如RepositoryX)和它的实现(例如<code class="fe mi mj mk ml b">RepositoryImpl</code>)之间的关系，使得源代码依赖指向上。使用这种技术，上层可以调用下层定义的实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/de2ab6fb46bb59e52498f47c8c0f52ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*tqQ8wq4XvtAbsJ_KK5_0Bw.png"/></div></figure><h1 id="2d5e" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">将React应用程序转变为干净的架构</h1><p id="4d80" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">当您从react应用程序的模板中启动您的应用程序代码时(例如由<a class="ae kv" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建的框架)，所有代码首先都包含在表示层中。这是因为react(以及所有UI框架)关注的是如何向用户呈现数据。在本节中，我们将转换基于react的应用程序代码，并使其符合干净的架构。</p><p id="9bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<a class="ae kv" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">官方react教程</a>中使用的TicTacToe的原代码。</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="5a1c" class="np mp iq ml b be nq nr l ns nt">function Square(props) {<br/>  return (<br/>    &lt;button className="square" onClick={props.onClick}&gt;<br/>      {props.value}<br/>    &lt;/button&gt;<br/>  );<br/>}<br/><br/>class Board extends React.Component {<br/>  renderSquare(i) {<br/>    return (<br/>      &lt;Square<br/>        value={this.props.squares[i]}<br/>        onClick={() =&gt; this.props.onClick(i)}<br/>      /&gt;<br/>    );<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;div className="board-row"&gt;<br/>          {this.renderSquare(0)}<br/>          {this.renderSquare(1)}<br/>          {this.renderSquare(2)}<br/>        &lt;/div&gt;<br/>        &lt;div className="board-row"&gt;<br/>          {this.renderSquare(3)}<br/>          {this.renderSquare(4)}<br/>          {this.renderSquare(5)}<br/>        &lt;/div&gt;<br/>        &lt;div className="board-row"&gt;<br/>          {this.renderSquare(6)}<br/>          {this.renderSquare(7)}<br/>          {this.renderSquare(8)}<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/><br/>class Game extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      history: [<br/>        {<br/>          squares: Array(9).fill(null)<br/>        }<br/>      ],<br/>      stepNumber: 0,<br/>      xIsNext: true<br/>    };<br/>  }<br/><br/>  handleClick(i) {<br/>    const history = this.state.history.slice(0, this.state.stepNumber + 1);<br/>    const current = history[history.length - 1];<br/>    const squares = current.squares.slice();<br/>    if (calculateWinner(squares) || squares[i]) {<br/>      return;<br/>    }<br/>    squares[i] = this.state.xIsNext ? "X" : "O";<br/>    this.setState({<br/>      history: history.concat([<br/>        {<br/>          squares: squares<br/>        }<br/>      ]),<br/>      stepNumber: history.length,<br/>      xIsNext: !this.state.xIsNext<br/>    });<br/>  }<br/><br/>  jumpTo(step) {<br/>    this.setState({<br/>      stepNumber: step,<br/>      xIsNext: (step % 2) === 0<br/>    });<br/>  }<br/><br/>  render() {<br/>    const history = this.state.history;<br/>    const current = history[this.state.stepNumber];<br/>    const winner = calculateWinner(current.squares);<br/><br/>    const moves = history.map((step, move) =&gt; {<br/>      const desc = move ?<br/>        'Go to move #' + move :<br/>        'Go to game start';<br/>      return (<br/>        &lt;li key={move}&gt;<br/>          &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt;<br/>        &lt;/li&gt;<br/>      );<br/>    });<br/><br/>    let status;<br/>    if (winner) {<br/>      status = "Winner: " + winner;<br/>    } else {<br/>      status = "Next player: " + (this.state.xIsNext ? "X" : "O");<br/>    }<br/><br/>    return (<br/>      &lt;div className="game"&gt;<br/>        &lt;div className="game-board"&gt;<br/>          &lt;Board<br/>            squares={current.squares}<br/>            onClick={i =&gt; this.handleClick(i)}<br/>          /&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="game-info"&gt;<br/>          &lt;div&gt;{status}&lt;/div&gt;<br/>          &lt;ol&gt;{moves}&lt;/ol&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/><br/>// ========================================<br/><br/>const root = ReactDOM.createRoot(document.getElementById("root"));<br/>root.render(&lt;Game /&gt;);<br/><br/>function calculateWinner(squares) {<br/>  const lines = [<br/>    [0, 1, 2],<br/>    [3, 4, 5],<br/>    [6, 7, 8],<br/>    [0, 3, 6],<br/>    [1, 4, 7],<br/>    [2, 5, 8],<br/>    [0, 4, 8],<br/>    [2, 4, 6]<br/>  ];<br/>  for (let i = 0; i &lt; lines.length; i++) {<br/>    const [a, b, c] = lines[i];<br/>    if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) {<br/>      return squares[a];<br/>    }<br/>  }<br/>  return null;<br/>}</span></pre><p id="78ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而这里是TicTacToe的截图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/0d1d34d4d7001ba6ba449ecbc1651efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*2PApRqXAtLdZ8wbhkqTg5Q.png"/></div></figure><h1 id="20ba" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">设计模型层</h1><p id="81f5" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">首先，让我们在模型层提取数据模型。根据定义，这里定义的模型应该是平台无关的和框架无关的，并且它们应该完全专注于业务规则。</p><p id="47bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使原始代码没有明确的类型定义，您也应该明确定义那些类型，以利用TypeScript的类型推理机制，并让它在开发时支持您。</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="0e1a" class="np mp iq ml b be nq nr l ns nt">export type Square = null | "X" | "O";<br/><br/>export type Board = Square[];<br/><br/>type HistoryStep = {<br/>  board: Board;<br/>};<br/><br/>export type History = HistoryStep[];</span></pre><h1 id="4f7f" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">设计用例层和存储库层</h1><p id="479f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">下一步是提取用例。一个用例可以被形式化为“当X发生时，做Y”。</p><p id="c98b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React应用程序中，用例通常实现为(1)React框架调用的渲染功能，(2)用户输入的事件处理程序，或(3)自主效果。在<code class="fe mi mj mk ml b">TicTacToe</code>的例子中，我们有三个用例。</p><ul class=""><li id="9b71" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated"><code class="fe mi mj mk ml b">render()</code>:当有数据更新时，调用该函数。</li><li id="f4fa" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><code class="fe mi mj mk ml b">handleClick(i)</code>:当你按下棋盘上的一个方块时，这个功能被调用。</li><li id="80b7" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><code class="fe mi mj mk ml b">jumpTo(step)</code>:当您按下“Go to move #x”按钮时，此功能被调用。</li></ul><p id="5381" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是您注意到最初的用例功能(<code class="fe mi mj mk ml b">render()</code>、<code class="fe mi mj mk ml b">handleClick()</code>、<code class="fe mi mj mk ml b">jumpTo()</code>)包括来自多个层的代码(用例、存储库、数据、表示(react))。我们需要以某种方式解开这个意大利面条，并将代码分配到适当的层。</p><p id="ee03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我通常通过分析变量之间的依赖关系来开始这种理清。然后，我找到了无法从任何其他变量推导出的原始数据来源。在<code class="fe mi mj mk ml b">TicTacToe</code>示例中，您可以很容易地检测到两个数据源<code class="fe mi mj mk ml b">history</code>和<code class="fe mi mj mk ml b">stepNumber</code>，如下图所示。那些原始数据需要存储在持久数据存储中，我们把它们放在数据层。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/a4f17f4874a82a7e31e236e57aa0782c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAR1a7rxpsFPit628qwQIQ.png"/></div></div></figure><p id="5576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计<code class="fe mi mj mk ml b">UseCase</code>层和<code class="fe mi mj mk ml b">Repository</code>层之间的边界是主观的，部分取决于你。存储库层被定义为保存所有特定于模型的操作的中心位置。除此之外，我有自己的策略来定义存储层中的操作，如下所示:</p><ul class=""><li id="5341" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated">存储库操作应该最小化。公开主数据源的所有原始setter/getter函数并不是一个好主意，因为这很容易导致无效/不一致的数据。</li><li id="28a8" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated">存储库操作应该是中立的，并且独立于<code class="fe mi mj mk ml b">UseCase</code>层中定义的业务逻辑。</li><li id="6274" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated">每个存储库操作应该只在需要一次改变多个数据源时才访问它们(作为原子操作),以保持数据源之间的一致性。</li></ul><p id="fd42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这个策略，我将<code class="fe mi mj mk ml b">UseCase</code>层和<code class="fe mi mj mk ml b">Repository</code>层解耦如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/932efe65818a81eca140ca82795b5abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dedDxV5GCC4j0xCLD0Y0xg.png"/></div></div></figure><p id="30d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来定义一下<code class="fe mi mj mk ml b">Repository</code>接口。实现在后面。</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="88f9" class="np mp iq ml b be nq nr l ns nt">export type Step = {<br/>  board: Board;<br/>  stepNumber: number;<br/>  numOfAllSteps: number;<br/>};<br/><br/>/**<br/> * Repository managing the history of TicTacToe steps.<br/> * Each step consists of a board.<br/> */<br/>export interface Repository {<br/>  getCurrentStep(): Promise&lt;Step&gt;;<br/>  setCurrentStepNumber(stepNumber: number): Promise&lt;void&gt;;<br/>  deleteStepsAfterCurrentStepNumber(): Promise&lt;void&gt;;<br/>  addStep(board: Board): Promise&lt;void&gt;;<br/>}</span></pre><p id="63c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后你可以定义<code class="fe mi mj mk ml b">UseCase</code>函数。现在你可以更清楚地理解业务逻辑了。</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="2a97" class="np mp iq ml b be nq nr l ns nt">export async function clickOnBoard(<br/>  indexOnBoard: number,<br/>  repository: Repository<br/>) {<br/>  const { board, stepNumber } = await repository.getCurrentStep();<br/>  const newBoard = board.slice();<br/>  if (calculateWinnerOnBoard(newBoard) || newBoard[indexOnBoard]) {<br/>    return;<br/>  }<br/>  newBoard[indexOnBoard] = isNextTurnX(stepNumber) ? "X" : "O";<br/>  await repository.deleteStepsAfterCurrentStepNumber();<br/>  await repository.addStep(newBoard);<br/>  await repository.setCurrentStepNumber(stepNumber + 1);<br/>}<br/><br/>export async function jumpToStep(<br/>  stepNumber: number,<br/>  repository: Repository<br/>): Promise&lt;void&gt; {<br/>  return repository.setCurrentStepNumber(stepNumber);<br/>}</span></pre><h1 id="29d8" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">设计表示层</h1><p id="7cec" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在表示层，最重要的提示是形成<a class="ae kv" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC(模型-视图-控制器)</a>。在react应用程序中，我们通常将“模型”和“控制器”合并在一个对象中，作为表示层和用例层之间的桥梁。</p><p id="a616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参见下图中的<code class="fe mi mj mk ml b">TicTacToeModelController</code>。React组件在MVC中作为“视图”工作，用自定义钩子引用“模型-控制器”。这样，我们可以将纯渲染代码(“视图”)与任何数据处理代码(“模型”和“控制器”)解耦。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2b494c578232e9e0f02ffede38064ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*KZVpP9avcOFi66OBFK9Hdw.png"/></div></figure><p id="7668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe mi mj mk ml b">TicTacToeModelController</code>的代码。</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="b2f9" class="np mp iq ml b be nq nr l ns nt">export function useTicTacToeModelController(repository: Repository) {<br/>  const [currentStep, setCurrentStep] = useState&lt;Step | null&gt;(null);<br/><br/>  useEffect(() =&gt; {<br/>    async function init() {<br/>      const initialStep = await repository.getCurrentStep();<br/>      setCurrentStep(initialStep);<br/>    }<br/>    init();<br/>  }, []);<br/><br/>  const handleClickOnBoard = async (indexOnBoard: number) =&gt; {<br/>    await clickOnBoard(indexOnBoard, repository);<br/>    const newStep = await repository.getCurrentStep();<br/>    setCurrentStep(newStep);<br/>  };<br/><br/>  const handleJumpToStep = async (stepNumber: number) =&gt; {<br/>    await jumpToStep(stepNumber, repository);<br/>    const newStep = await repository.getCurrentStep();<br/>    setCurrentStep(newStep);<br/>  };<br/><br/>  return {<br/>    currentStep,<br/>    handleClickOnBoard,<br/>    handleJumpToStep,<br/>  };<br/>}</span></pre><p id="3c2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而这里是<code class="fe mi mj mk ml b">TicTacToeView</code>。</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="6208" class="np mp iq ml b be nq nr l ns nt">type TicTacToeViewProps = {<br/>  repository: Repository;<br/>};<br/><br/>export function TicTacToeView({ repository }: TicTacToeViewProps) {<br/>  const { currentStep, handleClickOnBoard, handleJumpToStep } =<br/>    useTicTacToeModelController(repository);<br/><br/>  if (!currentStep) {<br/>    return null;<br/>  }<br/><br/>  const winner = calculateWinnerOnBoard(currentStep.board);<br/>  const xIsNext = isNextTurnX(currentStep.stepNumber);<br/>  return (<br/>    &lt;div className="game"&gt;<br/>      &lt;div className="game-board"&gt;<br/>        &lt;BoardView board={currentStep.board} onClick={handleClickOnBoard} /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="game-info"&gt;<br/>        &lt;StatusView winner={winner} xIsNext={xIsNext} /&gt;<br/>        &lt;JumpToStepButtons<br/>          numOfAllSteps={currentStep.numOfAllSteps}<br/>          onClick={handleJumpToStep}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h1 id="ac06" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">设计数据层</h1><p id="c898" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">数据层有两个子层。<code class="fe mi mj mk ml b">Data:Repository</code>层是实现<code class="fe mi mj mk ml b">Domain:Repository</code>层中定义的行为的层。<code class="fe mi mj mk ml b">Data:DataSource</code>层实现实际的数据存储，如内存存储或网络存储。</p><p id="63dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下图所示，我们在<code class="fe mi mj mk ml b">Domain:Repository</code>层(上层)和<code class="fe mi mj mk ml b">Data:Repository</code>层(下层)之间应用了依赖反转原理。控制流是向下的(例如，域使用数据)，而源代码依赖是向上的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f7aa813491fb067d058798065ce6e755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*fnCIn2naW-RJM1BSmwonew.png"/></div></figure><p id="4ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是<code class="fe mi mj mk ml b">RepositoryImpl</code>:</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="8346" class="np mp iq ml b be nq nr l ns nt">export class RepositoryImpl implements Repository {<br/>  dataSource: DataSource;<br/><br/>  constructor(dataSource: DataSource) {<br/>    this.dataSource = dataSource;<br/>  }<br/><br/>  async getCurrentStep(): Promise&lt;Step&gt; {<br/>    const [history, stepNumber] = await Promise.all([<br/>      this.dataSource.getHistory(),<br/>      this.dataSource.getStepNumber(),<br/>    ]);<br/>    const board = history[stepNumber].board;<br/>    const numOfAllSteps = history.length;<br/><br/>    return { board, stepNumber, numOfAllSteps };<br/>  }<br/><br/>  async setCurrentStepNumber(stepNumber: number): Promise&lt;void&gt; {<br/>    const history = await this.dataSource.getHistory();<br/>    if (stepNumber &lt; history.length) {<br/>      await this.dataSource.setStepNumber(stepNumber);<br/>    } else {<br/>      throw Error(<br/>        `Step number ${stepNumber} should be smaller than the history size (${history.length})`<br/>      );<br/>    }<br/>  }<br/><br/>  async deleteStepsAfterCurrentStepNumber(): Promise&lt;void&gt; {<br/>    const [history, stepNumber] = await Promise.all([<br/>      this.dataSource.getHistory(),<br/>      this.dataSource.getStepNumber(),<br/>    ]);<br/>    const trimmedHistory = history.slice(0, stepNumber + 1);<br/>    await this.dataSource.setHistory(trimmedHistory);<br/>  }<br/><br/>  async addStep(board: Board): Promise&lt;void&gt; {<br/>    const history = await this.dataSource.getHistory();<br/>    history.push({ board });<br/>    await this.dataSource.setHistory(history);<br/>  }<br/>}</span></pre><h1 id="8d50" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">设计主层</h1><p id="c6e2" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">最后，我们在主层的引导代码中将几层中的所有组件编织成一个应用程序。</p><p id="9e95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这段引导代码中，我们创建了一个存储库实现，并将其传递给<code class="fe mi mj mk ml b">TicTacToeView</code>。然后仓库通过<code class="fe mi mj mk ml b">TicTacToeModelController</code>传递到<code class="fe mi mj mk ml b">UseCase</code>层。</p><pre class="kg kh ki kj gt nl ml nm bn nn no bi"><span id="62ab" class="np mp iq ml b be nq nr l ns nt">// Dependency injection<br/>const dataSource = new OnMemoryDataSourceImpl();<br/>const repository = new RepositoryImpl(dataSource);<br/><br/>export function App() {<br/>  return &lt;TicTacToeView repository={repository} /&gt;;<br/>}</span></pre><p id="72f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种叫做<a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入(DI) </a>的技术。如下图所示，<code class="fe mi mj mk ml b">UseCase</code>层使用(依赖于)<code class="fe mi mj mk ml b">Repository</code>层，但是<code class="fe mi mj mk ml b">UseCase</code>层中的代码不应该在<code class="fe mi mj mk ml b">Repository</code>层中创建依赖于下层(数据层)的实际对象。</p><p id="55c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将对象创建(在<code class="fe mi mj mk ml b">Main</code>层)和对象使用(在<code class="fe mi mj mk ml b">UseCase</code>层)解耦，我们可以避免违反依赖规则(所有引用箭头都应该向上:下层到上层)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/7c578f345a992779795e93acdf60b71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qf63RbptpS45ji0yedUS9A.png"/></div></div></figure><p id="d506" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！你可以在这里看到最终的源代码<a class="ae kv" href="https://gitlab.com/kmiyashita/clean-tic-tac-toe/-/tree/clean-architecture/src" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="78ac" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="b493" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我展示了如何将您的react应用程序代码转换成干净的架构。一旦你熟悉了干净的架构，你就可以从一开始就设计出符合干净架构的代码。但是即使在这种情况下，我希望本文描述的设计过程能够为您的重构提供良好的指导。</p></div></div>    
</body>
</html>