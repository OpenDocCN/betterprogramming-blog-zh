<html>
<head>
<title>Building Multiplatform Mobile Apps With GraalVM Native Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraalVM本机映像构建多平台移动应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-multiplatform-mobile-apps-with-graalvm-native-image-7e9131fb185f?source=collection_archive---------9-----------------------#2022-10-31">https://betterprogramming.pub/making-multiplatform-mobile-apps-with-graalvm-native-image-7e9131fb185f?source=collection_archive---------9-----------------------#2022-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="481a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建语音听写应用程序的深入分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3f8db8392b5d63d3fd7e80c612e23b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o-ocmuTVbXHiPnkL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@iamdavid_10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·什维霍维奇</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="d8b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇后续文章中，我们将探索用Kotlin/Java编写的共享核心的iOS和Android中的演示应用程序。入门篇这里是<a class="ae kv" href="https://medium.com/@philip.han_66842/graalvm-native-image-for-mobile-development-49eb87a00eee" rel="noopener">这里是</a>。</p><p id="dff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是一个简单的语音听写app。本演示的要点是将平台服务与域模型相结合。我们将首先从iOS获取语音识别文本，并查询自然语言处理(NLP)服务器来确定捕获的句子是否是一个问题。并且产生的域模型数据将被交付给<code class="fe ls lt lu lv b">ViewModel</code>用于进一步的转换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/c2f6238164a99428fd03337c4f6a2f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*Oku_jbiPzyqr9HlwOZxJBw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS和Android示例应用</p></figure><p id="0a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">iOS应用程序将演示如何与核心组件的C接口进行交互。这包括使用核心组件发布的流/通道，并通过C函数指针导出平台服务。</p><p id="f70c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">制作一个C接口主要是用Java完成的，用<a class="ae kv" href="https://www.graalvm.org/22.0/reference-manual/native-image/C-API/" rel="noopener ugc nofollow" target="_blank"> GraalVM原生映像C API </a>和一些C头文件来声明函数和结构。</p><p id="9960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个演示应用程序是用GraalVM社区版(CE)制作的。GraalVM Enterprise Edition (EE)是有成本的，但不是必须的。如果您选择使用EE而不是CE，您将获得更丰富的特性集，尤其是更好的GC算法。</p><h1 id="e778" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">工具作业</h1><p id="eeee" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">请先安装<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm" rel="noopener ugc nofollow" target="_blank">GraalVM Tools for Java—Visual Studio market place</a>。一旦安装了扩展，您将需要以下模块。您也可以使用这个扩展下载并安装GraalVM。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6c9d61f107d212a5c78d13f1ac810ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*t4DKbfX3ibPBOZ-kDXS0ng.png"/></div></figure><p id="5527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是在GraalVM版本22.1.0或更低版本上测试的。由于模块导入不正确，较高版本目前不工作。一旦成功，我会尽快通知你。</p><h1 id="763f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">体系结构</h1><p id="1bf7" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这里的建筑是MVVM风格，略有调整。特别值得注意的是，ViewModel在主机平台和平台不可知的ViewModel之间是分开的。这样做是为了共享非特定于平台的视图模型逻辑。</p><p id="8e86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">领域模型处理所有的业务逻辑，是事实的来源。它处理大量的并发性，以保持观测数据的一致性。它是以actor范式设计的，所以它的更新是以有序的方式发布的。</p><p id="5a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的业务逻辑都表示为纯函数，因此很容易测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/3d84b525564af1971072c022f5ca5859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*udvdvznZ75cnQJ2wmMbxKw.png"/></div></figure><p id="2f03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个这种类型转换的例子。这里我们有一个<code class="fe ls lt lu lv b">StateFlow</code>用于监听语音识别器的状态。</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="045f" class="na ly iq lv b gy nb nc l nd ne">val speechRecognizerState: StateFlow&lt;Boolean&gt; =<br/>  model.speechRecognitionState</span></pre><p id="2706" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们为Android <code class="fe ls lt lu lv b">ViewModel</code>转换这种状态。</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="fc97" class="na ly iq lv b gy nb nc l nd ne">val speechRecognizerState = speechCore.speechRecognizerState.<em class="nf">map</em>(<em class="nf">viewModelScope</em>) { listening -&gt;<br/>    if (listening) Pair(R.string.<em class="nf">listening</em>, Color.Red)<br/>    else Pair(R.string.<em class="nf">sleeping</em>, Color.Black)<br/>}</span></pre><p id="8538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和Swift上相应的视图模型。</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="9bdd" class="na ly iq lv b gy nb nc l nd ne">func convertRecognizerState(listening: Bool) -&gt; (String, Color) {<br/>  listening ? ("LISTENING", Color.red) : ("Sleeping", Color.black)<br/>}</span></pre><p id="9e4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，你可能想知道一个Kotlin <code class="fe ls lt lu lv b">StateFlow</code>是如何被观测到并传递给Swift中的mapper函数的。可以肯定的是，在这两者之间还有相当多的工作要做，所以让我们更深入地了解一下。</p><h1 id="e46b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">孤立的</h1><p id="c9f4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Isolate是Java运行时的一个迷你容器。它维护编译到目标平台的Java/Kotlin代码的执行堆栈和堆。</p><p id="e461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一篇关于Isolate的详细文章:<a class="ae kv" href="https://medium.com/graalvm/isolates-and-compressed-references-more-flexible-and-efficient-memory-management-for-graalvm-a044cc50b67e" rel="noopener">Isolates and Compressed References:通过GraalVM实现更灵活高效的内存管理|作者:Christian Wimmer | GraalVM | Medium</a></p><p id="4c11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">必须首先创建一个隔离，然后在所有本机方法调用中使用。隔离在创建时绑定到指定的线程，并且本机调用必须包括线程引用。如果本机调用需要在不同的线程上运行，则必须在调用之前分离隔离，然后重新附加到目标线程。</p><p id="633c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">隔离必须手动销毁，不会被主机操作系统自动回收</p><p id="2275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分离C API:</p><ul class=""><li id="309a" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated"><code class="fe ls lt lu lv b">graal_create_isolate</code></li><li id="2ac3" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe ls lt lu lv b">graal_attach_thread</code></li><li id="f69a" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe ls lt lu lv b">graal_detach_thread</code></li><li id="035b" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe ls lt lu lv b">graal_tear_down_isolate</code></li><li id="5cad" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated"><code class="fe ls lt lu lv b">graal_detach_all_threads_and_tear_down_isolate</code></li></ul><p id="f830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">隔离C API可以直接在Swift中使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e61a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在演示应用程序中，我们将创建一个专用的Swift线程，并在屏幕持续期间附加一个隔离，而不是创建并销毁每个函数调用。</p><h1 id="4627" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">GraalVM本机映像C API</h1><p id="f7cd" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先需要为声明创建一个C头文件。然后将头文件导入Java。</p><p id="2a71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望作为C函数公开的所有方法必须是静态的，并且在由<code class="fe ls lt lu lv b">@CContext</code>注释的类中由<code class="fe ls lt lu lv b">@CEntryPoint</code>注释。<code class="fe ls lt lu lv b">@CContext</code>类似于c语言中的<code class="fe ls lt lu lv b">import &lt;header&gt;</code>指令。</p><p id="744e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您必须接受<code class="fe ls lt lu lv b">IsolateThread</code>作为<code class="fe ls lt lu lv b">@CEntryPoint</code>函数中的参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b752" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像结构这样更复杂的数据类型作为指针传递和返回。<code class="fe ls lt lu lv b">PointerBase</code>相当于c中的指针。</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="1c77" class="na ly iq lv b gy nb nc l nd ne">@CStruct("CError")<br/>public interface CError extends PointerBase {<br/>    @CField("code") void setCode(int code);<br/>    @CField("code") int getCode();<br/>    @CField("message") void setMessage(CCharPointer message);<br/>    @CField("message") CCharPointer getMessage();<br/>}</span></pre><p id="f453" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述结构首先在C头文件中定义，然后导入到Java中。这是C头文件中的声明，如下所示:</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="30bf" class="na ly iq lv b gy nb nc l nd ne">typedef struct CError {<br/>    int code;<br/>    char* message;<br/>} CError;</span></pre><p id="1137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只能处理头文件中定义的类型，而不是原语。布尔运算需要一个标准头文件<code class="fe ls lt lu lv b">stdbool.h</code>。字符串不是c语言中的标准类型。它是一个指向<code class="fe ls lt lu lv b">char</code>的指针，以<code class="fe ls lt lu lv b">null</code>终止。这也意味着根本没有泛型。</p><p id="f97b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在C语言中，求值是自顶向下的。因此，你不能向后引用事物。记住在c语言中声明的顺序很重要。</p><p id="3463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以导入/导出C函数指针。对于C头文件中的函数指针声明:</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="e212" class="na ly iq lv b gy nb nc l nd ne">typedef void (*ErrorDispatcher)(void*, char*);</span></pre><p id="a860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Java中，如上所示导入:</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="66a9" class="na ly iq lv b gy nb nc l nd ne">public interface ErrorDispatcher extends CFunctionPointer {</span><span id="a69a" class="na ly iq lv b gy nw nc l nd ne">@InvokeCFunctionPointer<br/>    void invoke(PointerBase ctx, CCharPointer errorMessage);</span><span id="5e85" class="na ly iq lv b gy nw nc l nd ne">}</span></pre><p id="9d7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">UnmanagedMemory</code>包提供了C类型的堆分配和释放。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分配的内存用<code class="fe ls lt lu lv b">free</code>释放，就像c中一样</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="9bf9" class="na ly iq lv b gy nb nc l nd ne">import org.graalvm.nativeimage.UnmanagedMemory;</span><span id="ce02" class="na ly iq lv b gy nw nc l nd ne">CSpeechBusinessData data = allocData();<br/>UnmanagedMemory.free(data);</span></pre><p id="0e2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:本机映像C API很可能会被弃用，并被Project Panama外部函数和内存API所取代。巴拿马计划在Java 19中作为第三个预览版。</p><h1 id="49c5" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">Swift C互操作</h1><p id="9367" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/swift/c-interoperability" rel="noopener ugc nofollow" target="_blank"> Swift C互操作</a>类似于GraalVM C API。他们只是名字不同。<code class="fe ls lt lu lv b">OpaquePointer</code>相当于Swift<code class="fe ls lt lu lv b">UnsafeMutableRawPointer</code><code class="fe ls lt lu lv b">CCharPointer</code>相当于<code class="fe ls lt lu lv b">UnsafeMutablePointer&lt;CChar&gt;.</code>它们分别是C中的<code class="fe ls lt lu lv b">void*</code>和<code class="fe ls lt lu lv b">char*</code>。</p><p id="ff3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，Swift可以使用<code class="fe ls lt lu lv b">@convention(c)</code>注释将闭包表示为C函数。</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="aca4" class="na ly iq lv b gy nb nc l nd ne">let httpPostFunc: @convention(c) (<br/>    _ uri: UnsafeMutablePointer&lt;CChar&gt;,<br/>    _ speech: UnsafeMutablePointer&lt;CChar&gt;<br/>) -&gt; UnsafeMutablePointer&lt;Either&gt;?</span></pre><p id="54d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述声明可以初始化为:</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="040e" class="na ly iq lv b gy nb nc l nd ne">httpPostFunc = { uri, speech in <br/>    // return http post operation in swift<br/>}</span></pre><p id="dc4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们可以分配一个具有匹配签名的函数:</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="ccbe" class="na ly iq lv b gy nb nc l nd ne">httpPostFunc = httpPostReal</span><span id="2f32" class="na ly iq lv b gy nw nc l nd ne">func httpPostReal(<br/>    uri: UnsafeMutablePointer&lt;CChar&gt;,<br/>    speech: UnsafeMutablePointer&lt;CChar&gt;<br/>) -&gt; UnsafeMutablePointer&lt;Either&gt;? {<br/>    // implementation<br/>}</span></pre><p id="b9ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将这些函数指针实例传递给GraalVM C接口，比如上一节的<code class="fe ls lt lu lv b">CError</code>例子。</p><h1 id="78f2" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">C/Swift中的反应流</h1><p id="289d" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先，我们需要将<code class="fe ls lt lu lv b">collect</code>转换成Kotlin/Java中的观察者模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在Java互操作层，我们连接C回调对象。</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="a7b6" class="na ly iq lv b gy nb nc l nd ne">// recognizerStateDispatcher is C callback provided by the host.<br/>// passed as speechRecognizerStateCallback above.</span><span id="ab3c" class="na ly iq lv b gy nw nc l nd ne">(Boolean state) -&gt; {<br/>    if (recognizerStateDispatcher.isNonNull())<br/>      recognizerStateDispatcher.invoke(ctx, state);<br/>}</span></pre><p id="8f5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Swift C互操作回调的定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="2b1f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">项目结构</h1><p id="3a9f" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在这个演示应用程序中，我们有三个项目和五个模块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f138f15c48cfc49c3ae8d0f737cc124c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*L3Df2CMM5y70PdQn1wASSw.png"/></div></figure><p id="cf63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin核心模块是纯Kotlin/Java模块，因为Java C Interop引用了它。</p><p id="ac61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java C Interop模块公开了Kotlin的核心功能，并将数据结构从Kotlin/Java映射到C。</p><p id="c43c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">iOS app模块再消费C函数和数据结构，以及向C接口提供基础设施服务。在这个演示应用中，iOS语音识别是通过函数指针导出的。</p><p id="e24a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java代理应用程序模块是可选的。它负责执行带有反射的代码部分，并生成将在AOT编译期间使用的反射配置。在这种情况下，Moshi <code class="fe ls lt lu lv b">KotlinJsonAdapterFactory</code>需要它来进行反射Json反序列化。您也可以手动编写这个配置，或者使用codegen版本来完全消除反射。</p><h1 id="b657" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">领域模型</h1><p id="f639" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">领域模型是应用程序的真实来源。它由数据和行为组成。d to用于构建领域模型的数据模型部分。行为是非常容易测试的纯业务功能。</p><p id="908c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一层完全与平台和客户端无关。它可以重复使用，为任何客户端提供服务，无论是移动客户端还是桌面客户端。</p><p id="5fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它处理并发性以保持其状态始终一致。它遵循actor模型以及Kotlin协同程序的结构化并发性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/7fd56c49612bdeb84a07392d4b698007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*E8h2AooBNs8a_RlNBc1HTw.png"/></div></figure><h1 id="02f3" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">模型</h1><p id="4877" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">模型层编排域模型和服务，然后将可观察的状态(平台不可知的视图模型)导出到客户端。</p><h1 id="2320" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">异常处理</h1><p id="2128" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">C接口上的异常传播是通过C中的<code class="fe ls lt lu lv b">Either</code> monad完成的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="03f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们可以启用<code class="fe ls lt lu lv b">build.gradle</code>中的<code class="fe ls lt lu lv b">-H:+ReportExceptionStackTraces</code>和<code class="fe ls lt lu lv b">-H:+GenerateDebugInfo=1</code>，以获得更详细的崩溃输出。</p><p id="55dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果Xcode崩溃，使您进入汇编中的断点，很可能是Java C接口代码中的指针或内存分配问题。根据我的经验，在这些情况下，除了“做出直觉，然后证明/否定它”的循环，我们别无选择。</p><h1 id="1916" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">外部组件</h1><h2 id="25d5" class="na ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">Ktor</h2><p id="d712" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">使用资源目录中提供的反射配置文件来处理AOT。它有更大的运行时内存占用，所以在这个应用程序中，我们使用iOS <code class="fe ls lt lu lv b">URLSession</code>来代替。</p><h2 id="7055" class="na ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">科特林序列化</h2><p id="3ad3" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">与Ktor一起用于Json反序列化。对于AOT，它应该与代理一起使用，以生成反射配置。</p><h2 id="e1f6" class="na ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">Swift URLSession</h2><p id="d04b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">URLSession需要一个扩展函数来使它同步运行，因为它已经在协程IO调度程序中运行。选择使用iOS HTTP客户端是因为与AOT编译的Ktor相比，内存占用显著减少。</p><h2 id="4d01" class="na ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">魔石</h2><p id="44e7" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">使用了Moshi Json mapper，除了需要一个配置文件用于反射DTO实例化之外，它工作得很好。</p><h2 id="0557" class="na ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">柯因</h2><p id="61f8" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Koin没有任何问题。</p><h2 id="9222" class="na ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">协同程序/流程/通道</h2><p id="306e" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这里唯一需要注意的是没有<code class="fe ls lt lu lv b">Dispatchers.main</code>，它只在有主事件循环的环境中可用，比如Android或Swing。您必须通过C接口使用一个<code class="fe ls lt lu lv b">callback</code>处理程序，它将闭包提交给iOS主调度程序。这方面的例子在上面的“C/Swift中的反应流”部分。</p><h1 id="13c0" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">代理人</h1><p id="65f4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">运行反射配置生成代理的最简单方法是使用VS代码的GraalVM本机映像插件。它将提供梯度任务附加代理。你可以使用这个梯度任务命令:<code class="fe ls lt lu lv b">./gradlew app:run -P agent.</code>之后，你必须指向生成文件所在的目录，例如<code class="fe ls lt lu lv b">app/build/native/agent-output/run</code></p><h1 id="9ce5" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">NLP服务器</h1><p id="31d0" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">需要Stanford CoreNLP服务器来解析语音识别器提供的文本。您可以在此下载:</p><p id="7f25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stanfordnlp.github.io/CoreNLP/download.html" rel="noopener ugc nofollow" target="_blank">下载—CoreNLP(stanfordnlp . github . io)</a></p><p id="6b43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需从提取命令的位置提取并运行该命令即可:</p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="5077" class="na ly iq lv b gy nb nc l nd ne">#/bin/sh</span><span id="137b" class="na ly iq lv b gy nw nc l nd ne">java -mx3g -cp stanford-corenlp-4.5.1.jar:stanford-corenlp-4.5.1-models.jar:joda-time.jar:jollyday.jar:protobuf-java-3.19.2.jar:xom.jar:ejml-core-0.39.jar:ejml-simple-0.39.jar:ejml-ddense-0.39.jar:jaxb-api-2.4.0-b180830.0359.jar:jaxb-impl-2.4.0-b180830.0438.jar edu.stanford.nlp.pipeline.StanfordCoreNLPServer -preload tokenize,pos,parse,sentiment,ssplit</span></pre><p id="09b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后在<code class="fe ls lt lu lv b">speechcore/src/main/resources/</code>下创建文件<code class="fe ls lt lu lv b">nlpserver.properties</code></p><pre class="kg kh ki kj gt mw lv mx my aw mz bi"><span id="164d" class="na ly iq lv b gy nb nc l nd ne">nlp.host=&lt;your server ip&gt;<br/>nlp.port=9000</span></pre><p id="a4a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更改此文件后需要重建。</p><h1 id="e5e3" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">资源</h1><p id="5501" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">GitHub上提供了源代码:</p><p id="aacd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/philip-han/Great-Dictator-Android" rel="noopener ugc nofollow" target="_blank">安卓应用库</a> <br/> <a class="ae kv" href="https://github.com/philip-han/dictator_graal" rel="noopener ugc nofollow" target="_blank">共享库库</a> <br/> <a class="ae kv" href="https://github.com/philip-han/Great-Dictator-iOS" rel="noopener ugc nofollow" target="_blank"> iOS应用库</a></p></div></div>    
</body>
</html>