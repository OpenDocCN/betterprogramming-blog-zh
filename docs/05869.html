<html>
<head>
<title>Implement a Networking Layer Using Combine in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5中使用Combine实现网络层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-networking-layer-using-combine-in-swift-5-8a83e3ac9bae?source=collection_archive---------0-----------------------#2020-08-13">https://betterprogramming.pub/implement-a-networking-layer-using-combine-in-swift-5-8a83e3ac9bae?source=collection_archive---------0-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb13" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个灵活的解决方案，可复制并粘贴到您的新应用中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/007aa60c534ef7dbdecd5e5c7806527b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eBnuHz4NyzxyysT7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Thom Bradley 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="082b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解如何通过利用组合发布者、可编码、可自定义字符串转换协议和自定义端点结构来设计和创建高效且易于使用的网络层。</p><p id="a24f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程结束时，您将有一个现成的实现，您可以轻松地将它复制并粘贴到您的应用程序中，并按照您想要的方式扩展它。</p><p id="7c0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的源代码可以在文章的底部找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="11b5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们开始吧</h1><p id="e582" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在深入研究代码之前，让我们先概述一下网络层的所有组件:</p><ul class=""><li id="12cd" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><em class="ni">端点</em>——一个方便的<code class="fe nj nk nl nm b">struct</code>，具有<code class="fe nj nk nl nm b">path</code>和<code class="fe nj nk nl nm b">queryItems</code>属性。通过在其上定义扩展，我们可以方便地创建REST APIs的基本URL，定义特定的端点和头(当我们开始实现它时，这对您更有意义，所以不要担心)。</li><li id="a47e" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><em class="ni">可编码模型</em>——可以从JSON创建的简单对象。</li><li id="d3eb" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><em class="ni">网络控制器</em> —负责直接与<code class="fe nj nk nl nm b">URLSessionTask</code> s合作，从数据中解码出<code class="fe nj nk nl nm b">Codable</code>模型。例如，它有一个通用的<code class="fe nj nk nl nm b">get()</code>方法，返回包含模型的发布者。</li><li id="46a6" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><em class="ni">逻辑控制器— </em>从表示层(视图/视图控制器)抽象出网络控制器正在完成的工作，并提供查询模型的简单方法。例如，它可能有一个<code class="fe nj nk nl nm b">getUsers()</code>方法，该方法调用网络控制器所需的方法并返回一个用户数组。</li></ul><p id="d5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个名为Dummy API的免费REST API:</p><div class="ns nt gp gr nu nv"><a href="https://dummyapi.io" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">伪用户数据api。超正析象管(Image Orthicon)</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">拥有虚假数据的全周期REST生产API服务器，100个用户，800多个帖子，1000条评论，24/7可供您…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">dummyapi.io</p></div></div></div></a></div><p id="8a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始一个接一个地创建每个组件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7bc6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可编码模型</h1><p id="e970" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将从虚拟API中获取用户。JSON看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d57f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们创建了以下两个结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们遵循了<a class="ae ky" href="https://levelup.gitconnected.com/automate-debugging-swift-objects-using-the-customstringconvertible-protocol-c01fff74380f?source=friends_link&amp;sk=a4b2f320bf7da16bc771ef628b630f9c" rel="noopener ugc nofollow" target="_blank"> CustomStringConvertible协议</a>来轻松调试我们的对象。我们有以下方便的扩展，减轻了为每个一致性结构定义<code class="fe nj nk nl nm b">description</code>属性的负担:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型完成后，现在让我们来看另一个组件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c21" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">端点</h1><p id="e4f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">定义一个<code class="fe nj nk nl nm b">Endpoint</code>结构，我们将扩展它以满足特定的API需求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="63a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要创建一个扩展，在这个扩展中，我们为虚拟API构造了<code class="fe nj nk nl nm b">URL</code>,并且还定义了包含应用ID(虚拟API所必需的)的<code class="fe nj nk nl nm b">headers</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们定义几个端点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="10b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将只使用第一个。我提供了后两个来展示我们如何方便地添加参数和设置路径。</p><p id="2c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，该是<code class="fe nj nk nl nm b">NetworkController</code>的时候了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="74a4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">网络控制器</h1><p id="dab1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们定义一个<code class="fe nj nk nl nm b">NetworkController</code>协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们有一个查询单个可编码模型的方法。</p><p id="6d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要创建协议的具体实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在短短四行代码中，我们完成了以下工作:</p><ul class=""><li id="c3c0" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">创建并启动一个<code class="fe nj nk nl nm b">URLSessionDataTask</code></li><li id="ceed" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated">如果没有出现错误，获取<code class="fe nj nk nl nm b">data</code></li><li id="4ae9" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated">解码模型对象</li><li id="c344" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated">返回包含模型对象或错误的发布者</li></ul><p id="0386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还剩下最后一个组件——一个<code class="fe nj nk nl nm b">LogicController</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7921" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">逻辑控制器</h1><p id="e2ca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为我们想要获取用户，所以我们的逻辑控制器将被称为<code class="fe nj nk nl nm b">UsersLogicController</code>。首先，让我们从一个协议开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们依赖于<code class="fe nj nk nl nm b">NetworkController</code>并定义了三个方法:</p><ul class=""><li id="d579" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe nj nk nl nm b">getUsers()</code> —默认情况下查询20个用户</li><li id="27c0" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><code class="fe nj nk nl nm b">getUsers(count: Int)</code> —查询指定的<code class="fe nj nk nl nm b">count</code>用户</li><li id="4630" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><code class="fe nj nk nl nm b">getUser(id: String)</code> —查询一个与提供的<code class="fe nj nk nl nm b">id</code>匹配的用户</li></ul><p id="5fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们直接使用端点并调用所需的<code class="fe nj nk nl nm b">NetworkController</code>方法。通过将该类标记为<code class="fe nj nk nl nm b">final</code>，我们向其他开发人员发出信号，表明该类不被设计为子类。</p><p id="1588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以测试我们创造了什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="af23" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用法示例</h1><p id="65df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们初始化<code class="fe nj nk nl nm b">NetworkController</code>和<code class="fe nj nk nl nm b">UsersLogicController</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建将存储我们未来订阅的<code class="fe nj nk nl nm b">subscriptions</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="684f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以如下获取用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不出所料，我们看到<code class="fe nj nk nl nm b">User</code>对象像预期的那样打印得很漂亮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/45ec4efff1634a1372e74fdf3cf9fa78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kq1W7ceX7yE7MUGQDwJe0A.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7865" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><p id="7dd9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Xcode游乐场的源代码可以在<a class="ae ky" href="https://gist.github.com/zafarivaev/c9ffa6e47b302795fa3413fb5901b72e" rel="noopener ugc nofollow" target="_blank">概要</a>中找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="29e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="095c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">查看John Sundell关于管理URL和端点的视频，这是这篇文章的灵感来源:</p><div class="ns nt gp gr nu nv"><a href="https://swiftbysundell.com/clips/4/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Swift clip:管理URL和端点| Sundell Swift</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在本视频中，我们将了解三种不同的方式来管理URL和服务器端点，即Swift应用程序…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">swiftbysundell.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks nv"/></div></div></a></div><p id="0dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想了解更多关于联合收割机的信息吗？查看我的其他相关作品:</p><ul class=""><li id="4fbf" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/better-programming/use-combine-to-write-more-readable-swift-code-9e8e6cf0bf50" rel="noopener">使用Combine编写更可读的Swift代码</a></li><li id="69bd" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><a class="ae ky" href="/better-programming/replace-delegation-with-combine-in-swift-5-e4c193655e7b" rel="noopener ugc nofollow" target="_blank">在Swift 5中用Combine替换Delegation】</a></li><li id="c5ab" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><a class="ae ky" href="/better-programming/7-sequential-operators-you-should-know-from-swift-combine-1775ce3c47c8" rel="noopener ugc nofollow" target="_blank">您应该从Swift Combine了解的7个顺序运算符</a></li><li id="9699" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><a class="ae ky" href="/better-programming/6-combining-operators-you-should-know-from-swift-combine-17ea69d9dad7" rel="noopener ugc nofollow" target="_blank">你应该从Swift Combine了解的6个合并运算符</a></li><li id="cbac" class="mz na it lb b lc nn lf no li np lm nq lq nr lu ne nf ng nh bi translated"><a class="ae ky" href="/better-programming/5-transforming-combine-operators-you-should-know-4603fe112d74" rel="noopener ugc nofollow" target="_blank"> Swift:你应该知道的5个变换合并运算符</a></li></ul><p id="1381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>