<html>
<head>
<title>What Are Python Iterators and Iterables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Python迭代器和可迭代对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-python-iterators-and-iterables-c1dd67559d2f?source=collection_archive---------5-----------------------#2021-07-08">https://betterprogramming.pub/what-are-python-iterators-and-iterables-c1dd67559d2f?source=collection_archive---------5-----------------------#2021-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解可迭代对象、迭代器和生成器如何使循环成为可能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae2efaca268f3f8679dd8c95cdb8a29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NeHcKnn-30EpkloO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kai_wenzel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文泽尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，<strong class="lb iu">可迭代</strong>是可以循环的东西。</p><p id="c0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，列表是一个可迭代的对象:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7468" class="ma mb it lw b gy mc md l me mf">numbers = [1,2,3,4,5]</span><span id="163b" class="ma mb it lw b gy mg md l me mf">for number in numbers:<br/>    print(number)</span></pre><p id="86fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d0ea" class="ma mb it lw b gy mc md l me mf">1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="3308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表不是唯一可以循环的对象。可以用元组、字典、字符串、文件等等来做。</p><p id="e4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这怎么可能呢？是什么让这些对象可迭代？为什么迭代器和可迭代对象在Python中有用？</p><h1 id="0db8" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Python中的迭代器和迭代器</h1><p id="3471" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了符合iterable的条件，对象必须实现<code class="fe nd ne nf lw b">__iter__()</code>方法。让我们使用内置的<code class="fe nd ne nf lw b">dir()</code>方法检查一个数字列表，看看它是否有一个:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f4fc" class="ma mb it lw b gy mc md l me mf">numbers = [1,2,3,4,5]</span><span id="b1bf" class="ma mb it lw b gy mg md l me mf">print(dir(numbers))</span></pre><p id="6a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/a8533f465c7a6feadf97a83317702242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZV8xOJmmkckRgI4qgqUwg.png"/></div></div></figure><p id="7c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到列表中有<code class="fe nd ne nf lw b">__iter__()</code>方法。因此它是可迭代的。</p><p id="6c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让For循环工作，它调用list的<code class="fe nd ne nf lw b">__iter__()</code>方法。这个方法返回一个<strong class="lb iu">迭代器</strong>。循环使用这个迭代器遍历所有的值。</p><p id="5716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器是一个有状态的对象。它会记住迭代过程中的位置。迭代器也知道如何获取下一个值。他们通过使用每个迭代器都需要的<code class="fe nd ne nf lw b">__next__()</code>方法来做到这一点。</p><p id="3348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检索<code class="fe nd ne nf lw b">numbers</code>列表的迭代器进行检查:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8c16" class="ma mb it lw b gy mc md l me mf">iter_numbers = iter(numbers)</span></pre><p id="c406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(这与调用<code class="fe nd ne nf lw b">numbers.__iter__()</code>相同)</p><p id="b3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对此调用<code class="fe nd ne nf lw b">dir()</code>,看看它有哪些方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2fde" class="ma mb it lw b gy mc md l me mf">print(dir(iter_numbers))</span></pre><p id="943e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/3e998d0398ff3391662217c2a991abf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kpwEvQJzuKLJyCfOTbPEg.png"/></div></div></figure><p id="ab20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有描述迭代器的<code class="fe nd ne nf lw b">__next__()</code>方法。</p><h2 id="e56c" class="ma mb it bd mi ni nj dn mm nk nl dp mq li nm nn ms lm no np mu lq nq nr mw ns bi translated">概括一下</h2><ul class=""><li id="9db3" class="nt nu it lb b lc my lf mz li nv lm nw lq nx lu ny nz oa ob bi translated">列表是可迭代的，因为它有<code class="fe nd ne nf lw b">__iter__()</code>方法。</li><li id="8582" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe nd ne nf lw b">__iter__()</code>方法返回一个迭代器。</li><li id="1d5d" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">迭代器使用<code class="fe nd ne nf lw b">__next__()</code>方法获取下一个值。</li></ul><p id="74fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe nd ne nf lw b">numbers</code>列表的迭代器上调用<code class="fe nd ne nf lw b">__next__()</code>方法，看看会发生什么:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ea55" class="ma mb it lw b gy mc md l me mf">numbers = [1,2,3,4,5]<br/>iter_numbers = iter(numbers)</span><span id="aa0f" class="ma mb it lw b gy mg md l me mf">next(iter_numbers)</span></pre><p id="b0c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="556b" class="ma mb it lw b gy mc md l me mf">1</span></pre><p id="9065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再来一次:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b97d" class="ma mb it lw b gy mc md l me mf">next(iter_numbers)</span></pre><p id="0ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="eb89" class="ma mb it lw b gy mc md l me mf">2</span></pre><p id="f71c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nd ne nf lw b">next(iter_numbers)</code>总是返回<code class="fe nd ne nf lw b">numbers</code>列表中的下一个号码。这是可能的，因为迭代器是一个有状态的对象。这意味着它记得上次调用<code class="fe nd ne nf lw b">__next__()</code>时停止的地方。</p><p id="2587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再调用几次<code class="fe nd ne nf lw b">__next__()</code>方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8ccc" class="ma mb it lw b gy mc md l me mf">next(iter_numbers)<br/>next(iter_numbers)<br/>next(iter_numbers)<br/>next(iter_numbers)</span></pre><p id="8276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9975" class="ma mb it lw b gy mc md l me mf">3<br/>4<br/>5<br/><strong class="lw iu">Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>StopIteration</strong></span></pre><p id="ebf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当值用完时，会出现一个<code class="fe nd ne nf lw b">StopIteration</code>异常。此时，迭代器被<strong class="lb iu">用尽</strong>。</p><p id="22e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是一个for循环在引擎盖下的工作原理。它调用链表上的<code class="fe nd ne nf lw b">__iter__()</code>方法来检索迭代器，然后重复调用迭代器上的<code class="fe nd ne nf lw b">__next__()</code>方法，直到没有值了。抛出了一个<code class="fe nd ne nf lw b">StopIteration</code>异常，但是您看不到它，因为for循环会为您处理它。</p><p id="74c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何在一个<code class="fe nd ne nf lw b">while</code>循环中使用可迭代对象和迭代器来模拟for循环的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ab9d" class="ma mb it lw b gy mc md l me mf">1<br/>2<br/>3<br/>4<br/>5</span></pre><h1 id="f069" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何自己实现迭代器和可迭代对象</h1><p id="3238" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以对任何类实现<code class="fe nd ne nf lw b">__iter__()</code>和<code class="fe nd ne nf lw b">__next__()</code>方法。换句话说，您可以自己构建定制的可迭代对象和迭代器。</p><h2 id="d84d" class="ma mb it bd mi ni nj dn mm nk nl dp mq li nm nn ms lm no np mu lq nq nr mw ns bi translated"><strong class="ak">例子</strong></h2><p id="086f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我相信你对Python中内置的<code class="fe nd ne nf lw b">range()</code>函数很熟悉。你可以这样使用它:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9986" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">for</strong> i <strong class="lw iu">in</strong> range(4):<br/>    print(i)</span></pre><p id="1c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8b0c" class="ma mb it lw b gy mc md l me mf">0<br/>1<br/>2<br/>3</span></pre><p id="72e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们实现一个行为类似于<code class="fe nd ne nf lw b">range()</code>函数的自定义iterable:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="61df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细了解一下发生了什么:</p><p id="120e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第2–4行</strong></p><ul class=""><li id="201d" class="nt nu it lb b lc ld lf lg li oj lm ok lq ol lu ny nz oa ob bi translated"><code class="fe nd ne nf lw b">__init__()</code>方法使得用起始值和结束值初始化<code class="fe nd ne nf lw b">RangeValues</code>对象成为可能。比如:<code class="fe nd ne nf lw b">RangeValues(0, 10)</code>。</li></ul><p id="90b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第6–7行</strong></p><ul class=""><li id="9c88" class="nt nu it lb b lc ld lf lg li oj lm ok lq ol lu ny nz oa ob bi translated"><code class="fe nd ne nf lw b">__iter__()</code>方法使得类是可迭代的。也就是说，有可能调用<code class="fe nd ne nf lw b"><strong class="lb iu">for</strong> i <strong class="lb iu">in</strong> RangeValues(0,10)</code>。</li><li id="4499" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe nd ne nf lw b">__iter__()</code>方法必须返回一个迭代器，也就是一个带有<code class="fe nd ne nf lw b">__next__()</code>方法的对象。在这里，您可以将<code class="fe nd ne nf lw b">__next__()</code>方法实现到这个类中。因此，<code class="fe nd ne nf lw b">__iter__()</code>方法可以返回类本身，因为它是一个迭代器。</li></ul><p id="0341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第9–14行</strong></p><ul class=""><li id="3a0b" class="nt nu it lb b lc ld lf lg li oj lm ok lq ol lu ny nz oa ob bi translated"><code class="fe nd ne nf lw b">__next__()</code>方法负责从头到尾遍历这些值。</li><li id="06a7" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">当它到达范围的末尾时，它会引发一个<code class="fe nd ne nf lw b">StopIteration</code>异常。</li><li id="65e0" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">如果迭代器还没有到达末尾，它将继续返回当前值(并在下一轮递增)。</li></ul><p id="9043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们最后测试一下<code class="fe nd ne nf lw b">RangeValues</code>类:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b7b8" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">for</strong> i <strong class="lw iu">in</strong> RangeValues(1,5):<br/>    print(i)</span></pre><p id="d680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ee91" class="ma mb it lw b gy mc md l me mf">1<br/>2<br/>3<br/>4</span></pre><p id="88ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它就像一个魔咒！</p><h1 id="8351" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">生成器—创建可读的迭代器</h1><p id="757c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你看一下上面的<code class="fe nd ne nf lw b">RangeValues</code>类的例子，你会发现读起来令人望而生畏。</p><p id="6e11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Python为您提供了生成器。</p><p id="dd20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器是一种迭代器，它的实现更容易阅读。这是因为生成器让你省略了<code class="fe nd ne nf lw b">__iter__()</code>和<code class="fe nd ne nf lw b">__next__()</code>方法的实现。</p><p id="f459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为生成器是一个迭代器，它不返回单个值。相反，它<strong class="lb iu">一次产生一个</strong>值，并跟踪当前状态。</p><p id="a573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们把前面例子中的<code class="fe nd ne nf lw b">RangeValues</code>类变成一个生成器，使它更易读:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5729" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">def</strong> range_values(start, end):<br/>    current = start<br/>    <strong class="lw iu">while</strong> current &lt; end:<br/>        <strong class="lw iu">yield</strong> current<br/>        current += 1</span></pre><p id="6077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下这个功能:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1fc9" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">for</strong> i <strong class="lw iu">in</strong> range_values(0,5):<br/>    print(i)</span></pre><p id="3884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3db5" class="ma mb it lw b gy mc md l me mf">0<br/>1<br/>2<br/>3<br/>4</span></pre><p id="5577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf lw b">range_values</code>的工作方式和<code class="fe nd ne nf lw b">RangeValues</code>完全一样，但是实现方式更加简洁。</p><h1 id="6949" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">无限数量的元素</h1><p id="ca3d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">迭代器只关心当前值以及如何获取下一个值。因此，创建无限的价值流是可能的，因为你不需要把它们存储在任何地方。</p><h2 id="2fdc" class="ma mb it bd mi ni nj dn mm nk nl dp mq li nm nn ms lm no np mu lq nq nr mw ns bi translated">例子</h2><p id="8378" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们创建一个无限迭代器，它产生起始值之后的所有数字。让我们使用一个生成器函数来保持它的可读性:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b161" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">def</strong> infinite_values(start):<br/>    current = start<br/>    <strong class="lw iu">while</strong> True:<br/>        <strong class="lw iu">yield</strong> current<br/>        current += 1</span></pre><p id="7c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(如果你想看看如何用一个类做到这一点，<a class="ae ky" href="https://gist.github.com/artturijalli/2c80f4a538e1d438ea9627b36992dc9f" rel="noopener ugc nofollow" target="_blank">这里是</a>。)</p><p id="ed53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个迭代器产生从<code class="fe nd ne nf lw b">start</code>到无穷大的值。</p><p id="0ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行它。(<strong class="lb iu">警告:</strong>无限循环)</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5261" class="ma mb it lw b gy mc md l me mf">infinite_nums = infinite_values(0)</span><span id="fe9a" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">for</strong> num <strong class="lw iu">in</strong> infinite_nums:<br/>    print(num)</span></pre><p id="7b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="afc8" class="ma mb it lw b gy mc md l me mf">0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>.<br/>.<br/>.</span></pre><p id="42b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从语法上看，<code class="fe nd ne nf lw b">infinite_nums</code>似乎是<code class="fe nd ne nf lw b">0</code>之后的一个无限数字列表，但它只不过是一个迭代器，只存储当前值，并知道如何获取下一个值。</p><h1 id="5425" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">迭代器和可迭代对象为什么有用</h1><p id="fbd6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">迭代器和可迭代对象是内存高效的，因为它们使得只存储当前值并知道如何获得下一个值成为可能。</p><p id="90d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，如果你有一个包含数百亿条信息的文件，比如密码，你需要循环遍历它们。你不可能在一个列表或者一个元组中存储这么多的条目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/af297f1ef3a784292440028045625d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kbSPG8jkr9lfzsBk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@k_yasser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Khadeeja Yasser </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ea3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是迭代器派上用场的地方。你可以一个接一个地访问这些元素，而不用把它们存储在程序的内存中。更好的是，从语法上看，您似乎是在从一系列元素中读取整个列表。</p><h1 id="85e1" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="4393" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Python中，<strong class="lb iu"> iterable </strong>是可以循环的东西。</p><p id="703e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在低层次上，iterable是实现返回迭代器的<code class="fe nd ne nf lw b">__iter__()</code>方法的对象。</p><p id="9b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu">迭代器</strong>是一个有状态的对象。它会记住迭代过程中的位置。要成为迭代器，对象必须实现<code class="fe nd ne nf lw b">__next__()</code>方法来获得迭代过程中的下一个值。</p><p id="4906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住每一个迭代器都是可迭代的，而不是反过来。</p><p id="0242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。编码快乐！</p><p id="9a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很想加入你的LinkedIn网络。请随意连接<a class="ae ky" href="https://www.linkedin.com/in/artturi-jalli-29619413a" rel="noopener ugc nofollow" target="_blank">阿图里·贾利</a>。</p><h1 id="9697" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">你可能会发现见解深刻</h1><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/50-python-interview-questions-and-answers-5230fe2a0db6"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">50 Python面试问答</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">Ace您的下一次编码面试</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">better编程. pub</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a rel="noopener  ugc nofollow" target="_blank" href="/10-useful-python-snippets-to-code-like-a-pro-e3d9a34e6145"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">10个有用的Python片段，让你像专业人士一样编写代码</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">我每天使用的有用的提示和技巧</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">better编程. pub</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://python.plainenglish.io/how-to-perform-efficient-looping-in-python-811bd76d6aa" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">如何在Python中执行高效的循环</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">了解如何使用Itertools高效地执行与迭代相关的任务</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">python .平原英语. io</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>