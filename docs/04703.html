<html>
<head>
<title>Understand the Flow of a HTTP Request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解HTTP请求的流程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-the-flow-of-a-http-request-1a268ec193f0?source=collection_archive---------0-----------------------#2020-05-01">https://betterprogramming.pub/understand-the-flow-of-a-http-request-1a268ec193f0?source=collection_archive---------0-----------------------#2020-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6319" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当你在浏览器中输入一个网址时会发生什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f1b71d7eeaa41bc3a9ba68ae01388aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDpXIH19JkTjXYqhHyTcpg.png"/></div></div></figure><p id="44c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想知道当你在浏览器中点击回车会发生什么吗？这篇文章从开发人员的角度回答了这个问题，包括开发人员应该知道的关于完成HTTP请求的所有事情。虽然它只是一个传输文件的协议，但它本质上是互联网的主干。</p><p id="4d1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你在浏览器的地址栏中输入一个URL时，它会手动开始，或者通过应用程序、网站(JavaScript)或其他程序以编程方式开始，并在收到响应时结束，在这两者之间，神奇的事情发生了。</p><p id="265b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们通常理解HTTP请求的方式(一种过于简化的表示)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lq"><img src="../Images/e1b998a77ee53f3faf73bf180ae8e8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2UbC5pSRyjGmF1ezB9hvYg.png"/></div></div></figure><p id="0509" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设你在你的系统上打开<code class="fe lr ls lt lu b">app.mydomain.com/me</code>。浏览器会自动假定<code class="fe lr ls lt lu b">http://</code>在你的URL的开头。</p><p id="e6f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面我们来分解一下网址<code class="fe lr ls lt lu b">http://app.mydomain.com/me</code>:</p><ul class=""><li id="1900" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe lr ls lt lu b">http://</code>:用于通信的协议</li><li id="34ad" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe lr ls lt lu b">mydomain.com</code>:服务器的域</li><li id="eb77" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe lr ls lt lu b">app</code>:服务器的子域</li><li id="adda" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe lr ls lt lu b">/me</code>:路径</li></ul><p id="72d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HTTP协议具有普遍共享的标准预定义规则，这使得有意义的通信成为可能，就像英语具有使我们能够通信的标准语法一样。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="db73" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">那么一旦你点击了回车，我们的请求如何到达服务器呢？</h1><p id="0248" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">互联网仅仅是一个全球性的电缆网络，它允许每一个连接到网络的设备与任何其他连接到网络的设备进行通信。</p><p id="90f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是世界如何通过承载全球所有数据的海底电缆连接起来的。(本图仅显示海底电缆。陆地网络没有显示出来，但确实存在。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/049c756f17f8641739ac57a98d55bdfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IsISrALCWNWKQX_RkAWqMg.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">横跨全球的海底电缆网络</p></figure><p id="2db7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果这对你来说是新的，不要担心——你并不孤单。很长一段时间，我认为互联网是通过卫星路由的(是的，我知道那很傻！).</p><p id="c1c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设你在伦敦，你想连接到美国的服务器。这些电缆中的一条将把你的请求从伦敦传送到美国。</p><p id="6ef6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是有一个问题。这种数据包/数据的路由使用IP地址而不是域名，就像你的邮件到达时带有你的街道名和住宅地址，而不仅仅是你的名字。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="627d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">那么我们如何找到</strong> <code class="fe lr ls lt lu b"><strong class="ak">app.mydomain.com</strong></code> <strong class="ak">的IP地址呢？</strong></h1><p id="59ef" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">这就是域名系统(DNS)发挥作用的地方。这是互联网的地址簿。你连接到一个DNS服务器并请求<code class="fe lr ls lt lu b">app.mydomain.com</code>的IP地址，DNS服务器返回给你IP地址。</p><p id="b60b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的客户端如何知道DNS服务器的地址？</p><p id="2b95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为一台设备必须知道另一台设备的IP地址才能进行通信，所以客户端必须事先知道DNS服务器的IP地址。当您连接到网络时，会为客户端分配一个IP地址。它还被告知DNS服务器的地址。此外，您可以手动配置您的设备以使用特定的DNS服务器。</p><p id="79f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DNS服务器实际上是如何将域名解析为IP地址的？</p><p id="e7cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">客户端向查询多个名称服务器的DNS递归服务器发送请求，直到解析该查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/da26d73fc3ab2a53b5f71738316c9569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HVQfiRwxSg7Y5yo3rGWlQ.png"/></div></div></figure><p id="3ed6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每当你购买一个域名，你配置一个域名服务器，负责保存你所有的DNS记录。</p><p id="2d48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您已经将您的域、<code class="fe lr ls lt lu b">mydomain.com</code>、名称服务器配置为Cloudflare ( <code class="fe lr ls lt lu b">ns1.cloudflare.com</code>)。因此，无论你的域名有什么问题，<code class="fe lr ls lt lu b">ns1.cloudflare.com</code>都有权利回答。这就是这个域名服务器被称为<em class="nt">权威域名服务器的原因。</em></p><p id="a0d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么你的DNS递归器是如何到达你的权威域名服务器的呢？</p><ul class=""><li id="1109" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ma mb mc md bi translated">它查询根域名服务器以获取所有TLD域名服务器的位置，在我们的例子中(<code class="fe lr ls lt lu b">.com</code>)。</li><li id="2e40" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated">TLD域名服务器存储该TLD所有域名的权威域名服务器的位置(例如，<code class="fe lr ls lt lu b">.com</code> TLD域名服务器将存储所有<code class="fe lr ls lt lu b">.com</code>域名的所有权威域名服务器的位置)。</li><li id="89af" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated">权威名称服务器然后根据您配置的记录返回。例如，我为<code class="fe lr ls lt lu b">mydomain.com</code>配置了这样的DNS记录:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/af00fbd313edf5c5573355a9538828eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpTMjSN8EzVoQT_P5fMfmQ.png"/></div></div></figure><p id="3ea1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们请求了<code class="fe lr ls lt lu b">app.mydomain.com</code>，所以它将查找名为<code class="fe lr ls lt lu b">app</code>的记录。所以它会基于此返回一个IP地址。</p><p id="6e6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在客户端可以连接到服务器，因为它获得了<code class="fe lr ls lt lu b">app.mydomain.com</code>的IP地址。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5697" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">服务器如何响应HTTP请求？</strong></h1><p id="1f34" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">我们运行一个web服务器，负责处理这些传入的HTTP请求。最常用web服务器是Apache和nginx。这些web服务器持续监听传入的请求，并对这些请求做出响应。</p><p id="40ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等！</p><p id="6a65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一台服务器上必须运行多个进程，那么我们的请求如何到达Apache呢？</p><p id="0df3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像任何设备一样，可能有多个进程，这就是网络端口的用处。所以像Apache这样的进程会占用网络端口并监听这些端口。虽然一个进程可以使用多个端口，但是一个端口不能被多个进程使用。</p><p id="ddff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们还必须指定通信端口。但是我们没有提供港口，不是吗？</p><p id="bc84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我所说的，HTTP协议有一些普遍共享的预定义规则。其中之一是HTTP的默认端口是<code class="fe lr ls lt lu b">80</code>，HTTPS是<code class="fe lr ls lt lu b">443</code>，类似地，DNS有<code class="fe lr ls lt lu b">53</code>。所以我们的Apache必须监听我们服务器的端口<code class="fe lr ls lt lu b">80,443</code>。</p><p id="0d24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有默认端口并不意味着我们不能改变它。比方说，我们可以在<code class="fe lr ls lt lu b">3000</code>港运行Apache。但是由于我们使用HTTP协议和非标准的HTTP端口，我们必须像<code class="fe lr ls lt lu b">http://app.mydomain.com:3000/me</code>一样明确指定端口。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="beaa" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">Apache/nginx如何服务HTTP请求？</strong></h1><p id="1120" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">这是web服务器应用程序的两个最常见的用例:</p><ul class=""><li id="d9aa" class="lv lw it kw b kx ky la lb ld lx lh ly ll lz lp ma mb mc md bi translated">基于路径存储文件夹中的服务器静态文件</li><li id="39d5" class="lv lw it kw b kx me la mf ld mg lh mh ll mi lp ma mb mc md bi translated">将请求移交给节点服务器等其他流程，并让该流程处理和提供响应</li></ul><h2 id="b0dc" class="nv mr it bd ms nw nx dn mw ny nz dp na ld oa ob nc lh oc od ne ll oe of ng og bi translated"><strong class="ak">静态文件</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">静态站点的Apache虚拟主机配置文件</p></figure><p id="01af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您请求了<code class="fe lr ls lt lu b">app.mydomain.com/me</code>，它将在<code class="fe lr ls lt lu b">/var/www/my-static-website</code>中查找文件夹/文件，如果文件存在，它将返回该文件。或者如果一个文件夹存在，它将在那个文件夹中寻找<code class="fe lr ls lt lu b">index.html</code>(这也可以定制)并返回它。</p><h2 id="76ff" class="nv mr it bd ms nw nx dn mw ny nz dp na ld oa ob nc lh oc od ne ll oe of ng og bi translated"><strong class="ak">将该请求移交给其他进程</strong></h2><p id="a5c3" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">假设您有Node、Java、Python或其他服务器运行在端口<code class="fe lr ls lt lu b">4000</code>上，您希望该进程处理请求并生成响应。</p><p id="f2da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，Apache可以充当该服务器的代理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">代理的Apache虚拟主机</p></figure><p id="d731" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它会将任何针对<code class="fe lr ls lt lu b">app.mydomain.com</code>的请求转发给<code class="fe lr ls lt lu b">http://127.0.0.1:4000</code>，一旦收到响应，它会将其返回给客户端。它不需要局限于本地主机(<code class="fe lr ls lt lu b">127.0.0.1</code>)，也可以作为其他服务器的代理。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="75ef" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated"><strong class="ak">为什么不直接在端口80上运行我们的Node/Java/Python服务器，避免Apache的开销？</strong></h1><p id="c2ff" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">典型的情况是，您可能在一台服务器上运行多个网站。由于一个端口只能有一个进程，Apache接受请求，并根据<code class="fe lr ls lt lu b">ServerName</code>、<strong class="kw iu">、</strong>执行必要的操作。</p><p id="b735" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果您托管的是一台拥有独立服务器(如Node)的服务器，您可以去掉Apache，直接在端口<code class="fe lr ls lt lu b">80</code>上运行它。</p><p id="588f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，一旦响应被确定，它就被发送回客户机。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8fb6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">嗯，那是HTTP，但HTTPS是什么？</h1><p id="a846" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">HTTPS是HTTP的升级版。HTTP中的所有内容都以明文形式传输。我们知道，所有这些数据都是通过各种不同公司拥有的光缆网络传输的，并经过各种政治管辖区。任何人都可以简单地接入这个网络，读取客户端和服务器之间的所有消息。</p><p id="3133" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，输入您的Gmail帐户的密码，从您到Gmail服务器的每个人都能够阅读该电子邮件和密码。太可怕了，对吧？这就是没有HTTPS的互联网。HTTPS在客户端和服务器之间提供端到端的加密，所以没有人能读取这些信息。</p><p id="8a98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有HTTPS提供的安全性，大规模的现代互联网是不可能的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f6d2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="75b6" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">所有这些都是为了提供一个简单的HTTP请求。</p></div></div>    
</body>
</html>