<html>
<head>
<title>How to Use the Android Paging3 Library With Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过Jetpack Compose使用Android Paging3库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/turn-the-page-overview-of-android-paging3-library-integration-with-jetpack-compose-3a7881ed75b4?source=collection_archive---------4-----------------------#2022-09-14">https://betterprogramming.pub/turn-the-page-overview-of-android-paging3-library-integration-with-jetpack-compose-3a7881ed75b4?source=collection_archive---------4-----------------------#2022-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fba3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在你的应用程序中打开谷歌图书页面</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7b8eb2b01ec434a143dde946ab7349c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*su1z64DSVNNz6DoZrX6yJQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="80ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文将根据Android开发的最新趋势，重点解释如何在Android中实现分页。我们将使用Android中最新版本的分页——paging 3，并将探索如何将其与Jetpack Compose集成。</p><p id="68ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">剧透提醒:比你想象的简单！</p><h1 id="17fd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">寻呼还是不寻呼——这是个问题</h1><p id="b6b0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">什么时候应该实现分页？如果需要获取的数据相对较少，并且您知道需要在UI上显示所有这些数据，那么就没有必要对响应进行分页。</p><p id="cade" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您加载大量数据时，分页是有意义的，您可能需要，也可能不需要，这取决于用户交互。或者，当数据量不可预测时——在您实际发出呼叫之前，您不知道响应会有多大。在这种情况下，明智的做法是使用分页，在用户滚动页面时逐渐获取数据并呈现给用户。这被称为无限滚动，在本文中，我们将看看如何使用Google最新的分页库和Jetpack Compose来实现它。</p><h1 id="939f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">1.基础知识</h1><p id="fcd3" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">首先，我们需要一个支持分页的API。为此，我们将使用<a class="ae mo" href="https://developers.google.com/books/docs/v1/using" rel="noopener ugc nofollow" target="_blank">谷歌的图书API </a>。很方便，我知道。</p><p id="49b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将制作一个使用这个API的单屏幕应用程序，并允许用户搜索一本书。我们将利用分页来编写，使书籍的加载更快、更有效。每次请求我们只加载10本书，当用户滚动时，我们会加载更多。这样，我们只取我们需要的书，使网络请求更快，用户体验更好。</p><p id="db86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用最新版本的依赖项:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="abec" class="mu ls iq mq b gy mv mw l mx my">implementation "androidx.paging:paging-runtime:3.1.1"<br/>implementation "androidx.paging:paging-compose:1.0.0-alpha16"</span></pre><p id="503b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请确保您始终使用兼容版本的标准分页库和用于撰写的分页。不兼容的版本可能会导致崩溃。</p><p id="31de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mz">注意:为了简单起见，在这个例子中我将省略使用Koin或其他依赖注入框架。</em></p><h1 id="dfde" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">2.数据层</h1><p id="60af" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">数据层与任何其他层相同，由一个存储库和一个使用API的服务组成，在这种情况下，通过改进来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0292" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一的区别是分页源，它是分页库的一个特定部分。这就是奇迹发生的地方:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ff8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mz"/><code class="fe nc nd ne mq b">query</code><strong class="kx ir"><em class="mz"/></strong><em class="mz">参数仅用于搜索功能，与分页没有直接关系。</em></p><p id="17c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，该类需要从PagingSource抽象类继承并实现两个方法。让我们来实现它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3810" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<code class="fe nc nd ne mq b">load()</code>方法中，我们调用API。当然，这里我们需要<code class="fe nc nd ne mq b">limit</code>和<code class="fe nc nd ne mq b">startIndex</code>参数。这些都是分页库给我们提供的。limit参数指示在一次调用中应该获取多少项。它是由<code class="fe nc nd ne mq b">LoadParams</code>的<code class="fe nc nd ne mq b">loadSize</code>属性定义的。</p><p id="4f40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，<code class="fe nc nd ne mq b">startIndex</code>参数表示我们要开始获取的第一个元素的索引(这可能因API而异，有些使用页码代替)。由<code class="fe nc nd ne mq b">LoadParams</code>的key属性提供。</p><p id="dc85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用这两个属性调用端点，并将结果包装在一个<code class="fe nc nd ne mq b">Page</code>实例中。这里我们还需要提供上一个和下一个密钥。这对于正确获取数据至关重要。这里的逻辑是，<code class="fe nc nd ne mq b">prevKey</code>应该表示前一页，<code class="fe nc nd ne mq b">nextKey</code>应该指示下一页应该加载哪一页(下次调用<code class="fe nc nd ne mq b">key</code>时，它将被传递给该方法)。</p><p id="d8f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们到达最后一页，我们通过<code class="fe nc nd ne mq b"><strong class="kx ir">null</strong></code>，以指示全部数据已经被加载。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9677" class="mu ls iq mq b gy mv mw l mx my">override fun getRefreshKey(state: PagingState&lt;Int, Book&gt;): Int =<br/>    ((state.anchorPosition ?: 0) - state.config.initialLoadSize / 2)<br/>        .<em class="mz">coerceAtLeast</em>(0)</span></pre><p id="021b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nc nd ne mq b">getRefreshKey()</code> <em class="mz"> </em>方法向库提供了在数据无效的情况下加载哪个页面的信息。</p><p id="6def" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不正确地实现此方法会导致每当执行刷新时重新加载数据，而不是更新当前列表并保持列表中的位置。</p><h1 id="4a16" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">3.视图模型</h1><p id="6fce" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">ViewModel表示视图和数据层之间的链接。当谈到分页时，这是非常简单的。你只需要几条线就可以把所有东西连接起来。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0340" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就这么简单。我们创建了一个带有<code class="fe nc nd ne mq b">PagingConfig</code>的<code class="fe nc nd ne mq b">Pager</code>，并为寻呼机提供了一个<code class="fe nc nd ne mq b">PagingSource</code>。然后，我们将所有这些打包成一个流，使其易于被UI使用。就是这样！</p><h1 id="b485" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated"><strong class="ak"> 4。视图</strong></h1><p id="445c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我假设您对Compose有基本的了解，并且知道如何创建一个可组合的屏幕并在活动中呈现它。如果没有，您可以在本文末尾找到完整的代码，看看所有的东西是如何连接在一起的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f243" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还记得我说过将页面包装在流中对以后会有用吗？下面是在UI中使用流是多么方便——一行代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="000e" class="mu ls iq mq b gy mv mw l mx my">mainViewModel.bookPager.<em class="mz">collectAsLazyPagingItems</em>()</span></pre><p id="8d94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这条线是做什么的？基本上，正如它的名字所说——它收集流的数据作为惰性项。这正是我们所需要的。Compose知道如何处理这个对象，并在用户到达列表末尾时请求更多的条目。因此，我们将这个对象传递给可组合屏幕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dd4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以将<code class="fe nc nd ne mq b">LazyPagingItems</code>传递给Compose提供的懒惰布局之一:<code class="fe nc nd ne mq b">LazyColumn</code>、<code class="fe nc nd ne mq b">LazyRow</code>、<code class="fe nc nd ne mq b">LazyHorizontalGrid</code>或<code class="fe nc nd ne mq b">LazyVerticalGrid</code>。更多信息请点击这里<a class="ae mo" href="https://developer.android.com/jetpack/compose/lists#lazy" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cbbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里需要注意的另一件重要事情是处理加载状态。<code class="fe nc nd ne mq b">LazyPagingItems</code>包含<code class="fe nc nd ne mq b">LoadState</code>的信息。在这个例子中，我们只对<code class="fe nc nd ne mq b"><em class="mz">refresh</em></code>事件作出反应(初始加载或使数据源无效)，但是您也可以处理<code class="fe nc nd ne mq b"><em class="mz">append</em></code>、<code class="fe nc nd ne mq b"><em class="mz">prepend</em></code>、<em class="mz">、</em>和更多事件，并向用户显示适当的UI。</p><h1 id="1728" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">5.分析</h1><p id="5151" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated"><em class="mz">请注意，本文中的摘录就是摘录，并且(可能)是不可编译的，因为我故意省略了部分代码，以使其清晰易读。您可以在文章末尾找到完整代码的链接。</em></p><p id="9460" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们看看一切是如何一起工作的。</p><p id="1390" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我已经在项目中添加了数字，并在应用程序中附加了网络检查器，向您展示分页在后台是如何工作的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/dce91aede9eff22bd0b2b7ccfbfe4cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*483vN3rGmfDYJERVp4Yq4A.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分页在幕后是如何工作的？</p></figure><p id="828a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在代码中看到的，我们已经将负载大小设置为10。但是在初始加载时，<code class="fe nc nd ne mq b">maxResults</code>参数是30。为什么？</p><p id="02f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">缺省情况下，分页库使用预加载—它加载请求的<code class="fe nc nd ne mq b">load size * 3</code>。这是为了让用户在最初加载数据时有足够的内容可以查看。所有后续加载实际上是每个请求取10个项目。您可以通过定义<code class="fe nc nd ne mq b">PagingConfig</code>的<code class="fe nc nd ne mq b">initialLoadSize</code>属性来改变这种行为。</p><p id="c5cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最初，我们装载了30件物品。但是当我们进行到第20项时，一个新的请求产生了。这是分页库的另一个特性，称为<code class="fe nc nd ne mq b">prefetchDistance</code>。它默认为您在<code class="fe nc nd ne mq b">PagingConfig</code>中定义的<code class="fe nc nd ne mq b">pageSize</code>，但是如果您愿意，您可以在定义<code class="fe nc nd ne mq b">PagingConfig</code>时覆盖它。</p><h1 id="f55d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">6.收场白</h1><p id="b42e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">Paging3提供了方便的方法来延迟加载项目并呈现给用户，而不会在UI中出现明显的延迟。虽然您可以在旧的XML定义的视图中使用它，但是与Compose的集成确实是无缝的。每当您想要加载大量数据而不是一次提取全部数据时，请使用分页。</p><p id="6f03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整代码可以在GitHub上找到:</p><div class="ng nh gp gr ni nj"><a href="https://github.com/DimovskiD/turn-the-page" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">GitHub-DimovskiD/翻页:展示Paging3与Jetpack compose的集成</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div><p id="e48a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我已经发表了一篇后续文章，对这个代码库进行了扩展。如果你对Jetpack Compose的副作用很好奇，看看Jetpack Compose的闪屏:<a class="ae mo" href="https://dimovski-d.medium.com/splash-screen-with-jetpack-compose-side-effects-in-compose-how-to-use-them-2a90eb6e1d34" rel="noopener">Compose的副作用&amp;如何使用它们</a></p></div></div>    
</body>
</html>