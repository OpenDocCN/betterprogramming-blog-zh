# 通过构建总线服务来学习围棋

> 原文：<https://betterprogramming.pub/learn-go-by-building-a-bus-service-6c11e7b81b92>

## 和 Golang 一起坐公共汽车

![](img/ef44315d0cf9055d4039bb1cd3ab2ffe.png)

由[泰迪·奥斯特罗姆](https://unsplash.com/@teddyosterblom?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

让我们和 Golang 一起乘坐公共汽车，同时探索如何以及何时恰当地应用设计模式。

围棋是一种实用的语言。而是把事情做好。这允许一种更直接的编码风格，我个人认为这是对“经典的”面向对象编码风格的一种解脱，因为它们的类层次结构越来越多。使用 Go，我们仍然可以利用许多相关的设计模式，而不会因为必须编写 getters、setters、factory 类和复杂的类层次结构而分心。

设计模式从根本上来说只是解决某些问题的方法——或最佳实践。但是当在 Go 中应用时，这些模式实现起来变得简单，或者几乎微不足道。也许部分是由于关键词极简主义(`public static void main`)，有人吗？)，部分原因是与带有构造函数和析构函数的类相比，结构更简单，或者是因为缺少继承性，从而妨碍了代码解耦的尝试。但最重要的是，这是因为 Go 对函数式编程有极好的支持。这些品质结合起来使得设计模式在 Go 中变得简单而简洁。记住这一点，让我们通过乘坐公共汽车来演示一下吧！一路上，我们将把乘客送到他们的目的地，同时也应用一些设计模式。一路上会有大量的 Go 代码，所以至少要对这门语言有基本的了解。

# 公共汽车服务

我们先来定义一下以运送乘客为目的的公交车。为了处理机票，我们需要识别每个乘客，我们将使用他们的社会安全号(SSN)来识别。这些都将在一个`busservice`包中定义。

*注意:感谢 Reddit* *的* [*回复指出，在现实世界的应用程序中，我们不应该在我们的数据结构中使用 SSN 作为引用，因为在许多国家，SSN 是一条敏感的私有信息。然而，出于演示的目的，我们做了一个例外。*](https://www.reddit.com/r/golang/comments/iml937/i_wrote_a_piece_about_lightweight_design_patterns/?utm_source=share&utm_medium=web2x&context=3)

代码片段 01

这太棒了！我们有一辆载有一些乘客的公共汽车。先添加几个`Passengers`后，观察我们如何获得一个清单(乘客列表)。

代码片段 02

很可爱。但是有个问题！我们已经向外界公开了`Passengers`数据结构。我们可以在我们的`busservice`包中自由使用任何我们想要的数据结构，但是当它涉及到包的外部接口时，我们必须采取措施隐藏实现细节。否则，我们将失去对自己包的控制，并且以后不可能在不影响应用程序其余部分的情况下更改`Passengers`片。但是我们为什么要改变它呢？

比方说，我们的`Bus`增长(功能方面)到了一个点，我们发现自己经常需要找到一个特定的 SSN 的`Passenger`。每次都必须迭代`Passengers`切片是次优的，我们想用一张地图来代替它，如下所示。

代码片段 03

但是这影响了一切，包括我们如何将`Passengers`添加到`Bus`。我们已经知道了解决方案:使`Passengers`数据结构不被导出(私有),并导出一些使用它的方便方法。但是如何迭代一个任意的数据结构，就像我们为了生成一个清单需要做的那样？

# 访问者模式

这就是访问者模式的由来。我们将定义一个方法`VisitPassengers`，它接受一个为每个乘客调用的函数。为了更好地衡量，让我们也内在化增加乘客的功能。观察下面的实现。

代码片段 04

现在，让我们再来看看我们的主函数。

代码片段 05

那好多了！我们已经成功地对外界隐藏了数据结构，这意味着如果我们以后有改变它的自由，我们应该这么想。如果我们想的话，我们甚至可以用二叉查找树来代替它，而不会影响应用程序的其他部分。为了实现这一点，我们必须改变`VisitPassengers`方法的逻辑，但是它仍然会以完全相同的方式被调用。此外，现在我们可以使用常数时间查找 *O(1)* 快速有效地找到特定的`Passenger`，而不是在线性时间 *O(n)* 中循环遍历一个切片。

代码片段 06

注意，`VisitPassengers`用类型`Passenger`的值调用`visitor`，这意味着访问者正在接收*一个乘客的副本*，因此不能改变`Passenger`上的任何东西——至少就`Bus`而言不能。关于这个话题的更多信息，Yury Pitsishin 有一个很好的解释。传递一个`Passenger`的副本是很好的保护，因为一个普通的访问者可能没有修改它的选项，但是如果我们愿意，我们可以很容易地添加对更新乘客的支持。见下文。

代码片段 07

由于我们没有在`b.passengers`中使用指向乘客的指针，我们必须用更新后的`Passengers`创建一个新地图，并将其分配回`Bus`，因为我们不能获取地图条目的地址。但这只是当前实现的细微差别，因为您也可以使用带有指针的类型。

为什么不能取地图会员的地址？想了解更多原因，请看这篇文章。

有了这个实现，如果我们想的话，我们可以开始分配座位号。

代码片段 08

# 立面图案

随着我们的应用程序的增长，我们希望与`Passengers`的集合进行更多的交互(比如在获取清单时)，我们可以进一步将`Passengers`的映射转换成它自己的数据类型，用它自己的专用方法集来处理整个集合。这是完全可行的，同时尊重数据结构本身的隐私。观察。

代码片段 09

注意我们如何在实现中使用我们自己的`Visit`方法。此时，我们还引入了一个构造函数(`NewPassengerSet`)，以确保`Bus`不必知道我们在实现中使用了哪种数据结构。这是现在的`Bus`。

代码片段 10

由于构造函数的原因，`func main`有些变化。

代码片段 11

请注意处理乘客的责任是如何从`Bus`转移到`Passengers`的。这很好，因为`Bus`真的应该更关心从 *A* 到 *B* 获取有效载荷的责任。此外，从`Bus`的角度来看，所有关于乘客的逻辑都得到了简化，`Bus`甚至可以选择不公开更新其`Passengers`的功能。通过将`Passengers`转换成它自己的类型，然后嵌入到`Bus`上未导出的字段中，我们还演示了 Facade 模式，其中`Bus`向它的乘客提供接口，并完全控制公开哪些方法，不公开哪些方法。

# 观察者模式

让我们看看公共汽车站。那里有人在等着登上`Bus`，但他们还没有登上`Passengers`——直到他们真正登上`Bus`。在那之前，我们称他们为*潜在客户*。

公交车站本身可以仅仅是(车站的)名称、潜在客户列表以及路线上有该车站的已知公交车列表。让我们来定义它们。对于`Prospect`，我们可能也需要知道它们要去哪里，所以让我们为`BusStop`添加一个`Destination`和一些样板代码。

代码片段 12

`Prospects`如何知道`Bus`何时到达`BusStop`？需要有某种事件来通知`Bus`的到来，并启动登机算法。虽然`Bus`可以简单地搜索合适的`BusStop`并在其上调用一个`NotifyArrival`方法，但这不会成功。可能有数百个站点，其中许多是空的，为每个`Bus`维护这样一个列表是不可行的。相反，当一个`Prospect`到达一个`BusStop`时，`BusStop`将*向其路线上的总线注册自己*。这更有效，因为`Bus`不需要维护可能登上它的每个`Prospect`的列表，也不需要在更多的`Prospects`到达时接收更新，因为`Bus`正在途中。最重要的是，`Bus`提前知道它可以跳过哪个`BusStops`是一个优势。

一个`Prospect`的到来本身就是一个事件，需要`Prospects`去了解`BusStops`，但是让我们把重点放在`BusStop`和`Bus`之间的动态上。当一个`Prospect`到达时，方法`NotifyProspectArrival`被调用。可能看起来是这样的。

代码片段 13

我们还需要实现`NotifyBoardingIntent`:

代码片段 14

以及相关的通知程序:

代码片段 15

与观察者模式的典型例子相比，这个例子有点不典型，但是原理是一样的:模式的核心是`NotifyBoardingIntent`，它允许`BusStop`向`Bus`和`NotifyArrival`注册自己为*观察者*，其中*主题* ( `Bus`)通知观察者它的到来。由于`Bus`只在一个`BusStop`到达，我们通过调用`b.currentStop`找到那个确切的`BusStop`，然后通过调用`curr.NotifyBusArrival`通知它我们的到达。关于*观察者*和*主体*角色的更多信息可以在[这里](https://en.wikipedia.org/wiki/Observer_pattern.)找到。

这里有几个方法我们还没有实现，但是它们很琐碎。我们将在内部保存一个`BusStops`的切片和该切片的索引，该索引告诉我们哪个是当前的`BusStop`。

代码片段 16

停靠点的类型是指针，因此我们确保通知的是实际的`BusStops`而不是它们的副本。因为`stops`是一个内部数据结构，我们在这里不需要任何花哨的访问者模式；我们无意公开这个列表，至少不是为了本文的目的。

代码片段 17

如果我们用-1 的`currentStop`初始化`Bus`，上面的工作会好一点，所以让我们改变构造函数。

代码片段 18

下面实现了通知程序和对`BusStop`的相等性检查，前者的目的是登上它的前景。

代码片段 19

你可以让一个`Prospect`把自己变成一个`Passenger`，或者让`Bus`承担那个责任。第一种方法的优点是`Bus`永远不需要知道什么是`Prospect`，所以我个人认为这是一个更好的实现。将一个`Prospect`转换成一个`Passenger`很简单，因为它们在结构上是相似的，所以我们只需要转移 SSN。

代码片段 20

这就是观察者模式的全部内容。

至此，我们实际上可以实现让公交车绕圈行驶并搭载乘客的算法了。我们将在`main`中用几个`BusStops`和`Passengers`来使它变得有趣。

代码片段 21

运行模拟应该产生以下输出。

代码片段 22

# 战略模式

是时候向乘坐我们公交车的乘客收费了！

向乘客收费是不可选择的——没有免费的公交车！因此，向乘客收费的功能是登机算法的一部分，但是向每位乘客收取多少费用的决定最好留给`BusCompany`来决定。

为了避免让每辆巴士承担票价决策的负担，我们将使用策略模式。我们来看看登车算法，目前很简单。

代码片段 23

既然我们不再只是在`Bus`上增加一个`Passenger`，让我们将`Bus.Add`的名字改为`Bus.Board`，并与向乘客收取票价的方法一起实现。观察。

代码片段 24

请注意，我们没有将`chargeFn`直接传递给`Passenger`:`Passenger`没有责任知道`BusCompany`如何处理门票定价的任何细节，他们知道如何收取一定金额的费用就足够了。但是此时，另一个问题出现了:谁负责将`chargeFn`传递给`Board`？

`BusCompany`可能会提供这两种政策。

代码片段 25

然后由`BusCompany`为每个`Bus`提供当天的正确策略。

代码片段 26

现在我们有了一个可以提供价格的`BusCompany`—和两个定价策略——我们可以重构`BusStop.NotifyBusArrival`来使用新的`Board`方法。

代码片段 27

要做到这一点，我们只需要知道乘客是不是老年人。

代码片段 28

我们可能已经将`SeniorAge`与`BusCompany`联系起来，因此它可能会因每个公司的政策而异，但我们只能说这是一项国家法律，因此对所有人都是平等的。在这种情况下，使用常量*就可以了。此外，为了简单起见，我们将使用 SSN 的最后两位数作为年龄，如果年龄提取失败，就惊慌失措。在真实的程序中，我们会传播错误或在包边界检查有效的 SSN，这样我们就不必每次都检查它。*

回到`main`函数，我们会立即注意到这些变化已经使*贝蒂*成为了一名资深者。

代码片段 29

我们现在可以运行该程序并验证 *Betty* 确实为老年人收取了较低的票价(在本例中为周末价格)。输出如下。

代码片段 30

这种策略模式让我们能够让`Bus`专注于向`Passenger`收取乘车费用，而不是实现的技术细节:是否是工作日，以及`BusCompany`在多大程度上决定让乘客的特征影响定价。方法`Bus.Board`接收一个简单的`PriceCalculator`函数，并让`BusCompany`来分析情况并提供正确的定价策略。

# 结论

在这次总线之旅的过程中，我们应用了 visitor 模式来避免向其他包公开内部数据结构(`Bus.Passengers`)。然后，我们继续使用 facade 模式对相同的数据结构进行抽象，这允许我们编写方便的方法，可以轻松地对乘客集合进行操作，我们通过实现一个获取乘客清单的解决方案来演示这一点。

接下来，我们开始在乘客上车和下车时访问不同的公交车站，这是通过使用观察者模式实现事件驱动的通知系统来实现的。这使我们能够将责任保持在它们应该在的地方，而不是拥有一个无所不知的算法来联系其他一切。

在验证了我们的算法有效之后，我们应用了策略模式，以便向乘客收取不同的票价，而不产生对特定实现的依赖性，同时将计算细节的责任排除在公共汽车如何运行的细节之外。

最后，我们运行了完成的模拟，并带着几个乘客在城市里转了一圈。

我希望你喜欢阅读，甚至可能学到一些东西。

当然，还有比这里描述的更多的设计模式，我可能会在以后的续篇中介绍更多的设计模式。

*整个巡演代码都在我的* [*GitHub 资源库*](https://github.com/mkock/busproject) *中。*

# 参考

有关每个主题的更多信息，请搜索*！但是这里有一些链接可以帮助你开始。*

*   [了解更多关于访客模式的信息](https://www.tutorialspoint.com/design_pattern/visitor_pattern.htm)
*   [关于立面图案的更多信息](https://en.wikipedia.org/wiki/Facade_pattern)
*   [关于观察者模式的更多信息](https://en.wikipedia.org/wiki/Observer_pattern)
*   [了解更多关于战略模式的信息](https://en.wikipedia.org/wiki/Strategy_pattern)
*   在 [Go 中有更多设计模式的例子(带代码)，Golang By Example](https://golangbyexample.com/all-design-patterns-golang.) 是一个很棒的网站
*   Packt Publishing 有一个漂亮的小仓库，展示了 Go 中的各种设计模式
*   [关于提供许多设计模式背后的基本理念的坚实原则的信息](https://en.wikipedia.org/wiki/SOLID)
*   [这里记录了优秀的标准库](https://golang.org/pkg/)
*   要获得更多的灵感，请看我关于围棋轻量级模式的文章