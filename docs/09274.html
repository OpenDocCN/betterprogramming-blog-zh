<html>
<head>
<title>Concurrent API Calls and Race Conditions In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的并发API调用和竞争条件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/concurrent-api-calls-and-race-conditions-in-go-d59e0fe023d1?source=collection_archive---------3-----------------------#2021-08-05">https://betterprogramming.pub/concurrent-api-calls-and-race-conditions-in-go-d59e0fe023d1?source=collection_archive---------3-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba47" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Goroutines进行并发编程的快速示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a878eb363a12d3e40f82f4c07c50ebb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9SOz6XitzY4JadcV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@austris_a?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austris Augusts </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="294a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Golang(或Go)于2009年首次发布，至今已有一段时间。</p><p id="d9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着时间的推移，它变得越来越流行。至少这是我从栈溢出趋势中看到的，这是一个很好的衡量我们的开发者社区对技术/库/框架等的参与程度的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/c6410173278d6f6c3a351b362a359890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*6DmjPg47ZH7TI0gLTg4pUw.png"/></div></figure><p id="97b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go由Google开发，旨在帮助并发编程变得更容易、更安全、更高效。<a class="lw lx ep" href="https://medium.com/u/907a2ba198a8?source=post_page-----d59e0fe023d1--------------------------------" rel="noopener" target="_blank"> Lewis Fairweather </a>在这里<a class="ae ky" href="https://medium.com/swlh/want-to-learn-a-new-programming-language-consider-go-golang-1c32dc3788ba" rel="noopener">写了一篇关于Golang的深度文章</a>总结了Go背后的动机、优点和缺点。</p><p id="83af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究Go最伟大的特性之一:它对并发的支持。</p><p id="97bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将尝试执行多个API调用，比较其执行时间，并了解如何简单地在我们的程序中实现并发性。</p><h1 id="6be1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">基本代码</h1><p id="2851" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在我们的程序中，我们将调用网络来获取一些数据。为此，我将使用很酷的<a class="ae ky" href="https://api.chucknorris.io/" rel="noopener ugc nofollow" target="_blank"> Chuck Norris API </a>在每次调用中获得一些不错的引用。</p><p id="a6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们为我们的项目创建目录并使用<code class="fe mv mw mx my b">go mod init &lt;module_path&gt;/concurrent</code>。现在，让我们创建一个<code class="fe mv mw mx my b">main.go</code>文件。让我们定义存储API调用结果的结构。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加一个函数来进行网络调用。它看起来像下面这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加一个辅助函数，它可以打印出从程序开始到完成的执行时间。</p><pre class="kj kk kl km gt nb my nc nd aw ne bi"><span id="0875" class="nf lz it my b gy ng nh l ni nj">func printExecutionTime(t time.Time) {<br/>    fmt.Println("Execution time: ", time.Since(t))<br/>}</span></pre><p id="d646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数接受类型为<code class="fe mv mw mx my b">time.Time</code>的参数<code class="fe mv mw mx my b">t</code>，并计算当前时间和<code class="fe mv mw mx my b">t</code>之间的时间差。</p><h1 id="b300" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">顺序执行</h1><p id="6bf7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我们将获取总共100个报价。我将编写一个简单的函数来循环、获取这些引用，并将它们存储在一个map中。映射是从我们拨打的电话号码到收到的报价。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我要写我的主函数，它调用这个。</p><pre class="kj kk kl km gt nb my nc nd aw ne bi"><span id="641b" class="nf lz it my b gy ng nh l ni nj">func main() {<br/>    startTime := time.Now()<br/>    defer printExecutionTime(startTime)<br/>    getQuotesSequentially(100)<br/>}</span></pre><p id="79dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过终端在目录中用<code class="fe mv mw mx my b">go run .</code>运行它。这将按顺序运行我们所有的get报价，并在最后打印出执行时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2b42b95262fa8d83bec5aa470a9415d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-N2mV5MhnCxvuWy1iHoKxw.png"/></div></div></figure><p id="ba9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在我的电脑上总共花了25.52秒！哇，很慢，不是吗？</p><h1 id="c221" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">并行执行</h1><p id="1878" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">现在，让我们通过使用G<a class="ae ky" href="https://tour.golang.org/concurrency/1" rel="noopener ugc nofollow" target="_blank">or routines</a>和<a class="ae ky" href="https://gobyexample.com/waitgroups" rel="noopener ugc nofollow" target="_blank">等待组</a>来使我们的调用并发。</p><p id="fcae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">go routine是独立执行的函数，与程序中的其他go routine同时执行。虽然不完全相同，但可以将其视为轻量级线程。</p><p id="1827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等待组用于帮助我们跟踪将要运行的多个Goroutines。这可以防止我们的程序在主线程完成执行后立即退出。</p><p id="dbf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，拥有一个等待组有助于我们等到所有的程序全部完成。</p><p id="ee05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe mv mw mx my b">GetQuotesConcurrently</code>的函数来实现这一点。这看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们运行我们的主函数调用上面的。</p><pre class="kj kk kl km gt nb my nc nd aw ne bi"><span id="57b0" class="nf lz it my b gy ng nh l ni nj">func main() {<br/>    startTime := time.Now()<br/>    defer printExecutionTime(startTime)<br/>    getQuotesConcurrently(100)<br/>}</span></pre><p id="c95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行它，我们会看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/15de51dc1b5d789b758ce5a6ba4464b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUM9sG4gtwGjGpPMg3Ltrw.png"/></div></div></figure><p id="6c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，1.58秒！这比顺序执行快16倍！</p><h1 id="6db0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">并发执行(正确的方式)</h1><p id="5c29" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">然而，我们还没有完成。</p><p id="4a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go实际上为我们提供了一个很好的方法来检查我们的代码中是否有竞争条件。阅读此<a class="ae ky" href="https://blog.golang.org/race-detector" rel="noopener ugc nofollow" target="_blank">文章</a>了解更多信息。</p><p id="05c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行上面相同的函数，但是使用了<code class="fe mv mw mx my b">-race</code>标志和<code class="fe mv mw mx my b">go run -race .</code>来检查竞争条件，您将会看到:</p><p id="f91d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>为了清晰起见，我去掉了函数中的<code class="fe mv mw mx my b">fmt.Printf</code>语句。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/09632211deb582a1199de60f77f6661d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdygqfpjHnueDkcmWWAwVQ.png"/></div></div></figure><p id="f387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们已经多次尝试同时写入同一个映射。这导致了一种竞争情况，多个goroutines试图同时访问同一个变量<code class="fe mv mw mx my b">quotesMap</code>。</p><p id="6047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个安全的操作，随着代码的发展，可能会导致更多的问题。为了解决这个问题，我们将使用一个<code class="fe mv mw mx my b">sync.Map</code>，它允许我们将写操作同步到我们创建的映射。</p><p id="c823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如<a class="ae ky" href="https://pkg.go.dev/sync#Map" rel="noopener ugc nofollow" target="_blank">文档</a>中所述:</p><blockquote class="nl nm nn"><p id="7792" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated">" Map类似于Go map[interface{}]interface{}，但对于多个goroutines的并发使用是安全的，无需额外的锁定或协调。加载、存储和删除在分摊的常数时间内运行。</p></blockquote><p id="3336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新我们的函数来使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ba64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，用<code class="fe mv mw mx my b">go run -race .</code>再次运行我们的程序，我们看不到任何错误。</p><p id="1277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>为了清楚起见，我把函数中的<code class="fe mv mw mx my b">fmt.Printf</code>语句注释掉了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/7fec4d343320223a10fc6979ecdd5333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOwazZm0UFFf-vz8lTposQ.png"/></div></div></figure><h1 id="95a2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">完整的代码</h1><p id="3ec9" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">这是我们迄今为止编写的所有三个主要函数的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="8010" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="0d4c" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">是的，在Go程序中利用并发性就是这么简单！而且结果不言自明，尤其是当我们在处理大量的异步操作比如网络调用的时候。</p><p id="7827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑使用Go惊人、简单、高效的Goroutines来实现你的目标。同时，要注意比赛条件。使用Go内置的比赛检测工具来检查你的代码。</p><p id="d778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你准备开始用Go创建自己的API，<a class="lw lx ep" href="https://medium.com/u/6ae6d826295c?source=post_page-----d59e0fe023d1--------------------------------" rel="noopener" target="_blank">伊恩·邓肯</a>有一个很棒的教程<a class="ae ky" href="https://medium.com/the-andela-way/build-a-restful-json-api-with-golang-85a83420c9da" rel="noopener">在这里</a>你可以在那里构建一个RESTful JSON API。</p><p id="3c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那都是乡亲；编码快乐！</p></div></div>    
</body>
</html>