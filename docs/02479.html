<html>
<head>
<title>SwiftUI Navigation Links and the Common Pitfalls Faced</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI导航链接和面临的常见陷阱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-navigation-links-and-the-common-pitfalls-faced-505cbfd8029b?source=collection_archive---------2-----------------------#2019-12-03">https://betterprogramming.pub/swiftui-navigation-links-and-the-common-pitfalls-faced-505cbfd8029b?source=collection_archive---------2-----------------------#2019-12-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f4aa" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">目前，这不是懒惰，这可能是危险的</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8ab51a8e8e461427fee17fefa5a7ca93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PvEyvfL5p0aLz9Dr"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">劳拉·威克姆在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6bfe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每个应用程序都需要导航，当然，除非你做了一个杀手级的应用程序，在单一视图下运行良好。</p><p id="d03e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">NavigationView</code>是负责浏览不同视图的主要角色之一(另一个是<code class="fe lw lx ly lz b">TabView</code>)。</p><p id="5507" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>里的<code class="fe lw lx ly lz b">NavigationView</code>类似于<a class="ae kz" href="https://developer.apple.com/documentation/uikit" rel="noopener ugc nofollow" target="_blank"> UIKit </a>里的<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/uikit/uinavigationcontroller" rel="noopener ugc nofollow" target="_blank">UINavigationController</a></code>，而<code class="fe lw lx ly lz b">NavigationLinks</code>就像segues(其实比那个好多了)。</p><p id="581c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A <code class="fe lw lx ly lz b">NavigationLink</code>负责将用户带到<code class="fe lw lx ly lz b">destination</code>中指定的视图，如下所示:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="3cf1" class="me mf iu lz b gz mg mh l mi mj">NavigationLink(destination: Text("New Screen")) {</span><span id="a14d" class="me mf iu lz b gz mk mh l mi mj">Text("Press me")</span><span id="dc55" class="me mf iu lz b gz mk mh l mi mj">}</span></pre><p id="0727" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">NavigationLink</code>的主体是视图，当按下时，将用户带到目的地视图。</p><p id="d485" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了让一个<code class="fe lw lx ly lz b">NavigationLink</code>工作，它需要成为<code class="fe lw lx ly lz b">NavigationView</code>的一部分，尽管不是显式的。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="6017" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">我们的目标</h1><ul class=""><li id="710c" class="nj nk iu lc b ld nl lg nm lj nn ln no lr np lv nq nr ns nt bi translated">理解导航工作的不同方式。</li><li id="4822" class="nj nk iu lc b ld nu lg nv lj nw ln nx lr ny lv nq nr ns nt bi translated">处理<code class="fe lw lx ly lz b">NavigationLink</code>它屏蔽了里面的视图。</li><li id="3f77" class="nj nk iu lc b ld nu lg nv lj nw ln nx lr ny lv nq nr ns nt bi translated">解决<code class="fe lw lx ly lz b">NavigationLink</code>无法缓慢加载的目的地。</li></ul></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="567d" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">一点历史</h1><p id="1f5b" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">自从SwiftUI发布以来，导航链接已经经历了很多改变和废弃。</p><p id="b14b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">像<code class="fe lw lx ly lz b">DynamicNavigationDestinationLink</code>、<code class="fe lw lx ly lz b">NavigationDestinationLink</code>和<code class="fe lw lx ly lz b">NavigationButton</code>这样的东西已经过时，它们的功能现在包含在<code class="fe lw lx ly lz b">NavigationLink</code>中(在撰写本文时)。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="7f0a" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">以编程方式导航链接</h1><p id="162d" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">通常，需要基于某些异步事件或条件来触发导航链接。对于这种情况，我们可以将导航链接设置为以编程方式触发，如下所示:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="2745" class="me mf iu lz b gz mg mh l mi mj">NavigationView{<br/>            <br/>            VStack{<br/>                <br/>                NavigationLink(destination: Text("New Screen"),     isActive: self.$isActive) {<br/>                    Text("")<br/>                }<br/>                <br/>                Button("Press programmatically"){<br/>                    self.isActive = true<br/>                }<br/>                <br/>            }<br/>}</span></pre><p id="e3d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，<code class="fe lw lx ly lz b">NavigationLink</code>是用<code class="fe lw lx ly lz b">isActive</code>定义的，最初设置为<code class="fe lw lx ly lz b">false</code>。</p><p id="4ccd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦按钮被按下，state属性被设置为<code class="fe lw lx ly lz b">true</code>，导致SwiftUI视图的<code class="fe lw lx ly lz b">body</code>再次被渲染，从而触发现在处于活动状态的<code class="fe lw lx ly lz b">NavigationLink</code>。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="5c34" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">路由导航带标签的链接</h1><p id="7224" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">在有多个导航链接的情况下，用上述方法路由到导航链接将需要太多的状态变量。</p><p id="df73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">幸运的是，<code class="fe lw lx ly lz b">NavigationLink</code>通过使用如下所示的标签提供了另一种实现:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="82a5" class="me mf iu lz b gz mg mh l mi mj">@State var selection : Int? = nil<br/>    <br/>    var body: some View {<br/>        NavigationView{<br/>            <br/>            VStack{<br/>                <br/>                NavigationLink(destination: Text("New Screen"), tag: 1, selection: self.$selection) {<br/>                    Text("")<br/>                }<br/>                <br/>                NavigationLink(destination: Text("New Screen 2"), tag: 2, selection: self.$selection) {<br/>                    Text("")<br/>                }<br/>                <br/>                Button("Button 1"){<br/>                    self.selection = 1<br/>                }<br/>                <br/>                Button("Button 2"){<br/>                    self.selection = 2<br/>                }<br/>                <br/>            }<br/>        }<br/>        <br/>    }</span></pre></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="94c5" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">导航列表链接</h1><p id="5d4e" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">当SwiftUI列表中嵌入一个<code class="fe lw lx ly lz b">NavigationLink</code>时，箭头附件会自动放置在行项目中，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/d95579f374f9688f7564c2c4e68c2ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hr6u34q17qkMX4YIv3TbVA.png"/></div></div></figure><p id="007c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">NavigationLinks</code>尽管看起来很轻松，但如果处理不当，很容易失控。</p><p id="0ee7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们已经讨论了设置<code class="fe lw lx ly lz b">NavigationLinks</code>的不同方式，那么是时候解决在将该组件集成到SwiftUI应用程序中时将面临的常见陷阱了。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="1469" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">陷阱1。NavigationLink在ScrollView下屏蔽视图</h1><p id="2b52" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">让我们看看下面的例子，它试图在一个<code class="fe lw lx ly lz b">ScrollView</code>中显示一个图像，每个图像都嵌入在<code class="fe lw lx ly lz b">NavigationLink</code>中:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/68da7856c8c973d4db0ffe024f0a7a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P35ndGsfjhOOveg3aIm-bw.png"/></div></div></figure><p id="696f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">图像根本不可见。相反，我们看到视图被强调色(本例中为系统蓝)覆盖。</p><p id="c8c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要移除此覆盖，只需将<code class="fe lw lx ly lz b">NavigationLink</code>上的<code class="fe lw lx ly lz b">buttonStyle</code>属性设置为plain，如下所示:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="42b6" class="me mf iu lz b gz mg mh l mi mj">NavigationLink(destination: Text("Detail Screen")){</span><span id="9f9c" class="me mf iu lz b gz mk mh l mi mj">Image("car")<br/>.background(Color.red)</span><span id="7957" class="me mf iu lz b gz mk mh l mi mj">}<strong class="lz iv">.buttonStyle(PlainButtonStyle())</strong></span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/d476524b4e58d0479beabd49dec814cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*X5Jy982g9-7DXNVTCWmoXg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将NavigationLink设置为普通样式后</p></figure><p id="def8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在另一个场景中，我们在NavigationView中使用PickerView而不是Lists，将<code class="fe lw lx ly lz b">buttonStyle</code>设置为plain会导致图像被屏蔽，如<a class="ae kz" href="https://medium.com/better-programming/how-to-change-your-apps-icon-in-swiftui-1f2ff3c44344" rel="noopener">这一部分</a>所示。</p><p id="5e9c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，在这些情况下，将<code class="fe lw lx ly lz b">Image</code>渲染模式设置为<code class="fe lw lx ly lz b">original</code>很重要。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="71bb" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">陷阱2。NavigationLink目的地不懒惰</h1><p id="b27a" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><em class="of">更新:截至Xcode 11.4.1，iOS 13.4.1，苹果已经修复了这个问题。导航链接目的地视图现在是延迟加载的。出于历史目的，请随意阅读这一部分。</em></p><p id="b055" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着即使用户没有导航到目标视图，也会立即加载该视图。要对此进行交叉检查，只需在目标视图的<code class="fe lw lx ly lz b">onAppear</code>中添加一条打印语句。</p><p id="f3d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不懒惰的目标视图会影响具有视图列表的应用程序的性能。当列表中有数百行时，每一行都有一个获取远程数据的目标视图，应用程序的性能肯定会受到影响。</p><p id="ea7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">谢天谢地，有一个解决办法，正如<a class="ae kz" href="https://twitter.com/chriseidhof/status/1144242544680849410?lang=en" rel="noopener ugc nofollow" target="_blank">的推文</a>所展示的。通过将目的地视图包装在我们自己的自定义视图中，我们可以延迟加载<code class="fe lw lx ly lz b">NavigationLink</code>的<code class="fe lw lx ly lz b">destination</code>，如下所示:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="23d4" class="me mf iu lz b gz mg mh l mi mj">struct LazyView&lt;Content: View&gt;: View {<br/>    let build: () -&gt; Content<br/>    init(_ build: <a class="ae kz" href="http://twitter.com/autoclosure" rel="noopener ugc nofollow" target="_blank">@autoclosure</a> <a class="ae kz" href="http://twitter.com/escaping" rel="noopener ugc nofollow" target="_blank">@escaping</a> () -&gt; Content) {<br/>        self.build = build<br/>    }<br/>    var body: Content {<br/>        build()<br/>    }<br/>}</span></pre><p id="7701" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们将目的地封装在上面的视图中:</p><pre class="kk kl km kn gu ma lz mb mc aw md bi"><span id="db3f" class="me mf iu lz b gz mg mh l mi mj">NavigationLink(destination: <strong class="lz iv">LazyView</strong>(Text("Detail Screen"))){</span><span id="7400" class="me mf iu lz b gz mk mh l mi mj">Image("car")<br/>.background(Color.red)</span><span id="06ae" class="me mf iu lz b gz mk mh l mi mj">}.buttonStyle(PlainButtonStyle())</span></pre><p id="ebb5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这无疑提高了应用程序的性能。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h1 id="1373" class="ms mf iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结论</h1><p id="12d3" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">我们探索了在SwiftUI中设置<code class="fe lw lx ly lz b">NavigationLink</code>的不同方式，并解决了两个常见的陷阱。可以认为<code class="fe lw lx ly lz b">NavigationLink</code>目的地默认不偷懒(写的时候)。</p><p id="2f03" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">也许，从设计上来说，苹果不希望SwiftUI中的视图太重，因为重新加载视图应该是一种廉价的操作。</p><p id="001f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一个到此为止。我希望你喜欢阅读。</p></div></div>    
</body>
</html>