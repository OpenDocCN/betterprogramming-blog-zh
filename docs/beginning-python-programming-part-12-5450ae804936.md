# Python 编程入门—第 12 部分

> 原文：<https://betterprogramming.pub/beginning-python-programming-part-12-5450ae804936>

## 迭代器和生成器介绍

![](img/8120974e7abe2a71f6452434add85f72.png)

照片由[蒂莫西·戴克斯](https://unsplash.com/@timothycdykes?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在上一篇文章中，我们讨论了包和虚拟环境。

[](https://medium.com/better-programming/beginning-python-programming-part-11-1dc915b4f0fd) [## Python 编程入门—第 11 部分

### 使用模块和虚拟环境

medium.com](https://medium.com/better-programming/beginning-python-programming-part-11-1dc915b4f0fd) 

今天，我们将跳回来介绍一些我们还没有介绍的内置类方法。

在开始之前，我们应该了解一些基本的算法。这些都是非常基本的，但为我们开始提供了一个很好的基线。

让我们从我们之前讨论过的 *while 循环*开始:

我承认有更好的方法可以做到这一点，但是这为我们提供了一个简单的例子来为本文的其余部分做准备。

*带有 while 循环的正向循环*对我们来说并不陌生，但是，我们还没有介绍过*反向循环*。虽然这对你们中的一些人来说可能是微不足道的，但我不会假设我的所有读者都已经理解了遍历列表是如何工作的。

在一个反向循环中，我们首先需要获得列表的长度，并将我们的`index`变量设置为 length - 1。我们这样做是因为列表是从 0 开始的，这意味着最后一个可访问的索引将比列表中的项目总数少 1。

与我们在正向循环中比较`index`的值和列表的长度不同，我们需要确保`index`的值在循环中不小于 0。

我们可以执行列表中需要的工作，然后从`index`中减去 1，得到列表中的前一个条目。一旦`index`小于 0，while 循环就退出。

最后，我创建了一个返回给定列表中最后一项的函数。不管我们给它什么列表，它总是返回最后一项。我添加这一点是因为我们需要熟悉这个概念才能继续。

# 迭代器

有时我们需要创建包含一系列对象的类，我们可以循环遍历这些对象，同时对循环遍历的数据执行一些持续的操作。这些对象的范围可以从一系列数字到一系列类。迭代器是提供这种功能的类。

您需要熟悉两个类方法:

*   `__iter__(self)`—返回一个迭代器对象
*   `__next__(self)` —用于返回序列中的下一项

理解`__iter__`和`__init__`的区别很重要。

`__init__`用于在向类提供数据的同时创建类的实例；这是我们将数据赋给迭代器的地方。

当你想用一个序列(list，ordered_dict 等)创建一个类的实例时，使用`__iter__`。)来播种迭代器将循环遍历的数据。

`__iter__`用一个`__next__`方法返回一个对象，如果你在类里面有一个自定义的`__next__`方法，你只需要从`__iter__`方法返回`return self`。

举例来说:

这里我们有一个带有`__init__`、`__iter__`和`__next__`方法的`Doubled`类。

`__init__`在初始化类时要求参数`data`。在我们的例子中，我们设计了这个类来对一个数字列表进行双精度处理。为此，我们需要确保向类传递一个整数或浮点值的列表。

然后`__init__`方法获取数据的长度，这样我们就知道何时需要停止遍历传入的列表。它将数据保存到名为`data`的类属性中，并将当前索引位置设置为 0。我们设置了当前索引，所以当我们创建一个新的迭代器时，我们总是从 0 开始。

因为我们在这个类中定义了自己的`__next__`方法，所以我们只需要在`__iter__`方法内部定义`return self`。

`__next__`包含我们用来返回我们传递的列表中下一个值的逻辑。如果我们要传入一个字典，它将返回字典中的值，尽管我们需要指定如何返回下一个键的值。

在我们的`__next__`方法中，我们首先检查当前的索引位置不等于数据的长度。如果是，我们需要抛出`StopIteration`异常。这与`IndexError`不同，当我们到达列表的末尾时，我们会收到这个迭代器，因为我们可能对不同的数据类型使用这个迭代器。

`StopIteration`具体到我们收到了什么错误，如果我们需要再次迭代序列，那么我们要么需要创建另一个迭代器对象，要么想一个不同的方法来迭代我们的数据。

接下来，我们执行这个迭代器的逻辑。因为我们将列表中的每一项都加倍，所以我们将当前索引的值乘以 2 保存到一个结果变量中。我们这样做是因为我们需要为下一次运行准备索引，这将在下一行中进行。最后，如果一切顺利，我们返回结果。

迭代器的存在是为了使我们的工作更容易，但也是为了确保我们逻辑的一致性。然而，它们不是循环代码的唯一方式。

![](img/65e27396376794c14c0f470f4f6bcfb2.png)

Jason Blackeye 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 发电机

生成器类似于迭代器，除了它们是像迭代器一样工作的函数。生成器的巧妙之处在于它允许你的函数暂停，直到被再次调用。从某种意义上说，他们有自己的`__next__`和`__iter__`方法。与函数不同，它们使用关键字`yield`返回数据。让我们看一个简单的例子:

出于错误处理的考虑，我在这里添加了一个 try/except。

首先，我们创建一个名为`increment`的函数，它接受一个参数:`number`。在函数体中，我们有两条`yield`语句；第一个返回传入的数字并加 1，第二个返回该数字加 2。

然后我们需要将增量函数存储在变量`incrementor`中，为上面的增量函数提供初始值。这些都将存储在变量中，并被视为类对象。

从这里我们可以像使用迭代器一样使用它，通过将`incrementor`传递给`next()`函数，我们按顺序接收每个`yield`语句。这意味着我们会看到`5`和`6`被打印到控制台上。如果我们第三次调用`next(incrementor)`，如上所述，我们会收到一个`StopIteration`异常。

让生成器如此有趣的是我们对它们使用无限循环。由于`yield`暂停了函数的执行，我们一次只能收到一个结果。这意味着下面的代码是有效的，不会引起问题。

这里我们有一个新的 incrementor 函数，它接受一个数字。`=0`表示如果没有提供数字，则使用 0 作为默认值。然后我们创建一个局部变量`n`并给它赋值`number`。

接下来，我们有一个无限循环，虽然这样做通常不太好，但在这里是可以接受的，因为每次调用`yield`都会暂停执行。在函数的末尾，我们有了`n = n + 1`，它增加了我们的局部变量`n`。

由于函数在传递`yield`时暂停，所以下次我们将 incrementor 传递给`next()`函数时，它会在包含`n = n + 1`的行上恢复。

生成器也可以用接近列表理解的格式编写。唯一的区别是我们在表达式两边使用圆括号，而不是方括号。

从这里我们可以使用一个简单的 for 循环访问`generator_object`中的每一项，就像我们访问`list_comp_object`中的结果列表一样，或者我们可以使用`next(generator_object)`获得下一个值。

迭代器和生成器的一个显著区别是迭代器预先计算所有的值并把它们存储在内存中，而生成器只把每次运行所需的值存储在内存中。

生成器的运行速度比列表理解要慢，所以除非你面临内存不足的情况，否则你应该使用列表理解。嘿，如果需要的话很容易重构。

生成器可用于递归任务，如搜索硬盘上的文件或在 web 抓取工具中搜索网页。

# 摘要

迭代器和生成器更多的是一个中间话题，但是一旦你使用它们几次，你就开始寻找在任何地方使用它们的方法。了解迭代器和生成器之间的区别对于应用程序的性能至关重要；在“仅仅因为”而包含它们之前，确保你知道它们的区别。

# 下一步是什么？

接下来是 Async，这个主题非常高级，提供了许多同步代码的选项。不仅可以配置计时，还可以同时运行代码。坚持住，直到那时，继续练习！