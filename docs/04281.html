<html>
<head>
<title>Serverless on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上的无服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/serverless-on-kubernetes-354051a1942e?source=collection_archive---------15-----------------------#2020-04-02">https://betterprogramming.pub/serverless-on-kubernetes-354051a1942e?source=collection_archive---------15-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7096" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能认为这两件事不相配。让我解释一下</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/51649d82547edba0c817e590286633ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p984RQ5Nshx5dquRtBK1jQ.png"/></div></div></figure><p id="1597" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看完这个标题，你一定在思考如何把两个不同的东西放在一起，它们看起来根本不像serverless和Kubernetes那样适合放在一起。</p><p id="aa67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们澄清一下。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4d78" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我们所说的无服务器是什么意思？</h1><p id="669e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在高层次上，无服务器只是一种将服务器完全抽象化的部署方法。</p><p id="2b72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">开发人员只想编写他们的应用程序代码，按一个按钮，让他们的应用程序得到服务，而不需要规划部署、设置自动扩展或任何其他复杂的基础架构任务。</p><p id="684d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于某些用例来说，普通的老Kubernetes可能对开发人员更友好。随着无服务器定义的成熟，出现了两种不同的模式:</p><h2 id="3189" class="mu ly it bd lz mv mw dn md mx my dp mh ld mz na mj lh nb nc ml ll nd ne mn nf bi translated"><strong class="ak">容器即服务</strong></h2><p id="5950" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">在这里，您将应用程序作为容器进行部署，并期望平台为您完成所有其他工作。您可以在Kubernetes中运行容器，但是您仍然需要配置、部署、更新和自动伸缩一些活动部件。</p><p id="e079" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">容器即服务平台只是从开发人员那里接受一个容器，并为他们做其他的事情。这个领域流行的云供应商有<a class="ae ng" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">谷歌云运行</a>和<a class="ae ng" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> AWS Fargate </a>。</p><h2 id="7cc0" class="mu ly it bd lz mv mw dn md mx my dp mh ld mz na mj lh nb nc ml ll nd ne mn nf bi translated"><strong class="ak">作为服务发挥作用</strong></h2><p id="1d70" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">不是部署整个容器，而是部署一个函数，实际上是只能包含一个方法的代码片段，然后通过将多个函数组合在一起来构建服务。</p><p id="9553" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个领域流行的云厂商有<a class="ae ng" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">谷歌云功能</a>和<a class="ae ng" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>。</p><p id="e209" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，无服务器是一种有趣的做事方式，但是…</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4135" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">这和Kubernetes有什么关系？</h1><p id="0359" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">作为一个运行工作负载的运营团队，您应该将Kubernetes视为一个运行所有基础设施的分布式平台，而不管它是如何构建或需要部署的。</p><p id="7643" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">新项目可能会采用无服务器，并希望在无服务器功能上部署整个堆栈。然而，仍然存在这种方法不合适的用例，因为软件限制不允许这样做。</p><p id="85ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，您可能必须为许多不同的团队部署软件，每个团队都有自己的需求。您的大部分工作负载可能都基于Kubernetes的本地容器部署。</p><p id="986c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果开发人员希望偶尔使用无服务器功能来补充这种工作负载，Kubernetes能够提供支持无服务器部署的服务，因此您仍然可以运行一个更广泛的分布式系统，而不必在许多不同的系统之间分散精力。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="8e3a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">Kubernetes是如何做到这一点的？</h1><h2 id="fc93" class="mu ly it bd lz mv mw dn md mx my dp mh ld mz na mj lh nb nc ml ll nd ne mn nf bi translated">对于无服务器容器，有一个名为<strong class="ak">的T4项目</strong></h2><p id="2944" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这为容器提供了“点击部署”的无服务器部署。它通过向Kubernetes添加新的定制资源来实现无服务器容器部署。</p><p id="2db8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，从开发人员的角度来看，您只需构建您的容器并将它们部署到<a class="ae ng" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank"> Knative </a>。Knative负责联网、修订跟踪、自动缩放，这些将随着需求而增加，并在需要时缩放回零。</p><h2 id="3874" class="mu ly it bd lz mv mw dn md mx my dp mh ld mz na mj lh nb nc ml ll nd ne mn nf bi translated">您可以使用云运行来玩Knative</h2><p id="2dc9" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这是一个托管GCP产品，它实施与Knative相同的服务，而不需要GKE集群。</p><p id="0cba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，你可以通过安装Knative来扩展你自己的GKE集群，或者让Google在构建你的集群时为你添加在GKE上运行的云，这是为了容器即服务。那么，函数呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b8de5adcaf5a8a3ab7891f8d2f542afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*defcoqEt3RZLR306Z68Txg.png"/></div></figure><h2 id="9bb7" class="mu ly it bd lz mv mw dn md mx my dp mh ld mz na mj lh nb nc ml ll nd ne mn nf bi translated"><strong class="ak">在集群上安装kna tive(GKE)</strong></h2><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="59a3" class="mu ly it nj b gy nn no l np nq">gcloud beta container clusters create $CLUSTER_NAME \<br/>  --addons<strong class="nj iu">=</strong>HorizontalPodAutoscaling,HttpLoadBalancing,<strong class="nj iu">Istio</strong> \<br/>  --machine-type<strong class="nj iu">=</strong>n1-standard-4 \<br/>  --cluster-version<strong class="nj iu">=</strong>latest --zone<strong class="nj iu">=</strong>$CLUSTER_ZONE \<br/>  --enable-stackdriver-kubernetes --enable-ip-alias \<br/>  --enable-autoscaling --min-nodes<strong class="nj iu">=1</strong> --max-nodes<strong class="nj iu">=10</strong> \<br/>  --enable-autorepair \<br/>  --scopes cloud-platform</span></pre><p id="6dd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于在其他集群中安装Knative，请参考<a class="ae ng" href="https://knative.dev/docs/install/any-kubernetes-cluster/" rel="noopener ugc nofollow" target="_blank">Knative文档</a>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a8a6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">使用Knative部署应用</strong></h1><p id="2ee6" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">您可以简单地使用一个<code class="fe nr ns nt nj b">.yaml</code>文件来部署您的容器化应用程序，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5aed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用以下命令在您的GKE集群中运行这个<code class="fe nr ns nt nj b">.yaml</code>文件:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="dcb0" class="mu ly it nj b gy nn no l np nq">kubectl apply -f filename.yaml</span></pre><p id="b21c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们第一次使用Knative部署应用程序时，需要检索在您的集群前端配置的IP地址。为此，我们可以:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="112d" class="mu ly it nj b gy nn no l np nq">export IP_ADDERSS=$(kubectl get svc istio-ingressgateway --namescpace istio-system --output 'jsonpath={.status.loadbalancer.ingress[0].ip}')</span></pre><p id="b21a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，要获得输出域，您需要:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="45e2" class="mu ly it nj b gy nn no l np nq">kubectl get route helloworld --output=custom-coloum=Name:.metadata.name,DOMAIN:.status.domain</span></pre><p id="efe8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个命令之后，我们在我们的应用程序名称旁边得到一个域列。姑且称之为<code class="fe nr ns nt nj b">[DomainName]</code>。复制这个域并粘贴到下一个命令中，以查看终端中的输出。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="01f3" class="mu ly it nj b gy nn no l np nq">curl -H "Host: [DomainName]" http://${IP_ADDERSS}</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="aa14" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">使用OpenFaaS的Kubernetes上的无服务器功能</strong></h1><p id="083f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">如果您曾经使用过云函数或AWS Lambda，那么您可能非常熟悉无服务器函数；这些是作为服务或Faas平台的功能。</p><p id="6079" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过安装一个名为<a class="ae ng" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS </a>的开源项目，您可以在Kubernetes中使用这个功能。<strong class="kw iu"> </strong>也有其他选择，如<a class="ae ng" href="https://kubeless.io/" rel="noopener ugc nofollow" target="_blank"/>和<a class="ae ng" href="https://fission.io/" rel="noopener ugc nofollow" target="_blank">裂变</a>，但我们现在将坚持使用OpenFaaS。</p><p id="e90e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">部署在OpenFaaS中的功能仍然是容器，但它们被设计为尽可能最小，并且不像您作为自己的服务部署的容器，它们不需要包含web服务组件。</p><p id="15ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">HTTP请求通过OpenFaaS的专用组件进行抽象，以尽可能保持容器本身的流线型。</p><p id="35f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，这样来看，OpenFaaS仍然没有Google Cloud Functions这样的专用平台轻量级，但是可定制性要好得多。它允许您在自己的GKE集群中运行无服务器功能的部署方法。</p><p id="4501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有关OpenFaaS安装指南，请参考<a class="ae ng" href="https://docs.openfaas.com/deployment/kubernetes/" rel="noopener ugc nofollow" target="_blank">他们的网站</a>。</p><p id="2024" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用OpenFaaS部署一个功能，只需指向GitHub中的一个定义文件，使用:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c0ee" class="mu ly it nj b gy nn no l np nq">faas-cli deploy -f https://raw.githubusercontents.com/openfaas/faas/master/stack.yaml</span></pre><p id="eff2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将安装一个方便的web控制台来部署您想要的功能。</p><p id="6e72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将堆栈分解成一个组件服务，并采用无服务器组件方式，OpenFaaS将为您提供一个全功能的无服务器平台，同时仍然运行在您自己的Kubernetes集群中。</p></div></div>    
</body>
</html>