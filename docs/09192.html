<html>
<head>
<title>7 Tips To Effectively Use Context for State Management in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中有效使用上下文进行状态管理的7个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-tips-to-effectively-use-context-for-state-management-in-react-125f5ad904e6?source=collection_archive---------5-----------------------#2021-07-26">https://betterprogramming.pub/7-tips-to-effectively-use-context-for-state-management-in-react-125f5ad904e6?source=collection_archive---------5-----------------------#2021-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="44f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模式、文件提示、团队管理等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d5a84fe04c95678aafbfa078b9e4fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BodLciNtlnEmiI5Q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@morganhousel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摩根·豪斯尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="0ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索一些技巧，帮助您在React应用程序中有效地使用<a class="ae ky" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e599" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动机</h1><p id="fb54" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我的目标是提供一些关于在企业环境中有效使用React的上下文API而不需要依赖外部库的技巧。</p><p id="d927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态管理是React世界中最有争议和固执己见的话题之一，所以在支持成千上万个库中的一个之前，我建议探索React必须提供的工具。如果这还不够，去找外部的。但是，如果您遵循固定的模式，大多数情况下，React本身就是您所需要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7852" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初步资源</h1><p id="982f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文假设对React生态系统中的上下文<strong class="lb iu"> <em class="mz"> </em> </strong>有一个基本的理解。如果你不熟悉，我邀请你浏览一下<a class="ae ky" href="https://reactjs.org/docs/context.html#gatsby-focus-wrapper" rel="noopener ugc nofollow" target="_blank"> React的文档</a>，然后再回来。</p><p id="1c41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你至少读过状态缩减器模式和<code class="fe na nb nc nd b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>的话，那就太好了。</p><p id="2fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完了，我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d27d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.考虑是否需要在应用程序中引入上下文</h1><p id="f048" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在React应用程序中引入上下文可能会增加复杂性，并使应用程序更频繁地呈现，所以首先，考虑更简单的解决方案。</p><h2 id="61f9" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated">如果您的目标是在多个组件之间共享状态，请考虑提升和共存状态</h2><p id="cc2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster" rel="noopener ugc nofollow" target="_blank">状态托管</a>是保持应用程序可维护性的伟大策略。</p><p id="c94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使不考虑上下文，React本身就是一个状态管理工具，所以如果您正确地将状态放在一起，那么<a class="ae ky" href="https://reactjs.org/docs/glossary.html#state" rel="noopener ugc nofollow" target="_blank"> <em class="mz">组件状态</em> </a>可能就是您所需要的全部。</p><p id="aa65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确地将状态放在一起，请尝试遵循“将您的<em class="mz">组件状态</em>尽可能放在相关的地方”的原则<strong class="lb iu"> </strong>您可能知道，将您的状态移动到上层组件以在多个子组件之间共享是很自然的。尽量不要走得太远，把它放在离使用状态的地方最近的公共组件中。更重要的是，每次你的应用程序改变时，只要你有机会，就把状态移到组件树的下面。</p><h2 id="6324" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated">如果您的目标是修复支柱钻孔，请考虑组件组成</h2><p id="d80b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://kentcdodds.com/blog/prop-drilling" rel="noopener ugc nofollow" target="_blank">道具钻取</a>，是将数据从父级传递到子级的过程，超过一个级别，使中间的组件传递它们根本不使用的道具:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="02b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个不必要的复杂的组件树，但是请原谅我，我们有三个组件:<code class="fe na nb nc nd b">EmployeePage</code>(父组件，它是一个保存状态的<em class="mz">智能</em>组件)<em class="mz">、</em>、<code class="fe na nb nc nd b">EmployeeNameForm</code>(呈现一个表单来编辑一个雇员的姓名)、<code class="fe na nb nc nd b">EditEmployeeForm</code>(它是位于中间的组件，包装了<code class="fe na nb nc nd b">EmployeeNameForm</code>和具有类似目的的其他潜在组件，它本身没有状态，但是我们假设它是出于呈现目的而需要的)。</p><p id="27d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意<code class="fe na nb nc nd b">EditEmployeeForm</code>是如何通过props从其父节点接收状态并传递给其子节点的，但是它无论如何都不会使用这个状态。这还不算太坏，但是如果我们有更多层次的组件，可能会变得难以维护。</p><p id="0913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在应用程序中引入<em class="mz">上下文</em>最常见的论点之一(或者像<a class="ae ky" href="https://redux.js.org/introduction/core-concepts" rel="noopener ugc nofollow" target="_blank"> Redux </a>这样的外部工具)，但是在此之前，我邀请您尝试应用<a class="ae ky" href="https://www.pluralsight.com/guides/react-component-composition" rel="noopener ugc nofollow" target="_blank">组件组合</a>，这里，相同的组件树，有一个小的重构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意顶层父组件<code class="fe na nb nc nd b">EmployeePage</code>是如何将道具直接传递给它的<em class="mz">孙代</em> <code class="fe na nb nc nd b">EmployeeNameForm</code>，而不是显式地传递给中间的组件<code class="fe na nb nc nd b">EditEmployeeForm</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e66b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.遵循一致的模式</h1><p id="010b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您确实需要在您的应用程序中实现<em class="mz"> Context </em>，那么支持约定胜于配置，与您的团队就要遵循的模式达成一致，可以帮助您避免默认使用第三方工具。</p><p id="d094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢这篇精彩的<a class="ae ky" href="https://kentcdodds.com/blog/how-to-use-react-context-effectively" rel="noopener ugc nofollow" target="_blank">文章</a>中提出的模式，但是有一点小小的改变，那就是避免<code class="fe na nb nc nd b">useReducer</code>，除非你的状态变得足够复杂。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="cd22" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated">这种模式简而言之:</h2><ul class=""><li id="fe71" class="ns nt it lb b lc mu lf mv li nu lm nv lq nw lu nx ny nz oa bi translated">在同一个文件中，我们将创建始终相同的3个元素:一个<em class="mz">上下文</em> <code class="fe na nb nc nd b">(EmployeeContext)</code>、一个<em class="mz">提供者</em> <code class="fe na nb nc nd b">(EmployeeProvider)</code>和一个钩子<code class="fe na nb nc nd b">(useEmployeeContext)</code>。</li><li id="6476" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu"> <em class="mz">上下文</em> </strong> <em class="mz"> </em> <code class="fe na nb nc nd b">(EmployeeContext)</code>永远不会被导出，而只是使用带有默认值的<code class="fe na nb nc nd b">React.createContext</code>来创建，这个默认值将代表我们的初始状态。</li><li id="bb2d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu"> <em class="mz">提供者</em> </strong> <code class="fe na nb nc nd b">(EmployeeProvider)</code>将包装并返回我们的<em class="mz">上下文。提供者</em>将是我们声明我们想要公开的状态以及修改它的函数的地方，在我们的例子中，它将是<code class="fe na nb nc nd b">const [name, setName] = useState&lt;string&gt;('');</code>，它将被用作<a class="ae ky" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> <em class="mz">高阶组件、</em> </a> <em class="mz"> </em>，因此使用<code class="fe na nb nc nd b">name</code>和<code class="fe na nb nc nd b">setName</code>的组件必须被包装在这个<em class="mz">提供者中。</em></li><li id="8228" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">钩子</strong>T10将是组件在<em class="mz">上下文</em>中访问状态的(唯一)方式。这个钩子只能从先前定义的<em class="mz">提供者</em>中包装的组件调用。</li></ul><p id="6256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的状态增加了它的复杂性，您可能想要考虑使用<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"><em class="mz">useReducer</em></a><em class="mz">，</em>的状态缩减器模式，将它应用到我们的示例中，它看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="9441" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated">什么变了？</h2><p id="4bae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本质上，模式保持不变，不同的是我们用简单的<code class="fe na nb nc nd b">useState</code>代替了用来保存名称的<code class="fe na nb nc nd b">useReducer</code>，这将允许我们用一种优雅的方式更新一个更复杂的状态。组件将能够通过由<code class="fe na nb nc nd b">useEmployeeContext</code>钩子导出的<code class="fe na nb nc nd b">dispatch</code>属性通过<em class="mz">分派</em>动作来修改状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="05d3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.和你的团队讨论一下</h1><p id="85b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">变化是，你不是一个人在工作，尤其是如果你在一个企业环境中，所以你的团队需要与你决定遵循的任何模式保持一致。</p><p id="c434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">讨论它，和你的团队开一个会议，会上提出了建议的模式(如果有多个模式的话)，一旦你决定了要遵循哪个模式，确保每个人都理解它。</p><p id="1efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Mob编程会议是在你的团队中分享知识的一个极好的方式，在你的队友的日程表中预定一些时间，并且有一个会议，在这个会议中你将使用你已经决定实现的模式来编码。</p><p id="2017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交换控制键盘的人，在进行mob编程会议时，通常最雄辩的团队成员会控制会议，交换控制键盘的人会让你的队友参与讨论。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eb45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.保持状态接近需要的地方。</h1><p id="d67e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个原则也适用于存储在<em class="mz">上下文</em>中的状态，而不仅仅是简单的组件状态(如技巧#1所述)</p><p id="7e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次你的<em class="mz">上下文</em>由于状态更新而改变时，<em class="mz">提供者</em>下的所有组件都将重新呈现，因此，你可能希望让你的<em class="mz">提供者</em>尽可能靠近消耗其状态的组件。</p><p id="22ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请不要默认将您的<em class="mz">提供者</em>放在您的应用程序的根目录下。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad37" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.保持状态逻辑分离</h1><p id="069b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">并非应用程序中的所有状态都需要在同一个<em class="mz">提供者</em>中，您可以创建多组<em class="mz">上下文</em>和<em class="mz">提供者，</em>保存应用程序状态的不同部分。</p><p id="855a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们想象一下前面步骤中描述的应用程序，一个小的web应用程序，它有一个创建雇员的页面，另外还有一个包含一些“管理”设置的页面。两者可能都需要在<em class="mz">上下文中存储一些状态，但是您可能希望将这两个状态分开，因为一个与另一个无关</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/60f80e324b66cf7e2a8eab4507dad0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YKV2WRNDkhXYeE2z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我建议引入两个独立的<em class="mz">提供者，</em> <code class="fe na nb nc nd b">EmployeeProvider<em class="mz"> </em></code>和<code class="fe na nb nc nd b">AdminProvider</code>。</p><p id="36bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些情况下，如何构建应用程序的路由是划分<em class="mz">上下文</em>和<em class="mz">提供者</em>的逻辑方式的初步建议。</p><p id="a11a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，尽量避免在<code class="fe na nb nc nd b">App</code>组件级别拥有唯一的<em class="mz">提供者</em>的诱惑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0686" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.保持用户界面状态和服务器状态分离</h1><p id="82aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">请允许我介绍一下<em class="mz"> UI状态</em>和<em class="mz">服务器状态</em>之间的区别，对此，Kent C. Dodds有一个奇妙的定义:</p><blockquote class="oh oi oj"><p id="70d0" class="kz la mz lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">"默认情况下，通过useQuery或useInfiniteQuery的查询实例将缓存的数据视为陈旧数据。</em></p><p id="6bdc" class="kz la mz lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">要改变这种行为，您可以使用staleTime选项配置您的全局查询和每个查询。指定一个更长的失效时间意味着查询将不会频繁地重新获取数据</em></p><p id="95af" class="kz la mz lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">在下列情况下，过时的查询会在后台自动重新获取:</em></p><p id="bab9" class="kz la mz lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">查询挂载的新实例</em></p><p id="4a34" class="kz la mz lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">窗口被重新聚焦</em></p><p id="12b3" class="kz la mz lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">网络重新连接。</em></p><p id="5df1" class="kz la mz lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">查询可以选择配置一个重新获取间隔。”</em></p></blockquote><p id="c64d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要将<em class="mz">服务器状态</em>与UI状态混淆。随着应用程序的增长，您的<em class="mz"> UI状态</em>也会增长。</p><p id="4a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">服务器状态</em>和<em class="mz">用户界面状态</em>具有不同的挑战。首先，<em class="mz">服务器状态</em>通常与通过<em class="mz"> HTTP </em>访问的API相关，因此它具有异步特性。<em class="mz">另一方面，UI状态</em>通常同步工作。在许多情况下，混合它们会不必要地增加应用程序的复杂性，所以我鼓励你将这两者分开。</p><p id="b1cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经成功地将<a class="ae ky" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React Query </a> <em class="mz"> </em>用于服务器状态管理，甚至还写了一篇<a class="ae ky" href="https://medium.com/inside-personio/moving-to-react-query-462f8e5811b6" rel="noopener">帖子</a>和<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/7-tips-for-using-react-query-in-large-projects-22ccc49d61c2">另一篇</a>，其中有一些关于如何有效使用它的提示。</p><p id="31ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道我在这篇文章中一直建议避免使用第三方工具，但是在这种情况下，React Quey提供了如此多的功能并消除了如此多的复杂性，所以我愿意破例一次。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d35c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.在考虑避免重新渲染之前，先考虑避免慢速渲染。</h1><p id="3a2d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里没有秘密，引入<em class="mz">上下文</em>进行状态管理很有可能会让你的应用<em class="mz">更频繁地重新呈现</em>。</p><p id="2af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，只有当渲染本身很慢时，重新渲染才是一个问题，所以让您的应用程序快速渲染将消除重新渲染的顾虑。</p><p id="da4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些提示:</p><ul class=""><li id="f7f4" class="ns nt it lb b lc ld lf lg li on lm oo lq op lu nx ny nz oa bi translated">试着找出你的应用程序的瓶颈，例如，在组件中完成的昂贵的计算:那些将在组件每次运行时被执行，所以试着使用像<code class="fe na nb nc nd b"><a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code> <em class="mz">，</em>这样的工具来记忆这些计算，然后测量是否有实际的改进。</li><li id="a943" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">使用React的<code class="fe na nb nc nd b">key</code> prop，这个prop不仅用于删除浏览器控制台中恼人的警告消息，还通过保留组件实例和减少DOM更新来帮助优化应用程序的渲染过程</li><li id="c0e5" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">如前所述，尽量保持更小的状态，这将有助于每次重新渲染更少的组件。</li><li id="4fb4" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">将组件作为道具传递，在特定的情况下，你可以考虑将昂贵的组件提升到一个他们不经常渲染的父组件，然后将它们作为道具传递下去，这篇<a class="ae ky" href="https://kentcdodds.com/blog/optimize-react-re-renders" rel="noopener ugc nofollow" target="_blank">帖子</a>详细解释了如何做。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="adf2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="379c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="mz">上下文</em>可以是一个非常强大的状态管理工具，但它需要一点纪律来一致地使用，与您的团队定义一个共同的工作框架，以便以一种干净和可扩展的方式利用它；我希望这里给出的建议能帮助你实现这个目标。</p></div></div>    
</body>
</html>