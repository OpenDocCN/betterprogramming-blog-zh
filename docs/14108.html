<html>
<head>
<title>How to Use SIGTERM Signals in Unix-based and Cloud-based Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在基于Unix和基于云的系统中使用SIGTERM信号</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graceful-termination-in-k8s-sigterm-and-unix-processes-4ff845a2f1fc?source=collection_archive---------5-----------------------#2022-11-07">https://betterprogramming.pub/graceful-termination-in-k8s-sigterm-and-unix-processes-4ff845a2f1fc?source=collection_archive---------5-----------------------#2022-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="18a9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">K8S中的优美终止</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a98edbef4e64ea996ba1090e3cd8f2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oydJr72u9MT1OhQ7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@growtika?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Growtika开发商营销机构</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="af41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将讨论<code class="fe ls lt lu lv b">UNIX</code>过程信号，尤其是“SIGTERM”信号。我们将通过使用Node、<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>、<a class="ae kv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae kv" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> Kind </a> local cluster的实际例子来介绍如何处理它们。</p><h2 id="cc1f" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">UNIX信号和SIGTERM</h2><p id="f80c" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">基于Unix的操作系统(OS)有多个进程。操作系统使用软件<a class="ae kv" href="https://en.wikipedia.org/wiki/Interrupt" rel="noopener ugc nofollow" target="_blank">中断</a>(又名信号)作为与正在运行的进程通信的方式，这些信号表示某种事件已经发生，并且它们的意图和目的可能不同。</p><p id="b324" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我的机器上可用的信号列表:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="e90c" class="lw lx iq lv b gy my mz l na nb">$ kill -l<br/> 1) SIGHUP  2) SIGINT  3) SIGQUIT  4) SIGILL<br/> 5) SIGTRAP  6) SIGABRT  7) SIGEMT  8) SIGFPE<br/> 9) SIGKILL 10) SIGBUS 11) SIGSEGV 12) SIGSYS<br/>13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGURG<br/>17) SIGSTOP 18) SIGTSTP 19) SIGCONT 20) SIGCHLD<br/>21) SIGTTIN 22) SIGTTOU 23) SIGIO 24) SIGXCPU<br/>25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH<br/>29) SIGINFO 30) SIGUSR1 31) SIGUSR2</span></pre><p id="7393" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几个，但是我们要把重点放在<code class="fe ls lt lu lv b">SIGTERM</code>。</p><p id="17b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b"><strong class="ky ir">S</strong>IGTERM</code>信号是操作系统优雅地终止程序的一种方式。所谓优雅，是指程序在关闭前有时间进行最后的清理。根据应用程序的不同，清理任务会有所不同。有趣的是，Unix进程可以阻塞和忽略<code class="fe ls lt lu lv b">SIGTERM</code>。但是，如果我们想要高质量的流程/服务，我们需要按照它们的意图处理这些信号，否则我们的流程将被迫关闭。</p><h2 id="69bb" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">作为HTTP服务器的Unix进程</h2><p id="585d" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">为了进行演示，我们将使用<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>和<a class="ae kv" href="https://hapi.dev/" rel="noopener ugc nofollow" target="_blank"> hapi </a>创建一个示例HTTP服务器。</p><p id="44af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建<a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>项目，并按照提示操作:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="b760" class="lw lx iq lv b gy my mz l na nb">$ npm init<br/>…</span></pre><p id="20bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装依赖项:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="bdf0" class="lw lx iq lv b gy my mz l na nb">$ npm install <a class="ae kv" href="http://twitter.com/hapi/hapi" rel="noopener ugc nofollow" target="_blank">@hapi/hapi</a> typesript <a class="ae kv" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a> <a class="ae kv" href="http://twitter.com/types/node" rel="noopener ugc nofollow" target="_blank">@types/node</a> <a class="ae kv" href="http://twitter.com/types/hapi__hapi" rel="noopener ugc nofollow" target="_blank">@types/hapi__hapi</a></span></pre><p id="f940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们不会为开发和生产依赖的分离而烦恼。</p><p id="4e3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个本地文件，并将其命名为<code class="fe ls lt lu lv b">index.ts</code>:</p><pre class="kg kh ki kj gt mu lv nc bn nd ne bi"><span id="aef7" class="nf lx iq lv b be ng nh l ni nb">import { Server } from "@hapi/hapi";<br/>function sleep(ms: number, value: string) {<br/> return new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(value), ms));<br/>}<br/>export async function startServer(host: string, port: number): Promise&lt;Server&gt; {<br/> const server = new Server({ port, host });<br/>server.route({<br/> method: "GET",<br/> path: "/work",<br/> handler: async () =&gt; sleep(10 * 1000, `done something for 10 seconds\n`),<br/> });<br/>await server.start();<br/> console.log(`Server running at: ${server.info.uri}, PID: ${process.pid}`);<br/> return server;<br/>}<br/>startServer("0.0.0.0", 3000);</span></pre><p id="ee32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们在0.0.0.0主机和3000端口上启动本地服务器。我们还配置了一个端点GET <code class="fe ls lt lu lv b">/work</code>,它模拟了一些需要时间来计算的东西——在我们的例子中是10秒。在实际场景中，这可能是执行某种数据库查询所需的时间。</p><blockquote class="nj nk nl"><p id="6ca2" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">我喜欢node，它太酷了，你可以用27行代码定义一个服务器，你实际上需要的更少，因为我增加了睡眠功能等等。但是，是的，很棒。</p></blockquote><p id="6480" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们运行我们的服务器:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="816e" class="lw lx iq lv b gy my mz l na nb"><br/>$ ./node_modules/.bin/ts-node ./index.ts<br/>Server running at: <a class="ae kv" href="http://0.0.0.0:3000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000</a>, PID: 16544<br/></span></pre><p id="75f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切都好。我们有一台服务器在运行！</p><p id="6a42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们向端点发送<code class="fe ls lt lu lv b">GET /work</code> HTTP请求。选择你喜欢的网络工具，我将使用<a class="ae kv" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank"> CURL </a>:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="9614" class="lw lx iq lv b gy my mz l na nb"><br/>$ curl <a class="ae kv" href="http://0.0.0.0:3000/work" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/work</a><br/>done something for 10 seconds<br/></span></pre><p id="5949" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止一切顺利。但是，如果服务器突然被终止，或者换句话说，不再存在，那么HTTP请求会发生什么呢？我们在客户端会得到什么样的响应？我们会得到什么吗？在服务器死亡之后，什么将服务于请求？很多问题！让我们试一试:</p><p id="a3ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向服务器发送另一个请求:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="fea8" class="lw lx iq lv b gy my mz l na nb">$ curl <a class="ae kv" href="http://0.0.0.0:3000/work" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/work</a><br/>done something for 10 seconds</span></pre><p id="b7b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这一次，当服务器正在做10秒钟的模拟工作时——让我们<code class="fe ls lt lu lv b">KILL</code>它！</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="ab8a" class="lw lx iq lv b gy my mz l na nb">$ kill -15 19346</span></pre><blockquote class="nj nk nl"><p id="982a" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">注意:我使用的是从index.ts输出中获得的进程Id (PID )!你当地的PID我们肯定会做些别的事情！如果不是，那就是命中注定，一定要给我发邮件。</p></blockquote><p id="59bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有人可能会问，为什么不按下<code class="fe ls lt lu lv b">CTRL+C</code>键来终止服务器的shell进程呢？嗯，那会发出一个<code class="fe ls lt lu lv b">SIGINT</code>信号，但是我们想要<code class="fe ls lt lu lv b">SIGTERM</code>！</p><p id="b007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，那么当服务器关闭时，我们的客户端连接发生了什么？事情就是这样:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="5f2f" class="lw lx iq lv b gy my mz l na nb">$ curl <a class="ae kv" href="http://0.0.0.0:3000/work" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/work</a><br/>curl: (52) Empty reply from server</span></pre><p id="d40a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它得到了一个空的答复，这意味着它没有得到任何信息，什么也没有。让我们在CURL命令中添加<strong class="ky ir"> -v </strong>(代表verbose)标志来查看更多信息。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="743b" class="lw lx iq lv b gy my mz l na nb">$ curl -v <a class="ae kv" href="http://0.0.0.0:3000/work" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/work</a><br/>* Trying 0.0.0.0:3000…<br/>* Connected to 0.0.0.0 (127.0.0.1) port 3000 (#0)<br/>&gt; GET /work HTTP/1.1<br/>&gt; Host: 0.0.0.0:3000<br/>&gt; User-Agent: curl/7.84.0<br/>&gt; Accept: */*<br/>&gt; <br/>* Empty reply from server<br/>* Closing connection 0<br/>curl: (52) Empty reply from server</span></pre><p id="f26f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来服务器突然关闭了连接👀。这可不好。如果这种情况发生在生产中的服务器客户机上，会怎么样呢？如果您在某个云编排工具中运行您的应用程序，容器被关闭可能并不罕见。</p><p id="9553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用的是<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes (K8S) </a>，所以我要谈谈这个。K8S就像是云的操作系统。K8S可能会随意终止正在运行的<a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank"> Pods </a>(又名容器)，毕竟，K8S的全部目的是协调分布式系统。如果其中一个pod请求了太多的资源，或者如果应用程序正在被缩减，容器可能会从K8S收到一个信号，表示该走了。</p><p id="fdad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们有信号的概念来优雅地终止我们的容器。</p><h2 id="f576" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">服务优雅终止</h2><p id="cca1" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在上一节中，我们讨论了我们的进程或容器如何接收不同的信号。</p><p id="5b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当K8S需要终止一个Pod时，会发送<code class="fe ls lt lu lv b">SIGTERM</code>。这样，我们的服务不仅仅是被切断了资源，相反，它将有一些时间来执行终结任务。</p><p id="0687" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在节点服务器中实现这个逻辑:</p><pre class="kg kh ki kj gt mu lv nc bn nd ne bi"><span id="a605" class="nf lx iq lv b be ng nh l ni nb">import { Server } from "@hapi/hapi";<br/>function sleep(ms: number, value: string) {<br/> return new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(value), ms));<br/>}<br/>export async function startServer(host: string, port: number): Promise&lt;Server&gt; {<br/> const server = new Server({ port, host });<br/>server.route({<br/> method: "GET",<br/> path: "/work",<br/> handler: async () =&gt; sleep(10 * 1000, `done something for 10 seconds\n`),<br/> });<br/>process.on("SIGTERM", async function () {<br/> console.log(`Received SIGTERM`);<br/> await server.stop({ timeout: 10 * 1000 });<br/> console.log(`Server stopped.`);<br/> process.exit(0);<br/> });<br/> await server.start();<br/> console.log(`Server running at: ${server.info.uri}, PID: ${process.pid}`);<br/> return server;<br/>}<br/>startServer("0.0.0.0", 3000);</span></pre><p id="5918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们向<code class="fe ls lt lu lv b">SIGTERM</code>事件添加了一个监听器。当这样的事件发生时，我们会停止服务器，但不仅仅是终止它。在<code class="fe ls lt lu lv b">SIGTERM</code>到达的时间和指定的‘超时’参数之间，我们的服务器将拒绝接受任何新的请求，并将终止正在进行的请求。</p><p id="f79a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以检验这种说法！再次启动服务器:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="8f7b" class="lw lx iq lv b gy my mz l na nb">$ ts-node ./index.ts<br/>Server running at: <a class="ae kv" href="http://0.0.0.0:3000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000</a>, PID: 67116</span></pre><p id="9b5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<code class="fe ls lt lu lv b">CURL</code>请求并终止服务器:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="8e8e" class="lw lx iq lv b gy my mz l na nb">$ curl -v <a class="ae kv" href="http://0.0.0.0:3000/work" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/work</a></span></pre><p id="f18e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该看到请求已经完成，并且响应被发送回客户机——不再出现“(52)来自服务器的空回复”错误。</p><p id="1d38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们试图在<code class="fe ls lt lu lv b">SIGTERM</code>和实际关机之间的时间段内访问服务器，我们将得到:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="bf6b" class="lw lx iq lv b gy my mz l na nb">$ curl -v <a class="ae kv" href="http://0.0.0.0:3000/work" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/work</a><br/>* Trying 0.0.0.0:3000…<br/>* connect to 0.0.0.0 port 3000 failed: Connection refused<br/>* Failed to connect to 0.0.0.0 port 3000 after 3 ms: Connection refused<br/>* Closing connection 0<br/>curl: (7) Failed to connect to 0.0.0.0 port 3000 after 3 ms: Connection refused<br/></span></pre><p id="e846" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果根本没有服务器，我们会得到同样的错误！</p><p id="b035" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这就是我们为节点进程的优雅终止所需要做的一切！</p><h2 id="3af3" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">向K8S传送信号</h2><p id="d951" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">正如我们提到的，每当K8S Pod被终止时，它都会被发送一个<code class="fe ls lt lu lv b">SIGTERM</code>信号。</p><p id="db8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与我们对本地进程使用<code class="fe ls lt lu lv b">kill</code>命令的方式类似，我们可以使用<code class="fe ls lt lu lv b">delete</code>命令终止pod:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="0912" class="lw lx iq lv b gy my mz l na nb">$ kubectl delete pod my-pod-qgldf</span></pre><p id="f549" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当K8S出于某种原因决定终止Pod时，<code class="fe ls lt lu lv b">SIGTERM</code>信号将被发送给它，然后发送给Docker容器，最终发送给正在运行的进程。</p><p id="0949" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你不必相信我，试试看。</p><h2 id="0af9" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">K8S示例应用程序</h2><p id="28f2" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们将重用服务器代码，但是将其容器化并部署在本地K8S集群上。</p><p id="ca89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的文档:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="8445" class="lw lx iq lv b gy my mz l na nb">FROM node:19-bullseye<br/>WORKDIR /app<br/>COPY index.ts package.json package-lock.json /app/<br/>RUN npm install<br/>EXPOSE 3000<br/>ENTRYPOINT [“/app/node_modules/.bin/ts-node”, “index.ts”]</span></pre><p id="ed94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建docker容器:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="6a30" class="lw lx iq lv b gy my mz l na nb">$ docker build -t poc -f ./Dockerfile .</span></pre><p id="c8e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们运行它，看看是否能获得<code class="fe ls lt lu lv b">SIGTERM</code>相关日志:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="0243" class="lw lx iq lv b gy my mz l na nb">$ docker run -t poc:latest</span></pre><p id="b62f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取码头工人id:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="d453" class="lw lx iq lv b gy my mz l na nb">$ docker ps<br/>CONTAINER ID IMAGE <br/>86b0a46730ba poc:latest <br/></span></pre><p id="7094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">停下来:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="2ef0" class="lw lx iq lv b gy my mz l na nb">$ docker stop 86b0a46730ba<br/></span></pre><p id="081b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该看到docker run命令被终止，以及我们的docker容器，其输出与我们对流程的输出相同。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="999c" class="lw lx iq lv b gy my mz l na nb">$ docker run -t poc:latest<br/>Server running at: <a class="ae kv" href="http://0.0.0.0:3000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000</a>, PID: 1<br/>Received SIGTERM<br/>Server stopped.</span></pre><p id="ce22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们来做几个k8！</p><p id="dfbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要将容器映像加载到集群中:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="b9ca" class="lw lx iq lv b gy my mz l na nb"><br/><br/>$ kind load docker-image poc:latest — name my-cluster<br/></span></pre><p id="fb9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">K8S部署清单:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="1793" class="lw lx iq lv b gy my mz l na nb">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/> name: poc-namespace<br/> — -<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> name: poc-deployment<br/> namespace: poc-namespace<br/>spec:<br/> selector:<br/> matchLabels:<br/> app: poc-app<br/> template:<br/> metadata:<br/> labels:<br/> app: poc-app<br/> spec:<br/> containers:<br/> — name: poc<br/> image: poc:latest<br/> ports:<br/> — containerPort: 3000</span></pre><p id="70a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">部署到我们的集群:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="4b87" class="lw lx iq lv b gy my mz l na nb">$ kubectl apply -f ./deployment.yaml <br/>namespace/poc-namespace created<br/>deployment.apps/poc-deployment created</span></pre><p id="6a98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您流式传输pod日志:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="af71" class="lw lx iq lv b gy my mz l na nb">$ k logs -f poc-deployment-bf749f576-wfmv9<br/></span></pre><p id="74b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后删除pod:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="b3da" class="lw lx iq lv b gy my mz l na nb">$ kubectl delete pod poc-deployment-bf749f576-wfmv9</span></pre><p id="ef9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该得到相同的结果:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="c5a0" class="lw lx iq lv b gy my mz l na nb">$ k logs -f poc-deployment-bf749f576-wfmv9<br/>Server running at: <a class="ae kv" href="http://0.0.0.0:3000" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000</a>, PID: 1<br/>Received SIGTERM<br/>Server stopped.</span></pre><p id="012c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样结束了！</p><h1 id="24f5" class="nq lx iq bd ly nr ns nt mb nu nv nw me jw nx jx mh jz ny ka mk kc nz kd mn oa bi translated">摘要</h1><p id="fed0" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在本文中，我们介绍了<code class="fe ls lt lu lv b">SIGTERM</code>信号，它们是如何在基于Unix和基于云的系统中使用的，并展示了处理这些信号的实际应用及其潜在的it影响。</p><p id="ba09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">SIGTERM</code>处理对于<a class="ae kv" href="https://en.wikipedia.org/wiki/Scalability#Horizontal_(scale_out)_and_vertical_scaling_(scale_up)" rel="noopener ugc nofollow" target="_blank">可水平扩展的</a>云应用来说至关重要。它允许应用程序按需伸缩，而不会影响客户端的稳定性。</p></div></div>    
</body>
</html>