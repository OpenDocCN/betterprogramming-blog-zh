<html>
<head>
<title>Redis as a Lock! Are You Sure?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">雷迪斯锁定了！你确定吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/redis-as-a-lock-are-you-sure-a870c9f22ad8?source=collection_archive---------9-----------------------#2022-05-02">https://betterprogramming.pub/redis-as-a-lock-are-you-sure-a870c9f22ad8?source=collection_archive---------9-----------------------#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e08" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你说的锁是专属锁还是壁垒？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f44f3d087d36a526d0673be164eb4cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ruuHg6RyBfet0s48"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗洛里安·奥利佛在Unsplash<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><p id="11d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis是一个将数据保存在内存中的存储器，我们知道内存中的任何东西都是不可靠的。此外，<a class="ae kv" href="https://towardsdev.com/data-persistence-in-redis-2780c11d1623" rel="noopener ugc nofollow" target="_blank"> Redis的数据持久性</a>并不像宣称的那么可靠。因此，使用Redis作为锁来实现某种同步是非常危险的。</p><p id="dcf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，本文并不打算只关注Redis的不可靠性，而是进一步分析这些锁的使用是否正确。</p><p id="9095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，我们经常把两个非常不同的概念称为锁。</p><ul class=""><li id="bf53" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">独占锁:用于控制一个关键部分的访问权限，一次只能有一个人在关键部分。一个类似的概念是信号量，它允许临界区中有最大数量的人。</li><li id="0040" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">障碍:用于降低特定动作的频率。</li></ul><p id="6493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这两个概念具有完全不同的目的，并且以完全不同的方式实现。然而，通常，我们没有仔细定义需求并选择正确的方法，从而导致异常。</p><h1 id="a22f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">互锁</h1><p id="b9da" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">排他锁(也称为互斥锁)的目的是控制临界区的并发用户只有一个。</p><p id="305f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然是临界段，就有两个动作，锁定和释放，锁定时进入，释放时离开。这通常用于避免数据库中的竞争情况，例如MySQL无法避免更新丢失，因此使用额外的排他锁作为两个同时更新的同步机制。</p><p id="88ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于以上描述，我们可以编写一个伪代码。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="393e" class="ni mh iq ne b gy nj nk l nl nm">while tryLock(forLongTime):<br/>    sleep(veryShortTime)<br/>    <br/>doSomeThing()</span><span id="ec50" class="ni mh iq ne b gy nn nk l nl nm">releaseLock()</span></pre><p id="9f05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上有几点值得注意。</p><ol class=""><li id="ae40" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr no ly lz ma bi translated"><code class="fe np nq nr ne b">tryLock</code>方法包含两个动作:获取锁并锁定它。如果你能获得锁，你必须立即锁定它，否则锁会被别人拿走，下面的关键部分就会被突破。</li><li id="c279" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr no ly lz ma bi translated">等待时间应该设置得很短，目的是能够尽快继续工作，而不是花费大量时间等待。</li><li id="9f73" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr no ly lz ma bi translated">但是锁定时间要很长，避免事情还没做完锁就消失了，导致临界区失效。</li><li id="55fb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr no ly lz ma bi translated">在完成需要完成的工作后，必须立即释放锁，以便其他人可以立即访问临界区。</li></ol><p id="76d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，排他锁的目的是控制对关键部分的访问。如果两个动作同时发生，那么两个动作都可以正确完成，只是一个接一个。</p><h1 id="b239" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">屏障</h1><p id="c02d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">屏障的目的是减少某个动作的频率。比如你连续调用一个API两次，第二次API回应“请稍后再试”，这就是典型的壁垒。</p><p id="70cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为目的是降低频率，所以阻塞的时间很重要，这取决于特性要求。例如，如果产品规范要求API之间至少间隔5秒，那么锁定时间就是5秒。这通常比独占锁的锁定时间短。</p><p id="3be5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也试着写伪代码。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="fa61" class="ni mh iq ne b gy nj nk l nl nm">if tryLock(featureSpecTime):<br/>    return False</span><span id="39ac" class="ni mh iq ne b gy nn nk l nl nm">return doSomeThing()</span></pre><p id="cb3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和独占锁相比，没有解锁和等待，使用的是同一个<code class="fe np nq nr ne b">tryLock</code>，只是锁的时间是从产品要求来的。</p><p id="ab10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">障碍是降低频率，所以如果两个动作同时发生，那么一个会成功，另一个会失败。</p><h1 id="79a9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Redis怎么样？</h1><p id="02cd" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">好的，我们知道所有这些，那么这对Redis有什么关系呢？是的，绝对的。</p><p id="add2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis是最常用于实现排他锁或屏障的一个，而两边都使用的<code class="fe np nq nr ne b">tryLock</code>是Redis中的一行命令:<code class="fe np nq nr ne b">SET someKey 1 EX someTime NX</code>。根据结果是<code class="fe np nq nr ne b">OK</code>还是<code class="fe np nq nr ne b">nil</code>，可以判断是否已经获得锁。从实现上来说，这很简单。</p><p id="261c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，正如文章开头提到的，Redis数据并不可靠，使用Redis作为排他锁可能会导致临界区失效。</p><p id="6aa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis可以起到很好的屏障作用，因为一次封杀失败最多是多做几次的动作，不影响系统的稳定性，但作为独占锁，必须慎重考虑利弊。</p><p id="78a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我来说，如果想避免MySQL丢失更新，我一直推荐使用MySQL的原生<code class="fe np nq nr ne b">FOR UPDATE</code>，实现起来并不难，也不需要等待，也不会失效。当然，要避免MySQL丢失更新，除了加锁还有几种方法，可以在<a class="ae kv" href="https://medium.com/interviewnoodle/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4" rel="noopener">我之前的文章</a>中找到。</p><h1 id="ff13" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="a645" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">本文解释了我们通常所说的锁实际上有两种不同的含义，尽管它们有相似的外观，但它们实现的目的和细节是完全不同的。</p><p id="ebf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总结一下。</p><ul class=""><li id="e782" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">排他锁:两个同时发生的动作都会成功，但是一个接一个。</li><li id="0b55" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">障碍:两个同时发生的动作，只有一个会成功。</li></ul><p id="0390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当谈到锁时，确保您确切地知道您想要处理哪种上下文，并得到正确的处理。在我的情况下，即使我的系统中有Redis并且我会使用它，我也会设计我的系统，就好像Redis数据不存在一样，这样当不幸的事情发生时，你就会知道你的系统是否会正确处理它。</p></div></div>    
</body>
</html>