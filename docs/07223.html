<html>
<head>
<title>NumPy Illustrated: The Visual Guide to NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy图解:NumPy的视觉指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/numpy-illustrated-the-visual-guide-to-numpy-3b1d4976de1d?source=collection_archive---------0-----------------------#2020-12-21">https://betterprogramming.pub/numpy-illustrated-the-visual-guide-to-numpy-3b1d4976de1d?source=collection_archive---------0-----------------------#2020-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b93" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">温习你的数学或从头开始学习</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90c172392e38d7fed94e7642ed05fd30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbZqTBXZmnQtVZ_llbGJTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="abe6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>是一个基础库，大多数广泛使用的Python数据处理库都是建立在这个基础库之上的(<a class="ae lu" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>、<a class="ae lu" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>)、受(<a class="ae lu" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>)启发，或者可以高效地与(<a class="ae lu" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>、<a class="ae lu" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>等)共享数据。理解NumPy的工作方式也有助于提高您在这些库中的技能。也可以在<a class="ae lu" href="https://stsievert.com/blog/2016/07/01/numpy-gpu" rel="noopener ugc nofollow" target="_blank"> GPU </a>上运行NumPy代码，而不需要或只需要很小的改动。</p><p id="457d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy的核心概念是一个n维数组。它的美妙之处在于，不管数组有多少维，大多数操作看起来都是一样的。但是1D和2D的情况有点特殊。文章由三部分组成:</p><ol class=""><li id="4551" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="#3338" rel="noopener ugc nofollow">向量，1D数组</a></li><li id="b55b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="#35fb" rel="noopener ugc nofollow">矩阵，2D阵列</a></li><li id="bb68" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="#c6af" rel="noopener ugc nofollow"> 3D及以上</a></li></ol><p id="ae4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我以杰伊·阿拉姆马的一篇很棒的文章“NumPy 的视觉介绍”为起点，显著扩展了它的覆盖范围，并修改了两个细微差别。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="54fd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Numpy数组与Python列表</h1><p id="88ea" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">乍一看，NumPy数组类似于Python列表。它们都是容器，可以快速获取和设置项目，但插入和移除元素的速度要慢一些。</p><p id="6cc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy数组节拍列表最简单的例子是算术:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/789a3e5322c235eb157684aba0975fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ND8LvMjQOX19G-Yg0ANPxw.png"/></div></div></figure><p id="f53c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，NumPy数组还有:</p><ul class=""><li id="1388" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt no mb mc md bi translated">更紧凑，尤其是当有多个维度时</li><li id="1eb3" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt no mb mc md bi translated">当操作可以矢量化时，比列表更快</li><li id="15b5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt no mb mc md bi translated">在末尾追加元素时比列表慢</li><li id="42d9" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt no mb mc md bi translated">通常是同构的:只能快速处理一种类型的元素</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/5bc0347590085945f3bb0d6cdc03ab0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-I8hK4WXC8wtpR5tvR0fw.png"/></div></div></figure><p id="3cf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里O(N)表示完成运算所需要的时间与数组的大小成正比(参见<a class="ae lu" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"> Big-O Cheat Sheet </a> site)，O*(1)(所谓“摊销”O(1))表示时间一般不取决于数组的大小(参见Python <a class="ae lu" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank">时间复杂度</a> ⁴ wiki页面)</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3338" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.向量，1D阵列</h1><h2 id="9c0c" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">向量初始化</h2><p id="f522" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">创建NumPy数组的一种方法是转换Python列表。类型将从列表元素类型中自动推导出来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/df612772af55de8500a628725c145bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQRt7v_zDO7DNRLRUlCm5w.png"/></div></div></figure><p id="dbf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一定要输入一个同质的列表，否则你会以<code class="fe od oe of og b">dtype=’object’</code>结束，它消灭了速度，只留下NumPy中包含的语法糖。</p><p id="9916" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的新文章中有更多关于dtypes的内容</p><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/a-comprehensive-guide-to-numpy-data-types-8f62cb57ea83"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">NumPy数据类型综合指南</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">除了int32和float64还有什么？</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><p id="02c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy数组不能像Python列表那样增长:数组末尾没有预留空间来方便快速追加。因此，通常的做法是要么增大一个Python列表，并在准备就绪时将其转换为NumPy数组，要么用<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.zeros.html" rel="noopener ugc nofollow" target="_blank">zeros</a></code>或<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.empty.html" rel="noopener ugc nofollow" target="_blank">empty</a></code>预先分配必要的空间:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/c5a3f295103ceb3019fd5bf424b28771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_CdjlwqtzCj98i2oCr5Tw.png"/></div></div></figure><p id="d2a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常需要创建一个空数组，通过形状和元素类型来匹配现有数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/9f40b66e670a98d6a78d8ee72ca4583a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXny4Z0frysfsVllO84Jyw.png"/></div></div></figure><p id="4287" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，所有创建一个填充有常量值的数组的函数都有一个<code class="fe od oe of og b">_like</code>对应项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/034cb92d559c46a93e3f9b56603bf6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyN_FxUVbkdDyrULhfTIGw.png"/></div></div></figure><p id="1817" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy中有多达两个函数用于单调序列的数组初始化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/e36f82bc22f718de8cb67f701801ccc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NNCWBPDCPfLtNYDc_ul5SA.png"/></div></div></figure><p id="58b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你需要一个类似的浮点数组，像<code class="fe od oe of og b">[0., 1., 2.]</code>，你可以改变<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.arange.html" rel="noopener ugc nofollow" target="_blank">arange</a></code>输出的类型:<code class="fe od oe of og b">arange(3).astype(float)</code>，但是有一个更好的方法。<code class="fe od oe of og b">arange</code>函数是类型敏感的:如果你将int作为参数，它将生成int，如果你将float(例如<code class="fe od oe of og b">arange(3.)</code>)作为参数，它将生成float。</p><p id="2dcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是<code class="fe od oe of og b">arange</code>并不特别擅长处理浮动:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/b853601176f65f70a133d57090f63511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps2PYTthKUdNbzynKjW4oQ.png"/></div></div></figure><p id="3507" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe od oe of og b">0.1</code>对我们来说看起来像一个有限的十进制数，但对计算机来说不是:在二进制中，它是一个无限的分数，必须在某个地方四舍五入，因此是一个错误。这就是为什么将带小数部分的步骤输入到<code class="fe od oe of og b">arange</code>通常是个坏主意:您可能会遇到一个差一位的错误。您可以使间隔的结束落在非整数步数中(解决方案1 ),但这会降低可读性和可维护性。这就是<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html" rel="noopener ugc nofollow" target="_blank">linspace</a></code>可能派上用场的地方。它不受舍入误差的影响，并且总是生成您所要求的元素数量。不过<code class="fe od oe of og b">linspace</code>有一个常见的问题。它计算点，而不是间隔，因此最后一个参数总是比你通常想到的要多一个。所以它是11，而不是上面例子中的10。</p><p id="ede2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于测试目的，通常需要生成随机数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/3f7882da78669b78d1faf25dc81310b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFoQ5Vw4s9mx7RyUi1wYOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旧式随机数生成(已弃用)</p></figure><p id="e64e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一个新的随机数组生成界面。它是:<br/>-更适合多线程，<br/>-更快，<br/>-更可配置(你可以通过选择一个非默认的所谓“位生成器”来获得更高的速度或质量)，<br/>-能够通过两个旧版本未能通过的复杂的综合测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/ff24f9c89e70e646682e2c31fb72f2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6RkkCzD3TTSCjzf6CV7nVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新型随机数生成</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="c75a" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">向量索引</h2><p id="2afb" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">一旦您将数据存储在阵列中，NumPy在提供简单的归还方法方面表现出色:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/c0e871e4d8a9639cd9dfd23b380e2f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xpufyWZWcIbabsOHVlc4g.png"/></div></div></figure><p id="792d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了花哨的索引之外，上面介绍的所有索引方法实际上都是所谓的“视图”:它们不存储数据，也不反映原始数组中的变化(如果它在被索引后发生了变化)。</p><p id="5043" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">包括花式索引在内的所有这些方法都是可变的:它们允许通过赋值来修改原始数组内容，如上所示。这个特性打破了通过切片来复制数组的习惯:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/1db8483fa177e59c298e13a2af47a0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dv9HzG2dSf3QuhjfpSIhqA.png"/></div></div></figure><p id="bcc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，这种赋值不能改变数组的大小，所以像</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/ad5e460a7ea71b37d4e8e1d9b6122b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1ZD8Qi4iGyuzeLcfdYK9w.png"/></div></div></figure><p id="987c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在NumPy中不起作用—使用<code class="fe od oe of og b">np.insert</code>、<code class="fe od oe of og b">np.append</code>等。取而代之(在下面的“2D”一节中描述)。</p><p id="9be1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从NumPy数组获取数据的另一个非常有用的方法是布尔索引，它允许使用各种逻辑运算符:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/4055dc177251f52ef9d8509afaa34594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFGcXav_xxD7TXGiRYMpHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.any.html" rel="noopener ugc nofollow" target="_blank"> any </a>和<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.all.html" rel="noopener ugc nofollow" target="_blank"> all </a>的行为就像它们的python对等体一样，但是不会短路</p></figure><p id="e864" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管小心；类似于<code class="fe od oe of og b">3&lt;=a&lt;=5</code>的Python“三元”比较在这里不起作用。</p><p id="e520" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所述，布尔索引也是可写的。它的两个常见用例是作为专用函数派生出来的:过度重载的<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.where.html" rel="noopener ugc nofollow" target="_blank">where</a></code>函数(参见下面的两种含义)和<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.clip.html" rel="noopener ugc nofollow" target="_blank">clip</a></code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/f67c2316b9f7f1863bf1d1705a8d4f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLUqfXDFbKtGVBl5VwuySQ.png"/></div></div></figure><p id="d1a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，带有一个参数的<code class="fe od oe of og b">np.where</code>返回一个数组元组(在1D的情况下是1元组，在2D的情况下是2元组，等等)，因此您需要编写<code class="fe od oe of og b">np.where(a&gt;5)[0]</code>来获得上面示例中的<code class="fe od oe of og b">np.array([5,6,7])</code>(对于<code class="fe od oe of og b">np.nonzero</code>也是如此)。</p><p id="68ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于单边裁剪，有<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.minimum.html" rel="noopener ugc nofollow" target="_blank">minimum</a></code>和<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.maximum.html" rel="noopener ugc nofollow" target="_blank">maximum</a></code>。所有三个裁剪函数也接受一个数组作为阈值。</p><h2 id="a861" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">向量运算</h2><p id="77ce" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">算术是NumPy speed最出彩的地方之一。向量操作符被转移到c++级别，并允许我们避免缓慢的Python循环的代价。NumPy允许像处理普通数字一样处理整个数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/ba7b1e5d5dc5d65b8e85fb5a48e59c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNfQubSwH_6-GnWHVjn9CQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通常在Python中，a//b表示一个div b(除法的商)，x**n表示xⁿ</p></figure><p id="0472" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与加法或减法时将整型提升为浮点型相同，标量提升(也称为<em class="pk">广播</em>)为数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/b7182fcc82797bfb460ab0f45df6c9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VyadDu7CyuF5-7rKVoFSrw.png"/></div></div></figure><p id="4218" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数<code class="fe od oe of og b">math</code>函数都有可以处理向量的对应函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/a885b0aa26fc86de99421f863fbd32b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pc4t0jilbHSM0sMwtVNGIA.png"/></div></div></figure><p id="837c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标量积有自己的运算符:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/d89b22cca1797b6ad24dc3c5fdfe1793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDUgKZO4bj9_SSRY6ddnfg.png"/></div></div></figure><p id="a816" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">三角学也不需要循环:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/c459286b8c2033cf71ccac1f3fc219b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyHVvsoUdsHA0RedM6kdvQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反函数的命名不同于“math ”: NP。<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.arcsin.html" rel="noopener ugc nofollow" target="_blank"> arcsin </a>但是数学。<a class="ae lu" href="https://docs.python.org/3/library/math.html#math.asin" rel="noopener ugc nofollow" target="_blank">阿辛</a></p></figure><p id="0049" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数组可以整体舍入:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/23f6382daa4c0de7033d7f34b2ec3607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkjXtrFriVBXTQove8vEPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.floor.html" rel="noopener ugc nofollow" target="_blank">floor</a></code>舍入到-∞, <code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.ceil.html" rel="noopener ugc nofollow" target="_blank">ceil</a></code>舍入到+∞，而<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.around.html" rel="noopener ugc nofollow" target="_blank">舍入到</a>附近——舍入到最接近的整数(. 5到偶数)</p></figure><p id="8891" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">名字<code class="fe od oe of og b">np.around</code>只是<code class="fe od oe of og b">np.round</code>的别名，引入它是为了避免在编写<code class="fe od oe of og b">from numpy import *</code>时遮蔽Python <code class="fe od oe of og b">round</code>(相对于更常见的<code class="fe od oe of og b">import numpy as np</code>)。也可以用<code class="fe od oe of og b">a.round()</code>。</p><p id="cc8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">NumPy还能够进行基本的统计:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/05b61ae1adc5a60d92f184b561b45945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAB7WXfvTM7FxD1bJ7augQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这些函数中的每一个都有一个抗nan变量:例如<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.nansum.html" rel="noopener ugc nofollow" target="_blank"> nansum </a>、<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.nanmax.html" rel="noopener ugc nofollow" target="_blank"> nanmax </a>等</p></figure><p id="6436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的公式中可以看出，<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.std.html" rel="noopener ugc nofollow" target="_blank">std</a></code>和<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.var.html" rel="noopener ugc nofollow" target="_blank">var</a></code>都忽略了<a class="ae lu" href="https://en.wikipedia.org/wiki/Bessel%27s_correction" rel="noopener ugc nofollow" target="_blank"> Bessel的修正</a>，在总体均值未知的情况下，从样本中估计std的最典型用例中，给出了一个有偏差的结果。获得偏差较小的估计的标准方法是在分母中加入<code class="fe od oe of og b">n-1</code>，这是通过<code class="fe od oe of og b">ddof=1</code>(“自由度增量”)实现的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/515a69ec053bdf5e06f491c40937fa40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TUC2TP7AG6MTGmNNCx_hg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫<a class="ae lu" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.std.html" rel="noopener ugc nofollow" target="_blank"> std </a>默认使用贝塞尔校正</p></figure><p id="e6c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">贝塞尔校正的效果随着样本量的增加而迅速减弱。此外，这不是一个放之四海而皆准的解决方案，例如对于正态分布<code class="fe od oe of og b">ddof=1.5</code> <a class="ae lu" href="https://en.wikipedia.org/wiki/Unbiased_estimation_of_standard_deviation" rel="noopener ugc nofollow" target="_blank">更好</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/417a2907a68828d8ab22c38a5b5533b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdW0aiVWfUHJmV8nydkeZA.png"/></div></div></figure><p id="0737" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">排序函数的功能比Python中的对应函数要少:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/69096c7dd77573f1e6eddea767acd058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmS5_eCb8onu7MYjjdYpFw.png"/></div></div></figure><p id="1d25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在1D的例子中，<code class="fe od oe of og b">reversed</code>关键字的缺失可以很容易地通过反转结果来弥补。在2D中，这有点棘手(<a class="ae lu" href="https://github.com/numpy/numpy/pull/14989" rel="noopener ugc nofollow" target="_blank">特征请求</a> ⁵).</p><h2 id="f5d1" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">搜索向量中的元素</h2><p id="ef20" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">与Python列表相反，NumPy数组没有<code class="fe od oe of og b">index</code>方法。相应的<a class="ae lu" href="https://github.com/numpy/numpy/issues/2269" rel="noopener ugc nofollow" target="_blank">功能要求</a> ⁶已经挂在那里好一阵子了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/17d7238bfb9124e81c060c9de52e2b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQXR_BLBC91f5WvH4TaFcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" rel="noopener ugc nofollow" target="_blank">索引</a>()定义中的方括号表示j或者I和j都可以省略</p></figure><ul class=""><li id="9f5f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt no mb mc md bi translated">寻找元素的一种方法是<code class="fe od oe of og b">np.where(a==x)[0][0]</code>，它既不优雅也不快速，因为它需要遍历数组的所有元素，即使要寻找的元素在最开始。</li><li id="9469" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt no mb mc md bi translated">更快的方法是通过用<a class="ae lu" href="https://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank">数字</a> ⁷加速<code class="fe od oe of og b">next((i[0] for i, v in np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.ndenumerate.html" rel="noopener ugc nofollow" target="_blank">ndenumerate</a>(a) if v==x), -1)</code>(否则在最坏的情况下会比<code class="fe od oe of og b">where</code>慢)。</li><li id="3e56" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt no mb mc md bi translated">一旦数组被排序，情况会变得更好:<code class="fe od oe of og b">v = np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.searchsorted.html" rel="noopener ugc nofollow" target="_blank">searchsorted</a>(a, x); return v if a[v]==x else -1</code>非常快，复杂度为O(log N ),但是首先排序需要O(N log N)的时间。</li></ul><p id="3ebe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其实用c实现加速搜索不是问题，问题是浮点比较。对于任意数据，这是一项不能开箱即用的任务。</p><h2 id="eae4" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">比较浮动</h2><p id="2779" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">函数<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.isclose.html" rel="noopener ugc nofollow" target="_blank">allclose</a>(a, b)</code>将浮点数组与给定的容差进行比较</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/5887572c0aae5be01b7da829c5cafffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZWByfm3vyHXhNreHGy3hQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有什么灵丹妙药！</p></figure><ul class=""><li id="d88a" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt no mb mc md bi translated"><code class="fe od oe of og b">np.allclose</code>假设所有比较的数字都是典型的1。例如，如果使用纳秒，则需要将默认的<code class="fe od oe of og b">atol</code>参数值除以1e9: <code class="fe od oe of og b">np.allclose(1e-9, 2e-9, atol=1e-17) == False</code>。</li><li id="8122" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt no mb mc md bi translated"><code class="fe od oe of og b">math.<a class="ae lu" href="https://docs.python.org/3/library/math.html#math.isclose" rel="noopener ugc nofollow" target="_blank">isclose</a></code>对要比较的数字不做任何假设，而是依赖用户给出一个合理的<code class="fe od oe of og b">abs_tol</code>值(采用默认的<code class="fe od oe of og b">np.allclose</code> <code class="fe od oe of og b">atol</code>值1e-8对于典型标度为1的数字来说已经足够):<code class="fe od oe of og b">math.isclose(0.1+0.2–0.3, abs_tol=1e-8)==True</code>。</li></ul><p id="d56a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，<code class="fe od oe of og b">np.allclose</code>在绝对和相对公差的公式中有一些小问题，例如，对于某些a，b <code class="fe od oe of og b">allclose(a, b) != allclose(b, a)</code>。这些问题在(标量)函数<code class="fe od oe of og b">math.isclose</code>(稍后介绍)中得到解决。要了解更多，请看一下GitHub上优秀的<a class="ae lu" href="https://floating-point-gui.de/errors/comparison/" rel="noopener ugc nofollow" target="_blank">浮点指南</a> ⁸和相应的NumPy <a class="ae lu" href="https://github.com/numpy/numpy/issues/10161" rel="noopener ugc nofollow" target="_blank"> issue </a> ⁹。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="35fb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.矩阵，2D阵列</h1><p id="da61" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated"><em class="pk">NumPy中曾经有一个专门的</em> <code class="fe od oe of og b">matrix</code> <em class="pk">类，现在已经弃用了，我就把</em>矩阵<em class="pk">和</em> 2D数组<em class="pk">这两个词互换使用。</em></p><p id="8da3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">矩阵初始化语法类似于向量的语法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/60b45489503ee1dede9893a1be1bc581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLMuXA81pDXaw0J0QdKvRQ.png"/></div></div></figure><p id="b7cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里双括号是必要的，因为第二个位置参数是为(可选)<code class="fe od oe of og b">dtype</code>(也接受整数)保留的。</p><p id="d4c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随机矩阵的生成也类似于向量的生成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/910b23a0e0c9e4c3df37ff475135c4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9bawffUMaZeQw1g0DuHrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旧式随机数生成</p></figure><p id="3cce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无处不在的双圆括号找到了它们在新型(参见上面1D部分的细节)数字生成例程的接口上的道路，因此到今天为止，只有在<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.eye.html" rel="noopener ugc nofollow" target="_blank">eye</a></code>中，美观取代了传递形状的严格性和方便性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/b773ab787b6a1d352701a3bc5f32af62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOgsZhCTMnbJWC5u_I3fiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新型随机数生成</p></figure><p id="f9b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">二维索引语法比嵌套列表更方便:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/c5e25921e7ccd9c239f44f9f0d2bdd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brbsl7QFZGWfmvgFHMwt9Q.png"/></div></div></figure><p id="6281" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“view”符号表示在对数组切片时，实际上没有进行任何复制。当阵列被修改时，这些更改也会反映在切片中。</p><h2 id="8501" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">轴参数</h2><p id="06fd" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在许多操作中(如<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.sum.html" rel="noopener ugc nofollow" target="_blank">sum</a></code>)，你需要告诉NumPy你是否想要跨行或列操作。为了有一个适用于任意维数的通用符号，NumPy引入了轴的概念:<code class="fe od oe of og b">axis</code>参数的值实际上是所讨论的索引号:第一个索引是<code class="fe od oe of og b">axis=0</code>，第二个是<code class="fe od oe of og b">axis=1</code>，依此类推。所以在2D，<code class="fe od oe of og b">axis=0</code>是按列的，而<code class="fe od oe of og b">axis=1</code>是按行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/0145d349edff7f57798b799fc55d171a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmXqsVUNaBaUsBAkHgqb3A.png"/></div></div></figure><p id="548d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，第一维度<code class="fe od oe of og b">i</code> (axis=0)负责对行进行索引，因此<code class="fe od oe of og b">sum(axis=0)</code>应该理解为“对其所有行的任何给定列求和”，而不仅仅是“按列”。2D的例子有些反直觉:你需要指定要消除的尺寸<em class="pk"/>，而不是你通常会想到的剩余尺寸<em class="pk">。然而，在更高维的情况下，这更自然:如果你只需要对一个维度求和，那么列举所有剩余维度将是一个负担。</em></p><p id="e236" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“轴”参数的概念(在MATLAB中称为“维度”)实际上非常简单:它只是您希望操作继续执行的索引号。它在NumPy的许多函数中使用，所以理解它是值得的，但是如果出于某种原因它不适合你，在这种特殊情况下，你可以使用爱因斯坦求和——这是一种不用“轴”进行求和的方法:<code class="fe od oe of og b">np.einsum(‘ij-&gt;j’, a)</code>是按列求和的(与上图中的<code class="fe od oe of og b">sum(axis=0)</code>相同),而<code class="fe od oe of og b">np.einsum(‘ij-&gt;i’, a)</code>是按行求和的(与<code class="fe od oe of og b">sum(axis=1)</code>相同)。</p><h2 id="e868" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">矩阵运算</h2><p id="ccc2" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">除了按元素工作的普通运算符(如+、-、*、/、//和**)之外，还有一个@运算符可以计算矩阵乘积:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/f42215c1c9840083cbb3c73dad817c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0vpti4m5rnRdG7tjFBAAA.png"/></div></div></figure><p id="17f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为我们在第一部分已经看到的标量广播的推广，NumPy允许在向量和矩阵之间，甚至在两个向量之间进行混合运算:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/ca4f676499cd9c1fdad0c7de9aae09ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbi-kCjxBE9Wd6Y0cKHfaQ.png"/></div></div></figure><p id="75ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，在最后一个示例中，这是一个对称的每元素乘法。要使用非对称线性代数矩阵乘法计算外积，操作数的顺序应该颠倒过来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/42c2b1aba7eaecd5c2ba8544871f2a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AxPMBAD67SbeXV4wEdcamQ.png"/></div></div></figure><h2 id="430e" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">行向量和列向量</h2><p id="b7f9" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">从上面的例子可以看出，在2D上下文中，行和列向量被不同地对待。这与通常尽可能使用一种类型的1D数组的NumPy实践形成对比(例如，<code class="fe od oe of og b">a[:,j]</code>—2D数组的第j列<code class="fe od oe of og b">a</code> —是1D数组)。默认情况下，1D数组在2D运算中被视为行向量，因此当矩阵乘以行向量时，您可以使用shape (n，)或(1，n) —结果将是相同的。如果你需要一个列向量，有几种方法可以从1D数组中得到它，但是令人惊讶的是<code class="fe od oe of og b">transpose</code>不在其中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/262a9f0c8e554746d2392aa6463f2d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYk9Ukt2OpnWXrlYqjXEBw.png"/></div></div></figure><p id="dcf1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="pk">和</em>能够从1D数组中生成2D列向量的两个操作是用<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" rel="noopener ugc nofollow" target="_blank">newaxis</a></code>整形和索引:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/af734071ef10ca078357da8fa56c2f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ettWjwGl17oyxeSvAHtbCQ.png"/></div></div></figure><p id="ac33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里-1参数告诉<code class="fe od oe of og b">reshape</code>自动计算一个尺寸大小，方括号中的<code class="fe od oe of og b">None</code>作为<code class="fe od oe of og b">np.newaxis</code>的快捷方式，在指定位置添加一个空轴。另一种方法是通过<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.expand_dims.html" rel="noopener ugc nofollow" target="_blank">expand_dims</a>(a, axis=0)</code>，其中0告诉NumPy您希望新轴出现的位置。</p><p id="a907" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，NumPy中总共有三种类型的向量:1D数组、2D行向量和2D列向量。下面是这两者之间显式转换的示意图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/f8d27b6226828020e323bb5256017849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9j1sDyzpBXLxK11vU-Mtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flatten.html" rel="noopener ugc nofollow" target="_blank">展平</a>始终是一个副本，<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.reshape.html" rel="noopener ugc nofollow" target="_blank">整形</a> (-1)始终是一个视图，<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.ravel.html" rel="noopener ugc nofollow" target="_blank">散开</a>可能时是一个视图</p></figure><p id="1531" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据广播规则，1D数组被隐式解释为2D行向量，因此通常不需要在这两者之间进行转换——因此相应的区域是有阴影的。</p><p id="8676" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="pk">严格来说，任何一个数组，除了一维以外都是一维的，都是一个向量(例如</em> <code class="fe od oe of og b">a.shape==[1,1,1,5,1,1]</code> <em class="pk">)，所以numpy中有无限多种向量类型，但常用的只有这三种。你可以使用</em> <code class="fe od oe of og b">np.reshape </code> <em class="pk">将一个“正常的”1D矢量转换成这种形式，并使用</em> <code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.squeeze.html" rel="noopener ugc nofollow" target="_blank">squeeze</a></code> <em class="pk">将其恢复。这两个函数都充当视图。</em></p><h2 id="0c20" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">矩阵操作</h2><p id="2360" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">连接阵列有两个主要功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/03785f122faeab33a2c5dfc348330b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJbmp5_qJixVztVMJQn9sw.png"/></div></div></figure><p id="db15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种方法只适用于堆叠矩阵或向量，但是当混合堆叠1D数组和矩阵时，只有<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.vstack.html" rel="noopener ugc nofollow" target="_blank">vstack</a></code>能按预期工作:<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.hstack.html" rel="noopener ugc nofollow" target="_blank">hstack</a></code>会产生维度不匹配错误，因为如上所述，1D数组被解释为行向量，而不是列向量。解决方法是将其转换为行向量，或者使用专门的<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.column_stack.html" rel="noopener ugc nofollow" target="_blank">column_stack</a></code>函数自动完成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/52a191c754a6f0979f6440847092d1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUFxtl3Z2cdDZhcLUNpE0Q.png"/></div></div></figure><p id="5bb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">堆叠的逆过程是分裂:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/dca77c148d7a456cc7f5430d5b93649b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADtgaXz1wxze7c6K6kK9CQ.png"/></div></div></figure><p id="ef48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.split.html" rel="noopener ugc nofollow" target="_blank">split</a></code>风格要么接受一个要分割的索引列表，要么接受一个整数，即相同大小部分的数量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/4ea5cee7101dd3b7df3b8f8657bfb13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhinWlrXT9nOlr6qUI8RHw.png"/></div></div></figure><p id="8d4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">矩阵复制有两种方式:<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.tile.html" rel="noopener ugc nofollow" target="_blank">tile</a></code>类似于复制粘贴，<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.repeat.html" rel="noopener ugc nofollow" target="_blank">repeat</a></code>类似于分页打印:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qk"><img src="../Images/c3de5aa1d0f38b4b6f1c1845b0f62a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCClP8kiegtYZNyEdsCPbw.png"/></div></div></figure><p id="cbbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">特定的列和行可以是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ql"><img src="../Images/1ddd4a258e652893a0160e6d4adc047e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSCZ2ADLw-YN-S6reXOiMQ.png"/></div></div></figure><p id="b739" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反向操作是<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.insert.html" rel="noopener ugc nofollow" target="_blank">insert</a></code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qm"><img src="../Images/8f936917e0a0052b83674edf01aaf70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEVGMjetDiL27pSOAO7FuA.png"/></div></div></figure><p id="158a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.append.html" rel="noopener ugc nofollow" target="_blank">append</a></code>函数，就像<code class="fe od oe of og b">hstack</code>一样，不能自动转置1D数组，所以再次强调，要么需要对向量进行整形，要么增加一个维度，要么需要使用<code class="fe od oe of og b">column_stack</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qn"><img src="../Images/c854550c5c878a0822db3ad86a8e5976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ji2JnZUnVcG6IHFSl0FWFg.png"/></div></div></figure><p id="7555" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，如果您所要做的就是向数组的边界添加常量值，那么<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html" rel="noopener ugc nofollow" target="_blank">pad</a></code>函数就足够了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qo"><img src="../Images/623e48b0c162661b593edbf61edd521e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nymIetfKC2vkbmNrxoSeGg.png"/></div></div></figure><h2 id="4717" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">网格</h2><p id="7fab" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">广播规则使得使用网格更加简单。假设，您需要下面的矩阵(但是非常大):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qp"><img src="../Images/3cd298d5800a4c1259fe4b9ee8a62079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdYuQI6m7C6oTAdYNPLoyQ.png"/></div></div></figure><p id="a4d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两种明显的方法很慢，因为它们使用Python循环。MATLAB处理这类问题的方法是创建一个网格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/12c8881749dd8e933d654cd05ffeb705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pM5EfQuHuAAH-5VL-r9aw.png"/></div></div></figure><p id="4d4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html" rel="noopener ugc nofollow" target="_blank">meshgrid</a></code>函数接受一组任意的索引，<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.mgrid.html" rel="noopener ugc nofollow" target="_blank">mgrid</a></code> —只是切片，而<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.indices.html" rel="noopener ugc nofollow" target="_blank">indices</a></code>只能生成完整的索引范围。<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.fromfunction.html" rel="noopener ugc nofollow" target="_blank">fromfunction</a></code>使用如上所述的I和J参数调用所提供的函数一次。</p><p id="248d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但实际上，在NumPy中有更好的方法。没有必要在整个I和J矩阵上花费内存(即使<code class="fe od oe of og b">meshgrid</code>足够聪明，可能的话只存储对原始向量的引用)。只存储正确形状的向量就足够了，其余的由广播规则处理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qq"><img src="../Images/07f88c91aaf1b150340e9a5888a8a181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Af4Z0dCrwxyZRzImmtoeBA.png"/></div></div></figure><p id="7845" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有<code class="fe od oe of og b">indexing=’ij’</code>参数，<code class="fe od oe of og b">meshgrid</code>将改变参数的顺序:<code class="fe od oe of og b">J, I= np.meshgrid(j, i)</code> —这是一种“xy”模式，用于可视化3D绘图(参见文档中的<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html" rel="noopener ugc nofollow" target="_blank">示例)。</a></p><p id="5b70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了在二维或三维网格上初始化函数之外，网格还可以用于索引数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qr"><img src="../Images/0cd5ae5804b59e505d7040fadf9f744a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVIGDRv9TAqVwJV4mm69Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">也适用于稀疏网格</p></figure><h2 id="942b" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">矩阵统计</h2><p id="78fc" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">就像<code class="fe od oe of og b">sum</code>一样，所有其他统计函数(<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.min.html" rel="noopener ugc nofollow" target="_blank">min</a>/<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.max.html" rel="noopener ugc nofollow" target="_blank">max</a></code>、<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.argmin.html" rel="noopener ugc nofollow" target="_blank">argmin</a>/<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.argmax.html" rel="noopener ugc nofollow" target="_blank">argmax</a></code>、<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html" rel="noopener ugc nofollow" target="_blank">mean</a>/<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.median.html" rel="noopener ugc nofollow" target="_blank">median</a>/<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.percentile.html" rel="noopener ugc nofollow" target="_blank">percentile</a></code>、<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.std.html" rel="noopener ugc nofollow" target="_blank">std</a>/<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.var.html" rel="noopener ugc nofollow" target="_blank">var</a></code>)都接受<code class="fe od oe of og b">axis</code>参数并相应地执行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qs"><img src="../Images/6151eb21329582c533b1fd7489f90bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTNRworY2lLrtnEW92tQbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">np。<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.amin.html" rel="noopener ugc nofollow" target="_blank"> amin </a>只是np.min的别名，以避免在编写'<code class="fe od oe of og b">from numpy import *'</code>时遮蔽Python min</p></figure><p id="7c90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2D和更高版本中的<code class="fe od oe of og b">argmin</code>和<code class="fe od oe of og b">argmax</code>函数有一个麻烦，就是返回扁平化的索引(最小值和最大值的第一个实例)。要将其转换为两个坐标，需要一个<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.unravel_index.html" rel="noopener ugc nofollow" target="_blank">unravel_index</a></code>函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qt"><img src="../Images/a5b3b3b9209de56e563d3cb415656777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bbkABjr18h_q5cPQmgkehg.png"/></div></div></figure><p id="cba0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">量词<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.all.html" rel="noopener ugc nofollow" target="_blank">all</a></code>和<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.any.html" rel="noopener ugc nofollow" target="_blank">any</a></code>也知道<code class="fe od oe of og b">axis</code>这个参数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qu"><img src="../Images/092442018c3cd2d0d3564c6fd4faac6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y95ZnO1wB9U-MFAYf4r4qw.png"/></div></div></figure><h2 id="b97e" class="nq mr it bd ms nr ns dn mw nt nu dp na lh nv nw nc ll nx ny ne lp nz oa ng ob bi translated">矩阵排序</h2><p id="c0cf" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">尽管<code class="fe od oe of og b">axis</code>参数对上面列出的函数很有帮助，但它对2D排序毫无帮助:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qv"><img src="../Images/debd0c6f851a5fc39739716b239b3783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ilp0Mn0vS5ly0NhxUs3bhw.png"/></div></div></figure><p id="4c7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是你通常想要的对矩阵或电子表格排序:<code class="fe od oe of og b">axis</code>不能代替<code class="fe od oe of og b">key</code>参数。但是幸运的是，NumPy有几个助手函数，允许按一列排序——如果需要，也可以按几列排序:</p><p id="2fa9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.<code class="fe od oe of og b">a[a[:,0].<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.argsort.html" rel="noopener ugc nofollow" target="_blank">argsort</a>()]</code>按第一列对数组排序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/c0abad475b141ade5f2eaf47ff31cf60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*way2tJEnsXOjtfo1PkTv8w.png"/></div></div></figure><p id="073f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.argsort.html" rel="noopener ugc nofollow" target="_blank">argsort</a></code>返回排序后的原数组的索引数组。</p><p id="ac0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个技巧可以重复，但是必须小心，不要让下一个排序弄乱前一个排序的结果:<code class="fe od oe of og b"><br/>a = a[a[:,2].argsort()]<br/>a = a[a[:,1].argsort(kind='stable')]<br/>a = a[a[:,0].argsort(kind='stable')]</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qw"><img src="../Images/c848aabc54a0dae475a613b4f9fd396c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r98wxRa5nD4uK9KMcV7pEA.png"/></div></div></figure><p id="ac87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.有一个助手函数<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html" rel="noopener ugc nofollow" target="_blank">lexsort</a></code>，它按照上面描述的方式对所有可用的列进行排序，但是它总是按行执行，并且要排序的行的顺序是颠倒的(即从下到上)，所以它的用法有点做作，例如<br/>–<code class="fe od oe of og b">a[np.lexsort(np.rot90(a))]</code>按照从左到右的顺序对所有列进行排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qx"><img src="../Images/ca8a3bf1da53f939b3d8b36396a9d89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IA-eW_0yADEape36TOBRRA.png"/></div></div></figure><p id="a588" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">–<code class="fe od oe of og b">a[np.lexsort(np.rot90(a[:,[2,5]]))]</code>先按第2列排序，然后(当第2列中的值相等时)按第5列排序。另一种形式是<code class="fe od oe of og b">a[np.lexsort(np.flipud(a.T[[2,5]]))]</code></p><p id="e67e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.flipud.html" rel="noopener ugc nofollow" target="_blank">flipud</a></code>在上下方向翻转矩阵(准确地说，在<code class="fe od oe of og b">axis=0</code>方向，与<code class="fe od oe of og b">a[::-1,...]</code>相同，其中三个点表示“所有其他维度”——所以是突然的<code class="fe od oe of og b">flipud</code>，而不是<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.fliplr.html" rel="noopener ugc nofollow" target="_blank">fliplr</a></code>，翻转1D数组)，而<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.rot90.html" rel="noopener ugc nofollow" target="_blank">rot90</a></code>在正方向(即逆时针)旋转矩阵90度。翻转和旋转90°都返回视图。</p><p id="8ef7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.要使用<code class="fe od oe of og b">sort</code>的<code class="fe od oe of og b">order</code>参数，首先将数组转换为结构化形式，然后对其进行排序，最后将其转换回普通(“非结构化”)形式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qy"><img src="../Images/6806991134d3d30af6478ad2b99f9b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOsfSY2_d43iee9Dv3nXhg.png"/></div></div></figure><p id="8487" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种转换实际上都是视图，因此速度很快，不需要任何额外的内存。但是函数<code class="fe od oe of og b">u2s</code>和<code class="fe od oe of og b">s2u</code>需要先导入恐怖的<code class="fe od oe of og b">from numpy.lib.recfunctions import unstructured_to_structured as u2s, structured_to_unstructured as s2u</code></p><p id="b045" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.在Pandas中这样做可能是一个更好的选择，因为这个特定的操作可读性更好，不容易出错:<br/>–<code class="fe od oe of og b">pd.DataFrame(a).<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html" rel="noopener ugc nofollow" target="_blank">sort_values</a>(by=[2,5]).to_numpy()</code>先按列2排序，然后按列5排序。<br/>–<code class="fe od oe of og b">pd.DataFrame(a).sort_values().to_numpy()</code>按所有列从左到右的顺序排序。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c6af" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.3D及以上</h1><p id="9eea" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">通过重塑1D矢量或转换嵌套Python列表来创建3D数组时，索引的含义为(z，y，x)。第一个索引是飞机的编号，然后是飞机的坐标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qz"><img src="../Images/25059a6b178626f9c953e195e300ebe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAr1RXkpGJD5lcwbTePGLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通用3D阵列</p></figure><p id="c49a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种索引顺序很方便，比如保存一堆灰度图像:<code class="fe od oe of og b">a[i]</code>是引用第I张图像的快捷方式。</p><p id="b4e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这种索引顺序并不通用。当处理RGB图像时，通常使用(y，x，z)顺序:首先是两个像素坐标，最后一个是颜色坐标(RGB在<a class="ae lu" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>中，BGR在<a class="ae lu" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/2ad087efeebb7fd11f988e328766b911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2p58GMzIPSQYVrS2E-rbFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RGB图像</p></figure><p id="9d78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样引用一个特定的像素很方便:<code class="fe od oe of og b">a[i,j]</code>给出了一个<code class="fe od oe of og b">(i,j)</code>像素的<code class="fe od oe of og b">(r,g,b)</code>元组。</p><p id="a8e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，创建特定几何形状的实际命令取决于您正在处理的领域的约定:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ra"><img src="../Images/6e962c95a5b2fe54087f2c35b02130c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NNm3gGO8sEinq6JYlI84dg.png"/></div></div></figure><p id="490a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，像<code class="fe od oe of og b">hstack</code>、<code class="fe od oe of og b">vstack</code>或<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.dstack.html" rel="noopener ugc nofollow" target="_blank">dstack</a></code>这样的NumPy函数并不知道这些约定。其中硬编码的索引顺序为(y，x，z)，RGB图像顺序为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rb"><img src="../Images/69fafeafbdae0fbe067a12d8f1243521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_XjRbJHN26dMw1dcRS6qQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆叠RGB图像(此处只有两种颜色)</p></figure><p id="6403" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您的数据布局不同，使用<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html" rel="noopener ugc nofollow" target="_blank">concatenate</a></code>命令堆叠图像会更方便，在<code class="fe od oe of og b">axis</code>参数中输入明确的索引号:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/328e13359b305b2ad5e0fe6c07f4e105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUfuXiTZOas6ZSD_lOSbXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆叠通用3D阵列</p></figure><p id="2c1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果考虑轴数对您不方便，您可以将数组转换为硬编码为<code class="fe od oe of og b">hstack</code>和co:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rc"><img src="../Images/5b587a19315f899173aac65606afdd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yGMnpHwEo8XeJET_U5CMA.png"/></div></div></figure><p id="44e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种转换是廉价的:没有实际的复制发生；它只是动态地混合了索引的顺序。</p><p id="26bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种混合索引顺序的操作是数组转置。查看它可能会让您对3D数组更加熟悉。根据您决定的轴的顺序，转置阵列所有平面的实际命令会有所不同:对于通用阵列，它交换索引1和2，对于RGB图像，它交换索引0和1:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rd"><img src="../Images/87946f8e7cdf513b535839209caa0e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJiDVb9xb8VL9XmFDevSGg.png"/></div></div></figure><p id="e8b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是，<code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.transpose.html" rel="noopener ugc nofollow" target="_blank">transpose</a></code>的默认<code class="fe od oe of og b">axes</code>参数(也是唯一的<code class="fe od oe of og b">a.T</code>操作模式)颠倒了索引顺序，这与上面描述的索引顺序惯例都不一致。</p><p id="52d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更高维度的广播作品也一样，详见我的短文《NumPy 中的<a class="ae lu" href="https://towardsdatascience.com/broadcasting-in-numpy-58856f926d73?sk=d3f8527b160fba2ad87e201369279e52" rel="noopener" target="_blank">广播》。</a></p><p id="08fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在处理多维数组时，这里有一个函数可以帮你省去很多Python循环，并且可以让你的代码更整洁— <code class="fe od oe of og b"><a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.einsum.html" rel="noopener ugc nofollow" target="_blank">einsum</a></code>(爱因斯坦求和):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi re"><img src="../Images/21fc6c58ccbda3725deab51cda5f39ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGKflexdelNxiireoI8YJw.png"/></div></div></figure><p id="fe4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它沿着重复的索引对数组求和。在这个特殊的例子中，<code class="fe od oe of og b">np.<a class="ae lu" href="https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html" rel="noopener ugc nofollow" target="_blank">tensordot</a>(a, b, axis=1)</code>在两种情况下都足够了，但是在更复杂的情况下，<code class="fe od oe of og b">einsum</code>可能工作得更快，并且通常更容易读写——一旦你理解了它背后的逻辑(参见我的新的<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/einsum-visualized-c050903145ef?sk=e05c7d70e150f91e29f3d0a37326e087"> Einsum Visualized </a>指南了解详情)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="e7b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想测试你的数字技能，GitHub上有一套巧妙的众包<a class="ae lu" href="https://github.com/rougier/numpy-100" rel="noopener ugc nofollow" target="_blank"> 100数字练习</a> ⁰。</p><p id="625b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我错过了你最喜欢的NumPy功能，请让我知道(在<a class="ae lu" href="https://www.reddit.com/r/MachineLearning/comments/kibblu/p_numpy_illustrated_the_visual_guide_to_numpy/" rel="noopener ugc nofollow" target="_blank"> reddit </a>、<a class="ae lu" href="https://news.ycombinator.com/item?id=25550393" rel="noopener ugc nofollow" target="_blank"> hackernews </a>或<a class="ae lu" href="https://twitter.com/LevMaximov" rel="noopener ugc nofollow" target="_blank"> twitter </a>)，我会尽量把它放进去！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4ec7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">参考</h1><ol class=""><li id="3cf8" class="lv lw it la b lb ni le nj lh rf ll rg lp rh lt ma mb mc md bi translated">斯科特·希沃特，<a class="ae lu" href="https://stsievert.com/blog/2016/07/01/numpy-gpu" rel="noopener ugc nofollow" target="_blank"> NumPy GPU加速</a></li><li id="660a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Jay Alammar，<a class="ae lu" href="http://jalammar.github.io/visual-numpy/" rel="noopener ugc nofollow" target="_blank">NumPy和数据表示的可视化介绍</a></li><li id="9695" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"> Big-O备忘单网站</a></li><li id="09ed" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank"> Python时间复杂度wiki页面</a></li><li id="9d24" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">NumPy问题#14989，<a class="ae lu" href="https://github.com/numpy/numpy/pull/14989" rel="noopener ugc nofollow" target="_blank">排序函数中的反向参数</a></li><li id="7902" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">NumPy问题#2269，<a class="ae lu" href="https://github.com/numpy/numpy/issues/2269" rel="noopener ugc nofollow" target="_blank">第一个非零元素</a></li><li id="3ccc" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank">数字图书馆主页</a></li><li id="d9d1" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://floating-point-gui.de/errors/comparison/" rel="noopener ugc nofollow" target="_blank">浮点引导，比较</a></li><li id="704d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">NumPy问题#10161，<a class="ae lu" href="https://github.com/numpy/numpy/issues/10161" rel="noopener ugc nofollow" target="_blank">NumPy . is close vs math . is close</a></li><li id="4945" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://github.com/rougier/numpy-100" rel="noopener ugc nofollow" target="_blank">GitHub上的100个NumPy练习</a></li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a651" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">许可证</h1><p id="65d0" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">保留所有权利。未经作者许可)。</p></div></div>    
</body>
</html>