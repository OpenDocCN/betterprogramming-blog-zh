<html>
<head>
<title>Implement a Skybox Texture Using Rust and WebGL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust和WebGL实现一个天空盒纹理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/webgl-rust-webassembly-skybox-texture-cd3220bb1ebc?source=collection_archive---------17-----------------------#2022-05-09">https://betterprogramming.pub/webgl-rust-webassembly-skybox-texture-cd3220bb1ebc?source=collection_archive---------17-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bd6c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">模拟涡流粒子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbba90dd21f01fcc7e98fdd66a9a68fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iifMftT4O1mrKslkE56Z9g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Miramar天空盒纹理应用于漩涡粒子模拟网页浏览器</p></figure><p id="ab79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个故事着眼于使用Rust和WebGL实现一个<em class="lr">天空盒</em>纹理，用于<a class="ae ls" href="https://julien-decharentenay.medium.com/implementing-a-webassembly-webgl-viewer-using-rust-a6d8a703153d" rel="noopener">这个故事</a>中描述的漩涡粒子模拟的web查看器。一个<em class="lr">天空盒</em>纹理是"<em class="lr">一个上面有纹理的盒子[……]看起来像是很远的地方，包括地平线</em>"(<a class="ae ls" href="https://webgl2fundamentals.org/webgl/lessons/webgl-skybox.html" rel="noopener ugc nofollow" target="_blank">web gl2 fundamentals web gl2天空盒</a>)。</p><p id="a251" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">天空盒为WebGL场景提供了深度和上下文。使用的skybox图像由Hipshot命名为<em class="lr"> miramar </em>，在此发布<a class="ae ls" href="https://forums.epicgames.com/unreal-tournament-2003-2004/ut2004-level-editing-modeling-skinning/108243-my-skies-and-and-cliff-textures-large-images" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="fa36" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">源代码可在<a class="ae ls" href="https://github.com/juliendecharentenay/vortexParticleSimulation/blob/main/rust/wasm/src/viewer/program_skybox.rs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得，现场版本可在<a class="ae ls" href="https://cfd-webassembly.com/vpm/index.html" rel="noopener ugc nofollow" target="_blank">CFD-webassembly.com</a>上查看。</p><p id="58e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个故事中表达的观点/意见是我自己的。这个故事与我的个人经历和选择有关，并提供了希望有用的信息，但没有任何担保。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="d7e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想提及使这一实施成为可能的以下来源:</p><ul class=""><li id="7961" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated"><a class="ae ls" href="https://webgl2fundamentals.org/webgl/lessons/webgl-skybox.html" rel="noopener ugc nofollow" target="_blank">webgl 2 fundamentals webgl 2 SkyBox</a>章节和<a class="ae ls" href="https://github.com/gfxfundamentals/webgl2-fundamentals/blob/master/webgl/webgl-skybox.html" rel="noopener ugc nofollow" target="_blank">源代码</a>；</li><li id="f9ce" class="ma mb iq kx b ky mj lb mk le ml li mm lm mn lq mf mg mh mi bi translated"><a class="ae ls" href="https://www.keithlantz.net/2011/10/rendering-a-skybox-using-a-cube-map-with-opengl-and-glsl/" rel="noopener ugc nofollow" target="_blank">Keith Lantz使用OpenGL和GLSL的立方体贴图渲染天空盒</a>——引导我使用了<em class="lr"> miramar </em>天空盒纹理；</li><li id="22ca" class="ma mb iq kx b ky mj lb mk le ml li mm lm mn lq mf mg mh mi bi translated">“如何在Rust/WebGL中加载纹理”为我提供了足够的信息来制作第一个工作版本；和</li><li id="f652" class="ma mb iq kx b ky mj lb mk le ml li mm lm mn lq mf mg mh mi bi translated">这个<a class="ae ls" href="https://stackoverflow.com/questions/5314298/how-do-i-use-texsubimage2d-to-show-sprites-in-webgl" rel="noopener ugc nofollow" target="_blank"> StackOverflow问答</a>让我知道了如何成功地将一个图像的子集应用为纹理。</li></ul><p id="a32c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个实现引发了对这个问题的思考:<em class="lr">图像应该用JavaScript加载，然后传输到Rust/WebAssembly还是直接在Rust中？</em>我选择了后者，将与skybox相关的代码保存在一个Rust文件中—<a class="ae ls" href="https://github.com/juliendecharentenay/vortexParticleSimulation/blob/main/rust/wasm/src/viewer/program_skybox.rs" rel="noopener ugc nofollow" target="_blank"><em class="lr">program _ skybox . RS</em></a><em class="lr">。</em></p><h2 id="a693" class="mo mp iq bd mq mr ms dn mt mu mv dp mw le mx my mz li na nb nc lm nd ne nf ng bi translated">预赛</h2><p id="92bb" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">由于天空盒渲染需要分别访问视图和投影矩阵，因此进行了以下更改(如有兴趣，请参见<a class="ae ls" href="https://github.com/juliendecharentenay/vortexParticleSimulation/commit/ee3e13c4318e064a986f001db323dfe5c0f2a22f" rel="noopener ugc nofollow" target="_blank">此提交</a>):</p><ul class=""><li id="4219" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated"><code class="fe nm nn no np b"><em class="lr">camera.rs</em></code>修改为允许分别提取视图和投影矩阵；</li><li id="b8f1" class="ma mb iq kx b ky mj lb mk le ml li mm lm mn lq mf mg mh mi bi translated">对<code class="fe nm nn no np b">View</code>特征方法<code class="fe nm nn no np b">draw</code>和<code class="fe nm nn no np b">redraw</code>进行修改，用<code class="fe nm nn no np b">Camera</code>结构代替<code class="fe nm nn no np b">Matrix4</code>结构。</li></ul><h2 id="3e1c" class="mo mp iq bd mq mr ms dn mt mu mv dp mw le mx my mz li na nb nc lm nd ne nf ng bi translated">履行</h2><p id="069f" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated"><em class="lr">天空盒</em>渲染在结构<code class="fe nm nn no np b">ProgramSkyBox</code> <em class="lr"> — </em>文件<code class="fe nm nn no np b"><em class="lr">viewer/program_skybox.rs</em></code>—<em class="lr">—</em>中实现，并实现<code class="fe nm nn no np b">View</code>特征。</p><p id="438f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由顶点和片段着色器组成的WebGL程序几乎一字不差地取自WebGL2 SkyBox的着色器，并使用之前构建的辅助函数进行编译。程序在第一次需要时被编译，然后被重用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="540f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">天空盒渲染在<code class="fe nm nn no np b">redraw</code>方法中实现，因为渲染不依赖于模拟状态。</p><p id="9094" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该实现遵循与WebGL2 SkyBox实现中描述的步骤相同的步骤，但略有不同，如下所示:</p><ul class=""><li id="1e83" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated">将WebGL程序设置为当前渲染上下文:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="3d4e" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated">顶点数组缓冲区收集"<em class="lr">属性的状态，每个属性使用哪个缓冲区，以及如何从这些缓冲区中取出数据</em> " ( <a class="ae ls" href="https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html" rel="noopener ugc nofollow" target="_blank"> WebGL2基础知识</a>)。它在第一次调用时被初始化和填充，并在后续调用中重复使用:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="462b" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated">对于天空盒实现，我们不将3D空间坐标转换到视图空间，而是创建一个覆盖整个视图空间并直接使用视图空间坐标的四边形。基于观察方向和投影将纹理应用于该四边形。下面的代码摘录显示了这个quad的定义和赋值，它也非常类似于WebGL2 SkyBox实现。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="6c81" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated">应用于天空盒的纹理，又名立方体贴图，使用纹理层0定义和应用如下。下一节将提供更多关于纹理加载和<code class="fe nm nn no np b">assign_textures</code>方法实现的信息。该步骤是仅在第一次<code class="fe nm nn no np b">redraw</code>调用期间执行的最后一步。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="8a78" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated">以下代码在每次<code class="fe nm nn no np b">redraw</code>调用时运行，因为它与每次<code class="fe nm nn no np b">redraw</code>调用之间可能改变的摄像机方向有关。它使用视图矩阵来定义相机的方向，并将其与视图投影相结合来定义视图空间位置和纹理之间的关系——尽管我理解矩阵操作(例如，第10行到第14行交换了<code class="fe nm nn no np b">y</code>和<code class="fe nm nn no np b">z</code>坐标),但我并不完全理解投影和视图矩阵的乘积的反演如何与立方体贴图纹理相关联。因此，请参考<a class="ae ls" href="https://webgl2fundamentals.org/webgl/lessons/webgl-skybox.html" rel="noopener ugc nofollow" target="_blank"> WebGL2 SkyBox文章</a>了解关于此主题的更多详细信息…</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="9b14" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated">最后，根据WebGL2 SkyBox实现，在设置渲染参数后调用渲染函数。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1b30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这涵盖了WebGL渲染方面的实现，除了纹理加载和应用纹理时调用的<code class="fe nm nn no np b">assign_texture</code> <em class="lr"> </em>方法。</p><h2 id="0302" class="mo mp iq bd mq mr ms dn mt mu mv dp mw le mx my mz li na nb nc lm nd ne nf ng bi translated">纹理加载和分配</h2><p id="2e0e" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">我之前提到纹理图像是直接加载到Rust/WebAssembly中的。文章“<a class="ae ls" href="https://snoozetime.github.io/2019/12/19/webgl-texture.html" rel="noopener ugc nofollow" target="_blank">如何在Rust/WebGl </a>中加载纹理”提供了一种使用<code class="fe nm nn no np b">HtmlImageElement</code>元素及其关联的<code class="fe nm nn no np b">on_load</code>回调元素的方法——同时提到闭包的删除需要仔细考虑，因为它“正在Rust中泄漏内存”。</p><p id="4c7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我选择使用<code class="fe nm nn no np b">fetch</code> <a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> API </em> </a>来加载图像内容，然后将这些内容转换成一个<code class="fe nm nn no np b">ImageBitmap</code>。这些函数(以及其他函数)使用承诺来代替回调，因此减少了对丢弃闭包的需求。使用<code class="fe nm nn no np b">wasm-bindgen-futures</code>箱将JavaScript承诺视为Rust Future——参见<code class="fe nm nn no np b">wasm-bindgen</code>指南中的<a class="ae ls" href="https://rustwasm.github.io/wasm-bindgen/reference/js-promises-and-rust-futures.html" rel="noopener ugc nofollow" target="_blank">使用JS承诺和Rust Future </a>。</p><p id="4308" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图像获取和转换是在创建<code class="fe nm nn no np b">ProgramSkyBox</code>对象的过程中进行的——它现在是一个异步函数。该函数的异步特性暴露给JavaScript，以允许使用以下代码创建天空盒视图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="49e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe nm nn no np b">fetch</code> <em class="lr"> API </em>加载纹理并转换为<code class="fe nm nn no np b">ImageBitmap</code>如下所示。执行单个获取调用来加载单个图像，该图像组合了需要应用于立方体贴图的6个面的所有6个纹理。使用<code class="fe nm nn no np b">CubeMapTexSxSySw</code> struct存储图像中纹理的坐标。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fc98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">加载的<code class="fe nm nn no np b">ImageBitmap</code>与存储在<code class="fe nm nn no np b">CubeMapTexSxSySw</code>对象中的<code class="fe nm nn no np b">x</code>、<code class="fe nm nn no np b">y</code>和<code class="fe nm nn no np b">w</code>参数一起使用，以在<code class="fe nm nn no np b">assign_textures</code>方法中识别并应用图像的相关部分到每个立方体贴图纹理。使用<code class="fe nm nn no np b">HtmlCanvasElement</code>提取图像的相关部分。我最初尝试使用<code class="fe nm nn no np b">texSubImage2d</code>方法，但是没有成功——类似于最初发帖者对<a class="ae ls" href="https://stackoverflow.com/questions/5314298/how-do-i-use-texsubimage2d-to-show-sprites-in-webgl" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>的查询。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="8d47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我发现给网页浏览器添加背景纹理非常有趣。它让我对承诺和未来有了更好的理解。我将简化与错误映射和导致转换的选项相关的样板代码——但这将是另一天的事情。</p></div></div>    
</body>
</html>