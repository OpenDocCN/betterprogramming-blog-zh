<html>
<head>
<title>How Would You Design TinyURL and Instagram?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你会如何设计TinyURL和Instagram？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-would-you-design-tinyurl-and-instagram-987dfc06cbe9?source=collection_archive---------1-----------------------#2020-05-22">https://betterprogramming.pub/how-would-you-design-tinyurl-and-instagram-987dfc06cbe9?source=collection_archive---------1-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f108" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">系统设计面试准备指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a79411e6a51b1491c1067c6d50d2f640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leO6tMoHhSfi71FHYl3l0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="7aa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在当今的科技行业，理解系统设计比以往任何时候都更加重要。随着应用程序变得越来越大，设计既高效又可靠的架构模式非常重要。现在，系统设计通常是获得你梦想中的软件工程工作的必要条件。</p><p id="a4c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我们将通过设计Instagram和TinyURL来回顾系统设计原则。</p><p id="546f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将涵盖:</p><ul class=""><li id="9baf" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如何设计TinyURL</li><li id="95f3" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何设计Instagram</li><li id="ec7d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">更多资源</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/87f326220cb0d752d51c9f4104f6e477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8SwToX81G7B0ckun"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6434" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何设计TinyURL</h1><h2 id="170c" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">TinyURL是什么？</h2><p id="622b" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">TinyURL是一个缩短URL的web服务，为长URL创建较短的别名。当点击短链接时，用户被重定向到原始URL。这项服务非常有用，因为短链接可以节省空间，并允许用户更容易地键入长URL。</p><h2 id="4a55" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">系统的要求和目标</h2><p id="ca65" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">在设计类似TinyURL的应用程序时，需要考虑一些功能性和非功能性需求。</p><p id="ac9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非功能性需求:</p><ul class=""><li id="0acd" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">系统必须高度可用。如果服务失败，所有的短链接都将不起作用。</li><li id="90ec" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">URL重定向应该以最小的延迟实时发生。</li><li id="61d1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">缩短的链接不应该以任何方式预测。</li></ul><p id="3ccc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">功能要求:</p><ul class=""><li id="d3da" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">当给定一个URL时，我们的服务将生成原始URL的一个较短的别名。这个新链接将被大大缩短，以便于复制和粘贴。</li><li id="3c78" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">短链接应该将用户重定向到原始链接。</li><li id="bcbb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">用户应该可以选择为他们的URL选择一个自定义的短链接。</li><li id="e524" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">短链接将在默认时间间隔后过期，但用户可以指定过期时间。</li></ul><h2 id="5e3c" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">容量估计和限制</h2><p id="214b" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们的系统将会被大量读取。与新的URL缩短相比，将会有大量的重定向请求。让我们假设读和写的比率为100:1。</p><h2 id="aca9" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">交通量估计</h2><p id="d25a" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">假设我们每个月有5亿个新的URL快捷方式，读/写比为100:1，我们可以预计在同一时期有500亿个重定向:</p><p id="2c99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 100 * 500M = &gt; 50B </em></p><p id="670c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们系统的每秒查询数(QPS)是多少？每秒新的URL缩写:</p><p id="f95f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 5亿/ (30天* 24小时* 3600秒)= ~200个网址/秒</em></p><p id="9ad8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到100:1的读/写比，每秒的URL重定向将为:</p><p id="7889" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 100 * 200个网址/秒= 20K/秒</em></p><h2 id="f15d" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">存储估计</h2><p id="517f" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">假设我们将每个URL缩短请求(以及相关的缩短链接)存储了五年。由于我们预计每个月会有5亿个新URL，因此我们预计要存储的对象总数将达到300亿:</p><p id="f202" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 5亿* 5年* 12个月= 300亿</em></p><p id="1900" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们假设每个存储的对象大约为500字节(这只是一个大概的估计——我们稍后会深入研究)。我们将需要15TB的总存储空间:</p><p id="d116" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa">300亿* 500字节= 15 TB </em></p><h2 id="5f0b" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">带宽估计</h2><p id="59ad" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">对于写入请求，由于我们预计每秒会有200个新URL，因此我们服务的总传入数据将为每秒100KB:</p><p id="38e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 200 * 500字节= 100 KB/s </em></p><p id="5abb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于读取请求，由于我们预计每秒大约有20K个URL重定向，因此我们服务的总传出数据将为每秒10MB:</p><p id="c5b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 20K * 500字节= ~10 MB/s </em></p><h2 id="e887" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">内存估计</h2><p id="896c" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">如果我们想缓存一些经常访问的热门网址，我们需要多少内存来存储它们？如果我们遵循80-20规则，这意味着20%的URL产生80%的流量，我们希望缓存这些热门URL。</p><p id="219a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们每秒有20，000个请求，所以我们每天会收到17亿个请求:</p><p id="544f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 20K * 3600秒* 24小时= ~ 17亿</em></p><p id="21ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要缓存其中20%的请求，我们需要170GB的内存:</p><p id="645e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa">0.2 * 17亿* 500字节= ~170GB </em></p><p id="3cca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里需要注意的一点是，由于会有很多重复的请求(相同URL的)，我们的实际内存使用将少于170GB。</p><h2 id="b41c" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">系统API</h2><p id="c8e9" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们可以使用REST APIs来公开服务的功能。以下是用于创建和删除URL而无需服务的API的定义示例:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="6634" class="ni mr it oc b gy og oh l oi oj">createURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_date=None)</span></pre><p id="587f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">参数:</p><ul class=""><li id="0f1a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe ok ol om oc b">api_dev_key</code>(字符串):注册账户的API开发者密钥。这将用于根据分配给用户的配额限制用户。</li><li id="ccff" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe ok ol om oc b">original_url</code>(字符串):要缩短的原始URL。</li><li id="a4c1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe ok ol om oc b">custom_alias</code>(字符串):URL的可选自定义键。</li><li id="6925" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe ok ol om oc b">user_name</code>(字符串):编码中使用的可选用户名。</li><li id="f28f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe ok ol om oc b">expire_date</code>(字符串):缩短的URL的可选截止日期。</li></ul><p id="f547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Returns (string):成功插入将返回缩短的URL。否则，它会返回一个错误代码。</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="4ca5" class="ni mr it oc b gy og oh l oi oj">deleteURL(api_dev_key, url_key)</span></pre><p id="539b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ok ol om oc b">url_key</code>是一个字符串，描述了需要删除的缩短的URL。成功删除将返回<code class="fe ok ol om oc b">URL Removed</code>。</p><h2 id="eafb" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">数据库设计</h2><p id="ed60" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">让我们来看看对我们存储的数据的一些观察:</p><ul class=""><li id="66e3" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">这项服务需要存储数十亿条记录。</li><li id="55af" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">这项服务的阅读量很大。</li><li id="f12e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">每个对象都很小(小于1K)。</li><li id="8ccd" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">除了用户用短链接创建的存储之外，每个记录之间没有任何关系。</li></ul><p id="dee1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于模式，<strong class="la iu"> </strong>我们需要一个表来存储关于URL映射的信息，还需要另一个数据库来存储来自创建短链接的用户的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d27fe7329dcffe3fb90b34af47622e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zu0iEoOpdDjiRe3aFdeC-w.png"/></div></div></figure><p id="c30b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最好的数据库类型是NoSQL的数据库存储，比如DynamoDB或Cassandra，因为我们存储的是数十亿行，而对象之间没有关系。</p><h2 id="9cb3" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">基本系统设计和算法</h2><p id="7d6f" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">对于我们的服务来说，最大的问题是当给定一个URL时，如何生成一个简短且唯一的密钥。我们今天要看的方法是对实际的URL进行编码。</p><p id="ac5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以计算一个唯一的散列(例如MD5、SHA256等。)的链接。然后可以对散列进行编码以供显示。这种编码可以是base36 ([a-z，0–9])或base62 ([a-z，A-Z，0–9])。如果加上<code class="fe ok ol om oc b">+</code>和<code class="fe ok ol om oc b">/</code>，就可以用Base64编码了。一个合理的问题是，“短键的长度应该是多少？6、8或10个字符？”</p><ul class=""><li id="baf3" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">使用base64编码，六个字母的密钥将产生64⁶= ~ 687亿个可能的字符串。</li><li id="0b61" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用base64编码，一个八个字母的密钥将产生64⁸ = ~281万亿个可能的字符串</li><li id="c6c2" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">有了687亿个唯一的字符串，让我们假设六个字母的键对我们的系统来说就足够了。</li></ul><p id="4911" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们使用MD5算法作为散列函数，它将产生一个128位的散列值。经过base64编码后，我们将得到一个超过21个字符的字符串(因为每个base64字符编码哈希值的6位)。现在我们每个快捷键只能容纳八个字符。那么我们将如何选择我们的密钥呢？</p><p id="66d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用前六个(或八个)字母作为密钥。这可能导致密钥重复。为了解决这个问题，我们可以从编码字符串中选择一些其他字符或者交换一些字符。</p><p id="79a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">采用这种方法时的潜在障碍:</p><ul class=""><li id="ce3e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如果多个用户输入相同的URL，他们将获得相同的短链接。</li><li id="6641" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">URL的某些部分可以进行URL编码。</li></ul><p id="6d43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">变通办法:</p><ul class=""><li id="2de1" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">为了解决其中的一些问题，我们可以将一个序列中的数字附加到每个短链接URL上。这使得它是唯一的，即使多个用户提供相同的URL。</li><li id="4878" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">另一个潜在的解决方案是将用户id附加到输入URL上。如果用户没有登录，这将不起作用，我们将不得不生成一个惟一性密钥。</li></ul><h2 id="7b8d" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">数据分区和复制</h2><p id="95c3" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">不可避免地，我们将需要扩展我们的数据库，这意味着我们必须对它进行分区，以便我们可以存储数十亿个URL的信息。</p><p id="119a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于范围的分区:我们可以根据散列键的首字母将URL存储在单独的分区中。因此，我们将所有URL的散列关键字的第一个字母保存在一个分区中，以此类推。</p><p id="fadb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法是有问题的，因为它会导致不平衡的数据库服务器，造成不均衡的负载。</p><p id="5f48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于散列的分区:使用基于散列的分区，我们可以获得被存储对象的散列，然后计算使用哪个分区。哈希函数会将数据随机分配到不同的分区。</p><p id="99be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时，这种方法会导致分区过载，这可以使用一致散列法<em class="oa">来解决。</em></p><h2 id="3bc2" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">隐藏物</h2><p id="78c7" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们的服务应该能够缓存经常被访问的URL。我们可以通过Memcached这样的解决方案做到这一点，Memcached可以存储完整的URL和相应的哈希。</p><p id="bfda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该有多少高速缓冲存储器？首先，我们可以从大约20%的日常流量开始，并根据使用模式进行调整。根据我们之前的估计，我们将需要170GB的内存来缓存20%的日常流量。</p><p id="e7bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该使用哪种缓存回收策略？因为我们想用一个更流行的URL替换一个链接，所以我们可以对我们的系统使用最近最少使用(LRU)策略。</p><h2 id="8268" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">负载平衡器(磅)</h2><p id="f53e" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">我们可以在三个地方向系统添加负载平衡层:</p><ul class=""><li id="9efa" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">客户端和应用服务器之间</li><li id="f445" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在应用服务器和数据库服务器之间</li><li id="6083" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在应用服务器和缓存服务器之间</li></ul><p id="0e15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们可以简单地使用循环法，在服务器之间平均分配传入的请求。这很容易实现，并且不会产生任何开销。</p><p id="aaf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果服务器因这种方法而过载，负载平衡器不会停止向该服务器发送新请求。为了解决这个问题，可以开发一种更加智能的负载平衡器解决方案，根据负载定期调整流量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/f98104b68ce67e3df25c3adcf32a8023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jlkbjZMeO_SqXGC6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="751b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设计Instagram</h1><h2 id="70bc" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">Instagram是什么？</h2><p id="2cd3" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">Instagram是一个社交媒体平台，允许用户与其他用户分享照片和视频。像许多其他社交媒体平台一样，用户可以公开或私下分享他们的信息。</p><p id="da15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我们将设计一个简单版本的Instagram，用户可以在其中分享照片，关注其他用户，并访问新闻。这包括用户关注的人的顶部照片。</p><h2 id="4163" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">需求和目标</h2><p id="07ab" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">在设计类似Instagram的应用程序时，需要考虑一些功能性和非功能性需求。</p><p id="00af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非功能性需求:</p><ul class=""><li id="bf27" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">服务应该是高度可用的。</li><li id="84d4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">对于新闻提要，系统可接受的延迟应该在200毫秒左右。</li><li id="2ffa" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">该系统应该是高度可靠的，这样系统中的任何照片或视频都不会丢失。</li></ul><p id="38fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">功能要求:</p><ul class=""><li id="71af" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">用户应该能够根据照片或视频标题进行搜索。</li><li id="5f1f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">用户应该能够上传，下载和查看照片和视频。</li><li id="6f48" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">用户应该能够跟随其他用户。</li><li id="24bc" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">该系统应该能够生成一个显示的新闻提要，其中包括用户关注的人的顶级照片和视频。</li></ul><p id="94c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些不会在这个项目范围内的事情是给照片添加标签，搜索带标签的照片，评论照片，标记用户等。</p><h2 id="0846" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">容量估计和限制</h2><ul class=""><li id="e808" class="lu lv it la b lb nu le nv lh oo ll op lp oq lt lz ma mb mc bi translated">假设我们有5亿用户，每天有100万活跃用户。</li><li id="513f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">每天200万张新照片，每秒23张新照片。</li><li id="5054" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">平均照片文件大小=&gt; 200KB</li><li id="62b2" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">一天的照片所需的总空间:</li></ul><p id="f911" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 2M * 200KB = &gt; 400 GB </em></p><ul class=""><li id="30dd" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">10年所需的总空间:</li></ul><p id="8b98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 400GB * 365(一年天数)* 10(年)～= 1425 TB</em></p><h2 id="249e" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">高级系统设计</h2><p id="332f" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">在高层次上，系统应该能够支持用户上传他们的媒体和其他用户能够查看照片。因此，我们的服务需要服务器来存储照片和视频，还需要另一个数据库服务器来存储媒体的元数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/893609d6852388de2799442899493d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVsKgg_jEdJeSdWP01NtxA.png"/></div></div></figure><h2 id="a0d1" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">数据库模式</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/c5b1a30dce7c61810943ca142a3b720b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9bo0cGx_mM9rOv34YERgw.png"/></div></div></figure><p id="976b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然我们可以采取一种简单的方法，将上面的模式存储在关系数据库管理系统(RDBMS)中，但是在使用关系数据库时会出现一些挑战——尤其是在扩展应用程序时。</p><p id="832b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以利用NoSQL数据库存储上面的模式和键值对。照片和视频的元数据将属于一个表，其中<code class="fe ok ol om oc b">key</code>将是<code class="fe ok ol om oc b">PhotoID</code>,<code class="fe ok ol om oc b">value</code>将是一个包含<code class="fe ok ol om oc b">PhotoLocation</code>、<code class="fe ok ol om oc b">UserLocation</code>、<code class="fe ok ol om oc b">CreationTimestamp</code>等的对象。</p><p id="aedb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用Apache Cassandra，一个宽列数据存储，来存储用户和照片之间的关系以及用户关注的人的列表。<code class="fe ok ol om oc b">UserPhoto</code>表的<code class="fe ok ol om oc b">key</code>将是<code class="fe ok ol om oc b">UserID</code>,<code class="fe ok ol om oc b">value</code>将是用户拥有的<code class="fe ok ol om oc b">PhotoIDs</code>的列表，它们将被存储在不同的列中。该模式类似于<code class="fe ok ol om oc b">UserFollow</code>表。</p><p id="834d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">照片和视频可以存储在分布式文件存储器，如HDFS。</p><h2 id="f14c" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">数据大小估计</h2><p id="a555" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">让我们估计一下将有多少数据进入每个表，以及10年内我们将需要多少总存储量。</p><p id="e346" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设每个<code class="fe ok ol om oc b">int</code>和<code class="fe ok ol om oc b">dateTime</code>都是四个字节，用户表中的每一行都是68个字节:</p><p id="e55e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> UserID (4字节)+ Name (20字节)+ Email (32字节)+ DateOfBirth (4字节)+ CreationDate (4字节)+ LastLogin (4字节)= 68字节</em></p><p id="36ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们有5亿用户，我们将需要32GB的总存储空间:</p><p id="1dca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 5亿* 68 ~= 32GB </em></p><p id="1ccf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">照片表中的每一行都是284字节:</p><p id="16a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> PhotoID (4字节)+ UserID (4字节)+ PhotoPath (256字节)+ PhotoLatitude (4字节)+photolongitude(4字节)+ UserLatitude (4字节)+ UserLongitude (4字节)+ CreationDate (4字节)= 284字节</em></p><p id="bbfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果每天上传200万张新照片，我们一天将需要0.5GB的存储空间:</p><p id="31f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 2M * 284字节~=每天0.5 GB</em></p><p id="b225" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">10年后，我们将需要1.88TB的存储。</p><p id="c5b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">UserFollow表中的每一行都由8个字节组成。如果我们有5亿个用户，每个用户平均关注500个用户，我们将需要1.82TB的存储用于用户下表:</p><p id="e522" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa"> 5亿用户* 500关注者* 8字节~= 1.82TB </em></p><p id="f5d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有表10年所需的总空间为3.7TB:</p><p id="8a4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oa">32GB+1.88 TB+1.82 TB ~ = 3.7 TB</em></p><h2 id="7684" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">组件设计</h2><p id="2a75" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">照片上传通常是一个缓慢的过程，因为它们会进入磁盘，而读取要快得多。上传用户将消耗所有可用的连接，因为这个过程非常慢。因此，当系统加载写入请求时，无法提供读取服务。为了解决这个瓶颈，我们可以将读取和写入分散到不同的服务器上，这样系统就不会过载。</p><p id="d9b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将使我们能够有效地优化每个操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/88da2a67ec72aa1d2427782f9dd9af37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGvPc6xTZrKmlIBRwuN7hw.png"/></div></div></figure><h2 id="e26d" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">可靠性和冗余</h2><p id="6780" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">因为应用强调可靠性，所以我们不能丢失任何文件。因此，我们将存储每张照片和视频的多个副本，这样即使一台服务器出现故障，系统也可以从副本服务器中检索媒体。</p><p id="859e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种设计将应用于我们架构的其他组件。我们将在系统中运行服务的多个副本，这样即使一个服务终止，系统也将保持运行。在系统中创建冗余允许我们在系统故障时创建备份。</p><h2 id="41cb" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">数据分片</h2><p id="ee82" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">元数据分片的一个可能方案是基于PhotoID进行分区。如果我们能先生成唯一的PhotoIDs，然后通过<code class="fe ok ol om oc b">PhotoID % 10</code>找到碎片号，上面的问题就解决了。在这种情况下，我们不需要为ShardID添加PhotoID，因为PhotoID本身在整个系统中是唯一的。</p><p id="7b20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如何才能生成PhotoIDs？在这里，我们不能在每个碎片中有一个自动递增的序列来定义PhotoID，因为我们需要首先知道PhotoID来找到它将被存储的碎片。一种解决方案是使用一个单独的数据库实例来生成自动递增的id。如果我们的PhotoID可以放入64位，我们可以定义一个只包含64位ID字段的表。因此，每当我们想要在系统中添加照片时，我们可以在这个表中插入一个新行，并将该ID作为新照片的PhotoID。</p><p id="59af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个生成密钥的数据库不会是一个单点故障吗？是的，会的。一种解决方法是定义两个这样的数据库，一个生成偶数编号的id，另一个生成奇数编号的id。对于MySQL，以下脚本可以定义这样的序列:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="357d" class="ni mr it oc b gy og oh l oi oj">KeyGeneratingServer1:<br/>auto-increment-increment = 2<br/>auto-increment-offset = 1<br/><br/>KeyGeneratingServer2:<br/>auto-increment-increment = 2<br/>auto-increment-offset = 2</span></pre><p id="0bdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在这两个数据库前放置一个负载平衡器，在它们之间进行循环调度，以应对停机时间。这两个服务器可能不同步，一个生成的密钥比另一个多，但这不会在我们的系统中引起任何问题。我们可以通过为用户、照片评论或系统中的其他对象定义单独的ID表来扩展这种设计。</p><h2 id="af37" class="ni mr it bd ms nj nk dn mw nl nm dp na lh nn no nc ll np nq ne lp nr ns ng nt bi translated">负载平衡</h2><p id="4111" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">这项服务需要一个大规模的照片传送系统，为全球用户提供数据。我们可以使用地理上分散的缓存服务器将内容推送到离用户更近的地方。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d7e9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">包扎</h1><p id="710d" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">干得好！现在，你应该很清楚如何设计一个像Instagram和TinyURL这样的应用程序了。其他好的应用程序包括Dropbox、Facebook Messenger、YouTube、优步后端、Twitter等等！通过真实世界的例子学习系统设计的行业标准，不仅在面试中，而且在工作中都会给你力量！</p><p id="8511" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了帮助您入门，我们编制了一份您应该了解的系统设计基础术语表:</p><ul class=""><li id="c89d" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">可扩展性(水平与垂直)</li><li id="69db" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">负载平衡</li><li id="e3ae" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">贮藏</li><li id="0442" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">数据划分</li><li id="5592" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">指数</li><li id="ccb6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">委托书</li><li id="2c22" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">冗余和复制</li><li id="e645" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">SQL与NoSQL</li><li id="4d8f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">一致散列法</li><li id="b481" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">长轮询vs. WebSockets vs .服务器发送事件</li><li id="2986" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">CAP定理</li><li id="7f1e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">系统设计模式(即工厂方法、观察者、构建者、状态等。)</li></ul><p id="4b3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快乐学习！</p></div></div>    
</body>
</html>