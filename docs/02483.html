<html>
<head>
<title>The Encyclopedia of Smart Contract Attacks and Vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合约攻击和漏洞百科全书</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-encyclopedia-of-smart-contract-attacks-vulnerabilities-dfc1129fdaac?source=collection_archive---------6-----------------------#2019-12-03">https://betterprogramming.pub/the-encyclopedia-of-smart-contract-attacks-vulnerabilities-dfc1129fdaac?source=collection_archive---------6-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a48" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探讨智能合约安全性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db7307ad78e11ac306a9cac9b849bf7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGC7G9jHlzp0EJVJSEWLFQ.png"/></div></div></figure><p id="03a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以太坊上的应用程序管理金融价值，使得安全性变得绝对重要。作为一项新生的实验性技术，智能合约肯定受到了不少攻击。</p><p id="5c6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了帮助防止进一步的攻击，我构建了一个几乎所有已知攻击和漏洞的列表。尽管此列表可能涵盖了已知的攻击，但仍会定期发现新的漏洞，因此，这应该只是您作为工程师研究智能合约安全性的开始。</p><p id="ab7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个列表也可以在<a class="ae lq" href="https://github.com/KadenZipfel/smart-contract-attack-vectors" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="03e2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">攻击</h1><p id="815a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在本节中，我们将了解可用于利用智能合约漏洞的已知攻击。</p><h2 id="668c" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">前端运行又名事务排序依赖</h2><p id="3c79" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Concordia大学认为抢先交易是“一个实体从优先获得关于即将进行的交易和交易的特许市场信息中受益的行为过程。”这种对市场未来事件的了解会导致剥削。</p><p id="cca9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，知道将发生对特定代币的非常大量的购买，不良行为者可以提前购买该代币，并在过大的购买订单提高价格时出售该代币以获利。</p><p id="8d11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">抢先攻击长期以来一直是金融市场的一个问题，由于区块链的透明性质，这个问题在加密货币市场再次出现。</p><p id="f724" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这个问题的解决方案因合同而异，因此很难防范。可能的解决方案包括批量交易和使用预提交方案(即允许用户稍后提交详细信息)。</p><h2 id="8454" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">带阻塞气体限制的DoS</h2><p id="0e56" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在以太坊区块链，所有的街区都有气体限制。阻塞气体限制的好处之一是它可以防止攻击者创建无限的事务循环，但是如果事务的气体使用量超过此限制，事务将会失败。这可能以几种不同的方式导致<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit" rel="noopener ugc nofollow" target="_blank"> DoS攻击</a>。</p><p id="b9e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">无界运营</strong></p><p id="6a19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">块气体限制可能是一个问题的情况是向一组地址发送资金。即使没有任何恶意，这也很容易出错。仅仅是因为有太多的用户需要支付，就可能使汽油限额达到最大，从而阻止交易成功。</p><p id="594e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种情况也可能导致攻击。假设一个坏人决定创建大量地址，每个地址从智能合同中获得少量资金。如果操作有效，事务可以被无限期地阻塞，甚至可能阻止进一步的事务通过。</p><p id="3d23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决这个问题的有效方法是在当前的推式支付系统上使用拉式支付系统。要做到这一点，将每笔支付分成自己的交易，并让收款人调用该函数。</p><p id="9e23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果出于某种原因，您真的需要遍历一个长度不确定的数组，至少要预计到它可能会占用多个块，并允许它在多个事务中执行，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-block-gas-limit" rel="noopener ugc nofollow" target="_blank"> Consensys </a>的示例</p></figure><p id="f17e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">块馅</strong></p><p id="af61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在某些情况下，您的契约可能会受到block gas限制的攻击，即使您没有遍历未指定长度的数组。攻击者可以通过使用足够高的天然气价格来填充几个区块，然后才能处理交易。</p><p id="4857" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种攻击是通过以非常高的气价发布几笔交易来完成的。如果天然气价格足够高，并且交易消耗足够多的天然气，它们可以填满整个街区，并阻止其他交易被处理。</p><p id="cf6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以太坊交易要求发送者支付汽油以阻止垃圾邮件攻击，但在某些情况下，可能有足够的动机进行这种攻击。例如，在赌博Dapp fomo 3d上使用了块填充攻击。该应用程序有一个倒计时定时器，用户可以通过最后一个购买钥匙来赢得头奖——只是每次用户购买钥匙时，定时器都会延长。一名攻击者买了一把钥匙，然后连续填满接下来的13个街区，这样他们就可以赢得头奖。</p><p id="f298" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了防止这种攻击的发生，仔细考虑在应用程序中加入基于时间的操作是否安全是很重要的。</p><h2 id="1d1a" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">带有(意外)恢复的DoS</h2><p id="108e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当您试图向用户发送资金时，函数中可能会发生DoS(拒绝服务)攻击，而该功能依赖于资金转账的成功。</p><p id="52d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在资金被发送到由不良行为者创建的智能合同的情况下，这可能是有问题的，因为他们可以简单地创建退回所有付款的回退功能。</p><p id="9565" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert" rel="noopener ugc nofollow" target="_blank">议会</a>的例子</p></figure><p id="4580" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您在本例中所看到的，如果攻击者从一个具有回退功能的智能合同中出价，将永远无法退还所有付款，因此，没有人能够出价更高。</p><p id="ec1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有攻击者在场，这也是有问题的。例如，您可能希望通过遍历数组向一组用户付费，当然，您希望确保每个用户都得到适当的付费。这里的问题是，如果一次支付失败，该功能被还原，没有人支付。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert" rel="noopener ugc nofollow" target="_blank">议会</a>的例子</p></figure><p id="e320" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决这个问题的有效方法是在当前的推式支付系统上使用拉式支付系统。要做到这一点，将每笔支付分成自己的交易，并让收款人调用该函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert" rel="noopener ugc nofollow" target="_blank">议会</a>的例子</p></figure><h2 id="dccd" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">强行发送以太合同</h2><p id="0905" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">有时，用户不希望发送以太网到智能合同。不幸的是，在这种情况下，有可能绕过合同回退功能，强行发送以太网。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#forcibly-sending-ether-to-a-contract" rel="noopener ugc nofollow" target="_blank"> Consensys </a>的示例</p></figure><p id="4de8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然看起来任何易受攻击的契约的事务都应该被恢复，但实际上有几种方法可以强制发送以太网。</p><p id="5245" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一种方法是在将易受攻击的契约地址设置为受益人的契约上调用<code class="fe nn no np nq b">selfdestruct</code>方法。这是因为<code class="fe nn no np nq b">selfdestruct</code>不会触发回退功能。</p><p id="0dd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种方法是预先计算契约的地址，并在契约部署之前将以太网发送到该地址。令人惊讶的是，这是可能的。</p><h2 id="7513" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">气体净化不足</h2><p id="a163" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Griefing是视频游戏中经常出现的一种攻击类型，恶意用户以一种非故意的方式玩游戏来打扰其他玩家，也称为trolling。这种类型的攻击也用于阻止交易按预期执行。</p><p id="5774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种攻击可以在接受数据并在另一个契约的子调用中使用数据的契约上进行。这种方法常用于多重签名钱包和交易中继器。如果subcall失败，要么整个事务被还原，要么继续执行。</p><p id="9819" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以一个简单的延期合同为例。如下所示，relayer契约允许某人在不执行交易的情况下进行和签署交易。这通常在用户不能支付与交易相关的汽油费用时使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing" rel="noopener ugc nofollow" target="_blank"> Consensys </a>的示例</p></figure><p id="6622" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行事务的用户，<em class="nr">转发器，</em>可以通过使用刚好足够事务执行的gas，而不是足够subcall成功的gas，来有效地审查事务。</p><p id="c07c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有两种方法可以防止这种情况。第一种解决方案是只允许可信用户中继交易。另一个解决方案是要求货代提供足够的气体，如下图所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing" rel="noopener ugc nofollow" target="_blank"> Consensys </a>的示例</p></figure><h2 id="576e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">可重入</h2><p id="2b56" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">可重入是一种攻击，当契约函数中的一个bug允许一个函数交互进行多次时，这种攻击就会发生。如果被恶意使用，这可以用来从智能合约中榨干资金。事实上，可重入性是DAO hack中使用的攻击媒介。</p><p id="277b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">单功能重入</strong></p><p id="01f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当易受攻击的函数与攻击者试图递归调用的函数相同时，就会发生单函数可重入攻击。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy" rel="noopener ugc nofollow" target="_blank"> Consensys </a>的示例</p></figure><p id="f90e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们可以看到余额仅在资金转移后才被修改。这使得黑客可以在余额被设置为0之前多次调用该函数，从而有效地耗尽智能合约。</p><p id="2ad4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">跨函数重入</strong></p><p id="41d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">跨功能重入攻击是同一过程的更复杂版本。当易受攻击的函数与攻击者可以利用的函数共享一个状态时，就会发生跨函数可重入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy" rel="noopener ugc nofollow" target="_blank"> Consensys </a>的示例</p></figure><p id="1dfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，黑客可以通过调用回退函数<code class="fe nn no np nq b">transfer()</code>来利用这个契约，在<code class="fe nn no np nq b">withdraw()</code>函数中的余额被设置为0之前转移花费的资金。</p><p id="47b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">防止重入</strong></p><p id="b851" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在智能合约中转移资金时，使用<code class="fe nn no np nq b">send</code>或<code class="fe nn no np nq b">transfer</code>而不是<code class="fe nn no np nq b">call</code>。使用<code class="fe nn no np nq b">call</code>的问题与其他函数不同，它没有2300的气体限制。这意味着<code class="fe nn no np nq b">call</code>可以在外部函数调用中使用，可以用来执行可重入攻击。</p><p id="4b51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个可靠的预防方法是<em class="nr">标记不可信的函数</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy" rel="noopener ugc nofollow" target="_blank">议会</a>的例子</p></figure><p id="9139" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，为了获得最佳安全性，请使用<em class="nr">检查-效果-交互模式</em>。这是订购智能合约功能的简单经验法则。</p><p id="7cb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数应以<em class="nr">检查开始，例如<code class="fe nn no np nq b">require</code>和<code class="fe nn no np nq b">assert</code>语句。</em></p><p id="8940" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，应该执行契约的<em class="nr">效果</em>——例如，状态修改。</p><p id="f17d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们可以执行与其他智能契约的<em class="nr">交互</em>——例如，外部函数调用。</p><p id="2c9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种结构对于可重入性是有效的，因为契约的修改状态将防止不良参与者执行恶意的交互。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy" rel="noopener ugc nofollow" target="_blank"> Consensys </a>的示例</p></figure><p id="3e62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为在执行任何交互之前余额被设置为0，所以如果递归调用契约，那么在第一个事务之后就没有什么要发送的了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="86e3" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">脆弱点</h1><p id="2d5c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在本节中，我们将了解已知的智能合约漏洞以及如何避免这些漏洞。这里列出的几乎所有漏洞都可以在<a class="ae lq" href="https://swcregistry.io/" rel="noopener ugc nofollow" target="_blank">智能合同弱点分类</a>中找到。</p><h2 id="69b5" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">整数溢出和下溢</h2><p id="ac96" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在solidity中，整型有最大值。例如:</p><p id="6b6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">uint8</code> = &gt; 255</p><p id="8a51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">65535</p><p id="db36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">uint24</code> = &gt; 16777215</p><p id="48a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nn no np nq b">uint256</code> = &gt; (2^256) - 1</p><p id="3545" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当超过最大值(溢出)或低于最小值(下溢)时，可能会出现上溢和下溢错误。当你超过最大值时，你回到零，当你低于最小值时，你回到最大值。</p><p id="f560" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为较小的整数类型——如<code class="fe nn no np nq b">uint8</code>、<code class="fe nn no np nq b">uint16</code>等。—最大值越小，越容易导致溢出；因此，应该更加谨慎地使用它们。</p><p id="3229" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很可能，解决溢出和下溢错误的最佳方案是在执行数学运算时使用<a class="ae lq" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin SafeMath库</a>。</p><h2 id="6fcd" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">时间戳依赖性</h2><p id="cab2" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">由<code class="fe nn no np nq b">now</code>或<code class="fe nn no np nq b">block.timestamp</code>访问的块的时间戳可以由挖掘器操作。当使用时间戳执行契约函数时，有三个需要考虑的事项。</p><p id="9881" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">时间戳操作</strong></p><p id="6c47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果试图使用时间戳来产生随机性，矿工可以在块验证的15秒内发布时间戳，使他们能够将时间戳设置为一个值，以增加他们从该函数中受益的几率。</p><p id="4a69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，彩票应用可以使用块时间戳来挑选一组中的随机投标人。矿工可以参加抽奖，然后将时间戳修改为给他们赢得抽奖的更大几率的值。</p><p id="c75e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，时间戳不应被用来制造随机性。</p><p id="dce7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">15秒规则</strong></p><p id="f496" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以太坊的参考规范“黄皮书”没有规定多少数据块可以随时间变化的限制，它必须大于其父数据块的时间戳。也就是说，流行的协议实现拒绝未来时间戳超过15秒的块，所以只要您的时间相关事件可以安全地变化15秒，使用块时间戳是安全的。</p><p id="27c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">不要使用</strong> <code class="fe nn no np nq b">block.number</code> <strong class="kw iu">作为时间戳</strong></p><p id="b03a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用<code class="fe nn no np nq b">block.number</code>和平均阻塞时间来估计事件之间的时间差。但是阻塞时间可能会改变和破坏功能，所以最好避免这种使用。</p><h2 id="3f2c" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">通过tx.origin授权</h2><p id="a56c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><code class="fe nn no np nq b">tx.origin</code>是Solidity中的一个全局变量，它返回发送事务的地址。务必不要使用<code class="fe nn no np nq b">tx.origin</code>进行授权，因为其他合同可以使用回退功能调用您的合同并获得授权，因为授权地址存储在<code class="fe nn no np nq b">tx.origin</code>中。考虑这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin" rel="noopener ugc nofollow" target="_blank">实体文件</a>的示例</p></figure><p id="c9a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们可以看到<code class="fe nn no np nq b">TxUserWallet</code>合同用<code class="fe nn no np nq b">tx.origin</code>授权<code class="fe nn no np nq b">transferTo()</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae lq" href="https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin" rel="noopener ugc nofollow" target="_blank">实体文件</a>的示例</p></figure><p id="b3e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果有人欺骗你发送以太网到<code class="fe nn no np nq b">TxAttackWallet</code>合同地址，他们可以通过检查<code class="fe nn no np nq b">tx.origin</code>找到发送交易的地址来窃取你的资金。</p><p id="b503" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了防止这种攻击，使用<code class="fe nn no np nq b">msg.sender</code>进行授权。</p><h2 id="b753" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">浮动杂注</h2><p id="8e53" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">选择一个编译器版本并坚持使用它被认为是最佳实践。使用浮动pragma，可能会意外地使用过时或有问题的编译器版本部署协定，这可能会导致错误，使您的智能协定的安全性处于危险之中。对于开源项目，pragma还会告诉开发人员应该使用哪个版本来部署您的合同。所选择的编译器版本应该经过彻底的测试，并考虑已知的错误。</p><p id="2724" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以接受使用浮动pragma的例外情况是库和包。否则，开发人员将需要手动更新pragma以在本地编译。</p><h2 id="15c4" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">功能默认可见性</h2><p id="505a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">函数可见性可以指定为公共、私有、内部或外部。重要的是要考虑哪种可见性最适合您的智能合同功能。</p><p id="6d5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多智能合同攻击是由于开发人员忘记或放弃使用可见性修饰符而引起的。默认情况下，该函数被设置为公共的，这可能会导致非预期的状态变化。</p><h2 id="cf35" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">过时的编译器版本</h2><p id="840c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">开发人员经常发现现有软件中的错误和漏洞，并进行修补。因此，尽可能使用最新的编译器版本很重要。在这里可以看到过去编译器版本的错误。</p><h2 id="48a3" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">未选中的调用-返回值</h2><p id="b93c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果未检查低级调用的返回值，则即使函数调用引发错误，执行也可能继续。这可能会导致意想不到的行为，并打破程序逻辑。调用失败甚至可能是由攻击者引起的，攻击者可能会进一步利用该应用程序。</p><p id="d382" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Solidity中，您可以使用低级别的呼叫，例如<code class="fe nn no np nq b">address.call()</code>、<code class="fe nn no np nq b">address.callcode()</code>、<code class="fe nn no np nq b">address.delegatecall()</code>、<code class="fe nn no np nq b">address.send()</code>，或者您可以使用合同呼叫，例如<code class="fe nn no np nq b">ExternalContract.doSomething()</code>。低级别的调用永远不会抛出异常——相反，如果遇到异常，它们将返回<code class="fe nn no np nq b">false</code>，而契约调用将自动抛出。</p><p id="20be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在使用低级调用的情况下，请确保检查返回值以处理可能失败的调用。</p><h2 id="3773" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">无保护的乙醚停药</h2><p id="8505" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果没有适当的访问控制，不良行为者可能会从合同中撤回部分或全部乙醚。这可能是由于错误命名了一个旨在作为构造函数的函数，从而使任何人都有权重新初始化协定。为了避免这个漏洞，只允许由那些被授权的人或者按照预期的方式来触发取款，并适当地命名您的构造函数。</p><h2 id="1c4e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">无保护自毁指令</h2><p id="f005" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在有<code class="fe nn no np nq b">selfdestruct</code>方法的合同中，如果缺少或没有足够的访问控制，恶意参与者可以自毁合同。重要的是要考虑自毁功能是否绝对必要。如果有必要，考虑使用多重授权来防止攻击。</p><p id="1446" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种攻击被用于<a class="ae lq" href="https://www.parity.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/" rel="noopener ugc nofollow" target="_blank">奇偶攻击</a>。一个匿名用户找到并利用了“库”智能合同中的一个漏洞，使自己成为合同所有者。攻击者随后开始自毁合同。导致资金被封在587个唯一钱包里，共持有513，774.16以太。</p><h2 id="b902" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">状态变量默认可见性</h2><p id="11c9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">开发人员显式声明函数可见性很常见，但声明变量可见性却不常见。状态变量可以有三个可见性标识符之一:<code class="fe nn no np nq b">public</code>、<code class="fe nn no np nq b">internal</code>或<code class="fe nn no np nq b">private</code>。幸运的是，变量的默认可见性是内部的，而不是公共的，但是即使您打算将一个变量声明为内部的，明确一点也很重要，这样就不会出现关于谁可以访问该变量的错误假设。</p><h2 id="8637" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">未初始化的存储指针</h2><p id="9b9a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">数据以<code class="fe nn no np nq b">storage</code>、<code class="fe nn no np nq b">memory</code>或<code class="fe nn no np nq b">calldata</code>的形式存储在EVM中。很重要的一点是，这两者被很好地理解并正确初始化。不正确地初始化数据存储指针，或者干脆不初始化它们，都可能导致契约漏洞。</p><p id="90bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从Solidity <code class="fe nn no np nq b">0.5.0</code>开始，未初始化的存储指针不再是一个问题，因为带有未初始化存储指针的契约将不再编译。尽管如此，理解在某些情况下应该使用什么样的存储指针仍然很重要。</p><h2 id="2558" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">断言违例</h2><p id="2efa" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在Solidity <code class="fe nn no np nq b">0.4.10</code>中，创建了以下函数:<code class="fe nn no np nq b">assert()</code>、<code class="fe nn no np nq b">require()</code>和<code class="fe nn no np nq b">revert()</code>。在这里，我们将讨论assert函数以及如何使用它。</p><p id="2f02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正式地说，<code class="fe nn no np nq b">assert()</code>函数意味着断言不变量；非正式地说，<code class="fe nn no np nq b">assert()</code>是一个过分自信的保镖，保护你的合同，但在这个过程中偷走你的汽油。正常运行的契约永远不会到达失败的断言语句。如果您到达了一个失败的assert语句，您要么没有正确使用<code class="fe nn no np nq b">assert()</code>,要么您的契约中有一个bug使其处于无效状态。</p><p id="9979" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果在<code class="fe nn no np nq b">assert()</code>中检查的条件实际上不是一个不变量，建议你用一个<code class="fe nn no np nq b">require()</code>语句替换它。</p><h2 id="2b4a" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">使用不推荐使用的功能</h2><p id="7a0c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">随着时间的推移，Solidity中的函数被弃用，往往被更好的函数所取代。不要使用不推荐使用的函数，这很重要，因为这可能会导致意想不到的效果和编译错误。</p><p id="a6f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个不推荐使用的函数和替代函数的列表。许多替代方法都是简单的别名，如果用来替代已被否决的对应方法，不会破坏当前的行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9ee2c737eee68d67b32d4960bd919989.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*zfZ9LcXxdbE-I_qDOStqDg.png"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">弃用的函数和替代函数</p></figure><h2 id="558e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">向不受信任的被呼叫者委派呼叫</h2><p id="ae04" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><code class="fe nn no np nq b">Delegatecall</code>是消息调用的特殊变体。除了目标地址在调用契约的上下文中执行，并且<code class="fe nn no np nq b">msg.sender</code>和<code class="fe nn no np nq b">msg.value</code>保持不变之外，它几乎与常规消息调用相同。本质上，<code class="fe nn no np nq b">delegatecall</code>委托其他契约来修改调用契约的存储。</p><p id="e22d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe nn no np nq b">delegatecall</code>给了合同如此多的控制权，所以只对可信的合同使用它是非常重要的，比如你自己的合同。如果目标地址来自用户输入，请确保验证它是一个受信任的契约。</p><h2 id="c018" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">签名延展性</h2><p id="2ed4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">通常，人们认为在智能合同中使用加密签名系统可以验证签名的唯一性；然而，事实并非如此。以太坊中的签名可以在没有私钥的情况下被修改并保持有效。例如，椭圆密钥加密包含三个变量— <em class="nr"> v </em>、<em class="nr"> r </em>和<em class="nr"> s — </em>，如果以正确的方式修改这些值，您可以使用无效的私钥获得有效的签名。</p><p id="07ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了避免签名延展性的问题，永远不要在已签名的消息哈希中使用签名来检查以前签名的消息是否已被契约处理，因为恶意用户可以找到您的签名并重新创建它。</p><h2 id="418f" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">不正确的构造函数名</h2><p id="10c0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在Solidity <code class="fe nn no np nq b">0.4.22</code>之前，定义构造函数的唯一方法是用契约名创建一个函数。在某些情况下，这是有问题的。例如，如果一个智能协定以不同的名称重用，但构造函数没有改变，那么它只是一个常规的可调用函数。</p><p id="3afd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在有了现代版本的Solidity，您可以用<code class="fe nn no np nq b">constructor</code>关键字定义构造函数，有效地消除了这个漏洞。因此，这个问题的解决方案就是使用现代的Solidity编译器版本。</p><h2 id="71c9" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">隐藏状态变量</h2><p id="45d4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在坚固性中可能会使用同一个变量两次，但这可能会导致意想不到的副作用。这对于处理多个合同来说尤其困难。举以下例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">隐藏状态变量的示例</p></figure><p id="221a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们可以看到<code class="fe nn no np nq b">SubContract</code>继承了<code class="fe nn no np nq b">SuperContract</code>，变量<code class="fe nn no np nq b">a</code>被定义了两次不同的值。现在，假设我们使用<code class="fe nn no np nq b">a</code>来执行<code class="fe nn no np nq b">SubContract</code>中的一些功能。从<code class="fe nn no np nq b">SuperContract</code>继承的功能将不再工作，因为<code class="fe nn no np nq b">a</code>的值已被修改。</p><p id="1bd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了避免这种漏洞，我们必须检查整个智能合约系统的模糊性。检查编译器警告也很重要，因为只要它们在智能契约中，它们就可以标记这些歧义。</p><h2 id="0384" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">来自链属性的随机性的弱来源</h2><p id="b2f8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在以太坊中，有一些应用程序依赖随机数生成来保证公平性。然而，在以太坊中随机数的生成非常困难，有几个陷阱值得考虑。</p><p id="32a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用像<code class="fe nn no np nq b">block.timestamp</code>、<code class="fe nn no np nq b">blockhash</code>和<code class="fe nn no np nq b">block.difficulty</code>这样的链属性似乎是一个好主意，因为它们经常产生伪随机值。然而，问题在于矿工修改这些值的能力。例如，在一个累积奖金数百万美元的赌博应用程序中，矿工有足够的动机生成许多可供选择的区块，只选择将为矿工带来累积奖金的区块。当然，像那样控制区块链是要付出很大代价的，但是如果赌注足够大，这肯定是可以做到的。</p><p id="8ca8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了避免在随机数生成中进行挖掘操作，有一些解决方案:</p><ul class=""><li id="fdbb" class="nt nu it kw b kx ky la lb ld nv lh nw ll nx lp ny nz oa ob bi translated">承诺方案，如RANDAO，一种由DAO中的所有参与者生成随机数的DAO</li><li id="61fc" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">通过oracles获得外部资源—例如，Oraclize</li><li id="dba0" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">使用比特币区块哈希，因为网络更加分散，区块开采成本更高</li></ul><h2 id="c52d" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">缺少对签名重放攻击的保护</h2><p id="325b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">有时在智能合同中，有必要执行签名验证以提高可用性和汽油成本。但是，在实现签名验证时需要考虑。</p><p id="229e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了防止签名重放攻击，契约应该只允许处理新的散列。这可以防止恶意用户多次重放另一个用户的签名。</p><p id="4626" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使签名验证更加安全，请遵循以下建议:</p><ul class=""><li id="aa7e" class="nt nu it kw b kx ky la lb ld nv lh nw ll nx lp ny nz oa ob bi translated">存储由契约处理的每个消息散列，然后在执行该函数之前对照现有消息散列检查消息散列</li><li id="ad36" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在哈希中包含协定的地址，以确保消息仅在单个协定中使用</li><li id="2be6" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">永远不要生成包含签名的消息哈希。参见“签名延展性”</li></ul><h2 id="1377" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">需求违反</h2><p id="2c0b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><code class="fe nn no np nq b">require()</code>方法旨在验证条件，比如输入或契约状态变量，或者验证外部契约调用的返回值。为了验证外部调用，输入可以由调用者提供，也可以由被调用者返回。如果被调用方的返回值违反了输入，可能是以下两种情况之一出错:</p><ul class=""><li id="3e9d" class="nt nu it kw b kx ky la lb ld nv lh nw ll nx lp ny nz oa ob bi translated">提供输入的合同中有一个错误。</li><li id="bf6a" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">要求条件太强。</li></ul><p id="74f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要解决这个问题，首先要考虑需求条件是否太强。如有必要，削弱它以允许任何有效的外部输入。如果问题不是需求条件，那么在提供外部输入的契约中一定有一个bug。确保此合同不提供无效输入。</p><h2 id="1f54" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">写入任意存储位置</h2><p id="1d61" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">只有经过授权的地址才有权写入敏感存储位置。如果在整个合同中没有适当的授权检查，恶意用户可能会覆盖敏感数据。然而，即使存在对写入敏感数据的授权检查，攻击者仍然能够通过不敏感数据覆盖敏感数据。这可能使攻击者能够覆盖重要的变量，如合同所有者。</p><p id="375a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了防止这种情况发生，我们不仅希望通过授权需求来保护敏感数据存储，还希望确保对一个数据结构的写入不会无意中覆盖另一个数据结构的条目。</p><h2 id="179e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">不正确的继承顺序</h2><p id="c8ab" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在可靠性中，可以从多个来源继承，如果没有正确理解，可能会引入模糊性。这种模糊性被称为<em class="nr">钻石问题:</em>如果两个基础契约具有相同的功能，应该优先考虑哪一个？幸运的是，Solidity很好地处理了这个问题——只要开发人员理解解决方案。</p><p id="d552" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Solidity为菱形问题提供的解决方案是使用反向C3线性化。这意味着它将从右到左线性化继承，因此继承的顺序很重要。建议从更一般的合同开始，以更具体的合同结束，以避免出现问题。</p><h2 id="e77d" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">函数型变量的任意跳转</h2><p id="8617" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Solidity支持函数类型。这意味着function类型的变量可以分配给具有匹配签名的函数。然后，可以像调用任何其他函数一样，从变量中调用该函数。用户不应该能够改变函数变量，但在某些情况下，这是可能的。</p><p id="fb76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果智能合约使用某些汇编指令，例如，<code class="fe nn no np nq b">mstore</code>，攻击者可能能够将函数变量指向任何其他函数。这可能使攻击者能够破坏合同的功能，甚至可能耗尽合同资金。</p><p id="37ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于内联汇编是一种在低级别访问EVM的方式，它绕过了许多重要的安全功能。因此，重要的是，只有在必要和正确理解的情况下才使用汇编。</p><h2 id="a834" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">存在未使用的变量</h2><p id="ece9" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">尽管这是允许的，但最好避免使用未使用的变量。未使用的变量会导致一些不同的问题:</p><ul class=""><li id="b9f4" class="nt nu it kw b kx ky la lb ld nv lh nw ll nx lp ny nz oa ob bi translated">计算量增加(不必要的气体消耗)</li><li id="d1dd" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">错误或畸形数据结构的指示</li><li id="144c" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">降低代码可读性</li></ul><p id="c481" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">强烈建议从代码库中移除所有未使用的变量。</p><h2 id="40e2" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">意外的乙醚平衡</h2><p id="cbcc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">因为总是有可能向契约发送以太网—请参见“强制向智能契约发送以太网”—如果一个契约假定了特定的平衡，它就容易受到攻击。</p><p id="c64c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有一个契约，如果契约中存储了任何以太，它将阻止所有函数的执行。如果恶意用户决定通过强制发送以太网来利用这一点，他们将导致DoS，使合同不可用。由于这个原因，永远不要对契约中的平衡使用严格的等式检查是很重要的。</p><h2 id="353b" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">未加密的秘密</h2><p id="0994" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">以太坊智能合约码随时可以读取。照此处理。即使您的代码没有在Etherscan上验证，攻击者仍然可以反编译，甚至只是检查进出它的事务来分析它。</p><p id="5439" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的一个问题的例子是有一个猜谜游戏，用户必须猜一个存储的私有变量来赢得契约中的以太。当然，利用这一点是非常微不足道的(你不应该尝试，因为它几乎肯定是一个更加棘手的蜜罐合同)。</p><p id="e1c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的另一个常见问题是在Oracle调用中使用未加密的外链秘密，比如API密钥。如果可以确定您的API密钥，恶意行为者可以简单地为自己使用它，或者利用其他途径，例如耗尽您允许的API调用并迫使Oracle返回错误页面，这可能会也可能不会导致问题，具体取决于合同的结构。</p><h2 id="069e" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">错误合同检测</h2><p id="3f10" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">有些契约不希望其他契约与之交互。防止这种情况的常见方法是检查调用帐户中是否存储了任何代码。然而，在构造期间发起调用的契约帐户还不会显示它们存储了代码，从而有效地绕过了契约检测。</p><h2 id="a81b" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">畅通的区块链信实公司</h2><p id="92a3" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">许多合约依赖于在一定时间内发生的呼叫，但以太坊可以在相当长的时间内以相当低的成本被垃圾邮件发送非常高的Gwei交易。</p><p id="4ebf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，Fomo3D(一种倒数游戏，其中最后一个投资者赢得头奖，但每次投资都会给倒数计时增加时间)被一个用户赢得，该用户在一小段时间内完全阻塞了区块链，不允许其他人投资，直到计时器超时，他才获胜(见“阻塞气体限制的DoS”)。</p><p id="132f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在有许多赌台管理员赌博合同依靠过去的区块散列来提供RNG。这在很大程度上并不是一个可怕的RNG来源，它们甚至解释了在256个块之后发生的哈希修剪。但在那个时候，他们中的许多人干脆放弃了赌注。这将允许某人在许多这些功能相似的合同上下注，并以一定的结果作为他们所有人的赢家，检查赌台管理员的提交，如果它仍然待定，则简单地阻塞区块链，直到修剪发生，他们可以获得他们的赌注回报。</p><h2 id="7aee" class="mv lz it bd ma mw mx dn me my mz dp mi ld na nb mk lh nc nd mm ll ne nf mo ng bi translated">与标准不一致</h2><p id="801b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">就智能合约开发而言，遵循标准很重要。标准是为了防止漏洞而设置的，忽略它们会导致意想不到的后果。</p><p id="a1a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以币安最初的BNB代币为例。它作为一种ERC20令牌进行营销，但后来有人指出它实际上并不符合ERC-20，原因如下:</p><ul class=""><li id="1569" class="nt nu it kw b kx ky la lb ld nv lh nw ll nx lp ny nz oa ob bi translated">它阻止发送到0x0</li><li id="82f0" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">它阻止了0值的转移</li><li id="0cd5" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">它没有为成功或失败返回真或假</li></ul><p id="7732" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">担心这种不正确实现的主要原因是，如果它用于需要ERC-20令牌的智能契约，它会以意想不到的方式运行。它甚至可能永远被锁定在合同中。</p><p id="eda5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管标准并不总是完美的，而且有一天可能会过时，但它们会促成最安全的智能合约。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5613" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="163e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如您所见，有许多方法可以利用您的智能合约。在构建之前，充分了解每个攻击媒介和漏洞至关重要。</p><p id="5f3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">特别感谢<a class="ae lq" href="https://github.com/RobertMCForster" rel="noopener ugc nofollow" target="_blank"> RobertMCForster </a>的诸多优秀贡献。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b09c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">进一步阅读</h1><ul class=""><li id="189c" class="nt nu it kw b kx mq la mr ld oh lh oi ll oj lp ny nz oa ob bi translated">https://github.com/ethereum/wiki/wiki/Safety<a class="ae lq" href="https://github.com/ethereum/wiki/wiki/Safety" rel="noopener ugc nofollow" target="_blank"/></li><li id="4cea" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">【https://swcregistry.io/ T4】</li><li id="7d12" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated"><a class="ae lq" href="https://eprint.iacr.org/2016/1007.pdf" rel="noopener ugc nofollow" target="_blank">https://eprint.iacr.org/2016/1007.pdf</a></li><li id="1419" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated"><a class="ae lq" href="https://www.dasp.co/" rel="noopener ugc nofollow" target="_blank">https://www.dasp.co/</a></li><li id="98d7" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated"><a class="ae lq" href="https://consensys.github.io/smart-contract-best-practices/" rel="noopener ugc nofollow" target="_blank">https://consensys.github.io/smart-contract-best-practices/</a></li><li id="dce8" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated"><a class="ae lq" href="https://github.com/sigp/solidity-security-blog" rel="noopener ugc nofollow" target="_blank">https://github.com/sigp/solidity-security-blog</a></li><li id="0778" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated"><a class="ae lq" href="https://solidity.readthedocs.io/en/latest/bugs.html" rel="noopener ugc nofollow" target="_blank">https://solidity.readthedocs.io/en/latest/bugs.html</a></li></ul></div></div>    
</body>
</html>