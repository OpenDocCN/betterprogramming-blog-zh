<html>
<head>
<title>Building Crypto Charity dApp for Crowdfunding Using Next.js, Solidity, IPFS, and Truffle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Next.js、Solidity、IPFS和Truffle为众筹建立加密慈善dApp</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-crypto-charity-dapp-for-crowdfunding-using-next-js-solidity-ipfs-and-truffle-6a7d75d81ead?source=collection_archive---------2-----------------------#2022-11-03">https://betterprogramming.pub/building-crypto-charity-dapp-for-crowdfunding-using-next-js-solidity-ipfs-and-truffle-6a7d75d81ead?source=collection_archive---------2-----------------------#2022-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立一个筹款活动，在MATIC中捐款，生成收据，并提取金额</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f6ab6caba8c33e8c609c64c64e60583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkxxhGfFnbDiQPfSI3Nylw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由Freepik上的<a class="ae ky" href="https://www.freepik.com/free-photo/crowdfunding-money-business-bulb-graphic-concept_18134060.htm#query=fundraising&amp;position=17&amp;from_view=search&amp;track=sph" rel="noopener ugc nofollow" target="_blank">rawpixel.com</a>拍摄</p></figure><p id="c6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们构建一个用于筹款的全栈web3应用程序。我们将使用Next.js、material-UI、cryptocompare(用于ETH-USD转换)、truffle、web3modal和OpenZeppelin契约来创建我们的Web3应用程序。</p><h2 id="94e0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能:</h2><ul class=""><li id="6274" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">发起筹款活动</li><li id="84d3" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">用户可以在MATIC中捐款</li><li id="497d" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">转换ETH-USD以避免捐赠错误</li><li id="d190" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">受益人可以提取捐赠的金额</li><li id="7acc" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">捐赠者可以查看最后的捐赠并生成收据</li></ul><p id="6270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的第一件事是克隆模板:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="f5a9" class="lv lw it nf b gy nj nk l nl nm">git clone <a class="ae ky" href="https://github.com/ac12644/Crypto-Charity.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ac12644/Crypto-Charity.git</a><br/>cd fundraiser<br/>yarn</span></pre><p id="9063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您需要为我们的合同创建新文件。首先，为我们的合同创建所有的空文件:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="8a44" class="lv lw it nf b gy nj nk l nl nm">touch contracts/FundraiserFactory.sol<br/>touch contracts/Fundraiser.sol</span></pre><p id="72e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要安装<code class="fe nn no np nf b">OpenZeppelin</code>,因为我们正在使用Ownable契约:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="7b31" class="lv lw it nf b gy nj nk l nl nm">yarn add @openzeppelin/contracts</span></pre><p id="9372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在<code class="fe nn no np nf b">Fundraiser.sol</code> <em class="nq"> </em>文件中，从OpenZeppelin导入<code class="fe nn no np nf b">Ownable</code>和<code class="fe nn no np nf b">SafeMath</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7b46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续我们的<code class="fe nn no np nf b">Fundraiser.sol</code>智能契约，让我们为捐赠定义一个结构:</p><p id="b5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Solidity中的结构允许我们创建新的数据类型。这些数据类型将具有不同类型的属性。例如，我们可以使用下面的代码来生成一个<code class="fe nn no np nf b">Donation</code>结构:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a167" class="lv lw it nf b gy nj nk l nl nm">struct Donation {<br/>  uint256 value;<br/>  uint256 date;<br/>}</span></pre><p id="b0b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射允许您将键与值相关联。要声明映射，您需要指定键和值的类型，如下所示:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="98f9" class="lv lw it nf b gy nj nk l nl nm">mapping(address =&gt; Donation[]) public _donations;</span></pre><p id="277f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种映射将地址与捐赠的动态数组相关联。如果我们想要访问个人捐赠者的捐赠，我们使用<code class="fe nn no np nf b">[ ]</code>符号:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a778" class="lv lw it nf b gy nj nk l nl nm">address donor = msg.sender;<br/>_donations[donor];</span></pre><p id="11cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将构造函数和状态变量添加到契约中。我们将保留收款人地址，以支付转账金额。地址将代表受益人和保管人。保管人的地址是与募捐者的经理相关联的地址。该地址不会收到任何资金，但将是允许进行更改和请求向受益人转移资金的地址。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ae10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果被所有者之外的任何人调用，函数<code class="fe nn no np nf b">setBeneficiary</code>将会失败。如果发件人是所有人，它将使用作为参数传入的地址更新受益人地址:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4540" class="lv lw it nf b gy nj nk l nl nm">function setBeneficiary(address payable _beneficiary) <br/>  public onlyOwner { beneficiary = _beneficiary; }</span></pre><p id="7dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将创建一个接受以太的<code class="fe nn no np nf b">donate</code>函数。为此，我们需要在函数声明中添加payable修饰符。当我们将以太发送给一个合同或EOA时，它们的余额会自动增加——我们不需要添加任何代码来产生这种行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建<code class="fe nn no np nf b">myDonationsCount</code>函数，该函数将返回发出请求的捐赠者的捐赠计数。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6b77" class="lv lw it nf b gy nj nk l nl nm">function myDonationsCount() public view returns (uint256) { <br/>  return _donations[msg.sender].length;<br/>}</span></pre><p id="0ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该创建<code class="fe nn no np nf b">myDonations</code>函数，将捐赠者的捐赠返回给募捐者。不幸的是，由于当前ABI的限制，不可能从外部或公共函数返回结构数组。因此，我们将不得不利用多个返回值和数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，定义撤销函数并使用<code class="fe nn no np nf b">onlyOwner</code>修饰符来限制访问并发出<code class="fe nn no np nf b">withdraw</code>事件。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="c38e" class="lv lw it nf b gy nj nk l nl nm">event Withdraw(uint256 amount);</span><span id="f034" class="lv lw it nf b gy nt nk l nl nm">function withdraw() public onlyOwner {<br/>  uint256 balance = address(this).balance;<br/>  beneficiary.transfer(balance);<br/>  emit Withdraw(balance);<br/>}</span></pre><p id="d868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免测试失败，我们必须包括一个可支付的回退功能。现在我们来补充一个:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="fe22" class="lv lw it nf b gy nj nk l nl nm">fallback() external payable {<br/>  totalDonations = totalDonations.add(msg.value);<br/>  donationsCount++;<br/>}</span></pre><p id="93aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的筹款合同准备好了。完成后，它将看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="9432" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">筹款工厂</h1><p id="74c6" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">以前的<code class="fe nn no np nf b">Fundraiser</code>合同充满了功能，但它不能用来创造任何东西。在这个契约中，我们将使用一个通用的设计模式来添加缺失的部分:工厂模式。</p><p id="24a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续我们的<code class="fe nn no np nf b">FundraiserFactory</code>契约，让我们在契约上设置一个新的状态变量来存储已经创建的筹资者。然后我们需要创建一个函数来检索集合的长度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们从表单中获取所有参数，然后使用<code class="fe nn no np nf b">createFundraiser</code>函数初始化一个新的募捐者，并发出一个事件，该事件将包括募捐者和所有者的地址:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="18da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一种向用户展示可用筹款人的方式。一种选择是检索在对我们的契约的单个调用中创建的所有筹资者，类似于我们对我们的<code class="fe nn no np nf b">Fundraiser</code>契约中的<code class="fe nn no np nf b">myDonations</code>函数所做的。当我们预计集合大小相对较小时，这种方法很好，但是如果我们的应用程序变得流行，我们将希望以更小的块加载这些数据。</p><p id="8614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管查看来自区块链的数据不需要任何成本(天然气)，但它仍然会使用EVM的资源。如果用户来到我们的应用程序，并立即看到他们想要的资金筹集者，我们会浪费很多资源。与等待单个请求返回所有项目相比，更小的块还可以使页面呈现得更快。</p><p id="9c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的集合大小将小于<code class="fe nn no np nf b">fundraisersCount</code>或请求的限制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的合同准备好了。完成后，它将看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="395c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过运行以下命令在Polygon Mumbai上部署协定，在部署之前添加环境字段:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ae87" class="lv lw it nf b gy nj nk l nl nm">truffle deploy --network mumbai</span></pre><h2 id="e071" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">JavaScript函数</h2><p id="ecfd" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">在这一部分中，我们将在前端调用这些函数，以便您能够理解如何与部署的智能合约进行交互。</p><p id="39c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先添加创建新的资金筹集者所需的函数。移至<code class="fe nn no np nf b">src/views/Create/components/Form/Form.js</code>。</p><p id="98aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是通过元掩码初始化web3身份验证。为此，我们使用web3modal，然后我们连接我们部署的智能合同<code class="fe nn no np nf b">FundraiserFactory</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dd47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们上传图像时，我们需要创建一个IPFS客户端来上传文件，为此，我们使用Infura网关。你必须从Infura获得项目id、密钥和专用子域网关。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="442a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表单中的最后一步是创建submit函数，该函数将在多边形网络上创建一个募捐者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="50ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你把它们放在一起时，看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/5d5d9830005e883d4552800c659a034e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zB3mNCmQYau_hYEC.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">形式</p></figure><p id="de22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们可以生成一个新的筹款人，我们应该添加一个前端，以便筹款人出现在页面上，与其他任何筹款人一起创建。一旦我们有了显示募捐者的UI，我们就可以使用一个模态，这样用户就可以点击特定的募捐者并进行捐赠。然而，我们应该从展示募捐者的名单开始。</p><p id="066e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移动到<code class="fe nn no np nf b">src/views/Projects/Projects.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e3f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经从合同中收到了数据，我们将在前端向用户显示每张<code class="fe nn no np nf b">Fundraiser</code>卡。我们需要做的第一件事是创建一个新组件来显示我们的<code class="fe nn no np nf b">Card</code>组件:</p><p id="f37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移动到<code class="fe nn no np nf b">src/blocks/FundraiserCard/FundraiserCard.js</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c8b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，切换到<code class="fe nn no np nf b"><a class="ae ky" href="https://github.com/ac12644/fundraiser_dapp/blob/master/client/src/Home.js" rel="noopener ugc nofollow" target="_blank">Projects.js</a></code> <a class="ae ky" href="https://github.com/ac12644/fundraiser_dapp/blob/master/client/src/Home.js" rel="noopener ugc nofollow" target="_blank"> </a>文件，我们将遍历筹款人列表并显示每个筹款人的<code class="fe nn no np nf b">Card</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="8432" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">收尾工作</h1><h2 id="c2ff" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">添加每个募捐者的详细信息</h2><p id="3d0d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">复制以下代码，并将其添加到<code class="fe nn no np nf b">Projects.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a524d9a36f86d175be66f303b9212f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7tSbJYR8a676HS9I.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">筹款模式</p></figure><p id="01d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于GitHub回购，请访问<a class="ae ky" href="https://github.com/ac12644/Crypto-Charity.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ac12644/Crypto-Charity.git</a>。</p><p id="f786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><h1 id="ac63" class="nu lw it bd lx nv nw nx ma ny nz oa md jz ob ka mg kc oc kd mj kf od kg mm oe bi translated">想要更多吗？</h1><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/supply-chain-smart-contract-design-e0ae5071bcbe"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">设计供应链智能合约</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">简化农业供应链网络的运作</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>