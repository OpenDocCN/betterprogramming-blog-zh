<html>
<head>
<title>The Magic of Metaprogramming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">元编程的魔力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-magic-of-metaprogramming-732f0300a5c7?source=collection_archive---------4-----------------------#2019-08-04">https://betterprogramming.pub/the-magic-of-metaprogramming-732f0300a5c7?source=collection_archive---------4-----------------------#2019-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b495" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用抽象的魔法改造你的程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8041b3271258d535ac6aedbd2d648c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jvGT9Ic3XJ5DA8WPq6TUw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">莎拉·埃勒斯的照片</p></figure><p id="a8dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">技术与科学有着美好的关系。几十年的热情研究，忠实地遵循科学方法，已经产生了数字工具，任何以前的人类时代都会将其称为魔法。</p><p id="fb0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我也发现自己偶尔会被技术的明显魔力所迷惑。</p><p id="c899" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，在学习面向对象编程(OOP)时，我遇到了一个看似神奇的概念，叫做<em class="lr">元编程</em>。虽然元编程在某些语言中非常流行，但它可以用于抽象出几乎任何项目中的问题。</p><p id="abac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们讲解核心概念时，我将使用Ruby的例子，但是你可以在几乎任何编程语言中应用这些知识。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3e69" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">定义</h1><p id="6e38" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">首先，元编程是什么意思？</p><p id="25c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">前缀“meta”现在经常被抛出，而且经常是不正确的，所以我们必须为我们的讨论确定一个确切的定义。</p><p id="3590" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出于我们的目的，前缀“元”意味着<em class="lr">某种东西以一种完全自我参照的方式作用于世界</em>。</p><p id="0052" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，举例来说，元魔法是一个魔法作用于<em class="lr">魔法</em>的法术。元文本是讨论<em class="lr">文本</em>本身的文本。元程序是以编程方式作用于<em class="lr">程序</em>的程序。</p><p id="0c98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个简单的定义可以是:</p><blockquote class="mx"><p id="1708" class="my mz iq bd na nb nc nd ne nf ng lq dk translated">"元编程是为我们编写代码的实践."</p></blockquote></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2064" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">例子</h1><p id="dc86" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">Ruby编程语言允许重复的任务被简化和抽象。让我们来看一个用来使实例变量可访问的典型例子。</p><p id="6165" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们正在创建一个<code class="fe nh ni nj nk b">Wizard</code>班级来组织霍格沃茨所有的学生和老师。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bbed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，我们的代码缺少如何导航到这些数据的说明。任何试图读取关于向导<em class="lr">或</em>更新向导信息的尝试都会导致错误，因为计算机没有任何描述该过程的方法。</p><p id="6765" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要解决这个问题，可以在<code class="fe nh ni nj nk b">Wizard</code> <code class="fe nh ni nj nk b">class</code>中定义实例方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3844" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这个设置，我们就可以调用和更新任何特定巫师的房屋分配。</p><p id="708b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果我们保存20或30个实例变量，以及每个向导呢？代码会非常乏味和重复——增加出错的可能性和不必要的复杂性。</p><p id="c8c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用一点魔法一劳永逸地解决这个问题。</p><p id="8f35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了编写每个新的<code class="fe nh ni nj nk b">class</code>来为每个实例变量编写这些方法，我们必须在Ruby语言中前进一层，编写<code class="fe nh ni nj nk b">Class</code>类。</p><p id="8304" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Ruby中，关键字<code class="fe nh ni nj nk b">class</code>不仅仅是一个定义，也是一个表达式，用于评估<code class="fe nh ni nj nk b">class</code>的每个实例。因此，包含在<code class="fe nh ni nj nk b">Class</code>T3中的抽象方法可以在每个新实例上运行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9efb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果运行该文件，输出将是:</p><p id="b210" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nh ni nj nk b">Hello World!</code></p><p id="ee7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们现在有能力编写一个抽象的方法，在任何我们想要的类中为我们编写代码！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0206" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面应用的一些方法可以有一篇自己的文章，(<a class="ae ls" href="https://rubymonk.com/learning/books/2-metaprogramming-ruby/chapters/25-dynamic-methods/lessons/72-define-method" rel="noopener ugc nofollow" target="_blank">就像这个</a>)但是，幸运的是，它们对代码的描述足够清晰易懂。</p><p id="5ce5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是元编程真正令人兴奋的地方！</p><p id="8b00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在Ruby <code class="fe nh ni nj nk b">Class</code> <code class="fe nh ni nj nk b">class</code>有了我们的<code class="fe nh ni nj nk b">magically_write_my_code</code>方法，我们可以在任何新类上调用它来动态编写我们的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="94dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是魔法…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0b28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在已经成功地编写了为我们编写功能代码的代码！</p><p id="2f86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这是一个简单的例子，而且是一个已经用<code class="fe nh ni nj nk b">attr_accessor</code>、<code class="fe nh ni nj nk b">attr_writer</code>和<code class="fe nh ni nj nk b">attr_reader</code>宏为我们编写了的例子，但它展示了编写抽象代码的能力，这些代码可以在各种环境下为我们编写代码。</p><p id="f4df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们把这个新观点应用到另一个例子中。</p><p id="b7af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在一个<a class="ae ls" href="https://github.com/jollyjerr/Git_Forknite" rel="noopener ugc nofollow" target="_blank">项目</a>中，我和我的两个朋友正在创建一个小型多人CLI游戏，我们遇到了一个问题，即相对于仍然活着的玩家数量，如何渲染合适的屏幕。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/c008c7995ce82ff2f1ddba87410383a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Vj8jZWOK-e-OOjl1BCf0_A.gif"/></div></figure><p id="4c98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">忠于面向对象的设计模式，我们创建了一个<code class="fe nh ni nj nk b">Screen</code>类，并调用该类中的不同方法来呈现适当的屏幕。</p><p id="1c89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，<code class="fe nh ni nj nk b">Screen.three</code>将返回三个简笔画的图片，而<code class="fe nh ni nj nk b">Screen.five</code>将返回五个。然而，当玩家开始无序死亡时，麻烦就出现了。</p><p id="fe4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了编写灵活的代码，我们必须尝试元编程！</p><p id="479e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们开发了一种<code class="fe nh ni nj nk b">refresh_screen</code>方法来:</p><ol class=""><li id="c175" class="no np iq kx b ky kz lb lc le nq li nr lm ns lq nt nu nv nw bi translated">参考数据库，计算活着的玩家数量。</li><li id="5629" class="no np iq kx b ky nx lb ny le nz li oa lm ob lq nt nu nv nw bi translated"><code class="fe nh ni nj nk b"><a class="ae ls" href="https://apidock.com/ruby/Object/send" rel="noopener ugc nofollow" target="_blank">send</a></code>调用<code class="fe nh ni nj nk b">Screen</code>类以返回适当的屏幕。</li></ol><p id="0969" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，我们开发了一种方法来为我们动态元编程一行代码——它改变了我们的游戏。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="36e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了计算活着的玩家的数量，我们计算从数据库中选择的玩家数组中的元素，这些玩家的健康状态大于零。</p><p id="c4fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这条线<code class="fe nh ni nj nk b">Screen.send(numbers_to_name[number_of_players])</code>包含了一点点魔力。根据存活玩家的数量，<code class="fe nh ni nj nk b">refresh_screen</code>方法将返回不同的代码行。</p><p id="13f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这使得我们的<code class="fe nh ni nj nk b">refresh_screen</code>方法对活着的玩家数量完全是动态的，不管顺序如何，并且为程序创建了一个简单的方法来处理游戏中可能出现的不同情况。</p><p id="09d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管这是一个简单的真实例子，但它展示了让代码为您编写代码所提供的强大功能和灵活性！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ba71" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="4012" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">抽象、灵活性和逻辑自治都提供给了愿意投入元编码初始工作的程序员。</p><p id="20ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然本文关注的是简单的例子，但是许多复杂的系统都是基于这些概念开发的。</p><p id="4aca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae ls" href="https://queue.acm.org/detail.cfm?id=1394140" rel="noopener ugc nofollow" target="_blank">动态ORM的</a>、灵活的后端和<a class="ae ls" href="http://www-compsci.swan.ac.uk/~csphil/CS335/chapt5.pdf" rel="noopener ugc nofollow" target="_blank">加速的机器学习</a>都是通过元编程获得的，未来只会为能够围绕多样化输入构建程序的抽象系统看起来更光明。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/05e72dc91aefa09121785d949115d225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WSo2IFG7yU3ugy8B"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由Cory C拍摄。</p></figure><p id="533c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果没有别的，重要的是提醒我们自己编码从来都不是魔术。</p><p id="5eeb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当我们看到一个看似神奇的新概念时，我们可以慢慢地研究其内部工作，直到只剩下选择、迭代和数据操作。</p></div></div>    
</body>
</html>