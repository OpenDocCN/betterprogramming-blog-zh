<html>
<head>
<title>Building a Modern React App From Scratch in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在2021年从头开始构建一个现代的React应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-modern-react-app-from-scratch-in-2021-d2071c31c98?source=collection_archive---------6-----------------------#2021-02-24">https://betterprogramming.pub/building-a-modern-react-app-from-scratch-in-2021-d2071c31c98?source=collection_archive---------6-----------------------#2021-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ef2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步的教程，关于建立一个没有样板的现代React应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd4979b3a68250a80ab3e804f5dfb354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSnL10fjE0xUDUwaAgCseA.png"/></div></div></figure><p id="e54a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">➡️ <a class="ae lq" href="https://github.com/yakkomajuri/react-from-scratch#readme" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="lr">你可以在GitHub上访问整篇文章和所有相关代码。</em> </strong> </a></p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="42c6" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">动机</h1><p id="29d4" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">本教程的主要目的是让我自己更好地理解使React应用程序工作的多个移动部分，而不仅仅是接受那里许多模板/样板的“魔力”(例如<a class="ae lq" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>和<a class="ae lq" href="https://www.reactboilerplate.com/" rel="noopener ugc nofollow" target="_blank">React-样板</a>)。</p><p id="da81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它的灵感很大程度上来自于<a class="mw mx ep" href="https://medium.com/u/8de87b6cc577?source=post_page-----d2071c31c98--------------------------------" rel="noopener" target="_blank"> Jedai破坏者</a>写得非常好的<a class="ae lq" href="https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658" rel="noopener ugc nofollow" target="_blank">从头开始创建一个React应用程序</a>。这篇文章太好了，以至于在官方反应文件中被引用。</p><p id="8f0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，时代变了，我想在2021年从零开始建立一个现代的React应用程序。因此，我在工具链中增加了一些“要素”,并希望使用最新版本的核心库。在某些方面，我认为这是上面提到的教程的<code class="fe my mz na nb b">latest</code>版本。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="fbca" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">目标</h1><p id="dfc9" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我的目标很简单:从头开始构建一个React应用程序。这里的“从零开始”并不意味着自己构建支持工具，而是对它们的设置负责，而不是外包给像<code class="fe my mz na nb b">create-react-app</code>这样的东西。</p><p id="1496" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，除了设置一个能够正常工作的React应用程序之外，我还对许多人认为的现代堆栈的“本质”有一些要求:</p><ol class=""><li id="85f9" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">它必须支持TypeScript。</li><li id="234a" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">它应该从一开始就提供状态管理。</li></ol></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="50cb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">工具作业</h1><p id="6b4c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">那么我到底需要什么来让这个工作？</p><p id="fce9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了找到答案，我从React文档开始。</p><p id="9ead" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阅读<a class="ae lq" href="https://reactjs.org/docs/create-a-new-react-app.html#creating-a-toolchain-from-scratch" rel="noopener ugc nofollow" target="_blank">从头开始创建工具链</a>告诉我我需要什么:</p><blockquote class="nq nr ns"><p id="3403" class="ku kv lr kw b kx ky ju kz la lb jx lc nt le lf lg nu li lj lk nv lm ln lo lp im bi translated">“一个<strong class="kw iu">包管理器</strong>，比如Yarn或者npm。它让你可以利用第三方软件包的庞大生态系统，并轻松地安装或更新它们。</p><p id="0647" class="ku kv lr kw b kx ky ju kz la lb jx lc nt le lf lg nu li lj lk nv lm ln lo lp im bi translated">一个<strong class="kw iu">捆扎机</strong>，如网袋或包裹。它允许您编写模块化代码，并将其打包成小的包，以优化加载时间。</p><p id="24a0" class="ku kv lr kw b kx ky ju kz la lb jx lc nt le lf lg nu li lj lk nv lm ln lo lp im bi translated">一个<strong class="kw iu">编译器</strong>比如巴别塔。它允许您编写现代的JavaScript代码，这些代码仍然可以在旧的浏览器中工作。"</p></blockquote><p id="b322" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个简短的片段告诉了我很多关于我需要什么以及我为什么需要它的信息。所以我做出了选择:</p><ul class=""><li id="a94b" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nw ni nj nk bi translated">包装经理:<a class="ae lq" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank">纱线</a></li><li id="2ef0" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nw ni nj nk bi translated">捆绑者:<a class="ae lq" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">网络包</a></li><li id="11a7" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nw ni nj nk bi translated">编译器:<a class="ae lq" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a></li></ul><p id="23c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些都是非常标准的选择。即使你自己以前没有设置过这些，你也可能和它们打过交道，或者至少在某个时候听说过它们。</p><p id="db47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，基于我的要求，我还缺少一样东西:一个状态管理库。</p><p id="99f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redux 是最直接的选择，但是我选择了Kea 。Kea实际上是建立在 Redux之上的<em class="lr">，所以我将有效地使用Redux，但是它使状态管理变得更加容易。</em></p><p id="0b45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了充分披露，我肯定是有偏见的。选择Kea的原因很简单，我在工作中使用<a class="ae lq" href="https://github.com/PostHog/posthog" rel="noopener ugc nofollow" target="_blank"/>，它的<a class="ae lq" href="https://github.com/mariusandra" rel="noopener ugc nofollow" target="_blank">作者</a>是我的同事。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="deff" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">入门指南</h1><p id="c8e5" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们首先需要的是一个新的目录。设置好，然后在里面运行<code class="fe my mz na nb b">yarn init</code>就可以开始了。</p><p id="c3b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当它询问您“入口点”时，使用<code class="fe my mz na nb b">src/index.tsx</code>。你马上就会知道为什么了。</p><p id="23f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你的目录中，再创建两个:<code class="fe my mz na nb b">src</code>和<code class="fe my mz na nb b">public</code>。</p><p id="d56f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">src</code>将托管我们项目的全部源代码，而<code class="fe my mz na nb b">public</code>将是我们放置静态资产的地方。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="fdc0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">设置</h1><p id="6b37" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">这不是一个一刀切的教程，而是一个学习过程，处理出现的问题不可避免地是其中的一个重要部分。</p><p id="58a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我不会在安装上标记版本号。如果你想把它作为样板文件，你可以检查在<code class="fe my mz na nb b">package.json</code>中使用的版本。</p><p id="4311" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我决定在本教程中使用webpack v5，这带来了一些与我最初在webpack v4项目中使用的配置的兼容性问题。像往常一样，有了足够多的文档、文章和堆栈溢出帖子，我熬过来了，并在这个过程中学到了更多。</p><h2 id="026a" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">巴比伦式的城市</h2><p id="1f26" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让Babel工作需要相当多的软件包。您可以像这样安装它们:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="564f" class="nx ma it nb b gy on oo l op oq">yarn add --dev \<br/>  @babel/core \<br/>  @babel/cli \<br/>  @babel/preset-env \<br/>  @babel/preset-typescript \<br/>  @babel/preset-react</span></pre><p id="88ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编译器是我们需要的主要东西。</p><p id="9480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">babel-cli</code>将让我们通过CLI使用编译器。</p><p id="95e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">后三个包是处理各种用例的巴别塔“模板”(预置)。<code class="fe my mz na nb b">preset-env</code>是用来防止我们头疼的，允许我们写现代的JS，同时确保输出可以跨客户端工作。<code class="fe my mz na nb b">preset-typescript</code>和<code class="fe my mz na nb b">preset-react</code>是不言自明的:我们同时使用了TypeScript和React，所以我们会需要它们。</p><p id="d903" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们需要建立一个<code class="fe my mz na nb b">babel.config.js</code>文件，向编译器指定我们正在使用的预置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="f613" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">以打字打的文件</h2><p id="88bb" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们希望在我们的项目中使用TypeScript，这样它就有了自己的设置，超越了Babel预设。</p><p id="043b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要<code class="fe my mz na nb b">typescript</code>包:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="00cb" class="nx ma it nb b gy on oo l op oq">yarn add --dev typescript</span></pre><p id="9d38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，积极主动地，我建议你也得到下面的包，如果你将跟随这个教程直到结束的话:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="ec2d" class="nx ma it nb b gy on oo l op oq">yarn add --dev @types/react @types/react-dom @types/react-redux</span></pre><p id="b349" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些包包含我们将在整个项目中使用的模块的类型声明。</p><p id="5fa3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要一个<code class="fe my mz na nb b">tsconfig.json</code>文件。我使用的<a class="ae lq" href="https://github.com/PostHog/posthog.com/blob/master/tsconfig.json" rel="noopener ugc nofollow" target="_blank">是我们在生产中使用的PostHog中的配置</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="538a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请随意更改上面的一些配置，以更好地满足您的需求。但是，保留以下选项很重要:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="04ad" class="nx ma it nb b gy on oo l op oq">"noEmit": true, <br/>"jsx": "react",</span></pre><p id="b87b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">"jsx": "react"</code>不言自明。至于<code class="fe my mz na nb b">noEmit</code>，我们应该把它作为<code class="fe my mz na nb b">true</code>的原因是Babel正在为我们编译类型脚本，所以我们只是希望<code class="fe my mz na nb b">typescript</code>被用来检查错误(例如，当我们写代码的时候)。</p><p id="2d1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr">旁注:</em><a class="ae lq" href="https://github.com/Microsoft/TypeScript/pull/5450" rel="noopener ugc nofollow" target="_blank"><em class="lr"/></a><code class="fe my mz na nb b"><a class="ae lq" href="https://github.com/Microsoft/TypeScript/pull/5450" rel="noopener ugc nofollow" target="_blank"><em class="lr">tsconfig.json</em></a></code><a class="ae lq" href="https://github.com/Microsoft/TypeScript/pull/5450" rel="noopener ugc nofollow" target="_blank"><em class="lr">文件</em> </a> <em class="lr">中允许有注释。</em></p><h2 id="ceb5" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">网络包</h2><p id="d0ef" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">Webpack也需要很多东西才能工作。本质上，对于我们想要捆绑的每种类型的文件，我们都需要一个特定的加载器。</p><p id="7c23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们需要的是:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="66b8" class="nx ma it nb b gy on oo l op oq">yarn add --dev \<br/>    webpack \<br/>    webpack-cli \<br/>    webpack-dev-server \<br/>    style-loader \<br/>    css-loader \<br/>    babel-loader</span></pre><p id="81f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">webpack</code>和<code class="fe my mz na nb b">webpack-cli</code>遵循和巴别塔一样的原理。一个是核心包，另一个让我们可以从CLI访问这些工具。</p><p id="bdd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是我们当地发展所需要的。您会注意到<code class="fe my mz na nb b">package.json</code>实际上从未从脚本中引用过它，但它是运行<code class="fe my mz na nb b">webpack serve</code>所必需的:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="b64b" class="nx ma it nb b gy on oo l op oq">[webpack-cli] For using 'serve' command you need to install: 'webpack-dev-server' package</span></pre><p id="4bfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，加载程序是我们处理不同文件所需要的。一个<code class="fe my mz na nb b">ts-loader</code>也存在，但是因为我们使用Babel来编译我们的JS文件，我们实际上并不需要它。</p><p id="7c3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且，像巴别塔一样，我们需要一个<code class="fe my mz na nb b">webpack.config.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="4feb" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">反应</h2><p id="e3d8" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">鉴于这是一个React应用程序，我们也需要一些React包！</p><p id="ab47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这应该足够了:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="5d1d" class="nx ma it nb b gy on oo l op oq">yarn add react react-dom react-hot-loader</span></pre><p id="75b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">react</code>不言自明。<code class="fe my mz na nb b">react-dom</code>将用于在<code class="fe my mz na nb b">index.tsx</code>上渲染我们的app，<code class="fe my mz na nb b">react-hot-loader</code>用于开发。它会根据文件变化自动更新我们的应用程序。</p><h2 id="d746" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">Kea</h2><p id="1f27" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">最后，我们需要建立我们的国家管理图书馆Kea。</p><p id="e26c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从<a class="ae lq" href="https://kea.js.org/docs/installation/instructions" rel="noopener ugc nofollow" target="_blank"> Kea文档</a>中，您需要以下内容:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="1a7f" class="nx ma it nb b gy on oo l op oq">yarn add kea redux react-redux reselect</span></pre><p id="bf09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在这里也将提前考虑，并获取在用TypeScript编写Kea逻辑时使用的一个单独的包:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="766d" class="nx ma it nb b gy on oo l op oq">yarn add --dev kea-typegen</span></pre><h2 id="39fd" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">package.json</h2><p id="5797" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">有了所有这些设置，我们应该向我们的<code class="fe my mz na nb b">package.json</code>文件添加一些有用的脚本:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="2043" class="nx ma it nb b gy on oo l op oq">...<br/>"scripts": {<br/>   "start": "webpack serve --mode development",<br/>   "typegen": "kea-typegen write ./src"<br/>},<br/>...</span></pre><p id="6713" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe my mz na nb b">start</code>将用于运行我们的服务器，而<code class="fe my mz na nb b">typegen</code>用于为我们的Kea逻辑文件生成类型。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="3c7f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最后，一些React代码</h1><p id="4558" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">相当多的设置，是吧？我想我们应该感谢样板文件，尤其是当它们为我们管理所有的依赖项和版本时(* cough<em class="lr">*</em><a class="ae lq" href="https://github.com/facebook/create-react-app/tree/master/packages/react-scripts" rel="noopener ugc nofollow" target="_blank">react-scripts</a>)。</p><p id="4528" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们现在已经完成了设置，接下来是一些代码！</p><h2 id="9d7e" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">但是首先，一些普通的HTML</h2><p id="cf7c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们需要的第一件事是React将用来呈现我们的应用程序的一个<code class="fe my mz na nb b">index.html</code>文件。这是我们仅有的<code class="fe my mz na nb b">.html</code>文件。这也是我们在本教程的<code class="fe my mz na nb b">public/</code>中唯一的文件。</p><p id="89e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我的<code class="fe my mz na nb b">index.html</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="5cc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生了一些事情:</p><ul class=""><li id="5c33" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nw ni nj nk bi translated">我们正在为我们的网站设置一些默认的元标签和标题。</li><li id="9ea5" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nw ni nj nk bi translated">我们指定了一个<code class="fe my mz na nb b">root</code> div，我们将使用它来呈现我们的应用程序(这实际上是React动态生成内部HTML的起点)。</li><li id="5eef" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nw ni nj nk bi translated">我们为那些禁用JavaScript的人添加了一条消息，因为我们的应用程序对他们不起作用。</li><li id="d465" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nw ni nj nk bi translated">我们导入了尚未实际生成的成品webpack包。</li><li id="8fa0" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nw ni nj nk bi translated">这将包含我们在单个文件中编写的所有代码。</li></ul><h2 id="2693" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">入口点</h2><p id="c312" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">还记得前面提到的入口点吗？好吧，现在我们已经开始了。进入<code class="fe my mz na nb b">src/</code>子目录，创建一个名为<code class="fe my mz na nb b">index.tsx</code>的新文件。</p><p id="0354" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我的记录:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="4c43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生了三件关键的事情:</p><ol class=""><li id="ea6c" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">我们正在设置Kea，它像Redux一样，使用<code class="fe my mz na nb b">Provider</code>使任何嵌套组件(在本例中，是我们的整个应用程序)都可以使用商店。</li></ol><ul class=""><li id="5a3c" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nw ni nj nk bi translated">这里实际上不需要<code class="fe my mz na nb b">resetContext</code>调用，因为我们没有向它传递任何东西。然而，我把它留在这里，这样你就知道在哪里添加，例如，你的Kea插件，因为你可能会用到它们。</li></ul><p id="84c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.我们正在导入和渲染我们的<code class="fe my mz na nb b">App</code>组件(我们还没有构建)。</p><p id="4973" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.我们告诉React使用来自<code class="fe my mz na nb b">index.html</code>的<code class="fe my mz na nb b">root</code> div作为“绑定点”来呈现我们的应用程序。</p><h2 id="c6a4" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">我们的应用！</h2><p id="a226" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">现在，同样在<code class="fe my mz na nb b">src/</code>中，用下面的代码创建一个名为<code class="fe my mz na nb b">App.tsx</code>的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="4d01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您只想看到您的应用程序在这一点上工作，您可以删除对<code class="fe my mz na nb b">MyJSComponent</code>和<code class="fe my mz na nb b">Counter</code>的导入和引用，并运行<code class="fe my mz na nb b">yarn start</code>。这将启动您的服务器，您应该能够在<code class="fe my mz na nb b">localhost:3000</code>访问您的React应用程序，接收您的“Hello world！”来自它的问候。</p><p id="add6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我包含这两个额外组件的原因是为了测试我们有一些东西在工作:</p><ol class=""><li id="7d27" class="nc nd it kw b kx ky la lb ld ne lh nf ll ng lp nh ni nj nk bi translated">我们可以在编写TypeScript的同时编写JavaScript。</li><li id="bff7" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">我们的国家管理运作良好。</li><li id="8520" class="nc nd it kw b kx nl la nm ld nn lh no ll np lp nh ni nj nk bi translated">我们的捆绑器处理<code class="fe my mz na nb b">.css</code>文件没有问题(<code class="fe my mz na nb b">Counter</code>有一些最小的样式)。</li></ol><p id="2a26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果你想的话，你可以停在这里。但是如果你想看到这三件事的实际效果，请继续阅读。</p><h2 id="95ec" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">并排写JS和TS</h2><p id="fdca" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">正如您在我们的<code class="fe my mz na nb b">App.tsx</code>文件中看到的，我们有一个导入JavaScript文件的TypeScript文件，没有任何问题。</p><p id="2422" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样做的原因是因为我们在<code class="fe my mz na nb b">webpack.config.js</code>中有这条规则:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="5f90" class="nx ma it nb b gy on oo l op oq">{<br/>    test: /\.[jt]sx?$/,<br/>    loader: 'babel-loader',<br/>    exclude: /node_modules/,<br/>},</span></pre><p id="eb83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将<code class="fe my mz na nb b">j</code>从<code class="fe my mz na nb b">test</code>中移除，我们将无法将JS文件与TS文件一起使用。</p><p id="9199" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了测试一切是否正常，我简单地创建了一个小小的JS组件，并将其导入到应用程序中。</p><p id="495c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在一个名为<code class="fe my mz na nb b">components/</code>的新目录中创建了它，下面是它包含的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="46f0" class="nx ma it bd mb ny nz dn mf oa ob dp mj ld oc od ml lh oe of mn ll og oh mp oi bi translated">计数器</h2><p id="4613" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我在这个项目中添加的最后一个东西是传统的React计数器组件，虽然它仍然保持最小化。</p><p id="c866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的目标是测试我们的Kea设置是否有效——以及导入CSS文件是否有效。</p><p id="3cbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我首先在<code class="fe my mz na nb b">components/</code>内部创建了一个名为<code class="fe my mz na nb b">Counter</code>的子目录。在这里，我添加了三个文件:</p><p id="f385" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1.<code class="fe my mz na nb b">index.tsx</code> —包括实际组件。这是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="8fb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很简单的东西。点击<code class="fe my mz na nb b">+</code>，计数上升。<code class="fe my mz na nb b">-</code>倒计时开始。使用输入设置任何数字，计数也会更新。</p><p id="bb31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，请注意<code class="fe my mz na nb b">style.css</code>导入。</p><p id="f4f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.<code class="fe my mz na nb b">counterLogic.ts</code> —托管用于操作我们的<code class="fe my mz na nb b">Counter</code>组件所使用的状态的逻辑。我不会在这里解释Kea是如何工作的，但是下面的内容是不言自明的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="7cef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.<code class="fe my mz na nb b">style.css </code> —在这里，我使用了我能想到的最简单的样式来测试CSS是否按预期工作:</p><pre class="kj kk kl km gt oj nb ok ol aw om bi"><span id="ac1c" class="nx ma it nb b gy on oo l op oq">h3 {<br/>    color: blue;<br/>}</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="9b5a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">就是这样！</h1><p id="b877" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果你已经走到这一步，希望你已经有了一个闪亮的新React应用程序、一个现代样板文件和一些额外的知识。老实说，这只是我记录的一点我的学习过程，但我希望你也有所收获！</p></div></div>    
</body>
</html>