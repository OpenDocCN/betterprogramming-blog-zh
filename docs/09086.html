<html>
<head>
<title>Build a Dashboard With Drag-and-Drop Dynamic Widgets in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中用拖放式动态部件构建一个仪表板</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-dashboard-with-drag-and-drop-dynamic-widgets-in-react-1f012eeecd8b?source=collection_archive---------3-----------------------#2021-07-14">https://betterprogramming.pub/build-a-dashboard-with-drag-and-drop-dynamic-widgets-in-react-1f012eeecd8b?source=collection_archive---------3-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建交互式仪表板</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3971667bba36fc52c2201187e9d10a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*muXvyi2lMSiBm0_y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="d0fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多时候，当创建一个web应用程序时，您需要创建一个交互式仪表板。这个仪表板可以有开发人员可以想象的许多功能。我们今天将实施几个:</p><ul class=""><li id="7ccd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">拥有用户可以玩的动态部件。</li><li id="5417" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">允许用户拥有一个包含默认小部件的默认视图。</li><li id="c81b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">允许用户通过从单独的视图拖放来添加新的小部件。</li><li id="8b27" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">允许用户在仪表板画布上的任何地方拖放现有的小部件。</li><li id="5a30" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">允许用户调整这些部件的大小。</li></ul><p id="9955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了启用这些特性，开发人员可以摆弄代码，实现一个本质上是动态的、对web包大小没有太大影响的解决方案。</p><p id="1ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们收集所有需要的材料:</p><ul class=""><li id="d058" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">React 17(或任何版本≥ 16.6)</li><li id="2b27" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们将用来管理小部件的库:<a class="ae ky" href="https://github.com/react-grid-layout/react-grid-layout" rel="noopener ugc nofollow" target="_blank"> React-Grid-Layout </a></li><li id="29eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后，一个可选的成分:打字稿</li></ul><p id="06c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整代码的堆栈:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="45e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们一步一步地实施它:</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="413b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">1.创建仪表板组件</h1><p id="332a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">该组件将负责呈现和管理小部件的网格。这也将负责保存当前小部件的布局。</p><ul class=""><li id="b714" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们将使用来自<code class="fe np nq nr ns b">react-grid-layout</code>的<code class="fe np nq nr ns b">GridLayout</code>来实现这一点。对于响应视图，使用<code class="fe np nq nr ns b">GridLayout.Responsive</code>。</li><li id="f023" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们将为它的一些属性提供值，比如<code class="fe np nq nr ns b">preventCollision</code>，以定制网格行为。</li><li id="4117" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe np nq nr ns b">GridLayout</code>提供了一些回调函数，比如<code class="fe np nq nr ns b">onDrop</code>，我们将使用它们向网格动态添加新的小部件，或者将布局保存在组件状态和一些持久存储中，比如<code class="fe np nq nr ns b">localStorage</code>。</li><li id="733e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们还将使用第二个组件<code class="fe np nq nr ns b">DashboardWidget</code>，动态加载我们将在下一步中创建的小部件组件。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mk l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b07a" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">2.创建DashboardWidget组件</h1><p id="2bde" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">该组件将负责在运行时动态加载组件，并在重新呈现时将其保存在状态中。</p><p id="ccc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个组件，我们将使用React 16.6中引入的React特性，<a class="ae ky" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank">代码分割</a>:</p><blockquote class="nu nv nw"><p id="7a86" class="kz la nx lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">“对你的应用进行代码拆分可以帮助你‘延迟加载’用户当前需要的东西，这可以极大地提高你的应用的性能。虽然你没有减少应用程序中的总代码量，但你避免了加载用户可能永远不需要的代码，并减少了初始加载期间所需的代码量。”—反应文档</p></blockquote><p id="1ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个React特性将帮助我们在构建时将小部件代码分割成单独的文件，从而减小主包的大小。因此，浏览器将只加载用户在定制布局中实际选择的小部件。</p><ul class=""><li id="faa4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对于加载组件，我们将使用<a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#import" rel="noopener ugc nofollow" target="_blank">动态</a> <code class="fe np nq nr ns b"><a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#import" rel="noopener ugc nofollow" target="_blank">import()</a></code> <a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#import" rel="noopener ugc nofollow" target="_blank">语法</a>结合<code class="fe np nq nr ns b"><a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">React.lazy</a></code> <a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">函数</a>和<code class="fe np nq nr ns b">Suspense</code>组件。</li><li id="5fd5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们必须将来自<code class="fe np nq nr ns b">GridLayout</code>的引用传递给div元素，我们将在其中呈现我们的小部件。这是允许<code class="fe np nq nr ns b">GridLayout</code>将div标识为可拖动元素所必需的。在本例中，我们使用了<code class="fe np nq nr ns b">forwardRef</code>并将所有的props和ref转发给第一个div元素。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mk l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="7de7" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">3.创建小部件选择器</h1><p id="3d89" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">该组件将负责管理新的小部件，并允许用户将小部件拖放到仪表板上的网格中。</p><ul class=""><li id="63b2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">为了允许用户拖放小部件，我们将使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" rel="noopener ugc nofollow" target="_blank"> HTML拖放API </a>。这个API允许界面用鼠标拖动<em class="nx">可拖动的</em>元素，并通过释放鼠标按钮来放下它们。</li><li id="88e0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为此，我们将使用<code class="fe np nq nr ns b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/dragstart_event" rel="noopener ugc nofollow" target="_blank">onDragStart</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/dragstart_event" rel="noopener ugc nofollow" target="_blank">事件</a>和<code class="fe np nq nr ns b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" rel="noopener ugc nofollow" target="_blank">dataTransfer</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" rel="noopener ugc nofollow" target="_blank">对象</a>来允许网格将元素识别为新的小部件。</li><li id="121a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您可以在此自定义可用小部件的显示方式。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mk l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="defd" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">4.创建小部件</h1><p id="bb3c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这将是一个自给自足的独立组件，可以管理自己的状态和数据。您可以根据自己的选择定制其界面。</p><p id="f5d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建小部件时唯一要记住的是，您必须使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#syntax" rel="noopener ugc nofollow" target="_blank">默认导出(而不是命名导出)</a>来导出组件。这是由于<code class="fe np nq nr ns b">React.lazy</code>功能目前只支持<a class="ae ky" href="https://reactjs.org/docs/code-splitting.html#named-exports" rel="noopener ugc nofollow" target="_blank">默认导出</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mk l"/></div></figure><p id="e3f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。</p><p id="9188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您已经创建了一个动态仪表板，它将允许您的用户定制小部件及其布局。您还可以在运行时动态加载小部件。</p><p id="c5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以添加一些改进，为小部件添加道具，这些小部件可以在运行时被网格更改(有助于为显示的数据添加过滤器)，或者使网格根据可用的宽度做出响应。</p><p id="59ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是GitHub回购的链接:</p><div class="ob oc gp gr od oe"><a href="https://github.com/kgrvr/React-Dashboard-Widget-Example" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">kgr VR/React-Dashboard-Widget-示例</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">由斯塔克布里兹·⚡️.创作通过在…上创建帐户，为kgr VR/React-Dashboard-Widget-Example开发做出贡献</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><p id="7f53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>