# 使用 id()理解 Python 中的 6 个关键概念

> 原文：<https://betterprogramming.pub/use-id-to-understand-6-key-concepts-in-python-73e0bbd461ec>

## 发现引擎盖下的机械

![](img/4cf33792472ba7f264f05528337b2abb.png)

[天一马](https://unsplash.com/@tma?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照。

有超过 70 个内置函数[可供任何 Python 解释器在启动时使用。每个 Python 学习者都不应该对一些常见的不熟悉。例如，我们可以使用`len()`来获取一个对象的长度，比如一个列表或字典中的条目数。再比如，我们可以使用`print()`打印出感兴趣的对象，用于学习和调试。](https://docs.python.org/3/library/functions.html#id)

此外，几乎所有的 Python 程序员都应该在教程中看到过使用内置的`id()`函数来演示特定的 Python 概念。然而，据我所知，这些信息是分散的。在本文中，我将提供一个使用`id()`函数理解六个关键 Python 概念的系统回顾。

# 1.在 Python 中，一切都是对象

作为一种流行的面向对象编程语言，Python 在其实现中处处使用对象。例如，整数、浮点数、字符串、列表和字典等内置数据类型都是对象。此外，函数、类、甚至模块也被用作对象。

根据定义，`id()`函数接受一个对象并返回该对象的标识，即以整数表示的内存地址。因此，我们可以使用这个函数来证明 Python 中的一切都是对象。

Python 对象和 id()函数。

在上面的代码片段中，您可以看到`objects`列表中的每一项都可以在`id()`函数中使用，它揭示了每个对象的内存地址。

下面的操作，我认为非常有趣，作为一个函数本身，`id()`函数也应该有它的内存地址。

```
>>> print(f'{type(id)} with id: {id(id)}')
<class 'builtin_function_or_method'> with id: 4480774224
```

# 2.变量赋值和别名

当我们在 Python 中创建变量时，我们通常使用以下语法:

```
var_name = the_object
```

这个过程基本上将在内存中创建的对象绑定到特定的变量名。如果我们给一个变量赋值另一个变量，比如`var_name1 = var_name`，会发生什么？

考虑下面的例子。在下面的代码片段中，我们首先创建了一个名为`hello`的变量，并为其分配了一个字符串值。接下来，我们通过给前面的变量`hello`赋值来创建另一个变量`world`。当我们打印出它们的内存地址时，我们发现`hello`和`world`有相同的内存地址，这表明它们是内存中的同一个对象。

变量赋值和别名。

在这种情况下，变量`world`通常被称为变量`hello`的别名，并且通过分配现有变量来创建新变量的过程可以被称为别名。在其他编程语言中，别名非常类似于内存中底层对象的指针或引用。

在上面的代码中，我们可以进一步看到，当我们为字典创建别名并修改别名的数据时，修改也适用于原始变量，因为在幕后，我们修改了内存中的同一个字典对象。

# 3.比较运算符:== vs. is

在各种场景中，我们需要比较两个对象作为决策点，以便在满足或不满足特定条件时应用不同的功能。在等式比较方面，我们可以使用两个比较运算符:`==`和`is`。一些新的 Python 学习者可能会错误地认为它们是一样的，但是还是有细微差别的。

考虑下面的例子。我们创建了相同项目的两个列表。当我们使用`==`操作符比较两个列表时，比较结果是`True`。当我们使用`is`操作符比较两个列表时，比较结果是`False`。为什么它们会产生不同的结果？是因为`==`运算符比较的是值，而`is`运算符比较的是身份(即内存地址)。

正如你所期望的，引用内存中相同对象的变量，它们不仅有相同的值，而且有相同的标识。这导致`==`和`is`操作员的评估结果相同，如下面涉及`str0`和`str1`的示例所示:

比较运算符。

# 4.整数缓存

我们在编程中经常使用的一组数据是整数。在 Python 中，解释器通常会缓存-5 到 256 范围内的小整数。这意味着当 Python 解释器启动时，这些整数将被创建，并在内存中供以后使用。以下代码片段展示了这一特性:

整数缓存。

在上面的代码中，我创建了两个字典，`id_counters`跟踪每个整数的唯一标识的数量，`id_records`跟踪该整数的最新标识。对于-10 到 265 范围内的整数，如果新整数的标识不同于现有的标识，则相应的计数器加 1。这个过程我重复了 1000 次。

最后一行代码使用列表理解技术向您展示了具有多个单位的整数。显然，经过 1000 次之后，从-5 到 256 的整数每一个都只有一个单位，正如上一段所讨论的。要了解更多关于 Python 的列表理解，可以参考我以前的一篇文章:

[](https://medium.com/better-programming/9-things-to-know-to-master-list-comprehensions-in-python-8bc0411ec2ed) [## 掌握 Python 中列表理解的 9 件事

### 本教程将帮助你学习 Python 中列表理解的最常见用法

medium.com](https://medium.com/better-programming/9-things-to-know-to-master-list-comprehensions-in-python-8bc0411ec2ed) 

# 5.浅拷贝和深拷贝

有时，我们需要制作现有对象的副本，这样我们可以在不改变另一个副本的情况下改变一个副本。内置的`copy`模块为此提供了两种方法:`copy()`和`deepcopy()`，分别制作浅层副本和深层副本。如果你不知道它们是什么，让我们利用`id()`函数来理解这两个概念。

浅拷贝和深拷贝。

我们首先创建了一个名为`original`的列表变量，它由一个嵌套列表和两个整数组成。然后我们分别使用`copy()`和`deepcopy()`方法制作了两个副本(`copy0`和`copy1`)。正如我们所料，`original`、`copy0`和`copy1`具有相同的值(即`[[0, 1], 2, 3]`)。然而，它们有不同的身份，因为与别名不同，`copy()`和`deepcopy()`方法都在内存中创建新的对象，因此新的副本有不同的身份。

浅拷贝和深拷贝之间最本质的区别是，深拷贝将为原始复合对象递归地创建拷贝，而浅拷贝将维护对现有对象的引用(如果适用)。在上面的例子中，变量`original`实际上是一个复合对象(即一个列表嵌套在另一个列表中)。

在这种情况下，使用`copy()`方法，变量`copy0`的第一个元素与`original`的第一个元素具有相同的身份(即相同的对象)。相比之下，`deepcopy()`方法会在内存中复制嵌套列表，这样`copy1`中的第一个元素就与`original`中的不同

但是深度复制中的“递归”是什么意思呢？这意味着如果有多层嵌套(例如，一个列表嵌套在一个列表中，而这个列表又嵌套在另一个列表中)，`deepcopy()`方法将为每一层创建新的对象。有关此功能，请参见以下示例:

deepcopy()中的递归。

# 6.数据可变性

Python 编程中的一个高级主题与数据可变性有关。一般来说，不可变数据是那些在创建后其值不能被改变的对象，比如整数、字符串和元组。相比之下，可变数据指的是那些在创建后其值可以改变的对象，比如列表、字典和集合。

需要注意的一个关键点是，我们所说的“改变值”是指内存中的底层对象是否可以改变。关于数据可变性的详细讨论可以在我以前的文章中找到:

[](https://medium.com/swlh/6-things-to-understand-python-data-mutability-b52f5c5db191) [## 理解 Python 数据可变性的 6 件事

### 不可变与可变

medium.com](https://medium.com/swlh/6-things-to-understand-python-data-mutability-b52f5c5db191) 

出于本文讨论 id `()`函数的目的，让我们考虑下面的例子。对于不可变的数据类型(代码片段中的整数变量`thousand`，当我们试图改变它的值时，一个新的整数在内存中被创建，正如变量`thousand`的新标识所反映的那样。换句话说，原始的底层整数对象不能被改变。改变整数的尝试导致在内存中创建了一个新的对象。

数据可变性和 id()。

如果这让您感到困惑，让我们看看可变数据类型发生了什么——在我们的例子中，是变量`numbers`。如上面的代码所示，当我们试图改变`numbers`的值时，变量`numbers`得到了更新，更新后的列表仍然具有相同的标识，这证实了`list`类型的对象的可变性。

# 外卖食品

在本文中，我们利用内置的`id()`函数来理解 Python 中的六个关键概念。以下是这些概念的简要回顾:

*   Python 中的一切都是对象。
*   我们通过赋值来创建变量，别名指向内存中相同的对象。
*   比较运算符`==`比较值，而比较运算符`is`比较恒等式。
*   Python 解释器在启动时创建从-5 到 256 的整数对象。
*   浅拷贝和深拷贝都具有与其原始对象相同的值，但是浅拷贝仅拷贝原始对象的嵌套对象的引用。
*   可变对象的值可以在内存中更改，而不可变对象不支持值更改。