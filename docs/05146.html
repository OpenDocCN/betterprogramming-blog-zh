<html>
<head>
<title>How to Modify States During View Updates in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中修改视图更新期间的状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-modify-states-during-view-updates-in-swiftui-923bf7cea44f?source=collection_archive---------4-----------------------#2020-06-15">https://betterprogramming.pub/how-to-modify-states-during-view-updates-in-swiftui-923bf7cea44f?source=collection_archive---------4-----------------------#2020-06-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1854" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">让我们利用Combine框架的力量来解决这个问题</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f3198be61dcda62d67b50556a3561b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NTi5gorXl8eUIKxV"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">瑞安·昆塔尔在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="326f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI在WWDC 2019上推出，改变了我们为应用程序构建用户界面的方式。使用UIKit和Auto Layouts时需要花费大量时间和样板代码的事情，使用SwiftUI可以非常快速地完成。</p><p id="98f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于其状态驱动的框架，更新SwiftUI视图非常容易。在SwiftUI中连接一个<code class="fe lw lx ly lz b">ProgressBar</code>和<code class="fe lw lx ly lz b">WKWebView</code>似乎很容易。</p><p id="e403" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是当您需要随着网页的加载从<code class="fe lw lx ly lz b">WKWebView</code>修改<code class="fe lw lx ly lz b">ProgressBar</code>状态时会发生什么呢？这就是本文的目标。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="c75c" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">我们的目标</h1><ul class=""><li id="86fa" class="mz na iu lc b ld nb lg nc lj nd ln ne lr nf lv ng nh ni nj bi translated">构建一个由<code class="fe lw lx ly lz b">WKWebView</code>和<code class="fe lw lx ly lz b">ProgressBar</code>组成的SwiftUI iOS应用程序。我们将在SwiftUI中加载网页时更新<code class="fe lw lx ly lz b">ProgressBar</code>。</li><li id="b1ca" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">了解在视图更新期间修改状态将如何导致SwiftUI视图中的未定义行为和差异。</li><li id="b4cd" class="mz na iu lc b ld nk lg nl lj nm ln nn lr no lv ng nh ni nj bi translated">使用带有<code class="fe lw lx ly lz b">@Published</code>属性包装器和<code class="fe lw lx ly lz b">ObservableObject</code>的Combine框架的力量来修复我们应用程序中的这个问题。</li></ul></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="e821" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">构建一个SwiftUI ProgressBar</h1><p id="0403" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">SwiftUI目前没有为<code class="fe lw lx ly lz b">ProgressBars</code>提供开箱即用的实现。谢天谢地，我们可以利用SwiftUI <code class="fe lw lx ly lz b">Rectangle</code>形状和一个<code class="fe lw lx ly lz b">GeometryReader</code>来创建我们自己的<code class="fe lw lx ly lz b">ProgressBar</code>，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="8b66" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面先睹为快，看看<code class="fe lw lx ly lz b">ProgressBar</code>的预览。我们使用SwiftUI滑块来更新<code class="fe lw lx ly lz b">progress</code>值:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/1d04f96883aca6fdef9104b862c7f629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Lrl0Wrgb1LwEW97r-6NZBA.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">屏幕截图</p></figure><p id="cf5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这又快又简单。我们的下一个目标是创建SwiftUI WebView，并将其与<code class="fe lw lx ly lz b">ProgressBar</code>集成。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="ca54" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">使用WebView可表示协议创建SwiftUI WebView</h1><p id="fdbe" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">和<code class="fe lw lx ly lz b">ProgressBars</code>一样，SwiftUI没有提供显示<code class="fe lw lx ly lz b">WKWebViews</code>的内置实现。幸运的是，我们可以使用<code class="fe lw lx ly lz b">UIViewRepresentable</code>协议并利用UIKit-SwiftUI互操作性为<code class="fe lw lx ly lz b">WKWebView</code>构建一个包装器结构。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="4cd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当创建上述结构的实例时，触发<code class="fe lw lx ly lz b">makeUIView</code>函数。随后，我们需要使用<code class="fe lw lx ly lz b">updateUIView</code>来更新视图。</p><p id="cc3b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您会注意到在上面的结构中定义了一个<code class="fe lw lx ly lz b">@Binding</code>属性— <code class="fe lw lx ly lz b">progress</code>。它用于从我们将监控的<code class="fe lw lx ly lz b">WKWebView</code>页面加载进度更新<code class="fe lw lx ly lz b">ProgressBar</code>状态。</p><p id="c93a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">Coordinator</code>类用于处理UIKit委托并将数据传递回SwiftUI视图。我们正在传递上面的<code class="fe lw lx ly lz b">Binding progress</code>属性:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="308d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">observe</code>方法需要<code class="fe lw lx ly lz b">WKWebView</code>的<code class="fe lw lx ly lz b">estimatedProgress</code>属性<strong class="lc iv"> </strong>，我们在它上面使用了Swift 5.2 Keypath语法。</p><p id="ab8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">.new</code>参数确保页面加载的任何新进展都会触发观察者。</p><p id="fec9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">逻辑非常简单。我们将<code class="fe lw lx ly lz b">estimateProgress</code>值设置为<code class="fe lw lx ly lz b">Binding</code>属性，这将更新SwiftUI <code class="fe lw lx ly lz b">ProgressBar</code>。但是下面这条线是一个突出的问题:</p><pre class="kk kl km kn gu nv lz nw nx aw ny bi"><span id="b9a1" class="nz mi iu lz b gz oa ob l oc od">self.progress = webView.estimatedProgress</span></pre><p id="5a7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI在运行时给我们以下消息:</p><pre class="kk kl km kn gu nv lz nw nx aw ny bi"><span id="3875" class="nz mi iu lz b gz oa ob l oc od">Warning: Modifying state during view update, this will cause undefined behavior.</span></pre><p id="6a84" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可以预见，当您运行上面的SwiftUI应用程序时，您最终会得到一个不断更新的<code class="fe lw lx ly lz b">ProgressBar</code>,如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/d4be15c82f05f509cbdb509a6e077d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mP6at6O0_8pi3PvZr0a3Wg.gif"/></div></div></figure><p id="8ab7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如你所见，<code class="fe lw lx ly lz b">ProgressBar</code>一直显示随机值，<code class="fe lw lx ly lz b">WKWebView</code>一直重新加载。我们在视图加载时修改了<code class="fe lw lx ly lz b">State</code>属性，这导致视图被重新渲染。苹果可能会在即将发布的版本中修复这个未定义的行为，但在此之前，我们需要修复这个问题。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="aa94" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">使用@Published属性修复未定义的行为</h1><p id="27ef" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">上面代码的问题是，当视图更新时，我们试图从另一个状态改变视图的状态，这导致整个主体重新加载。</p><p id="41d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以使用<code class="fe lw lx ly lz b">@Published</code>属性包装器被动更新视图，而不是使用SwiftUI的状态驱动数据流。SwiftUI现在提供了对Combine的<code class="fe lw lx ly lz b">Published</code>属性包装器的内置支持。</p><p id="9f3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们创建一个符合<code class="fe lw lx ly lz b">ObservableObject</code>协议的类，以便向SwiftUI发布公告:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="3d76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">progress</code>属性将用于被动更新<code class="fe lw lx ly lz b">ProgressBar</code>,<code class="fe lw lx ly lz b">link</code>将在<code class="fe lw lx ly lz b">WKWebView</code> <code class="fe lw lx ly lz b">loadRequest</code>中设置字符串URL。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="3283" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们之前声明的<code class="fe lw lx ly lz b">WebViewModel</code>实例的属性现在可以从<code class="fe lw lx ly lz b">Coordinator</code>类中更改，以相应地更新SwiftUI视图。如您所见，我们使用<code class="fe lw lx ly lz b">Publisher</code>来被动更新视图，而不是使用<code class="fe lw lx ly lz b">States</code>和<code class="fe lw lx ly lz b">Binding</code>，这在视图更新期间修改时会导致问题。</p><p id="a68e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">包含上面的<code class="fe lw lx ly lz b">SwiftUIWebView</code>和<code class="fe lw lx ly lz b">SwiftUIProgressBar</code>的SwiftUI视图的代码如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="5963" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，每当<code class="fe lw lx ly lz b">progress</code>属性改变时，<code class="fe lw lx ly lz b">ObservedObject</code>就发布一个double值。但是<code class="fe lw lx ly lz b">ProgressBar</code>需要一个<code class="fe lw lx ly lz b">Binding</code>属性。因此，为了将<code class="fe lw lx ly lz b">Double</code>转换为<code class="fe lw lx ly lz b">Binding&lt;Double&gt;</code>值，我们使用了<code class="fe lw lx ly lz b">constant</code>绑定。</p><p id="ee54" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该应用程序现在非常好用:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/3057bd2d6bfefe594141ef403de4b678.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/1*7-QPqCCh31QANTY7YMBBbQ.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">输出</p></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="bc95" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结束语</h1><p id="bcd9" class="pw-post-body-paragraph la lb iu lc b ld nb jv lf lg nc jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">SwiftUI是一个状态驱动的框架，让我们可以轻松地创建声明式用户界面。但是，有时当您需要在视图更新期间修改状态时，使用Combine框架的功能是一个更好的主意，因为它可以防止呈现和重新加载问题。</p><p id="be2b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在这个<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/SwiftUIWebViewsProgressBars" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的源代码。</p><p id="d92d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>