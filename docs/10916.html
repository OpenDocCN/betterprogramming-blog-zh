<html>
<head>
<title>Exploring Typed Events in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中探索类型化事件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typed-events-in-typescript-2ad75657640e?source=collection_archive---------7-----------------------#2022-02-03">https://betterprogramming.pub/typed-events-in-typescript-2ad75657640e?source=collection_archive---------7-----------------------#2022-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3c9d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用泛型类型清晰地调度和处理事件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/61a53452d34a8e0964d32ac5a3f847c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cAa2yv7LUnymtf0q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">山姆·曼斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="df12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的应用程序中有解耦的逻辑，使我能够根据容器或上下文对象将控制器和视图组合在一起。</p><p id="2524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这些控制器不知道彼此的存在，因此针对上下文对象分派事件。</p><p id="e93f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在较大的应用程序中，记住每个事件处理程序需要什么属性变得很麻烦——我不想不断地检查事件处理程序来回忆要调度哪些属性。</p><p id="30c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种分派事件的模式给了我这样的信息:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fcba" class="lx ly iq lt b gy lz ma l mb mc">public dispatch&lt;T&gt;(type: string, data: T): void {<br/>}</span></pre><p id="d960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使我能够指定数据的动作类型和有效载荷。</p><p id="c62b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们使用<a class="ae kv" href="https://github.com/primus/eventemitter3" rel="noopener ugc nofollow" target="_blank"> EventEmitter3 </a>作为上下文对象上的事件机制。我们的上下文对象将扩展这个发射器并提供一个<code class="fe md me mf lt b">dispatch()</code>实现:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="edfb" class="lx ly iq lt b gy lz ma l mb mc">import EventEmitter from "eventemitter3";<br/><br/>class Context extends EventEmitter {<br/>  public dispatch&lt;T&gt;(type: string, data: T) {<br/>    this.emit(type, data);<br/>  }<br/>}</span></pre><p id="6ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试调度一些事件。</p><h1 id="353b" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">预警事件示例</h1><p id="b6e9" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">让我们从简单的东西开始——一个警报系统，它在不同的日志级别报告一个字符串消息。</p><p id="5973" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要可以调度的事件类型。这将是枚举中定义的标准信息、错误、警告和成功类型:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ed1d" class="lx ly iq lt b gy lz ma l mb mc">enum AlertEvent {<br/>  <em class="nc">ERROR </em>= "AlertEvent:ERROR",<br/>  <em class="nc">INFO </em>= "AlertEvent:INFO",<br/>  <em class="nc">SUCCESS </em>= "AlertEvent:SUCCESS",<br/>  <em class="nc">WARNING </em>= "AlertEvent:WARNING",<br/>}</span></pre><p id="5d9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个数据，有效载荷将只是一个字符串消息</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8654" class="lx ly iq lt b gy lz ma l mb mc">type AlertEventOptions = {<br/>  readonly message: string;<br/>};</span></pre><p id="12e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了分派事件，将<code class="fe md me mf lt b">AlertEventOptions</code>作为通用函数类型来传递，以定义我们将要传递的数据的有效载荷。然后，使用<code class="fe md me mf lt b">AlertEvent</code>枚举来定义事件的类型。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9c66" class="lx ly iq lt b gy lz ma l mb mc">context.dispatch&lt;<strong class="lt ir">AlertEventOptions</strong>&gt;(<strong class="lt ir">AlertEvent.<em class="nc">INFO</em></strong>, {<br/>  message: "This is some info",<br/>});<br/><br/>context.dispatch&lt;<strong class="lt ir">AlertEventOptions</strong>&gt;(<strong class="lt ir">AlertEvent.<em class="nc">ERROR</em></strong>, {<br/>  message: "This is an error",<br/>});</span></pre><p id="a491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了处理事件，再次使用<code class="fe md me mf lt b">AlertEventOptions</code>作为事件类型:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2466" class="lx ly iq lt b gy lz ma l mb mc">const onAlertInfo = (event: AlertEventOptions): void =&gt; {<br/>  console.log(event.message);<br/>};<br/><br/>context.on(AlertEvent.<em class="nc">INFO</em>, onAlertInfo);</span></pre><p id="70f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得IDE能够智能地理解数据的有效载荷:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/d1bb2b9f691344488faf7ab9ddf639a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*n81TyWJg4G5LlC4Omp9D0w.gif"/></div></div></figure><h1 id="266e" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">查看模式事件示例</h1><p id="b753" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">假设这个应用程序是一个图形编辑应用程序，用户可以在不同的工具之间进行切换，例如:</p><ul class=""><li id="f172" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">拉制工具</li><li id="0827" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">用于缩放/平移的抓取工具</li><li id="3e99" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">选择工具</li></ul><p id="448c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将这些定义为一个<code class="fe md me mf lt b">ViewMode</code>枚举:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5a7a" class="lx ly iq lt b gy lz ma l mb mc">enum ViewMode {<br/>  <em class="nc">DRAW </em>= "ViewMode:DRAW",<br/>  <em class="nc">SELECT </em>= "ViewMode:SELECT",<br/>  <em class="nc">GRAB </em>= "ViewMode:GRAB",<br/>}</span></pre><p id="707e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户改变视图模式时，我们将调度一个<code class="fe md me mf lt b">change</code>事件:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f5f4" class="lx ly iq lt b gy lz ma l mb mc">enum ViewModeEvent {<br/>  <em class="nc">CHANGE </em>= "ViewModeEvent:CHANGE",<br/>}</span></pre><p id="1a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们的数据有效载荷将由新模式组成:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fe58" class="lx ly iq lt b gy lz ma l mb mc">type ViewModeOptions = {<br/>  readonly mode: ViewMode;<br/>};</span></pre><p id="e614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要调度，用<code class="fe md me mf lt b">ViewModeEvent.CHANGE</code>传递<code class="fe md me mf lt b">ViewModeOptions</code>，并将<code class="fe md me mf lt b">ViewMode</code>包含在数据有效载荷中:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f068" class="lx ly iq lt b gy lz ma l mb mc">context.dispatch&lt;ViewModeOptions&gt;(ViewModeEvent.<em class="nc">CHANGE</em>, {<br/>  mode: ViewMode.<em class="nc">SELECT</em>,<br/>});</span></pre><p id="c6f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了处理事件，监听<code class="fe md me mf lt b">ViewModeEvents</code>为:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="65aa" class="lx ly iq lt b gy lz ma l mb mc">const onViewModeChange = (event: ViewModeOptions): void =&gt; {<br/>  switch (event.mode) {<br/>    case ViewMode.<em class="nc">SELECT</em>:<br/>      // ...<br/>      break;<br/>    case ViewMode.<em class="nc">DRAW</em>:<br/>      break;<br/>    case ViewMode.<em class="nc">GRAB</em>:<br/>      break;<br/>  }<br/>};<br/><br/>context.on(ViewModeEvent.<em class="nc">CHANGE</em>, onViewModeChange);</span></pre><p id="57bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">IDE再一次熟练地解析了类型:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/adb672533846f4b8d0a29070ab069137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YXtf1o5O3Czd_J2qHapOBA.gif"/></div></div></figure><h1 id="11d4" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">分音</h1><p id="88f4" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果您的数据有效负载包含几个属性，但并不打算将它们全部包含在内，那么可以将它实现为一个部分:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="564d" class="lx ly iq lt b gy lz ma l mb mc">export type LinkOptions = {<br/>  readonly href: string;<br/>  readonly target: string;<br/>};</span><span id="f4ef" class="lx ly iq lt b gy ns ma l mb mc">const onNavigate = (event: Partial&lt;LinkOptions&gt;): void =&gt; {<br/>  // ...<br/>};</span></pre><p id="7732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这可能反映了一个过于复杂的事件——为了清晰起见，请考虑将其分解。</p><h1 id="0ebd" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">摘要</h1><p id="6b7a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">与编程中的任何事情一样，有替代方法，尤其是在实现依赖注入和控制模式反转时。</p><p id="b702" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型别名提供了委托，其中谓词函数可以处理动作——我将在下一篇文章中探讨这一点。</p></div></div>    
</body>
</html>