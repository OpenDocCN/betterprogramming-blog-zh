<html>
<head>
<title>30 Simple Tricks to Level Up Your Python Coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升Python编码水平的30个简单技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/30-simple-tricks-to-level-up-your-python-coding-5b625c15b79a?source=collection_archive---------0-----------------------#2020-03-20">https://betterprogramming.pub/30-simple-tricks-to-level-up-your-python-coding-5b625c15b79a?source=collection_archive---------0-----------------------#2020-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="557e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好的Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/232f34ba11b473740282a898de22dfa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mt7OADaVgEr3SBCPvz914Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">林赛·亨伍德在<a class="ae ky" href="https://unsplash.com/s/photos/stairs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="32c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一种通用编程语言，Python已经渗透到几乎所有的工业和学术领域。根据我在生物医学领域对Python编程的观察，我意识到相当多的Python程序员，包括我自己，来自不同的编程背景，比如Matlab、C、C++、Java、JavaScript和Swift，更不用说一些以前没有编程经验的人了。</p><p id="0924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Python是他们的“外国”语言，他们可能没有接受过Python编码的系统培训，也可能不知道Python开发的惯用方法。</p><p id="5215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要误解我——只要代码能够满足预期的目的，他们仍然可以通过以不同的方式实现相同的功能来编写优秀的代码。因此，对我来说，编写非惯用的Python程序是可以接受的。</p><p id="2d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，就像我作为一个在美国的外国人一直在努力改善我的英语口音一样，我希望我的Python代码尽可能地地道。在这篇文章中，我分享了我在过去几年中积累的一些习惯用法，希望能帮助你提高Python编码的水平。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f6d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.对序列进行切片</h1><p id="08cb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一些常见的序列类型有列表、元组和字符串。我们可以通过分割另一个序列来创建一个序列。以下功能使用列表作为示例，但是它们也可以应用于元组、字符串和其他序列类型(例如，字节)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="597b" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]<br/>&gt;&gt;&gt; # Using a range, [start, end)<br/>&gt;&gt;&gt; a[1:3]<br/>[2, 4]<br/>&gt;&gt;&gt; # Using a range with a step<br/>&gt;&gt;&gt; a[1:9:2]<br/>[2, 6, 10, 14]<br/>&gt;&gt;&gt; # Leave out the start = an implicit start of 0<br/>&gt;&gt;&gt; a[:5]<br/>[0, 2, 4, 6, 8]<br/>&gt;&gt;&gt; # Leave out the stop = an implicit end to the very last item<br/>&gt;&gt;&gt; a[9:]<br/>[18, 20]<br/>&gt;&gt;&gt; # Entire list<br/>&gt;&gt;&gt; a[:]<br/>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dcb2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.颠倒顺序</h1><p id="b1db" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时候，我们想颠倒一个顺序。虽然我们可以使用for循环来实现它，但是有一种简单的方法。类似地，如上所述，当一个功能可用于序列时，通常意味着字符串、元组和列表都支持该功能。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cade" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = (1, 2, 3, 4, 5)<br/>&gt;&gt;&gt; a[::-1]<br/>(5, 4, 3, 2, 1)<br/>&gt;&gt;&gt; b = 'start'<br/>&gt;&gt;&gt; b[::-1]<br/>'trats'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa2f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用反向索引访问序列中的元素</h1><p id="fdba" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果我们想访问序列末尾的一些元素，倒计数更容易。在Python序列中，最后一个元素的索引为-1，前面一个元素的索引为-2，依此类推。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="60a1" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = 'Hello World!'<br/>&gt;&gt;&gt; # instead of using a[len(a)-1]<br/>&gt;&gt;&gt; a[-1]<br/>'!'<br/>&gt;&gt;&gt; # in combination with slicing<br/>&gt;&gt;&gt; a[-5:-1]<br/>'orld'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="154f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.多重任务</h1><p id="0581" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们想给几个变量赋值的时候，我们可以做多重赋值。我们可以应用相同的习语来交换列表中的两个变量或两个元素。在幕后，这个特性与本文后面介绍的元组解包密切相关。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9890" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; # instead of doing a = 8; b = 5<br/>&gt;&gt;&gt; a, b = 8, 5<br/>&gt;&gt;&gt; print(f'a is {a}; b is {b}')<br/>a is 8; b is 5<br/>&gt;&gt;&gt; # Swap two variables<br/>&gt;&gt;&gt; a, b = b, a<br/>&gt;&gt;&gt; print(f'a is {a}; b is {b}')<br/>a is 5; b is 8<br/>&gt;&gt;&gt; # Swap the first and last elements in a list<br/>&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; numbers[0], numbers[-1] = numbers[-1], numbers[0]<br/>&gt;&gt;&gt; numbers<br/>[5, 2, 3, 4, 1]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fa37" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.检查序列是否为空</h1><p id="5a22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有些操作只有在序列(例如list、tuple)不为空时才有意义，因此我们需要在应用适当的操作之前进行检查。为此，我们可以使用关键字<code class="fe nj nk nl na b">not</code>对序列求反(例如，<code class="fe nj nk nl na b">not []</code>)，如果序列为空，它将计算为<code class="fe nj nk nl na b">True</code>。此外，我们可以对另外两种常见的数据类型做同样的事情:<code class="fe nj nk nl na b">dict</code>和<code class="fe nj nk nl na b">set</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="77eb" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; empty_list = [(), '', [], {}, set()]<br/>&gt;&gt;&gt; for item in empty_list:<br/>...     if not item:<br/>...         print(f'Do something with the {type(item)}')<br/>... <br/>Do something with the &lt;class 'tuple'&gt;<br/>Do something with the &lt;class 'str'&gt;<br/>Do something with the &lt;class 'list'&gt;<br/>Do something with the &lt;class 'dict'&gt;<br/>Do something with the &lt;class 'set'&gt;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e3cb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.列出理解</h1><p id="03d9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python中一个方便的特性是列表理解，我们可以用它非常方便地构造一个列表。列表理解一般格式为<code class="fe nj nk nl na b">[some_expression for element in iterable if some_condition]</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8e86" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = [1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; [x*2 for x in a]<br/>[2, 4, 6, 8, 10]<br/>&gt;&gt;&gt; [x*3 for x in a if x%2 == 1]<br/>[3, 9, 15]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="71e7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">7.集合理解</h1><p id="b990" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如上所述，集合理解的用法类似于列表理解。区别在于我们将使用花括号而不是方括号。此外，重复的元素将被<code class="fe nj nk nl na b">set</code>数据类型的定义移除。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a54c" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = [1, -2, 2, -3, 3, 4, 4, 5, 5, 5]<br/>&gt;&gt;&gt; {x*x for x in a}<br/>{1, 4, 9, 16, 25}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="81e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">8.字典理解</h1><p id="5149" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了列表和集合理解之外，理解特性也可用于字典数据类型的创建。一个<code class="fe nj nk nl na b">dict</code>由键-值对组成，因此dict理解涉及键和值的规范，它们由冒号分隔。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d5d0" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = [1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; {x: x*x for x in a}<br/>{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0506" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">9.生成器表达式</h1><p id="8aa9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python中的生成器是创建迭代器的一种便捷方式。由于生成器是“懒惰的”(即，在请求时产生所需的项目)，它们非常节省内存。创建生成器的一种特殊方法称为生成器表达式，它在语法上类似于列表理解，除了使用圆括号而不是方括号。</p><p id="9694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，当生成器直接用在可迭代的函数中时，括号是可选的。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="55c3" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; sum(x**2 for x in range(100))<br/>328350<br/>&gt;&gt;&gt; max((x*x for x in range(100)))<br/>9801</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="65b0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">10.解包元组</h1><p id="10e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">元组是Python中非常常见的数据结构。它们只是相关值的组，元组的常见用法包括访问它们的元素。我们可以使用索引来访问这些元素，但是解包是一种更方便的方式。关于它的用法，我们可以使用下划线来表示我们不需要的元素，并使用星号来指定除命名元素之外的其余元素。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="322d" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; items = (0, 'b', 'one', 10, 11, 'zero')<br/>&gt;&gt;&gt; a, b, c, d, e, f = items<br/>&gt;&gt;&gt; print(f)<br/>zero<br/>&gt;&gt;&gt; a, *b, c = items<br/>&gt;&gt;&gt; print(b)<br/>['b', 'one', 10, 11]<br/>&gt;&gt;&gt; *_, a, b = items<br/>&gt;&gt;&gt; print(a)<br/>11</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be54" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">11.在for循环中使用Enumerate()</h1><p id="373c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">enumerate()</code>函数接受一个iterable来创建一个迭代器。此外，它还可以跟踪迭代次数。我们可以选择设置计数的开始。默认计数从0开始。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="908f" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; students = ('John', 'Mary', 'Mike')<br/>&gt;&gt;&gt; for i, student in enumerate(students):<br/>...     print(f'Iteration: {i}, Student: {student}')<br/>... <br/>Iteration: 0, Student: John<br/>Iteration: 1, Student: Mary<br/>Iteration: 2, Student: Mike<br/>&gt;&gt;&gt; for i, student in enumerate(students, 35001):<br/>...     print(f'Student Name: {student}, Student ID #: {i}')<br/>... <br/>Student Name: John, Student ID #: 35001<br/>Student Name: Mary, Student ID #: 35002<br/>Student Name: Mike, Student ID #: 35003</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e20b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">12.在for循环中使用Reversed()</h1><p id="469f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">reversed()</code>函数经常在for循环中使用，作为一种以与原始iterable相反的顺序创建迭代器的方法。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="846a" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; tasks = ['laundry', 'picking up kids', 'gardening', 'cooking']<br/>&gt;&gt;&gt; for task in reversed(tasks):<br/>...     print(task)<br/>... <br/>cooking<br/>gardening<br/>picking up kids<br/>laundry</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="70f2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">13.Zip()函数</h1><p id="39a4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">zip()</code>函数对于在一对一匹配的基础上连接多个可重复项很有用。如果某些可重复项超过了最短的一个，它们就会被截断。这个函数返回一个迭代器，因此经常在迭代中使用。我们也可以使用<code class="fe nj nk nl na b">zip()</code>函数来解压一个带有星号的迭代器，并将解压后的项赋给变量。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d111" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; students = ('John', 'Mary', 'Mike')<br/>&gt;&gt;&gt; ages = (15, 17, 16)<br/>&gt;&gt;&gt; scores = (90, 88, 82, 17, 14)<br/>&gt;&gt;&gt; for student, age, score in zip(students, ages, scores):<br/>...     print(f'{student}, age: {age}, score: {score}')<br/>... <br/>John, age: 15, score: 90<br/>Mary, age: 17, score: 88<br/>Mike, age: 16, score: 82<br/>&gt;&gt;&gt; zipped = zip(students, ages, scores)<br/>&gt;&gt;&gt; a, b, c = zip(*zipped)<br/>&gt;&gt;&gt; print(b)<br/>(15, 17, 16)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="df90" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">14.用于排序的Lambdas</h1><p id="acaa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Lambdas是匿名函数，可以用一个单行表达式接受多个参数。它的一个常见用法是在<code class="fe nj nk nl na b">sorted()</code>函数中设置为<code class="fe nj nk nl na b">key</code>参数。除此之外，lambdas经常用于一些函数中(例如，<code class="fe nj nk nl na b">max()</code>，<code class="fe nj nk nl na b">map()</code>)，在这些函数中，一行表达式可用于替换使用<code class="fe nj nk nl na b">def</code>关键字的常规函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="aa01" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; students = [{'name': 'John', 'score': 98}, {'name': 'Mike', 'score': 94}, {'name': 'Jennifer', 'score': 99}]<br/>&gt;&gt;&gt; sorted(students, key=lambda x: x['score'])<br/>[{'name': 'Mike', 'score': 94}, {'name': 'John', 'score': 98}, {'name': 'Jennifer', 'score': 99}]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="71dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">15.速记条件赋值</h1><p id="1f6b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个特性主要是一个语法糖。当你需要根据某个条件给一个变量赋值的时候，我们可以用一个简写的赋值，使用这个通用的形式:<code class="fe nj nk nl na b">y = x if condition_met else another_x</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5478" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; some_condition = True<br/>&gt;&gt;&gt; # the expanded format<br/>&gt;&gt;&gt; if some_condition:<br/>...     x = 5<br/>... else:<br/>...     x = 3<br/>&gt;&gt;&gt; print(f'x is {x}')<br/>x is 5<br/>&gt;&gt;&gt; # the shorthand way<br/>&gt;&gt;&gt; x = 5 if some_condition else 3<br/>&gt;&gt;&gt; print(f'x is {x}')<br/>x is 5</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="829a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">16.集合中的成员测试</h1><p id="2e2f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时，我们需要测试某个元素是否存在于一个集合中，然后才能将操作应用于集合或匹配的项目。惯用的方法是使用<code class="fe nj nk nl na b">in</code>关键字。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ea0f" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = ('one', 'two', 'three', 'four', 'five')<br/>&gt;&gt;&gt; if 'one' in a:<br/>...     print('The tuple contains one.')<br/>... <br/>The tuple contains one.<br/>&gt;&gt;&gt; b = {0: 'zero', 1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; if 2 in b.keys():<br/>...     print('The dict has the key of 2.')<br/>... <br/>The dict has the key of 2.</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b877" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">17.使用Get()在字典中检索一个值</h1><p id="814e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们通常可以在方括号中指定键来检索键的值。然而，当字典中不存在这个键时，它会产生一个错误。当然，我们可以使用try/except来解决这个问题。相反，我们可以使用<code class="fe nj nk nl na b">get()</code>方法，该方法允许我们在键不在字典中时使用默认值。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3130" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; number_dict = {0: 'zero', 1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; number_dict[5]<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>KeyError: 5<br/>&gt;&gt;&gt; number_dict.get(5, 'five')<br/>'five'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b488" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">18.获取字典中值最大的键</h1><p id="ecd4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于字典，我们有时需要找出值最大的键。我们可以首先在所有值的列表中找到最大值的索引，然后从另一个存储所有键的列表中找到相应的键。或者，更简单的方法是在<code class="fe nj nk nl na b">max()</code>函数中指定<code class="fe nj nk nl na b">key</code>参数。</p><p id="2426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们不考虑最大值可能有重复的情况。此外，使用<code class="fe nj nk nl na b">min()</code>函数，同样的方法可以应用于寻找具有最小值的键。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b10b" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; model_scores = {'model_a': 100, 'model_z': 198, 'model_t': 150}<br/>&gt;&gt;&gt; # workaround<br/>&gt;&gt;&gt; keys, values = list(model_scores.keys()), list(model_scores.values())<br/>&gt;&gt;&gt; keys[values.index(max(values))]<br/>'model_z'<br/>&gt;&gt;&gt; # one-line<br/>&gt;&gt;&gt; max(model_scores, key=model_scores.get)<br/>'model_z'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="877f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">19.使用Print()函数进行调试</h1><p id="1117" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于较小的项目，我们总是可以使用<code class="fe nj nk nl na b">print()</code>函数来帮助我们调试。我们在教学中也经常使用这个函数。对于<code class="fe nj nk nl na b">print()</code>函数，我们经常使用一些技巧。第一种是结束除默认换行符以外的字符串，第二种是使用f-string，它允许我们创建一个包含一些表达式的字符串。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4bd9" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; for i in range(5):<br/>...     print(i, end=', ' if i &lt; 4 else '\n')<br/>... <br/>0, 1, 2, 3, 4<br/>&gt;&gt;&gt; for i in range(5):<br/>...     print(f'{i} &amp; {i*i}', end=', ' if i &lt; 4 else '\n')<br/>... <br/>0 &amp; 0, 1 &amp; 1, 2 &amp; 4, 3 &amp; 9, 4 &amp; 16</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee8c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">20.海象操作员</h1><p id="7065" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">海象操作符(<code class="fe nj nk nl na b">:=</code>)是Python 3.8+中的一个新特性。它只是赋值表达式的另一个名称，即在表达式中对变量的赋值。通常，当一个表达式使用一个变量时，该变量必须在前面声明。使用walrus运算符，变量赋值可以包含在表达式中，并且变量可以立即使用。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="39ec" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; a = ['j', 'a', 'k', 'd', 'c']<br/>&gt;&gt;&gt; if (n := len(a))%2 == 1:<br/>...     print(f'The number of letters is {n}, which is odd.')<br/>...<br/>The number of letters is 5, which is odd.</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4492" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">21.拆开一根绳子</h1><p id="3ae8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们处理字符串时，将字符串分成单词列表是一项常见的任务。在这种情况下，我们可以使用<code class="fe nj nk nl na b">split()</code>函数，它接受一个分隔符和可选的最大拆分。一个相关的函数是<code class="fe nj nk nl na b">rsplit()</code>函数，它有一个类似的功能，除了它从右边开始拆分，以满足设置时的最大拆分要求。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bb26" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; sentence = 'this is, a python, tutorial, about, idioms.'<br/>&gt;&gt;&gt; sentence.split(', ')<br/>['this is', 'a python', 'tutorial', 'about', 'idioms.']<br/>&gt;&gt;&gt; sentence.split(', ', 2)<br/>['this is', 'a python', 'tutorial, about, idioms.']<br/>&gt;&gt;&gt; sentence.rsplit(', ')<br/>['this is', 'a python', 'tutorial', 'about', 'idioms.']<br/>&gt;&gt;&gt; sentence.rsplit(', ', 2)<br/>['this is, a python, tutorial', 'about', 'idioms.']</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cad2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">22.在Iterable中连接字符串</h1><p id="e1de" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当处理字符串时，我们有时需要通过连接包含在iterable(例如，list、tuple)中的一系列字符串来创建单个字符串。在这种情况下，我们可以使用由所需分隔符调用的<code class="fe nj nk nl na b">join()</code>函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8724" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; words = ('Hello', 'Python', 'Programmers')<br/>&gt;&gt;&gt; '!'.join(words)<br/>'Hello!Python!Programmers'<br/>&gt;&gt;&gt; words_dict = {0: 'zero', 1: 'one', 2: 'two', 3: 'three'}<br/>&gt;&gt;&gt; '&amp;'.join(words_dict.values())<br/>'zero&amp;one&amp;two&amp;three'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="66e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">23.Map()函数</h1><p id="f567" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">map()</code>函数是高阶函数(即使用函数作为参数或返回函数作为输出的函数)。它有一个通用的格式<code class="fe nj nk nl na b">map(function, iterables)</code>，将函数应用于iterable(s)并返回一个<code class="fe nj nk nl na b">map</code>对象，这是一个迭代器。iterables的数量应该与函数所需的参数数量相匹配。</p><p id="15a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，内置的<code class="fe nj nk nl na b">pow()</code>函数需要两个参数。当然，也可以使用自定义函数。顺便提一下，当我们使用<code class="fe nj nk nl na b">map()</code>函数创建一个列表时，我们可以使用列表理解来达到同样的效果。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e99c" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; numbers = (1, 2, 4, 6)<br/>&gt;&gt;&gt; indices = (2, 1, 0.5, 2)<br/>&gt;&gt;&gt; # use map()<br/>&gt;&gt;&gt; list(map(pow, numbers, indices))<br/>[1, 2, 2.0, 36]<br/>&gt;&gt;&gt; # list comprehensions<br/>&gt;&gt;&gt; [pow(x, y) for x, y in zip(numbers, indices)]<br/>[1, 2, 2.0, 36]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2a5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">24.Filter()函数</h1><p id="3a93" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nj nk nl na b">filter()</code>功能是使用指定函数或lambda函数过滤序列。这个函数返回一个过滤器对象，它是一个迭代器。总的来说，它的用法与<code class="fe nj nk nl na b">map()</code>功能非常相似。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a3f7" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; def good_word(x: str):<br/>...     has_vowels = not set('aeiou').isdisjoint(x.lower())<br/>...     long_enough = len(x) &gt; 7<br/>...     good_start = x.lower().startswith('pre')<br/>...     return has_vowels &amp; long_enough &amp; good_start<br/>... <br/>&gt;&gt;&gt; words = ['Good', 'Presentation', 'preschool', 'prefix']<br/>&gt;&gt;&gt; list(filter(good_word, words))<br/>['Presentation', 'preschool']</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de05" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">25.找出列表中最常见的元素</h1><p id="b121" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们使用列表来记录可能有重复元素的东西时，比如说跟踪一系列游戏的获胜者，找出谁赢了最多次是一项相关的任务。这可以通过指定<code class="fe nj nk nl na b">key</code>参数使用<code class="fe nj nk nl na b">max()</code>函数来完成，它将通过集合中元素的计数找出最大值。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ef77" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; winnings = ['John', 'Billy', 'Billy', 'Sam', 'Billy', 'John']<br/>&gt;&gt;&gt; max(set(winnings), key = winnings.count)<br/>'Billy'</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebc9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">26.跟踪列表中元素的频率</h1><p id="b6dc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据上面的例子，我们还想知道非冠军选手在比赛中的表现，这样我们就可以找出第二名和第三名。要做到这一点，我们需要找出每个玩家有多少奖金。我们可以使用字典理解和带有lambda函数的<code class="fe nj nk nl na b">sorted()</code>函数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1362" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; winnings = ['John', 'Billy', 'Billy', 'Sam', 'Billy', 'John']<br/>&gt;&gt;&gt; tracked = {item: winnings.count(item) for item in set(winnings)}<br/>&gt;&gt;&gt; sorted(tracked.items(), key=lambda x: x[1], reverse=True)<br/>[('Billy', 3), ('John', 2), ('Sam', 1)]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b8d6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">27.检查对象的类型</h1><p id="e4e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">检查对象的类型是Python中自省主题的一部分。有时候，我们需要知道一个对象是否属于某种类型，然后再应用相应的函数。为此，我们可以使用<code class="fe nj nk nl na b">type()</code>或<code class="fe nj nk nl na b">isinstance()</code>函数，后者是一种更灵活的方法，允许一对多检查。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2316" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; def check_type(number):<br/>...     if type(number) == int:<br/>...         print('do something with an int')<br/>...     if isinstance(number, (int, float)):<br/>...         print('do something with an int or float')<br/>... <br/>&gt;&gt;&gt; check_type(5)<br/>do something with an int<br/>do something with an int or float<br/>&gt;&gt;&gt; check_type(4.2)<br/>do something with an int or float</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c939" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">28.Any()函数</h1><p id="4e21" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们有一个记录列表，记录了John到达工作地点的时间。一个用例是我们想知道他本周是否迟到，在这种情况下，<code class="fe nj nk nl na b">any()</code>函数非常方便。如果布尔列表中的任何元素为<code class="fe nj nk nl na b">True</code>，该函数将返回<code class="fe nj nk nl na b">True</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7b52" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; arrival_hours = {'Mon': 8.5, 'Tue': 8.75, 'Wed': 9, 'Thu': 8.5, 'Fri': 8.5}<br/>&gt;&gt;&gt; arrival_checks = [x&gt;8.75 for x in arrival_hours.values()]<br/>&gt;&gt;&gt; any(arrival_checks)<br/>True</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="89c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">29.All()函数</h1><p id="50bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">根据上面的同一个例子，我们还想知道他是否整个星期都在9:30之前到达工作地点。为了测试情况是否如此，我们可以使用<code class="fe nj nk nl na b">all()</code>函数，只有当布尔列表中的所有元素都是<code class="fe nj nk nl na b">True</code>时，该函数才返回<code class="fe nj nk nl na b">True</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="063e" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; arrival_checks_all = [x&lt;9.5 for x in arrival_hours.values()]<br/>&gt;&gt;&gt; all(arrival_checks_all)<br/>True</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eba3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">30.对文件使用With关键字</h1><p id="0ec1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们处理一个文件时，我们需要打开它，处理内容，然后关闭它。如果在使用后不关闭文件，该文件可能在一段时间内不可用。在这种情况下，<code class="fe nj nk nl na b">with</code>关键字非常有用。如下图，文件用完后会自动关闭。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4ff2" class="ne md it na b gy nf ng l nh ni">&gt;&gt;&gt; with open('a_file.txt') as file:<br/>...     pass<br/>...<br/>&gt;&gt;&gt; file.closed<br/>True</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="963e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="3171" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文并不打算提供Python编程中惯用用法的详尽列表。相反，它试图向您展示一些常见的习惯用法，其中大部分可以应用到我们的日常Python编码中。</p><p id="58a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一定错过了本文中Python编码的一些习惯用法。因此，如果您想到任何方便的东西与其他Python程序员分享，非常欢迎您留下您的回答。</p></div></div>    
</body>
</html>