<html>
<head>
<title>The Best Way to Use Environment Objects in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中使用环境对象的最佳方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-best-way-to-use-environment-objects-in-swiftui-d9a88b1e253f?source=collection_archive---------0-----------------------#2020-04-21">https://betterprogramming.pub/the-best-way-to-use-environment-objects-in-swiftui-d9a88b1e253f?source=collection_archive---------0-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d938" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究环境对象的用途和功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a887cfe79b9af4a46af4b88e3d5fc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6iorECPNRd8yivYOB76zNg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们应该尽量减少对环境的影响，即使是在SwiftUI应用中。照片由<a class="ae ky" href="https://unsplash.com/@joren78?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Joren </a>在<a class="ae ky" href="https://unsplash.com/s/photos/environment?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI 应用中的<a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2019/226/" rel="noopener ugc nofollow" target="_blank">数据流不同于我们多年来一直致力于开发的任何其他苹果早期命令式UI框架，如UIKit或AppKit。</a></p><p id="ada8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI中，我们可以只声明视图，它总是与数据保持同步。</p><p id="cbab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的视图中的属性可以用<code class="fe lv lw lx ly b">State</code>、<code class="fe lv lw lx ly b">Binding</code>或<code class="fe lv lw lx ly b">Observed</code>、<a class="ae ky" href="https://www.swiftbysundell.com/articles/property-wrappers-in-swift/" rel="noopener ugc nofollow" target="_blank">属性包装器</a>来包装。每当这些包装器提供的属性值发生变化时，视图就会相应地重新绘制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/e41615c518dba682dc2a953608518768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oG-BoAYYQOMKrHalRr5q_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在SwiftUI视图之间共享数据的属性包装器。更新了本演示文稿的第82张幻灯片。</p></figure><p id="2868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，视图应该很小，有私有的<code class="fe lv lw lx ly b">State</code>属性，有一个或几个<code class="fe lv lw lx ly b">Binding</code>或<code class="fe lv lw lx ly b">Observed</code>属性。因为，我们不想经常重新绘制您的视图。</p><p id="4323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是后来，苹果给我们提供了<code class="fe lv lw lx ly b">EnvironmentObject</code>。顾名思义，环境对象可以让我们知道应用程序中任何地方发生的事情，以及许多不相关的视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/afec6e3c8fe2722e29235537e55896cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-p2mRHYlmXvIGwtXwpFBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">环境对象如何跨视图共享数据PC: <a class="ae ky" href="https://devstreaming-cdn.apple.com/videos/wwdc/2019/226mq9pvm28zqfqer2a/226/226_data_flow_through_swiftui.pdf?dl=1" rel="noopener ugc nofollow" target="_blank">苹果</a></p></figure><p id="7091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果为我们提供了一份<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/environmentvalues" rel="noopener ugc nofollow" target="_blank">长列表</a><em class="mb"/><em class="mb"/>环境<em class="mb"> </em>的价值观。</p><p id="aa34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的美好时光中，我们通过<code class="fe lv lw lx ly b">ViewController</code>生命周期方法来了解这些变化，比如当用户改变主题时(是的，<code class="fe lv lw lx ly b">triatCollectionDidChange</code>)，以及<code class="fe lv lw lx ly b">NotificationCenter</code>，比如当用户改变设备方向时。</p><p id="e0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些环境值可以很容易地注入到任何视图中。</p><pre class="kj kk kl km gt mc ly md me aw mf bi"><span id="0b91" class="mg mh it ly b gy mi mj l mk ml">@Environment(\.presentationMode) var presentationMode</span></pre><p id="d7a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图中的上述属性有助于了解当前的显示模式或手动关闭视图。</p><p id="6378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以创建自己的符合<code class="fe lv lw lx ly b">ObservableObject</code>的类，然后把它们变成<code class="fe lv lw lx ly b">EnvironmentObject</code> s</p><p id="aae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它被吹捧为下一级<a class="ae ky" href="https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。我们可以注射任何你想注射的东西，任何你想注射的地方。听起来很熟悉？首先，让我们看看<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/environmentobject" rel="noopener ugc nofollow" target="_blank">苹果文档</a>是怎么说的。</p><blockquote class="mm mn mo"><p id="ad35" class="kz la mb lb b lc ld ju le lf lg jx lh mp lj lk ll mq ln lo lp mr lr ls lt lu im bi translated">每当可观察对象改变时，环境对象使当前视图无效。如果将属性声明为环境对象，请确保通过调用其<em class="it"> environmentObject(_:) </em>方法在祖先视图上设置相应的模型对象。</p></blockquote><p id="2f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么东西很难闻吗？“一定要在祖先视图上设置相应的模型对象”是什么意思？运行时检查？如果检查失败了怎么办？我们马上就知道了。</p><p id="0181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，这里有一个简单的使用Swift  <em class="mb"> </em>教程中<a class="ae ky" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-environmentobject-to-share-data-between-views" rel="noopener ugc nofollow" target="_blank">的例子。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="01df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个视图，一个用于更改分数，另一个用于显示分数。两个视图读取/写入相同的乐谱<code class="fe lv lw lx ly b">environment object</code>。</p><p id="d3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正常工作，我们必须在场景代理中的主机控制器的根视图中注入环境对象，如教程中所述。</p><p id="d35d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们不在根视图中注入环境对象会发生什么呢？</p><pre class="kj kk kl km gt mc ly md me aw mf bi"><span id="9695" class="mg mh it ly b gy mi mj l mk ml">Fatal error: No ObservableObject of type UserSettings found. A View.environmentObject(_:) for UserSettings may be missing as an ancestor of this view.</span></pre><p id="3740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">猜对了没有奖。应用程序崩溃，出现上述错误。为什么这样</p><p id="46d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">环境对象可能只是一个隐式展开的可选对象，我们不知道它的实现细节。</p><p id="846a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这个错误消息非常类似于强制展开nil对象时抛出的错误。此外，很难想到任何其他实现来实现相同的功能。</p><p id="ed9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在回到选项。自古以来，Apple开发人员社区就一直在争论使用这些隐式展开的可选属性是否是一个好的实践。</p><p id="88d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不讨论这个问题，让我们找到一种方法来确保这些环境对象在应用程序启动时被初始化，并且可以在任何视图中使用而不会崩溃。</p><p id="dca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，我们讨论过在应用的任何视图中使用<code class="fe lv lw lx ly b">Environment</code>值的能力。你听起来熟悉吗？老好人单身者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="54c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们把<code class="fe lv lw lx ly b">UserSettings</code>变成了一个<code class="fe lv lw lx ly b">Singleton</code>类，也就是说，它在应用程序启动时被初始化，随时随地都可以使用。</p><p id="43b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使它符合了<code class="fe lv lw lx ly b">ObservableObject</code>协议，所以我们可以在视图中为<code class="fe lv lw lx ly b">UserSettings</code>属性使用<code class="fe lv lw lx ly b">ObserveredObject</code>属性包装器，而不是<code class="fe lv lw lx ly b">EnvironmentObject</code>。</p><p id="ee44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这确保了每当<code class="fe lv lw lx ly b">shared</code> <code class="fe lv lw lx ly b">UserSettings</code>对象中的分数发生变化时，所有观察它的视图都会得到通知，并且每个视图都会相应地更新。</p><p id="569e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe lv lw lx ly b">ObservableSingleton</code>的行为和<code class="fe lv lw lx ly b">EnvironmentObject</code>完全一样，除了如果你注射失败它不会崩溃。实际上，前者为您提供了编译时安全性。正确编译的代码应该正确运行——没有意外的运行时错误。</p><p id="10a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果编译时安全性是您的首要任务，或者您正在与许多开发人员一起开发一个大型SwiftUI项目(这可能不会在不久的将来发生)，那么符合<code class="fe lv lw lx ly b">Observable</code>协议的<code class="fe lv lw lx ly b">Singleton</code>类可能会比<code class="fe lv lw lx ly b">EnvironmentObject</code> s更好地为您服务。</p><p id="a8d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，你知道使用<code class="fe lv lw lx ly b">EnvironmentObject</code>的最佳方法是什么吗？</p><p id="7bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要使用它，或者至少减少它的使用。因为，当你的应用程序运行时，<code class="fe lv lw lx ly b">EnvironmentObject</code>和<code class="fe lv lw lx ly b">ObservableSingleton</code>一直都在内存(RAM)中。</p><p id="30a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在设计你的应用程序时，需要在多个视图间共享很少的属性，并确保这些属性是基本类型和轻量级的。</p><p id="8e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你能设计出没有任何这类属性的app，对你和app都更好。</p><p id="16c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快乐的雨燕！</p></div></div>    
</body>
</html>