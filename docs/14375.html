<html>
<head>
<title>Dart Futures: The Fundamentals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">飞镖期货:基本面</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-futures-in-dart-4edf6db3da90?source=collection_archive---------11-----------------------#2022-12-05">https://betterprogramming.pub/introduction-to-futures-in-dart-4edf6db3da90?source=collection_archive---------11-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fc68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基本概念、著名的构造函数和有用的方法优雅地处理异步任务</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/f05f23dae57a1caaf3dbb41e3a3960b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qs3jUnFDxGbOz-qRpC_u-A.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">按作者分类的标题图像</p></figure><h1 id="61da" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">前言</h1><p id="832b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在现实世界中，法律机构在当事人之间签订的合同涉及在特定时期以特定价格将资产或商品从一方转移(通过销售或租赁)到另一方。</p><p id="7fe1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些合同被称为期货。</p><p id="fe1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Dart语言中，<code class="fe mp mq mr ms b">Future</code>类有一个类似于真实期货合约的工作概念，它存在于现实世界中，因此得名。与现实世界的契约不同，这个契约涉及数据事务。</p><p id="ee3b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">未来为我们提供了一种以更简洁、更易管理的方式处理异步任务的方法。每当我们利用async-await处理我们的异步任务时，Dart强制返回值为Future类型。这使我们能够在不中断程序的情况下解决它。</p><p id="2cc0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于这是一个非常广泛的主题，而且由于它得到了认可和清晰的解释，它也是值得的，因此我决定在这篇文章中介绍基础知识，在另一篇即将发表的文章中介绍一些复杂的概念和实现。</p><p id="a034" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我的目标是:</p><ul class=""><li id="f7c9" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated">提供对<code class="fe mp mq mr ms b">Future</code>的概念性理解，它如何与事件循环一起处理异步任务以及作为指示器的状态。</li><li id="bc56" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">讨论著名的构造函数及其潜在用途。</li><li id="9767" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">讨论涉及的关键方法，以及它们如何帮助我们解决异步操作的麻烦。</li></ul><h1 id="ffc0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">概念理解</h1><p id="6191" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Dart是一种单线程编程语言。它使用事件循环一个接一个地挑选任务，并按顺序执行。这就是Dart如何实现后台执行任务的假象，即使没有后台线程。</p><p id="2495" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mp mq mr ms b">Future</code>为我们提供了访问事件循环和处理异步任务所需的API。它允许我们执行以下操作:</p><ul class=""><li id="7b18" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated">封装任务并发送进行处理</li><li id="bb67" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">确定任务的当前状态及其完成情况</li><li id="cb07" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">如果任务成功，则获取任务的结果</li><li id="0243" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">获取导致任务失败的错误</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nh"><img src="../Images/b0def4e1db7863ef9eecdb762f05d3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n8cLbebmsfUqLdjj"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">图1:事件循环中未来操作的图示</p></figure><p id="0dac" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了跟踪<code class="fe mp mq mr ms b">Future</code>的当前状态，我们依赖于三种不同的状态:</p><ul class=""><li id="e1bf" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated">未完成:任务仍在进行中。</li><li id="7469" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">有数据完成:任务完成，数据准备好。</li><li id="a83f" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">已完成，但有错误:任务已完成，但有错误。</li></ul><p id="1f88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">完成后，我们将使用<code class="fe mp mq mr ms b">then()</code>获得结果，或者使用<code class="fe mp mq mr ms b">catchError()</code>获得抛出的错误。它看起来会像这样:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="c5bf" class="nm kx iq ms b be nn no l np nq">var list = coffeeList<br/>               .then((value) =&gt; (value)) // Success<br/>               .catchError((error) =&gt; (error)); // Failure</span></pre><p id="0067" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些状态使我们能够轻松地处理异步过程中的UI转换。我们可以在状态未完成时显示加载UI，在数据完成时显示数据，或者在完成时显示错误弹出窗口。</p><p id="88cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里需要注意的一点是，未来的API和方法也与JavaScript中的<code class="fe mp mq mr ms b">Promise</code>对象非常相似。我们可以观察<code class="fe mp mq mr ms b">then()</code>的用法，以及它是如何通过解析未来来解包数据的。</p><p id="6946" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于与<code class="fe mp mq mr ms b">Promise</code>的相似性，有JavaScript经验的开发者会发现更容易理解未来的用法和方法。</p><h1 id="12f4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在开始之前</h1><p id="e253" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们探索各种概念之前，让我们为我们的实验建立一个基础。</p><p id="53b4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设我们开发了一个应用程序，可以让我们更容易地在街对面的当地咖啡店里看到最新的咖啡。</p><p id="fe59" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的热咖啡数据将来自这里:<code class="fe mp mq mr ms b"><a class="ae nr" href="https://api.sampleapis.com/coffee/hot" rel="noopener ugc nofollow" target="_blank">https://api.sampleapis.com/coffee/hot</a></code></p><p id="b71e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个API返回给我们一个热咖啡的数组，单个对象看起来像这样:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="c928" class="nm kx iq ms b be nn no l np nq">{<br/>  "title":"Black",<br/>  "description":"Black coffee is as simple as it gets with ground coffee beans steeped in hot water, served warm.",<br/>  "ingredients":[<br/>     "Coffee"<br/>  ],<br/>  "image":"https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/A_small_cup_of_coffee.JPG/640px-A_small_cup_of_coffee.JPG",<br/>  "id":1<br/>}</span></pre><h1 id="0eed" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">著名的建筑商</h1><p id="7c1b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">构造函数是我们用来初始化一个类实例的方法。当创建一个<code class="fe mp mq mr ms b">Future</code>的实例时，一些构造函数会非常方便，给我们带来一些关键的好处。</p><h1 id="523e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">未来()</h1><p id="3139" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们继续讨论更复杂的<code class="fe mp mq mr ms b">Future</code>构造函数的实现之前，让我们先来看看初始化它的一个非常基本的方法。基于上面提到的问题，我们可以创建一个<code class="fe mp mq mr ms b">Future</code>来获取数据，如下所示:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="8c3c" class="nm kx iq ms b be nn no l np nq">void main() {<br/>  Future&lt;http.Response&gt; coffeeData =<br/>      http.get(Uri.parse('https://api.sampleapis.com/coffee/hot'));<br/>}</span></pre><p id="541a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个<code class="fe mp mq mr ms b">coffeeData</code>现在保存了我们需要的数据，我们可以通过使用<code class="fe mp mq mr ms b">then()</code>很容易地解决这个问题，并且我们可以通过使用<code class="fe mp mq mr ms b">catchError()</code>来查看是否有错误。就这么简单。</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="19a9" class="nm kx iq ms b be nn no l np nq">coffeeData.then((value) =&gt; (value)) // Success<br/>.catchError((error) =&gt; (error)); // Failure</span></pre><h1 id="3f99" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Future.delayed()</h1><h2 id="8c8f" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">问题陈述</h2><p id="9e77" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在开发的早期阶段，我们可能没有从中获取数据的API，因为它可能由后端团队开发。</p><p id="20c1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们需要开发我们的coffee应用程序的UI，因为设计已经准备好了，并且我们有一组样本数据可用于表示层。</p><p id="bf9f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们如何模拟一个HTTP请求和响应的假象来开发UI，并很好地考虑加载和成功状态？</p><h2 id="a6bd" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">解决办法</h2><p id="bfb7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是我们可以利用<code class="fe mp mq mr ms b">Future.delayed()</code>构造函数的地方。这个构造函数使我们能够创建一个<code class="fe mp mq mr ms b">Future</code>任务，该任务在我们指定的延迟时间后在其封装内运行。</p><p id="78a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，如果我们想要开发一个加载屏幕，它将在获取发生时显示，然后在没有实际API存在的情况下显示UI，我们可以这样做:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="008e" class="nm kx iq ms b be nn no l np nq">void main() {<br/>  List&lt;Coffee&gt; coffeeList = [<br/>    const Coffee(<br/>      id: 1,<br/>      title: 'Black',<br/>      description:<br/>          "If you want to sound fancy, you can call black coffee by its proper name: cafe noir.",<br/>      ingredients: ['Coffee'],<br/>      image:<br/>          "https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/A_small_cup_of_coffee.JPG/640px-A_small_cup_of_coffee.JPG",<br/>    )<br/>  ];<br/><br/>  Future.delayed(const Duration(milliseconds: 2000), () {<br/>   // The code below will be executed after a delay of 2 seconds<br/>      return coffeeList;<br/>   });<br/>}</span></pre><p id="532e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从上面的代码中可以看出，我们使用了<code class="fe mp mq mr ms b">Future.delayed()</code>将模拟数据的返回延迟了两秒钟。这使我们能够创建一个请求-响应的错觉。</p><p id="169e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们可以开发加载屏幕和结果屏幕，并且我们也可以在不依赖API的情况下看到它的运行。</p><h1 id="55d2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Future.error()</h1><h2 id="4142" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">问题陈述</h2><p id="3c24" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们模拟了这样一个场景:在数据列表返回给我们之前，我们可以有一个加载状态。因此，我们已经完成了咖啡应用程序的开发，有了一个加载UI和一个可以显示的咖啡列表。但是<code class="fe mp mq mr ms b">Future.delayed()</code>总是返回一个正值。</p><p id="34e0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们想要模拟一个请求由于某种原因而失败的场景，会怎么样呢？</p><h2 id="b81a" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">解决办法</h2><p id="ed62" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这就是<code class="fe mp mq mr ms b">Future.delayed()</code>出现的原因。我们可以创建一个<code class="fe mp mq mr ms b">Future</code>，它将返回一个错误而不是一个正值，并使用它来开发相应的失败场景UI。我们可以简单地这样做:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="b336" class="nm kx iq ms b be nn no l np nq">void main() {  <br/>final Future&lt;Exception&gt; apiErrorTest = Future.delayed(const Duration(milliseconds: 2000), () {<br/>    // The code below will return an error after a delay of 2 seconds<br/>    return Future.error(<br/>      Exception('Failed to fetch data from coffee endpoint.'), // Throw<br/>    );<br/>  });<br/>}</span></pre><p id="471d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从上面的代码中可以看出，我们通过使用<code class="fe mp mq mr ms b">Future.delayed()</code>来延迟响应，但是这次它返回一个<code class="fe mp mq mr ms b">Future.error()</code>，其中包含一个异常。利用这一点，我们可以模拟API fetch调用的失败。</p><h1 id="fe55" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">有用的方法</h1><p id="9f62" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将在本节讨论四个主要方法，我认为它们对于作为异步事件处理程序的<code class="fe mp mq mr ms b">Future</code>的整体功能非常重要。</p><h2 id="8497" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">然后()</h2><p id="6b93" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文的几个地方已经给出了这个方法如何工作的例子，但是并没有专门讨论它。<code class="fe mp mq mr ms b">then()</code>是一个回调方法，它允许我们解析在<code class="fe mp mq mr ms b">Future</code>中给我们的契约，如果成功的话，就获得<code class="fe mp mq mr ms b">Future</code>持有的结果。</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="c86c" class="nm kx iq ms b be nn no l np nq">void main() {<br/>  Future&lt;http.Response&gt; coffeeData =<br/>      http.get(Uri.parse('https://api.sampleapis.com/coffee/hot'));<br/><br/>  coffeeData.then((value) =&gt; (value));<br/>}</span></pre><p id="3d29" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，<code class="fe mp mq mr ms b">then()</code>为我们提供了从API调用中获得的咖啡列表。</p><p id="9aba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是如果失败了呢？如果我们从表面上看，调用似乎会无声无息地失败，使我们无法捕捉错误。但是如果我们看看底层的实现，它有一个<code class="fe mp mq mr ms b">onError</code>函数调用:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="5db1" class="nm kx iq ms b be nn no l np nq">Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; onValue(T value), {Function? onError});</span></pre><p id="1074" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这使得<code class="fe mp mq mr ms b">then()</code>能够通过全局错误处理程序捕获错误，该处理程序在整个应用程序中捕获未被捕获的错误。这种回退的存在是为了确保错误不会无声无息地失败。</p><h2 id="e36b" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">catchError()</h2><p id="5b9b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经看到了<code class="fe mp mq mr ms b">then()</code>如何在成功时返回一个值，并且仍然报告一个错误而不让它无声地失败。尽管依靠全局错误处理程序可以做到这一点，但通常建议注册一个单独的错误处理程序来优雅地处理错误。</p><p id="367a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是<code class="fe mp mq mr ms b">catchError()</code>出现的原因。与<code class="fe mp mq mr ms b">then()</code>类似，<code class="fe mp mq mr ms b">catchError()</code>也是一个回调函数。该方法不能单独使用，需要与<code class="fe mp mq mr ms b">then()</code>配合使用，以提供整体解决方案。但是与<code class="fe mp mq mr ms b">then()</code>不同的是，<code class="fe mp mq mr ms b">catchError()</code>抛出了异步操作的错误:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="9ced" class="nm kx iq ms b be nn no l np nq">void main() {<br/>  Future&lt;http.Response&gt; coffeeData =<br/>      http.get(Uri.parse('https://api.sampleapis.com/coffee/hot'));<br/><br/>  coffeeData.then((value) =&gt; (value))<br/>    .catchError((error) =&gt; (error));<br/>}</span></pre><p id="e0bd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，如果API调用失败，我们可以通过<code class="fe mp mq mr ms b">catchError((error) =&gt; (error))</code>代码块来处理错误。</p><p id="4608" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mp mq mr ms b">catchError()</code>允许我们向它添加测试。下面我们来看看它的实现:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="e6f5" class="nm kx iq ms b be nn no l np nq">Future&lt;T&gt; catchError(Function onError, {bool test(Object error)?});</span></pre><p id="e863" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从实现中我们可以看到，我们可以有选择地向<code class="fe mp mq mr ms b">catchError()</code>添加测试。这使我们能够知道我们面临着什么样的错误。让我们看一个测试的例子:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="4c89" class="nm kx iq ms b be nn no l np nq">coffeeListFuture.then((value) =&gt; (coffeeList = getCoffeeList(value)))<br/>  // Custom error catch block<br/>  .catchError(<br/>  (<br/>    Object error,<br/>    StackTrace stackTrace,<br/>  ) {<br/>    print(error.toString());<br/>  },<br/>  test: (Object error) {<br/>      return error is HttpException;<br/>  }<br/>);</span></pre><p id="66bc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的代码块中，我们可以看到一个<code class="fe mp mq mr ms b">catchError()</code>回调被添加了一个测试来检查它是否是HTTP异常类型。如果测试返回一个<code class="fe mp mq mr ms b">true</code>布尔值，那么我们可以根据HTTP异常的特定业务需求来处理这个异常。</p><h2 id="5e4b" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">问题陈述</h2><p id="b258" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">包含测试的缺点是这个<code class="fe mp mq mr ms b">catchError()</code>块将只捕捉通过测试的错误。那些不适合这个测试的将作为未捕获的错误被抛出。我们如何捕捉那些不合适的？如果我们需要识别不同类型的错误，而不仅仅是一种错误，会怎么样？</p><h2 id="0571" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">解决办法</h2><p id="306e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这就是向同一个<code class="fe mp mq mr ms b">Future</code>注册多个<code class="fe mp mq mr ms b">catchError()</code>方法的能力发挥作用的地方。我们可以有不止一个<code class="fe mp mq mr ms b">catchError()</code>方法，每个方法监听一个特定类型的错误。让我们看看下面的代码是如何做到的:</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="a5b5" class="nm kx iq ms b be nn no l np nq">  coffeeListFuture.then((value) =&gt; (coffeeList = getCoffeeList(value)))<br/>    // Custom error catch block<br/>    .catchError(<br/>        (<br/>          Object error,<br/>          StackTrace stackTrace,<br/>        ) {<br/>          print(error.toString());<br/>        },<br/>        test: (Object error) =&gt; error is CustomException)<br/>    // Http error catch block<br/>    .catchError(<br/>        (<br/>          Object error,<br/>          StackTrace stackTrace,<br/>        ) {<br/>          print(error.toString());<br/>        },<br/>        test: (Object error) =&gt; error is HttpException)</span></pre><p id="1934" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，我们可以看到两个<code class="fe mp mq mr ms b">catchError()</code>方法被绑定到一个<code class="fe mp mq mr ms b">Future</code>，第一个<code class="fe mp mq mr ms b">catchError()</code>捕捉我们定义的自定义错误，第二个让我们能够捕捉HTTPS异常。</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="67dc" class="nm kx iq ms b be nn no l np nq">coffeeListFuture.then((value) =&gt; (coffeeList = getCoffeeList(value)))<br/>    // Http error catch block<br/>    .catchError(<br/>        (<br/>          Object error,<br/>          StackTrace stackTrace,<br/>        ) {<br/>          print(error.toString());<br/>        },<br/>        test: (Object error) =&gt; error is HttpException)<br/>    // General error catch block<br/>    .catchError(<br/>        (error) =&gt; print(error)<br/>);</span></pre><p id="77d4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，我们创建了一个自动防故障装置来捕获不属于<code class="fe mp mq mr ms b">HttpException</code>类型的错误，以避免错误被视为未处理的异常。</p><p id="e01c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">能够附加多个<code class="fe mp mq mr ms b">catchError()</code>，允许我们为应用程序定义不同的错误处理方式。它允许我们以不同的方式处理多种错误场景，改善应用程序的整体用户体验。</p><h1 id="f9a5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">当完成时()</h1><p id="e9d6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">不管单个异步任务的结果如何，应用程序都需要连续性。上面我们已经讨论了两个场景，一个是任务成功的积极场景，一个是任务失败的消极场景，分别使用<code class="fe mp mq mr ms b">then()</code>和<code class="fe mp mq mr ms b">catchError()</code>。</p><h2 id="b40c" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">问题陈述</h2><p id="14a0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">但是，如果我们想让一段代码运行，而不管异步任务的结果如何呢？假设我们想调用一个方法来获取冷咖啡的列表，而不管端点是否能提供热咖啡的列表，那会怎么样呢？</p><h2 id="d2c9" class="ns kx iq bd ky nt nu dn lc nv nw dp lg lx nx ny li mb nz oa lk mf ob oc lm od bi translated">解决办法</h2><p id="2796" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这就是<code class="fe mp mq mr ms b">whenComplete()</code>出现的原因。这个方法允许我们执行代码，不管<code class="fe mp mq mr ms b">Future</code>完成时是有结果还是有错误，代码都会运行。</p><p id="d15d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于我们这些来自JavaScript背景的人来说，这与<code class="fe mp mq mr ms b">finally()</code>对<code class="fe mp mq mr ms b">Promise</code>的作用是一样的。</p><p id="f258" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看这是如何实现的。我们将创建一个函数，根据端点是<code class="fe mp mq mr ms b">hot</code>还是<code class="fe mp mq mr ms b">cold</code>，返回一个包含咖啡列表的HTTP响应<code class="fe mp mq mr ms b">Future</code>。</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="4f78" class="nm kx iq ms b be nn no l np nq">Future&lt;http.Response&gt; fetchCoffeeData({required String coffeeTemp}) async {<br/>  const baseURL = 'https://api.sampleapis.com/';<br/>  final coffeeResponse =<br/>      await http.get(Uri.parse(baseURL + '/coffee/' + coffeeTemp));<br/><br/>  if (coffeeResponse.statusCode == 200) {<br/>    return coffeeResponse;<br/>  } else {<br/>    throw Exception('Failed to fetch coffees');<br/>  }<br/>}</span></pre><p id="6d6f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，让我们创建一个<code class="fe mp mq mr ms b">Future</code>并将<code class="fe mp mq mr ms b">then()</code>、<code class="fe mp mq mr ms b">catchError()</code>和<code class="fe mp mq mr ms b">whenComplete()</code>附加到它，以演示我们一直在讨论的内容。</p><pre class="kh ki kj kk gt ni ms nj bn nk nl bi"><span id="c1a0" class="nm kx iq ms b be nn no l np nq">Future&lt;http.Response&gt; coffeeListFuture = fetchCoffeeData(coffeeTemp: 'hot');<br/><br/>  coffeeListFuture<br/>      .then((value) =&gt; value)<br/>      .catchError((error) =&gt; error)<br/>      .whenComplete(() =&gt; fetchCoffeeData(coffeeTemp: 'cold'));</span></pre><p id="32cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">可以看到，我们可以执行一条指令来获取冷咖啡列表，而不管<code class="fe mp mq mr ms b">coffeeListFuture</code>的结果如何。这让我们清楚地知道在初始<code class="fe mp mq mr ms b">Future</code>完成后需要立即发生什么。</p><h1 id="8a02" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="88f0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">从上面提供的讨论和解释中，我们已经涵盖了围绕<code class="fe mp mq mr ms b">Future</code>类的关键概念，以及在处理异步任务时它是如何使我们的生活变得更容易的。</p><p id="ccde" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望现在阅读这篇文章的人能够很好地理解以下内容:</p><ul class=""><li id="fe36" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe mp mq mr ms b">Future</code>如何在单线程环境下运行，方便我们与事件循环交互。</li><li id="5fb7" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">怎么，本质上和JavaScript里的<code class="fe mp mq mr ms b">Promise</code>很像。</li><li id="b649" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">我们如何使用它来处理异步任务</li><li id="8f1c" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">我们如何使用<code class="fe mp mq mr ms b">Future</code>来模拟API加载</li><li id="52ef" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">如何知道异步调用是成功的还是失败的</li><li id="fb1c" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">如何使用构造函数模拟API调用的加载、成功和错误状态。</li><li id="cbca" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">我们有哪些值得注意的方法，为什么我们需要它们通过期货来处理异步任务。</li></ul><p id="41a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我将在另一篇文章中讨论使用Futures解决更复杂的编程问题的方法。</p></div></div>    
</body>
</html>