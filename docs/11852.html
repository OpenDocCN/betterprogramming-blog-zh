<html>
<head>
<title>Type Placeholders: A Look at the New Swift 5.6 Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型占位符:Swift 5.6新功能一览</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/type-placeholders-new-swift-5-6-feature-12738e93054?source=collection_archive---------12-----------------------#2022-04-21">https://betterprogramming.pub/type-placeholders-new-swift-5-6-feature-12738e93054?source=collection_archive---------12-----------------------#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d118" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Swift 5.6最近引入了类型占位符。了解一项新的有用的Swift功能。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b3e615e00a703c2b3a34df021ed7f612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RV-cMIUn2xDaWzsqb-7f9g.png"/></div></div></figure><p id="45b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Swift 5.6最近引入了类型占位符。是的，它们是强大的Swift型推理系统的一个很好的附件。如果你熟悉C++，你一定知道一个<code class="fe ln lo lp lq b">auto</code>关键字。类型占位符<em class="lr">几乎</em>一样。</p><h1 id="8ff4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">泛型和类型占位符</h1><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="1a56" class="mo lt iq lq b gy mp mq l mr ms">let number: _ = 42 // Type placeholder<br/>let anotherNumber = 42</span></pre><p id="e986" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，Swift可以推断变量的类型，但是类型占位符意味着用于包含多种类型的类型。仿制药。那才是他们真正发光的地方。</p><p id="cfe1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑常规的<code class="fe ln lo lp lq b">Result</code>枚举</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="046e" class="mo lt iq lq b gy mp mq l mr ms">enum Result&lt;Success, Failure&gt; where Failure : Error {<br/>    case success(Success)<br/>    case failure(Failure)<br/>}</span></pre><p id="b46c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们有某种复杂的物体呢</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="2cdb" class="mo lt iq lq b gy mp mq l mr ms">var ohMy = [1: [3: (1, 2, 3, "That's a long tuple")]]</span></pre><p id="d19b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你试图从<code class="fe ln lo lp lq b">ohMy</code>创建一个<code class="fe ln lo lp lq b">Result</code>，你会看到编译错误。</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="4575" class="mo lt iq lq b gy mp mq l mr ms">let result = Result.success(ohMy)</span></pre><blockquote class="mt mu mv"><p id="1b9d" class="kr ks lr kt b ku kv jr kw kx ky ju kz mw lb lc ld mx lf lg lh my lj lk ll lm ij bi translated">注意:无法推断通用参数<code class="fe ln lo lp lq b">Failure</code></p></blockquote><p id="beaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">兄弟。所以我需要写…</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="38b5" class="mo lt iq lq b gy mp mq l mr ms">let result = Result&lt;[Int : [Int : (Int, Int, Int, String)]], Error&gt;.success(ohMy)</span></pre><blockquote class="mt mu mv"><p id="084d" class="kr ks lr kt b ku kv jr kw kx ky ju kz mw lb lc ld mx lf lg lh my lj lk ll lm ij bi translated">💡使用类型占位符来省略Swift可以推断的类型</p></blockquote><p id="a6dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多亏了类型占位符，Swift可以自己推断对象的类型。所以，我们只需要提供<code class="fe ln lo lp lq b">Failure</code>类型。</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="e813" class="mo lt iq lq b gy mp mq l mr ms">let result = Result&lt;_, Error&gt;.success(ohMy) // Nice</span></pre><h1 id="02a2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">集合和类型占位符</h1><p id="ca97" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">这个特性对于集合也很有用。如果我们需要一个带有枚举键的字典呢？</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="125c" class="mo lt iq lq b gy mp mq l mr ms">enum Foo {<br/>	case bizz<br/>	case bonk<br/>}<br/><br/>let results = [<br/>	.bizz: ohMy,<br/>	.bonk: ohMy<br/>]</span></pre><blockquote class="mt mu mv"><p id="09e2" class="kr ks lr kt b ku kv jr kw kx ky ju kz mw lb lc ld mx lf lg lh my lj lk ll lm ij bi translated">没有上下文类型，无法解析对成员<code class="fe ln lo lp lq b">bizz</code>的引用</p></blockquote><p id="5d15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，让我们提供这个<em class="lr">上下文类型，</em>但是你还记得<code class="fe ln lo lp lq b">ohMy</code>的类型有多难看吗？让我们使用一个类型占位符。</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="c475" class="mo lt iq lq b gy mp mq l mr ms">// 🚫<br/>let results:[Foo: [Int : [Int : (Int, Int, Int, String)]]] = [<br/>	.bizz: ohMy,<br/>	.bonk: ohMy<br/>]<br/><br/>// ✅<br/>let results:[Foo: _] = [<br/>	.bizz: ohMy,<br/>	.bonk: ohMy<br/>]</span></pre><h2 id="d5ff" class="mo lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">更多示例</h2><p id="141c" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">包含占位符的类型示例有:</p><pre class="kg kh ki kj gt mk lq ml mm aw mn bi"><span id="8455" class="mo lt iq lq b gy mp mq l mr ms">Array&lt;_&gt;    // array with placeholder element type<br/>[Int: _]    // dictionary with placeholder value type<br/>(_) -&gt; Int  // function type accepting a single type placeholder argument and returning 'Int'<br/>(_, Double) // tuple type of placeholder and 'Double'<br/>_?          // optional wrapping a type placeholder</span></pre></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="6852" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个很棒的特性，扩展了Swift的类型推断能力。就目前而言，它的知名度相对较低，但我认为它在未来会被更多地使用。</p><p id="17e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在我之前的帖子中查看其他不太为人所知的Swift功能:</p><div class="nw nx gp gr ny nz"><a href="http://alexdremov.me/top-7-subtle-swift-features/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">7大微妙的Swift特性| Alex Dremov</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">Alex Dremov iniOS &amp; Swift-在这里，我收集了一些不太为人所知的Swift功能，在您准备…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">alexdremov.me</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div><h2 id="1c7c" class="mo lt iq bd lu ne nf dn ly ng nh dp mc la ni nj me le nk nl mg li nm nn mi no bi translated">参考</h2><ul class=""><li id="a5b6" class="oo op iq kt b ku mz kx na la oq le or li os lm ot ou ov ow bi translated"><a class="ae ox" href="https://github.com/apple/swift-evolution/blob/main/proposals/0315-placeholder-types.md" rel="noopener ugc nofollow" target="_blank">swift-evolution/0315-placeholder-types . MD at main apple/swift-evolution</a></li></ul></div></div>    
</body>
</html>