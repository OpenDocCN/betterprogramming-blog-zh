<html>
<head>
<title>Top TypeScript Features Released in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年发布的顶级类型脚本功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-typescript-features-released-in-2021-426905a9c6e7?source=collection_archive---------10-----------------------#2022-01-03">https://betterprogramming.pub/top-typescript-features-released-in-2021-426905a9c6e7?source=collection_archive---------10-----------------------#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc31" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概述2022年将使用的新功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aff1a3d36fb1a91db58a9640484ca15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxQ70lyQb6Ers3W5zsC2lA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7905" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Typescript以一个伟大的<code class="fe lu lv lw lx b">4.1</code>发布结束了2020年。在那里，推出了期待已久的<code class="fe lu lv lw lx b">Template Literal String</code>和<code class="fe lu lv lw lx b">Remapping</code>功能。这些为许多可能性和模式打开了大门。</p><p id="e275" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，那次<code class="fe lu lv lw lx b">4.1</code>发布只是为<code class="fe lu lv lw lx b">Template Literal Types</code>做铺垫。随着2021版本的发布，这一特性已经变得越来越成熟。例如，在<code class="fe lu lv lw lx b">4.5</code>发布之后，我们现在可以使用<code class="fe lu lv lw lx b">Template Literal Types</code>作为union discriminates。</p><p id="66a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在2021年，已经有4个Typescript版本。它们包含了许多优秀的特性。核心和开发人员体验得到了显著改善。在这篇文章中，我将总结我2021年的首选。这些对我的日常打字工作有着更大的影响。</p><p id="64f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想检查任何版本，特别是，我会在文章的最后链接这些。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="ec82" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.元组中的前导/中间元素</h1><p id="03aa" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">Tuple基本类型早就出现在Typescript中了。它允许我们表达固定数量的数组类型元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7c87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将可选元素定义为元组的一部分:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="66d1" class="ni mg it lx b gy nj nk l nl nm">// ✅ last 2 elements are optional<br/>let arrayOptions: <strong class="lx iu">[string, boolean?, boolean?]</strong>;</span><span id="b503" class="ni mg it lx b gy nn nk l nl nm">// ❌ A required element cannot follow an optional element<br/>let arrayOptions: <strong class="lx iu">[string, boolean?, boolean]</strong>;</span></pre><p id="e5db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用可选的修饰符，我们暗示我们的数组可以有多种长度。我们甚至可以更进一步，定义一个类型的动态长度数组:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="6b48" class="ni mg it lx b gy nj nk l nl nm">// ✅ last 2 elements are optional<br/>let arrayOptions: <strong class="lx iu">[</strong>string, <strong class="lx iu">...boolean[]]</strong>;</span><span id="ac8d" class="ni mg it lx b gy nn nk l nl nm">// the below will be all valid<br/>arrayOptions = ['foo', true];<br/>arrayOptions = ['foo', true, true];<br/>arrayOptions = ['foo', true, true, false];</span></pre><p id="2dae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个新的TypeScript中，版本元组变得更加强大。以前，我们可以使用spread操作符，但是我们不能定义最后的元素类型。</p><p id="5f11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在<code class="fe lu lv lw lx b">4.2</code>发布之前，类似上面的内容是无效的:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="950b" class="ni mg it lx b gy nj nk l nl nm">// ❌ An optional element cannot follow a rest element.<br/>let arrayOptions: [string, ...boolean[], number?];</span></pre><p id="6500" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">4.2</code>之前，rest操作符必须总是元组中的最后一个元素。在<code class="fe lu lv lw lx b">4.2</code>版本中，这不再是一个要求。没有这种限制，我们可以添加任意多的尾随元素。然而，我们不能在spread操作符后添加可选元素。</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="7411" class="ni mg it lx b gy nj nk l nl nm">// ❌ Prior to 4.2, Error: rest element must be last in a tuple type<br/>let arrayOptions: <strong class="lx iu">[string, ...boolean[], number]</strong>;</span><span id="3fd6" class="ni mg it lx b gy nn nk l nl nm">// ✅ works from 4.2<br/>let arrayOptions: <strong class="lx iu">[string, ...boolean[], number]</strong>;</span><span id="3e63" class="ni mg it lx b gy nn nk l nl nm">// ❌ Error: An optional element cannot follow a rest element<br/>let arrayOptions: <strong class="lx iu">[string, ...boolean[], number?]</strong>;</span></pre><p id="d7bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在下面的例子中详细了解一下:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="80e8" class="ni mg it lx b gy nj nk l nl nm">let arrayOptions: <strong class="lx iu">[string, ...boolean[], number]</strong>;<br/>arrayOptions = ['config', 12]; // works</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="7c5a" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.始终如一的承诺检查中的错误</h1><p id="e7f9" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">从<code class="fe lu lv lw lx b">4.3</code>版本开始，作为<code class="fe lu lv lw lx b">strictNullChecks</code>配置的一部分，当断言一个承诺时，TypeScript将给出一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d8dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe lu lv lw lx b">if (promise)</code>条件总是为<code class="fe lu lv lw lx b">true</code>，编译器要求我们改变<code class="fe lu lv lw lx b">if</code>语句。</p><p id="421e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在配置编译器选项中没有额外的标志来配置它。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="26a4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.类型保护引用保存在常量/只读变量中</h1><p id="60d3" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">Typescript现在将在断言if语句时做一些额外的工作。如果变量是一个<code class="fe lu lv lw lx b">const</code>或<code class="fe lu lv lw lx b">readonly</code>，它将保留它的类型保护(如果有的话)。</p><p id="3bc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们检查以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ef62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe lu lv lw lx b">isString</code>变量在<code class="fe lu lv lw lx b">let</code>范围内，上面的代码就不会工作。不考虑类型保护，代码将失败，如下所示:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="a496" class="ni mg it lx b gy nj nk l nl nm">// isString is instead declared as let<br/><strong class="lx iu">let isString</strong> = typeof text === "string";</span><span id="e6bc" class="ni mg it lx b gy nn nk l nl nm">// ❌ this statement won't work as a Type Guard<br/><strong class="lx iu">if (isString) {<br/></strong> ...<br/>}</span></pre><h2 id="2a72" class="ni mg it bd mh no np dn ml nq nr dp mp lh ns nt mr ll nu nv mt lp nw nx mv ny bi translated">组合多个变量</h2><p id="b644" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">类型保护别名现在更加智能，甚至可以理解多个变量的组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="47ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">bothNonEmpty</code>常量变量保存两种类型守卫的信息。所以<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>都是<code class="fe lu lv lw lx b">if</code>语句中的<code class="fe lu lv lw lx b">string</code>类型。</p><h2 id="9a61" class="ni mg it bd mh no np dn ml nq nr dp mp lh ns nt mr ll nu nv mt lp nw nx mv ny bi translated">它是过渡性的</h2><p id="916e" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">当组合具有关联类型保护的变量时，这些变量仍将被传播。这意味着它将能够根据需要组合任意多的类型保护，而不会丢失任何类型信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c853" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在上面的例子中看到,<code class="fe lu lv lw lx b">bothNonEmpty</code>属性保留了类型保护信息。</p><p id="e6f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">综上所述，<code class="fe lu lv lw lx b">Control Flow Analysis</code>已经有了很大的改进。最好的部分是这将在Typescript <code class="fe lu lv lw lx b">4.4</code>中开箱即用。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4638" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.精确的可选属性类型</h1><p id="b8e8" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">当使用Typescript时，有一个反复出现的争论:使属性可选还是使属性<code class="fe lu lv lw lx b">undefined</code>？这确实取决于个人偏好。</p><p id="147b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那是什么问题呢？Typescript编译器以同样的方式处理这两者。这导致代码不一致和一些摩擦。</p><p id="90f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5138" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了结束这种不一致性，Typescript现在包含了一个标志:<code class="fe lu lv lw lx b">--exactOptionalPropertyTypes</code>。启用后，当试图将可选值视为可空值时会显示错误，反之亦然🚀</p><p id="4405" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们检查一个将<code class="fe lu lv lw lx b">--exactOptionalPropertyTypes</code>设置为true的代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a44d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有启用<code class="fe lu lv lw lx b">--exactOptionalPropertyTypes</code>，上面的代码都不会有问题。</p><p id="ea47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了防止任何破坏性的改变，它在默认情况下被禁用。由我们来决定它是否是一个值得拥有的特性。在我看来，这是必须的。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="961f" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.符号和模板文字字符串的索引签名</h1><p id="0071" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">该功能是已经工作了三年的<code class="fe lu lv lw lx b">Generalized index signatures</code>的超集。可以在<a class="ae nz" href="https://github.com/microsoft/TypeScript/pull/26797" rel="noopener ugc nofollow" target="_blank">这里</a>找到那个PR。</p><p id="eff7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Typescript <code class="fe lu lv lw lx b">4.4</code>现在支持索引签名中的<code class="fe lu lv lw lx b">symbol</code>、<code class="fe lu lv lw lx b">unions</code>和<code class="fe lu lv lw lx b">template literal string</code>。只要是由<code class="fe lu lv lw lx b">string</code>、<code class="fe lu lv lw lx b">number</code>或<code class="fe lu lv lw lx b">symbol</code>组成的工会都是支持的。</p><p id="36d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">symbol</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="03fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">literal template string</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b52e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过能够使用联合，我们可以减少许多样板文件。我们可以更好地表达我们的接口和类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="186b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">索引签名仍然不完美。它们有局限性。他们仍然不支持<code class="fe lu lv lw lx b">Generic Types</code>也不支持<code class="fe lu lv lw lx b">Template Literal Types</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="671b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，这仍然是一个很棒的特性，它将帮助我们用更少的代码行创建更强大的界面。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="a1d8" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">6.等待的类型</h1><p id="b908" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在<code class="fe lu lv lw lx b">4.5</code>之前，为了获得承诺的返回类型，我们必须使用<code class="fe lu lv lw lx b">infer</code>功能，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8eb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">4.5</code>版本带有一种新型<code class="fe lu lv lw lx b">Awaited</code>。我们不需要像上面描述的<code class="fe lu lv lw lx b">Unwarp</code>那样的自定义映射类型。</p><p id="6154" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看它的语法:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="0210" class="ni mg it lx b gy nj nk l nl nm">type Result = <strong class="lx iu">Awaited</strong>&lt;T&gt;;</span></pre><p id="c75e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些不同的用例示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="eb44" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">7.仅限类型的导入说明符</h1><p id="30e7" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">从版本<code class="fe lu lv lw lx b">3.8</code>开始，我们可以通过将<code class="fe lu lv lw lx b">type</code>添加到<code class="fe lu lv lw lx b">import</code>关键字来显式使用类型导入。这确实告诉TypeScript编译器该导入只包括Typescript类型。这有什么关系？在将代码转换为JavaScript时，TSC可以安全地对导入进行分段。</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="f2e9" class="ni mg it lx b gy nj nk l nl nm">// ✅ importing the FC type from React<br/>import <strong class="lx iu">type</strong> { FC } from 'react';<br/>import { useEffect } from 'react';</span></pre><p id="2890" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在上面看到的，问题在于，如果您想要明确您的导入类型，有时您需要导入语句。您仍然可以执行以下操作:</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="0a6a" class="ni mg it lx b gy nj nk l nl nm">import { FC, useEffect } from 'react';</span></pre><p id="d190" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你牺牲了一点可读性。从版本<code class="fe lu lv lw lx b">4.5</code>你可以将它们混合在一起。</p><pre class="kj kk kl km gt ne lx nf ng aw nh bi"><span id="722d" class="ni mg it lx b gy nj nk l nl nm">import { <strong class="lx iu">type</strong> FC, useEffect } from 'react';</span></pre><p id="1441" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得代码更加清晰，而没有添加任何额外的样板文件。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="87c5" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">包裹</h1></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="aad8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些年来，打字稿变得越来越重要。我们可以预期Typescript将很快成为基于JavaScript的项目的默认语言。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oa"><img src="../Images/e2c9ec5217fa09de8152c6de4491872f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6JG24aD-1J7iImBZpLtteA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">octoverse.github.com历年最热门的语言</p></figure><p id="5cf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Typescript在2021年有了很大的改进。它的核心变得越来越聪明，让我们进一步依赖推理。这使得从JavaScript代码中移植变得不那么麻烦和容易。</p><p id="1d18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2022年看起来也令人兴奋。一些很酷的功能即将出现。TypeScript编译器现在专注于Node.js中的ECMAScript模块支持。它已经在夜间版本中发布，预计很快就会足够稳定，可以用于生产。</p><p id="0145" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里查看我之前版本的笔记:<a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/whats-new-in-typescript-4-2-97f722689c43"> 4.2 </a>，<a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/whats-new-in-typescript-4-3-72f74289e765"> 4.3 </a>，<a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/whats-new-in-typescript-4-4-e17d63b84b86"> 4.4 </a>，<a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/whats-new-in-typescript-4-5-57d6b88b1e72"> 4.5 </a></p><p id="cdb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。</p><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/6-killer-features-from-remix-3d7e01b0789e"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">混音版的6个黑仔特色</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">改变游戏规则的全栈JavaScript框架的主要亮点</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">better编程. pub</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>