<html>
<head>
<title>A GoMock Quick Start Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoMock快速入门指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-gomock-quick-start-guide-71bee4b3a6f1?source=collection_archive---------0-----------------------#2020-03-18">https://betterprogramming.pub/a-gomock-quick-start-guide-71bee4b3a6f1?source=collection_archive---------0-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa7e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用GoMock进行单元测试的固执己见的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c776759e8b19a325aad949af4c9f908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdJRGhi8SNIPbjho6gnsNg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">西蒙·马辛格在<a class="ae ky" href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="094e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么我们需要嘲笑</h1><p id="bc29" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">对有依赖关系的代码进行单元测试总是一件痛苦的事情。如果依赖的是外部资源，如数据库、网络和文件，情况会变得更糟。</p><p id="2202" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">一个直观的解决方案是创建一个提供所有这些外部资源的隔离环境，然后在其中运行测试用例。但是它们不再是单元测试了。它们是整合测试。</p><p id="d1d7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">不要误解我。集成测试有其价值，我们肯定需要它们。但是它们不适合运行每一个代码变更，原因有三:</p><ul class=""><li id="e778" class="mz na it ma b mb mu me mv mh nb ml nc mp nd mt ne nf ng nh bi translated">它们比单元测试慢得多。</li><li id="d066" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">他们可能会因为许多不可预知的原因而失败。</li><li id="c4dd" class="mz na it ma b mb ni me nj mh nk ml nl mp nm mt ne nf ng nh bi translated">集成测试失败可能不会直接解释失败和您所做的代码更改之间的关系。</li></ul><p id="2db4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在mocking框架的帮助下，我们可以对我们写下的几乎所有逻辑进行单元测试，而没有外部资源的麻烦。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e61c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍GoMock</h1><p id="9338" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">evidence</a>和<a class="ae ky" href="https://github.com/golang/mock" rel="noopener ugc nofollow" target="_blank"> GoMock </a>是两个流行的嘲讽围棋的框架。今天我将介绍GoMock，这是我的偏好。虽然对这两个框架进行点对点的比较超出了本文的范围，但是你可以在这里找到一个<a class="ae ky" href="https://blog.codecentric.de/2019/07/gomock-vs-testify/" rel="noopener ugc nofollow" target="_blank">详细的比较</a>(虽然我不认同文章的结论)。</p><p id="88e3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意:两个框架都只能模拟接口，所以我们需要组织接口背后的代码依赖。这将有利于我们的单元测试，即使不涉及嘲讽。</p><p id="100a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">GoMock是Go团队的一个嘲讽框架。它由一个生成类型安全模拟对象的代码生成工具和一个强大的存根API组成。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5e23" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">用mockgen生成模拟对象</h1><p id="e37b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">要使用GoMock，我们需要首先安装代码生成工具<code class="fe nn no np nq b">mockgen</code>:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="75ac" class="nv lh it nq b gy nw nx l ny nz">GO111MODULE=on go get github.com/golang/mock/mockgen@latest</span></pre><p id="01cd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">mockgen</code>将被安装到<code class="fe nn no np nq b">$GOPATH/bin</code>中。然后我们可以调用这个命令来生成模拟对象。</p><p id="8548" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意:<code class="fe nn no np nq b">mockgen</code>支持两种生成模式，源和反射。我们建议你总是使用反射模式，因为它更强大，可以避免源模式的一些<a class="ae ky" href="https://github.com/golang/mock/issues/10" rel="noopener ugc nofollow" target="_blank">死角</a>。</p><p id="4484" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">假设我们有一个接口<code class="fe nn no np nq b">Foo</code>和一个使用它的方法<code class="fe nn no np nq b">Bar</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5eeb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">要生成嘲讽代码:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="3463" class="nv lh it nq b gy nw nx l ny nz">mockgen -destination=mocks/mock_foo.go -package=mocks . Foo</span></pre><p id="2eb6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">上面的命令在当前包中找到接口<code class="fe nn no np nq b">Foo</code>(由点参数指定)并为该接口生成一个模仿对象。</p><p id="dcfb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><strong class="ma iu">注意:</strong> <code class="fe nn no np nq b">mockgen</code>可以和<code class="fe nn no np nq b">go:genernate<strong class="ma iu">.</strong></code>集成在一起，这有助于我们将<code class="fe nn no np nq b">mockgen</code>命令保持在被嘲笑的界面附近。因此，我们总是可以将<code class="fe nn no np nq b">go:generate</code>放在源文件中，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7df8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">生成的源代码被写入<code class="fe nn no np nq b">mocks/mock_foo.go</code>(由标志<code class="fe nn no np nq b">-destination</code>指定)，目标包为<code class="fe nn no np nq b">mocks</code>(由标志<code class="fe nn no np nq b">-package</code>指定)。</p><p id="7850" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">结果看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="676c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">MockFoo</code>是嘲讽对象，实现接口<code class="fe nn no np nq b">Foo</code>。每个mocking对象都有一个方法<code class="fe nn no np nq b">EXPECT</code>，该方法返回一个<code class="fe nn no np nq b">MockRecorder</code>实例(在本例中为<code class="fe nn no np nq b">MockFooMockRecorder</code>)。</p><p id="88d3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">MockFooMockRecorder</code>拥有接口<code class="fe nn no np nq b">Foo</code>的所有方法。唯一的区别是方法参数的类型是<code class="fe nn no np nq b">interface{}</code>。</p><p id="373a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe nn no np nq b">NewMockFoo</code>是一个创建模拟实例的公共函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b7d0213f4e29896cde7dc9b1211aba43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVSwNywZ2N55fw8wkcYmMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模拟对象的类图</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1390" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">建筑模型</h1><p id="d9d5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">生成模拟对象后，我们可以在单元测试中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f87f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这个测试中，我们先建立一个<code class="fe nn no np nq b">*gomock.Controller</code>。这是GoMock的核心。</p><p id="c23e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注<code class="fe nn no np nq b">defer ctrl.Finish()</code>用于触发最终断言。如果被忽略，嘲讽断言永远不会失败。</p><p id="3209" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">接下来，我们用<code class="fe nn no np nq b">mocks.NewMockFoo</code>创建一个新的模拟对象，将控制器实例作为参数传递。</p><p id="a6e1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对于新创建的模拟对象，它将接受任何输入和输出。我们需要用方法<code class="fe nn no np nq b">EXPECT</code>(又名<em class="od">构建存根</em>)来定义它的行为。这是模仿框架所能提供的最有价值的功能。</p><p id="1510" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">通过行<code class="fe nn no np nq b">m.EXPECT().<strong class="ma iu">Do</strong>(99).Return(101</code>，我们确保只有<code class="fe nn no np nq b">m.Do(99)</code>会被调用，并且该方法必须返回101。通过使用<code class="fe nn no np nq b">EXPECT</code>，我们极大地简化了模仿方法行为的工作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9e27" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">建筑树桩</h1><p id="c4b6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">GoMock有一个非常强大的期望API，这意味着我们可以轻松地构建不同的存根。以下是一些例子:</p><p id="ba84" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果不在乎输入参数，就用<code class="fe nn no np nq b">gomock.Any</code>。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1f91" class="nv lh it nq b gy nw nx l ny nz">m.EXPECT().Do(gomock.<strong class="nq iu">Any</strong>()).Return(101)</span></pre><p id="8b85" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">断言长度和零指针:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4991" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">断言反转条件和组合条件:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="56f7" class="nv lh it nq b gy nw nx l ny nz">m.EXPECT().Do2(gomock.Any()).Return(gomock.<strong class="nq iu">All</strong>(<br/>   gomock.<strong class="nq iu">Not</strong>(gomock.Nil()),<br/>   gomock.Len(8)))</span></pre><p id="1fa0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">断言调用次数:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="35f3" class="nv lh it nq b gy nw nx l ny nz">// assert invocation time is a fixed number<br/>m.EXPECT().Do(gomock.Any()).<strong class="nq iu">Times</strong>(8)<br/>// assert invocation time is in a range<br/>m.EXPECT().Do(gomock.Any()).<strong class="nq iu">MinTimes</strong>(3).<strong class="nq iu">MaxTimes</strong>(5)</span></pre><p id="4e5e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果需要断言不同参数之间的关系，使用<code class="fe nn no np nq b">Call.Do</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cd25" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">用<code class="fe nn no np nq b">Call.DoAndReturn</code>控制模拟逻辑和返回值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1a17" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用<code class="fe nn no np nq b">gomock.InOrder</code>执行呼叫指令:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="fbe7" class="nv lh it nq b gy nw nx l ny nz">gomock.InOrder(<br/>   m.EXPECT().Do(1),<br/>   m.EXPECT().Do(2),<br/>   m.EXPECT().Do2(gomock.Any()),<br/>)</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7030" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结束语</h1><p id="40a0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">嘲讽框架可以帮助我们构建干净、轻量级的单元测试。结合接口和依赖注入，我们几乎可以模仿任何东西。</p><p id="5ec2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在所有可用的嘲讽工具中，GoMock是我最喜欢的一个。它来自Go团队，提供了一个简单而强大的API。一般来说，官方团队的解决方案会更地道，也更符合Go的理念。我认为戈莫克就是这种情况。</p><p id="8521" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">希望这篇文章能帮助你轻松开始嘲讽。</p><p id="f7ab" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">快乐开发快乐生活。</p></div></div>    
</body>
</html>