<html>
<head>
<title>How To Build a Web Component With Lit Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Lit元素构建Web组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-web-component-with-lit-elements-d88684a46e56?source=collection_archive---------2-----------------------#2022-12-20">https://betterprogramming.pub/how-to-build-a-web-component-with-lit-elements-d88684a46e56?source=collection_archive---------2-----------------------#2022-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9c7c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将媒体的RSS提要转换为预览卡列表</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/659ffa8263627a138003d876b3dc6896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gNVvgWKINIx0gVE8StMrdw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用轻元素将自己从沉重框架的重力中解放出来(📷miszaszym </p></figure><h1 id="b81c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">定义</h1><p id="0e03" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk">“web组件是一组Web平台API，允许你创建新的定制的、可重用的、封装的HTML标签，用于网页和Web应用。”——</em>【webcomponents.org】T4</p><h1 id="193a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目标</h1><p id="4e51" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本系列中，我们将构建一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> web组件</a>，它将一个<a class="ae kv" href="https://help.medium.com/hc/en-us/articles/214874118-Using-RSS-feeds-of-profiles-publications-and-topics" rel="noopener">中型RSS </a>提要转换成一个可以添加到您的博客或web应用程序中的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook/Card" rel="noopener ugc nofollow" target="_blank">预览卡列表。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/f32a2b4fcd7f9511d84c09647349754a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jXki44z-j1qvfPdNvdyjLw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">媒体馈送教程web组件</p></figure><p id="8ec0" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">本文提供了各种技术的演练，这些技术可用于使用<a class="ae kv" href="https://lit.dev/" rel="noopener ugc nofollow" target="_blank"> Lit </a>和<a class="ae kv" href="https://open-wc.org/" rel="noopener ugc nofollow" target="_blank"> @open-wc </a>构建灵活、可扩展且经过良好测试的web组件。此外，我们将讨论测试策略并为您的web组件自动生成文档。</p><p id="b344" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">本文的配套报告可通过以下链接找到:</p><div class="mr ms gp gr mt mu"><a href="https://github.com/bobbyg603/medium-feed" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">GitHub — bobbyg603/medium-feed:演示如何从一个…</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">这个Web组件演示了如何从一个RSS提要中预览媒体报道—GitHub—bobbyg 603/Medium-feed:Web…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kp mu"/></div></div></a></div><h1 id="daa9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Web组件</h1><p id="7de1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用web组件，您可以像创建任何其他HTML元素一样创建应用程序中使用的自定义元素，但包括它们自己的自定义行为和样式。</p><p id="5a7c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">利用web组件可以使您的应用程序更加高效和可维护，因为您可以根据需要轻松地重用和修改您的组件。此外，web组件被设计成与框架无关，因此您可以将它们用于任何前端JavaScript库或框架。</p><p id="479f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">总的来说，使用web组件可以帮助您构建一个更具伸缩性和灵活性的web应用程序。</p><h1 id="ebeb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">准备发射</h1><p id="c5d2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，我们将创建一个基于<a class="ae kv" href="https://github.com/lit/lit-element-starter-ts" rel="noopener ugc nofollow" target="_blank">LitElement TypeScript starter repo</a>的项目。这个<a class="ae kv" href="https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template" rel="noopener ugc nofollow" target="_blank">模板</a>自带了许多有用的工具来加速我们的开发。</p><p id="85ed" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我们从将模板复制到我们的GitHub帐户开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/1aec1cef7c8524ec8973dfa5dce9605a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WQDo25n5PO4nFIDK4bwwkQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将模板repo复制到您的GitHub帐户</p></figure><p id="92d6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果您对最小设置感兴趣，您也可以使用<a class="ae kv" href="https://open-wc.org/guides/developing-components/getting-started/" rel="noopener ugc nofollow" target="_blank"> npm init @open-wc </a>来启动您的项目。</p><p id="10d2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">接下来，克隆您创建的repo并安装项目的依赖项。下面是如何做到这一点:</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="3623" class="no kx iq nk b be np nq l nr ns">git clone https://github.com/your-github-username/your-github-repo<br/>cd your-github-repo<br/>npm i</span></pre><p id="7aec" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在开发我们的web组件时，我们希望在不同的终端中运行两个命令。第一个命令将监视我们的源文件，并在发生任何变化时重新构建我们的组件。第二个命令将启动我们的开发预览服务器。</p><p id="9658" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在第一个终端窗口中运行<code class="fe nt nu nv nk b">build:watch</code>命令:</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="4964" class="no kx iq nk b be np nq l nr ns">npm run build:watch</span></pre><p id="114f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在第二个终端窗口中运行<code class="fe nt nu nv nk b">serve</code>命令:</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="0543" class="no kx iq nk b be np nq l nr ns">npm run serve</span></pre><p id="3f68" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">第二个命令应该显示一个可以在web浏览器中打开的URL。导航到指定的URL，单击组件演示链接，并确保您看到类似如下的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/fb1e6a1a5a07b5cbaa64c1091286ad4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9eqdVrkxpxI7gdpMg4aIg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">点燃元件启动器组件</p></figure><p id="1110" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">不错！您已经成功构建了您的第一个web组件。</p><p id="ab3f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在我们继续之前，让我们看看模板生成的文档。首先，使用以下命令构建文档:</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="ff3e" class="no kx iq nk b be np nq l nr ns">npm run docs</span></pre><p id="600a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">接下来，在单独的终端中运行以下命令。第一个命令将监视docs文件夹的更改，并在文件更改时进行重建。第二个命令将为本地主机上的文档启动一个web服务器。</p><p id="5676" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">运行<code class="fe nt nu nv nk b">docs:gen:watch</code>命令:</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="27ce" class="no kx iq nk b be np nq l nr ns">npm run docs:gen:watch</span></pre><p id="64ac" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">运行<code class="fe nt nu nv nk b">docs:serve</code>命令:</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="afd8" class="no kx iq nk b be np nq l nr ns">npm run docs:serve</span></pre><p id="8299" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">导航到终端窗口中列出的URL。您应该会看到类似如下的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/36af02bf46c09c2272f376d808263f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BsJE_olT_v20ApH8CbHjFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为Lit元素生成的文档</p></figure><p id="41f5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">太棒了。我们已经获得了构建新web组件所需的所有工具。在下一节中，我们将深入了解LitElement TypeScript starter repo的内部工作方式。</p><h1 id="7c61" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">倒数计秒</h1><p id="4c15" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们快速浏览一下代码，以理解让它工作的每一部分。打开<a class="ae kv" href="https://github.com/lit/lit-element-starter-ts/blob/main/src/my-element.ts" rel="noopener ugc nofollow" target="_blank"> src/my-element.ts </a>并查看以下内容:</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="b488" class="no kx iq nk b be np nq l nr ns">/**<br/> * An example element.<br/> *<br/> * @fires count-changed - Indicates when the count changes<br/> * @slot - This element has a slot<br/> * @csspart button - The button<br/> */</span></pre><p id="2906" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">前面的代码片段是一个注释，由<a class="ae kv" href="https://github.com/webcomponents/custom-elements-manifest" rel="noopener ugc nofollow" target="_blank"> custom-elements-manifest </a>读取，生成一个描述我们的web组件及其API的<code class="fe nt nu nv nk b">custom-elements.json</code>文件。<code class="fe nt nu nv nk b"> custom-elements.json</code>文件由<a class="ae kv" href="https://www.11ty.dev/" rel="noopener ugc nofollow" target="_blank">eleven</a>读取，用于为我们的组件文档生成一个<a class="ae kv" href="https://www.sanity.io/static-websites#d8a2954dc26c" rel="noopener ugc nofollow" target="_blank">静态站点</a>。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="fe8e" class="no kx iq nk b be np nq l nr ns">@customElement('my-element')<br/>export class MyElement extends LitElement {<br/>  // Implementation<br/>}</span></pre><p id="f54a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上面的代码为我们的web组件定义了一个扩展了<a class="ae kv" href="https://lit.dev/docs/api/LitElement/" rel="noopener ugc nofollow" target="_blank"> LitElement </a>的<code class="fe nt nu nv nk b">MyElement</code>类。我们使用<code class="fe nt nu nv nk b">@customElement</code> <a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank">装饰器</a>，它<a class="ae kv" href="https://lit.dev/docs/components/defining/" rel="noopener ugc nofollow" target="_blank">指示Lit定义</a>一个叫做<code class="fe nt nu nv nk b">my-element</code>的定制元素<a class="ae kv" href="https://softwareengineering.stackexchange.com/questions/289038/what-is-the-difference-between-web-components-and-custom-elements" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="e3f6" class="no kx iq nk b be np nq l nr ns">static override styles = css`<br/>  :host {<br/>    display: block;<br/>    border: solid 1px gray;<br/>    padding: 16px;<br/>    max-width: 800px;<br/>  }<br/>`;</span></pre><p id="2c7f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">静态<code class="fe nt nu nv nk b">styles</code>属性是<a class="ae kv" href="https://lit.dev/docs/components/styles/" rel="noopener ugc nofollow" target="_blank">用Lit定义样式</a>的推荐方法。其他选项包括<a class="ae kv" href="https://lit.dev/docs/components/styles/#sharing-styles" rel="noopener ugc nofollow" target="_blank">从共享导出导入样式</a>，<a class="ae kv" href="https://lit.dev/docs/components/styles/#theming" rel="noopener ugc nofollow" target="_blank">使用继承和CSS属性进行主题化</a>，以及<a class="ae kv" href="https://lit.dev/docs/components/styles/#theming" rel="noopener ugc nofollow" target="_blank">可构造样式表</a>。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="b8c6" class="no kx iq nk b be np nq l nr ns">/**<br/> * The name to say "Hello" to.<br/> */<br/>@property()<br/>name = 'World';</span></pre><p id="8d50" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在上面的例子中，我们用<a class="ae kv" href="https://lit.dev/docs/api/decorators/#property" rel="noopener ugc nofollow" target="_blank"> @property </a> decorator定义了一个<a class="ae kv" href="https://lit.dev/docs/components/properties/" rel="noopener ugc nofollow" target="_blank">反应性属性</a>，它可以在发生变化时触发反应性更新周期，重新呈现组件，并可选地读取或写入<a class="ae kv" href="https://lit.dev/docs/components/properties/#attributes" rel="noopener ugc nofollow" target="_blank">属性</a>。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="6fcc" class="no kx iq nk b be np nq l nr ns">override render() {<br/>  return html`<br/>    &lt;h1&gt;${this.sayHello(this.name)}!&lt;/h1&gt;<br/>    &lt;button @click=${this._onClick} part="button"&gt;<br/>      Click Count: ${this.count}<br/>    &lt;/button&gt;<br/>    &lt;slot&gt;&lt;/slot&gt;<br/>  `;<br/>}</span></pre><p id="bf5e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><a class="ae kv" href="https://lit.dev/docs/components/lifecycle/#render" rel="noopener ugc nofollow" target="_blank">渲染</a>函数是一个<a class="ae kv" href="https://lit.dev/docs/components/lifecycle" rel="noopener ugc nofollow" target="_blank">生命周期</a>函数，每当检测到<a class="ae kv" href="https://lit.dev/docs/components/lifecycle/#reactive-update-cycle-triggering" rel="noopener ugc nofollow" target="_blank">更新</a>时，就会调用该函数来重新渲染<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank"> DOM </a>。<code class="fe nt nu nv nk b">render</code>函数返回一个<a class="ae kv" href="https://lit.dev/docs/api/templates/#TemplateResult" rel="noopener ugc nofollow" target="_blank">模板结果</a>，在本例中，通过<a class="ae kv" href="https://lit.dev/docs/templates/overview/" rel="noopener ugc nofollow" target="_blank"> HTML标签</a>模板文字。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="5000" class="no kx iq nk b be np nq l nr ns">private _onClick() {<br/>  this.count++;<br/>  this.dispatchEvent(new CustomEvent('count-changed'));<br/>}</span></pre><p id="74b9" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">对<code class="fe nt nu nv nk b">@click</code> <a class="ae kv" href="https://lit.dev/docs/components/events/" rel="noopener ugc nofollow" target="_blank">事件</a>的处理由<code class="fe nt nu nv nk b">_onClick</code>函数完成。在这里，我们更新了<code class="fe nt nu nv nk b">count</code>属性，在元素更新之后<a class="ae kv" href="https://lit.dev/docs/components/events/#dispatching-events-after-an-element-updates" rel="noopener ugc nofollow" target="_blank">调度了一个事件，以根据更改了属性的用户交互来重新呈现页面。</a></p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="fce0" class="no kx iq nk b be np nq l nr ns">declare global {<br/>  interface HTMLElementTagNameMap {<br/>    'my-element': MyElement;<br/>  }<br/>}</span></pre><p id="b676" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">文件的最后一部分声明了一个<code class="fe nt nu nv nk b">HTMLElementTagNameMap</code>，它允许<a class="ae kv" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a>到<a class="ae kv" href="https://lit.dev/docs/components/defining/#typescript-typings" rel="noopener ugc nofollow" target="_blank">为我们的自定义元素<code class="fe nt nu nv nk b">my-element</code>提供良好的类型</a>。</p><p id="c26e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">打开<a class="ae kv" href="https://github.com/lit/lit-element-starter-ts/blob/main/dev/index.html" rel="noopener ugc nofollow" target="_blank"> dev/index.html </a>，看看<code class="fe nt nu nv nk b">my-element</code>的实例是如何在html中创建的。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="5173" class="no kx iq nk b be np nq l nr ns">&lt;my-element&gt;<br/>  &lt;p&gt;This is child content&lt;/p&gt;<br/>&lt;/my-element&gt;</span></pre><p id="89c5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果我们想为<code class="fe nt nu nv nk b">name</code>传递一个值，我们应该将我们的HTML更新如下。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="4235" class="no kx iq nk b be np nq l nr ns">&lt;my-element name="bobby"&gt;<br/>  &lt;p&gt;This is child content&lt;/p&gt;<br/>&lt;/my-element&gt;</span></pre><p id="3d8e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">最后但同样重要的是，<code class="fe nt nu nv nk b">&lt;my-element&gt;</code>标签内的内容将在<a class="ae kv" href="https://lit.dev/docs/components/shadow-dom/#slots" rel="noopener ugc nofollow" target="_blank">槽</a>中呈现。<code class="fe nt nu nv nk b">&lt;p&gt;</code>标签的内容将被插入到<code class="fe nt nu nv nk b">&lt;my-element&gt;</code>模板中<code class="fe nt nu nv nk b">&lt;slot&gt;</code>标签的位置。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="3db5" class="no kx iq nk b be np nq l nr ns">&lt;h1&gt;${this.sayHello(this.name)}!&lt;/h1&gt;<br/>&lt;button @click=${this._onClick} part="button"&gt;<br/>  Click Count: ${this.count}<br/>&lt;/button&gt;<br/>&lt;p&gt;This is child content&lt;/p&gt;</span></pre><p id="bb85" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">厉害！既然我们了解了所有部件的工作原理，我们就可以组装更复杂的东西了。在下一节中，我们将完成web组件的构建。</p><h1 id="24bb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">t减0</h1><p id="462f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">构建Lit元素是一种很棒的体验，感觉类似于React开发。在上一节中，我们深入探讨了由<a class="ae kv" href="https://github.com/lit/lit-element-starter-ts" rel="noopener ugc nofollow" target="_blank">LitElement TypeScript starter</a>repo提供的工具。现在我们已经了解了我们的工具，是时候开始构建我们的组件了。</p><p id="207c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">首先，我们将对起始模板进行一些调整，以改善开发人员的体验。接下来，我们将构建一个巨大的web组件，它获取一个<a class="ae kv" href="https://help.medium.com/hc/en-us/articles/214874118-Using-RSS-feeds-of-profiles-publications-and-topics" rel="noopener">媒体RSS提要</a>并显示几个<a class="ae kv" href="https://codepen.io/search/pens?q=image+card" rel="noopener ugc nofollow" target="_blank">预览卡</a>。最后，我们将把我们的项目重新组织成小的、封装良好的、易于测试的组件。</p><p id="1798" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">完成下一部分后，您将构建类似如下的东西。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/f32a2b4fcd7f9511d84c09647349754a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jXki44z-j1qvfPdNvdyjLw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中馈纸幅组件</p></figure><h1 id="fff9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">发射</h1><p id="dfa6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">默认模板配置将所有构建工件输出到与源代码相同的文件夹中，这非常烦人。我们可以通过更新<code class="fe nt nu nv nk b">.eleventy.cjs,</code><code class="fe nt nu nv nk b">.gitignore</code><code class="fe nt nu nv nk b">dev/index.html</code><code class="fe nt nu nv nk b">rollup.config.js</code><code class="fe nt nu nv nk b">tsconfig.json</code><code class="fe nt nu nv nk b">web-test-runner.config.js</code>和<code class="fe nt nu nv nk b">package.json</code>来改变这种行为。如果您希望帮助更新您的配置以构建到<code class="fe nt nu nv nk b">dist</code>文件夹，请查看此<a class="ae kv" href="https://github.com/bobbyg603/lit-element-starter-ts/commit/5cd4995a9133887a84d571161cf884974a85e9b2" rel="noopener ugc nofollow" target="_blank">差异</a>。</p><p id="d3c6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果你的工作区域没有被这些文件困扰，请继续阅读！</p><p id="5c44" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我们重命名<code class="fe nt nu nv nk b">my-element</code>组件。您可以利用IDE的搜索来确保更新从<code class="fe nt nu nv nk b">MyElement</code>到<code class="fe nt nu nv nk b">MediumFeed</code>的所有代码引用，以及从<code class="fe nt nu nv nk b">my-element</code>到<code class="fe nt nu nv nk b">medium-feed</code>的模板引用，并将文件<code class="fe nt nu nv nk b">my-element.ts</code>和<code class="fe nt nu nv nk b">my-element_test.ts</code>分别重命名为<code class="fe nt nu nv nk b">medium-card.ts</code>和<code class="fe nt nu nv nk b">medium-feed_test.ts</code>。</p><p id="5c69" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">您可以查看它并将您的更改与此<a class="ae kv" href="https://github.com/bobbyg603/lit-element-starter-ts/commit/f53a59e59bec32675e68d958d5ec98caac5d7b76" rel="noopener ugc nofollow" target="_blank"> diff </a>进行比较，以检查您的工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/360b953d25af75f8b454460a0bacf354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Imm5Ry0u_zHL0WeF3bYrWw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">VS代码中的查找和替换查询示例</p></figure><p id="8891" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">现在我们已经有了一个好的工作区，最简单的开始方式是将所有的组件功能转储到<code class="fe nt nu nv nk b">medium-feed</code>中。首先，我们将允许用户为一个中等RSS提要指定一个<code class="fe nt nu nv nk b">url</code>属性。我们将使用RSS提要URL来获取文章的<a class="ae kv" href="https://en.wikipedia.org/wiki/XML" rel="noopener ugc nofollow" target="_blank"> XML </a>集合，并将其转换为<a class="ae kv" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>。最后，我们将<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">将</a>每篇文章映射到一个包含<code class="fe nt nu nv nk b">thumbnail</code>、<code class="fe nt nu nv nk b">header</code>、<code class="fe nt nu nv nk b">body</code>和<code class="fe nt nu nv nk b">footer</code>的HTML卡片。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中馈纸幅组件</p></figure><p id="b57d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在上面的代码中，我们添加了一个描述组件的<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L4-L9" rel="noopener ugc nofollow" target="_blank">注释，并且</a><a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L10" rel="noopener ugc nofollow" target="_blank">使用<code class="fe nt nu nv nk b">@customElement</code>装饰器定义了我们的定制元素</a>。我们添加了几个默认的样式和更多的样式，这些样式可以通过CSS变量进行主题化。我们声明了<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L71-L72" rel="noopener ugc nofollow" target="_blank"> URL </a>和<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L74-L75" rel="noopener ugc nofollow" target="_blank">计数</a>输入<a class="ae kv" href="https://lit.dev/docs/components/properties/" rel="noopener ugc nofollow" target="_blank">属性</a>，并使用它们通过<code class="fe nt nu nv nk b"><a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L80-L83" rel="noopener ugc nofollow" target="_blank">connectedCallback</a></code>生命周期挂钩<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L125-L132" rel="noopener ugc nofollow" target="_blank">获取数据</a>。RSS提要数据通过一个<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L126" rel="noopener ugc nofollow" target="_blank">端点获取，该端点将其转换为JSON </a>，保存到<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L77-L78" rel="noopener ugc nofollow" target="_blank">组件的状态</a>，我们<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L88-L117" rel="noopener ugc nofollow" target="_blank">将</a>每个结果映射到一个<a class="ae kv" href="https://gist.github.com/bobbyg603/1b7b7212e1ff2a01b9578531ad027777#file-medium-feed-ts-L95-L116" rel="noopener ugc nofollow" target="_blank">卡片数组</a>。</p><p id="2797" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在一个终端运行<code class="fe nt nu nv nk b">npm run build:watch</code>，在另一个终端运行<code class="fe nt nu nv nk b">npm run serve</code>。构建完成后，导航到终端中显示的URL，通常是<code class="fe nt nu nv nk b"><a class="ae kv" href="https://localhost:8000)." rel="noopener ugc nofollow" target="_blank">https://localhost:8000</a></code>。</p><p id="127b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上面代码片段中的代码应该产生以下内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/4ebe8beec4cbc039c9a9b43d61da18e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJufVyM0uOE63m2tNJOvcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中等饲料成分</p></figure><p id="c5d5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这是一个非常好看的web组件，但是代码很难处理，并且很难测试。让我们从这个web组件中提取一些片段，并解释它们是如何工作的。我们将提取<code class="fe nt nu nv nk b">thumbnail</code>、<code class="fe nt nu nv nk b">header</code>、<code class="fe nt nu nv nk b">body</code>、<code class="fe nt nu nv nk b">footer</code>片段来构建一个可以在<code class="fe nt nu nv nk b">medium-feed</code>组件中使用的通用<code class="fe nt nu nv nk b">card</code>。</p><p id="0e78" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">首先，我们将在<code class="fe nt nu nv nk b">src</code>目录中创建一个<code class="fe nt nu nv nk b">card</code>文件夹。在<code class="fe nt nu nv nk b">card</code>文件夹中，创建<code class="fe nt nu nv nk b">medium-card-thumbnail.ts</code>并粘贴以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中型卡片缩略图组件</p></figure><p id="5073" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe nt nu nv nk b">medium-card-thumbnail</code>元素允许消费者为模板用来呈现图像的<code class="fe nt nu nv nk b">src</code>属性指定值。我们使用<code class="fe nt nu nv nk b">:host</code>选择器对包含元素的组件进行<a class="ae kv" href="https://lit.dev/docs/components/styles/#host" rel="noopener ugc nofollow" target="_blank">样式化，并赋予它们属性<code class="fe nt nu nv nk b">display: flex</code>。<code class="fe nt nu nv nk b">img</code>样式还包含一组</a><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank"> CSS属性</a>，我们稍后将使用它们来允许用户覆盖我们的默认样式，以控制图像的圆角和更改缩略图大小。</p><p id="384c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我们也在<code class="fe nt nu nv nk b">card</code>文件夹中创建一个<code class="fe nt nu nv nk b">medium-card-header.ts</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">介质卡标题组件</p></figure><p id="19f2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">用户可以通过<code class="fe nt nu nv nk b">--medium-header-color</code>变量设置<code class="fe nt nu nv nk b">medium-card-header</code>元素的颜色。<code class="fe nt nu nv nk b">header</code>和<code class="fe nt nu nv nk b">subheader</code>属性的值分别呈现在<code class="fe nt nu nv nk b">h2</code>和<code class="fe nt nu nv nk b">h3</code>标签中。</p><p id="e471" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们可以创建一个<code class="fe nt nu nv nk b">medium-card-body</code>元素来显示<code class="fe nt nu nv nk b">card</code>中的一段文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">介质卡体组件</p></figure><p id="c68f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe nt nu nv nk b">body</code>属性允许用户设置组件的主体内容。目前,<code class="fe nt nu nv nk b">overflow: hidden</code>和<code class="fe nt nu nv nk b">text-overflow: ellipsis</code>有点令人向往。这些样式的工作方式不太好，它们会截断body元素底部的文本。我们将把这作为一个练习留给读者——如果你找到了用CSS规则控制溢出的解决方案，请在评论中告诉我们！</p><p id="6a62" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">将我们的<code class="fe nt nu nv nk b">card</code>的最后一个子组件添加到新的<code class="fe nt nu nv nk b">medium-card-footer.ts</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中型卡片页脚组件</p></figure><p id="ad85" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">通过<code class="fe nt nu nv nk b">footer</code>属性设置<code class="fe nt nu nv nk b">medium-card-footer</code>内容。与其他子组件类似，页脚接受一个<code class="fe nt nu nv nk b">--medium-footer-color</code>变量，允许消费者对其进行主题化。组件的其余部分是我们以前见过的死记硬背的东西。</p><p id="0bae" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们可以在一个新的<code class="fe nt nu nv nk b">medium-card</code>组件中组织所有这些部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3326" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上面的片段是事情开始变得有趣的地方。</p><p id="b0d0" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们为组件定义了几种样式和属性。该组件还接受传递给子组件的几个CSS变量值。如果消费者想要设计<code class="fe nt nu nv nk b">medium-card</code>的实例，他们可以通过设置<code class="fe nt nu nv nk b">--medium-card-header-color</code>、<code class="fe nt nu nv nk b">--medium-card-body-color</code>、<code class="fe nt nu nv nk b">--medium-card-footer-color</code>等的值来实现。CSS变量值被传递给子组件，允许消费者将<code class="fe nt nu nv nk b">card</code>作为一个内聚单元进行主题化。我们的设计还允许消费者使用主题化的子组件作为构建模块来构建他们自己版本的卡片。</p><p id="91a1" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">下面是一个消费者如何创建自己的<code class="fe nt nu nv nk b">card</code>的示例，即创建一个省略缩略图的新卡:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">合成不带缩略图的中型卡片</p></figure><p id="9c56" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">最后，我们可以重构我们的<code class="fe nt nu nv nk b">medium-feed</code>组件来利用我们的新<code class="fe nt nu nv nk b">medium-card</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重构的介质馈送</p></figure><p id="8fd1" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们现在有了一个更干净的实现，很容易被<a class="ae kv" href="https://www.merriam-webster.com/dictionary/grok" rel="noopener ugc nofollow" target="_blank"> grok </a>。同样，我们将几个CSS变量传递给子组件，以便于组件主题化。<code class="fe nt nu nv nk b">connectedCallback</code> <a class="ae kv" href="https://lit.dev/docs/components/lifecycle/#connectedcallback" rel="noopener ugc nofollow" target="_blank">生命周期钩子</a>用于获取媒体RSS提要XML并将其转换为JSON。</p><p id="82ad" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">将内部的<code class="fe nt nu nv nk b">_state.posts</code>属性映射到一个<code class="fe nt nu nv nk b">MediumPosts</code>数组，并将每个帖子映射到一个<code class="fe nt nu nv nk b">medium-card</code>。我们使用<code class="fe nt nu nv nk b">trimContent</code>删除文章正文中的所有HTML标签，并将内容截短为32个单词。我们的卡体的开头是从文章的第三段生成的，因为这看起来在测试中效果最好。</p><p id="89ce" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上面的<code class="fe nt nu nv nk b">trimContent</code>片段中潜伏着一个bug，因为并不是所有的文章都保证有三段。如果你发现了漏洞，干得好！我们将把这个问题留给用户来解决。</p><p id="fd5e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">您已经成功地构建了一个定制的、可重用的web组件，该组件可以获取一组中型文章，并将它们显示为预览卡——干得漂亮！在下一节中，我们将开发一个测试web组件的策略，并学习帮助我们与其他开发人员一起构建更复杂的web组件的技术。</p><h1 id="6cd0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">测试</h1><p id="c920" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">测试web组件可能很棘手，编写有效的测试需要良好的设计和聪明的思维。编写测试是记录特性如何工作的好方法，这样将来的开发人员可以快速有效地迭代。编写良好的测试可以防止回归，而不会重复其他测试中的工作。在Lit Elements教程的最后一节中，我们将讨论测试策略，回顾我们的中馈示例中的测试，并深入细节。</p><h1 id="9293" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">测试基础</h1><p id="0ac2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在上一篇文章中，我们从一个巨大的web组件开始，并将其分解成更小的子组件。将整体组件分解成小块有助于我们组织项目。此外，封装良好的小型组件更容易测试，因此<a class="ae kv" href="https://stackoverflow.com/questions/18666821/what-does-the-term-reason-about-mean-in-computer-science" rel="noopener ugc nofollow" target="_blank">与</a>有关。根据经验，如果某个东西很难测试，它可能需要被分成更小的部分和/或简化。</p><p id="c811" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我们从子组件的一些测试开始。最简单的测试组件是<code class="fe nt nu nv nk b">medium-card-body</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中等卡体测试</p></figure><p id="b2e6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">第一个测试创建了一个<code class="fe nt nu nv nk b">medium-card-body</code>，并断言它是我们的<code class="fe nt nu nv nk b">MediumCardBodyElement</code>的一个实例。接下来，我们设置<code class="fe nt nu nv nk b">body</code>属性的值，并针对影子DOM断言以确保<code class="fe nt nu nv nk b">body</code>属性被正确呈现。最后，我们添加了一个测试来确保如果我们设置了<code class="fe nt nu nv nk b">--medium-body-color</code> CSS变量会改变主体的<code class="fe nt nu nv nk b">color</code>。</p><p id="d993" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们使用<code class="fe nt nu nv nk b">medium-card-body</code>元素的<code class="fe nt nu nv nk b">style</code>属性注入我们的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank"> CSS变量</a>的值。为了检查CSS变量是否正确连接，我们使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle" rel="noopener ugc nofollow" target="_blank"> getComputedStyle </a>函数来获取<code class="fe nt nu nv nk b">color</code>属性，并断言它等于我们通过<code class="fe nt nu nv nk b">styles</code>属性注入的值。</p><p id="2262" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">用于测试<code class="fe nt nu nv nk b">medium-card-body</code>的策略的一个稍微复杂的例子可以在<code class="fe nt nu nv nk b">medium-card-header</code>的测试中看到。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中型卡接头测试</p></figure><p id="8894" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在<code class="fe nt nu nv nk b">medium-card-header</code>测试中，我们断言组件正确地分别呈现了<code class="fe nt nu nv nk b">h2</code>和<code class="fe nt nu nv nk b">h3</code>标签中<code class="fe nt nu nv nk b">header</code>和<code class="fe nt nu nv nk b">subheader</code>的值。<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" rel="noopener ugc nofollow" target="_blank"> querySelector </a>函数用于获取感兴趣的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Element" rel="noopener ugc nofollow" target="_blank">元素</a>，以便我们针对其属性运行断言。我们使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a> <code class="fe nt nu nv nk b">?</code>操作符和<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator" rel="noopener ugc nofollow" target="_blank">非空断言操作符</a> <code class="fe nt nu nv nk b">!</code>来告诉TypeScript编译器，我们接受对象可能是<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/undefined" rel="noopener ugc nofollow" target="_blank">未定义的</a>的可能性。一旦我们有了对<code class="fe nt nu nv nk b">h2</code>和<code class="fe nt nu nv nk b">h3</code>元素的引用，我们就可以断言它们的<code class="fe nt nu nv nk b">color</code>等于我们用<code class="fe nt nu nv nk b">--medium-header-color</code>指定的值。</p><h1 id="3eb9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">高级测试策略</h1><p id="943c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，我们已经测试了子组件的属性值是否正确呈现，CSS变量是否可以覆盖组件样式。因为我们的子组件用于实现<code class="fe nt nu nv nk b">medium-card</code>组件，这对测试这些组件的集成并确保值正确地从父组件传递到子组件是很重要的。</p><p id="22ea" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">起初，测试完全呈现的组件树并验证传递给子组件的值是否被正确呈现似乎是个好主意。不幸的是，测试呈现的子组件会变得复杂，并且我们的许多测试逻辑会在父组件和我们为子组件编写的测试之间重复。</p><p id="1876" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">多亏了TypeScript，我们可以避免重复代码，并安全地测试父组件和子组件的边界。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">介质卡标题测试</p></figure><p id="2bd8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在上面的片段中，我们将一个大的测试分成了两个更小的、更有针对性的测试。我们可以测试到一个<code class="fe nt nu nv nk b">medium-card</code>和任何子元素的边界，而不是测试整个呈现的<code class="fe nt nu nv nk b">medium-card</code>组件。这是可行的，因为我们已经有了子组件实现的测试覆盖，并且避免了测试之间的逻辑重复。</p><p id="65a5" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">将一个整体集成测试分解成更小的单元测试实现了我们的目标，即编写测试来防止未来的开发人员重命名子组件中的属性并忘记更新父组件中的引用。</p><p id="55e6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">测试到<code class="fe nt nu nv nk b">medium-card</code>组件边界的具体例子可以在<code class="fe nt nu nv nk b">medium-card-header</code>测试中看到。我们测试了<code class="fe nt nu nv nk b">medium-card-header</code>上的<code class="fe nt nu nv nk b">header</code>属性设置是否正确，并且可以保证它们能够正确渲染，因为我们已经在单独的测试中测试了<code class="fe nt nu nv nk b">medium-card-header</code>的渲染。</p><p id="9d42" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">重要的是要注意，只有当你能够利用编译器来确保<a class="ae kv" href="https://en.wikipedia.org//wiki/Type_safety" rel="noopener ugc nofollow" target="_blank">类型安全</a>时，边界测试才有效。当您更改子组件中的属性名时，您需要一些警告或错误来提示您更新父组件中的任何引用。为了确保测试中的类型安全，我们可以使用<code class="fe nt nu nv nk b">as</code>关键字向<code class="fe nt nu nv nk b">querySelector</code>的结果添加一个<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions" rel="noopener ugc nofollow" target="_blank">类型断言</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/b7c9e13882c637f2001022cda5b64336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BgazliV87ZoQkDmWP_xtKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">中型标题类型安全示例</p></figure><p id="a5ba" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">由于<code class="fe nt nu nv nk b">querySelector</code>结果类型正确，将<code class="fe nt nu nv nk b">medium-card-header</code>中的属性<code class="fe nt nu nv nk b">header</code>更改为<code class="fe nt nu nv nk b">title</code>会产生编译错误。此外，在VS代码中，您使用<a class="ae kv" href="https://code.visualstudio.com/docs/editor/refactoring#_rename-symbol" rel="noopener ugc nofollow" target="_blank">重命名符号</a>特性来安全地更新<code class="fe nt nu nv nk b">header</code>到<code class="fe nt nu nv nk b">title</code>的所有引用，并完全避免这个问题！</p><p id="f823" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">既然我们已经彻底测试了<code class="fe nt nu nv nk b">medium-card</code>组件，让我们来看看我们的<code class="fe nt nu nv nk b">medium-feed</code>组件。</p><h1 id="3a25" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">间谍</h1><p id="a409" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们的<code class="fe nt nu nv nk b">medium-feed</code>组件发出一个网络调用，从一个中等的RSS提要中获取数据并填充组件。网络调用是用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> fetch </a>完成的，这是一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous" rel="noopener ugc nofollow" target="_blank">异步</a>操作。我们不想在测试中执行任何“真正的”网络调用，因为它们运行缓慢，并且发送端的数据会发生变化。</p><p id="a314" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们可以使用一个<a class="ae kv" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank">Sinon</a>T19】spy(又名<a class="ae kv" href="https://sinonjs.org/releases/latest/stubs/" rel="noopener ugc nofollow" target="_blank"> stub </a>)来<a class="ae kv" href="https://sinonjs.org/releases/latest/mocks/" rel="noopener ugc nofollow" target="_blank">模拟</a>网络调用并返回<a class="ae kv" href="https://github.com/bobbyg603/medium-feed/blob/main/test/article.ts" rel="noopener ugc nofollow" target="_blank">假数据</a>，而不是进行真正的网络调用。</p><pre class="kg kh ki kj gt nj nk nl bn nm nn bi"><span id="dea9" class="no kx iq nk b be np nq l nr ns">import { MediumFeedElement } from '../src/feed/medium-feed.js';<br/>import { assert, fixture, html, waitUntil } from '@open-wc/testing';<br/>import { article } from './article';<br/>import sinon from 'sinon';<br/><br/>suite('medium-feed', () =&gt; {<br/>  const url = '🔗';<br/>  const cards = 3;<br/>  let stubbedFetch: sinon.SinonStub;<br/><br/>  setup(() =&gt; {<br/>    const response = createFakeResponse(cards);<br/>    stubbedFetch = sinon.stub(globalThis, 'fetch');<br/>    stubbedFetch.returns(Promise.resolve(response));<br/>  });<br/><br/>  teardown(() =&gt; {<br/>    stubbedFetch.restore();<br/>  });<br/><br/>  test('gets articles from rss feed', async () =&gt; {<br/>    const el = await fixture(html`&lt;medium-feed .url="${url}"&gt;&lt;/medium-feed&gt;`) as MediumFeedElement;<br/>    await el.updateComplete;<br/>    assert.isTrue(stubbedFetch.calledWith(`https://api.rss2json.com/v1/api.json?rss_url=${url}`));<br/>  });<br/>  <br/>  function createFakeResponse(cards: number) {<br/>    const items = Array.from(Array(cards)).map(() =&gt; article);<br/>    return new Response(<br/>      JSON.stringify({<br/>        items<br/>      })<br/>    );<br/>  }<br/>});</span></pre><p id="e6b2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">我们通过从<code class="fe nt nu nv nk b">article.ts</code>导入<code class="fe nt nu nv nk b">article</code>来创建一个假的<code class="fe nt nu nv nk b">response</code>。fetch实现被存根化，<code class="fe nt nu nv nk b">returns</code>函数指示我们的存根返回一个假响应。存根允许针对用于通过用调用的<a class="ae kv" href="https://sinonjs.org/releases/latest/spies/#spy-api" rel="noopener ugc nofollow" target="_blank">调用fetch的参数执行断言。测试</a><a class="ae kv" href="https://mochajs.org/#hooks" rel="noopener ugc nofollow" target="_blank">生命周期挂钩</a> <code class="fe nt nu nv nk b">setup</code>和<code class="fe nt nu nv nk b">teardown</code>用于在每次测试后创建和销毁存根，以防止在一个测试中修改存根的操作影响其他测试。请注意，根据您使用的测试框架，<code class="fe nt nu nv nk b">setup</code>和<code class="fe nt nu nv nk b">teardown</code>可能分别被命名为<code class="fe nt nu nv nk b">beforeEach</code>和<code class="fe nt nu nv nk b">afterEach</code>。</p><h1 id="dd3c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">等待</h1><p id="e71a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们的<code class="fe nt nu nv nk b">medium-feed</code>异步网络请求填充组件的内容，我们必须等待它完成，然后才能执行断言。</p><p id="9725" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在执行断言之前，确保组件有效的最简单方法是使用<code class="fe nt nu nv nk b"><a class="ae kv" href="https://open-wc.org/docs/testing/helpers/#waituntil" rel="noopener ugc nofollow" target="_blank">waitUntil</a></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5b04" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><code class="fe nt nu nv nk b">waitUntil</code>函数接受一个函数参数，该参数一直运行到内部条件返回true(也称为<a class="ae kv" href="https://dcl-prog.stanford.edu/function-predicate.html" rel="noopener ugc nofollow" target="_blank">谓词</a>)。此外，传递给<code class="fe nt nu nv nk b">waitUntil</code>的第二个参数是一条消息，如果等待超时而谓词没有返回true，将显示这条消息。在这个例子中，我们使用了一个谓词，当呈现的<code class="fe nt nu nv nk b">medium-cards</code>的数量等于预期的卡片数量时，该谓词返回true。一旦测试等待卡片被呈现，就可以安全地在夹具上执行断言了。</p><h1 id="fbca" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">任务完成</h1><p id="c67c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本系列涵盖了Lit Element Starter模板的来龙去脉，并演示了如何制作一个经过良好测试的可重用web组件。如果你想让你的web组件更上一层楼，考虑一下<a class="ae kv" href="https://lit.dev/docs/tools/publishing/" rel="noopener ugc nofollow" target="_blank">将你的web组件</a>发布到<a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>或者<a class="ae kv" href="https://lit.dev/docs/tools/production/" rel="noopener ugc nofollow" target="_blank">在你的博客上部署你的web组件</a>。如果你觉得这个教程有用，请留下评论。</p><p id="62f8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>