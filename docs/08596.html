<html>
<head>
<title>How To Fix Your Docker-Based Microservice Infrastructure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复基于Docker的微服务基础设施</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-fix-your-docker-based-microservice-infrastructure-17ba34bb7561?source=collection_archive---------12-----------------------#2021-05-18">https://betterprogramming.pub/how-to-fix-your-docker-based-microservice-infrastructure-17ba34bb7561?source=collection_archive---------12-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="100a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每当出现故障时，针对Docker API启动命令来修复您的基础设施</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7c6e26403797850d224a152ce97ea00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Dc8ybkxudIwsaMh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="906e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://searchmicroservices.techtarget.com/definition/microservices" rel="noopener ugc nofollow" target="_blank">微服务架构风格</a>为开发团队提供了一种更加分散的构建软件的方法，每个服务都被独立地隔离、构建、部署和管理。因此，<a class="ae ky" href="https://medium.com/swlh/what-exactly-is-docker-1dd62e1fde38" rel="noopener">容器</a>已经成为包装单个服务的事实上一致且资源高效的标准。</p><p id="cb52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后出现了编排工具，如<a class="ae ky" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>、<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae ky" href="https://www.nomadproject.io/" rel="noopener ugc nofollow" target="_blank"> Nomad </a>。这些工具有助于自动化扩展、部署和容器管理。</p><p id="4acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管由于这些突破，微服务管理的复杂性正在降低，但一些挑战仍然存在，如对此类基础设施的平稳轻松监控。在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/distributed-instant-logs-made-easy-with-docker-b5e7f501f045">上一篇文章</a>中，我们介绍了<a class="ae ky" href="https://github.com/gliderlabs/logspout" rel="noopener ugc nofollow" target="_blank"> Logspout </a>和一个新的<a class="ae ky" href="https://github.com/kalisio/logspout-slack" rel="noopener ugc nofollow" target="_blank"> Slack adapter </a>作为Docker容器的轻量级日志监控替代。在本文中，我们将介绍<a class="ae ky" href="https://github.com/kalisio/kontrol" rel="noopener ugc nofollow" target="_blank"> kontrol </a>，它是Docker容器内置健康检查的轻量级替代方案，您可以快速配置和部署它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4739" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一言以蔽之</h1><p id="046a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">kontrol是一个非常轻量级的应用程序，可以作为Docker容器或Docker Swarm服务运行。它针对一组资源(容器或服务)运行请求，以确定这些资源是否正常运行(也称为健康检查)。每当健康检查失败时，它<em class="mz">针对Docker API发出命令</em>，以便<em class="mz">修复</em>基础设施。kontrol可以监控和修复基于Docker的微服务基础设施。</p><p id="acc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">kontrol包括使用<a class="ae ky" href="https://api.slack.com/messaging/webhooks" rel="noopener ugc nofollow" target="_blank">传入Webhook </a>的<a class="ae ky" href="https://slack.com/" rel="noopener ugc nofollow" target="_blank">松弛</a>通知。只需将webhook URL插入到您的环境中，并启用Slack集成。无论何时运行状况检查失败，您在Slack上指定的通道都会收到一条消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3626" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么选择kontrol？</h1><p id="3a2c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然Docker为容器提供了内置的健康检查，但在某些用例中它可能太有限了。首先，如果您想在Slack上得到关于健康检查失败的通知，您将需要使用第三方工具。第二，Docker的修复操作只包括重启出错的容器本身。在复杂的微服务场景中，这可能是不够的，因为一些容器依赖于其他容器才能到达。</p><p id="c09d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您有一个使用服务B的服务A。从Docker的角度来看，服务A和B可以被视为运行良好，而服务B由于某种原因(例如，网络故障、超时等)无法从服务A访问。).在这种情况下，从A 的角度来看，展示服务A中提供服务B <em class="mz">状态的健康检查端点可能会很有趣。当服务A中的运行状况检查失败时，您应该会得到通知，并且除了服务A之外，服务B也可能会自动重新启动。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d0bf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">配置kontrol</h1><p id="abfc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大多数配置选项来自于<a class="ae ky" href="https://github.com/sindresorhus/got" rel="noopener ugc nofollow" target="_blank"> got </a>和<a class="ae ky" href="https://github.com/apocas/dockerode" rel="noopener ugc nofollow" target="_blank">docker ode</a>powering kontrol。<code class="fe na nb nc nd b">config.js</code>中导出的对象应该是这样的结构:</p><ul class=""><li id="774a" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">docker</code>:用于初始化dockerode的选项。</li><li id="b9e2" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">jobs</code>:健康检查和通知/修复任务的映射，通过其键识别每个任务。</li><li id="1977" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">cron</code>:<a class="ae ky" href="https://github.com/kelektiv/node-cron" rel="noopener ugc nofollow" target="_blank">CRON模式</a>来调度它。</li><li id="5492" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">delay</code>:调度任务前的延迟秒数。</li><li id="abe1" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">notify</code>:可选函数，当健康检查失败时使用<code class="fe na nb nc nd b">error</code>对象作为输入，或者当健康检查失败后恢复健康时使用none作为输入(返回发送通知的Slack消息有效载荷)。</li><li id="494a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">heal</code>:可选函数，以<code class="fe na nb nc nd b">docker</code>对象(即dockerode实例)和<code class="fe na nb nc nd b">_</code> (lodash实例)作为输入。执行Docker命令来修复基础设施。</li><li id="60de" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">所有其他选项都被发送到运行状况检查请求的get实例。</li></ul><p id="712d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是可用于自定义行为的环境变量:</p><ul class=""><li id="02a3" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">CONFIG_FILEPATH</code>:您的配置文件路径是<code class="fe na nb nc nd b">config.js</code></li><li id="3102" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">PORT</code>:服务器端口(默认为<code class="fe na nb nc nd b">8080</code>)</li><li id="65f9" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe na nb nc nd b">SLACK_WEBHOOK_URL</code>:你的Slack webhook网址</li></ul><p id="4d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认的<code class="fe na nb nc nd b"><a class="ae ky" href="https://github.com/kalisio/kontrol/blob/master/config.js" rel="noopener ugc nofollow" target="_blank">config.js</a></code>是一个很好的例子。它主要检查kontrol容器本身，并在失败时重启它，就像Docker所做的那样。在测试模式下，kontrol容器将随机失败，并显示一个<code class="fe na nb nc nd b">500</code>状态代码，因此只要您不手动终止它，容器就会重新启动。要构建并启动该示例，请执行以下命令:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="90ea" class="nw md it nd b gy nx ny l nz oa">git clone <a class="ae ky" href="https://github.com/kalisio/kontrol.git" rel="noopener ugc nofollow" target="_blank">https://github.com/kalisio/kontrol.git</a><br/>SLACK_WEBHOOK_URL=https://hooks.slack.com/services/xxx<br/>docker-compose build<br/>docker-compose up</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5f85" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">控制微服务</h1><p id="2f5f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您使用Docker Swarm，这里有一个更完整的示例，作为Docker合成文件，以便在管理器上部署它来监控和修复您的服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的配置示例中，我们将假设一个应用程序正在使用分布式服务A和B。即使从Docker的角度来看服务A和B是健康的，我们也会使用专用的健康检查端点来测试从应用程序的角度来看它们是否也是可到达的。如果失败，将会发出通知，并且目标服务将会自动重新启动:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a97b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="dad6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望您会发现这个解决方案非常简单和有用。如果是这样，请立即在新的kontrol <a class="ae ky" href="https://github.com/kalisio/kontrol" rel="noopener ugc nofollow" target="_blank">存储库</a>上打开问题或PRs。</p><p id="338f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对构建一个基于微服务的平台感兴趣，你可能想看看一些开源项目，比如:</p><ul class=""><li id="143a" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">Kaabah ，一个构建和运营Docker群基础设施的解决方案。</li><li id="eb9d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://kalisio.github.io/kargo/" rel="noopener ugc nofollow" target="_blank"> Kargo </a>，一个基于Docker的解决方案，用于在Docker Swarm基础设施上部署服务。</li></ul><p id="cace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这篇文章中介绍的是Kargo内置监控栈的<a class="ae ky" href="https://kalisio.github.io/kargo/reference/environment.html#kontrol" rel="noopener ugc nofollow" target="_blank">部分。</a></p></div></div>    
</body>
</html>