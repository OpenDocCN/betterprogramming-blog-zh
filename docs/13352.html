<html>
<head>
<title>Understanding the Layered Architecture With KMM, Part 3 — The Domain Layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用KMM理解分层架构，第3部分—领域层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-layered-architecture-with-kmm-part-3-the-domain-layer-3df5e1fa3e6a?source=collection_archive---------12-----------------------#2022-08-18">https://betterprogramming.pub/understanding-the-layered-architecture-with-kmm-part-3-the-domain-layer-3df5e1fa3e6a?source=collection_archive---------12-----------------------#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7075" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分，共5部分</h2></div><p id="5489" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">KMM项目的理念是能够尽可能多地重用代码。业务逻辑不会因平台而异，它总是相同的，所以我们的域层(将是纯Kotlin)在项目的共享模块中是有意义的。</p><p id="770c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一层可以被任何平台重用，无论是web、移动还是终端。这是我们定义仓库和用例或交互器的契约或接口的地方。对于当前的例子，我们只有一个交互器:<code class="fe lb lc ld le b">GetMoviesInteractor</code>，顾名思义，它将处理获取电影并依赖于<code class="fe lb lc ld le b">MovieRepository</code>库，后者将是我们的<code class="fe lb lc ld le b">domain</code>包中的一个接口。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="bd88" class="ln lo iq le b gy lp lq l lr ls">class GetMoviesInteractorImpl(private val repo: MovieRepository) {<br/>    override suspend fun execute(): List {<br/>        return repo.getMovies()<br/>    }<br/>}</span></pre><p id="c099" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以想象，域内的所有类和函数都不依赖于任何外部平台框架(无论是iOS、Android等)。它只取决于它自己和它的定义。我们的<code class="fe lb lc ld le b">GetMoviesInteractor</code>在其构造函数中期望任何实现<code class="fe lb lc ld le b">MovieRepository</code>接口的对象，并返回属于同一层的对象。</p><p id="d26c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能想知道，拥有一个除了调用简单的存储库功能什么都不做的用例有什么意义呢？乍一看可能没有多大意义(而且在很多情况下，尤其是在小app中，确实没有)，但是使用<em class="lt">交互器</em>可以简化业务逻辑的构建和维护。</p><p id="857c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设，我们的<code class="fe lb lc ld le b">Movie</code>模型有一个类型为<code class="fe lb lc ld le b">MovieDirector</code>(另一个类)的<code class="fe lb lc ld le b">directorDetail</code>属性。电影存储库不一定有导演信息，可能有必要向另一个存储库查询该信息。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4827" class="ln lo iq le b gy lp lq l lr ls">class GetMoviesInteractorImpl(<br/>    private val moviesRepo: MovieRepository,<br/>    private val directorsRepo: MovieDirectorRepository,<br/>    private val productionCompanyRepository: ProductionCompanyRepository<br/>) {<br/>    override suspend fun execute(): List {<br/>        val movies = moviesRepo.getAll()<br/>        val moviesDetail = movies.map { movie -&gt;<br/>            MovieDetail(<br/>                movie = movie,<br/>                director = directorsRepo.getDirectorDetailById(movie.directorId),<br/>                productionCompany = productionCompanyRepository.getCompanyDetailById(movie.productionCompanyId)<br/>            ) <br/>        }<br/>        return moviesDetail<br/>    }<br/>}</span></pre></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="e6ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们的<code class="fe lb lc ld le b">shared</code>模块(我们应用程序的所有共享核心都在这里)的结构如下:</p><ul class=""><li id="7dd8" class="mb mc iq kh b ki kj kl km ko md ks me kw mf la mg mh mi mj bi translated"><code class="fe lb lc ld le b">– androidMain</code>:这里我们添加了一个<em class="lt">数据库驱动工厂</em>，这是一个Android的SqlDelight实现。</li><li id="26e8" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated"><code class="fe lb lc ld le b">–iosMain</code>:同上，这里我们实现了iOS的SqlDelight数据库的实例。</li><li id="94a1" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la mg mh mi mj bi translated"><code class="fe lb lc ld le b">– commonMain</code>:这里是<em class="lt">多平台魔法</em>。在里面，我们将为我们的<code class="fe lb lc ld le b">domain</code>和<code class="fe lb lc ld le b">data</code>层划分。在域包中是我们的<em class="lt">交互器</em>、<code class="fe lb lc ld le b">Movie</code>模型和存储库接口。在图中，您可以看到一个<code class="fe lb lc ld le b">DispatcherProvider.kt</code>,它定义了Kotlin协程的调度程序，用于数据层中存储库或数据源的实现。</li></ul><figure class="lf lg lh li gt mq gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/70c633f3318175743a28bc42004bc7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/0*aLd9i66IMc9G1Fcl"/></div></figure><p id="2bcf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得澄清的是，在<code class="fe lb lc ld le b">androidMain</code>和<code class="fe lb lc ld le b">iosMain</code>包中，您会找到那些平台的Kotlin代码，比如SQLight数据库管理器。业务/领域层的代码可以在<code class="fe lb lc ld le b">commonMain</code>中找到，因为它是最可重用和独立的。</p><p id="e77c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在下一篇文章中看到数据层的结构。同时，应该清楚的是，域层(我们已经在域包中的<code class="fe lb lc ld le b">shared/commonMain</code>模块中实现了)是将被两个平台和数据层重用的层，因此它的实现被排除在<code class="fe lb lc ld le b">androidMain</code>和<code class="fe lb lc ld le b">iosMain</code>之外。</p><p id="2ca6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个重要的细节:不要忘记在我们的<code class="fe lb lc ld le b">shared</code>模块中添加Kotlin协程依赖。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2cc6" class="ln lo iq le b gy lp lq l lr ls">// shared/build.gradle.kts<br/>   sourceSets {<br/>        val coroutineVersion = "1.6.0-native-mt"<br/>        val commonMain by getting {<br/>            dependencies {<br/>                implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutineVersion") {<br/>                    version { strictly(coroutineVersion) }<br/>                }<br/>            }<br/>        }</span><span id="2183" class="ln lo iq le b gy mt lq l lr ls">        ...</span><span id="fb6b" class="ln lo iq le b gy mt lq l lr ls">    }</span></pre><p id="206c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在GitHub上关注项目的进展:</p><div class="mu mv gp gr mw mx"><a href="https://github.com/jflavio11/LayeredKMM" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">GitHub-jflavio 11/LayeredKotlinMultiplatform:展示分层的示例KMM应用程序…</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">这个项目是由一系列的职位，你可以在我的博客https://jflavio.com领域和数据层…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl mr mx"/></div></div></a></div><h1 id="fdec" class="nm lo iq bd nn no np nq nr ns nt nu nv jw nw jx nx jz ny ka nz kc oa kd ob oc bi translated">此帖子系列的拆分</h1><p id="007f" class="pw-post-body-paragraph kf kg iq kh b ki od jr kk kl oe ju kn ko of kq kr ks og ku kv kw oh ky kz la ij bi translated">这是我们讨论领域层的第二篇文章。下面，我们将讨论数据层。本指南分为以下帖子:</p><ol class=""><li id="4b33" class="mb mc iq kh b ki kj kl km ko md ks me kw mf la oi mh mi mj bi translated"><a class="ae oj" href="https://medium.com/better-programming/understanding-layered-architecture-in-a-kotlin-multiplatform-project-part-1-a7488f478978" rel="noopener">简介</a></li><li id="0a65" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la oi mh mi mj bi translated"><a class="ae oj" href="https://jflavio11.medium.com/understanding-layered-architecture-in-kmm-part-2-designing-the-solution-957e2b1fb536" rel="noopener">设计解决方案</a></li><li id="15b3" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la oi mh mi mj bi translated"><a class="ae oj" href="https://jflavio11.medium.com/understanding-the-layered-architecture-with-kmm-part-3-the-domain-layer-3df5e1fa3e6a" rel="noopener">创建领域层</a>(本帖)</li><li id="6f37" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la oi mh mi mj bi translated"><a class="ae oj" href="https://jflavio11.medium.com/understanding-layered-architecture-in-kmm-part-4-the-data-layer-6fc0e153fffb" rel="noopener">创建图层数据</a></li><li id="0a98" class="mb mc iq kh b ki mk kl ml ko mm ks mn kw mo la oi mh mi mj bi translated">实现表示层</li></ol></div></div>    
</body>
</html>