<html>
<head>
<title>Advanced Programming in Kotlin (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的高级编程(第3部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-programming-in-kotlin-2e01fbc39134?source=collection_archive---------19-----------------------#2020-02-03">https://betterprogramming.pub/advanced-programming-in-kotlin-2e01fbc39134?source=collection_archive---------19-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">kot Lin-您应该使用的独有功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/49feaa131b88068a1a3104fe7661de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*v4LXaVKgUORTM_BP565Q8g.jpeg"/></div></figure><p id="0473" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">今天我们将学习Kotlin的一些令人兴奋的特性，这些特性你可能还没有见过或使用过，还有一些你在用Kotlin编程时应该注意的事情。</p><p id="87c7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们开门见山吧！</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="0ff9" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">#1.参数数量可变的函数</h1><p id="21f9" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">在Kotlin中，我们可以向函数传递可变数量的参数。这意味着你可以给一个函数传递<code class="fe mq mr ms mt b">n</code>个参数。这个特性在Java里是有的，但是你知道在Kotlin里怎么做吗？看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e648" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以传递尽可能多的变量，但这并不意味着你可以传递一个<code class="fe mq mr ms mt b">ArrayList</code>。但是，有一种方法可以传递数组，也可以传递数组和单个字符串的组合。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="562b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">内部发生的是，当提到<code class="fe mq mr ms mt b">vararg</code>时，你传递的参数，无论是<code class="fe mq mr ms mt b">Array</code>格式还是各自的类型，都被转换成Kotlin编译器中的一个数组值，同时生成Java文件。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="6ef5" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">#2.优化递归函数</h1><p id="c022" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">调用递归函数在任何平台上都是代价高昂的。当递归函数本身包含昂贵的作业时，它将变得更加复杂。我们应该做些事情来优化功能，而<code class="fe mq mr ms mt b">tailrec </code>就是Kotlin的做法。看看一个简单的递归函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="310c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个看似简单，但是当你过了<code class="fe mq mr ms mt b">30000</code>而不是<code class="fe mq mr ms mt b">5</code>，会简单吗？如果函数<code class="fe mq mr ms mt b">Fact</code>有一些昂贵的操作，比如写入文件或套接字通信，会发生什么？你可以看到递归会使事情变得复杂。</p><p id="732d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不幸的是，Kotlin通过JVM不会对此做任何优化。但Kotlin只要在函数前加上<code class="fe mq mr ms mt b">tailrec </code>就能优化。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="d445" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">#3.财产委托</h1><p id="4926" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">假设我有一个属性，而不是必须获取和设置它的方法；当get或set被调用时，我想调用另一个类。要了解我在说什么，请看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1d00" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以在许多方面利用这个科特林代表团。我发现一个有用的方法是在<code class="fe mq mr ms mt b">preference</code>中去掉单独的<code class="fe mq mr ms mt b">get</code>和<code class="fe mq mr ms mt b">set</code>函数。看看</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b4e3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下一个有用的使用方法是观察一个变量值——这样当变量值改变时我们会得到通知。这样，如果有任何UI需要更新，我们可以做。看看下面的代码，看看如何观察一个变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="7463" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">#4.循环中的“步进”</h1><p id="6e42" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们都知道在科特林循环是如何工作的。你给一个初始值，并在每次迭代中递增，直到你提到的条件不满足。看一下下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="bb77" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，如果您只想打印循环的每三次迭代，该怎么办呢？这就是<code class="fe mq mr ms mt b">step </code>派上用场的地方。我们需要提到<code class="fe mq mr ms mt b">step 3</code>，Kotlin会处理好事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b2f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这非常有用，但根据romainguy在KotlinConfig 2019中的说法，这将大幅增加大小，所以你应该只把它作为最后的救援手段。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="6cb3" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">#5.懒惰的</h1><p id="0289" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">假设您的类中有一个变量，它的值是通过执行一项昂贵的工作获得的，但该变量只有在用户访问屏幕上的特定功能时才有用。处理这个问题的最简单的方法是最初将变量设为null，并在用户访问该特性时初始化该值。但是我们必须在每次访问变量的时候使用空值检查。</p><p id="37ea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以做得更好，我们可以通过两种方式来实现，一种是将这个变量称为<code class="fe mq mr ms mt b">lateinit var</code> <strong class="ks iu"> </strong>，并在需要时进行初始化。另一种方式是<strong class="ks iu"> </strong>懒初始化。</p><p id="4c61" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">还记得我们上面讨论的财产委托吗？在这里，我们使用Kotlin委托来初始化这个变量。为此，我们首先需要创建一个可以在整个项目的任何地方使用的委托，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7f43" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个委托做什么:如果<code class="fe mq mr ms mt b">valueHolder</code>为空，并且第一次只有空，那么它将调用构造函数中传递的高阶函数，将结果值赋给<code class="fe mq mr ms mt b">valueHolder</code>，并返回它。</p><p id="5617" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们将使用这个委托和函数初始化变量，该函数会产生变量的值。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="a9b0" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">#6如何在Java中查看Kotlin代码</h1><p id="bd29" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">我们都知道，在幕后，Kotlin代码被转换成Java，然后是字节码，以便JVM能够理解和执行。你知道我们可以在Android studio中直接看到一个Kotlin文件的字节码吗？看一看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/80106bf86fa7ba64bb04383d0087e9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UfV1I7H2Ud510vl9R7Hs2A.png"/></div></div></figure><p id="99e1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当你点击最后一个选项<code class="fe mq mr ms mt b">Show Kotlin Bytecode</code>时，活动窗口Kotlin文件转换后的字节码显示在一个单独的窗口中。然后，您可以单击弹出窗口左上角的反编译选项来查看Java代码。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="cb95" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">#7.内部密封类</h1><p id="1317" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">状态管理是移动开发中至关重要的事情之一，尤其是在Android中，我们必须为不同的状态做不同的事情。例如，当我们发出网络请求时，结果可能是<code class="fe mq mr ms mt b">Success</code>或<code class="fe mq mr ms mt b">Error</code>。</p><p id="7c83" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这很简单，这个<code class="fe mq mr ms mt b">sealed class</code>可以做对:</p><pre class="kj kk kl km gt nb mt nc nd aw ne bi"><span id="7d83" class="nf lu it mt b gy ng nh l ni nj"><strong class="mt iu">sealed class Result </strong>{<br/>    <strong class="mt iu">class Sucess </strong>: Result()<br/>    <strong class="mt iu">class Error </strong>: Result()<br/>}</span></pre><p id="a520" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果有两种不同的错误，比如未知错误和本地错误，该怎么办？如果操作也不同，比如当服务器出错时，我想显示一个警告对话框。当一个本地错误发生时，我想显示一个<code class="fe mq mr ms mt b">Toast</code>。这就是内部密封类发挥作用的地方，它提供了一个更简洁明了的结构。看一看:</p><pre class="kj kk kl km gt nb mt nc nd aw ne bi"><span id="2e43" class="nf lu it mt b gy ng nh l ni nj"><strong class="mt iu">sealed class Result </strong>{<br/>    <strong class="mt iu">class Sucess </strong>: Result()<br/>    <strong class="mt iu">sealed class ErrorType </strong>: Result() {<br/>        <strong class="mt iu">class remoteError </strong>: ErrorType()<br/>        <strong class="mt iu">class localError </strong>: ErrorType()<br/>    }<br/>}</span></pre><p id="2f1e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在操控部分，用mighty <code class="fe mq mr ms mt b">when</code>来看看还是挺舒服的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="2243" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">更新</h1><p id="2891" class="pw-post-body-paragraph kq kr it ks b kt ml ju kv kw mm jx ky kz mn lb lc ld mo lf lg lh mp lj lk ll im bi translated">要了解更多关于Kotlin的内容，请阅读Kotlin高级编程系列中的其他文章:</p><ul class=""><li id="934e" class="nk nl it ks b kt ku kw kx kz nm ld nn lh no ll np nq nr ns bi translated"><a class="ae nt" href="https://medium.com/better-programming/advanced-android-programming-with-kotlin-5e40b1be22bb" rel="noopener">“用Kotlin进行高级编程</a></li><li id="3dd9" class="nk nl it ks b kt nu kw nv kz nw ld nx lh ny ll np nq nr ns bi translated"><a class="ae nt" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“用Kotlin进行高级编程—第二部分</a>”</li><li id="069e" class="nk nl it ks b kt nu kw nv kz nw ld nx lh ny ll np nq nr ns bi translated"><a class="ae nt" href="https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048" rel="noopener">“使用Kotlin进行高级编程—第4部分”</a></li><li id="e9cf" class="nk nl it ks b kt nu kw nv kz nw ld nx lh ny ll np nq nr ns bi translated"><a class="ae nt" href="https://medium.com/better-programming/advanced-programming-in-kotlin-part-5-b674ce9e692f" rel="noopener">“使用Kotlin进行高级编程—第5部分”</a></li></ul><p id="09eb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要进一步了解Kotlin协同程序和其他高级特性，请阅读以下文章:</p><p id="3906" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae nt" href="https://medium.com/better-programming/kotlin-coroutines-from-basics-to-advanced-ad3eb1421006" rel="noopener"> <strong class="ks iu">科特林协程，从基础到高级</strong> </a></p><p id="d8fa" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae nt" href="https://medium.com/@sgkantamani/sealed-classes-in-kotlin-e48e072daca8" rel="noopener"> <strong class="ks iu">科特林</strong> </a>中的密封类</p><p id="0bf5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae nt" href="https://medium.com/better-programming/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b" rel="noopener"> <strong class="ks iu">异步数据加载与新Kotlin流</strong> </a></p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="6c3d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">看看下面这个来自Kotlinconf 2019的演讲。我在这里解释的一些概念，是我从下面的谈话中学到的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz mv l"/></div></figure></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="7a30" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢阅读。</p></div></div>    
</body>
</html>