<html>
<head>
<title>JavaScript Type Checking With Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流进行JavaScript类型检查</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-type-checking-with-flow-more-about-functions-e1a9675782a7?source=collection_archive---------29-----------------------#2020-01-28">https://betterprogramming.pub/javascript-type-checking-with-flow-more-about-functions-e1a9675782a7?source=collection_archive---------29-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="83ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看看参数、函数类型、“这个”等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67a868f223155c68c5911eba8a8f8f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VARcpSFhNYdprsH9G8sIaw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lurm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Adrien Converse </a>在<a class="ae ky" href="https://unsplash.com/s/photos/flow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">unplash</a>上拍摄</p></figure><p id="a270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/facebook/flow" rel="noopener ugc nofollow" target="_blank"> Flow </a>是脸书生产的一种类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用来注释变量和函数参数的类型。</p><p id="ebd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解更多关于Flow函数的属性，包括箭头函数、函数类型等等。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d850" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">箭头函数</h1><p id="0d10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">箭头函数是在函数内部没有不同值<code class="fe mz na nb nc b">this</code>的函数。</p><p id="f3d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以向箭头函数添加类型注释，就像对流程中的任何其他函数一样。例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d4a9" class="nh md it nc b gy ni nj l nk nl">const foo = (str: string, bool?: boolean, ...nums: Array&lt;number&gt;): void =&gt; {<br/>  console.log(nums);<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98c9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">功能类型</h1><p id="e265" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以指定参数类型，并将函数的类型作为自己的类型注释返回。这叫做<em class="nm">函数类型。</em></p><p id="2eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型注释可以写如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c084" class="nh md it nc b gy ni nj l nk nl">const foo: (str: string, bool?: boolean, ...nums: Array&lt;number&gt;) =&gt; void = (str: string, bool?: boolean, ...nums: Array&lt;number&gt;): void =&gt; {<br/>  console.log(nums);<br/>}</span></pre><p id="26c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，代码…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d035" class="nh md it nc b gy ni nj l nk nl">(str: string, bool?: boolean, ...nums: Array&lt;number&gt;) =&gt; void</span></pre><p id="3316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…是<code class="fe mz na nb nc b">foo</code>函数的类型注释。它指定第一个参数是字符串，第二个是可选的布尔值，其余的是数字。此外，返回类型为<code class="fe mz na nb nc b">void</code>，如肥胖箭头后所述。</p><p id="b487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数类型注释对于回调函数这样的事情很方便:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dbd5" class="nh md it nc b gy ni nj l nk nl">const fn = (callback: (a: number, b: number) =&gt; number) =&gt; {</span><span id="8ee2" class="nh md it nc b gy nn nj l nk nl">}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7571" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">功能参数</h1><p id="d67a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以通过在参数名称后添加一个冒号，然后在参数的类型批注后添加一个类型批注来添加函数参数。</p><p id="334a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ee3d" class="nh md it nc b gy ni nj l nk nl">function method(a: string, b: boolean) {<br/>  <br/>}</span></pre><p id="f7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe mz na nb nc b">a</code>接受一个字符串，<code class="fe mz na nb nc b">b</code>接受一个布尔值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c335" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可选参数</h1><p id="0e78" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过在参数名称后添加问号来添加可选参数。</p><p id="a1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fa6b" class="nh md it nc b gy ni nj l nk nl">function foo(optionalString?: string) {<br/>  <br/>}</span></pre><p id="8bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以输入<code class="fe mz na nb nc b">undefined</code>、nothing，或者从<code class="fe mz na nb nc b">string</code>到<code class="fe mz na nb nc b">foo</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bdbc" class="nh md it nc b gy ni nj l nk nl">foo();          <br/>foo(undefined); <br/>foo("string");</span></pre><p id="9a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传递任何其他信息都会给我们带来错误。例如，写作…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c359" class="nh md it nc b gy ni nj l nk nl">foo(null);</span></pre><p id="d2cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…会给我们带来错误，因为它不是<code class="fe mz na nb nc b">string</code>、没有或<code class="fe mz na nb nc b">undefined</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="486d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">休息参数</h1><p id="d66d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用rest运算符，我们可以将任意数量的参数传递给一个函数。如果参数的数量大于固定参数的数量，那么rest运算符会将其他参数存储在一个数组中。</p><p id="1c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8e43" class="nh md it nc b gy ni nj l nk nl">function foo(a: number, ...args: Array&lt;number&gt;) {<br/>  console.log(args);<br/>}</span></pre><p id="e911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们这样称呼它时…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e0c5" class="nh md it nc b gy ni nj l nk nl">foo(1,2,3);</span></pre><p id="b0f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们将得到<code class="fe mz na nb nc b">[2,3]</code>作为<code class="fe mz na nb nc b">args</code>的值，因为在<code class="fe mz na nb nc b">args</code>上操作的rest操作符将超出第一个参数的值发送给<code class="fe mz na nb nc b">args</code>参数。</p><p id="0156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们还指定<code class="fe mz na nb nc b">args</code>是一个数字数组，所以传入任何东西都会导致错误。</p><p id="83a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型注释必须是一个<code class="fe mz na nb nc b">Array</code>类型，因为在JavaScript中，rest操作符参数总是存储在一个数组中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e6c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">函数返回类型</h1><p id="2270" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过在参数列表后添加类型注释来指定函数的返回类型。例如，如果我们想定义一个返回字符串的函数，那么我们可以编写下面的代码来创建一个返回字符串的函数:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5f3f" class="nh md it nc b gy ni nj l nk nl">function foo(): string {<br/>  return 'foo';<br/>}</span></pre><p id="333f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果为函数定义了返回类型，那么它必须在代码的所有分支中返回相同的数据类型。例如，如果我们写…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0389" class="nh md it nc b gy ni nj l nk nl">function foo(): string {<br/>  if (Math.random() &gt; 0.5){<br/>    return 'foo';<br/>  }<br/>}</span></pre><p id="2344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…这会给我们一个错误，因为<code class="fe mz na nb nc b">foo</code>并不总是返回一个字符串。要解决这个问题，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7545" class="nh md it nc b gy ni nj l nk nl">function foo(): string {<br/>  if (Math.random() &gt; 0.5){<br/>    return 'foo';<br/>  }<br/>  return 'bar';<br/>}</span></pre><p id="9e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后所有的分支返回一个字符串，流接受它为有效的。</p><p id="342f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数总是返回一个承诺，所以如果我们想包含它，返回类型的注释必须是一个承诺。</p><p id="8adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们应该这样写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3344" class="nh md it nc b gy ni nj l nk nl">async function foo(): Promise&lt;string&gt; {<br/>  return 'foo';<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/be1d4d577a4e82d062f067f534482226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ly--xn6O__AdCcDM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuanxu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">徐川</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e8e0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">这个的价值</h1><p id="446f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于箭头函数以外的函数,<code class="fe mz na nb nc b">this</code>的值根据函数的上下文而变化。在功能代码的顶层，<code class="fe mz na nb nc b">this</code>将取该功能的值。</p><p id="40fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Flow中，我们不注释<code class="fe mz na nb nc b">this</code>的值，我们应该让类型由我们调用函数的任何上下文来推断。</p><p id="a162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们用一个数字调用一个函数<code class="fe mz na nb nc b">foo</code>，如下…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c99c" class="nh md it nc b gy ni nj l nk nl">function foo() {<br/>  return this;<br/>}</span><span id="79de" class="nh md it nc b gy nn nj l nk nl">let num: number = foo.call(1);</span></pre><p id="c23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…那么<code class="fe mz na nb nc b">this</code>将是一个数字。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0890" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">谓词函数</h1><p id="21cf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Flow中，我们可以用<code class="fe mz na nb nc b">%checks</code>关键字将一个函数标记为谓词函数。谓词函数是检查条件的函数。</p><p id="d46d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过编写以下代码来定义一个:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1976" class="nh md it nc b gy ni nj l nk nl">function areStrings(a, b): boolean %checks {<br/>  return typeof a === 'string' &amp;&amp; typeof b === 'string';<br/>}</span></pre><p id="2f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c617" class="nh md it nc b gy ni nj l nk nl">function foo(a, b): string {<br/>  if (areStrings(a, b)){<br/>    return a + b;<br/>  }<br/>  return '';<br/>}</span></pre><p id="ec1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在其他谓词函数中调用谓词函数。例如，我们可以将前面的示例重写如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b5bb" class="nh md it nc b gy ni nj l nk nl">function isString(a): boolean %checks {<br/>  return typeof a === 'string'<br/>}</span><span id="12f3" class="nh md it nc b gy nn nj l nk nl">function areStrings(a, b): boolean %checks {<br/>  return isString(a) &amp;&amp; isString(b);<br/>}</span><span id="9762" class="nh md it nc b gy nn nj l nk nl">function foo(a, b): string {<br/>  if (areStrings(a, b)){<br/>    return a + b;<br/>  }<br/>  return '';<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="17e6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可调用对象</h1><p id="5e47" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以输入一个可调用的对象。例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d2c6" class="nh md it nc b gy ni nj l nk nl">type CallableObject = {<br/>  (string, string): string,<br/>  foo: string<br/>};</span><span id="759f" class="nh md it nc b gy nn nj l nk nl">function concat(x, y) {<br/>  return x + y;<br/>}</span><span id="f5f4" class="nh md it nc b gy nn nj l nk nl">concat.foo = "hello world";<br/>(concat: CallableObject);</span></pre><p id="d7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个被认为是<code class="fe mz na nb nc b">CallableObject</code>类型的对象，我们必须将其定义为一个具有所需签名和返回类型的函数。然后，我们必须添加所需的<code class="fe mz na nb nc b">foo</code>属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="124b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><code class="fe mz na nb nc b">Function</code>式</h1><p id="6448" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以通过对函数使用<code class="fe mz na nb nc b">(...args: Array&lt;any&gt;) =&gt; any</code>来指定更灵活的类型。这样，函数可以有任何签名并返回任何内容。例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b7a2" class="nh md it nc b gy ni nj l nk nl">function foo(fn: (...args: Array&lt;any&gt;) =&gt; any){<br/>  return fn();<br/>}</span></pre><p id="3189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以传入任何函数作为<code class="fe mz na nb nc b">foo</code>的回调函数:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e5f0" class="nh md it nc b gy ni nj l nk nl">foo((a) =&gt; true);<br/>foo((a , b) =&gt; a + b);</span></pre><p id="dd09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以给参数添加类型注释，并返回函数的类型。此外，通过指定签名和返回类型，我们可以对函数本身进行类型注释。</p><p id="9cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以用<code class="fe mz na nb nc b">%check</code>关键字指定谓词函数类型。我们也可以对Flow使用rest参数。rest参数必须具有数组类型。对于<code class="fe mz na nb nc b">async</code>函数，如果我们要添加一个返回类型，我们必须有一个<code class="fe mz na nb nc b">Promise</code>返回类型。</p><p id="8a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选参数的名称后面应该有一个问号。</p><p id="8471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他规则与JavaScript相同。</p></div></div>    
</body>
</html>