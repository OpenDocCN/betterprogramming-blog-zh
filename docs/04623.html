<html>
<head>
<title>JavaScript Best Practices for Creating Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建对象的JavaScript最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practices-for-writing-more-robust-code-creating-objects-428e55be6fd4?source=collection_archive---------1-----------------------#2020-04-25">https://betterprogramming.pub/javascript-best-practices-for-writing-more-robust-code-creating-objects-428e55be6fd4?source=collection_archive---------1-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="721a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">工厂功能、扩展原型等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55d7034fe034c8887ee02dcfb2274c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6CvNMcNLYA1W9mP6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@spacexuan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭锦恩</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="a43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种容易学习的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有用例并编写健壮的JavaScript代码。</p><p id="39b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究一些编写健壮JavaScript代码的最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58ff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用工厂功能</h1><p id="25ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">工厂函数是返回构造函数或类的新实例的函数。</p><p id="e1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用它们来创建对象，而不用编写任何带有<code class="fe mz na nb nc b">new</code>关键字的代码来实例化类或构造函数。</p><p id="244a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造函数经常是JavaScript中令人困惑的部分，如果我们愿意，我们肯定可以避免它。</p><p id="53b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以让自己的工厂运行如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="256c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有一个<code class="fe mz na nb nc b">createPerson</code>工厂函数，它接受一个<code class="fe mz na nb nc b">firstName</code>和<code class="fe mz na nb nc b">lastName</code>参数，并使用<code class="fe mz na nb nc b">firstName</code>、<code class="fe mz na nb nc b">lastName</code>和<code class="fe mz na nb nc b">fullName</code>方法返回一个对象。</p><p id="3053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用了一个箭头函数，这样我们就不会与返回对象中的值<code class="fe mz na nb nc b">this</code>混淆。由于箭头函数没有绑定到<code class="fe mz na nb nc b">this</code>，我们知道<code class="fe mz na nb nc b">fullName</code>中<code class="fe mz na nb nc b">this</code>的值就是返回的对象。</p><p id="67c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂函数可以用任何东西返回对象，所以可能性是无穷的。</p><p id="8278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用我们的<code class="fe mz na nb nc b">createPerson</code>工厂函数，我们可以编写以下代码:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="b009" class="nj md it nc b gy nk nl l nm nn">const person = createPerson('Jane', 'Smith');<br/>const fullName = person.fullName();</span></pre><p id="d6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe mz na nb nc b">createPerson</code>函数创建了一个<code class="fe mz na nb nc b">person</code>对象，然后在其上调用了<code class="fe mz na nb nc b">fullName</code>方法。</p><p id="c9c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe mz na nb nc b">fullName</code>是‘简·史密斯’，因为<code class="fe mz na nb nc b">this</code>引用了<code class="fe mz na nb nc b">person</code>对象。</p><p id="836f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多JavaScript函数像<code class="fe mz na nb nc b">Number</code>和<code class="fe mz na nb nc b">Boolean</code>都是工厂函数。它们接受任何对象作为参数，然后分别返回一个数字或布尔值。</p><p id="a2b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得我们的JavaScript代码更加健壮，因为我们不必担心类或构造函数实例。我们只需要考虑对象和组成函数。</p><p id="0a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组合函数使代码更具可重用性和可测试性，从而创建更健壮的代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6fae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通过附加到prototype属性为构造函数创建实例方法</h1><p id="c089" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们想要创建构造函数的实例方法时，我们应该将这些方法附加到构造函数的<code class="fe mz na nb nc b">prototype</code>属性上。</p><p id="e27b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，当我们实例化构造函数时，我们也可以调用实例上的方法。</p><p id="f1e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接附加到函数的方法是所有方法共享的静态方法。</p><p id="ae07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以将实例方法添加到构造函数中，方法是将它附加到它的<code class="fe mz na nb nc b">prototype</code>属性，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们创建了一个返回<code class="fe mz na nb nc b">Fruit</code>实例的<code class="fe mz na nb nc b">Fruit</code>构造函数。然后我们通过编写来添加<code class="fe mz na nb nc b">grow</code>实例方法:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="311d" class="nj md it nc b gy nk nl l nm nn">Fruit.prototype.grow = function() {<br/>  console.log(`${this.name} grew.`);<br/>}</span></pre><p id="6974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么当我们如下实例化它时:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="1dbc" class="nj md it nc b gy nk nl l nm nn">const fruit = new Fruit('apple');<br/>fruit.grow();</span></pre><p id="8fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实例方法将方法封装在构造函数实例中，防止它暴露给外部代码，并允许它进行意外的更改。</p><p id="a80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这使得我们的代码更加健壮。此外，每个构造函数都有自己的职责，因为它有自己的实例方法。这可以防止多个构造函数对同一个对象做不同的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">备选方案(如上)为每个实例创建一个<code class="fe mz na nb nc b">grow</code>实例方法的副本。该方法没有被缓存，所以以这种方式使用attach instance方法会比较慢。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="235f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用。类型属性来创建可以创建多种对象类型的工厂函数</h1><p id="7192" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为工厂函数可以被组合，所以我们可以创建一个可以创建多种类型对象的工厂函数。</p><p id="be8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe mz na nb nc b">type</code>属性来区分它们，这是一种区分我们想要创建的不同类型对象的传统方法。</p><p id="f532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="84b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有<code class="fe mz na nb nc b">createPet</code>工厂函数，它调用<code class="fe mz na nb nc b">createDog</code>或<code class="fe mz na nb nc b">createCat</code>工厂函数，这取决于我们传递给<code class="fe mz na nb nc b">createPet</code>的是哪种宠物<code class="fe mz na nb nc b">type</code>。</p><p id="b3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还通过调用<code class="fe mz na nb nc b">createPet</code>工厂函数内部的工厂函数来组合工厂函数。</p><p id="5201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们只需要担心一个工厂函数(<code class="fe mz na nb nc b">createPet</code>)，而不是使用多个工厂函数来创建不同种类的对象。这隐藏了代码下面的复杂性，因此当我们进行更改时，破坏东西的风险更小。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="347f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="43bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用工厂函数，我们可以创建它们来创建新的对象。我们也可以组合它们，并在一个工厂函数中调用不同的函数来做不同的事情。</p><p id="7e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有一个构造函数时，我们应该将实例方法附加到构造函数的<code class="fe mz na nb nc b">prototype</code>属性上，这样就不必一直重新创建它们。</p></div></div>    
</body>
</html>