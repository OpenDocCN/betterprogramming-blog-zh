<html>
<head>
<title>Docker Tips: Access the Docker Daemon via SSH</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:通过SSH访问Docker守护进程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-tips-access-the-docker-daemon-via-ssh-97cd6b44a53?source=collection_archive---------0-----------------------#2018-10-12">https://betterprogramming.pub/docker-tips-access-the-docker-daemon-via-ssh-97cd6b44a53?source=collection_archive---------0-----------------------#2018-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Docker 18.09开始，可以通过ssh访问该守护进程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3824144b6710c52f4b762855b808ba29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46kC94dk-JAHQsd29JrBrA.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="66b5" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">客户端/服务器通信</h1><p id="691c" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">Docker客户端通常通过unix套接字<code class="fe mp mq mr ms b">/var/run/docker.sock</code>在本地与守护进程通信，或者通过TCP套接字在网络上与守护进程通信。下面是启动时提供给Docker守护进程的选项的典型示例。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="6bbd" class="mx lc it ms b gy my mz l na nb"><strong class="ms iu">$ ps aux | grep dockerd</strong><br/>root 2900 0.1 4.4 388008 45424 ? Sl 09:28 0:01 /usr/local/bin/dockerd -g /var/lib/docker <br/><strong class="ms iu">-H unix:// <br/>-H tcp://0.0.0.0:2376</strong> <br/>--label provider=virtualbox <br/>--tlsverify <br/>--tlscacert=/var/lib/boot2docker/ca.pem<br/>--tlscert=/var/lib/boot2docker/server.pem<br/>--tlskey=/var/lib/boot2docker/server-key.pem<br/>--storage-driver aufs</span></pre><p id="2f66" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">这里有两个与客户机/服务器通信相关的重要标志:</p><ul class=""><li id="3587" class="nh ni it lv b lw nc lz nd mc nj mg nk mk nl mo nm nn no np bi translated"><code class="fe mp mq mr ms b">-H unix://</code> <em class="nq">，</em>指本地unix套接字<code class="fe mp mq mr ms b">/var/run/docker.sock</code>。在本地，Docker客户机使用这个套接字与守护进程通信。</li><li id="0d51" class="nh ni it lv b lw nr lz ns mc nt mg nu mk nv mo nm nn no np bi translated"><code class="fe mp mq mr ms b">-H tcp://0.0.0.0:2376</code>通过端口2376上的任何网络接口使守护程序可用。这个端口需要在安全组中打开(如果可能，限制为IP地址的白名单)，这样远程客户端就可以访问守护程序。</li></ul><p id="df0b" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">由于SSH被广泛使用，并且通常是默认允许的协议之一，所以通过SSH直接访问Docker守护进程可能会很方便。Docker 18.09让这成为可能，我们来测试一下。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="d87f" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">虚拟机的创建</h1><p id="50c4" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们将首先创建一个新的Docker主机，并确保它运行最新的Docker版本。我们使用<a class="ae nw" href="https://www.vagrantup.com/" rel="noopener ugc nofollow" target="_blank">vagger</a>，一个来自<a class="ae nw" href="https://www.hashicorp.com/" rel="noopener ugc nofollow" target="_blank"> Hashicorp </a>的伟大工具，在<a class="ae nw" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank"> VirtualBox </a>上供应和配置本地虚拟机。在新文件夹中，我们运行以下命令:</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="0cbc" class="mx lc it ms b gy my mz l na nb">$ vagrant init ubuntu/bionic64</span></pre><p id="86ff" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">这将生成一个名为“浮动文件”的文件，该文件定义了虚拟机应该如何设置。我们稍微修改了一下，看起来像这样:</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="142c" class="mx lc it ms b gy my mz l na nb"># -*- mode: ruby -*-<br/># vi: set ft=ruby :</span><span id="7268" class="mx lc it ms b gy nx mz l na nb">Vagrant.configure(“2”) do |config|<br/>  config.vm.box = “ubuntu/bionic64”</span><span id="06f2" class="mx lc it ms b gy nx mz l na nb">  # Bridge network configuration<br/>  config.vm.network “public_network”</span><span id="0d4a" class="mx lc it ms b gy nx mz l na nb">  config.vm.provision “shell”, inline: &lt;&lt;-SHELL<br/>    # Install last version of Docker<br/>    curl -fsSL <a class="ae nw" href="https://test.docker.com" rel="noopener ugc nofollow" target="_blank">https://test.docker.com</a> -o test-docker.sh<br/>    sh test-docker.sh # helper script installs the beta package</span><span id="e8a8" class="mx lc it ms b gy nx mz l na nb">    # Add default user in docker group<br/>    usermod -aG docker vagrant<br/>  SHELL<br/>end</span></pre><p id="17e3" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">基本上，我们告诉流浪者:</p><ul class=""><li id="b4b0" class="nh ni it lv b lw nc lz nd mc nj mg nk mk nl mo nm nn no np bi translated">基于<a class="ae nw" href="https://app.vagrantup.com/ubuntu" rel="noopener ugc nofollow" target="_blank"> Ubuntu Bionic64 </a>创建一个虚拟机。</li><li id="0b99" class="nh ni it lv b lw nr lz ns mc nt mg nu mk nv mo nm nn no np bi translated">使用桥接网络，以便可以从主机访问虚拟机。</li><li id="cbd0" class="nh ni it lv b lw nr lz ns mc nt mg nu mk nv mo nm nn no np bi translated">安装Docker的最新测试版本。</li><li id="6d69" class="nh ni it lv b lw nr lz ns mc nt mg nu mk nv mo nm nn no np bi translated">将默认的<code class="fe mp mq mr ms b">vagrant</code>用户添加到<code class="fe mp mq mr ms b">docker</code>组(每个命令上不再有<code class="fe mp mq mr ms b">sudo</code>)</li></ul><p id="58e0" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">然后，我们可以使用以下命令创建虚拟机:</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="45df" class="mx lc it ms b gy my mz l na nb">$ vagrant up</span></pre><p id="0a27" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">虚拟机启动后，我们通过SSH连接并检查网络接口，以获取它在LAN上的IP地址(在本例中是192.168.5.178)。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="b883" class="mx lc it ms b gy my mz l na nb"><strong class="ms iu">$ vagrant ssh</strong></span><span id="5315" class="mx lc it ms b gy nx mz l na nb"><strong class="ms iu">vagrant@ubuntu-bionic:~$ ip a</strong><br/>...<br/>3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br/> link/ether 08:00:27:75:93:48 brd ff:ff:ff:ff:ff:ff<br/> inet <strong class="ms iu">192.168.5.178/24</strong> brd 192.168.5.255 scope global dynamic enp0s8<br/> valid_lft 4242sec preferred_lft 4242sec<br/> inet6 fe80::a00:27ff:fe75:9348/64 scope link<br/> valid_lft forever preferred_lft forever</span></pre></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="02ca" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">通过SSH访问守护程序</h1><p id="8004" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在VM设置期间创建了一个额外的文件夹<code class="fe mp mq mr ms b">.vagrant</code>。这一个包含VM元数据和私有密钥，允许默认的流浪者用户进行无密码的SSH连接。我们使用以下命令将这个密钥添加到身份验证代理中(这样我们就不必在每次使用它时都指定它的路径):</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="9f61" class="mx lc it ms b gy my mz l na nb"><strong class="ms iu">$ ssh-add -k .vagrant/machines/default/virtualbox/private_key</strong><br/>Identity added: .vagrant/machines/default/virtualbox/private_key (.vagrant/machines/default/virtualbox/private_key)</span></pre><p id="ffba" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">我们现在可以通过SSH发出Docker命令，使用<code class="fe mp mq mr ms b">-H</code>标志，后跟SSH连接字符串。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="0c5c" class="mx lc it ms b gy my mz l na nb"><strong class="ms iu">$ docker -H ssh://vagrant@192.168.5.178 run -ti alpine echo “hello”</strong><br/>Unable to find image ‘alpine:latest’ locally<br/>latest: Pulling from library/alpine<br/>4fe2ade4980c: Pull complete<br/>Digest: sha256:621c2f39f8133a3a94dbdf0d5ca81102b9e57c0dc184cadaf5528<br/>Status: Downloaded newer image for alpine:latest<br/><strong class="ms iu">hello</strong></span></pre><p id="e464" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">当然，为了避免每个命令都使用这个标志，可以使用环境变量<code class="fe mp mq mr ms b">DOCKER_HOST</code>。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="a573" class="mx lc it ms b gy my mz l na nb"><strong class="ms iu">$ export DOCKER_HOST=ssh://vagrant@192.168.5.178</strong></span><span id="bc3c" class="mx lc it ms b gy nx mz l na nb"><strong class="ms iu">$ docker image ls</strong><br/>REPOSITORY TAG IMAGE ID CREATED SIZE<br/>alpine latest 196d12cf6ab1 4 weeks ago 4.41MB</span></pre><p id="e6e6" class="pw-post-body-paragraph lt lu it lv b lw nc ju ly lz nd jx mb mc ne me mf mg nf mi mj mk ng mm mn mo im bi translated">注意:“alpine<em class="nq">”</em>是主机上唯一可用的映像，它是在我们运行容器时下载的。</p></div></div>    
</body>
</html>