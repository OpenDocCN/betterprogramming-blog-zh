<html>
<head>
<title>How to Create Circuit Breaker in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中创建断路器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-circuit-breaker-in-ts-1416ba076760?source=collection_archive---------0-----------------------#2021-10-24">https://betterprogramming.pub/how-to-create-circuit-breaker-in-ts-1416ba076760?source=collection_archive---------0-----------------------#2021-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ac12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用纯类型脚本构建您自己的断路器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/37572302cc2d6b4e38cf46819e6b78ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_zwxTxAYo7dPeyta"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@esptroy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Troy Bridges </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="796d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你好世界！</p><p id="9e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我想和你分享如何为你的代码创建另一个安全机制。我相信每个人都会发现它很有用，有人可以更新他们的知识，获得新的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9550" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">断路器？</h1><p id="0417" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们弄清楚什么是断路器。从它的名字，你可能知道，它是一个自动操作的电气开关，设计用于在过载或短脉冲的情况下切断电源，以保护电路免受损坏。</p><p id="deec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种说法对我们来说是可以接受的，唯一的区别是—我们将保护某人的系统。为了保护我们的系统，我们必须使用另一种方法——背压，但这篇文章不是关于它的。</p><p id="6739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程环境中，我们希望有一种机制来阻止向第三方服务发送请求。当我们使用一些其他服务时，可能需要它，但是我们受限于每分钟的请求量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7bfd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">准备</h1><p id="92e2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们开始之前，我必须指出，有一些库提供了这个解决方案，所以没有必要自己实现它，但肯定的是，知道如何实现它是很好的。</p><p id="afc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们将使用<code class="fe mz na nb nc b">axios</code>，因为它可以很容易地中止请求。</p><p id="3a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从一个简单的<code class="fe mz na nb nc b">Http</code>类开始我们的代码，它将负责发送请求。</p><p id="36ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有一个非常简单的界面…</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f689" class="nh md it nc b gy ni nj l nk nl">import { AxiosInstance } from 'axios';</span><span id="2271" class="nh md it nc b gy nm nj l nk nl">interface IHttp {<br/>  instance: AxiosInstance;<br/>}</span></pre><p id="10ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…以及实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用法的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="6a91" class="mc md it bd me mf np mh mi mj nq ml mm jz nr ka mo kc ns kd mq kf nt kg ms mt bi translated">履行</h1><p id="bcbe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从一个接口开始。它将只有一个公共方法来知道断路器是否打开:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="13b2" class="nh md it nc b gy ni nj l nk nl">interface ICircuitBreaker {<br/>  getStatus(): boolean;<br/>}</span></pre><p id="ac7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">CircuitBreaker</code>将是一个类，它接受<code class="fe mz na nb nc b">Http</code>类和一些选项。让我们也通过界面来描述这些选项:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="276d" class="nh md it nc b gy ni nj l nk nl">interface ICircuitBreakerOptions {<br/>  timeout: number;<br/>  errorHandler: (error: any) =&gt; boolean;<br/>}</span></pre><p id="141f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">timeout</code>是断路器阻止请求的一段时间——冷却时间。</p><p id="f956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">errorHandler</code>是接收请求错误的功能，根据该功能的响应，断路器将被打开。我们需要它在特定时间打开断路器——通常是当我们有429错误而不是400或404时。</p><p id="ae66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的基本类是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="22ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个构造函数中，我们接受<code class="fe mz na nb nc b">Http</code>类(以后会用到)、选项— <code class="fe mz na nb nc b">timeout</code>和<code class="fe mz na nb nc b">errorHandler</code>函数。同样默认情况下，一个类有一个<code class="fe mz na nb nc b">isOpen</code>布尔值，它指示断路器是否打开。方法<code class="fe mz na nb nc b">getStatus</code>只是返回当前状态。</p><p id="9102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在该介绍真正的逻辑了。我们将增加两个功能<code class="fe mz na nb nc b">interceptErrorResponse</code>和<code class="fe mz na nb nc b">openCircuitBreaker</code>。第一个负责处理来自请求的错误，第二个负责断开断路器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="30f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑非常简单——当它捕捉到一个错误时，它将它传递给<code class="fe mz na nb nc b">this.errorHandler</code>。如果函数返回<code class="fe mz na nb nc b">true</code>，则意味着断路器应该打开。如果以前没有打开过，我们会触发一个相关的函数。在<code class="fe mz na nb nc b">openCircuitBreaker</code>中，我们只需改变<code class="fe mz na nb nc b">isOpen</code>的状态，并设置一个超时(从<code class="fe mz na nb nc b">this.timeout</code>开始有一个必要的持续时间)来将其切换回来。</p><p id="49ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦它被打开，我们需要一个机制来停止发送请求。在我们的例子中，它将是<code class="fe mz na nb nc b">interceptRequest</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="b6c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能使用<code class="fe mz na nb nc b">axios</code>的能力来中止请求。如果断路器打开，我们通过<code class="fe mz na nb nc b">cancelToken</code>来阻止请求的发送，并通过相关的错误信息——“断路器打开”。</p><p id="6bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，我们需要将我们的函数与来自<code class="fe mz na nb nc b">Http</code>类的<code class="fe mz na nb nc b">axios instance</code>连接起来。在构造函数内部，我们将使用<code class="fe mz na nb nc b">interceptors</code>来完成这项工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="76c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">this</code>需要不丢失断路器类的上下文。</p><p id="9caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在完成了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="c091" class="mc md it bd me mf np mh mi mj nq ml mm jz nr ka mo kc ns kd mq kf nt kg ms mt bi translated">高级版本</h1><p id="519e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">然而，我们的版本运行良好，总有一些改进的空间。我提议给我们的断路器添加事件。要做到这一点，我们需要一个事件发射器，我们可以尝试自己创建它。关于创建你自己的事件发射器的文章可以在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-your-own-event-emitter-in-javascript-fbd5db2447c4">这里</a>找到。</p><p id="a10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个界面开始:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f062" class="nh md it nc b gy ni nj l nk nl">interface IEventEmitter {<br/>  on(name: string, listener: Function): void;<br/>  removeListener(name: string, listener: Function): void;<br/>  emit(name: string, data?: any): void;<br/>}</span></pre><p id="7dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们未来的类将由3个公共方法组成:<code class="fe mz na nb nc b">on</code>用于将侦听器附加到特定事件上，<code class="fe mz na nb nc b">removeListener</code>用于移除侦听器，最后但同样重要的是——<code class="fe mz na nb nc b">emit</code>用于发出事件。</p><p id="1e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将跳过创建事件发射器的步骤，因为这篇文章不是关于它的。以下是最终结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们能够将事件发射器与断路器类集成在一起。让我们从一个界面开始:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b473" class="nh md it nc b gy ni nj l nk nl">type CircuitBreakerEvents = 'OPEN' | 'CLOSE';</span><span id="126c" class="nh md it nc b gy nm nj l nk nl">interface ICircuitBreakerWithEmitter extends ICircuitBreaker {<br/>  on(event: CircuitBreakerEvents, listener: Function): void;<br/>}</span></pre><p id="f453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…还有一门课:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">区别在于:</p><ul class=""><li id="14f6" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">我们已经更新了<code class="fe mz na nb nc b">constructor</code>和一些属性。现在它已经初始化了<code class="fe mz na nb nc b">EventEmitter</code>；</li><li id="5c16" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">我们已经实现了<code class="fe mz na nb nc b">on</code>方法，它只是将事件代理给真实的事件发射器；</li><li id="2f54" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">在<code class="fe mz na nb nc b">openCircuitBreaker</code>内部，我们在必要的地方触发<code class="fe mz na nb nc b">EventEmitter</code>(打开和关闭时)。</li></ul><h1 id="fbf9" class="mc md it bd me mf np mh mi mj nq ml mm jz nr ka mo kc ns kd mq kf nt kg ms mt bi translated">测试</h1><p id="972a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在是检验我们工作的时候了。首先我们需要一个第三方服务，在我们需要的时候会返回一个必要的错误。为此，我们可以创建一个简单的<code class="fe mz na nb nc b">express</code>服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="14d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它具有以下逻辑—在第三次请求时返回400错误，在第五次请求时返回429错误。</p><p id="ff18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在是最后一步——准备断路器和一个<code class="fe mz na nb nc b">http</code>客户端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ee5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">TestHttp</code>的帮助下，每2秒钟我们的服务器就会发送一个请求<code class="fe mz na nb nc b">GET</code> <code class="fe mz na nb nc b">http://localhost:5000/test/</code>。当请求返回429错误时- <code class="fe mz na nb nc b">CircuitBreakerWithEmitter</code>阻塞触发<code class="fe mz na nb nc b">http</code>客户端10秒钟。当断路器断开/闭合时，事件发射器将发送相关信息。</p><h1 id="7109" class="mc md it bd me mf np mh mi mj nq ml mm jz nr ka mo kc ns kd mq kf nt kg ms mt bi translated">演示文稿</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ca5cdab50f17df86ca0db9991140f84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*HRs2DOqaVjcFw8_54JbfSA.gif"/></div></figure><p id="d767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的gif中，你可以看到，断路器忽略了400个错误(在每个第三次请求时发生)。当服务器返回429错误时，它会在每第5次请求时打开一个断路器。此外，当断路器打开时，请求不能被发送，它们被中止。</p><h1 id="b0a2" class="mc md it bd me mf np mh mi mj nq ml mm jz nr ka mo kc ns kd mq kf nt kg ms mt bi translated">摘要</h1><p id="6c77" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，我想再强调一次——上面的例子可以用于学习目的，而不是用于生产环境。有很多解决方案可以找到，我肯定会建议使用它们。同时，知道什么是“引擎盖下”总是好的。</p></div></div>    
</body>
</html>