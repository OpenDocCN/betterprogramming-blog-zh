<html>
<head>
<title>8 Common Data Structures in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的8种常见数据结构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-common-data-structures-in-javascript-3d3537e69a27?source=collection_archive---------2-----------------------#2019-10-08">https://betterprogramming.pub/8-common-data-structures-in-javascript-3d3537e69a27?source=collection_archive---------2-----------------------#2019-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4844" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更好地了解数据结构是如何工作的</h2></div><p id="5f4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这听起来熟悉吗:“我通过完成兼职课程开始前端开发”</p><p id="6c4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能希望提高你的计算机科学基础知识，尤其是数据结构和算法。今天我们将讨论一些常见的数据结构，并用JavaScript实现它们。</p><p id="8631" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这篇文章能补充你的技能！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/d59ba13fe6054a5d52c326750f1879a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Slu14tK1Ge-trxTiBDkbng.png"/></div></div></figure><h2 id="b0bf" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak"> 1。堆栈</strong></h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/0fcd66048f27aa69881560a4a7fceaed.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*qIrnEjtsini8lrwIO0ntPA.png"/></div></figure><p id="e74b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆栈遵循后进先出的原则。如果你叠书，最上面的书会比最下面的先拿走。或者当您浏览互联网时，后退按钮会将您带到最近浏览的页面。</p><p id="875f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Stack有这些常用的方法:</p><ul class=""><li id="fd08" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">push</code>:输入新元素</li><li id="adea" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">pop</code>:移除顶部元素，返回移除的元素</li><li id="858b" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">peek</code>:返回顶层元素</li><li id="9bf7" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">length</code>:返回堆栈中元素的个数</li></ul><p id="6888" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Javascript中的数组具有栈的属性，但是我们通过使用<code class="fe mt mu mv mw b">function Stack()</code>从零开始构造一个栈</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="026b" class="lq lr it mw b gy ng nh l ni nj">function Stack() {<br/>this.count = 0;<br/>  this.storage = {};<br/><br/>  this.push = function (value) {<br/>    this.storage[this.count] = value;<br/>    this.count++;<br/>  }<br/><br/>  this.pop = function () {<br/>    if (this.count === 0) {<br/>      return undefined;<br/>    }<br/>    this.count--;<br/>    var result = this.storage[this.count];<br/>    delete this.storage[this.count];<br/>    return result;<br/>  }<br/><br/>  this.peek = function () {<br/>    return this.storage[this.count - 1];<br/>  }<br/><br/>  this.size = function () {<br/>    return this.count;<br/>  }<br/>}</span></pre><h2 id="212a" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak"> 2。队列</strong></h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fcffb49ce38af7f4e34b2ed0106f46b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*6eCq8aT9EKBWJLzAQPPL0Q.png"/></div></figure><p id="da67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">队列类似于堆栈。唯一的区别是队列使用FIFO原则(先进先出)。换句话说，当你排队等车时，总是第一个上车。</p><p id="1be0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">队列有以下方法:</p><ul class=""><li id="79d5" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">enqueue</code>:进入队列，在末尾增加一个元素</li><li id="b8d1" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">dequeue</code>:离开队列，移除前面的元素并返回</li><li id="6e21" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">front</code>:获取第一个元素</li><li id="2e9a" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">isEmpty</code>:判断队列是否为空</li><li id="8cf0" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">size</code>:获取队列中元素的数量</li></ul><p id="8528" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的数组具有队列的一些属性，所以我们可以用数组来构造一个队列的例子:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="5506" class="lq lr it mw b gy ng nh l ni nj">function Queue() {<br/>  var collection = [];<br/>  this.print = function () {<br/>    console.log(collection);<br/>  }<br/>  this.enqueue = function (element) {<br/>    collection.push(element);<br/>  }<br/>  this.dequeue = function () {<br/>    return collection.shift();<br/>  }<br/>  this.front = function () {<br/>    return collection[0];<br/>  }<br/><br/>  this.isEmpty = function () {<br/>    return collection.length === 0;<br/>  }<br/>  this.size = function () {<br/>    return collection.length;<br/>  }<br/>}</span></pre><h2 id="486f" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak">优先队列</strong></h2><p id="d8e4" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">队列有另一个高级版本。为每个元素分配优先级，它将根据优先级进行排序:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="0312" class="lq lr it mw b gy ng nh l ni nj">function PriorityQueue() {<br/><br/>  ...<br/><br/>  this.enqueue = function (element) {<br/>    if (this.isEmpty()) {<br/>      collection.push(element);<br/>    } else {<br/>      var added = false;<br/>      for (var i = 0; i &lt; collection.length; i++) {<br/>        if (element[1] &lt; collection[i][1]) {<br/>          collection.splice(i, 0, element);<br/>          added = true;<br/>          break;<br/>        }<br/>      }<br/>      if (!added) {<br/>        collection.push(element);<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="d345" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试它:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="6623" class="lq lr it mw b gy ng nh l ni nj">var pQ = new PriorityQueue();<br/>pQ.enqueue([ gannicus , 3]);<br/>pQ.enqueue([ spartacus , 1]);<br/>pQ.enqueue([ crixus , 2]);<br/>pQ.enqueue([ oenomaus , 4]);<br/>pQ.print();</span></pre><p id="ae4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="f0b5" class="lq lr it mw b gy ng nh l ni nj">[<br/>  [  spartacus , 1 ],<br/>  [  crixus , 2 ],<br/>  [  gannicus , 3 ],<br/>  [  oenomaus , 4 ]<br/>]</span></pre><h2 id="863a" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak"> 3。链表</strong></h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a40ab85b2cfd1d0a52f210630f442417.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*bPKHDqhRAzUoILC1IQN2Sw.png"/></div></figure><p id="55f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从字面上看，链表是一个链式的数据结构，每个节点由两条信息组成:该节点的数据和指向下一个节点的指针。链表和传统数组都是串行存储的线性数据结构。当然，他们也有不同之处:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nr"><img src="../Images/63e691ec62c8020108a8a4d80fb12b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cr_Y17z9PX3Qv-8M80tUAw.png"/></div></div></figure><p id="05ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单向链表通常有以下方法:</p><ul class=""><li id="bd49" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">size</code>:返回节点数</li><li id="e8f8" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">head</code>:返回头部元素</li><li id="dbf1" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">add</code>:在尾部添加另一个节点</li><li id="1a89" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">remove</code>:删除某个节点</li><li id="9ef0" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">indexOf</code>:返回一个节点的索引</li><li id="63bb" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">elementAt</code>:返回索引的节点</li><li id="2eb9" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">addAt</code>:在特定索引处插入一个节点</li><li id="f802" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">removeAt</code>:删除特定索引处的节点</li></ul><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="2947" class="lq lr it mw b gy ng nh l ni nj">/** Node in the linked list **/<br/>function Node(element) {  <br/>    // Data in the node<br/>    this.element = element;  <br/>    // Pointer to the next node <br/>    this.next = null;<br/>}<br/>    function LinkedList() {  <br/>        var length = 0;  <br/>        var head = null;  <br/>        this.size = function () {    <br/>            return length;  <br/>        }  <br/>        this.head = function () {    <br/>            return head;  <br/>        }  <br/>        this.add = function (element) {    <br/>            var node = new Node(element);    <br/>            if (head == null) {      <br/>                head = node;    <br/>            } else {      <br/>                var currentNode = head;      <br/>                while (currentNode.next) {        <br/>                    currentNode = currentNode.next;      <br/>                }      <br/>                currentNode.next = node;    <br/>            }    <br/>            length++;  <br/>        }  <br/>        this.remove = function (element) {    <br/>            var currentNode = head;    <br/>            var previousNode;    <br/>            if (currentNode.element === element) {      <br/>                head = currentNode.next;    <br/>            } else {      <br/>                while (currentNode.element !== element) {        <br/>                    previousNode = currentNode;        <br/>                    currentNode = currentNode.next;      <br/>                }      <br/>                previousNode.next = currentNode.next;    <br/>            }    <br/>            length--;  <br/>        }  <br/>        this.isEmpty = function () {    <br/>            return length === 0;  <br/>        }  <br/>        this.indexOf = function (element) {    <br/>            var currentNode = head;    <br/>            var index = -1;    <br/>            while (currentNode) {      <br/>                index++;      <br/>                if (currentNode.element === element) {        <br/>                    return index;      <br/>                }      <br/>                currentNode = currentNode.next;    <br/>            }    <br/>            return -1;  <br/>        }  <br/>        this.elementAt = function (index) {    <br/>            var currentNode = head;    <br/>            var count = 0;    <br/>            while (count &lt; index) {      <br/>                count++;      <br/>                currentNode = currentNode.next;    <br/>            }    <br/>            return currentNode.element;  <br/>        }  <br/>        this.addAt = function (index, element) {    <br/>            var node = new Node(element);    <br/>            var currentNode = head;    <br/>            var previousNode;    <br/>            var currentIndex = 0;    <br/>            if (index &gt; length) {      <br/>                return false;    <br/>            }    <br/>            if (index === 0) {      <br/>                node.next = currentNode;      <br/>                head = node;    <br/>            } else {      <br/>                while (currentIndex &lt; index) {        <br/>                    currentIndex++;        <br/>                    previousNode = currentNode;        <br/>                    currentNode = currentNode.next;      <br/>                }      <br/>                node.next = currentNode;      <br/>                previousNode.next = node;    <br/>            }    <br/>            length++;  <br/>        }  <br/>        this.removeAt = function (index) {    <br/>            var currentNode = head;    <br/>            var previousNode;    <br/>            var currentIndex = 0;    <br/>            if (index &lt; 0 || index &gt;= length) {      <br/>                return null;    <br/>            }    <br/>            if (index === 0) {      <br/>                head = currentIndex.next;    <br/>            } else {      <br/>                while (currentIndex &lt; index) {        <br/>                    currentIndex++;        <br/>                    previousNode = currentNode;        <br/>                    currentNode = currentNode.next;      <br/>                }      <br/>                previousNode.next = currentNode.next;    <br/>            }    <br/>            length--;    <br/>            return currentNode.element;  <br/>        }<br/>    }</span></pre><h2 id="6f14" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak"> 4。设置</strong></h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/800fbe1278aa19d6dd15ff1a2e3b99cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*iRlwSeYGSInNqsi8GUouZw.png"/></div></figure><p id="cf54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">集合是数学中的一个基本概念:定义明确的不同对象的集合。ES6引入了集合的概念，集合与数组有一定程度的相似性。但是，集合不允许重复元素，并且不被索引。</p><p id="395c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">典型的集合有如下方法:</p><ul class=""><li id="06e0" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">values</code>:返回集合中的所有元素</li><li id="91b7" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">size</code>:返回元素个数</li><li id="2122" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">has</code>:判断一个元素是否存在</li><li id="3961" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">add</code>:将元素插入集合</li><li id="d419" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">remove</code>:从集合中删除元素</li><li id="3441" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">union</code>:返回两个集合的交集</li><li id="6a05" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">difference</code>:返回两套的差额</li><li id="09a7" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">subset</code>:判断某个集合是否是另一个集合的子集</li></ul><p id="8f6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了区分ES6中的<code class="fe mt mu mv mw b">set</code>,我们在下面的示例中声明为<code class="fe mt mu mv mw b">MySet</code>:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="ba05" class="lq lr it mw b gy ng nh l ni nj">function MySet() {  <br/>    var collection = [];  <br/>    this.has = function (element) {    <br/>        return (collection.indexOf(element) !== -1);  <br/>    }  <br/>    this.values = function () {    <br/>        return collection;  <br/>    }  <br/>    this.size = function () {    <br/>        return collection.length;  <br/>    }  <br/>    this.add = function (element) {    <br/>        if (!this.has(element)) {      <br/>            collection.push(element);      <br/>            return true;    <br/>        }    <br/>        return false;  <br/>    }  <br/>    this.remove = function (element) {    <br/>        if (this.has(element)) {      <br/>            index = collection.indexOf(element);      <br/>            collection.splice(index, 1);      <br/>            return true;    <br/>        }    <br/>        return false;  <br/>    }  <br/>    this.union = function (otherSet) {    <br/>        var unionSet = new MySet();    <br/>        var firstSet = this.values();    <br/>        var secondSet = otherSet.values();    <br/>        firstSet.forEach(function (e) {      <br/>            unionSet.add(e);    <br/>        });    <br/>        secondSet.forEach(function (e) {      <br/>            unionSet.add(e);    <br/>        });    <br/>        return unionSet;  }  <br/>        this.intersection = function (otherSet) {    <br/>            var intersectionSet = new MySet();    <br/>            var firstSet = this.values();    <br/>            firstSet.forEach(function (e) {      <br/>                if (otherSet.has(e)) {        <br/>                    intersectionSet.add(e);      <br/>                }    <br/>            });    <br/>            return intersectionSet;  <br/>        }  <br/>        this.difference = function (otherSet) {    <br/>            var differenceSet = new MySet();    <br/>            var firstSet = this.values();    <br/>            firstSet.forEach(function (e) {      <br/>                if (!otherSet.has(e)) {        <br/>                    differenceSet.add(e);      <br/>                }    <br/>            });    <br/>            return differenceSet;  <br/>        }  <br/>        this.subset = function (otherSet) {    <br/>            var firstSet = this.values();    <br/>            return firstSet.every(function (value) {      <br/>                return otherSet.has(value);    <br/>            });  <br/>        }<br/>    }</span></pre><h2 id="213d" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak"> 5。Hast表</strong></h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/06dd75bf01fd79c3e66c10ac52ac614e.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*rCTODsa0YDGG-JyJZGIlRg.png"/></div></figure><p id="c4db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哈希表是一种键值数据结构。由于通过键查询一个值的速度非常快，所以它通常用于地图、字典或对象数据结构中。如上图所示，哈希表使用一个<code class="fe mt mu mv mw b">hash function</code>将键转换成一列数字，这些数字作为对应键的值。用key取值速度极快，时间复杂度可以达到O(1)。相同的键必须返回相同的值，这是哈希函数的基础。</p><p id="b534" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哈希表有以下方法:</p><ul class=""><li id="88ae" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">add</code>:添加一个键值对</li><li id="65b5" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">remove</code>:删除键值对</li><li id="fdbb" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">lookup</code>:使用键查找相应的值</li></ul><p id="51d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Javascript中简化哈希表的示例:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="6d2a" class="lq lr it mw b gy ng nh l ni nj">function hash(string, max) {<br/>  var hash = 0;<br/>  for (var i = 0; i &lt; string.length; i++) {<br/>    hash += string.charCodeAt(i);<br/>  }<br/>  return hash % max;<br/>}<br/><br/>function HashTable() {<br/>  let storage = [];<br/>  const storageLimit = 4;<br/><br/>  this.add = function (key, value) {<br/>    var index = hash(key, storageLimit);<br/>    if (storage[index] === undefined) {<br/>      storage[index] = [<br/>        [key, value]<br/>      ];<br/>    } else {<br/>      var inserted = false;<br/>      for (var i = 0; i &lt; storage[index].length; i++) {<br/>        if (storage[index][i][0] === key) {<br/>          storage[index][i][1] = value;<br/>          inserted = true;<br/>        }<br/>      }<br/>      if (inserted === false) {<br/>        storage[index].push([key, value]);<br/>      }<br/>    }<br/>  }<br/><br/>  this.remove = function (key) {<br/>    var index = hash(key, storageLimit);<br/>    if (storage[index].length === 1 &amp;&amp; storage[index][0][0] === key) {<br/>      delete storage[index];<br/>    } else {<br/>      for (var i = 0; i &lt; storage[index]; i++) {<br/>        if (storage[index][i][0] === key) {<br/>          delete storage[index][i];<br/>        }<br/>      }<br/>    }<br/>  }<br/><br/>  this.lookup = function (key) {<br/>    var index = hash(key, storageLimit);<br/>    if (storage[index] === undefined) {<br/>      return undefined;<br/>    } else {<br/>      for (var i = 0; i &lt; storage[index].length; i++) {<br/>        if (storage[index][i][0] === key) {<br/>          return storage[index][i][1];<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h2 id="1ac2" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">6。树</h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/dd028e9cb02e61ef8de5691a9bfa2a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*S2hTiKJrxOlt6nbwUb95ng.png"/></div></figure><p id="6a5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">树形数据结构是一种多层结构。与数组、堆栈和队列相比，它也是一种非线性数据结构。这种结构在插入和搜索操作中非常高效。让我们来看看树数据结构的一些概念:</p><ul class=""><li id="c306" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">root</code>:树的根节点，根没有父节点</li><li id="d6e6" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">parent node</code>:上层的直接节点，只有一个</li><li id="391e" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">child node</code>:下级的直接节点，可以有多个</li><li id="a0c8" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">siblings</code>:共享同一个父节点</li><li id="8705" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">leaf</code>:无子节点</li><li id="21df" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">Edge</code>:节点间的分支或链接</li><li id="0803" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">Path</code>:从起始节点到目标节点的边</li><li id="a5fe" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">Height of Node</code>:特定节点到叶节点的最长路径的边数</li><li id="b6e1" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">Height of Tree</code>:根节点到叶节点的最长路径的边数</li><li id="bcd8" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">Depth of Node</code>:从根节点到特定节点的边数</li><li id="690d" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">Degree of Node</code>:子节点数</li></ul><p id="aaeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个二叉查找树的例子。每个节点最多有两个节点，左边的节点小于当前节点，右边的节点大于当前节点:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/bb210d6144c96d232c058a9c2b2d6a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*F_LCQ8dc15hbsrTWdACmXg.png"/></div></figure><p id="fb99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二叉查找树的常用方法:</p><ul class=""><li id="5d83" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">add</code>:在树中插入一个节点</li><li id="b170" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">findMin</code>:获取最小节点</li><li id="39cc" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">findMax</code>:获取最大节点</li><li id="c583" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">find</code>:搜索特定节点</li><li id="bb47" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">isPresent</code>:判断某个节点的存在</li><li id="836b" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">remove</code>:从树中删除一个节点</li></ul><p id="21ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript中的示例:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="5372" class="lq lr it mw b gy ng nh l ni nj">class Node {<br/>  constructor(data, left = null, right = null) {<br/>    this.data = data;<br/>    this.left = left;<br/>    this.right = right;<br/>  }<br/>}<br/><br/>class BST {<br/>  constructor() {<br/>    this.root = null;<br/>  }<br/><br/>  add(data) {<br/>    const node = this.root;<br/>    if (node === null) {<br/>      this.root = new Node(data);<br/>      return;<br/>    } else {<br/>      const searchTree = function (node) {<br/>        if (data &lt; node.data) {<br/>          if (node.left === null) {<br/>            node.left = new Node(data);<br/>            return;<br/>          } else if (node.left !== null) {<br/>            return searchTree(node.left);<br/>          }<br/>        } else if (data &gt; node.data) {<br/>          if (node.right === null) {<br/>            node.right = new Node(data);<br/>            return;<br/>          } else if (node.right !== null) {<br/>            return searchTree(node.right);<br/>          }<br/>        } else {<br/>          return null;<br/>        }<br/>      };<br/>      return searchTree(node);<br/>    }<br/>  }<br/><br/>  findMin() {<br/>    let current = this.root;<br/>    while (current.left !== null) {<br/>      current = current.left;<br/>    }<br/>    return current.data;<br/>  }<br/><br/>  findMax() {<br/>    let current = this.root;<br/>    while (current.right !== null) {<br/>      current = current.right;<br/>    }<br/>    return current.data;<br/>  }<br/><br/>  find(data) {<br/>    let current = this.root;<br/>    while (current.data !== data) {<br/>      if (data &lt; current.data) {<br/>        current = current.left<br/>      } else {<br/>        current = current.right;<br/>      }<br/>      if (current === null) {<br/>        return null;<br/>      }<br/>    }<br/>    return current;<br/>  }<br/><br/>  isPresent(data) {<br/>    let current = this.root;<br/>    while (current) {<br/>      if (data === current.data) {<br/>        return true;<br/>      }<br/>      if (data &lt; current.data) {<br/>        current = current.left;<br/>      } else {<br/>        current = current.right;<br/>      }<br/>    }<br/>    return false;<br/>  }<br/><br/>  remove(data) {<br/>    const removeNode = function (node, data) {<br/>      if (node == null) {<br/>        return null;<br/>      }<br/>      if (data == node.data) {<br/>        // no child node<br/>        if (node.left == null &amp;&amp; node.right == null) {<br/>          return null;<br/>        }<br/>        // no left node<br/>        if (node.left == null) {<br/>          return node.right;<br/>        }<br/>        // no right node<br/>        if (node.right == null) {<br/>          return node.left;<br/>        }<br/>        // has 2 child nodes<br/>        var tempNode = node.right;<br/>        while (tempNode.left !== null) {<br/>          tempNode = tempNode.left;<br/>        }<br/>        node.data = tempNode.data;<br/>        node.right = removeNode(node.right, tempNode.data);<br/>        return node;<br/>      } else if (data &lt; node.data) {<br/>        node.left = removeNode(node.left, data);<br/>        return node;<br/>      } else {<br/>        node.right = removeNode(node.right, data);<br/>        return node;<br/>      }<br/>    }<br/>    this.root = removeNode(this.root, data);<br/>  }<br/>}</span></pre><p id="b455" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试它:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="77b1" class="lq lr it mw b gy ng nh l ni nj">const bst = new BST();<br/>bst.add(4);<br/>bst.add(2);<br/>bst.add(6);<br/>bst.add(1);<br/>bst.add(3);<br/>bst.add(5);<br/>bst.add(7);<br/>bst.remove(4);<br/>console.log(bst.findMin());<br/>console.log(bst.findMax());<br/>bst.remove(7);<br/>console.log(bst.findMax());<br/>console.log(bst.isPresent(4));</span></pre><p id="3cf5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="edeb" class="lq lr it mw b gy ng nh l ni nj">1<br/>7<br/>6<br/>false</span></pre><h2 id="00a5" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak"> 7。Trie </strong>(读作“尝试”)</h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6c21d2ffc7bf18ecaab841370e5168d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*q3r9ipZsIhQpvcgeBnkQOw.png"/></div></figure><p id="a430" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Trie或“前缀树”也是一种搜索树。Trie逐步存储数据—树中的每个节点代表一个步骤。Trie用于存储词汇，因此可以快速搜索，特别是对于自动完成的功能。</p><p id="6226" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Trie中的每个节点都有一个字母表，跟随分支可以组成一个完整的单词。它还包括一个布尔指示器，用于显示这是否是最后一个字母表。</p><p id="9901" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Trie有以下方法:</p><ul class=""><li id="a5d9" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">add</code>:将单词插入字典树</li><li id="ea44" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">isWord</code>:判断树是否由某个单词组成</li><li id="8d78" class="mk ml it kk b kl mx ko my kr mz kv na kz nb ld mp mq mr ms bi translated"><code class="fe mt mu mv mw b">print</code>:返回树中的所有单词</li></ul><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="2545" class="lq lr it mw b gy ng nh l ni nj">/** Node in Trie **/<br/>function Node() {  <br/>    this.keys = new Map();  <br/>    this.end = false;  <br/>    this.setEnd = function () {    <br/>        this.end = true;  <br/>    };  <br/>    this.isEnd = function () {    <br/>        return this.end;  <br/>    }<br/>}<br/><br/>function Trie() {  <br/>        this.root = new Node();  <br/>        this.add = function (input, node = this.root) {    <br/>            if (input.length === 0) {     <br/>                node.setEnd();      <br/>                return;    <br/>            } else if (!node.keys.has(input[0])) {      <br/>                node.keys.set(input[0], new Node());      <br/>                return this.add(input.substr(1), node.keys.get(input[0]));    <br/>            } else {      <br/>                return this.add(input.substr(1), node.keys.get(input[0]));    <br/>            }  <br/>        }  <br/>        this.isWord = function (word) {    <br/>            let node = this.root;    <br/>            while (word.length &gt; 1) {      <br/>                if (!node.keys.has(word[0])) {        <br/>                    return false;      <br/>                } else {        <br/>                    node = node.keys.get(word[0]);       <br/>                    word = word.substr(1);      <br/>                }    <br/>            }    <br/>            return (node.keys.has(word) &amp;&amp; node.keys.get(word).isEnd()) ? true : false;  <br/>        }  <br/>            this.print = function () {    <br/>                let words = new Array();    <br/>                let search = function (node = this.root, string) {      <br/>                    if (node.keys.size != 0) {        <br/>                        for (let letter of node.keys.keys()) {          <br/>                            search(node.keys.get(letter), string.concat(letter));        <br/>                        }        <br/>                        if (node.isEnd()) {          <br/>                            words.push(string);        <br/>                        }      <br/>                    } else {        <br/>                        string.length &gt; 0 ? words.push(string) : undefined;        <br/>                        return;      <br/>                    }    <br/>                };    <br/>                search(this.root, new String());    <br/>                return words.length &gt; 0 ? words : null;  <br/>    }<br/>}</span></pre><h2 id="15f2" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak"> 8。图表</strong></h2><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ab1907c265b72ef256650893b88f8c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*U7clK_WA52dR-pBTezcMLQ.png"/></div></figure><p id="3495" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图，有时被称为网络，是指具有链接(或边)的节点集。它可以进一步分为两组(即有向图和无向图)，根据链接是否有方向。Graph在我们的生活中应用广泛——在导航app中计算最佳路线，或者在社交媒体中向好友推荐，举两个例子。</p><p id="9a8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图表有两种显示方式:</p><p id="c2a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">邻接表</strong></p><p id="e898" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个方法中，我们在左边列出所有可能的节点，在右边显示连接的节点。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/861891466f29525c976e4585a9a8820c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*U7K5TZP4WWTA7Gf0mZ30ew.png"/></div></figure><p id="64d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">邻接矩阵</strong></p><p id="a6e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">邻接矩阵显示行和列中的节点，行和列的交叉点解释节点之间的关系，0表示不链接，1表示链接，&gt; 1表示不同的权重。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7c6acc71a24bc65e2d855e0f0e848e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*mzU34MmP1nP00yhXfMwTCg.png"/></div></figure><p id="3632" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查询图中的节点，必须用呼吸优先搜索(BFS)法或深度优先搜索(DFS)法搜索整个树形网络。</p><p id="3cd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个Javascript中的BFS的例子:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="1150" class="lq lr it mw b gy ng nh l ni nj">function bfs(graph, root) {<br/>  var nodesLen = {};<br/>  for (var i = 0; i &lt; graph.length; i++) {<br/>    nodesLen[i] = Infinity;<br/>  }<br/>  nodesLen[root] = 0;<br/>  var queue = [root];<br/>  var current;<br/>  while (queue.length != 0) {<br/>    current = queue.shift();<br/><br/>    var curConnected = graph[current];<br/>    var neighborIdx = [];<br/>    var idx = curConnected.indexOf(1);<br/>    while (idx != -1) {<br/>      neighborIdx.push(idx);<br/>      idx = curConnected.indexOf(1, idx + 1);<br/>    }<br/>    for (var j = 0; j &lt; neighborIdx.length; j++) {<br/>      if (nodesLen[neighborIdx[j]] == Infinity) {<br/>        nodesLen[neighborIdx[j]] = nodesLen[current] + 1;<br/>        queue.push(neighborIdx[j]);<br/>      }<br/>    }<br/>  }<br/>  return nodesLen;<br/>}</span></pre><p id="7356" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试它:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="0b2d" class="lq lr it mw b gy ng nh l ni nj">var graph = [<br/>  [0, 1, 1, 1, 0],<br/>  [0, 0, 1, 0, 0],<br/>  [1, 1, 0, 0, 0],<br/>  [0, 0, 0, 1, 0],<br/>  [0, 1, 0, 0, 0]<br/>];<br/>console.log(bfs(graph, 1));</span></pre><p id="7251" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果:</p><pre class="lf lg lh li gt nc mw nd ne aw nf bi"><span id="e32b" class="lq lr it mw b gy ng nh l ni nj">{<br/>  0: 2,<br/>  1: 0,<br/>  2: 1,<br/>  3: 3,<br/>  4: Infinity<br/>}</span></pre><p id="3cb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这样——我们已经介绍了所有常见的数据结构，并给出了JavaScript示例。这应该会让你更好地了解数据结构在计算机中是如何工作的。编码快乐！</p></div></div>    
</body>
</html>