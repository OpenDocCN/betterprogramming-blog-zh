<html>
<head>
<title>Debugging Kubernetes Pods: Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试Kubernetes吊舱:深潜</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/debugging-kubernetes-pods-deep-dive-d6b2814cd8ce?source=collection_archive---------3-----------------------#2022-05-23">https://betterprogramming.pub/debugging-kubernetes-pods-deep-dive-d6b2814cd8ce?source=collection_archive---------3-----------------------#2022-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="540a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我将讨论使用临时容器调试和排除Kubernetes pods故障。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a5df94bcb132cf05a573bf4602642de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mTDQ6_ky9fHsiXig"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@zanilic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zan </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="77aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调试pods的最简单方法是进入有问题的pods，并尝试对发生的情况进行故障排除。这是一个简单的方法，但它有许多缺点。</p><ul class=""><li id="eac2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">正在运行的应用程序窗格可能没有解决现有问题所需的所有工具。</li><li id="5d47" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果您想要执行一些需要额外权限的操作，您将需要重新启动当前运行的应用程序窗格的所有窗格，以添加新的要求。</li><li id="1a09" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">他们通过在主docker映像中添加调试工具引入了安全风险，如果容器权限被提升也是如此。</li></ul><p id="b498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们探索另一种调试pod的方法。</p><h1 id="d430" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用临时调试容器进行调试</h1><p id="caad" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/" rel="noopener ugc nofollow" target="_blank">短暂容器</a>在<code class="fe nd ne nf ng b">kubectl exec</code>不足以进行交互式故障排除时非常有用，因为容器已经崩溃，或者容器映像不包括调试实用程序，如distroless映像，或者运行的容器没有调试所需的权限。</p><p id="c55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">临时容器背后的主要思想是K8S向现有的pod添加一个带有选定的自定义图像的新容器，而不需要重新启动这个pod。这个新的容器共享可以共享来自目标容器的许多资源，</p><ul class=""><li id="19fb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Linux网络名称空间</li><li id="05cc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Linux进程名称空间</li><li id="62d7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对共享卷的访问</li><li id="00b4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">访问k8s节点</li></ul><p id="0678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将为这些用例中的每一个给出一个例子。</p><p id="a12f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始演示之前，您需要一个版本为1.23的k8s集群。我推荐使用<code class="fe nd ne nf ng b"><a class="ae kv" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">kind</a></code>，但是您也可以使用任何其他供应器。</p><p id="8967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们首先为我们的演示创建一个集群</p><h1 id="3991" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">正在创建种类群集</h1><p id="2d05" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">创建一种新的集群就像运行命令<code class="fe nd ne nf ng b">kind create cluster</code>一样简单</p><p id="2e34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/704a7f8f8f5b5297756fe30bf866c248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wL9hfbtSkVdE0dGwLh_rtw.png"/></div></div></figure><p id="2f8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建群集后，您需要验证它是否已启动并且可以访问</p><p id="dfc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/c8323730a73153ce36a29d9cea038d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpW-ezXjRtdjE1vNtay-uA.png"/></div></div></figure><p id="d804" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们所有的操作都将从主<code class="fe nd ne nf ng b">kind</code>节点执行，因此我们需要通过<code class="fe nd ne nf ng b">docker exec -it &lt;kind-container-id&gt; bash</code>访问它</p><p id="1583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/1058b10f9b840d27420082584824a0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZ9jbGPF202NWKW-2euujw.png"/></div></div></figure><h1 id="f736" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">创建简单的工作负载</h1><p id="9187" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们将假设我们有一个想要调试的Nginx部署，所以让我们用一个副本创建一个Nginx部署。这将通过运行以下命令来完成</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="7d3f" class="no mh iq ng b gy np nq l nr ns">kubectl create deployment nginx --image=nginx</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/755b3d8e0b8041c28cf48d36a1559b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rs7AKyPAaezYevxSAtRB8w.png"/></div></div></figure><h1 id="e7af" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">网络活动故障排除</h1><p id="1a7b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">排除网络活动故障需要共享网络名称空间，当您将临时容器连接到正在运行的pod时，这是默认的Linux名称空间。</p><p id="a493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建第一个临时容器，我将使用<code class="fe nd ne nf ng b">knicolaka/netshoot</code>作为新临时容器的图像。该图像包含许多故障排除工具，如<code class="fe nd ne nf ng b">tcpdump</code>和strace</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="561c" class="no mh iq ng b gy np nq l nr ns">kubectl debug --it pod-name --image=&lt;ephemeral-container&gt; -- command</span></pre><p id="38b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">举例:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/13d9a61ace893f43757280bdbb18fadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-kzDqSaSEunJkJ8ABCF3g.png"/></div></div></figure><p id="d2b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们确认两个容器共享相同的Linux名称空间。打开主节点的新shell，并运行以下命令</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="22ed" class="no mh iq ng b gy np nq l nr ns">systemd-cgls -u kubelet-kubepods-besteffort.slice</span></pre><p id="4a9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/4c20f8c8e9307ff3d421b8ef02feffd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9OdtioGbLwb-SRCQzTpzg.png"/></div></div></figure><p id="8971" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的例子中，我们可以获得两个容器的主进程id</p><ul class=""><li id="ec51" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">2612 -&gt;临时容器的主进程ID</li><li id="aecc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">2259-&gt; Nginx容器的主进程ID</li></ul><p id="5f63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们检查每个进程的所有Linux名称空间</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/b47d2f8ef7153249ace75e4d8489f4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_qdLwqW3h4LpV7Lh1_PtA.png"/></div></div></figure><p id="1e89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从前面的截图中，我们发现两个进程都有相同的Linux网络名称空间id。</p><p id="bb1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们从临时容器中转储Nginx容器的网络数据包。</p><p id="fd90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在临时容器外壳中，运行以下命令</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="659e" class="no mh iq ng b gy np nq l nr ns">tcpdump -n port 80</span></pre><p id="311b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例输出:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/31e777127deed6d56a0890fdb3600a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PA4kNml1a4b4w3lMRxRjCQ.png"/></div></div></figure><p id="2ab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，尝试从k8s主节点向这个pod发送一些请求</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="d48e" class="no mh iq ng b gy np nq l nr ns">curl http://pod-ip-adderss</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/cc6b40ddea0665a57ad5ba1bcd986288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBX7kjhJelIHTsEWLTW6LA.png"/></div></div></figure><p id="7f93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您转到临时容器终端，您会发现TCP包的转储被打印到输出中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/10f2047f752db845e9f50bd7049a9336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXLAKvkw5xIF1gD31OzkiA.png"/></div></div></figure><p id="32d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们完成了第一次演示，现在，我们可以从临时容器中捕获网络数据包。</p><p id="678e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看第二个用例。</p><h1 id="d85c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用临时容器的跟踪/分析过程。</h1><p id="1759" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们的临时容器的下一个用例是从另一个容器跟踪一个容器中运行的进程。</p><p id="b873" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们需要:</p><ul class=""><li id="2d72" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">这两个容器必须共享同一个Linux进程名称空间。</li><li id="94cc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">短暂的容器必须有Linux功能<code class="fe nd ne nf ng b">SYS_PTRACE</code></li></ul><p id="01b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建临时容器时，通过添加一个额外的参数<code class="fe nd ne nf ng b">--target=&lt;container-name&gt;</code>，可以很容易地共享Linux进程名称空间</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="ce58" class="no mh iq ng b gy np nq l nr ns">kubectk debug -it &lt;pod-name &gt; --image=nicolaka/netshoot --target &lt;container-name&gt; -- bash</span></pre><p id="e07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/adba1c9fe47f79f01ea397cc4a1f3ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsuipTTDJcEGMSuSdLPKIA.png"/></div></div></figure><p id="8391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从之前的截图可以看出:</p><ol class=""><li id="446a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ob ly lz ma bi translated">为了共享进程名称空间，我们可以添加一个额外的命令参数<code class="fe nd ne nf ng b">--targer=&lt;cotainer-name&gt;</code></li><li id="3aad" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ob ly lz ma bi translated">从临时容器中，我们可以看到来自<code class="fe nd ne nf ng b">nginx</code>容器的所有正在运行的进程</li><li id="0d1b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ob ly lz ma bi translated">我们无法跟踪<code class="fe nd ne nf ng b">nginx</code>进程，因为临时容器没有发送<code class="fe nd ne nf ng b">ptrace</code>系统调用所需的权限。strace命令使用这个系统调用来暂停Linux进程，以记录每个<code class="fe nd ne nf ng b">nginx</code>发送给内核的系统调用。</li></ol><p id="5bb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何解决这个问题？不幸的是，我没有找到从<code class="fe nd ne nf ng b">kubectl</code>命令向临时容器传递额外权限的方法。所以我们将构造一个HTTP请求并发送给kube API服务器，而不使用<code class="fe nd ne nf ng b">kubectl</code>命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="2c9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你可以不经许可就拒绝<code class="fe nd ne nf ng b">strace</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/de6796221c91d45836942f8afe3d1ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3ZNldi141mmp_LvUejKdw.png"/></div></div></figure><p id="ba7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我添加了一个权限来做<code class="fe nd ne nf ng b">SYS_PTRACE</code>。但是这取决于您使用的调试器，或者简单地说，您可以给临时容器特权访问。所以你不需要担心你需要允许哪些系统调用。</p><p id="e498" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外要提到的是，您可以从临时容器中访问<code class="fe nd ne nf ng b">nginx</code>容器的文件系统。根文件系统在<code class="fe nd ne nf ng b">/proc/&lt;process-id&gt;/root</code>下。</p><p id="4634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看是否可以从临时容器中访问<code class="fe nd ne nf ng b">nginx</code> config。</p><p id="4158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/64b86dba6a35f8b6bb0e7da85d00d7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39cHswNsk4yA2xTnl6k_aQ.png"/></div></div></figure><p id="be1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在让我们开始最后选择的短暂容器用例</p><h1 id="3788" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">通过节点上的shell进行调试</h1><p id="121a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">有时候，您需要访问k8s节点，但是您没有对该节点的ssh访问或控制台访问。</p><p id="9689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过使用临时容器来访问节点</p><pre class="kg kh ki kj gt nk ng nl nm aw nn bi"><span id="c522" class="no mh iq ng b gy np nq l nr ns">kubectl debug node/&lt;node-name&gt; -it --image=&lt;image-name&gt;</span></pre><p id="3382" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在节点上创建调试会话时，请记住:</p><ul class=""><li id="e83c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nd ne nf ng b">kubectl debug</code>根据节点名称自动生成新Pod的名称。</li><li id="f235" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">容器在主机IPC、Network和PID命名空间中运行。</li><li id="d875" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">节点的根文件系统将安装在<code class="fe nd ne nf ng b">/host</code>。</li></ul><p id="eab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你希望临时容器的根文件系统与节点相同，你只需要<code class="fe nd ne nf ng b">chroot</code>到<code class="fe nd ne nf ng b">/host</code></p><p id="14d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/c9aeee14c02352aa063459efeed2e9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rVydSibUUi_Jw8QzpaR1Q.png"/></div></div></figure><h1 id="cee1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="ad98" class="ls lt iq ky b kz my lc mz lf oh lj oi ln oj lr lx ly lz ma bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/debug/debug-application/debug-running-pod/</a></li><li id="0c36" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.redhat.com/sysadmin/container-namespaces-nsenter" rel="noopener ugc nofollow" target="_blank">https://www . red hat . com/sysadmin/container-namespaces-n输入</a></li><li id="5bb6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://static.sched.com/hosted_files/kccnceu2022/70/Ephemeral_Containers.pdf" rel="noopener ugc nofollow" target="_blank">https://static . sched . com/hosted _ files/kccncue 2022/70/periodic _ containers . pdf</a></li></ul></div></div>    
</body>
</html>