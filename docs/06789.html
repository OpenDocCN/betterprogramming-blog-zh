<html>
<head>
<title>Becoming Root Through Overprivileged Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过过度特权化的过程成为根</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/becoming-root-through-overprivileged-processes-f26f83e18059?source=collection_archive---------9-----------------------#2020-11-04">https://betterprogramming.pub/becoming-root-through-overprivileged-processes-f26f83e18059?source=collection_archive---------9-----------------------#2020-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="538a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用过度特权进程提升Linux特权</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f10ad77ea761ddcc0cabd7297d779b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8UtT0onF0QaXUn19"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·拉德里奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="2189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎回到Linux安全系列！在本系列中，我们将讨论影响Linux系统的安全问题以及导致这些问题的常见错误配置。我们开始吧！</p><p id="5f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">权限提升是攻击者提升系统权限的一种方式。例如，假设一个攻击者已经获得了对您的web服务器的访问权，但只是作为一个低特权用户。他们不能读写敏感文件、执行脚本或更改系统配置。他们如何危害您的服务器并保持对服务器的访问？</p><p id="0695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果他们可以找到一种方法来欺骗系统，使其认为自己是根用户，攻击者就可以进行更强大的攻击，如读写敏感文件和在系统中插入永久性后门。这就是特权升级的由来。</p><p id="7866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们来讨论一下攻击者如何利用特权过高的进程来提升他们的特权。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c8fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是超特权进程？</h1><p id="a9ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">特权过高的进程是指运行时使用的权限比它需要的多。这是一个安全风险，因为如果攻击者劫持了以高特权运行的应用程序，攻击者就可以获得它在系统上的权限。今天，让我们看看攻击者在遇到以root用户身份运行的特权过高的进程时可以做些什么。</p><p id="b710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设一个web应用程序遭受了典型的命令注入攻击。该应用程序允许用户通过GET请求参数提交文件名来读取文件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="269d" class="ne md it na b gy nf ng l nh ni"><a class="ae ky" href="https://example.com/read?filename=abc.txt" rel="noopener ugc nofollow" target="_blank">https://example.com/read?filename=abc.txt</a></span></pre><p id="b701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序的PHP源代码如下所示。应用程序从用户处检索URL参数，然后将其直接连接到一个系统命令中:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a056" class="ne md it na b gy nf ng l nh ni">&lt;?php</span><span id="7d81" class="ne md it na b gy nj ng l nh ni">  $file=$_GET[‘filename’];</span><span id="890b" class="ne md it na b gy nj ng l nh ni">  system(“echo $file”);</span><span id="dfb5" class="ne md it na b gy nj ng l nh ni">?&gt;</span></pre><p id="3b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序缺乏对“系统”调用的任何输入验证，使得攻击者能够通过命令注入执行任意系统命令。例如，攻击者可以通过将系统命令注入filename参数来执行系统命令:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="71d0" class="ne md it na b gy nf ng l nh ni"><a class="ae ky" href="https://example.com/read?filename=abc.txt;ls" rel="noopener ugc nofollow" target="_blank">https://example.com/read?filename=abc.txt;ls</a></span></pre><p id="d589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将导致应用程序执行该命令，该命令将打印<code class="fe nk nl nm na b">abc.txt</code>的内容，然后列出当前目录的内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6829" class="ne md it na b gy nf ng l nh ni">echo abc.txt;ls</span></pre><p id="f211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果web应用程序拥有root权限，该怎么办呢？那么攻击者可以做得更糟，因为注入的命令也将在root权限下运行。例如，攻击者可以使用命令注入，通过编辑<code class="fe nk nl nm na b">/etc/passwd</code>文件将自己添加为根用户:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="64a1" class="ne md it na b gy nf ng l nh ni"><a class="ae ky" href="https://example.com/read?filename=abc.txt;ls" rel="noopener ugc nofollow" target="_blank">https://example.com/read?filename=abc.txt;</a>echo+“vickie::0:0:System Administrator:/root/root:/bin/bash”&gt;&gt; /etc/passwd</span></pre><p id="375d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令向<code class="fe nk nl nm na b">/etc/passwd</code>文件添加一个新的根用户:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8c03" class="ne md it na b gy nf ng l nh ni">echo “vickie::0:0:System Administrator:/root/root:/bin/bash” &gt;&gt; /etc/passwd</span></pre><p id="ab21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe nk nl nm na b">0</code>是root用户的UID，所以添加一个UID为<code class="fe nk nl nm na b">0</code>的用户将赋予该用户root权限。这个用户将拥有用户名<code class="fe nk nl nm na b">vickie</code>和一个空密码。该命令对于普通用户来说通常是不可能的，因为只有特权用户才能修改<code class="fe nk nl nm na b">/etc/password</code>文件。但是，由于web应用程序以根用户身份运行，因此命令会成功，攻击者会获得对系统的根用户访问权限。</p><p id="5993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当攻击者可以执行任意代码时，特权过高的进程不仅仅是一种危险。假设在web应用程序中的这个端点上也存在路径遍历攻击:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9315" class="ne md it na b gy nf ng l nh ni"><a class="ae ky" href="https://example.com/read?filename=abc.txt" rel="noopener ugc nofollow" target="_blank">https://example.com/read?filename=abc.txt</a></span></pre><p id="b9b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">攻击者可以通过使用文件名参数中的序列<code class="fe nk nl nm na b">../</code>来逃离当前目录，从而读取当前目录之外的文件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f0fb" class="ne md it na b gy nf ng l nh ni"><a class="ae ky" href="https://example.com/read?filename=../../../../etc/shadow" rel="noopener ugc nofollow" target="_blank">https://example.com/read?filename=../../../../etc/shadow</a></span></pre><p id="a5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">/etc/shadow</code>文件是Linux系统中的一个文件，包含系统用户的散列密码。只有特权用户才能读取。如果web应用程序有权查看<code class="fe nk nl nm na b">/etc/shadow</code>文件，攻击者就可以利用路径遍历漏洞读取该文件。然后，攻击者可以破解他们在该文件中找到的密码，以访问系统上特权用户的帐户。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8140" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">注意安全！</h1><p id="2a73" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我在本文中讨论的攻击都是由应用程序以过多的特权运行引起的。为了防止这些问题，您应该实现最小特权的原则。</p><p id="b98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一原则意味着应用程序和进程只应被授予完成其任务所需的特权。例如，当应用程序只需要文件的读权限时，就不应该授予它任何写或执行权限。您应该经常检查面向用户的应用程序(如web服务器和文件服务器)是否以root用户身份运行。你永远不应该使用“以根用户身份运行”作为权限问题的默认解决方案。相反，您可以准确地授予应用程序所需的权限。这将降低攻击期间整个系统受损的风险。</p><p id="dd81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！下一次，我们将深入探讨攻击者可以用来危害您的系统的更多特权提升技术。</p></div></div>    
</body>
</html>