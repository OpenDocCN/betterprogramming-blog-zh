<html>
<head>
<title>JavaScript: Vanilla Single Page Applications (SPA)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:普通的单页应用程序(SPA)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/js-vanilla-script-spa-1b29b43ea475?source=collection_archive---------4-----------------------#2017-11-08">https://betterprogramming.pub/js-vanilla-script-spa-1b29b43ea475?source=collection_archive---------4-----------------------#2017-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4514" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">建造一个没有任何框架、铃铛或哨子的水疗中心</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/60246a5ba71db0437547a41a6dbd638a.png" data-original-src="https://miro.medium.com/v2/format:webp/0*UzaG_alYU6vQ8MIt.jpg"/></div></figure><p id="c234" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇博客是我开始撰写的一系列文章的继续，我试图解释JavaScript如何在较低的层次上处理我们现有的多个框架和库的一些特性。</p><p id="dfbd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">之前，我们用普通的脚本创建了一个<a class="ae lj" href="https://medium.com/frontend-fun/js-vanilla-two-way-binding-5a29bc86c787" rel="noopener">双向绑定，现在我们要用普通的JavaScript实现一个SPA功能，但是，当然，在进行实际的实现之前，让我们稍微谈一谈SPA…</a></p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="9dec" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么是SPA(单页应用程序)？</h1><p id="ca35" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">SPA背后的主要思想是将内容动态加载到当前页面，而不是从服务器加载整个页面。您会有一种桌面应用程序的感觉。</p><p id="de4f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">第一次加载应用程序时，所有的HTML、JavaScript和CSS都可以从服务器中检索到，而不是像非SPA那样每次加载都一遍又一遍地获取所有内容。</p><p id="6c5b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">另一个要点是，主页或内容永远不会重新加载，但通过使用位置哈希或HTML5历史API，您仍然有不同的URL和浏览器历史。</p><p id="0658" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在示例中，我们将使用并解释位置散列，但这两者都非常容易使用和理解。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="e929" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">为什么是SPA？</h1><p id="9e0a" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">让我们提一下使用水疗的一些好处:</p><ul class=""><li id="5496" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated">性能<strong class="kp ir">。SPA减少了浏览器对服务器执行请求的必要性，这影响了我们应用程序的速度和用户体验。</strong></li><li id="79a7" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated">更好的UX。<strong class="kp ir"> </strong>由于应用的速度提高，用户迭代流畅，感觉更好。</li></ul><p id="1ccd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当然也有缺点，下面就提一些:</p><ul class=""><li id="2738" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated">第一次负载重。由于应用程序的第一次加载可能会加载一堆资源，它可能会感觉很慢。</li><li id="1429" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated">必须启用JS。这听起来可能很愚蠢，因为每个人的浏览器都启用了JavaScript，但是如果有人关闭了它，那么SPA就一文不值了。</li><li id="13d8" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated">安全。<strong class="kp ir"> </strong> SPAs不太安全，因为它使黑客能够执行跨站脚本。</li></ul><p id="5a2d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">没必要补充，反正我是要做的。如果您以错误的方式实现SPA，所有的优势都将丧失。</p><p id="ba35" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们找点乐子，看一个例子…</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="a98c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">创建一个简单的水疗中心</h1><p id="2220" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">这个想法是使用带有位置散列方法的普通脚本实现一个简单的单页应用程序。</p><h2 id="6025" class="nc ls iq bd lt nd ne dn lx nf ng dp mb kw nh ni md la nj nk mf le nl nm mh nn bi translated">文件夹结构</h2><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d089a93d8b9b294fbc9cba09ec2f7db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*1ZjsQAZ3YKgcWLG890QHog.png"/></div></figure><ul class=""><li id="7661" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated"><code class="fe np nq nr ns b">js</code>。这是JavaScript实现所在的位置。</li><li id="864c" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">views</code>。这是路线的HTML所在的位置。</li><li id="2c11" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">index.html.</code>这是我们应用程序的主HTML。它将加载脚本并设置容器来呈现路线的HTML。</li></ul><h2 id="28ad" class="nc ls iq bd lt nd ne dn lx nf ng dp mb kw nh ni md la nj nk mf le nl nm mh nn bi translated">索引HTML</h2><p id="8f55" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">正如我们之前提到的，这是我们的应用程序的主HTML，它将加载我们需要的JS，添加菜单链接，并设置容器元素来呈现路线的HTML。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6f3de991bf8a12dee695d20ff6059808.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*DU1effL-a93wz22Uwiq8wQ.png"/></div></figure><ul class=""><li id="5d41" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated">我们正在创建链接到<code class="fe np nq nr ns b">#home</code>和<code class="fe np nq nr ns b">#about</code>的两个菜单选项(因为我们将使用位置散列，所以需要散列)。</li><li id="66f1" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated">将<code class="fe np nq nr ns b">id</code>设置为<code class="fe np nq nr ns b">app</code>的<code class="fe np nq nr ns b">div</code>是我们将要呈现与活动路线相关联的HTML的地方。</li><li id="5779" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated">最后，我们加载将要使用的脚本。</li></ul><h2 id="4124" class="nc ls iq bd lt nd ne dn lx nf ng dp mb kw nh ni md la nj nk mf le nl nm mh nn bi translated">关于和主页HTML</h2><p id="2e90" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">我们并不真正关心这些文件的内容，所以一个只包含一个带有<code class="fe np nq nr ns b">Home</code>文本的<code class="fe np nq nr ns b">div</code>，另一个包含一个带有<code class="fe np nq nr ns b">About</code>文本的<code class="fe np nq nr ns b">div</code>。</p><p id="2c08" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个想法是默认加载一个(作为默认路由)，如果需要的话加载另一个。正如我们之前提到的，它们位于<code class="fe np nq nr ns b">views</code>文件夹中。</p><h2 id="516e" class="nc ls iq bd lt nd ne dn lx nf ng dp mb kw nh ni md la nj nk mf le nl nm mh nn bi translated">路线JS</h2><p id="c07d" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">这个JavaScript将为我们的<code class="fe np nq nr ns b">Route</code>提供一个构造器和一些功能。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/eb5c1a5080385f77a7a4a0fac2501871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*_nYd9GQmgkXVIPkYlPaU-A.png"/></div></figure><p id="0713" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们有三个参数:</p><ul class=""><li id="405d" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated"><code class="fe np nq nr ns b">name</code>。是我们路由的名称，我们将使用它来检查该路由是否是活动路由。</li><li id="442c" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">htmlName</code>。与路线一起加载的HTML的名称。</li><li id="4d44" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">default</code>。<code class="fe np nq nr ns b">True</code>如果路线是我们app的默认路线。</li></ul><p id="a30f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它有两个功能:</p><ul class=""><li id="4795" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated"><code class="fe np nq nr ns b">constructor</code>。这只是一个构造函数。</li><li id="581e" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">isActiveRoute</code>。每个路由提供的功能，用于检查它是否是活动路由。它接收实际的窗口位置。</li></ul><h2 id="3ba0" class="nc ls iq bd lt nd ne dn lx nf ng dp mb kw nh ni md la nj nk mf le nl nm mh nn bi translated">路由器JS</h2><p id="ea81" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">这个朋友包含了大部分的魔力。让我们看一下代码，然后我们将解释它。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/4928eba6a8b35e8871109fd0d3ab4efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*m792j9qM9_SDZ2RjYFWIww.png"/></div></figure><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/2d2800b3b9164fefa1bf4c4a6ef7bb44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*NjZIe8lfQ3H2kj1KQ_mk0Q.png"/></div></figure><p id="d959" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以，让我们开始挖掘这个JS。</p><p id="eb93" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它只接收一个参数:</p><ul class=""><li id="c94c" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated"><code class="fe np nq nr ns b">routes</code>。这是一个数组，包含我们的应用程序的路线。</li></ul><p id="fdc6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它还有另一个属性:</p><ul class=""><li id="e8e6" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated"><code class="fe np nq nr ns b">rootElem</code>。它是我们应用程序的根元素。其他HTML被渲染的地方。</li></ul><p id="1172" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，它有四个功能:</p><ul class=""><li id="f9c8" class="mo mp iq kp b kq kr kt ku kw mq la mr le ms li mt mu mv mw bi translated"><code class="fe np nq nr ns b">constructor</code>。这只是一个构造函数。在创建<code class="fe np nq nr ns b">Router</code>时只执行一次。</li><li id="3a7c" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">init</code>。<strong class="kp ir"> </strong>该函数为窗口的<code class="fe np nq nr ns b">hashchange</code>事件创建一个监听器。首先，它给那个监听器设置一个回调来执行函数<code class="fe np nq nr ns b">hasChanged</code>，最后，它第一次执行它(这将允许我们执行一个默认路由)。现在，每当位置散列发生变化时，我们刚刚创建的侦听器就会被执行。该功能在创建<code class="fe np nq nr ns b">Router</code>时只执行一次。</li><li id="a70b" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">hasChanged</code>。<strong class="kp ir"> </strong>该功能有两个主要职责，都与执行正确的<code class="fe np nq nr ns b">Route</code>负载相关。如果窗口位置改变，它将加载正确的活动<code class="fe np nq nr ns b">Route</code>并调用另一个函数来加载它的HTML，如果窗口位置为空，它将加载默认的<code class="fe np nq nr ns b">Route</code>。这个函数接收两个参数，一个是<code class="fe np nq nr ns b">Router</code>实例的范围，另一个是路由。</li><li id="d577" class="mo mp iq kp b kq mx kt my kw mz la na le nb li mt mu mv mw bi translated"><code class="fe np nq nr ns b">goToRoute</code>。<strong class="kp ir"> </strong>该函数负责获取并加载活动路线的正确HTML。它接收必须加载的HTML名称，最后执行一个请求来获取它。</li></ul><p id="1413" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这就是我们让一个简单的SPA实现工作所需的全部内容。</p><h2 id="f187" class="nc ls iq bd lt nd ne dn lx nf ng dp mb kw nh ni md la nj nk mf le nl nm mh nn bi translated">路由和路由器初始化</h2><p id="0e5b" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">最后，让我们看看如何在app.js文件中启动路由器。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d473b5b0745779ffa7f96921bfbfcf95.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*ZAqZ_dO_WafIZJImagOwIg.png"/></div></figure><p id="c6c3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个脚本正在执行一个<code class="fe np nq nr ns b">init</code>函数，该函数实例化了<code class="fe np nq nr ns b">Router</code>并提供了两个<code class="fe np nq nr ns b">Route</code>，将<code class="fe np nq nr ns b">home</code>设置为缺省值。</p><p id="b504" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">实现:<a class="ae lj" href="https://github.com/SantiagoGdaR/vanilla-spa" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="1127" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="57d1" class="pw-post-body-paragraph kn ko iq kp b kq mj jr ks kt mk ju kv kw ml ky kz la mm lc ld le mn lg lh li ij bi translated">正如我们在开始时提到的，这篇文章的目的是展示一种实现SPA路由器的方法，目的是了解一个库或框架如何处理这个特性。</p><p id="1fc8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我希望你喜欢它！</p></div></div>    
</body>
</html>