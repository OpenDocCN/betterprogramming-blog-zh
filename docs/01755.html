<html>
<head>
<title>The Publisher/Subscriber Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的发布者/订阅者模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-publisher-subscriber-pattern-in-javascript-2b31b7ea075a?source=collection_archive---------2-----------------------#2019-10-11">https://betterprogramming.pub/the-publisher-subscriber-pattern-in-javascript-2b31b7ea075a?source=collection_archive---------2-----------------------#2019-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">发布/订阅，简化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c14fbd465d81dd26928930b9327ad70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yH2hPgLBkX2CtuFwGlpdIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">照片由</em> <a class="ae kz" href="https://unsplash.com/@nordwood" rel="noopener ugc nofollow" target="_blank"> <em class="ky">诺德伍德主题</em> </a> <em class="ky">上</em><a class="ae kz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"><em class="ky">Unsplash</em></a></p></figure><p id="2fe7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我们将讨论JavaScript中的发布/订阅模式，看看它在我们的JavaScript应用程序中实现起来有多简单(但功能强大)。</p><p id="c672" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">发布者/订阅者模式是一种设计模式，它允许我们创建功能强大的动态应用程序，这些应用程序的模块可以相互通信，而不直接相互依赖。</p><p id="b0fb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种模式在JavaScript中很常见，并且在工作方式上与观察者模式非常相似——除了在观察者模式中，观察者通过其主题直接得到通知，而在发布者/订阅者方法中，订阅者通过发布者和订阅者之间的通道得到通知，该通道来回传递消息。</p><p id="44e4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我们实现这个时，我们将需要一个发布者、订阅者和一些存储从订阅者注册的回调的地方。</p><p id="79e3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们来看看这在代码中是什么样子的。我们将使用一个<a class="ae kz" href="https://www.sitepoint.com/factory-functions-javascript/" rel="noopener ugc nofollow" target="_blank">工厂</a>函数(您不必使用这种模式)来创建发布者/订阅者实现。</p><p id="8a88" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们要做的第一件事是在函数内部声明一个局部变量来存储订阅的回调:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f56e" class="mb mc it lx b gy md me l mf mg">function pubSub() {<br/>  const subscribers = {}<br/>}</span></pre><p id="1d7a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，我们将定义负责向<code class="fe mh mi mj lx b">subscribers</code>插入回调的<code class="fe mh mi mj lx b">subscribe</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e7d1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里发生的事情是，在尝试为事件名注册回调监听器之前，它检查在<code class="fe mh mi mj lx b">subscribers</code>存储中的<code class="fe mh mi mj lx b">eventName</code>属性是否已经是一个<code class="fe mh mi mj lx b">array</code>。如果不是，它假设这将是第一个注册的对<code class="fe mh mi mj lx b">subscribers[eventName]</code>的回调，并将其初始化为一个数组。然后，它继续将回调推入数组。</p><p id="da0a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当<code class="fe mh mi mj lx b">publish</code>事件触发时，它将接受两个参数:</p><ol class=""><li id="aab8" class="mm mn it lc b ld le lg lh lj mo ln mp lr mq lv mr ms mt mu bi translated"><code class="fe mh mi mj lx b">eventName</code></li><li id="6ad7" class="mm mn it lc b ld mv lg mw lj mx ln my lr mz lv mr ms mt mu bi translated">任何将被传递给在<code class="fe mh mi mj lx b">subscribers[eventName]</code>中注册的每个回调的<code class="fe mh mi mj lx b">data</code></li></ol><p id="dc27" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们来看看这在代码中是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c370" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在对<code class="fe mh mi mj lx b">subscribers</code>中的回调列表进行迭代之前，它将检查它是否确实作为数组存在于对象中。如果没有，它会认为<code class="fe mh mi mj lx b">eventName</code>以前从未注册过，所以它会简单地返回。这是防止潜在崩溃的安全措施。</p><p id="328b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">之后，如果程序到达了<code class="fe mh mi mj lx b">.forEach</code>行，那么我们知道<code class="fe mh mi mj lx b">eventName</code>在过去注册了一个或多个回调。程序将安全地循环通过<code class="fe mh mi mj lx b">subscribers[eventName]</code>。</p><p id="c6d6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于它遇到的每个回调，它调用带有作为第二个参数传入的<code class="fe mh mi mj lx b">data</code>的回调。</p><p id="08f6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们订阅了这样一个函数，就会发生这样的情况:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="422e" class="mb mc it lx b gy md me l mf mg">function showMeTheMoney(money) {<br/>  console.log(money)<br/>}</span><span id="9951" class="mb mc it lx b gy na me l mf mg">const ps = pubSub()</span><span id="a412" class="mb mc it lx b gy na me l mf mg">ps.subscribe('show-money', showMeTheMoney)</span></pre><p id="777e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们在将来的某个时候调用<code class="fe mh mi mj lx b">publish</code>方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="87b0" class="mb mc it lx b gy md me l mf mg">ps.publish('show-money', 1000000)</span></pre><p id="dcb1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，除了接收作为<code class="fe mh mi mj lx b">money</code>参数的<code class="fe mh mi mj lx b">1000000</code>之外，我们注册的<code class="fe mh mi mj lx b">showMeTheMoney</code>回调将被调用:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8f54" class="mb mc it lx b gy md me l mf mg">function showMeTheMoney(money) {<br/>  console.log(money) <em class="nb">// result: 10000000</em><br/>}</span></pre><p id="fa7a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是发布者/订阅者模式的工作方式。我们定义了一个<code class="fe mh mi mj lx b">pubSub</code>函数，并为存储回调的函数提供了一个本地位置，一个<code class="fe mh mi mj lx b">subscribe</code>方法用于注册回调，一个<code class="fe mh mi mj lx b">publish</code>方法用于迭代和调用所有带有任何数据的已注册回调。</p><p id="e034" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不过，还有一个问题。在实际的应用程序中，如果我们订阅了许多回调，我们可能会遭受永无止境的内存泄漏，如果我们对此不做任何事情，这将是非常浪费的。</p><p id="9c9b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，我们最后需要的是一种方法，当订阅的回调不再必要时，可以将其删除。在这种情况下经常发生的是某个<code class="fe mh mi mj lx b">unsubscribe</code>方法被放置在某个地方。实现这一点最方便的地方是来自<code class="fe mh mi mj lx b">subscribe </code>的返回值，因为在我看来，当我们在代码中看到这一点时，这是最直观的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9aad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个例子中，我们需要一个索引。因此，我们确保删除了正确的条目，因为我们使用了<code class="fe mh mi mj lx b">.splice</code>，它需要一个准确的索引来删除我们正在寻找的条目。</p><p id="2ce4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你也可以这样做；然而，它的性能较差:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="4ed2" class="nj mc it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">不足之处</h1><p id="7b14" class="pw-post-body-paragraph la lb it lc b ld oa ju lf lg ob jx li lj oc ll lm ln od lp lq lr oe lt lu lv im bi translated">尽管这种模式有巨大的好处，但也有毁灭性的缺点，可能会花费我们大量的调试时间。</p><p id="3990" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们如何知道我们之前是否订阅了相同的回调？除非我们实现一个映射列表的实用程序，否则真的没有办法知道，但是那样我们会让JavaScript做更多的任务。</p><p id="6062" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在现实世界中，我们越是滥用这种模式，维护我们的代码就越困难。事实上，回调在这种模式中是分离的，当回调到处做这做那时，很难跟踪每一步。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="698f" class="nj mc it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">结论</h1><p id="100b" class="pw-post-body-paragraph la lb it lc b ld oa ju lf lg ob jx li lj oc ll lm ln od lp lq lr oe lt lu lv im bi translated">这篇文章到此结束。我希望你发现这是有价值的，并期待在未来更多！</p></div></div>    
</body>
</html>