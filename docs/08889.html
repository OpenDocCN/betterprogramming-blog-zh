<html>
<head>
<title>All the Reserved Keywords in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中所有保留的关键字</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/all-the-reserved-keywords-in-swift-17efcfaa3f3e?source=collection_archive---------4-----------------------#2021-06-23">https://betterprogramming.pub/all-the-reserved-keywords-in-swift-17efcfaa3f3e?source=collection_archive---------4-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3706" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个包含所有保留关键字的快速备忘单，有一堆有用的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1061593765edb115b6966c599783715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOErUs2zytrgrDD79V5Rkw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="bec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是Swift中所有可能保留的关键字的完整列表。每个关键字都包括一个简单的用法示例。</p><p id="8323" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据<a class="ae lu" href="https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#:~:text=the%20following%20keywords%20are%20reserved%20and%20can%E2%80%99t%20be%20used%20as%20identifiers" rel="noopener ugc nofollow" target="_blank"> Swift的官方文件</a>，有六组关键词:</p><ul class=""><li id="7561" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">声明中使用的关键字</li><li id="8a9a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">语句中使用的关键字</li><li id="cf10" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">表达式和类型中使用的关键字</li><li id="3701" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">模式中使用的关键字</li><li id="7203" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">以数字符号(<code class="fe mj mk ml mm b">#</code>)开头的关键词</li><li id="10be" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">特定上下文中保留的关键字</li></ul><p id="02cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们仔细检查每组中的所有关键词。我希望你喜欢它！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="01c3" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">声明中使用的关键字</h1><h2 id="58fc" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">关联类型</h2><p id="111f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">关联类型可用于使协议通用化。使用<code class="fe mj mk ml mm b">associatedtype</code>关键字指定关联类型。</p><p id="9e16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最好用一个例子来说明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6fa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，<code class="fe mj mk ml mm b">associatedType</code>就是<code class="fe mj mk ml mm b">WhateverObject</code>。它是一个任意的对象，当您创建一个符合该协议的类型时，它会变成它后来变成的任何东西。</p><p id="759e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第14–16行，您创建了一个符合<code class="fe mj mk ml mm b">Store</code>协议的新结构<code class="fe mj mk ml mm b">Shop</code>，您指定在这种情况下的<code class="fe mj mk ml mm b">WhateverObject</code>是一个<code class="fe mj mk ml mm b">String</code>。</p><h2 id="884f" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">班级</h2><p id="1c73" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在Swift中，<code class="fe mj mk ml mm b">class</code>是创建对象的蓝图。类别允许:</p><ul class=""><li id="2d80" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">遗产</li><li id="601e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">铅字铸造</li><li id="f579" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">去初始化</li><li id="2248" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">引用计数</li></ul><p id="8b99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建一个类，使用<code class="fe mj mk ml mm b">class</code>关键字。</p><p id="97db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1b2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="0d75" class="nm mv it mm b gy oj ok l ol om">banana</span></pre><h2 id="399d" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">德尼特</h2><p id="f61f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">取消初始化是一个类专用的属性，它允许释放一个<code class="fe mj mk ml mm b">class</code>实例正在使用的资源。这是一个内存管理特性。</p><p id="ef4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Denitializer是通过<code class="fe mj mk ml mm b">deinit</code>关键字调用的。</p><p id="ee99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了演示反初始化，让我们用初始化器和反初始化器创建一个简单的示例类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0303" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b714" class="nm mv it mm b gy oj ok l ol om">The number is now: 150<br/>After the deinitialization, the number is now: 0</span></pre><p id="2d4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，在大多数情况下，Swift会为您负责内存管理，因此您很少需要自己使用反初始化器。</p><h2 id="bd0d" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">列举型别</h2><p id="d2fe" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过Swift中的<code class="fe mj mk ml mm b">enum</code>关键字创建枚举。这是一种使用一组相关值的类型安全方式。</p><p id="8071" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="0b52" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">enum</strong> Direction {<br/>    <strong class="mm iu">case</strong> north<br/>    <strong class="mm iu">case</strong> east<br/>    <strong class="mm iu">case</strong> south<br/>    <strong class="mm iu">case</strong> west<br/>}</span></pre><p id="c208" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你的程序中有了一个方向约定。不使用字符串，比如<code class="fe mj mk ml mm b">“north”</code>，可以使用枚举<code class="fe mj mk ml mm b">Direction.north</code>。</p><h2 id="0dc4" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">延长</h2><p id="2f16" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过编写扩展来扩展类、结构或枚举的行为。您可以使用<code class="fe mj mk ml mm b">extension</code>关键字创建一个扩展名。</p><p id="2508" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="8247" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="68e0" class="nm mv it mm b gy oj ok l ol om">This fruit is banana</span></pre><h2 id="2f6c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">文件私有</h2><p id="263a" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">要声明一个将实体的范围限制在源文件的访问控制级别，可以使用关键字<code class="fe mj mk ml mm b">fileprivate</code>。</p><p id="a972" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="3fb9" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">class</strong> Fruit {<br/>    <strong class="mm iu">fileprivate</strong> <strong class="mm iu">var</strong> name = "banana"<br/>}</span><span id="9491" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">let</strong> fruit = Fruit()<br/>fruit.name = "Apple" // <strong class="mm iu">Works only in this source file</strong></span></pre><h2 id="f233" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">功能</h2><p id="d517" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">功能是用于执行特定任务的一组给定的指令。函数调用接受在执行任务时可以使用的参数。</p><p id="5d53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以使用<code class="fe mj mk ml mm b">func</code>关键字创建一个函数。</p><p id="d83a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个问候某人的函数:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="1ae1" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">func</strong> greet(_ someone: String){<br/>    print("Hi, \(someone).")<br/>}</span><span id="99fd" class="nm mv it mm b gy on ok l ol om">greet("Bob")</span></pre><p id="ed94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="491c" class="nm mv it mm b gy oj ok l ol om">Hi, bob.</span></pre><h2 id="7ed5" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">进口</h2><p id="7f29" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">用<code class="fe mj mk ml mm b">import</code>语句将应用程序或框架作为一个单元暴露给你的程序。</p><p id="5a2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果您希望能够利用苹果的<code class="fe mj mk ml mm b">UIKit</code>提供的所有功能，请通过以下方式导入:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="0659" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">import</strong> UIKit</span></pre><h2 id="6005" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">初始化</h2><p id="0e36" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过调用类型定义中的<code class="fe mj mk ml mm b"><strong class="la iu">init()</strong></code>方法，准备一个类、结构或枚举的实例以供使用。</p><p id="7d43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="1ff4" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">inout</h2><p id="7e41" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">如果你想直接改变一个传入函数的值，使用一个<code class="fe mj mk ml mm b">inout</code>参数。</p><p id="eedc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要声明一个<code class="fe mj mk ml mm b">inout</code>参数，在类型前面添加关键字<code class="fe mj mk ml mm b">inout</code>。</p><p id="7e25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a18d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="331d" class="nm mv it mm b gy oj ok l ol om">10000</span></pre><h2 id="06a2" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">内部的</h2><p id="c390" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">internal</code> <strong class="la iu"> </strong>声明一个内部访问级别，允许从定义实体的模块中访问任何源文件内的实体，但不能访问源文件外的实体。</p><p id="4899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以像这样使用<code class="fe mj mk ml mm b">internal</code>关键字:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="7d9e" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">class</strong> Fruit {<br/>    <strong class="mm iu">internal</strong> <strong class="mm iu">var</strong> name = "banana"<br/>}</span><span id="ccab" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">let</strong> fruit = Fruit()<br/>fruit.name = "Apple" // Valid anywhere in the modules source</span></pre><h2 id="a030" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">让</h2><p id="eb72" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用关键字<code class="fe mj mk ml mm b">let</code> <strong class="la iu">在Swift中定义一个不可变变量。</strong></p><p id="b222" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，创建一个以后不能更改的数字100:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="c1db" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> n = 100</span></pre><h2 id="9404" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">打开</h2><p id="96fa" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过使用开放访问控制修饰符来访问和子类化模块外部的对象。关键字<code class="fe mj mk ml mm b">open</code>会发生这种情况。</p><p id="f072" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="311c" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">open</strong> <strong class="mm iu">var</strong> number = 100</span></pre><p id="cc7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法在编写框架时很有用。</p><h2 id="8fb0" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">操作员</h2><p id="c16c" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">一种特殊的符号/短语，可用于组合、改变和检查值。Swift中有很多运算符，例如<code class="fe mj mk ml mm b">+</code>、<code class="fe mj mk ml mm b">&amp;&amp;</code>或<code class="fe mj mk ml mm b">*</code>。</p><p id="5dd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用<code class="fe mj mk ml mm b">operator</code>关键字创建一个自定义操作符。</p><p id="f861" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个自定义运算符，用表情符号将两个数字相加:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="ff0e" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">infix</strong> <strong class="mm iu">operator</strong> ➕</span><span id="7e08" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">func</strong> ➕(lhs: Int, rhs: Int) -&gt; Int {<br/>    <strong class="mm iu">return</strong> lhs + rhs<br/>}</span><span id="b367" class="nm mv it mm b gy on ok l ol om">print(3➕6)</span></pre><p id="ed66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="d87c" class="nm mv it mm b gy oj ok l ol om">9</span></pre><h2 id="4c6e" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">私人的</h2><p id="624f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">例如，创建一个访问控制级别，将使用限制在类的声明中。可以使用关键字<code class="fe mj mk ml mm b">private</code> <strong class="la iu">创建私有实体。</strong></p><p id="539e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3904" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="3a30" class="nm mv it mm b gy oj ok l ol om">banana</span></pre><p id="a500" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是如果您尝试运行以下代码，代码将会崩溃，因为属性<code class="fe mj mk ml mm b">name</code>是<code class="fe mj mk ml mm b">Fruit</code>类的私有属性:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="7c43" class="nm mv it mm b gy oj ok l ol om">print(fruit1.name)</span></pre><h2 id="530d" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">草案</h2><p id="1554" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">协议是编写代码的蓝图。如果一个类型符合一个协议，它必须包含并实现协议中声明的变量和方法。</p><p id="6021" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要声明一个协议，使用关键字<code class="fe mj mk ml mm b">protocol</code>。</p><p id="226a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="db24" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">protocol</strong> Animal {<br/>    <strong class="mm iu">var</strong> name: String { <strong class="mm iu">get</strong> <strong class="mm iu">set</strong> }<br/>    <strong class="mm iu">var</strong> color: String { <strong class="mm iu">get</strong> <strong class="mm iu">set</strong> }<br/>    <strong class="mm iu">func</strong> makeSound()<br/>}</span></pre><p id="6de6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在<code class="fe mj mk ml mm b">Animal</code>协议可以在为一只猫创建类时使用:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="4d27" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">class</strong> Cat: Animal {<br/>    <strong class="mm iu">var</strong> name = "Luna"<br/>    <strong class="mm iu">var</strong> color = "gray"<br/>    <strong class="mm iu">func</strong> makeSound() {<br/>        print("Meow!")<br/>    }<br/>}</span></pre><h2 id="ed99" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">公众的</h2><p id="67b8" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用关键字<code class="fe mj mk ml mm b">public</code>访问任何模块中任何源文件中的实体。</p><p id="dfa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="9e40" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">public</strong> <strong class="mm iu">var</strong> number = 10</span></pre><h2 id="e936" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">重新抛出</h2><p id="2328" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">当函数本身不抛出错误，但函数参数闭包抛出错误时，标记函数<code class="fe mj mk ml mm b">rethrows</code>。</p><p id="90d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这允许编译器只有在闭包实际抛出错误时才要求使用<code class="fe mj mk ml mm b">try</code>错误处理关键字。</p><p id="c10f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ca1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="6128" class="nm mv it mm b gy oj ok l ol om">Yay<br/>this is a test</span></pre><h2 id="8d4c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">静电</h2><p id="07ec" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">要创建只属于一个类型的属性和方法，需要使用关键字<code class="fe mj mk ml mm b">static</code> <strong class="la iu">使它们成为静态的。</strong></p><p id="dd34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，为了能够调用<code class="fe mj mk ml mm b">Person.greet()</code>而不单独创建<code class="fe mj mk ml mm b">Person</code>的实例，您需要将<code class="fe mj mk ml mm b">greet</code>设为静态:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="76db" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">class</strong> Person {<br/>    <strong class="mm iu">static</strong> <strong class="mm iu">func</strong> greet(){ print("Yo!") }<br/>}</span><span id="d97c" class="nm mv it mm b gy on ok l ol om">Person.greet() // Success!</span></pre><h2 id="88ac" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">结构体</h2><p id="fc39" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">结构是代码非常基本的构造块之一。它是一个灵活的代码结构，允许初始化。要创建一个结构，使用关键字<code class="fe mj mk ml mm b">struct</code>。</p><p id="0661" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，通过以下方式创建一个<code class="fe mj mk ml mm b">Fruit</code>结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c91e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="a7eb" class="nm mv it mm b gy oj ok l ol om">banana</span></pre><h2 id="ddd0" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">下标</h2><p id="1fe6" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">下标是访问集合成员元素的快捷方式。若要使用下标来查询类型的实例，请使用方括号。</p><p id="fc50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="8f7c" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> numbers = [1, 2, 3, 4, 5]</span><span id="1053" class="nm mv it mm b gy on ok l ol om">print(numbers[2])</span></pre><p id="2e46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="6d9c" class="nm mv it mm b gy oj ok l ol om">3</span></pre><p id="db39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以为您的自定义类型创建一个下标，如类。为此，使用<code class="fe mj mk ml mm b">subscript</code>关键字来定义<code class="fe mj mk ml mm b">subscript()</code>方法。</p><p id="3c04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们像调用数组一样调用带有下标的<code class="fe mj mk ml mm b">banana</code>实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0298" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="c66e" class="nm mv it mm b gy oj ok l ol om">I'm a banana!</span></pre><p id="075b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个特殊的例子并不有用，但是演示了自定义<code class="fe mj mk ml mm b">subscript</code>是如何工作的。</p><h2 id="ea06" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">typealias</h2><p id="34ca" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><a class="ae lu" href="https://www.codingem.com/2021/05/03/typealias-in-swift/" rel="noopener ugc nofollow" target="_blank">类型别名</a>是现有数据类型的别名。要创建一个，使用<code class="fe mj mk ml mm b">typealias</code> <strong class="la iu"> </strong>关键字。</p><p id="3c41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们为整数创建一个类型别名，并将其命名为<code class="fe mj mk ml mm b">WholeNum</code>:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b6de" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">typealias</strong> WholeNum = Int</span></pre><p id="5fae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以使用这个整数别名，例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="bc42" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> wholeNum: WholeNum = 3<br/>print(wholeNum) // prints 3</span></pre><h2 id="aae5" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">定义变量</h2><p id="21c6" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">要声明一个可变变量，使用<code class="fe mj mk ml mm b">var</code>关键字。例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="7667" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">var</strong> num = 10</span><span id="7124" class="nm mv it mm b gy on ok l ol om">num = 20</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fa7e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">语句中使用的关键字</h1><h2 id="202a" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">破裂</h2><p id="fa1c" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">break</code>结束循环、<code class="fe mj mk ml mm b">if</code>语句或<code class="fe mj mk ml mm b">switch</code>语句的执行。</p><p id="a7c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="f34a" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">for</strong> i <strong class="mm iu">in</strong> 0 ... 100 {<br/>    print("Value is \(i)")<br/>    <strong class="mm iu">if</strong> i == 2 {<br/>        <strong class="mm iu">break</strong><br/>    }<br/>}</span></pre><p id="95a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="79d4" class="nm mv it mm b gy oj ok l ol om">Value is 0<br/>Value is 1<br/>Value is 2</span></pre><h2 id="1afa" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">情况</h2><p id="5910" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">case</code>语句匹配模式。</p><p id="4963" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b1e4" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> num = 1</span><span id="8b9c" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">switch</strong> num {<br/>    <strong class="mm iu">case</strong> 0: print("Number 0")<br/>    <strong class="mm iu">case</strong> 1: print("Number 1")<br/>    <br/>    <strong class="mm iu">default</strong>: print("Not accepted")<br/>}</span></pre><h2 id="99a1" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">继续</h2><p id="760e" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">continue</code>跳过当前循环迭代中的剩余语句或<code class="fe mj mk ml mm b">switch</code>语句。例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="35cc" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">for</strong> i in 0 ... 4 {<br/>    <strong class="mm iu">if</strong> i % 2 == 0 {<br/>        <strong class="mm iu">continue</strong><br/>    }<br/>    print("The execution does not make it here with even numbers")<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/09e22d62f94267869512e2470fb737f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uwzX_dgiFcmLF5BsBg5Tw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe mj mk ml mm b">Continue</code>语句跳转到下一次迭代的开始</p></figure><h2 id="3811" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">系统默认值</h2><p id="d497" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在switch case语句中使用<code class="fe mj mk ml mm b">default</code>作为默认情况。</p><p id="9c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="428a" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> num = 10</span><span id="3990" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">switch</strong> num {<br/>    <strong class="mm iu">case</strong> 0: print("Number 0")<br/>    <strong class="mm iu">case</strong> 1: print("Number 1")<br/>    <br/>    <strong class="mm iu">default</strong>: print("Not accepted")<br/>}</span></pre><p id="e170" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="24a9" class="nm mv it mm b gy oj ok l ol om">Not accepted</span></pre><h2 id="81ab" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">推迟</h2><p id="1121" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">defer</code>在退出作用域之前运行代码。在函数中，这些是函数调用完成和函数作用域被破坏之前的“最后的话”。</p><p id="a270" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="914f" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">func</strong> printStuff() {<br/>    <strong class="mm iu">defer</strong> { <br/>        print("I printed numbers and now I go")<br/>    }<br/>    print("4")<br/>}</span><span id="a12c" class="nm mv it mm b gy on ok l ol om">printStuff()</span></pre><p id="530f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="3099" class="nm mv it mm b gy oj ok l ol om">4<br/>I printed numbers and now I go</span></pre><p id="5778" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">延迟通常在打开和关闭范围内的上下文时使用，例如在访问文件时。</p><h2 id="a37d" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">做</h2><p id="85b4" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">当处理错误时，您可以尝试在<code class="fe mj mk ml mm b">do</code>块中运行产生错误的代码。错误处理的一般结构是:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="89c0" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">do</strong> {<br/>    <strong class="mm iu">try</strong> throwing_expression<br/>} <strong class="mm iu">catch</strong> error_type {<br/>    handle_error   <br/>}</span></pre><p id="2027" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(在本文中可以找到更有用的错误处理示例<a class="ae lu" href="https://medium.com/codex/swift-error-handling-made-simple-83662e098a8c#27b0" rel="noopener">。)</a></p><h2 id="c0eb" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">其他</h2><p id="591c" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">将<code class="fe mj mk ml mm b">else</code>语句与<code class="fe mj mk ml mm b">if</code>语句结合使用。如果不满足<code class="fe mj mk ml mm b">if</code>(或<code class="fe mj mk ml mm b">else-if</code>)中的条件，则执行<code class="fe mj mk ml mm b">else</code>程序块。</p><p id="e0f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b481" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> num = 1</span><span id="e4c5" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">if</strong> num &gt; 1 {<br/>    print("Num &gt; 1")<br/>} <strong class="mm iu">else</strong> {<br/>    print("Num &lt;= 1")<br/>}</span></pre><h2 id="14d1" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">失败</h2><p id="2e32" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在Swift中，当发现匹配时，switch case语句停止执行。但是，您可以通过使用<code class="fe mj mk ml mm b">fallthrough</code>禁用此行为。</p><p id="85cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="845f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b104" class="nm mv it mm b gy oj ok l ol om">The number is 1<br/>The execution fell through here...</span></pre><p id="bd99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mj mk ml mm b">fallthrough</code>使代码执行贯穿整个案例，即使它通常会在那里停止。</p><h2 id="caf8" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">为</h2><p id="4a8f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">for</code>循环迭代一个序列，例如一系列数字。您可以使用<code class="fe mj mk ml mm b">for</code>关键字实例化一个<code class="fe mj mk ml mm b">for</code>循环。</p><p id="fef1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们使用一个<code class="fe mj mk ml mm b">for</code>循环打印从1到10的数字:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="6ae0" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">for</strong> i <strong class="mm iu">in</strong> 1 ... 10 {<br/>    print(i)<br/>}</span></pre><h2 id="0c97" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">防护装置</h2><p id="09c9" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">根据一定的条件，使用<code class="fe mj mk ml mm b">guard</code>将程序控制转移到范围之外。</p><p id="2c88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="8e9a" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">func</strong> demonstrate() {<br/>    <strong class="mm iu">guard</strong> 1 &lt; 2 <strong class="mm iu">else</strong> {<br/>        print("Condition was not met")<br/>        <strong class="mm iu">return</strong><br/>    }<br/>    print("Condition was met")<br/>}</span><span id="f801" class="nm mv it mm b gy on ok l ol om">demonstrate()</span></pre><p id="6c1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="fa5d" class="nm mv it mm b gy oj ok l ol om">Condition was met</span></pre><p id="e463" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://www.codingem.com/2021/05/13/the-guard-keyword-in-swift/" rel="noopener ugc nofollow" target="_blank">了解更多</a>关于<code class="fe mj mk ml mm b">guard</code>。</p><h2 id="eac3" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">如果</h2><p id="576a" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">检查是否满足条件，并使用<code class="fe mj mk ml mm b">if</code>语句运行代码。可以使用<code class="fe mj mk ml mm b">if</code>关键字创建一个<code class="fe mj mk ml mm b">if</code>语句。</p><p id="9b78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="7d67" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">if</strong> 1 &lt; 100 {<br/>    print("This is true.")<br/>}</span></pre><p id="a76f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="e69d" class="nm mv it mm b gy oj ok l ol om">This is true</span></pre><h2 id="59f6" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">在</h2><p id="d76c" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过组合<code class="fe mj mk ml mm b">for</code>和<code class="fe mj mk ml mm b">in</code>语句来循环一个序列:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="1166" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">for</strong> i <strong class="mm iu">in</strong> 1 ... 3 { print ("The number is \(i)") }</span></pre><p id="1920" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="c1cc" class="nm mv it mm b gy oj ok l ol om">The number is 1<br/>The number is 2<br/>The number is 3</span></pre><h2 id="0777" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">重复</h2><p id="3b47" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">repeat</code>在考虑条件之前总是执行一次代码块。</p><p id="adc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在<code class="fe mj mk ml mm b">false</code>条件下，重复块执行一次:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="e2a2" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">repeat </strong>{<br/>    print("Condition is false")<br/>}<br/><strong class="mm iu">while</strong> 1 &gt; 2</span></pre><p id="db7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="57ae" class="nm mv it mm b gy oj ok l ol om">Condition is false</span></pre><h2 id="c537" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">返回</h2><p id="fc86" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">从上下文中返回值，并使用<code class="fe mj mk ml mm b">return</code>语句退出该上下文中的控制流。</p><p id="fa51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="9efb" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">func</strong> giveOne() -&gt; Int {<br/>    <strong class="mm iu">return</strong> 1<br/>    print("This print statement is never run")<br/>}</span><span id="80bf" class="nm mv it mm b gy on ok l ol om">giveOne()</span></pre><h2 id="78e9" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">转换</h2><p id="b96a" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">尝试使用switch case语句将值与模式匹配。</p><p id="c37b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="2724" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> num = 1</span><span id="9cc4" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">switch</strong> num {<br/>    <strong class="mm iu">case</strong> 0: print("Number 0")<br/>    <strong class="mm iu">case</strong> 1: print("Number 1")<br/>    <br/>    <strong class="mm iu">default</strong>: print("Not accepted")<br/>}</span></pre><p id="2898" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="49d0" class="nm mv it mm b gy oj ok l ol om">Number 1</span></pre><h2 id="25e9" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">在哪里</h2><p id="7b17" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">where</code>语句有很多用例。其中之一是当您想要在模式中提供一个附加条件时。</p><p id="2bc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="472a" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">for</strong> i <strong class="mm iu">in</strong> 0 ... 6 <strong class="mm iu">where</strong> i % 2 == 0 {<br/>    print(i)<br/>}</span></pre><p id="858d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="6aa8" class="nm mv it mm b gy oj ok l ol om">0<br/>2<br/>4<br/>6</span></pre><p id="a377" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mj mk ml mm b">Where</code>也可用于要求关联类型符合特定协议。</p><p id="5bba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b07e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上意味着既是<code class="fe mj mk ml mm b">Callable</code>又是<code class="fe mj mk ml mm b">Equatable</code>的实体可以调用<code class="fe mj mk ml mm b">handleName()</code>函数。</p><h2 id="7136" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">在…期间</h2><p id="ead9" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">while</code>循环执行一组语句，直到不满足条件。你可以用关键字<code class="fe mj mk ml mm b">while</code>实例化一个<code class="fe mj mk ml mm b">while</code>循环。</p><p id="3091" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，打印从0到3的数字:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="041e" class="nm mv it mm b gy oj ok l ol om">var i = 0<br/><strong class="mm iu">while</strong> i &lt;= 3{<br/>    print("\(i)")<br/>    i += 1<br/>}</span></pre><p id="b42b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="d499" class="nm mv it mm b gy oj ok l ol om">0<br/>1<br/>2<br/>3</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0a8a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">表达式和类型中使用的关键字</h1><h2 id="beef" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">任何的</h2><p id="54a5" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">您可以使用<code class="fe mj mk ml mm b">Any</code>来表示任何类型的实例。例如，让我们创建一个可以包含不同类型项目的数组:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="08e2" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">var</strong> anyItems: [Any] = []</span><span id="476d" class="nm mv it mm b gy on ok l ol om">anyItems.append("A String") // You can append anything to this array<br/>anyItems.append(1500.0)<br/>anyItems.append(false)</span><span id="bd98" class="nm mv it mm b gy on ok l ol om">print(anyItems)</span></pre><h2 id="30c6" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">如同</h2><p id="9771" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">当编译器保证一个值可以转换成另一种类型时，您可以使用<code class="fe mj mk ml mm b">as</code>将其转换。</p><p id="2f56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="abce" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> doubleNumber = 1.502 <strong class="mm iu">as</strong> Double</span></pre><p id="97bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe mj mk ml mm b">as</code>运算符的左右两边不能相互转换，编译器会显示一个错误。在这种情况下，如果要强制施法，可以用<code class="fe mj mk ml mm b">as?</code>或<code class="fe mj mk ml mm b">as!</code>代替<code class="fe mj mk ml mm b">as</code>。切记小心处理可能的<code class="fe mj mk ml mm b">nil</code>值。</p><h2 id="5e9e" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">捕捉</h2><p id="1efa" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">如果一个错误抛出函数抛出了一个错误，那么<code class="fe mj mk ml mm b">catch</code> <strong class="la iu"> </strong>块会捕捉这个错误(在do-try-catch结构中)。</p><p id="f628" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="18d6" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">do</strong> {<br/>    <strong class="mm iu">try</strong> parseName("thisisatoolongnamefortheparser")<br/>} <strong class="mm iu">catch</strong> NameError.tooLong {<br/>    print("The name you entered is too long.")<br/>}</span></pre><p id="e89a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，一个过长的字符串被传递给了<code class="fe mj mk ml mm b">parseName</code>方法，这将抛出一个错误。catch块捕获错误，并通过打印错误消息来处理它。</p><p id="1caf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">参见本文中的完整示例<a class="ae lu" href="https://medium.com/codex/swift-error-handling-made-simple-83662e098a8c#27b0" rel="noopener">。</a></p><h2 id="b8b5" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">错误的</h2><p id="da2e" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在Swift中，<code class="fe mj mk ml mm b">false</code>是两个布尔之一。它代表不真实。</p><p id="1d74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b457" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">if</strong> false { print("This code is never run") }</span></pre><h2 id="63cb" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">是</h2><p id="e1ca" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">is</code>关键字检查一个对象是否是一个类的实例</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="e4e5" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">无</h2><p id="48d6" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">nil</code>是Swift中的无状态未定义值。Swift中任何类型都可以是<code class="fe mj mk ml mm b">nil</code>。</p><p id="27e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="4e22" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> studentID: String? = <strong class="mm iu">nil</strong><br/><strong class="mm iu">let</strong> age: Double? = <strong class="mm iu">nil</strong><br/><strong class="mm iu">let</strong> grades: [Int]? = <strong class="mm iu">nil</strong></span></pre><h2 id="dec1" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">极好的</h2><p id="b5b8" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过<code class="fe mj mk ml mm b">super</code>关键字访问父类的方法和属性。</p><p id="a42f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a931" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="84ae" class="nm mv it mm b gy oj ok l ol om">Hi, I'm Charlie<br/>I'm starting at this company today.</span></pre><h2 id="d174" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">自己</h2><p id="59e0" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">self</code>关键词有两个:<code class="fe mj mk ml mm b">self</code>和<code class="fe mj mk ml mm b">Self</code> <strong class="la iu">。</strong>前者与类型(比如类)有关，后者与协议有关。</p><p id="fdf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mj mk ml mm b">self</code>是一个类型的每个实例都具有的隐式属性。属性总是等同于实例本身。</p><p id="2867" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="5fdb" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">class</strong> Person {<br/>    <strong class="mm iu">func</strong> printMe() {<br/>        print("I am a \(self)")<br/>    }<br/>}<br/><strong class="mm iu">let</strong> person = Person()<br/>person.printMe()</span></pre><p id="38f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="c73c" class="nm mv it mm b gy oj ok l ol om">I am a Person</span></pre><p id="7e11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在协议中，<code class="fe mj mk ml mm b">Self</code>表示将要符合协议的类型。</p><p id="407f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a644" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="2def" class="nm mv it mm b gy oj ok l ol om">Hi, I am  Person()</span></pre><h2 id="4a95" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">扔</h2><p id="52d6" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">throw</code>关键字抛出一个错误。</p><p id="1b99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，函数<code class="fe mj mk ml mm b">inputInteger</code>是一个可抛出的函数，它总是抛出一个错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="108a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="9a31" class="nm mv it mm b gy oj ok l ol om">An error was caught.</span></pre><h2 id="8f0c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">投</h2><p id="7b5a" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">throws</code>指示函数可能抛出错误。</p><p id="f125" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="51df" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">enum</strong> BadError: Error {<br/>    <strong class="mm iu">case</strong> notAString<br/>}</span><span id="a315" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">func</strong> inputInteger() <strong class="mm iu">throws</strong> { <br/>    <strong class="mm iu">throw</strong> BadError.notAString <br/>}</span></pre><h2 id="117e" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">真实的</h2><p id="8702" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在Swift中，<code class="fe mj mk ml mm b">true</code>是两个布尔之一。它代表真实。</p><p id="a9d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="bf9b" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">if</strong> true { print("This is always executed") }</span></pre><h2 id="5a1d" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">尝试</h2><p id="f695" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">尝试使用<code class="fe mj mk ml mm b">try</code>关键字运行一个可能抛出错误的函数。这是Swift中错误处理的一部分。使用<code class="fe mj mk ml mm b">try</code>关键字需要一个do-try-catch结构来正确处理错误。</p><p id="8031" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="6c26" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">do</strong> {<br/>    <strong class="mm iu">try</strong> parseName("thisisatoolongnamefortheparser")<br/>} <strong class="mm iu">catch</strong> NameError.tooLong {<br/>    print("The name you entered is too long.")<br/>}</span></pre><p id="54d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，您试图解析一个太长的名字，这导致了一个错误。参见本文中的完整示例<a class="ae lu" href="https://medium.com/codex/swift-error-handling-made-simple-83662e098a8c#27b0" rel="noopener">。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4e9c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">模式中使用的关键字</h1><p id="4fff" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">关键字<code class="fe mj mk ml mm b"><strong class="la iu">_</strong></code>用于模式。</p><p id="20a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个例子:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="d323" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">for</strong> <strong class="mm iu">_</strong> <strong class="mm iu">in </strong>1...10 {<br/>    print("Hello, world!")<br/>}</span></pre><p id="4fae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，你将同一个句子打印了十次。循环索引<code class="fe mj mk ml mm b">i</code>是不相关的，因为它没有被使用。在这种情况下，可以用模式关键字<code class="fe mj mk ml mm b"><strong class="la iu">_</strong></code>替换。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0f95" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">以数字符号(#)开头的关键字</h1><h2 id="8fd4" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#available</code></h2><p id="54de" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">#available</code>条件使代码可用于某些特定的iOS版本和更高版本。</p><p id="9b81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="cced" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">if</strong> <strong class="mm iu">#available</strong>(iOS 14, *) {<br/>    print("This runs for iOS &gt;= 14")<br/>} <strong class="mm iu">else</strong> {<br/>    print("This runs for iOS &lt; 14")<br/>}</span></pre><h2 id="136e" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#colorLiteral</code></h2><p id="34f7" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">#colorLiteral</code>访问Swift的颜色选择器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/39ddbc511e9ac63c31c75d105f782f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0EYnAkUd4wFBf3bClpxbw.png"/></div></div></figure><p id="bbfc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="1d98" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> color = <strong class="mm iu">#colorLiteral</strong>(red: 0.2196078449, green: 0.007843137719, blue: 0.8549019694, alpha: 1)</span></pre><p id="7054" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码应该以这种方式出现在Xcode的代码编辑器中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/dd0fbcf38999d1b6c2a26015da2f3c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*j_7Mehvayoqvpej65KNWcw.png"/></div></figure><h2 id="2aed" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#column</code></h2><p id="23d6" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过使用<code class="fe mj mk ml mm b">#column</code>字面量，计算到代码行中的特定点为止有多少列。</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="cead" class="nm mv it mm b gy oj ok l ol om">print("Example: \(<strong class="mm iu">#column</strong>)")</span></pre><p id="22cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="f8dd" class="nm mv it mm b gy oj ok l ol om">19</span></pre><p id="203e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是它的工作原理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/e01e131faecf7efd6274428a67be9cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*qBL8ZlBLJT8S0IfXcHWxEg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列号一直计数到#号</p></figure><h2 id="1fa4" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#else</code></h2><p id="f034" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">#else</code>是一个条件编译器控制语句。(使用它需要使用一个<code class="fe mj mk ml mm b">#if</code>语句。)</p><p id="77bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用条件编译器控制语句，您可以有条件地编译一些代码，例如在调试时:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="68bb" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">#if</strong> DEBUG<br/>    print("Debugging")<br/><strong class="mm iu">#else</strong><br/>    print("Not debugging)<br/><strong class="mm iu">#endif</strong></span></pre><h2 id="f5e9" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#elseif</code></h2><p id="3336" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">#elseif</code>是条件编译器控制语句。使用它需要一个<code class="fe mj mk ml mm b">#if</code>语句。</p><p id="511d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用条件编译器控制语句，您可以有条件地编译代码，例如，在检查编译代码的设备类型时:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="9048" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">#if</strong> os(iOS)<br/>    print("Compiled for iOS device")<br/><strong class="mm iu">#elseif</strong> os(macOS)<br/>    print("Compiled for mac")<br/><strong class="mm iu">#else</strong><br/>    print("Compiled for something else")<br/><strong class="mm iu">#endif</strong></span></pre><h2 id="9e77" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#endif</code></h2><p id="6466" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">#endif</code>是一个条件编译器控制语句，标志着条件编译代码的结束。</p><p id="122c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用条件编译器控制语句，您可以有条件地编译一些代码，例如在调试时:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="5808" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">#if</strong> DEBUG<br/>    print("Debugging")<br/><strong class="mm iu">#else</strong><br/>    print("Not debugging)<br/><strong class="mm iu">#endif</strong></span></pre><h2 id="1b6d" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#error</code></h2><p id="4e47" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">用<code class="fe mj mk ml mm b">#error</code>文字创建您自己的红色编译器错误。</p><p id="3805" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/aed5b98f9e321e953c6adb8732f5de8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwUn2NXYqtNZRr_Wdwut_A.png"/></div></div></figure><h2 id="b786" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#file</code></h2><p id="bd7f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">您可以使用<code class="fe mj mk ml mm b">#file</code>文字访问当前Swift文件的路径:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="7f95" class="nm mv it mm b gy oj ok l ol om">print("I live in a file called \(<strong class="mm iu">#file</strong>)")</span></pre><p id="d696" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从Swift 5.3开始，使用<code class="fe mj mk ml mm b">#filePath</code>代替<code class="fe mj mk ml mm b">#file</code>。</p><h2 id="352f" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#fileID</code></h2><p id="4f1a" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">您可以通过使用<code class="fe mj mk ml mm b">#fileID</code>文字来访问文件ID:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="a6c0" class="nm mv it mm b gy oj ok l ol om">print("I live in a file with ID: \(<strong class="mm iu">#fileID</strong>)")</span></pre><h2 id="69a2" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#fileLiteral</code></h2><p id="a402" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">#fileLiteral</code>为源代码创建一个文件选择器:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="663d" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> file = <strong class="mm iu">#fileLiteral</strong>(resourceName: "file.txt")</span></pre><p id="231e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/731180944c885efd0ac548e1ca765236.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*C1vMRCrDIr99qXTPMEu8CQ.png"/></div></figure><h2 id="d448" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#filePath</code></h2><p id="cddc" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">从Swift 5.3开始，使用<code class="fe mj mk ml mm b">#filePath</code>文字(而不是<code class="fe mj mk ml mm b">#file</code>文字)访问文件的路径:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="3568" class="nm mv it mm b gy oj ok l ol om">print("Path: \(<strong class="mm iu">#filePath</strong>)") // prints Path: FILE_NAME.swift</span></pre><h2 id="bd1b" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#function</code></h2><p id="50f0" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">#function</code>文字来获取函数的名称。</p><p id="fb52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="fc26" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">func</strong> exampleFunction(){<br/>    print("I am the \(<strong class="mm iu">#function</strong>)")<br/>}</span><span id="3885" class="nm mv it mm b gy on ok l ol om">exampleFunction()</span></pre><p id="0d8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="9a80" class="nm mv it mm b gy oj ok l ol om">I am the exampleFunction()</span></pre><h2 id="30d0" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#if</code></h2><p id="f08d" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">#if</code>是一个条件编译器控制语句。</p><p id="5fdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用条件编译器控制语句，您可以有条件地编译一些代码，例如在调试时:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="4d96" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">#if</strong> DEBUG<br/>    print("Debugging")<br/><strong class="mm iu">#else</strong><br/>    print("Not debugging)<br/><strong class="mm iu">#endif</strong></span></pre><h2 id="0dc7" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#imageLiteral</code></h2><p id="9b34" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">#imageLiteral</code>为源代码创建一个简单的图像图标/图像拾取器，例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="0b4d" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> image = <strong class="mm iu">#imageLiteral</strong>(resourceName: "image.png")</span></pre><p id="9a5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/11c74f5f1c28cebb2e93063e6efccf44.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*lvgyksNEO8WyPMhV2-zAKA.png"/></div></figure><h2 id="b648" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#line</code></h2><p id="2297" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">#line</code>文字返回一个特定的行号。例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="ef8b" class="nm mv it mm b gy oj ok l ol om">print("This is the line number \(<strong class="mm iu">#line</strong>)")</span></pre><h2 id="2335" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#selector</code></h2><p id="3aa6" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">#selector</code>可以用来构造一个<code class="fe mj mk ml mm b">Selector</code>,它引用一个函数而不调用它。</p><p id="5eb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多相关的基于ObjC的API使用选择器，例如计时器或目标/动作模式。</p><p id="184e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个抽象的例子:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="55f4" class="nm mv it mm b gy oj ok l ol om">btn.addTarget(object, action: <strong class="mm iu">#selector</strong>(MyClass.handleTap),<br/>              for: .touchUpInside)</span></pre><h2 id="d5e1" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#sourceLocation</code></h2><p id="2c3d" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">#sourceLocation</code>指定行号和文件名(也可以不同于源代码的行号和文件名)。</p><p id="0dfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/6b8d93d79dfea44eb020055d54605b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZELL0R01lcPGGE6qHKNsHQ.png"/></div></div></figure><p id="d700" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在创建生成Swift源代码的工具时，该功能非常有用。在这种情况下，您希望使用它来定位生成错误的原始代码。</p><h2 id="f4f8" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated"><code class="fe mj mk ml mm b">#warning</code></h2><p id="3c8c" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">用<code class="fe mj mk ml mm b">#warning</code>创建自己的黄色编译器警告。例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="1e0a" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">#warning</strong>("This is a warning!")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/e8b961d1aed927ed03e2d6ffdcad15af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_mqDmy228IuyQgPdT8sZw.png"/></div></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="35dd" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">特定上下文中保留的关键字</h1><h2 id="89b6" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">结合性</h2><p id="80a9" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">定义当缺少括号时，一系列优先级相等的运算符如何组合在一起。</p><p id="8753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关联性类型包括</p><ul class=""><li id="d3f6" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><code class="fe mj mk ml mm b">left</code></li><li id="eed8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe mj mk ml mm b">right</code></li><li id="1501" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><code class="fe mj mk ml mm b">none</code></li></ul><p id="cb41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个自定义的数字除法表情符。为了正确工作，需要<strong class="la iu"> : </strong>的<code class="fe mj mk ml mm b">associativity</code> <code class="fe mj mk ml mm b">left</code>的优先组是<strong class="la iu"> </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6186" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="53ca" class="nm mv it mm b gy oj ok l ol om">0.166</span></pre><h2 id="8b3c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">便利</h2><p id="eccf" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b"><a class="ae lu" href="https://www.codingem.com/swift-multiple-init-methods/" rel="noopener ugc nofollow" target="_blank">convenience init</a></code>创建一个替代初始化器，最终将初始化委托给主初始化器。</p><p id="f1f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a398" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="8751" class="nm mv it mm b gy oj ok l ol om">No type<br/>Banana</span></pre><h2 id="ec2b" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">动态的</h2><p id="81e0" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">dynamic</code>修饰符让Objective-C代码可以访问你的属性/方法。</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="f485" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">class</strong> Fruit {<br/>    <strong class="mm iu">dynamic</strong> <strong class="mm iu">var</strong> type:String?<br/>}</span></pre><h2 id="c3b3" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">迪塞特</h2><p id="5589" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">属性观察者可以对属性进行观察。当发生变化时，属性观察器被触发。</p><p id="7486" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mj mk ml mm b">didSet</code>是一个可以分配给任何可变属性的属性观察器的例子:</p><p id="4fe6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="baae" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">var</strong> nums = [10,20,30] {<br/>    <strong class="mm iu">didSet</strong> {<br/>        print("Numbers changed")<br/>    }<br/>}</span><span id="e19d" class="nm mv it mm b gy on ok l ol om">nums.append(40)</span></pre><p id="3075" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="8309" class="nm mv it mm b gy oj ok l ol om">Numbers Changed</span></pre><h2 id="6f35" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">最后的</h2><p id="e0b2" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过标记类<code class="fe mj mk ml mm b"><strong class="la iu">final</strong></code> <strong class="la iu">禁止继承。</strong></p><p id="5a33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="c6a1" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">final</strong> <strong class="mm iu">class</strong> Fruit {}</span><span id="a4d9" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">class</strong> Dinner : Fruit {} // Triggers a compiler error</span></pre><h2 id="67c8" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">得到</h2><p id="33a7" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">计算属性通过<code class="fe mj mk ml mm b">get</code>方法按需计算值。计算属性不存储值。</p><p id="795e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个<code class="fe mj mk ml mm b">Weight</code>类，它只在被访问时计算重量(磅)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ecb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="c678" class="nm mv it mm b gy oj ok l ol om">220.5<br/>142.85715</span></pre><h2 id="5d86" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">中缀</h2><p id="765f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">infix</code> <strong class="la iu"> </strong>关键字指定在两个目标之间使用运算符。</p><p id="3165" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个自定义运算符(带有+-符号表情符号),它像常规的+运算符一样将两个数字相加:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="9336" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">infix</strong> <strong class="mm iu">operator</strong> ➕</span><span id="3715" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">func</strong> ➕(lhs: Int, rhs: Int) -&gt; Int {<br/>    <strong class="mm iu">return</strong> lhs + rhs<br/>}</span><span id="cc93" class="nm mv it mm b gy on ok l ol om">print(3➕ 6)</span></pre><h2 id="8e6d" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">间接的</h2><p id="1be8" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">indirect</code>关键字指示枚举事例是递归的。</p><p id="7456" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0df2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe mj mk ml mm b">Combination</code>案例中的<code class="fe mj mk ml mm b">Direction</code>参数指的是枚举本身。这很好，但是您需要使用<code class="fe mj mk ml mm b">indirect</code>关键字才能做到这一点。</p><h2 id="2160" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">懒惰的</h2><p id="9bb7" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">创建一个属性，其值仅在第一次使用<code class="fe mj mk ml mm b">lazy</code>关键字时计算。</p><p id="a07a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="c193" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">左边的</h2><p id="70d1" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">将运算符的结合性指定为从左到右。换句话说，当不使用括号时，运算的分组在数学上仍然是正确的。</p><p id="3cc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是使该计算产生正确结果的原因:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="64de" class="nm mv it mm b gy oj ok l ol om">5+2-4+3</span></pre><p id="359c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个实现自定义操作符并定义<code class="fe mj mk ml mm b">associativity</code> <code class="fe mj mk ml mm b">left</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="5ae3" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">变化</h2><p id="66d0" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">默认情况下，禁止更改结构的属性。为了允许改变一个结构的属性，标记方法<code class="fe mj mk ml mm b">mutating</code>。</p><p id="e3b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e3ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="a3f5" class="nm mv it mm b gy oj ok l ol om">Banana</span></pre><h2 id="dfff" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">没有人</h2><p id="0c3e" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">指定运算符没有任何应用的结合性。在代码中，你可以通过写<code class="fe mj mk ml mm b">associativity: none</code>来做到这一点。</p><p id="a138" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着不能将具有相同优先级的运算符放在一起使用。</p><p id="248f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b774" class="nm mv it mm b gy oj ok l ol om">let x = 1.0</span><span id="807c" class="nm mv it mm b gy on ok l ol om">print(0 &lt; x &lt; 10) // won't compile</span></pre><p id="dd19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过创建一个自定义的零合并运算符来进一步演示这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="12a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="c609" class="nm mv it mm b gy oj ok l ol om">1.223</span></pre><p id="4ef9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为结合性是none，所以不能将这些操作符链接在一起。尝试运行此代码片段会导致程序崩溃:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="8c10" class="nm mv it mm b gy oj ok l ol om">print(<strong class="mm iu">nil</strong> ?? <strong class="mm iu">nil</strong> ?? 1.223)</span></pre><h2 id="ca1c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">不变的</h2><p id="c815" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过标记它<code class="fe mj mk ml mm b">nonmutating</code>来表明一个方法不会改变实例。</p><p id="0589" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2e2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="3846" class="nm mv it mm b gy oj ok l ol om">I'm not going to change.<br/>Apple</span></pre><h2 id="a08e" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">可选择的</h2><p id="6a68" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">您可以通过标记<code class="fe mj mk ml mm b">optional</code>在<code class="fe mj mk ml mm b">@objc</code> <a class="ae lu" href="https://medium.com/codex/swift-how-protocols-work-5d0d43a961e7" rel="noopener">协议</a>中创建可选属性。这意味着当符合协议时，不需要实现这些属性。</p><p id="b8db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="b533" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">推翻</h2><p id="10a7" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">override</code>关键字更改子类中的实现。</p><p id="5e22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f5ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="074c" class="nm mv it mm b gy oj ok l ol om">Wassup?<br/>Hello, how is it going?</span></pre><h2 id="445a" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">后缀</h2><p id="193c" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">表示操作符跟随它所操作的目标。在阶乘中，比如<code class="fe mj mk ml mm b">5!</code>，运算符<code class="fe mj mk ml mm b">!</code>是一个<a class="ae lu" href="https://medium.com/codex/swift-create-your-own-custom-operator-a6fe4d71f606" rel="noopener">后缀运算符</a>。</p><p id="fa7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个自定义后缀运算符来计算阶乘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="547d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="3b33" class="nm mv it mm b gy oj ok l ol om">120.0</span></pre><h2 id="9df8" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">前缀</h2><p id="725f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">prefix</code>关键字表示一个操作符在它所操作的目标的前面。</p><p id="0cce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个自定义表情符，它接受一个数字的平方根:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="ccb9" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">prefix</strong> <strong class="mm iu">operator</strong> ✔️</span><span id="3643" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">prefix</strong> <strong class="mm iu">func</strong> ✔️(num: Double) -&gt; Double {<br/>    <strong class="mm iu">return</strong> sqrt(num)<br/>}</span><span id="5066" class="nm mv it mm b gy on ok l ol om">print(✔️25.0)</span></pre><p id="8118" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="fee9" class="nm mv it mm b gy oj ok l ol om">5.0</span></pre><h2 id="1868" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">草案</h2><p id="838a" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">Protocol</code>(大写P的关键字)是Objective-C运行时中定义的类。它代表一个Objective-C协议。</p><p id="329d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mj mk ml mm b">Protocol</code>是一个<a class="ae lu" href="https://swiftrocks.com/whats-type-and-self-swift-metatypes" rel="noopener ugc nofollow" target="_blank">元类型关键字</a>。</p><h2 id="a66c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">需要</h2><p id="01a5" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过标记初始化器<code class="fe mj mk ml mm b">required</code>，确保每个子类都实现了初始化器。</p><p id="ca26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="c719" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">正确</h2><p id="7d99" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">将运算符的结合性指定为从右向左。这意味着当不使用括号时，操作的分组仍然是正确的。</p><p id="56ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个使用双表情符号问号执行零合并的自定义运算符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6717" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="72c0" class="nm mv it mm b gy oj ok l ol om">1.223</span></pre><h2 id="3353" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">设置</h2><p id="9eae" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">set</code>为成员设置新值。这通常与<a class="ae lu" href="https://medium.com/codex/getters-and-setters-in-swift-79a46e9401a0" rel="noopener">计算属性</a>一起使用。计算属性是在被调用时计算的属性。</p><p id="c01f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9b47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="d619" class="nm mv it mm b gy oj ok l ol om">220.5<br/>142.85715</span></pre><h2 id="8607" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">类型</h2><p id="998e" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><code class="fe mj mk ml mm b">Type</code>关键字(带有一个大的<em class="ox"> T </em>)是一个类型的类型。这是Swift中元类型的一个例子。</p><h2 id="2ae1" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">无主的</h2><p id="2204" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在引用周期中，一个实例可以引用另一个实例，而不必在另一个实例存在更长时间或同样长的时间时保持对它的强烈控制。</p><p id="df48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="973c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，如果没有人做，就没有工作。</p><p id="9f7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://krakendev.io/blog/weak-and-unowned-references-in-swift" rel="noopener ugc nofollow" target="_blank">阅读更多关于使用<code class="fe mj mk ml mm b">unowned</code> <strong class="la iu">的</strong></a>。</p><h2 id="9821" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">无力的</h2><p id="8eed" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">在引用周期中，一个实例可以引用另一个实例，如果另一个实例存在的时间更短，则不需要牢牢地控制它。</p><p id="9931" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="60e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="50d2" class="nm mv it mm b gy oj ok l ol om">nil</span></pre><p id="a14e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">阅读更多关于使用<code class="fe mj mk ml mm b">weak</code>的。</p><h2 id="dfce" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">威尔塞特</h2><p id="7aeb" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated"><a class="ae lu" href="https://medium.com/codex/didset-and-willset-in-swift-f0ffe43a2fed" rel="noopener">属性观察器</a>，<code class="fe mj mk ml mm b">willSet</code>在被观察的属性改变之前被调用。</p><p id="419e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="6756" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">class</strong> Person {<br/>    <strong class="mm iu">var</strong> name: String? {<br/>        <strong class="mm iu">willSet</strong>(name) { <br/>            print("I'm about to be renamed to \(name!)!")<br/>        }<br/>    }<br/>}</span><span id="20ef" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">let</strong> person = Person()<br/>person.name = "Charlie"</span></pre><p id="6710" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="967e" class="nm mv it mm b gy oj ok l ol om">I'm about to be renamed to Charlie</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a94f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">额外收获:以<code class="fe mj mk ml mm b">@</code>开头的常见“关键词”</h1><p id="35ff" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">我知道这些不是技术上的关键词，但它们是你期望在这类文章中找到的，所以让我们开始吧:</p><h2 id="baf0" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@autoclosure</h2><p id="a283" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">@autoclosure</code>自动将函数参数包装在闭包内。使用自动结束的全部意义在于你可以省略花括号。</p><p id="6e83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="0ede" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">func</strong> I_will(_ perform_action: <strong class="mm iu">@autoclosure</strong> () -&gt; Void) {<br/>    perform_action()<br/>}</span><span id="a76b" class="nm mv it mm b gy on ok l ol om">I_will(print("Hello, world"))</span></pre><p id="eb8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="5a3a" class="nm mv it mm b gy oj ok l ol om">Hello, world</span></pre><p id="ce25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随意查看<a class="ae lu" href="https://medium.com/codex/swift-demystifying-autoclosures-dc106e4bc04a" rel="noopener">这篇文章</a>做进一步参考。</p><h2 id="b04c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@可用</h2><p id="7144" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">@available</code>检查某个方法或类是否可用于编译代码的特定iOS版本。例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="b178" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">@available</strong>(iOS 13, *)<br/><strong class="mm iu">func</strong> iOS13Works() {<br/>    <!-- -->print("Running this works for &gt;= iOS 13")<br/>}</span></pre><p id="da2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这类似于使用<code class="fe mj mk ml mm b">#available</code>条件。主要区别在于，通过使用<code class="fe mj mk ml mm b">@available</code>，你可以检查更大的代码块，例如类或方法，而使用<code class="fe mj mk ml mm b">#available</code>，你可以检查小块代码的可用性。</p><h2 id="1249" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@discardableResult</h2><p id="ac59" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">通过标记函数<code class="fe mj mk ml mm b">@discardableResult</code>，安全地丢弃函数的返回值。</p><p id="0153" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果您没有使用函数的返回值，编译器会警告您:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/f0e098f536a6130e2ed1baabe1dc307d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwtpIvbSE6fA37qAYz9tBg.png"/></div></div></figure><p id="edc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不需要返回值，你可以通过使用<code class="fe mj mk ml mm b">@discardableResult</code>丢弃它来让编译器高兴:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="bdaf" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">@discardableResult</strong> <strong class="mm iu">func</strong> giveNum() -&gt; Int {<br/>    print("I'll give you a number")<br/>    <strong class="mm iu">return</strong> 10<br/>}</span><span id="599c" class="nm mv it mm b gy on ok l ol om">giveNum()</span></pre><p id="55fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在编译器警告消失了。</p><h2 id="dbb1" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@dynamicCallable</h2><p id="7c06" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">这是将类型标记为可直接调用的语法规则。将<code class="fe mj mk ml mm b">@dynamicCallable</code>与这些方法中的一种或两种结合使用:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="f6ff" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">func</strong> dynamicallyCall(withArguments args: [Int]) -&gt; Double</span><span id="29e9" class="nm mv it mm b gy on ok l ol om"><strong class="mm iu">func</strong> dynamicallyCall(withKeywordArguments args: KeyValuePairs&lt;String, Int&gt;) -&gt; Double</span></pre><p id="ef86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们创建一个结构<code class="fe mj mk ml mm b">Adder</code>，您可以动态地调用它，就好像它是一个函数，可以接受任意数量的参数并将它们相加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="cfd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="32a0" class="nm mv it mm b gy oj ok l ol om">2.35<br/>17.45</span></pre><h2 id="480c" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@ dynamicMemberLookup</h2><p id="147e" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">@dynamicMemberLookup</code>和<code class="fe mj mk ml mm b">subscript(dynamicMember:)</code>方法为不存在的类型指定一个属性。</p><p id="06ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f87e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您现在可以调用fruit的<code class="fe mj mk ml mm b">type</code>或<code class="fe mj mk ml mm b">color</code>，就好像它们是它的真实属性一样:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="de08" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">let</strong> fruit1 = Fruit()</span><span id="dd3c" class="nm mv it mm b gy on ok l ol om">print(fruit1.type)<br/>print(fruit1.color)<br/>print(fruit1.somethingElse)</span></pre><p id="78bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="a134" class="nm mv it mm b gy oj ok l ol om">Banana<br/>Yellow<br/>N/A</span></pre><h2 id="cac2" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@逃避</h2><p id="5611" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">为了在调用闭包的函数完成后保持闭包的活力，用关键字<code class="fe mj mk ml mm b">@escaping</code>标记它的转义。</p><p id="b18e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让一个消息<code class="fe mj mk ml mm b">responseHandler</code>闭包比<code class="fe mj mk ml mm b">howAreYou()</code>调用活得长，以监听稍后到达的响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fab2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在上面的例子中，即使在<code class="fe mj mk ml mm b">howAreYou()</code>调用结束后，这个块仍然保持活动状态:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="582f" class="nm mv it mm b gy oj ok l ol om">{ friendResponse <strong class="mm iu">in</strong><br/>    print(friendResponse)<br/>}</span></pre><p id="bc45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，您可以使用它来处理稍后到达的响应。</p><p id="8e71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想更深入地了解Swift中的转义闭包，以及上面例子的更多细节，请查看这篇文章。</p><h2 id="3a09" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@objc</h2><p id="1675" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">@objc</code>标记Objective-C代码中可访问的方法和属性。</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="4214" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">@objc</strong> <strong class="mm iu">public</strong> <strong class="mm iu">class</strong> ExampleClass {} // Accessible in Objective-C</span></pre><h2 id="912a" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@objcMembers</h2><p id="6051" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">使用<code class="fe mj mk ml mm b">@objcMembers</code>快捷键标记Objective-C代码可用的类的所有方法和属性。例如:</p><pre class="kj kk kl km gt of mm og oh aw oi bi"><span id="043f" class="nm mv it mm b gy oj ok l ol om"><strong class="mm iu">@objcMembers</strong> <strong class="mm iu">class </strong>ExampleClass {<br/>    <strong class="mm iu">func</strong> doSomethingCool() {} // Accessible in Objective-C<br/>}</span></pre><p id="a0da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果您想在Objective-C中访问单个方法或属性，您可以使用<code class="fe mj mk ml mm b">@objc</code>来代替。</p><h2 id="d9c6" class="nm mv it bd mw nn no dn na np nq dp ne lh nr ns ng ll nt nu ni lp nv nw nk nx bi translated">@未知</h2><p id="6037" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">向<code class="fe mj mk ml mm b">switch</code>语句添加编译器警告，提醒自己彻底检查所有情况。这是通过在<code class="fe mj mk ml mm b">default</code>案例前添加<code class="fe mj mk ml mm b">@unknown</code>实现的。</p><p id="3f83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于常规的<code class="fe mj mk ml mm b">switch</code>语句，没有关于<code class="fe mj mk ml mm b">Pineapple</code>丢失<code class="fe mj mk ml mm b">case</code>的警告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/aef3336c9ef0f02ec93700ca02e79727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*386LxUNEIjMtvo1PJsVqxA.png"/></div></div></figure><p id="98a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，通过标记<code class="fe mj mk ml mm b">default</code>案例<code class="fe mj mk ml mm b">@unknown</code>，您可以看到一条关于未处理所有可能案例的警告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/ff578aba97a68042cabef0800c8d0c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DB_2VD_i5cMGjJdgAX6g4g.png"/></div></div></figure><p id="ec9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您向枚举中添加了新的事例，但忘记了处理它们，这将非常有用。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="3bf6" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="1139" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">如果单子上少了什么，请告诉我。我会相应地更新它。</p><p id="b905" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。编码快乐！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="94b0" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">资源</h1><div class="pb pc gp gr pd pe"><a href="https://swift.org/documentation/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">Swift.org</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">您可以将此页面上的资源用作Swift语言的文档。苹果公司拥有额外的资源…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">swift.org</p></div></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5c4f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">你也是皮托尼斯塔吗？</h1><p id="cb8f" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">如果你感兴趣，这里是Python 中所有<a class="ae lu" href="https://www.codingem.com/reserved-keywords-in-python/" rel="noopener ugc nofollow" target="_blank">保留关键字的完整列表。</a></p></div></div>    
</body>
</html>