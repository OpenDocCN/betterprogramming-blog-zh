<html>
<head>
<title>CQRS Software Architecture Pattern: The Good, the Bad, and the Ugly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CQRS软件架构模式:好的、坏的和丑陋的</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cqrs-software-architecture-pattern-the-good-the-bad-and-the-ugly-e9d6e7a34daf?source=collection_archive---------0-----------------------#2022-01-28">https://betterprogramming.pub/cqrs-software-architecture-pattern-the-good-the-bad-and-the-ugly-e9d6e7a34daf?source=collection_archive---------0-----------------------#2022-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="058d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用CQRS和事务发件箱模式设计可伸缩架构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6de2f31dc09617a08f91548ef1a5a2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zX2jzLKgp-UHbnQA"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jukan Tateisi 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">命令和查询责任分离(CQRS)这是一种架构模式，其主要重点是分离读取和写入数据的方式。这种模式使用两种不同的模型:</p><ul class=""><li id="9ede" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">查询</strong>——负责读取数据</li><li id="b55f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">命令</strong>——负责更新数据</li></ul><p id="5d20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说-</p><blockquote class="mg mh mi"><p id="345e" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">命令和查询责任分离(CQRS)模式将数据存储的读取和更新操作分开。</p><p id="41e4" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">在您的应用中实现CQRS可以最大化其性能、可伸缩性和安全性。</p></blockquote><p id="6a1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图展示了CQRS模式的一个基本实现。<em class="mj">(图1。)</em></p><p id="52eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍后，我将解决两个存储之间的同步问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/ccbc402c92fe63ed6fa9552a440cafb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*RiWr-7_SdVIOSFzp9HneOQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。高级CQRS实施</p></figure><h1 id="fb86" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">术语</h1><h2 id="c31c" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">命令</h2><p id="27a9" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">命令表示改变实体状态的意图。它们执行插入、更新、删除等操作。命令对象改变状态并且不返回数据。</p><p id="8a28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">命令代表一个业务操作，并且总是处于命令时态，因为它们总是告诉应用服务器做一些事情。</p><h2 id="503c" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">问题</h2><p id="aaf3" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">查询用于从数据库中获取数据。查询对象只返回数据，不做任何更改。</p><p id="bb5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查询将只包含获取数据的方法。它们用于读取数据库中的数据，以将d to返回给客户端，这些数据将显示在用户界面中。</p><h2 id="c308" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">活动采购</h2><p id="bafb" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">事件源确保对应用程序状态的所有更改都存储为一系列事件。</p><p id="96e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不仅可以查询这些事件，还可以使用事件日志来重建过去的状态，并以此为基础自动调整状态以应对追溯性的更改。</p><h2 id="5298" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">变更数据捕获</h2><p id="d48f" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">变更数据捕获(CDC)解决方案从数据库事务日志(或等效机制)中捕获变更事件，并将这些事件转发给下游消费者。</p><p id="810b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CDC最终允许应用程序状态外部化，并与外部数据存储同步。</p><p id="c6da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CDC可以使用<a class="ae kv" href="https://debezium.io/documentation/reference/stable/architecture.html" rel="noopener ugc nofollow" target="_blank"> Debezium </a>实现，如下所示:</p><ul class=""><li id="e077" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">嵌入式引擎—(仅适用于Java应用程序)</li><li id="2b29" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">独立Debezium服务器使用Kafka连接。</li></ul></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="a7e7" class="mo mp iq bd mq mr oe mt mu mv of mx my jw og jx na jz oh ka nc kc oi kd ne nf bi translated">CQRS模式</h1><h2 id="a7bb" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated"><strong class="ak">何时使用CQRS </strong></h2><p id="066d" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">CQRS可用于以下场景:</p><ul class=""><li id="d941" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">对数据消费有很高的需求</li><li id="df75" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">数据读取的性能必须与数据写入的性能分开调整，尤其是当读取次数远远大于写入次数时。</li><li id="4e30" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">需要一个团队专注于复杂的域模型，它是写模型的一部分，而另一个团队可以专注于读模型和用户界面。</li><li id="6376" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">该系统预计会随着时间的推移而发展，并且可能包含模型的多个版本，或者业务规则会定期发生变化。</li><li id="b579" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">与其他系统集成，特别是与事件源相结合，其中一个子系统的暂时故障不应该影响其他子系统的可用性。</li><li id="2492" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">您可以承受陈旧的数据。</li></ul><h2 id="d9cd" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">CQRS的优势</h2><ul class=""><li id="32bd" class="ls lt iq ky b kz ns lc nt lf oj lj ok ln ol lr lx ly lz ma bi translated"><strong class="ky ir">关注点分离</strong> —当读取和写入端分离时，模型变得更加可维护和灵活。读模型通常更简单，而写模型涉及更复杂的业务逻辑。</li><li id="47f5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">独立扩展</strong>—借助CQRS，读写工作负载可以独立扩展，从而减少锁争用。</li><li id="9db0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">优化的数据模式</strong> —在读取端，模式可以针对查询进行优化，在写入端，模式可以针对更新进行优化。</li><li id="eaa7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">安全性</strong> —更容易确保只有正确的域实体在数据上执行写操作。</li><li id="78fd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">更简单的查询</strong> —应用程序查询可以通过在读取的数据库中存储物化视图来避免复杂的连接。</li></ul><h2 id="4170" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">实施问题和考虑因素</h2><ul class=""><li id="48ab" class="ls lt iq ky b kz ns lc nt lf oj lj ok ln ol lr lx ly lz ma bi translated"><strong class="ky ir">代码的复杂性</strong>并导致更复杂的应用程序设计，尤其是在使用消息传递时。</li><li id="7837" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">消息传递</strong> —虽然CQRS不需要消息传递，但是使用消息传递来处理命令和发布更新事件是很常见的。在这种情况下，应用程序必须处理消息失败或重复消息。</li><li id="6e2d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">最终一致性— </strong>如果将读取和写入数据库分开，读取的数据可能会过时。</li></ul><h2 id="121b" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">分离的数据库</h2><p id="9050" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">使用CQRS时，也有可能拥有单独的数据库，但这不是强制性的:</p><ul class=""><li id="14c2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">仅用于读取数据和创建物化视图的“读取数据库”</li><li id="61f6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">而“写数据库”仅用于进行更改。</li></ul><p id="0b2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们处理更复杂的应用程序时，如微服务或任何类型的对数据消费有高需求的应用程序，通用方法可能会变得难以处理，因为在同一个数据库中进行大量的写入和读取会影响应用程序的性能(读取和写入工作负载具有非常不同的性能和规模要求)。</p><p id="4429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用单独的读写数据库，它们必须保持同步。通常，这是通过让写模型在更新数据库时发布事件来实现的。</p><p id="0c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">稍后将提供关于事件和保持读写数据库同步的不同方法的更多信息。</p><h2 id="98ba" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">分离的服务/模型</h2><p id="56fb" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">所谓独立的模型，我们通常指的是不同的对象模型，可能在不同的逻辑进程中运行，可能在独立的硬件上运行。</p><p id="e71a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经常可以看到CQRS系统被分割成独立的服务，与<a class="ae kv" href="https://martinfowler.com/eaaDev/EventCollaboration.html" rel="noopener ugc nofollow" target="_blank">事件协作</a>进行通信。这使得这些服务可以轻松利用<a class="ae kv" href="https://martinfowler.com/eaaDev/EventSourcing.html" rel="noopener ugc nofollow" target="_blank">事件源</a>。</p><h2 id="f8ff" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">CAP定理</h2><p id="eb2c" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">CAP定理指出，在一致性、可用性和分区容差(通常被认为是“可伸缩性”)之间，我们只能有两个。</p><blockquote class="mg mh mi"><p id="cb34" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">CQRS的一个巨大优势是，您将能够放松读取模型的一致性要求，以便获得高可用性和可伸缩性。</strong></p></blockquote></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="65be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">那么…为什么我们需要事务发件箱模式？</strong></p><p id="5b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事务发件箱模式用于可靠的消息传递和有保证的事件传递。</p><h1 id="973f" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">事务发件箱模式</h1><h2 id="395a" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">问题</h2><p id="a6e6" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">微服务通常在执行数据库事务后发布事件。</p><p id="d6a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写入数据库和发布事件是两个不同的事务，它们必须是原子的。</p><p id="3781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发布事件失败可能意味着业务流程的严重失败。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ebcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法工作得很好，直到在保存实体对象和发布相应的事件之间出现错误。此时发送事件可能会失败，原因有很多:</p><ul class=""><li id="8749" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">网络错误</li><li id="677e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">消息服务中断</li><li id="f598" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">主机故障</li></ul><p id="53cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论错误是什么，结果都是<code class="fe oo op oq or b">EntityCreated</code>事件不能发布到消息总线。<em class="mj">(图二。)</em></p><p id="c129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他服务不会被通知实体已被创建。</p><p id="4b30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">Entity</code>服务现在必须处理与实际业务流程无关的各种事情。</p><p id="fec6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它需要跟踪仍然需要在重新上线后立即放到消息总线上的事件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/84d04792ce38ecbe2c1aca0ef8e8263a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWr-r_4yu_hubGCgHrGtaA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。向消息总线发送事件时出错</p></figure><h2 id="ad86" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">解决办法</h2><p id="7dfd" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">有一种众所周知的模式叫做“事务性发件箱”,可以帮助避免这些情况。</p><p id="1b09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式为可靠地发布事件提供了有效的解决方案。这种方法的思想是在命令服务的数据库中有一个“发件箱”表。</p><p id="75d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当接收到创建实体的请求(命令)时，不仅完成对实体表的插入，而且表示事件的记录也被插入到发件箱表中。</p><p id="764e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个数据库操作是作为同一个事务的一部分完成的。<em class="mj">(图3。)</em></p><p id="ce68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步后台进程监视发件箱表中的新条目，如果有新条目，它会将事件发布到事件总线。</p><p id="78cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事务发件箱模式保证了消息传递的可靠性和至少一次传递。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/6410e7181d850cf5af4ea7a92fc94379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdpGCuH9hTolZyAMghOZgQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3。事务发件箱模式</p></figure><h2 id="66fa" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">发件箱表格</h2><p id="10b6" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">发件箱表记录描述了命令服务中发生的事件。</p><p id="cbc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，JSON结构表示实体的创建或更新、实体本身的数据以及上下文信息，比如用例标识符。</p><p id="1cbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过发件箱表中的记录显式发出事件，外部使用者可以确信事件的结构是正确的。</p><p id="801d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也确保了当内部域模型或实体表发生变化时，事件消费者不会中断。</p><h1 id="9da5" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">基于变更数据捕获的实现</h1><p id="f731" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated"><a class="ae kv" href="https://debezium.io/blog/2018/07/19/advantages-of-log-based-change-data-capture/" rel="noopener ugc nofollow" target="_blank">基于日志的变更数据捕获</a> (CDC)非常适合捕获发件箱表中的新条目，并将它们传输到Apache Kafka。与任何基于轮询的方法相反，事件捕获几乎实时地以非常低的开销发生。Debezium为MySQL、Postgres和SQL Server等几个数据库配备了<a class="ae kv" href="https://debezium.io/docs/connectors/" rel="noopener ugc nofollow" target="_blank"> CDC连接器</a>。</p><p id="7212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图<em class="mj">(图4。)</em>描述了以管理服务和用户服务这两个微服务为中心的整体架构。既然用了Debezium，那么这两个微服务都应该是用Java写的。</p><p id="8bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Debezium跟踪管理服务数据库的<em class="mj">事务日志</em>(【预写日志】，<em class="mj"> WAL </em>)，以便捕获发件箱表中的任何新事件，并将它们传播到Apache Kafka。有关事件路由的更多信息，请参考<a class="ae kv" href="https://debezium.io/documentation/reference/stable/transformations/outbox-event-router.html" rel="noopener ugc nofollow" target="_blank">发件箱事件路由器</a>配置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/3356c1d98705733c3fa30e71379a1513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_8aZcAntFRPgBXzl72FTA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4。使用CDC实施CQRS的架构</p></figure><p id="6166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">id</code> —每条消息的唯一标识；消费者可以使用它来检测任何重复事件，例如在出现故障后重新启动以读取消息时。创建新事件时生成。</p><p id="382f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">entity_type</code> —与给定事件相关的<em class="mj">聚合根</em>的类型；想法是，依靠领域驱动设计的相同概念。</p><p id="df35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">entity_id</code> —受给定事件影响的聚合根的id；例如，这可以是目录的id。</p><p id="c877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">topic</code> —事件的主题，如“目录已创建”或“目录已删除”。允许消费者触发合适的事件处理程序。</p><p id="1b8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">payload</code> —具有实际事件内容的JSON结构，例如包含目录信息。</p><p id="0b32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注册Debezium连接器时——我们应该确保放弃删除Kafka主题中的事件。通过将<code class="fe oo op oq or b">tombstones.on.delete</code>设置为<code class="fe oo op oq or b">false</code>，当从发件箱表中删除事件记录时，连接器将不会发出删除标记(“tombstones”)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="86b3" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">一种基于事件总线的实现</h1><p id="6624" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">发件箱消息处理可以在一个单独的过程中完成，这取决于用例。但是，您也可以使用相同的进程，但在单独的线程中，而不是创建一个新的进程，这取决于需求。<em class="mj">(图五。)</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/04a10b1a37a759e35c25d132f514f82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Auw2d-bJWHARgDpFbAZO0A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5。基于事件总线的CQRS体系结构。</p></figure><p id="609f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个想法是使用一个调度器，它将定期运行并处理来自O <em class="mj"> utbox表</em>的消息。任务执行计划可以配置为每隔几秒钟运行一次。调度器的配置实际上取决于系统中有多少消息需要处理。</p><p id="55ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们使用Postgres来保持发件箱表的持久性，我们将使用Postgres的CTE(公共表表达式)来获取100条按创建时间排序的消息，我们还识别和获取处理时间超过2分钟的消息。注意，我们还在同一个事务中将发件箱消息的状态设置为正在处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把这些放在一起—</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9edb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我在前面所写的，如果在处理消息和将它发布到发件箱表中设置为已处理之间存在错误，任务将在下一个任务迭代中从上次拾取消息起2分钟后拾取该消息。这样，我们保证至少一次交货。</p><h2 id="3860" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">发件箱消息</h2><p id="b20c" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated"><code class="fe oo op oq or b">status</code> —</p><ul class=""><li id="4109" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">待处理—发件箱邮件待处理。</li><li id="25fb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">正在处理—发件箱邮件当前正在处理中。引入这种状态的目的是避免在不同的线程或应用程序实例中运行多个作业调度执行来拾取和处理相同的消息。这样，我们可以最大限度地减少多次消息传递。</li><li id="7303" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">已处理—发件箱邮件已成功处理，可以删除。</li></ul><p id="d763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq or b">picked_at</code> —作业拾取消息进行处理的时间。该值还用于标识已选择进行处理但其状态未设置为已处理的消息。作业将再次挑选状态设置为“正在处理”且挑选时间超过2分钟的消息。</p><p id="0e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的就不言自明了。</p><h1 id="4413" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">CQRS不好和丑陋的一面</h1><h2 id="71b4" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">复杂性</h2><p id="171e" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">为什么向某个列表添加一个简单的条目并返回新列表作为响应如此困难？这完全取决于具体情况。</p><p id="934e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从更常见的上下文开始，在这种情况下，数据在一台机器上，用户规模合理，例如，数百或数千用户。在我们的案例中，CQRS很复杂，我们在用户希望获得一致性的地方优先考虑可用性。</p><p id="aad6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以脸书或Twitter为例，它们必须同时为数百万用户提供服务，并且必须针对可伸缩性和可用性进行优化。只要你还能使用他们的平台，继续参与，几分钟内你得到10个而不是11个赞或评论都没关系。或者让谷歌即时显示最新的搜索结果。</p><p id="dfb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，CQRS并不困难，因为同步几个存储的工作量比构建完成所有工作的单一模型的开销要少。通过减少可伸缩性的挑战来抵消同步两个模型所增加的复杂性。</p><h2 id="3829" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">应用程序更改</h2><p id="a707" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">CQRS增加了系统的复杂性，使得改变它更加困难。只有当您遇到一些极端的性能问题时，使用两个数据模型比使用一个数据模型更好，这才有意义。这不适用于大多数应用程序。</p><h2 id="7997" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">先有一些数字</h2><p id="c729" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">CQRS可能很适合你。你试过更简单的方法吗？您有任何数字来支持您的说法，即典型的关系数据库是不够的吗？您是否创建了概念证明(POC)来证明解决方案的可行性？</p><p id="cf93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，当谈到最终的一致性时，是产品所有者来决定它是否适合业务需求。</p><h2 id="2d72" class="ng mp iq bd mq nh ni dn mu nj nk dp my lf nl nm na lj nn no nc ln np nq ne nr bi translated">复杂的查询</h2><p id="e5e4" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">如果你用的是NoSQL，你有没有考虑过迁移到RDBS？或者您是否考虑过使用物化视图来预先计算您的查询？或者甚至是数据重塑？</p><h1 id="71ac" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="6402" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">CQRS和事件采购并不是一个神秘的组合。在开始您的旅程之前，掌握这两种模式的许多含义是很重要的。否则，很容易在技术和功能层面上搞得一团糟</p><p id="c61c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CQRS和/或活动采购和/或CDC可能是许多问题的优秀解决方案，前提是您对限制和不利因素有清晰的了解。</p><p id="b23b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要出于必要匆忙做出违背你最初商业计划的决定。在您的系统中实施CQRS模式之前，请确保进行概念验证和其他测试。创建概念验证来测试您的解决方案，将确保您获得最佳版本的解决方案，并在此过程中节省您的时间和金钱。不要害怕弄脏你的手。</p><h1 id="d566" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">进一步阅读</h1><ul class=""><li id="5395" class="ls lt iq ky b kz ns lc nt lf oj lj ok ln ol lr lx ly lz ma bi translated">CQRS——马丁·福勒</li><li id="45a7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://debezium.io/blog/2020/02/10/event-sourcing-vs-cdc/" rel="noopener ugc nofollow" target="_blank">微服务的分布式数据—事件源与变更数据捕获</a></li><li id="3ee4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/" rel="noopener ugc nofollow" target="_blank">可靠的微服务数据交换与发件箱模式</a></li><li id="246e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://microservices.io/patterns/data/transactional-outbox.html" rel="noopener ugc nofollow" target="_blank"> microservices.io —事务发件箱</a></li><li id="fe14" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs" rel="noopener ugc nofollow" target="_blank">微软— CQRS模式</a></li><li id="2d02" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://microservices.io/patterns/data/cqrs.html" rel="noopener ugc nofollow" target="_blank">微服务公司io — CQRS </a></li></ul><p id="69cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>