<html>
<head>
<title>Preferences in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的首选项</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/preferences-in-swiftui-17b9f1df2b8b?source=collection_archive---------11-----------------------#2021-01-26">https://betterprogramming.pub/preferences-in-swiftui-17b9f1df2b8b?source=collection_archive---------11-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="902b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个捉人游戏来演示它们的用法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ca7ba0aa98d2ff4fcee9fdd5cf88167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K7NUkFNlI7bHgZLS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e42e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我上周写了一篇关于使用拖拽手势的论文。我很高兴地说，它很受欢迎，我决定做一个后续的作品。</p><p id="08b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我用一个小应用程序来结束它(实际上是标题)，这个小应用程序使用可观察的对象来存储两个视图的坐标，正如你在这里看到的。这些信息被用来制作他们互动的动画。心随着进入对方的空间而微微褪色。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/cfd56eda0a5a9efe00cc6e228adfa6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kb2MFT4XmzmeU0pTuyC5FQ.gif"/></div></div></figure><p id="a5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想在这篇文章中扩展我所做的来构建一个简单的游戏。但更重要的是，我还想看看我在编码时犯的一些错误，并完成一些修复。请继续读下去。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4f1e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">介绍</h1><p id="9a8b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">案情摘要</p><p id="70f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在写一个简单的棋盘游戏，它很有可能是某种基于磁贴的应用。它将有简单的规则来拖动瓷砖超过对方很像动画gif中的两颗心。我想要实现的规则是这个游戏几乎是一样的——只是动作有点不同。我有十六块瓷砖，上面都有数字。当我将一个图块拖过另一个图块时，它会将传入图块上显示的值添加到被拖过的图块上。简单。</p><p id="131d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等…在我们开始编码之前，让我们更客观地看待这个问题。我需要一个瓷砖网格。我需要能够识别每个瓷砖，并根据需要修改其表现形式。很明显，我需要使用类似几何阅读器的东西来把我的拖拽动作和棋盘放在一起。最终结果应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/94af42b1f5d32b663e936471585fb877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*g96UXQ4I0TxXMUKEo5SkeA.gif"/></div></div></figure><p id="c3ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，在很大程度上，这是相当直接的代码，但有一个讨厌的陷阱。为了存储圆的坐标，我使用了<code class="fe nb nc nd ne b">.onAppear</code>视图修改器。这就像你看到的那样工作——但是只有当它所基于的界面没有任何可选的视图在移动元素时出现或消失。而且，只有当你的用户不改变设备的方向，任何一个事件都会破坏代码。</p><p id="cb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以利用。<code class="fe nb nc nd ne b">onAppear</code>更新坐标不是正确的解决方案。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="12ba" class="nf me it bd mf ng nh dn mj ni nj dp mn li nk nl mp lm nm nn mr lq no np mt nq bi translated">SwiftUI首选项</h2><p id="2df7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">但这是正确的解决方法。<em class="nr"> </em>事实上，这是您需要使用首选项协议全面存储坐标的最终方式。通过这种方式，您可以将附加信息与SwiftUI视图相关联。一种协议，通过它可以关联自定义结构。一个协议，我们可以使用它来保存我们的CGRect，并在情况发生变化时再次查询它(也就是设备的方向或进入帧的另一个视图)。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5dda" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">操作方法</h1><p id="dd51" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">真的很简单。我们需要使用两个修饰符，第一个是在构建网格时将坐标保存到一个结构中，第二个是在情况发生变化时更新坐标。显然，我们需要用一个<code class="fe nb nc nd ne b">GeometryReader</code>的领域来调用它们，以获得我们需要的值。我还使用自定义坐标空间来确保网格和拖动动作网格都映射到同一个空间。</p><p id="f154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">若要编码，请先执行结构:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="4a56" class="nf me it ne b gy nw nx l ny nz">struct CirclePreferenceData: Equatable {<br/>  static func == (lhs: CirclePreferenceData, rhs:   CirclePreferenceData) -&gt; Bool {<br/>  return lhs.viewTag == rhs.viewTag<br/>}<br/>  let viewTag: Int<br/>  let viewBounds: Anchor&lt;CGRect&gt;<br/>}</span></pre><p id="00bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将其链接到首选项协议:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="01b6" class="nf me it ne b gy nw nx l ny nz">struct CirclePreferenceKey: PreferenceKey {<br/>  typealias Value = [CirclePreferenceData]<br/>  static var defaultValue: [CirclePreferenceData] = []<br/>  static func reduce(value: inout [CirclePreferenceData], nextValue: () -&gt; [CirclePreferenceData]) {<br/>  value.append(contentsOf: nextValue())}<br/>}</span></pre><p id="a07e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我刚刚描述了使用它的代码:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="f237" class="nf me it ne b gy nw nx l ny nz">.anchorPreference(key: CirclePreferenceKey.self, value: .bounds, transform: { [CirclePreferenceData(viewTag: self.identify, viewBounds: $0)] })}<br/>.onPreferenceChange(CirclePreferenceKey.self) { preferences in<br/>  let p = preferences.first(where: { $0.viewTag == identify })<br/>  let bounds:CGRect = geo[p!.viewBounds]<br/>  newRange[identify] = bounds<br/>}</span></pre><p id="af90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些使我想到了本文的结尾。我包括了两个完整的应用程序副本。第一个用<code class="fe nb nc nd ne b">.onAppear</code>。第二个例子使用了<code class="fe nb nc nd ne b">.preferences</code>协议和<code class="fe nb nc nd ne b">view </code>修改器。</p><p id="ba0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它们本质上是相同的代码，只有少量的更改。注意<code class="fe nb nc nd ne b">Combine </code>框架发布者只显示了一次，尽管它在两个部分中都被使用。</p><p id="173d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用首选项协议的更改版本如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我将结束这一小段。我希望你觉得这篇文章很有用——并且像我写这篇文章一样喜欢阅读它。</p><p id="dbb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你愉快。</p></div></div>    
</body>
</html>