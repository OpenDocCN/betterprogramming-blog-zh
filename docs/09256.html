<html>
<head>
<title>How To Choose Data Fetching Strategies In NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NextJS中如何选择取数据策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-choose-data-fetching-strategies-in-nextjs-dadabf45e562?source=collection_archive---------8-----------------------#2021-08-03">https://betterprogramming.pub/how-to-choose-data-fetching-strategies-in-nextjs-dadabf45e562?source=collection_archive---------8-----------------------#2021-08-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9b55" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用真实世界的例子解释</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/b7c1b3f831cdedd1e731d1cec160044f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9o68lbtgwztDQ-w519nSg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@bdchu614?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae kz" href="https://unsplash.com/s/photos/confusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="627d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> NextJS </strong> </a>是我们React开发者喜爱和推崇的一个框架。需求量很大，而且非常非常强大。</p><p id="0f48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是当你开始学习这个的时候，你会看到<strong class="lc iv"> ReactJS </strong>和<strong class="lc iv"> NextJS </strong>主要区别在于<code class="fe lw lx ly lz b">pre-rendering</code>的能力。一开始可能有点难以理解。</p><p id="89d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有多种策略可供我们选择，一开始在正确的地方应用正确的解决方案会让人感到困惑。我们将采用现实生活中的应用程序，并了解哪种策略最适合哪种场景。</p><p id="363c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们开始吧。</p><h1 id="86c2" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">这些功能</h1><p id="fd4a" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">希望你已经对NextJS有了基本的了解。如果没有，我建议你先看这篇<a class="ae kz" href="https://javascript.plainenglish.io/start-your-journey-with-next-js-958705cfc299" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="e10b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NextJS中用于预渲染的特殊函数(ReactJS中没有)有:</p><ul class=""><li id="05d3" class="mx my iu lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated"><code class="fe lw lx ly lz b">getStaticProps</code></li><li id="374b" class="mx my iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe lw lx ly lz b">getStaticPaths</code></li><li id="c9ba" class="mx my iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe lw lx ly lz b">getServerSideProps</code></li></ul><p id="3217" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将看到您可以在哪些场景中应用这些功能，并了解最佳实践。</p><h1 id="fc0c" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">我们正在谈论一个电子商务网站</h1><p id="9131" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">使用React的最大缺点是有点难以做到SEO友好。但是对于一个电子商务网站来说，这是你需要的主要东西之一。</p><p id="fc06" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，让我们假设我们正在建立一个有多个页面的电子商务网站。让我们开始设计这个。</p><h1 id="3b51" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">产品页面(可预测)</h1><p id="2e63" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">我们电子商务网站的主页是产品页面，您可以在这里看到产品列表。显然，你已经知道要展示哪些产品。可以有多种策略，如:</p><ul class=""><li id="3425" class="mx my iu lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated">获得流行产品</li><li id="ba61" class="mx my iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">获取特色产品</li><li id="a635" class="mx my iu lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">获得打折产品</li></ul><p id="eed2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不管是哪种情况，最重要的是你已经知道你需要调用哪个API，并且这个API不会改变或者依赖于其他信息。在这些场景中只有<code class="fe lw lx ly lz b">getStaticProps</code>就足够了。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="250c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们的产品页面会提前预生成，不会改变。</p><h1 id="fdcf" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">产品页面(动态)</h1><p id="1c31" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">但是如果你正在建立一个网站，其中的顶级产品根据某种算法经常变化，那么你就不希望一直显示同一个页面。</p><p id="6821" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这种情况下，您需要确保生成的页面定期更新。</p><p id="a2ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，你必须使用<code class="fe lw lx ly lz b">revalidate</code>属性。我们可以定义一个以秒为单位的数字来表示刷新间隔。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="a5ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们给的值是10。这意味着我们仍在预生成我们的产品页面，但它将每10秒更新一次。这叫<code class="fe lw lx ly lz b">incremental static re-generation</code>。</p><h1 id="b928" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">产品详情页面(可预测但动态)</h1><p id="2f42" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">现在，当我们的用户点击某个产品时，我们必须显示该产品的详细信息页面。我们正在调用一个类似<code class="fe lw lx ly lz b">/product-details/?productId=123</code>的API。</p><p id="7a08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有趣的是，我们不知道我们要找的是哪一只<code class="fe lw lx ly lz b">productID</code>。所以我们的服务器需要提前知道所有有效的<code class="fe lw lx ly lz b">productId</code>。</p><p id="4611" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是<code class="fe lw lx ly lz b">getStaticPaths</code>的用武之地。它告诉服务器我们需要预先生成的所有可用路线。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="58d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，只有带有有效<code class="fe lw lx ly lz b">productId</code>的页面会被预生成。</p><h1 id="7631" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">帐户页面(动态和安全)</h1><p id="842a" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">现在有一些页面，我们想验证一些东西。例如在用户的简档页面上。我们不想预先生成所有用户的个人资料，并在需要时显示它们。</p><p id="714a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">或者，我们可能希望确保用户有查看页面的正确权限。在这些场景中，我们使用<code class="fe lw lx ly lz b">getServerSideProps</code>。</p><p id="8f8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">记住一点:如果你使用<code class="fe lw lx ly lz b">getServerSideProps</code>，它不会预生成任何页面。相反，它会在每次页面被请求时运行<code class="fe lw lx ly lz b">getServerSideProps</code>中的代码。</p><p id="7e26" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以这样更安全但效率低。你会想尽量少用它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="1fd8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有一个场景你甚至不能使用<code class="fe lw lx ly lz b">getServerSideProps</code>。</p><h1 id="3770" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">实时访问者数量(非常高度动态)</h1><p id="65c3" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">现在，如果你正在设计一个页面，需要显示一些每次都会改变的数据，例如，你的网站的活访问者数量，你不能使用以上四种方法中的任何一种。相反，你不得不依靠传统的数据获取。</p><p id="ac69" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，您可以使用任何库，如<code class="fe lw lx ly lz b">axios</code>、<code class="fe lw lx ly lz b">fetch</code>、<code class="fe lw lx ly lz b">useSWR</code>等。那是你的选择。</p><h1 id="7cce" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">结论</h1><p id="46cd" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">就是这样。现在，您应该清楚地了解了现代应用程序的可能场景，以及如何利用NextJS中的预渲染功能来提高应用程序的性能和SEO支持。</p><p id="8e63" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你有任何意见，请告诉我。</p><p id="bdfa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">祝您愉快！</p><p id="f67b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">通过</strong> <a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> LinkedIn </strong> </a> <strong class="lc iv">或我的</strong> <a class="ae kz" href="https://www.mohammadfaisal.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">个人网站</strong> </a> <strong class="lc iv">与我取得联系。</strong></p></div></div>    
</body>
</html>