# Python 编程入门—第 9 部分

> 原文：<https://betterprogramming.pub/beginning-python-programming-part-8-45cad890e6b>

## 关于 Python 中的错误处理，您需要知道的一切

![](img/9eb3478c38ff37db87ff3df360d88480.png)

照片由[丘特尔斯纳普](https://unsplash.com/@chuttersnap?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在上一篇文章中，我们讨论了格式化、列表理解和 lambdas。

[](https://medium.com/@broebling/beginning-python-programming-part-8-966f1189c1fe) [## Python 编程入门—第 8 部分

### 在上一篇文章中，我们深入挖掘了类，发现了它们是如何被创建和销毁的。我们还看了我们如何…

medium.com](https://medium.com/@broebling/beginning-python-programming-part-8-966f1189c1fe) 

有了这些灵活性，我们也使代码变得复杂。当您有一个复杂的代码库时，您肯定会遇到错误，这就是错误处理发挥作用的地方。

首先，错误处理是 ***而不是*** 测试！印刷的声明也不是这样。那么到底什么是错误处理呢？

# 错误处理

简而言之，错误处理就是添加足够的逻辑，这样你的程序就可以处理那些原本会停止运行的情况。

错误来自可能引发错误的函数。当错误出现时，它会从函数中返回，即使该函数应该返回一个字符串值。如果不被捕获，它将导致您的程序崩溃。所以让我们开始吧，这样我们可以有效地处理这些问题。

让我们看几个容易发现错误的例子。

首先，我们试图从`my_dict`访问`address`键。不出所料，那个键不存在，我们在控制台中收到一个`KeyError`。

其次，我们试图访问`my_list`中同样不存在的第 10 个元素。对于这个场景，我们接收到一个`IndexError`。

我们可以使用`try...except`来解决这个问题。

我稍微改变了顺序，但是它实际上做了和以前一样的事情，只是我在前面的 try/except 块中圈出了失败的代码。

我们通过编写`try:`来为 Python 解释器准备可能失败的代码。在`try`主体内部，Python 会在运行每一行时检查错误。如果出现错误，它会跳出`try`主体，执行写在`except:`内部的代码。

我们的程序不再崩溃，但它打印“哎呦！”还有“又呜呜了！”到控制台。这很好，因为以前我们的程序一遇到第一个失败的`print`语句就会退出，现在我们的程序继续运行。如果我们在最后一个 try/except 语句下面编写更多的代码，这些代码也会运行。

我不打算就此打住，因为虽然代码有效，但它不是好的代码。

让我们用正确的方式重写这个。

在这里，我们在`except`后面添加我们期望从失败代码中收到的错误类型。所有语言中大多数错误的酷之处在于，它们往往会告诉你发生了哪个错误，然后告诉你发生的原因。

我们还可以通过捕获错误以显示给用户或记录到控制台来改进这一点。

现在，我们正在获取有关所发生错误的有用信息。通过适当的日志格式(后面的文章)，我们可以包含失败的行号，或者如果数字 10 存储在变量中，甚至可以提供更多的信息。

在需要`my_dict`从`my_list`返回一个值的场景中，我们可以将它们封装在同一个`try`块中，如果一个失败，那么我们停止处理剩余的`try`体，执行`except`体并继续。

因为这无法检索字典值，所以它甚至没有尝试检索列表值。它下降到我们最后的`print`语句，程序结束。

> 这在与网络相关的呼叫的情况下是有帮助的，在这种情况下，用户可能没有互联网接入。因为我们通常有更多的代码依赖于这个网络访问，我们可以跳过它，节省一些处理时间。这只是一个例子，一个更现实的解决网络故障的方法是“提前退出”正在执行网络调用的函数，也就是说，调用一失败就从该函数返回。

请注意，在打印错误时，必须将其转换为字符串。因为 print 会自动为您调用任何类中的`__str__(self)`，所以我们只需要在将错误附加到字符串时这样做。我们也可以用 f 弦来代替它，它也能为我们做到这一点。

还有一件事我应该添加，以确保这是失败证明。这是一个全球性的例外条款。

所有的异常都来自于`BaseException`和`Exception`类。这两者之间的区别很简单。

*   `BaseException`是所有异常的子类，包括`Exception`
*   `Exception`是所有非退出异常的子类。根据 [python 文档](https://docs.python.org/3.7/library/exceptions.html#Exception):“所有用户定义的异常也应该从这个类派生。”

我只是加了另一个`BaseException`的例外。这样，如果出现我们没有预料到的情况，我们肯定会处理它，并收到一条消息，提示我们哪里出错了。

我还对`IndexError`异常做了另一个修改，如果数字超出范围，我们打印列表中的最后一项。虽然这并不简单，但我们更可能想要列表中的最后一项，而不是第一项，后者总是在索引 0 处；因此，这是一个足够好的解决方案。把这看作是对*启发式编程、*或者更简单地说最佳猜测逻辑*的一次尝试。*

这是异常的真正目的，我们不只是想显示它们，我们想对它们采取行动，我们需要对错误做些什么，让它对用户有意义。用户不关心列表中有多少元素；他们知道，如果他们想要最后一个，他们将从列表中要求一个高值，并希望它有效。

同样，我们可以用类似下面的内容替换`KeyError`异常:

看到这有多有用了吗？让你的错误有意义。

## 其他

有时我们可能想做一些事情，除非一切顺利。我们可以将`else`添加到我们的`try/except`中，只有当我们没有任何问题时，它才会执行。

这里我们试图以只读方式打开一个名为`my_file.txt`的文件，用`'r'`表示。如果成功，我们读取文件内容，并在将文件内容打印到控制台之前将其存储在`contents`中。

如果文件不存在于我们运行的程序所在的位置，我们将点击`FileNotFoundError`。如果发生这种情况，我们告诉用户发生了什么，然后继续。

如果这种情况没有发生，我们手上就有一个打开的文件，我们需要确保我们关闭了该文件以移除任何锁定，以便其他程序可以在以后使用该文件。这就是`else`的用武之地。如果成功，将执行 else 子句，并关闭文件。

这是工作代码，所以如果你想在你的工作目录中创建一个名为“my_file.txt”的新文件，这是可行的，并且文件会在完成后关闭。

*在 Python 中，通过垃圾回收或者当你的程序退出时，文件自动为你关闭；但是，最好是显式关闭您打开的任何文件。有一种更好的方法来处理文件 IO，但是我们将在以后的文章中讨论这一点。*

## 最后

不，这还不是文章的结尾，但是`else`还有一个兄弟姐妹叫做`finally`。这两者之间的区别很容易理解。

*   `else`是 try 语句成功时只调用**的**吗？
*   `finally`是不是**无论如何都要叫**。

根据您的需要，它们可以单独使用，也可以一起使用。

如果成功，我们将看到以下输出:

```
file opened!
Hello, World!
file closed
done
```

如果找不到文件:

```
File not found!
done
```

开始写你的`try/except`块的一个很好的方法是从把所有的东西彼此分开开始。找出哪些类型的错误可能来自错误引发函数。

![](img/b63c8aee968f833925b2111d56941b37.png)

彼得·赫尔希在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 创建自定义错误

有时，我们的程序非常专业，以至于我们需要自己的错误，我们可以从函数中返回，这些函数提供了告诉用户哪里出错的特异性。我们有两个选择，要么采用 Python 已经存在的错误，要么创建我们自己的错误。

让我们先来看看从 Python 中采用。

对于这个例子，我们将接受一个字符串参数，但是我们希望它只包含空格。

在这两个示例中，第一个`data`值是正确的，我们看到控制台中显示的值为 10。

在第二个例子中，我们有标签(`\t`)。我们的函数做的第一件事是检查数据是否包含制表符。如果是，它将引发`TabError`。错误本身与`data`字符串断开；它不关心内容。这只是一个错误，如果事情没有按计划进行，你可以用它在你的程序中提供一个有意义的停止。如果您尝试打印`TabError`的字符串值，您将返回`None`。

如果您想包含更适合当前情况的错误消息，您可以将函数改为:

这将允许您像上面那样使用`TabError as error`,并将其显示为错误消息。这是首选的，这样，你只需要担心返回你的错误信息，而不是每次调用这个函数都创建一个错误信息。

当然，如果您需要在错误消息中包含逻辑，您可以调整一条或两条消息来满足您的需要。

如果您需要比这更特殊的东西，您可以随时创建自己的错误。

这里我们创建了一个名为`BadData`的异常，它是`Exception`的子类，这是我们应该在所有错误中使用的。我添加了一个*文档串*，当我们看到`BadData`的自动文档时，它可以帮助我们理解它的用途。然后我们`pass`因为我们不需要再做什么了。

我们运行我们的程序，如果我们有一个包含级别的文件，那么我们继续处理内容。如果没有，那么我们抛出异常并在下面捕获它。因为我们的异常是一个类，所以我们可以在任何需要的地方使用它。

它很简单，并为您提供了许多功能来处理系统可能无法理解的错误。如果您找不到适合您需求的异常，并且没有更好的方法不使用`try/except`重构您的代码来处理那个错误，那么总是创建自定义异常。

## 再加注

有时，您可能会调用一个函数堆栈深处的异常，并需要它返回到顶部。在这种情况下，您可以使用`raise`通过堆栈继续引发相同的异常，直到您准备好处理它。

这里我只是使用了一个`NotImplementedError`,因为我们还没有完成这个函数。`some_other_func`使用`try/except`块调用`make_error`。如果我们收到一个`NotImplementedError`，我们再次引发它，这样我们就可以在我们的主体中处理它，在那里我们打印“未实现”虽然这是一个简单的例子，但它让您很好地了解了它是如何工作的。

# 摘要

今天，我们学习了错误是如何发生的，以及如果出现错误，我们如何处理它们。我们学习了几种在不太理想的条件下保持程序运行的技术，以及正确的错误处理和糟糕的错误处理之间的区别。如果您已经下载了 PyCharm，您可以输入`raise`，然后输入`ctrl` + `space`来查看一些您可以使用的异常。如果你有足够的勇气参与其他地方的模块，你甚至可以看到他们为你创建的关于他们项目的不同的异常。

## 推荐阅读

Python 教程的第 8 章

 [## 8.错误和异常-Python 3 . 7 . 3 文档

### 即使语句或表达式在语法上是正确的，当试图执行…

docs.python.org](https://docs.python.org/3/tutorial/errors.html) 

# 下一步是什么

接下来是代码结构和可读性。现在是我们学习如何在 PEP 8 标准下正确构建代码的时候了。我们可能还会涉及 PEP 257 中定义的 docstring 约定。

如果你打算写好的 Python 程序，你需要理解那些 PEP 标准，并至少遵守它们。

在那之前，看看你是否能处理一些项目中可能出现的令人讨厌的错误。这样你就可以把任何你想要的数据扔进你的应用程序，它会智能地回应你的疑虑。