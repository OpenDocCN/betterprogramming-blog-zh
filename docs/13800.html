<html>
<head>
<title>Memory Safety Violations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存安全违规</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/memory-safety-violations-a3e75536cc9?source=collection_archive---------10-----------------------#2022-09-28">https://betterprogramming.pub/memory-safety-violations-a3e75536cc9?source=collection_archive---------10-----------------------#2022-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4725" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何避免内存问题？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1ab69da8cbe066e2a8385c9f1a32c149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIa0IuvGEanvO919HwPpqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行程序的内存(图片由作者提供)</p></figure><h1 id="2d51" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">运行程序的内存</h1><p id="ee23" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">正在运行的程序的典型内存布局如下:</p><ul class=""><li id="0dcd" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">静态内存:静态大小、静态分配(编译时)、全局变量和静态局部变量。</li><li id="6b38" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">堆栈内存(调用堆栈):静态大小，动态分配(运行时)，用于局部变量。</li><li id="8969" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">堆内存:动态大小，动态分配(运行时)。它的程序员控制一些编程语言(可变大小的对象)。</li></ul><p id="1584" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">对于所有数据，必须分配内存(即保留内存空间)。</p><p id="3132" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">太好了！我们现在知道我们的程序如何以及何时使用内存了！</p><p id="f1d4" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">现在，让我们看看编程语言是如何管理(分配和释放)堆内存的！</p><h1 id="9216" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">在堆中分配和释放内存</h1><p id="6dbd" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">内存管理有几种类型:</p><ul class=""><li id="b9a7" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">手动:C，C++</li><li id="6fc5" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">手动保持-释放(MRR):目标-C</li><li id="a0f7" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">自动参考计数(ARC): Objective-C，Swift</li><li id="8a39" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">垃圾收集(全自动管理):Java、JavaScript</li><li id="a443" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">所有权:生锈</li></ul><p id="4d85" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">让我们快速了解一下每个选项的神奇之处！</p><h2 id="315d" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">手动内存管理</h2><p id="8e79" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在C中，像<code class="fe nr ns nt nu b">malloc()</code>这样的函数用于从堆中动态分配内存。当不再需要内存时，指针被传递给<code class="fe nr ns nt nu b">free</code>，它释放内存，以便它可以用于其他目的。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="b80a" class="nf kz it nu b gy nz oa l ob oc">#include &lt;stdlib.h&gt;</span><span id="1667" class="nf kz it nu b gy od oa l ob oc">int *array = malloc(num_items * sizeof(int));</span></pre><p id="d034" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated"><code class="fe nr ns nt nu b">malloc()</code> <strong class="ls iu"> </strong>会尝试找到未使用的足够大的内存来保存指定的字节数并保留它。否则，程序将终止，并显示一条错误消息。</p><p id="2be2" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated"><code class="fe nr ns nt nu b">malloc()</code>不会自动解除分配。还必须使用<code class="fe nr ns nt nu b">free</code>显式释放它。</p><p id="5949" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">忘记释放会导致内存泄漏和内存不足！</p><p id="517b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">除非重新分配或重新分配，否则我们不能使用释放的指针！</p><p id="88f1" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">哇，那不是很难吗？</p><p id="1864" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">我们来看看C++内部吧！</p><p id="ba86" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在C++中，内存管理是使用<code class="fe nr ns nt nu b">new</code>和<code class="fe nr ns nt nu b">delete</code>操作符来完成的。<code class="fe nr ns nt nu b">new</code>用于在执行时分配内存。<code class="fe nr ns nt nu b">delete</code>释放保留的内存。</p><p id="637d" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">和C语言一样，我们必须小心不要忘记释放内存和避免访问错误！</p><p id="5d38" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">尽管手动管理内存很困难，但它的好处是我们知道程序的确切需求，并且我们可以在使用完内存后立即释放内存。</p><p id="b359" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">我们还确保对象只要应该存在就存在，但不再存在。</p><p id="de51" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">您还可以基于低级内存管理函数创建您的自动内存管理方式！</p><h2 id="ee46" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">从手动保持释放(MRR)到自动参考计数(ARC)</h2><p id="c388" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">iOS和OS X应用通过引用计数实现内存管理:</p><ul class=""><li id="06a9" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">当我们声明一个对象的所有权时，我们增加了它的引用数。</li><li id="f482" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">当我们处理完这个对象后，我们减少它的引用数。</li><li id="883f" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">当计数达到零时，允许操作系统销毁它。</li></ul><p id="7fc9" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">很久以前，在Objective-C中，我们通过调用特殊的内存管理方法来手动控制对象的引用计数:</p><ul class=""><li id="5f23" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated"><code class="fe nr ns nt nu b">alloc</code>:引用计数加1(拥有一个对象)。</li><li id="931e" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated"><code class="fe nr ns nt nu b">retain</code>:引用计数加1(取得对象的所有权)。</li><li id="49d4" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated"><code class="fe nr ns nt nu b">release</code>、<code class="fe nr ns nt nu b">autorelease</code>:引用计数减一(放弃一个对象的所有权)。</li></ul><p id="f9b1" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">这叫做手动保持释放(MRR)！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/4b02dd20b0444c3e7042a90449201770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7ONpd0nnHOUGbwup.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae of" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html" rel="noopener ugc nofollow" target="_blank">参考计数内存管理</a></p></figure><p id="bedf" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">我们的工作是声明和放弃程序中每个对象的所有权:</p><ul class=""><li id="c2d6" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">如果我们忘记释放一个对象，它的底层内存永远不会被释放，从而导致内存泄漏(我们将在后面看到更多细节)。</li><li id="ab90" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">当我们试图释放一个对象太多次时，就会产生一个悬空指针(我们将在后面看到更多细节)。</li><li id="06f1" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">在这两种情况下，程序很可能会崩溃。</li></ul><p id="9217" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">很难在每一个<code class="fe nr ns nt nu b">alloc</code>、<code class="fe nr ns nt nu b">retain</code>、<code class="fe nr ns nt nu b">copy</code>和<code class="fe nr ns nt nu b">release</code>或者<code class="fe nr ns nt nu b">autorelease</code>之间保持平衡！</p><p id="850b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">幸运的是，随着Objective-C和Swift的新版本，我们已经转移到ARC了！</p><p id="fd5c" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">自动引用计数的工作方式与MRR完全相同，但它会自动为我们插入合适的内存管理方法。这意味着我们不会再次手动调用<code class="fe nr ns nt nu b">retain</code>、<code class="fe nr ns nt nu b">release</code>或<code class="fe nr ns nt nu b">autorelease</code>。哇哦。</p><p id="3e91" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">自动引用计数让我们完全忘记了内存管理。其思想是关注高级功能，而不是底层的内存管理。</p><p id="6783" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">你可以在这里找到更多关于ARC <a class="ae of" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank">的细节。尽情享受吧！</a></p><p id="b8f4" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">啊哈，这是自动管理内存的一大步，但不是唯一的方法！让我们继续我们的发现吧！</p><h2 id="a982" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">碎片帐集</h2><p id="d7d1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">垃圾收集(GC)是Java和JavaScript中用于自动内存管理的技术。</p><p id="8b29" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在Java中，使用一个<code class="fe nr ns nt nu b">new</code>操作符来分配对象。</p><p id="3494" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">为了简化GC的工作机制，就像在后台编写了一个线程，它将在每个周期运行，以分析内存使用情况并尝试释放未使用的对象。</p><p id="038b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">一般来说，所有GC都关注两个领域:</p><ul class=""><li id="a51f" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">找出所有仍然存在或被使用的对象(标记可到达的对象)。</li><li id="8170" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">去掉其他所有东西——假定是死的和不用的对象(去掉不用的对象，或者清扫)。</li></ul><p id="05da" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">这个算法叫做<a class="ae of" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="noopener ugc nofollow" target="_blank">标记和扫描</a>。抓住你了。</p><p id="8d35" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">那么，从所有这些定义中我们能注意到什么:</p><ul class=""><li id="01e1" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">GC依赖于运行时，而不是编程语言。</li><li id="863e" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">实际上，执行周期是不规则的，可能以不确定的时间间隔发生:或者在经过一定时间后，或者当运行时发现可用内存变低时。</li><li id="d2d4" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">这意味着对象不一定在不再使用的时候被释放。</li><li id="51ba" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">当垃圾收集算法运行时，正常的程序执行被挂起，以便找到使用的程序并清除未使用的程序。</li></ul><p id="46f7" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">哇哦。不是很神奇吗！</p><p id="f167" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">说实话，我不喜欢GC就是因为这种不确定性。我更喜欢ARC方法和提前的方式，而不是运行时任务，️which可能会降低程序的执行速度。</p><h2 id="1d8d" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">垃圾收集与ARC</h2><p id="bcd2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">有了ARC，编译器会将代码注入到可执行文件中，跟踪对象引用计数，并在必要时自动释放对象，而不是让运行时在后台查找和处理未使用的对象。</p><blockquote class="og oh oi"><p id="9581" class="lq lr oj ls b lt mo ju lv lw mp jx ly ok nc mb mc ol nd mf mg om ne mj mk ml im bi translated">自动参考计数(ARC)。在编译时，它将在运行时增加和减少引用计数的消息retain和release插入到对象代码中，当对这些对象的引用数达到零时，标记这些对象的释放。ARC不同于跟踪垃圾收集，因为它没有后台进程在运行时异步释放对象。与跟踪垃圾收集不同，ARC不会自动处理引用周期。<a class="ae of" href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting#:~:text=ARC%20differs%20from%20tracing%20garbage,not%20handle%20reference%20cycles%20automatically." rel="noopener ugc nofollow" target="_blank">自动引用计数—维基百科</a></p></blockquote><p id="80fa" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">太神奇了！编译时就完成了。确定性销毁，即提前销毁，无需后台处理！</p><h2 id="1f73" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">内存管理与内存安全</h2><p id="8b9a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我想你开始意识到自动并不意味着安全:</p><ul class=""><li id="727c" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">如果GC迟到释放内存怎么办？</li><li id="7294" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">如果我们在GC(多线程)释放变量的同时使用它，会怎么样呢？</li><li id="d55c" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">如果ARC没有很好地管理保留周期怎么办？</li><li id="6eb3" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">临时数据呢？</li><li id="e7a6" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">全局变量呢？</li><li id="5dca" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">输入大小超过内存怎么办？</li></ul><p id="cf1a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">不幸的是，这些情况会导致许多内存问题，从而导致程序崩溃，有时还会违反安全性！</p><p id="9f36" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在大多数情况下，自动内存管理保证了一定程度的安全性，然而，这是不够的，我们将看到为什么。那么，让我们继续看看会出现什么样的内存问题，以及如何避免它们！</p><h1 id="4d39" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">内存冲突以及如何避免内存冲突</h1><h2 id="0f7a" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">记忆行话</h2><p id="098e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我们开始之前，这里有一些重要的记忆术语:</p><p id="3131" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated"><a class="ae of" href="https://en.wikipedia.org/wiki/Data_buffer" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu"> Buffer </strong> </a>是一个在等待其他东西处理数据或我们正在处理数据时临时存放信息的地方。例如，当输入来自键盘时，它被存储在输入缓冲区中，直到被应用程序读取和使用。</p><p id="4816" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated"><a class="ae of" href="https://learn.microsoft.com/en-us/cpp/cpp/pointers-cpp?view=msvc-170" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">指针</strong> </a>是存储对象内存地址的变量。</p><h2 id="2a25" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">缓冲区溢出</h2><p id="df62" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">啊哈，我想你知道这个众所周知的<a class="ae of" href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow" rel="noopener ugc nofollow" target="_blank">安全漏洞</a>！</p><blockquote class="og oh oi"><p id="d513" class="lq lr oj ls b lt mo ju lv lw mp jx ly ok nc mb mc ol nd mf mg om ne mj mk ml im bi translated">缓冲区溢出或缓冲区溢出是一种异常现象，程序在向缓冲区写入数据时，会超出缓冲区的边界并覆盖相邻的内存位置。<a class="ae of" href="https://en.wikipedia.org/wiki/Buffer_overflow" rel="noopener ugc nofollow" target="_blank">缓冲区溢出—维基百科</a></p></blockquote><p id="a7ff" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">换句话说，当程序试图将超过缓冲区容量的数据放入缓冲区时，或者当程序试图将数据放入缓冲区以外的内存区域时，就会发生缓冲区溢出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/1cf37950939d1711d4c7a1f2f5bbd8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBvknZchAelH74nz4uhBKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缓冲区溢出示例(图片由作者提供)</p></figure><p id="1491" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">啊，你明白我为什么说自动并不意味着安全了吧！</p><p id="7a89" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">缓冲区溢出漏洞可能出现在以下代码中:</p><ul class=""><li id="182d" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">依赖外部数据来控制其行为。</li><li id="f8be" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">依赖于在代码直接范围之外应用的数据属性。</li><li id="7e28" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">在C和C++中有许多不执行边界检查的内存操作函数，它可以很容易地覆盖它们所操作的缓冲区的分配边界。</li></ul><p id="43cf" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在已分配内存块的边界之外进行写入会损坏数据、使程序崩溃或导致恶意代码的执行。</p><p id="3b36" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">为了避免这种类型的违规，我们需要验证所有通过HTTP请求接受用户输入的代码，并确保它对所有这样的输入提供适当的大小和类型检查。</p><p id="6846" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">还建议在将数组索引用作数组的索引之前，验证数组索引是否在正确的范围内。</p><p id="ddd6" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">这个问题关系到所有的编程语言，不管是手动还是自动管理内存，因为这是由于它的编码方式(<code class="fe nr ns nt nu b"><a class="ae of" href="https://docs.oracle.com/javase/7/docs/api/java/nio/BufferOverflowException.html" rel="noopener ugc nofollow" target="_blank">BufferOverflowException</a></code>、<code class="fe nr ns nt nu b"><a class="ae of" href="https://docs.oracle.com/javase/6/docs/api/java/lang/ArrayIndexOutOfBoundsException.html" rel="noopener ugc nofollow" target="_blank">ArrayIndexOutOfBoundsException</a></code>、<code class="fe nr ns nt nu b"><a class="ae of" href="https://docs.oracle.com/javase/6/docs/api/java/lang/IndexOutOfBoundsException.html" rel="noopener ugc nofollow" target="_blank">IndexOutOfBoundsException</a></code>)。</p><p id="4cd9" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">仅供参考，还有一个缓冲区问题:<a class="ae of" href="https://cwe.mitre.org/data/definitions/126.html" rel="noopener ugc nofollow" target="_blank">缓冲区过度读取</a>，在读取一个缓冲区时发生，使程序越过缓冲区限制，读取相邻内存。</p><h2 id="97c6" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">零解引用</h2><p id="1ff4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当使用空指针时，空指针解引用发生，就好像指向一个有效的内存区域。</p><p id="0a61" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">不应将空指针与未初始化的指针相混淆:</p><ul class=""><li id="402b" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">未初始化的变量是在使用前声明但未设置为已定义的已知值的变量。</li><li id="8444" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">空指针是不指向任何内存位置的指针(不指向任何东西)。它存储数据段的基址。</li></ul><p id="2619" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">空指针取消引用可能会发生:</p><ul class=""><li id="691e" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">当程序在调用一个函数后不检查错误，而该函数失败时会返回一个空指针。</li><li id="4dcf" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">当程序不能正确预测或处理在软件正常运行期间很少发生的异常情况时。</li><li id="a607" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">通过一些缺陷，包括竞争条件和简单的编程遗漏。</li></ul><p id="10ab" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在C #中，取消引用空指针是未定义的行为。在Java中，访问空引用会触发一个<a class="ae of" href="https://docs.oracle.com/javase/10/docs/api/java/lang/NullPointerException.html" rel="noopener ugc nofollow" target="_blank"> NullPointerException </a>。</p><p id="30e4" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">为了避免这种类型的违规:</p><ul class=""><li id="c654" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">在使用指针之前，请确保它不等于NULL。</li><li id="8b26" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">释放指针时，请确保它们没有设置为NULL。一旦它们被释放，一定要将它们设置为NULL。</li><li id="ae13" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">当使用多线程或异步环境时，确保在if语句之前使用正确的锁定API进行锁定；并在完成后解锁。</li><li id="14e4" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">在Java中，<a class="ae of" href="https://docs.oracle.com/javase/10/docs/api/java/lang/NullPointerException.html" rel="noopener ugc nofollow" target="_blank"> NullPointerException </a>可以被错误处理代码捕获，但是最好的做法是确保这种异常永远不会发生。</li><li id="c1de" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">使用<a class="ae of" href="https://en.wikipedia.org/wiki/Defensive_programming" rel="noopener ugc nofollow" target="_blank">防御编程</a>方法。</li></ul><p id="dcd8" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">对于范<a class="ae of" href="https://www.cybersecurity-help.cz/vulnerabilities/8953/" rel="noopener ugc nofollow" target="_blank">Google Chrome和Google Chrome(cyber security-help . cz)</a>中的空指针解引用。</p><h2 id="3907" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">悬空指针和百搭指针</h2><p id="2e57" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">你听说过使用DOM插件数组的<a class="ae of" href="https://www.mozilla.org/en-US/security/advisories/mfsa2010-51/" rel="noopener ugc nofollow" target="_blank">悬空指针漏洞— Mozilla </a>和nsTreeSelection — Mozilla 中的<a class="ae of" href="https://www.mozilla.org/en-US/security/advisories/mfsa2010-54/" rel="noopener ugc nofollow" target="_blank">悬空指针漏洞吗？</a></p><blockquote class="og oh oi"><p id="3134" class="lq lr oj ls b lt mo ju lv lw mp jx ly ok nc mb mc ol nd mf mg om ne mj mk ml im bi translated">安全研究员Sergey Glazunov报告了一个在<code class="fe nr ns nt nu b"><em class="it">navigator.plugins</em></code>实现中的悬空指针漏洞，其中<code class="fe nr ns nt nu b"><em class="it">navigator</em></code>对象可以保留一个指向插件数组的指针，即使它已经被破坏。</p><p id="d665" class="lq lr oj ls b lt mo ju lv lw mp jx ly ok nc mb mc ol nd mf mg om ne mj mk ml im bi translated">攻击者可能会利用此问题使浏览器崩溃，并在受害者的计算机上运行任意代码。<a class="ae of" href="https://bugzilla.mozilla.org/show_bug.cgi?id=584512&amp;_gl=1*acfhw8*_ga*MjI4Mjc3NzYxLjE2NjQxMDY5ODk.*_ga_MQ7767QQQW*MTY2NDE4NzM0MC4xLjAuMTY2NDE4NzM0MC4wLjAuMA.." rel="noopener ugc nofollow" target="_blank">584512—(CVE-2010–2767)nsPluginArray—内存损坏(mozilla.org)</a></p></blockquote><p id="bea2" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">当引用对象被删除或释放并且指针仍然指向内存位置时，悬空指针出现。这就产生了一个问题，因为指针指向了不可用的内存。哎呀！</p><p id="5e63" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在第一次使用之前没有正确初始化的指针(甚至不是空的)称为通配符指针。未初始化指针的行为是完全未定义的，因为它可能指向某个任意位置，这可能是程序崩溃的原因。所以叫野指针。OMG！</p><p id="7751" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">使用C++编写JavaScript引擎时会出现这些问题(Rust for Firefox实际版本)。</p><p id="3fe6" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">使用自动内存管理机制(GC或ARC)大大降低了遇到这些指针问题的可能性，但这并不能防止内存泄漏，我们将在下面看到这一点。让我们继续前进！</p><h1 id="e7b7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">堆栈溢出</h1><p id="b46b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你在浏览器中使用JavaScript，我想你至少遇到过一次这个错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/5b3251e0218c4651612b9ce2c5324421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AgYpY0a70GX6AcPalwTw2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JavaScript堆栈溢出—超出了最大调用堆栈大小(图片由作者提供)</p></figure><p id="7d8b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">此错误通常发生在递归调用中，并指示已超过最大堆栈大小:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/7491f6bbf5eeadecc0362b89d5b9e9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmpXtchLdDApxYh_Dtd-DA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调用堆栈溢出(图片由作者提供)</p></figure><p id="0c73" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">这里GC也没有帮助，因为每次迭代都引用前一次！</p><p id="953b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">这个问题并不是针对<a class="ae of" href="https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch8.md" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>的，而是针对所有没有<a class="ae of" href="https://exploringjs.com/es6/ch_tail-calls.html" rel="noopener ugc nofollow" target="_blank">尾调用优化</a>机制的编程语言。</p><p id="a306" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">尾调用是指一个函数的最后一条语句是对另一个函数的调用。优化在于让尾部调用函数替换它在堆栈中的父函数。这样，递归函数不会增加堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/2b3c436c25f8f5e7c535928b48e0945a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3HYC2MEmaU-OCXqHA_gYBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尾部调用优化(图片由作者提供)</p></figure><p id="3548" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">现在的问题是，如果语言默认不实现尾调用优化(TCO)，该怎么办？</p><p id="9270" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">嗯，在这种情况下，有一个神奇的模式可以帮助我们，它可以应用于所有语言，以接近地模仿TCO的行为:<a class="ae of" href="https://en.wikipedia.org/wiki/Trampoline_(computing)" rel="noopener ugc nofollow" target="_blank">蹦床</a>模式。</p><p id="8593" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">一个<code class="fe nr ns nt nu b">trampoline</code>函数在一个循环中包装了我们的递归函数。在引擎盖下，它一段一段地调用递归函数，直到不再产生递归调用:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="09d1" class="nf kz it nu b gy nz oa l ob oc">// Trampoline <br/>const Trampoline = fn =&gt; (...args) =&gt; {<br/>  let result = fn(...args)<br/>  while (typeof result === 'function') {<br/>    result = result()<br/>  }<br/>  return result<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/062cd9e979b8ea7569de52d5842f91ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ydm8t2ZZqLwguZUo.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae of" href="https://www.uraimo.com/2016/05/05/recursive-tail-calls-and-trampolines-in-swift/" rel="noopener ugc nofollow" target="_blank">uraimo.com Swift中的递归尾调用和蹦床</a></p></figure><p id="5d92" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">有了Trampoline，我们对普通的递归算法几乎没有任何改变(非TCO！)，但是我们完全跳过了调用栈的构建。这只是一个新的工具！</p><p id="0762" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">一个奇妙的图案！</p><h1 id="75d4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">内存不足(OOM)</h1><p id="e762" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当堆中没有足够的空间来分配对象，并且堆无法进一步扩展时，会出现此错误。这种情况，GC帮不上忙！</p><p id="61be" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">OOM错误通常意味着程序做错了什么，例如:</p><ul class=""><li id="0b1c" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">抓着东西太久</li><li id="ddb9" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">试图一次处理太多数据</li><li id="008b" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">有许多全局变量(函数和变量中的一个问题)</li></ul><p id="587a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">例如，在JavaScript中，直接指向根(全局或窗口)的引用总是活动的(已使用)，GC不能清除它们！</p><p id="6489" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">那么，我们能做些什么来避免OOM呢？让我们看看！</p><p id="83e8" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">为了处理大量数据，</p><ul class=""><li id="b721" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">对于使用Node JS的后端应用程序，我们可以使用<a class="ae of" href="https://nodejs.org/api/stream.html" rel="noopener ugc nofollow" target="_blank">流</a>和分页、<a class="ae of" href="https://www.mongodb.com/docs/manual/geospatial-queries/" rel="noopener ugc nofollow" target="_blank">地理空间查询</a>。</li><li id="c24b" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">对于使用JavaScript和React的前端应用程序，我们可以使用一些技术，如<a class="ae of" href="https://reactjs.org/docs/optimizing-performance.html#virtualize-long-lists" rel="noopener ugc nofollow" target="_blank">窗口</a>或分页。</li><li id="342a" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">一般来说，强烈建议采用这些原则:按需处理，按需显示，在开始时我们只加载和处理必要的东西(懒惰评估)。</li></ul><p id="0e6a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">为了避免<a class="ae of" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Strong_and_weak_references" rel="noopener ugc nofollow" target="_blank">强引用</a>，在利用这些API之前先试试:<a class="ae of" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"> WeakMap </a>、<a class="ae of" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet" rel="noopener ugc nofollow" target="_blank"> WeakSet </a>、<a class="ae of" href="https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html" rel="noopener ugc nofollow" target="_blank"> WeakHashMap </a>。</p><p id="d76a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">为了缓存数据，我们可以采用一种机制，例如<a class="ae of" href="https://github.com/isaacs/node-lru-cache" rel="noopener ugc nofollow" target="_blank"> LRU </a>(最近最少使用的)，通过设置我们想要保留的最近使用的项目的最大数量。</p><p id="e268" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">为了获取函数和变量，我们可以采用<a class="ae of" href="https://medium.com/p/fdc07b4b1084" rel="noopener">函数式编程</a>方法。对于JavaScript，我们应该尽可能避免全局变量、窗口和全局侦听器。</p><h2 id="0cdd" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">内存泄漏</h2><blockquote class="og oh oi"><p id="f0e3" class="lq lr oj ls b lt mo ju lv lw mp jx ly ok nc mb mc ol nd mf mg om ne mj mk ml im bi translated">虽然GC有效地处理了很大一部分内存，但它不能保证内存泄漏的解决方案万无一失。GC相当智能，但并非完美无缺。内存泄漏仍然会悄悄出现。内存泄漏是Java中真正的问题。<a class="ae of" href="https://www.baeldung.com/java-memory-leaks" rel="noopener ugc nofollow" target="_blank">了解Java | Baeldung中的内存泄漏</a></p></blockquote><p id="95b5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">我喜欢这个解释。它总结了我想在本文中解释的一切:GC很重要，但还不够。我们不应该依赖GC来为我们清理一切，但是我们应该帮助它做好自己的工作！</p><p id="5052" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">我想您会对我们在有GC的情况下仍然会遇到内存泄漏感到惊讶。我们一起来看看吧！</p><p id="e01d" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">内存泄漏是指堆中的对象不再被使用，但垃圾收集器无法将它们从内存中移除。因此，没有必要维护它们。什么时候出现这种情况？</p><p id="af69" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在Java中，内存泄漏可能由于以下原因而发生:</p><ul class=""><li id="c4cf" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">静态变量</li><li id="6e5e" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">未关闭的资源(建立新连接或打开流)</li><li id="38af" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">每当一个类的方法被覆盖时，该类的对象不会立即被垃圾回收。取而代之的是，GC将它们排队等待在稍后的时间点完成</li><li id="e40a" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">当使用这个<a class="ae of" href="https://www.baeldung.com/java-memory-leaks#7-using-threadlocals" rel="noopener ugc nofollow" target="_blank"> ThreadLocal </a>时，每个线程将持有一个对其ThreadLocal变量副本的隐式引用。只要线程是活动的，它将维护自己的副本，而不是在多个线程之间共享资源</li></ul><p id="7a25" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在JavaScript中，出现内存泄漏的原因可能是:</p><ul class=""><li id="a77f" class="mm mn it ls b lt mo lw mp lz mq md mr mh ms ml mt mu mv mw bi translated">未声明的或意外的全局变量</li><li id="a9d0" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">忘记了<code class="fe nr ns nt nu b">setTimeout</code>和<code class="fe nr ns nt nu b">setInterval</code></li><li id="08af" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">脱离DOM引用或分离的节点:已经从DOM中移除但在内存中仍然可用的节点</li><li id="824e" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">未清除的DOM事件侦听器</li><li id="085f" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">WebSocket订阅和对API的请求</li><li id="de24" class="mm mn it ls b lt mx lw my lz mz md na mh nb ml mt mu mv mw bi translated">如果在卸载组件后更新状态，执行状态更新和运行异步操作的React组件可能会导致内存泄漏问题。</li></ul><p id="9729" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">哇！知道JS和Java内存管理使用垃圾收集真是太可怕了！</p><h2 id="c76f" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">多线程和竞争条件</h2><p id="aa87" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在各种并行编程模型中，进程/线程共享一个公共地址空间，它们异步地读写该空间。在这种模式下，所有进程对共享内存都有同等的访问权。</p><p id="29b7" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">当两个线程使用共享内存数据访问同一个变量，并且至少有一个线程执行写操作时，共享内存程序中就会出现争用情况。访问是并发的，因此它们可以同时发生。</p><p id="80ba" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">作为信息，几个线程尝试读取一个共享资源是安全的，只要它们不尝试修改它。</p><p id="103a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">构成多处理环境的所有系统都容易受到竞争条件攻击！</p><p id="4415" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">在竞争情况下，共享内存可能会被线程破坏。</p><p id="67ca" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">诸如锁(<a class="ae of" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html" rel="noopener ugc nofollow" target="_blank">同步</a>)和<a class="ae of" href="https://en.wikipedia.org/wiki/Semaphore_(programming)" rel="noopener ugc nofollow" target="_blank">信号量</a>之类的各种机制可以用来控制对共享存储器的访问。</p><p id="f7ff" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">Java提供了几种<a class="ae of" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html" rel="noopener ugc nofollow" target="_blank">数据结构</a>，允许并发访问:<code class="fe nr ns nt nu b"><a class="ae of" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html" rel="noopener ugc nofollow" target="_blank">DelayQueue</a></code>、<code class="fe nr ns nt nu b"><a class="ae of" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html" rel="noopener ugc nofollow" target="_blank">BlockingQueue</a></code>、<code class="fe nr ns nt nu b"><a class="ae of" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html" rel="noopener ugc nofollow" target="_blank">ConcurrentMap</a></code>、<a class="ae of" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" rel="noopener ugc nofollow" target="_blank"> ConcurrentHashMap </a>。</p><h1 id="73f1" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="ffcc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">多么美好的记忆之旅啊！非常有教育意义！</p><p id="c51e" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">我们看到了一个程序的内存是如何布局和管理的:通过ARC或GC手动或自动管理。</p><p id="c548" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">我们已经看到，自动管理内存很重要，但还不够。甚至在GC运行时也会出现一些内存问题。</p><p id="bbf8" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">缓冲区溢出、缓冲区过度读取、空解引用、悬空和通配符指针、堆栈溢出和内存不足(OOM)是所有编程语言的例外。它们更多地与“不安全”的编码缺陷有关，而不是编程语言或运行时的内部问题。</p><p id="df27" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">最重要的建议是在编写代码时采取防御性的方法。一个程序应该能够正常运行，即使是在不可预见的过程中，或者是在意外进入时。</p><p id="776a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">这就是这次旅行的所有人。快乐阅读！</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="ec3e" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz nc mb mc md nd mf mg mh ne mj mk ml im bi translated">感谢您阅读我的文章。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="18bc" class="nf kz it nu b gy nz oa l ob oc"><strong class="nu iu">Want to Connect?</strong></span><span id="5ee9" class="nf kz it nu b gy od oa l ob oc">You can find me at GitHub: <a class="ae of" href="https://github.com/helabenkhalfallah" rel="noopener ugc nofollow" target="_blank">https://github.com/helabenkhalfallah</a></span></pre></div></div>    
</body>
</html>