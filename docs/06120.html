<html>
<head>
<title>How to Implement Logging in Your Python Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python应用程序中实现日志记录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-logging-in-your-python-application-1730315003c4?source=collection_archive---------3-----------------------#2020-09-03">https://betterprogramming.pub/how-to-implement-logging-in-your-python-application-1730315003c4?source=collection_archive---------3-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6756" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">实现日志记录的实用指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b97e840f90a2879166fbce78d539f710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uVSR4mzyr6gZFW1N"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Emile Perron 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="3faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我开始构建一个Python应用程序来查询PostgreSQL数据库，处理数据，并将后续的触发事件推送到Kafka队列。然而，在处理有趣的方面之前，我知道我需要把基础做好。任何应用程序的基础之一就是日志记录！</p><p id="31d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将解释Python中日志记录的一些关键特性，更重要的是，演示如何在我的应用程序中实现一个日志记录器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/e32d6920e3f6ce0f5b3831fdd62f25ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llTOHTqixbW3jHvH1V4GJA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">连接到PostgreSQL时的错误日志示例—来自作者的图片。</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="422b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">打印(为什么不呢？)</h1><p id="1b6c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">要解决的第一个问题是:为什么不直接使用<code class="fe mx my mz na b">print()</code>？很容易走捷径，在代码中添加<code class="fe mx my mz na b">print</code>语句。我们都写过类似这样的代码:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4f0b" class="nf mb iq na b gy ng nh l ni nj">print("Getting some docs...")<br/>docs = getDocs()<br/>print("Doc count %s", len(docs))<br/>print("Finished")</span></pre><p id="61d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，这对于小脚本或者在开发或调试过程中需要快速而简单的东西是很好的。然而，<code class="fe mx my mz na b">print()</code>对于较大的应用程序来说并不是一个可行的日志解决方案——尤其是如果您计划将您的代码推广到生产环境中。</p><p id="fabd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来谈谈应该避免使用<code class="fe mx my mz na b">print</code>的几个原因。首先，它只给你登陆<code class="fe mx my mz na b">stdout</code>的选项。如果您正在记录大量数据，这将是一个问题。实际上，您希望将日志写在一个易于保存、备份和日后查询的地方。另一个原因是<code class="fe mx my mz na b">print</code>语句在运行时不可配置。要打开/关闭特定的日志，您需要每次都修改您的代码。这意味着每当您需要打开调试日志记录时，都要将您的代码重新部署到生产环境中！除此之外，包含有价值的信息和上下文也更加困难，比如行号和日志消息生成的时间。</p><p id="9f9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我可以继续，但希望你已经被说服了！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="067d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">进入Python的日志模块</h1><p id="408c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">幸运的是，日志的重要性并不是一个新现象。Python附带了一个现成的日志记录解决方案，作为Python标准库的一部分。使用<code class="fe mx my mz na b">print</code>解决了前面提到的所有问题。例如:</p><ul class=""><li id="87c0" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">自动向日志添加上下文，如行号和时间戳。</li><li id="fc62" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">通过向应用程序传递一个配置文件，可以在运行时更新我们的日志。</li><li id="4905" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">很容易定制日志严重性，并为不同的环境配置不同的日志记录级别</li></ul><p id="25d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试一下，并设置一个非常基本的记录器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f372" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行该程序会得到:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0825" class="nf mb iq na b gy ng nh l ni nj">INFO:__main__:Getting some docs...<br/>INFO:__main__:Doc count 2<br/>INFO:__main__:Finished</span></pre><p id="78d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单！</p><p id="5ba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们从Python标准库中导入了日志模块。然后我们更新了默认的基本日志级别来记录<code class="fe mx my mz na b">INFO</code>消息。接下来，<code class="fe mx my mz na b">logger = logging.getLogger(__name__)</code>实例化我们的日志记录实例。最后，我们通过调用<code class="fe mx my mz na b">logger.info("")</code>将一个事件传递给日志级别为<code class="fe mx my mz na b">INFO</code>的日志记录器。</p><p id="edef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，这个输出可能与使用<code class="fe mx my mz na b">print()</code>非常相似。接下来，我们将扩展我们的示例日志记录器，以展示Python标准日志记录模块提供的一些更强大的特性。</p><h2 id="634d" class="nf mb iq bd mc oa ob dn mg oc od dp mk lf oe of mm lj og oh mo ln oi oj mq ok bi translated">日志级别</h2><p id="7c3e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们可以配置输出日志的严重性，过滤掉不重要的日志。该模块定义了整个频谱中的五个常数，使得区分消息变得容易。下表给出了日志记录级别的数值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ace54e7eabd6e730faa98add2fb8017d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*ZNusVhklnUTnEAPBPkKAtw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://docs.python.org/3/library/logging.html#logging-levels" rel="noopener ugc nofollow" target="_blank"> Python文档</a>的日志级别。</p></figure><p id="8e45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是不要用大量的消息淹没你的日志。为了获得简洁的日志，我们应该小心地为每个事件定义正确的日志级别:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="c400" class="nf mb iq na b gy ng nh l ni nj">logger.critical("Really bad event"<!-- -->)<br/>logger.error("An error")<br/>logger.warning("An unexpected event")<br/>logger.info("Used for tracking normal application flow")<br/>logger.debug("Log data or variables for developing")</span></pre><p id="3e2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我倾向于使用调试级别来记录在应用程序中传递的数据。下面是在负责向Kafka发送事件的几行代码中使用三种不同日志级别的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="7d67" class="nf mb iq bd mc oa ob dn mg oc od dp mk lf oe of mm lj og oh mo ln oi oj mq ok bi translated">格式化日志</h2><p id="4f09" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Python日志模块的默认格式化程序不提供大量细节。幸运的是，很容易配置日志格式来添加我们需要的所有上下文，以生成非常有用的日志消息。</p><p id="c77d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们在这里向日志消息添加了时间戳和日志级别:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="75ea" class="nf mb iq na b gy ng nh l ni nj">formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')</span></pre><p id="6e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最佳实践是在日志中添加尽可能多的上下文。这可以通过向日志消息的元数据中添加结构化数据来轻松实现。例如，您可能已经扩展了您的应用程序，以便与多个工作人员一起运行。在这种情况下，在您进行调试时，知道哪个worker正在记录每个事件可能很重要，因此让我们向日志元数据添加一个worker ID上下文:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="52e1" class="nf mb iq na b gy ng nh l ni nj"># Create the log formatter</span><span id="c3e8" class="nf mb iq na b gy om nh l ni nj">formatter = <!-- -->logging.Formatter(<!-- -->'%(asctime)s - %(worker)s %(levelname)s - %(message)s')<br/>handler.setFormatter(formatter)</span><span id="cec0" class="nf mb iq na b gy om nh l ni nj">logger.info('Querying database for docs...', extra={'worker': <br/>'id_1'})</span></pre><p id="a625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出变成:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="a22b" class="nf mb iq na b gy ng nh l ni nj">2020-09-02 22:06:18,170 - id_1 - INFO - Querying database for docs...</span></pre><h2 id="c74d" class="nf mb iq bd mc oa ob dn mg oc od dp mk lf oe of mm lj og oh mo ln oi oj mq ok bi translated">日志处理程序</h2><p id="a63e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">既然我们已经有了来自应用程序代码各处的格式完美的日志，我们需要考虑这些日志的最终位置。默认情况下，日志被写到<code class="fe mx my mz na b">stdout</code>，但是Python的日志模块为我们提供了将日志推到其他位置的功能。例如，将日志保存到磁盘上的<code class="fe mx my mz na b">example.log</code>文件:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="0996" class="nf mb iq na b gy ng nh l ni nj"># create a file handler<br/>handler = logging.FileHandler('example.log')<br/>handler.setLevel(logging.INFO)</span></pre><p id="1ca6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几种类型的处理程序可以使用。有关完整列表，参见处理程序的<a class="ae kv" href="https://docs.python.org/3/library/logging.handlers.html#module-logging.handlers" rel="noopener ugc nofollow" target="_blank">文档。还可以为不同的用例定义定制的日志处理程序。例如，</a><a class="ae kv" href="https://pypi.org/project/slacker-log-handler/" rel="noopener ugc nofollow" target="_blank">这个库</a>定义了一个日志处理器，用于将日志推送到Slack！</p><p id="0eba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总结一下。我们已经设置了Python标准日志模块，并将其配置为使用定制的日志格式记录到不同的位置。您可以在下面找到示例记录器的最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ce55" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">履行</h1><p id="a408" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">到目前为止，您应该对Python日志模块的一些关键特性有了很好的了解。这很好，但是您应该如何实现所有这些不同的配置并管理应用程序文件中日志模块的导入呢？这是很多导游经常忽略的一点。以下是我决定如何处理它。</p><p id="4e96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我决定将所有日志配置提取到一个名为<code class="fe mx my mz na b">logging.ini</code>的配置文件中。你可以在<a class="ae kv" href="https://docs.python.org/3/library/logging.config.html#configuration-file-format" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到所有你需要的关于如何格式化日志文件的信息，所以我不会在这里一一赘述。目前我的<code class="fe mx my mz na b">logging.ini</code>超级基础。当应用程序停止开发并准备部署时，我将扩展日志记录配置以处理不同的环境，在磁盘上循环日志，并向Slack通道发送警报。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从代码的角度来看，这确实简化了实现，因为设置日志处理程序和格式化程序所需的样板文件要少得多。上面，我们有15行代码设置了一个格式化程序和一个处理程序。很容易想象，随着用例越来越复杂，这个数字会变得更大。现在，所有的复杂性都被抽象到配置文件中了。结果是:要实现你的记录器，你只需要在你的应用程序中增加两行代码！</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4b2e" class="nf mb iq na b gy ng nh l ni nj">import logging.config</span><span id="ca0c" class="nf mb iq na b gy om nh l ni nj">logging.config.fileConfig(fname='logger.ini')</span></pre><p id="d495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相当整洁！但是这段代码应该放在哪里呢？</p><p id="b362" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的应用程序以一个<code class="fe mx my mz na b">__main__.py</code>作为入口点。我决定在这个文件中实现我的日志记录器，以便不影响包含在<code class="fe mx my mz na b">app.py</code>中的主要功能。下面的<code class="fe mx my mz na b">__main__.py</code>将处理读取配置文件并将配置应用到您的记录器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6bc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要通过发射一些日志来利用我们的创造！但是这些消息不会由<code class="fe mx my mz na b">__main__</code>函数生成，那么我们应该如何处理将我们的日志程序传递给应用程序中的其他文件和函数呢？</p><p id="add7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这又变得微不足道了。要在另一个文件中使用logger，我们只需要导入日志模块并实例化它。它将自动继承我们在<code class="fe mx my mz na b">__main__</code>中传递给它的配置。例如，要开始在<code class="fe mx my mz na b">app.py</code>中记录消息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="96eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的调试信息将根据从<code class="fe mx my mz na b">logging.ini</code>读取的日志配置进行处理。对于应用程序中的其他Python文件也是如此，只要你在顶层使用<code class="fe mx my mz na b">import logging</code>。是的，真的就这么简单！</p><p id="2c48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，您不仅看到了使Python的日志模块成为您军械库中一个令人敬畏的工具的一些特性，而且还看到了它是如何容易实现的。</p><p id="6816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。我希望这个指南对你有用。伐木快乐！</p></div></div>    
</body>
</html>