<html>
<head>
<title>How to Write Generic Helper Functions With Go 1.18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Go 1.18编写通用助手函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-generic-helper-functions-with-go-d47c52986016?source=collection_archive---------8-----------------------#2022-05-09">https://betterprogramming.pub/how-to-write-generic-helper-functions-with-go-d47c52986016?source=collection_archive---------8-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4de3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">检查数组/切片中是否存在元素的通用方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d54ad8e8a5fd924b7ba93c3d3e6a9a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEKJxwTIECUccHm_lqdBKA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">地鼠是由埃贡·厄尔布尔画的。</p></figure><p id="3352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几天前，我需要检查一个数组是否包含特定的值。通常这是一个简单的任务，你可以使用编程语言本身的预定义函数。在围棋中，很不幸，你得自己创造。但是不用担心。今天我们将构建一个函数来检查数组中是否存在元素。所以系好安全带，我们走吧。</p><h1 id="03f1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍</h1><p id="e36d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">开始前还有最后一件事。在我们的解决方案中我们需要泛型。因此，我们至少需要使用Golang版本。幸运的是，Golang在几周前发布了正式版1.18，其中包含了泛型🙌。</p><h1 id="da1a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">方法</h1><p id="20dd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们的意图应该是明确的。那么我们的目标是什么？这很简单。我们需要一个函数，它被传递一个数组和一个值，如果数组包含值，则返回true，如果值缺失，则返回false。</p><h1 id="605d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">解决办法</h1><p id="8505" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一种解决方案是创建一个函数，在其中静态地设置属性类型。在函数中，我们简单地迭代数组，看看数组中是否有值等于我们的元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="264d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它工作正常。我们对这种方法只有一个问题。想象一下，对于许多不同类型的数组，我们需要检查数组是否包含值。为了存档，我们需要为每种类型创建一个新的函数。这导致了非常冗长和重复的代码库。幸运的是，Golang在几个月前引入了许多不同的泛型类型。在下一章中，我们可以使用其中的一个来使我们的解决方案更加灵活。</p><h1 id="baf4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">丰富</h1><p id="0f35" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于我们的用例，我们需要“可比的”泛型类型。<br/> <em class="mr">(如果想了解更多关于仿制药的知识，我可以推荐以下</em> <a class="ae kv" href="https://bitfieldconsulting.com/golang/generics" rel="noopener ugc nofollow" target="_blank"> <em class="mr">篇</em> </a> <em class="mr">。)</em>正如您在下面看到的，我们需要将泛型T的名字写在函数名后面的括号中，并将它的类型指定为“comparable”。我们也给两个参数t类型。这样，当我们调用函数时，我们可以指定我们想要比较的数组和元素的类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4a92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用它，我们必须进行以下函数调用:<br/> <code class="fe ms mt mu mv b">Contains[string](["bar", "foo"], "foo")</code>。</p><p id="d234" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">括号前的括号中的单词“string”是我们指定数组和值的类型的地方。</p><h1 id="1a5c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基准</h1><p id="4d3a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们有两种不同的解决方案。一种是在函数中设置两个参数的类型。另一个是在函数调用中设置类型。但是哪种解决方案性能更好呢？这种差异明显吗？</p><p id="2f80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简化泛型，您可以将它们视为一种易于使用的反射。通常，这会导致这两个函数之间的性能差异。但是让我们看看:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="fddd" class="na lt iq mv b gy nb nc l nd ne">go test -bench=”BenchmarkContains” -run=^# -benchtime=10000x</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/f41ecad5a194c8b5a10915d796611618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnDaYpy2W689msXLpuC1Dw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基准包含函数</p></figure><p id="fa61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了获得更有意义的结果，我决定编写表基准测试。上述命令将两个测试运行10.000次。结果是显著的。通用版本没有时间问题。从上面的图片中可以看出，两个测试每次操作花费的时间基本相同。</p><h1 id="2798" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的想法</h1><p id="513b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我希望检查一个数组是否包含某个值的方法是有趣且有帮助的。如果你有其他的解决方案，一些要提及的事情或者问题，如果你能在评论中留下来，那就太好了。回头见。</p><p id="59f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PS: 这是我策划的一个新系列的第一篇文章。在接下来的几周里，我将会关注围棋世界中的各种通用助手函数、有趣的基准和有用的特性。</p></div></div>    
</body>
</html>