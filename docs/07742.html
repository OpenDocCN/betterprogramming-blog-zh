<html>
<head>
<title>GitHub Actions In Action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub行动在行动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/github-actions-in-action-3b10083cc700?source=collection_archive---------5-----------------------#2021-02-15">https://betterprogramming.pub/github-actions-in-action-3b10083cc700?source=collection_archive---------5-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GitHub动作自动化构建、测试、通知和部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9dfadfbd07e9e6cf5d014f3071e860df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Agtv-SaM-zw_GLzPI7p5w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub动作组件以及它们之间的关系。使用的任何图片都是自画的，与GitHub没有任何关系。</p></figure><p id="a4c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有没有厌倦过必须运行bash脚本或makefiles来执行重复的日常任务——运行测试、构建？对于一个小型的家庭项目来说，你是否觉得建立一个CI/CD有点过了？<br/>你不应该有这种感觉——使用GitHub Actions非常简单。</p><p id="70fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GitHub Actions允许用户在GitHub上执行大量的操作，比如部署到AWS、Terraform，如果提交破坏了任何测试，给开发人员发电子邮件，等等！GitHub Actions允许我们非常容易地运行CI/CD，并且不需要太多的先验知识。</p><p id="9deb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不熟悉CI/CD这个术语，我建议你读一下<a class="ae lu" href="https://towardsdatascience.com/what-is-cicd-where-is-it-in-2020-c3298c2802ff" rel="noopener" target="_blank">什么是CI/CD？由</a><a class="lv lw ep" href="https://medium.com/u/c35b3d4694a2?source=post_page-----3b10083cc700--------------------------------" rel="noopener" target="_blank">默罕默德·艾哈迈德</a>撰写。</p><p id="c6de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将把GitHub动作付诸实践，并对它们进行测试。我们将建立一个使用GitHub动作的示例库，我们将尝试推送以查看效果。我还将展示更高级的案例，我们可以在GitHub动作中设置Docker容器。</p><p id="4d88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">过去，我曾经为我参与的每个项目创建一个makefile文件。makefile有许多可能的选项:构建项目、测试项目等等。我在makefile中还有复杂的任务，这些任务将SSH到多个服务器并部署应用程序。维护这些makefiles是一项艰苦的工作，感觉从来都不好。</p><p id="9989" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近偶然看到<a class="ae lu" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>，我很惊讶。它们让我们能够基于特定事件自动执行操作。我已经开始在我的每个项目中实施它。这些事件可以是像将提交推送到存储库、分叉、拉请求或调度之类的事情。</p><p id="34a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢pull request事件，当人们向存储库发出pull请求时，我们可以让它对新代码运行所有的单元测试。</p><blockquote class="lx ly lz"><p id="b779" class="ky kz ma la b lb lc ju ld le lf jx lg mb li lj lk mc lm ln lo md lq lr ls lt im bi translated">GitHub动作帮助您在软件开发生命周期中自动化任务。GitHub动作是事件驱动的，这意味着您可以在特定事件发生后运行一系列命令。—github.com</p></blockquote><p id="0ecd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更棒的是<strong class="la iu"> GitHub动作对所有GitHub用户都是免费的，甚至是免费账号</strong>。唯一的例外是私有存储库。</p><p id="b169" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你仍然不相信GitHub动作适合你，别忘了去看看<a class="ae lu" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank">动作市场</a>。是的，他们确实为我们提供了预构建的配置来执行几乎任何操作！</p><h2 id="3f62" class="me mf it bd mg mh mi dn mj mk ml dp mm lh mn mo mp ll mq mr ms lp mt mu mv mw bi translated">让我们回顾一下GitHub的动作以及它们是如何工作的</h2><p id="158d" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在我们开始工作之前，有几个词我们需要理解。所有的GitHub动作都是从一个事件开始的。事件是某些触发器，告诉GitHub执行配置的动作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/4cab4a7fa7998c97ab82f653c94664b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*4DeHJxqt-0A3pInbhzWjNA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事件，告诉GitHub运行我们的操作的触发器。</p></figure><p id="dace" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以收听许多活动，完整列表可以在<a class="ae lu" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank"> GitHub文档</a>中找到。为了让您了解可用的事件，下面是一些常见的事件:</p><ul class=""><li id="7fb0" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated"><code class="fe nm nn no np b">Push</code> —当用户推入分支时触发</li><li id="4f5e" class="nd ne it la b lb nq le nr lh ns ll nt lp nu lt ni nj nk nl bi translated"><code class="fe nm nn no np b">Pull_request</code> —当存储库收到<code class="fe nm nn no np b">pull_request</code>时触发。可以指定只匹配某些类型的<code class="fe nm nn no np b">pull_request</code>如打开的等。</li><li id="fd26" class="nd ne it la b lb nq le nr lh ns ll nt lp nu lt ni nj nk nl bi translated"><code class="fe nm nn no np b">Fork </code> —每当资料库分叉时触发。</li><li id="f9c1" class="nd ne it la b lb nq le nr lh ns ll nt lp nu lt ni nj nk nl bi translated"><code class="fe nm nn no np b">Issues</code> —当问题发生变化时触发。可以指定为匹配某些类型，如打开、关闭等。</li><li id="d5b1" class="nd ne it la b lb nq le nr lh ns ll nt lp nu lt ni nj nk nl bi translated"><code class="fe nm nn no np b">Release </code> —在存储库上创建发布时触发。</li></ul><p id="3cb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事件侦听器是使用GitHub Actions配置中的<code class="fe nm nn no np b">on</code> <strong class="la iu"> </strong>关键字配置的。您可以使用多个事件侦听器。</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="b195" class="me mf it np b gy nz oa l ob oc"># This will create a event listener for Push events on a repository<br/>on: push</span></pre><p id="90f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，<code class="fe nm nn no np b">Event</code> s触发GitHub做出反应，但是他们触发了什么？这将我们带入下一个组件，工作流<strong class="la iu">。</strong>工作流是包含所有要执行的作业的配置的名称。为工作流设置一个名称很重要，因为我们需要能够引用它们。</p><p id="635d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，您可以有许多事件和许多工作流要执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c215117669fc778bbaa05fc3e6bbed24.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*ty5IuABvKW0u5SipXFDLaw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作流是指配置的名称。</p></figure><p id="c43e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用配置中的<code class="fe nm nn no np b">name</code> <strong class="la iu"> </strong>关键字设置工作流名称。</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="e9c0" class="me mf it np b gy nz oa l ob oc"># This will set the name of the workflow<br/>name: my-workflow</span></pre><p id="5ab0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个组成部分是乔布斯。这是一个包含所有执行步骤的容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/df14d59de4db8efd24aef164e02c509b.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*cVaIsk4Unmc4V9THIGSsSQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作业是保存要执行的步骤的配置，可以是一个作业中的多个步骤。</p></figure><p id="95c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用工作流程配置中的<code class="fe nm nn no np b">jobs</code>关键字来设置作业。<br/>可以使用许多有用的设置对作业进行配置。您可以创建所需的Docker容器和更多的容器在<code class="fe nm nn no np b">Jobs</code>中运行，甚至可以改变它运行的操作系统。我们稍后将在一个<code class="fe nm nn no np b">Job</code>中运行一个PostgresDocker。</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="d7cf" class="me mf it np b gy nz oa l ob oc">#Configure jobs below<br/>jobs:<br/>  #Name the Job by setting a key value<br/>  my-job:<br/>      name: My custom job<br/>      # Set the operation system to use on during the Job<br/>      runs-on: ubuntu-latest<br/>      # Configure the steps that are part of the job<br/>      steps: #Comes later in the article</span></pre><p id="81fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作业可以包含许多步骤。步骤是要执行的实际操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6c515bca7e44e5703cf099977987589b.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*N5PGdTG5-Q-MEZIC9arO3g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">步骤是要执行的操作/命令。</p></figure><p id="5207" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们开始做事情和运行命令的地方。步骤是某个命令或一系列命令的名称。步骤位于作业内部，通过使用<code class="fe nm nn no np b">steps</code>关键字进行设置。可以配置多个步骤——下面的示例用于安装Golang，从存储库中取出代码，然后运行终端命令:</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="8720" class="me mf it np b gy nz oa l ob oc">steps: <br/>  - name: Set up Go 1.x<br/>    uses: actions/setup-go@v2<br/>    with:<br/>       go-version: ^1.15.5<br/>  - name: Check out code from the repository<br/>    uses: actions/checkout@v2<br/>  - name: Run a terminal command<br/>    run: echo "Hello World" &amp;&amp; pwd</span></pre><p id="41e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">起初这看起来很困惑，或者至少对我来说是这样。这就是为什么我创建了一个信息图来显示GitHub操作中组件之间的关系，以可视化连接。请记住，每个子组件可以包含多个组件。所以<strong class="la iu"> </strong>一个事件可以触发很多工作流，一个工作流可以包含很多作业，一个作业可以包含很多步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9dfadfbd07e9e6cf5d014f3071e860df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Agtv-SaM-zw_GLzPI7p5w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub动作的组件层次结构</p></figure><h2 id="5216" class="me mf it bd mg mh mi dn mj mk ml dp mm lh mn mo mp ll mq mr ms lp mt mu mv mw bi translated">让我们开始使用GitHub动作</h2><p id="31c4" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我们需要做的第一件事是建立一个GitHub存储库。你需要一个GitHub帐户来尝试这个。</p><p id="8046" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">登录并创建一个存储库，并确保将存储库设置为<code class="fe nm nn no np b">Public</code>。GitHub动作只有在资源库公开的情况下才是免费的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ab499d4b27946ca10b8ae8bb6287f1dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkwEeaxc0Y1byBnkJVPSpw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在GitHub上创建一个新的资源库，确保它被标记为Public。</p></figure><p id="1785" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GitHub操作存储在YAML文件中，该文件位于。github/workflow。<strong class="la iu"> </strong>你可以通过在那里添加一个YAML文件来创建一个工作流程，或者你也可以使用网站来为你生成文件。进入存储库后，导航到“操作”选项卡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/2db3a3e2d61ef1fce3a24fa753163c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zz_alMB5fsnM5lgS26_zAg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Actions选项卡带你到一个页面，GitHub可以在这里为你生成动作。</p></figure><p id="3da6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该看到设置启动工作流的选项，请按“设置此工作流”进行设置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f09c72a4f4d8acf998dd0a6e4cebbfef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*3cgqLX87-XfYW-p3XGWmjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub为你生成一个简单的工作流程。</p></figure><p id="571a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你将看到一个非常用户友好的页面。它将包含一个文本编辑器的权利，在浏览器的左侧。在右侧，您将可以访问包含预建步骤的市场。是我第一次预览这个页面，让我爱上了GitHub Actions。在这里，我们可以编辑并提交我们的工作流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/33c4b1da103bc66a93917d57eefe1e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AymK7hUIJWCF5yZ8jrzxsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在浏览器中编辑GitHub动作非常流畅，可以访问文档和市场，还可以选择提交。</p></figure><p id="a1d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要做的第一件事是重命名工作流。现在工作流文件名为blank.yaml，我将命名为mine buildtest.yaml，因为它将用于此目的。我还将修改其中的名称配置以进行构建和测试。</p><p id="9f3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确保你阅读了当前的YAML，并对它感到舒适。当前工作流将触发两个事件—推送或拉取请求。只有在主分支上发生这些事件时，它才会触发。</p><p id="a5fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一项工作叫做构建，在Ubuntu操作系统上运行。构建将有三个步骤:第一步提取存储库中的任何代码，接下来的两步将只使用echo打印到标准输出。</p><p id="ca03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是在步骤中使用了run命令。作为用户，这就是我们如何修改一个步骤中将要发生的事情。这可以是适用于所选操作系统的任何内容。一个例子是安装依赖项。假设我有一个项目使用了<code class="fe nm nn no np b">libpcap</code>——因为它嗅探网络，我的单元测试将使用<code class="fe nm nn no np b">localhost</code>。但是测试仍然需要操作系统有<code class="fe nm nn no np b">libpcap</code>，所以我在运行我的单元测试之前使用run命令来安装它。我的单元测试也是用<code class="fe nm nn no np b">run</code>执行的——把它想象成一个终端。</p><p id="0c62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就足够了，让我们按下绿色的提交按钮来试试吧。提交后，再次进入Actions选项卡，您应该会看到一个作业在队列中或已完成。队列意味着它将运行工作流，但是等待服务器准备就绪。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/0d45864118641cd3f42987d4ec034611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uujl0YV4K69iV2XsDgCSIQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">再次输入操作将显示提交的名称和工作流的状态。</p></figure><p id="4949" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，在“所有工作流”下，<strong class="la iu"> </strong>您现在有了一个名为“构建和测试”的工作流<strong class="la iu"> </strong>您可以点击它，查看工作流程中所有作业的更深入状态:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/a3df1dceddd8a38b5dd97fb11dd5e909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8UXrkAO1wfWzoBsKQOKZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作流视图，显示有关工作流的信息，并列出其中所有可用的作业。</p></figure><p id="4e38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在工作流视图中，您应该在左侧面板上看到属于它的任何作业。在这种情况下，我们只有一个工作，建筑工作。它也是绿色的，表示一切正常。这是对工作流程的一个很好的概述，但通常，您会希望单击作业来查看步骤的深入视图。单击构建作业以查看每个步骤的详细信息和输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/b1211a0814440e273b80ab456c30b04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4No1ltfmLv9GoQObf-OEZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Step视图显示了运行的每个步骤的信息以及输出。这在调试失败的工作流时非常有用。</p></figure><p id="dae5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在转到“代码”<strong class="la iu"> </strong>选项卡，导航到工作流文件，然后按编辑开始更改它。记住，工作流存储在<code class="fe nm nn no np b">.github/workflows</code>中。<br/>现在，为了方便起见，我们将修改浏览器内部的配置，但也可以修改您本地计算机上的文件。当您提交并推送更改后的配置时，它将应用该配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/4896da4b2966b49e7b8aa34c90ab11a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDthzfOqBVR4ADPhRiA-tQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像突出显示了开始编辑工作流程的位置</p></figure><p id="9552" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们试着使用marketplace，搜索你感兴趣的任何东西并添加它。我将继续在市场中搜索名为“Setup Go”的操作。当您选择一个操作并使用它替换最后两个步骤时，我们将需要复制推荐的配置。这就是在插入新动作时使用市场是多么简单。</p><p id="9ccd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还将添加两个新步骤，一个编译我的存储库代码，另一个运行我的存储库中可用的任何单元测试。这必须根据您自己的需要或编程语言进行修改，但应该很容易做到，因为您只能替换所使用的终端命令。这是我当前工作流的样子，它将编译我的Golang项目并运行所有单元测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub Action为Golang项目构建并运行单元测试</p></figure><p id="c663" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果你尝试复制这个要点并提交它，你会看到当GitHub动作失败时会发生什么。再次访问Actions选项卡，您应该会看到一个红色图标，而不是我们在一切都通过时看到的绿色图标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/ccf31fa0074c3e22b9e51c03e0e73fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rynEJXveworUQXjI_4vQlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">失败的工作流标有红色叉号。</p></figure><p id="3fc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么我展示了如何找到步骤视图的部分。我们现在需要调试工作流中的错误，进入失败作业的步骤视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/13c5d3fac5aa4fb1d902a839b5dd5ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxQeZCX67ZaWuYVZ9MsT8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例输出如何调试失败的步骤。</p></figure><p id="f0e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到那个输出了吗？太神奇了。导航简单，容易找到错误。您可能已经注意到推送失败了，但它实际上仍然应用了它。如果您愿意，可以在存储库上更改这一设置—它被称为“分支保护规则”它位于“设置-&gt;分支-&gt;添加分支规则-&gt;合并前需要通过状态检查”我在主分支上配置了一个，用于我的构建检查，只是为了好玩。<strong class="la iu"> </strong>注意这只适用于合并和拉请求，不适用于管理员的推请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/12e030ff71e4b238e395a9c77c57644d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nrKMyuRLUg1w5YDTdCFt6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建分支保护规则可以强制所有操作在接受推送之前通过</p></figure><p id="355e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将添加一些用Go to the repository编写的小代码片段，刚好够它编译，以及一些简单的单元测试。</p><p id="9c73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将为我的存储库创建两个新文件并推送它们。是我能构建的最小的Go应用程序——它会编译，这就是它所需要的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go是一个超级瘦的应用，只是为了通过GitHub的动作作业</p></figure><p id="8c4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一个<code class="fe nm nn no np b">main_test.go</code>，里面有两个测试，只是给你看输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main_test.go运行两个golang单元测试。</p></figure><p id="158c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将这些文件推送到存储库将导致工作流被执行。这一次，如果我们查看测试步骤，我们应该会看到测试通过的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/b787d14c458d51c4b14daeb6fd1b0fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dJzZuI-6abyfjxKPc1iIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试成功通过，一切都好合并。</p></figure><p id="6c82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候加快步伐了。到目前为止，我们已经使用了最简单的操作:我们可以编译和运行单元测试，这让我们走得更远，但是如果我们想要或需要并行服务运行呢？</p><p id="1d0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有一个用例，其中我有一个依赖PostgreSQL和Redis的应用程序在测试期间可用。当我们可以在测试环境中运行时，为什么要嘲笑呢？</p><p id="28d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看<strong class="la iu">服务</strong>关键词。服务用于与您的工作流并行运行docker容器。你可以在这里阅读更多关于它们的<a class="ae lu" href="https://docs.github.com/en/actions/guides/about-service-containers" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="lx ly lz"><p id="5c50" class="ky kz ma la b lb lc ju ld le lf jx lg mb li lj lk mc lm ln lo md lq lr ls lt im bi translated">服务容器是Docker容器，它为您提供了一种简单且可移植的方式来承载您可能需要在工作流中测试或操作应用程序的服务。</p><p id="ba1a" class="ky kz ma la b lb lc ju ld le lf jx lg mb li lj lk mc lm ln lo md lq lr ls lt im bi translated">— GitHub文档</p></blockquote><p id="f21e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">熟悉Docker和Docker Compose对这一部分很有帮助，因为它将使用相同的语法。我们在服务配置中所做的与运行<code class="fe nm nn no np b">docker-compose</code>是一样的。如果你想了解更多关于Docker的知识，请阅读我的<a class="ae lu" href="https://itnext.io/docker-skyrocketed-my-teams-productivity-e19cd89a23ea" rel="noopener ugc nofollow" target="_blank"> Docker文章</a>。</p><p id="b718" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将在<code class="fe nm nn no np b">main_test.go</code>中添加一个测试，尝试连接到一个PostgreSQL。起初，它会失败，但是我们将添加一个运行它的服务，这样测试就可以通过:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的测试文件包含到数据库的连接尝试。</p></figure><p id="09e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你推改变的测试，它不会工作，它不会找到主机有两个原因。首先，我们使用<strong class="la iu">环境变量</strong>来存储连接信息。第二个原因是，没有运行PostgreSQL数据库。让我们通过更新工作流文件来解决这两个问题。</p><p id="9d59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将建立一个运行PostgreSQL的服务，并使用<code class="fe nm nn no np b">env</code>配置来设置环境变量。</p><p id="5c44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务将被插入到构建作业下，这将使服务可用于作业中的任何步骤。：</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点展示了在工作流中运行PostgreSQL的工作示例</p></figure><p id="ef79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您已经更新了测试文件和工作流文件，并将它们推送到存储库中，那么您现在应该会看到一个漂亮的绿色图标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/8a085dbe5f717bdcb41eacd63d917227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Bdq-lI2H0RmkTg9AlwrCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加服务成功了，现在我们的测试可以到达数据库了。</p></figure><p id="87d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个非常好的功能。此外，由于服务是基于Docker的，你可以使用任何你喜欢的Docker图像。查看<a class="ae lu" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>中的可用图片。</p><p id="3cf6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以现在你知道如何用GitHub动作轻松设置一些基本的CI/CD。让我们确保全世界都知道存储库使用了GitHub动作，并添加一个徽章来告诉我们最新执行的状态。这不仅在您的自述文件上看起来不错，而且还能给存储库一种信任感。如果我知道开发人员正在使用CI/CD，并且状态是通过所有的单元测试，我倾向于信任存储库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/2bd299bc14051ec798070319633480a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pijJIhieT5tnmx_W1C5mxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub Action可以为您自动生成徽章</p></figure><p id="4282" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入Actions选项卡，选择“构建和测试”作业。按上图中右边的三个点，选择“创建状态徽章”</p><p id="9597" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将为您呈现一个漂亮的小对话框，您可以在其中定制徽章。我们将制作一个徽章，告诉访问者存储库的状态。复制生成的文本并粘贴到README.md中，然后提交。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/5c730bc63fa306a1bc23f54793e6bcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*RbIBrPsoSEujY5jUuPG5lQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub状态动作徽章生成器。</p></figure><p id="406b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的访问者将会得到一个漂亮的小徽章，向他们保证你的库中的代码正在工作！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/a89fdfed556c2ec7c6b9921a30fcf81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aw20LE4K2hcMX0Osbf8GKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示通过状态的我的自述文件。</p></figure><p id="fdec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文到此为止。我建议探索市场来执行更多的动作——GitHub动作是一个非常强大的工具。</p><p id="3569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。</p></div></div>    
</body>
</html>