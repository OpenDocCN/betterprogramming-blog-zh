<html>
<head>
<title>Binary Tree Insertion in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的二叉树插入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/binary-tree-insertion-in-rust-a2d969c3d33d?source=collection_archive---------17-----------------------#2022-01-17">https://betterprogramming.pub/binary-tree-insertion-in-rust-a2d969c3d33d?source=collection_archive---------17-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0134" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用经典数据结构在Rust中学习所有权</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f38845a87ee3be924b99d71c324a939e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uof4TmwUqPNKOmpZoYxTMA.png"/></div></div></figure><h1 id="5a61" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="8896" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">🌳我们将一起实现一个二叉树。</li><li id="4961" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">🧑‍🌾我们将讨论在二叉树中插入一个节点的几种方法。</li><li id="bc3e" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">🧑‍🔬我们将讨论Rust的所有权。</li><li id="1849" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">✨:我们将在Rust中接触更多的特性和语法。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="8fc8" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在实现二叉树时，我一直在努力解决Rust的所有权问题，所以我转向并重新阅读了它。在花时间理解它并重构我的代码之后，我终于取得了突破😎我非常兴奋地与大家分享我在Rust中遇到的令人敬畏的功能。你会看到一些有趣的概念，比如智能指针和所有权。</p><p id="c07a" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">让我们得到它！</p><h1 id="7e28" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">数据结构</h1><p id="789b" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nf mx my lv ng na nb lx nh nd ne lz im bi translated">一个<a class="ae ni" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">二叉树</a>数据结构看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/eaa5c47d9d8b0f91b7dd7b2098f13333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpEYMe2R_IEfVgsPMt_N2w.png"/></div></div></figure><p id="6091" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">每个节点不超过两个子节点。我们称他们为<code class="fe nk nl nm nn b">left</code>孩子和<code class="fe nk nl nm nn b">right</code>孩子。我们可以将描述翻译成Rust代码，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="376b" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated"><code class="fe nk nl nm nn b">BinaryTree</code>结构保存一个泛型类型<code class="fe nk nl nm nn b">T</code>的值。我们用<code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/std/option/" rel="noopener ugc nofollow" target="_blank">Option</a></code> <a class="ae ni" href="https://doc.rust-lang.org/std/option/" rel="noopener ugc nofollow" target="_blank">枚举</a>来表示<code class="fe nk nl nm nn b">left</code>和<code class="fe nk nl nm nn b">right</code>子节点都是可选的。</p><p id="722d" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">一个<code class="fe nk nl nm nn b">Option&lt;T&gt;</code>要么是一个包含类型<code class="fe nk nl nm nn b">T</code>的值的<code class="fe nk nl nm nn b">Some</code>，要么是一个表示它不包含类型<code class="fe nk nl nm nn b">T</code>的值的<code class="fe nk nl nm nn b">None</code>。因为我们使用<code class="fe nk nl nm nn b">Option</code>来表示一个值是有还是无，Rust编译器可以检查我们是否处理了所有的情况<a class="ae ni" href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=option#the-option-enum-and-its-advantages-over-null-values" rel="noopener ugc nofollow" target="_blank">以防止bug</a>。</p><p id="22f8" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">与使用<code class="fe nk nl nm nn b"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">null</a></code>值来表达相同概念的JavaScript相比，<code class="fe nk nl nm nn b">Option</code>鼓励我提前处理用例，这让我在运行时省去了很多麻烦。</p><p id="b05b" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated"><code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/book/ch15-01-box.html" rel="noopener ugc nofollow" target="_blank">Box</a></code>是智能指针之一。它在内存中保存一个指向数据的地址。<code class="fe nk nl nm nn b">Box</code>帮助我们创建一个大小未知的<code class="fe nk nl nm nn b">BinaryTree</code>结构，这样我们就可以通过插入节点来增长二叉树，而不用在创建二叉树时预先考虑有多少节点。</p><p id="1b0e" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated"><a class="ae ni" href="http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/the-stack-and-the-heap.html" rel="noopener ugc nofollow" target="_blank">内存管理</a>是Rust如此出色且有趣的原因之一。</p><h1 id="9ed4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">插入</h1><p id="b5ba" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nf mx my lv ng na nb lx nh nd ne lz im bi translated">在插入一个新的二叉树节点之前，我们需要创建一个根。让我们来实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4eac" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated"><code class="fe nk nl nm nn b">new</code> <a class="ae ni" href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#associated-functions" rel="noopener ugc nofollow" target="_blank">关联函数</a>获取<code class="fe nk nl nm nn b">T</code>的值，并返回一个保存该值且没有子节点的<code class="fe nk nl nm nn b">BinaryTree</code>。</p><p id="6b0e" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">既然我们可以使用<code class="fe nk nl nm nn b">BinaryTree::new</code>创建一个根节点，我们可以考虑如何插入子节点。直观地说，如果我们可以通过调用根节点实例上的方法来插入左或右子节点，那就太好了。像这样:</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="bc8a" class="nu kv it nn b gy nv nw l nx ny">BinaryTree::new(1)<br/>  .left(BinaryTree::new(2))<br/>  .right(BinaryTree::new(3))</span></pre><p id="dcf1" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">幸运的是，我从我的朋友<a class="ae ni" href="https://twitter.com/matthiasendler" rel="noopener ugc nofollow" target="_blank"> Matthias </a>那里找到了一篇<a class="ae ni" href="https://endler.dev/2017/boxes-and-trees/" rel="noopener ugc nofollow" target="_blank">很棒的文章</a>，详细解释了如何实现它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="72fe" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">现在让我们编写一些测试来确保相关的功能正常工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="a70f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">广度优先插入</h1><p id="1140" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nf mx my lv ng na nb lx nh nd ne lz im bi translated">插入方法非常灵活，我们可以轻松地用几行代码创建一个树:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3fce" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">代码创建了一个二叉树，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a179e6b8f17196417bd70bb20425fce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLO4SYmLuRJXMew4DANoAw.png"/></div></div></figure><p id="2941" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">这让我开始思考。</p><blockquote class="nz oa ob"><p id="7d44" class="mq mr oc lo b lp ms ju mt lr mu jx mv od mw mx my oe mz na nb of nc nd ne lz im bi translated"><em class="it">如果我只想创建一棵</em> <a class="ae ni" href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" rel="noopener ugc nofollow" target="_blank"> <em class="it">平衡二叉树</em> </a> <em class="it">没有任何其他要求，我可以插入一个节点，树为我找到下一个可用点吗？</em></p></blockquote><p id="61fc" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">大概是这样的:</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="d3f4" class="nu kv it nn b gy nv nw l nx ny">let mut root = BinaryTree::new(1);<br/>root.insert(2);<br/>root.insert(3);<br/>root.insert(4);<br/>root.insert(5);</span></pre><p id="6542" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">它创建了和我们上面看到的一样的树结构。</p><p id="0f14" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我们可以通过以<a class="ae ni" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先</a>的方式遍历树，并在发现缺少子节点时插入一个节点来实现。</p><p id="2051" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">实现先呼吸遍历最简单的方法是使用一个<a class="ae ni" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">队列</a>。Rust标准库中有一个<code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html" rel="noopener ugc nofollow" target="_blank">VecDequeue</a></code>，我们可以使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8510" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">算法是强制循环在访问下一层子节点之前，首先从左到右访问兄弟节点。在每次迭代中，我们将检查是否有<code class="fe nk nl nm nn b">left</code>或<code class="fe nk nl nm nn b">right</code>孩子缺席。如果我们找到一个，那就是新节点的下一个可用位置。</p><p id="9e71" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">这是一个相当简单的算法，但是我很难把它做对。问题是我不明白Rust中的所有权。</p><p id="0003" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">下面我们一起来过一遍<code class="fe nk nl nm nn b">insert</code>的方法。</p><p id="366e" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我们首先要决定的是我们要如何使用第一个论点<code class="fe nk nl nm nn b">self</code>。<code class="fe nk nl nm nn b">self</code>指的是调用该方法的<code class="fe nk nl nm nn b">BinaryTree</code>实例。我们从<code class="fe nk nl nm nn b">self</code>中需要的是能够变异<code class="fe nk nl nm nn b">left</code>和<code class="fe nk nl nm nn b">right</code>子节点，以便我们可以插入一个新节点。简单地传入一个可变引用<code class="fe nk nl nm nn b">&amp;mut self</code>就可以完成这项工作，因为该方法不需要获得<code class="fe nk nl nm nn b">self</code>的所有权。</p><p id="bc4a" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">对于<code class="fe nk nl nm nn b">VecDeque</code>项的数据类型，我们可以使用与<code class="fe nk nl nm nn b">self</code>相同的数据类型来存储<code class="fe nk nl nm nn b">BinaryTree</code>的可变引用。</p><p id="97c0" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">当在循环中弹出队列时，我们希望使用对<code class="fe nk nl nm nn b">left</code>和<code class="fe nk nl nm nn b">right</code>的可变引用，因为我们希望插入新的节点。</p><p id="93d7" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">当插入新节点时，我们<a class="ae ni" href="https://doc.rust-lang.org/book/ch15-02-deref.html" rel="noopener ugc nofollow" target="_blank">解引用</a>中的<code class="fe nk nl nm nn b">left</code>和<code class="fe nk nl nm nn b">right</code>来允许新节点赋值，就像这样:<code class="fe nk nl nm nn b">*left = Some(Box::new(BinaryTree::new(new_value)))</code>。</p><p id="f18f" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我花了一些时间才弄明白如何借用或移动方法中的数据。一旦我明白了，这就很有意义了！</p><p id="45dc" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">让我们为它编写一些测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="37d4" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">如果我们运行测试，您会看到如下错误消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/4766d4bcae4b79ebf0a3056e774fd03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhZTjaG4KCjZV-brfvpMAA.png"/></div></div></figure><p id="2644" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">这是因为树木不能互相比较。我们可以通过向<code class="fe nk nl nm nn b">BinaryTree</code>结构添加<code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" rel="noopener ugc nofollow" target="_blank">PartialEq</a></code>特征来修复它。</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="4c38" class="nu kv it nn b gy nv nw l nx ny">+ #[derive(PartialEq)]<br/>pub struct BinaryTree&lt;T&gt; {<br/>    pub value: T,<br/>    pub left: Option&lt;Box&lt;BinaryTree&lt;T&gt;&gt;&gt;,<br/>    pub right: Option&lt;Box&lt;BinaryTree&lt;T&gt;&gt;&gt;,<br/>}</span></pre><h1 id="639d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">将数组转换成二叉树</h1><p id="1f08" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nf mx my lv ng na nb lx nh nd ne lz im bi translated">现在我们已经用<code class="fe nk nl nm nn b">insert</code>方法实现了自动插入，我们可以考虑用一种更方便的方式创建一个平衡树。例如，我想要类似于<code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#examples" rel="noopener ugc nofollow" target="_blank">Vec::from</a></code>的东西:一个关联函数<code class="fe nk nl nm nn b">BinaryTree::from</code>，它接受一个数组并返回一个平衡的<code class="fe nk nl nm nn b">BinaryTree</code>。</p><p id="edc5" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">让我们编写一个测试来更好地可视化用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="652e" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">为了实现<code class="fe nk nl nm nn b">BinaryTree::from</code>，我们可以简单地遍历数组，并使用<code class="fe nk nl nm nn b">insert</code>方法来创建树结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7756" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">在函数中，我们从第一个数组元素创建了一个根节点，然后将其余元素逐个插入树中。</p><p id="96a5" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">如果您尝试测试它，您将会看到如下错误消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/4d89de0c4f1a15e8dae0f1fb4d7e20c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qu6Ji5I2HdwZ8S6TwlZPLA.png"/></div></div></figure><p id="249a" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">我们可以通过指定类型<code class="fe nk nl nm nn b">T</code>实现<code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/std/marker/trait.Copy.html" rel="noopener ugc nofollow" target="_blank">Copy</a></code>特征来解决这个问题。</p><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="8923" class="nu kv it nn b gy nv nw l nx ny">- impl&lt;T&gt; BinaryTree&lt;T&gt; {<br/>+ impl&lt;T&gt; BinaryTree&lt;T&gt;<br/>+ where<br/>+     T: Copy,<br/>+ {</span></pre><p id="881c" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">原因是<code class="fe nk nl nm nn b">insert</code>方法实际上接管了<code class="fe nk nl nm nn b">new_value</code>的所有权。为了节省程序内存，编译器不允许我们将数组元素“移动”到<code class="fe nk nl nm nn b">insert</code>方法中，因为该数组可能在程序的其他部分被引用。所以我们能做的就是传入一个数组元素的副本。</p><p id="3424" class="pw-post-body-paragraph mq mr it lo b lp ms ju mt lr mu jx mv lt mw mx my lv mz na nb lx nc nd ne lz im bi translated">现在它应该工作了！</p><h1 id="b0cb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最后的想法</h1><p id="dc28" class="pw-post-body-paragraph mq mr it lo b lp lq ju mt lr ls jx mv lt nf mx my lv ng na nb lx nh nd ne lz im bi translated">就是这样！我们二叉树断言的完整实现在这里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="b3a2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参考</h1><ul class=""><li id="c5da" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">二叉树</a></li><li id="d89a" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" rel="noopener ugc nofollow" target="_blank">平衡二叉树</a></li><li id="5428" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先搜索</a></li><li id="f726" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">队列</a></li><li id="5c5f" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/std/option/" rel="noopener ugc nofollow" target="_blank">锈</a> <code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/std/option/" rel="noopener ugc nofollow" target="_blank">Option</a></code> <a class="ae ni" href="https://doc.rust-lang.org/std/option/" rel="noopener ugc nofollow" target="_blank">型</a></li><li id="3d2b" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/book/ch15-01-box.html" rel="noopener ugc nofollow" target="_blank">锈</a> <code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/book/ch15-01-box.html" rel="noopener ugc nofollow" target="_blank">Box</a></code> <a class="ae ni" href="https://doc.rust-lang.org/book/ch15-01-box.html" rel="noopener ugc nofollow" target="_blank">指针</a></li><li id="9369" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html" rel="noopener ugc nofollow" target="_blank">铁锈</a>T2】</li><li id="1e36" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" rel="noopener ugc nofollow" target="_blank">锈</a> <code class="fe nk nl nm nn b"><a class="ae ni" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" rel="noopener ugc nofollow" target="_blank">PartialEq</a></code> <a class="ae ni" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" rel="noopener ugc nofollow" target="_blank">性状</a></li><li id="2fd4" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/std/marker/trait.Copy.html" rel="noopener ugc nofollow" target="_blank">铁锈</a>T4<a class="ae ni" href="https://doc.rust-lang.org/std/marker/trait.Copy.html" rel="noopener ugc nofollow" target="_blank">特质</a></li><li id="4a2a" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#examples" rel="noopener ugc nofollow" target="_blank">铁锈</a>T5】</li><li id="3e5b" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#associated-functions" rel="noopener ugc nofollow" target="_blank">生锈关联功能</a></li><li id="34c5" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="noopener ugc nofollow" target="_blank">铁锈归属</a></li><li id="b8e8" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">JavaSCript</a>T6】</li><li id="7267" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/the-stack-and-the-heap.html" rel="noopener ugc nofollow" target="_blank">栈和堆</a></li><li id="587f" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">盒子和树的<a class="ae ni" href="https://endler.dev/2017/boxes-and-trees/" rel="noopener ugc nofollow" target="_blank">——生锈的智能指针</a></li><li id="a6ee" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://www.reddit.com/r/rust/comments/ry34vr/problem_with_implementing_binary_tree_insertion/" rel="noopener ugc nofollow" target="_blank">实现二叉树插入的问题</a></li><li id="9ef8" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=option#the-option-enum-and-its-advantages-over-null-values" rel="noopener ugc nofollow" target="_blank">枚举选项及其优于空值的优势</a></li><li id="09a5" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated"><a class="ae ni" href="https://doc.rust-lang.org/book/ch15-02-deref.html" rel="noopener ugc nofollow" target="_blank">将智能指针视为具有Deref特征的常规引用</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nq nn nr ns aw nt bi"><span id="609a" class="nu kv it nn b gy nv nw l nx ny"><strong class="nn iu">Want to Connect?</strong></span><span id="9d34" class="nu kv it nn b gy oi nw l nx ny">This article is originally posted on <a class="ae ni" href="https://dawchihliou.github.io/articles/binary-tree-insertion-in-rust" rel="noopener ugc nofollow" target="_blank">Daw-Chih’s website</a>.</span></pre></div></div>    
</body>
</html>