<html>
<head>
<title>Use Conan: An Open Source C/C++ Package Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Conan:一个开源的C/C++包管理器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-conan-an-open-source-c-c-package-manager-678bf2b0e6d?source=collection_archive---------2-----------------------#2022-02-15">https://betterprogramming.pub/use-conan-an-open-source-c-c-package-manager-678bf2b0e6d?source=collection_archive---------2-----------------------#2022-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="09db" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">管理您的C/C++包可能会很麻烦，但是它可以得到显著的改善</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/62680b8bf7cef2e11c580d0dd3f75034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DE_i8YNxWbtGQJMk"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@davealmine?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dawid za wia</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="bcad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将介绍C/C++中的包管理问题，以及Conan如何帮助您解决这些问题。</p><h1 id="8f1a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">从简单开始</h1><p id="3d78" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们从一个简单的任务开始，从命令行参数中获取值，并将它们打印到标准输出中:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0d57" class="mu lt iq mq b gy mv mw l mx my">+root<br/>    - mainapp.c<br/>    - CMakeLists.txt</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">mainapp.c</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">CMakeLists.txt</p></figure><p id="0cc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用标准库中的<a class="ae kv" href="https://www.gnu.org/software/libc/manual/html_node/Getopt.html" rel="noopener ugc nofollow" target="_blank"> getops </a>函数来获取参数<code class="fe nb nc nd mq b">-a</code>和<code class="fe nb nc nd mq b">-b</code>及其相关值，然后打印它们。</p><p id="4001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们使用<a class="ae kv" href="https://cmake.org/" rel="noopener ugc nofollow" target="_blank"> CMake </a>将项目编译成一个名为<code class="fe nb nc nd mq b">myproject</code>的可执行文件。</p><p id="da33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们配置这个项目:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2256" class="mu lt iq mq b gy mv mw l mx my">cmake --build ./build --config Debug --target MyProject -j 10 --</span></pre><p id="30a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们运行应用程序:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="16a2" class="mu lt iq mq b gy mv mw l mx my">./build/MyProject -a foo -b bar</span></pre><p id="c58c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b533" class="mu lt iq mq b gy mv mw l mx my">a: foo<br/>b: bar</span></pre><p id="904b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是可行的，但是“可行”并不总是足够的。<br/>Getops函数使用全局变量，例如<code class="fe nb nc nd mq b">optarg</code>来存储参数关联值，<code class="fe nb nc nd mq b">optopt</code>用于存储变量名，<code class="fe nb nc nd mq b">optind</code>用于存储索引。</p><p id="0389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着该函数不是线程安全的，您只能在一个线程中解析一个输入向量。</p><p id="e010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有多个输入向量，您需要顺序地解析这些向量，更糟糕的是，您每次都必须重置解析器的状态。</p><p id="71d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">getops的另一个众所周知的问题是内部隐藏的错误消息，这使得重定向变得困难。</p><p id="6c3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，为了解决这个问题，我决定使用<a class="ae kv" href="https://github.com/jibsen/parg/blob/master/parg.h" rel="noopener ugc nofollow" target="_blank"> parg </a>，一个开源的C库，通过分配一个struct并使用它来监视解析器的状态，而不是全局变量，来解析具有线程安全性的参数。</p><h1 id="068f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">但是我该如何使用这些代码呢？</h1><h2 id="145e" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">备选方案1。消费源代码</h2><p id="dc20" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以使用<a class="ae kv" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank"> gits子模块工具</a>将parg克隆到我们的项目目录，然后使用cmake编译并链接到我们的可执行文件。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="01f6" class="mu lt iq mq b gy mv mw l mx my">git submodules add <a class="ae kv" href="https://github.com/jibsen/parg.git" rel="noopener ugc nofollow" target="_blank">https://github.com/jibsen/parg.git</a></span></pre><p id="9279" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将创建包含以下内容的文件<code class="fe nb nc nd mq b">.gitsubmodules</code>:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="33dd" class="mu lt iq mq b gy mv mw l mx my">[submodule "parg"]</span><span id="c700" class="mu lt iq mq b gy np mw l mx my">path = parg</span><span id="126b" class="mu lt iq mq b gy np mw l mx my">url = https://github.com/jibsen/parg.git</span></pre><p id="1351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以获取回购及其源代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5fb7" class="mu lt iq mq b gy mv mw l mx my">git submodules init</span></pre><p id="325e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe nb nc nd mq b">parg</code>目录中有所有的<code class="fe nb nc nd mq b">parg</code>源代码。</p><p id="a51b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要将它添加到我们的<code class="fe nb nc nd mq b">CMakeLists.txt</code>配置中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2013" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经添加了目录并将库链接到我们的可执行文件。<br/>现在我们可以修改代码来使用<code class="fe nb nc nd mq b">parg</code>库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的代码是线程安全的，如果需要，我们可以很容易地解析多个参数向量。</p><p id="6f65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来编译一下:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ccfe" class="mu lt iq mq b gy mv mw l mx my">cmake --build ./build --config Debug --target MyProject -j 10 --</span></pre><p id="16eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8ccf" class="mu lt iq mq b gy mv mw l mx my">./build/MyProject -a foo -b bar</span></pre><p id="2af7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2b0c" class="mu lt iq mq b gy mv mw l mx my">a: foo<br/>b: bar</span></pre><p id="bb3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加源代码的主要限制是，每次编译可执行文件时，我们都需要编译它，这会导致编译时间延长。</p><h2 id="b40a" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">选项2。消费编译库</h2><p id="8fad" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这个选项中，我们将<code class="fe nb nc nd mq b">parg</code>编译一次，保存库，然后直接链接库，不需要再次编译。</p><p id="9ce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译我们的<code class="fe nb nc nd mq b">parg</code>项目将会创建文件<code class="fe nb nc nd mq b">libaprg.a</code>。</p><p id="0b99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以对CMakeLists和C代码进行一些修改以使其工作:</p><p id="817b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CMake:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e4aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是C代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0f34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对C代码的唯一更改是，现在头文件放在了链接库中。</p><p id="f6d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在CMakeLists文件中，我们已经移除了<code class="fe nb nc nd mq b">add_subdirectories</code>，取而代之的是，我们已经从它的路径链接了编译后的库，这样我们就不会在每次编译应用程序时都编译它。</p><p id="d412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们编译并再次运行。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2743" class="mu lt iq mq b gy mv mw l mx my">cmake --build ./build --config Debug --target MyProject -j 10 --</span></pre><p id="c3b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a95a" class="mu lt iq mq b gy mv mw l mx my">./build/MyProject -a foo -b bar</span></pre><p id="e450" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e799" class="mu lt iq mq b gy mv mw l mx my">a: foo<br/>b: bar</span></pre><p id="fe74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有用！更好，但还可以更好！</p><p id="31b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的问题是，它污染了工作环境，并且当您有许多依赖项时，您的依赖项有第二层甚至第三层依赖项，这变得非常难以管理。</p><h2 id="58d8" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">选项3。用柯南来大声哭吧！</h2><p id="25d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://conan.io/" rel="noopener ugc nofollow" target="_blank">柯南</a>是JFrog开发的开源C\C++包管理器。<br/>它使用JFrog artifactory来管理依赖关系。<br/>它主要由其软件即服务(SaaS)平台使用，但也可以用作公司内部需求的本地存储库。</p><p id="bf22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为先决条件，您需要安装<a class="ae kv" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>。</p><p id="3496" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要使用以下命令从<a class="ae kv" href="https://pypi.org/project/conan/" rel="noopener ugc nofollow" target="_blank"> pip </a>安装柯南:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a353" class="mu lt iq mq b gy mv mw l mx my">pip install conan</span></pre><p id="0502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要为我们的配置创建一个配置文件:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c314" class="mu lt iq mq b gy mv mw l mx my">conan profile new myprofile</span></pre><p id="5b4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出将是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="89a3" class="mu lt iq mq b gy mv mw l mx my">Empty profile created: C:\Users\user\.conan\profiles\myprofile</span></pre><p id="5635" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以转到概要文件，根据需要设置配置。<br/>在我的例子中，我使用了以下代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6fd6" class="mu lt iq mq b gy mv mw l mx my">[env]</span><span id="84be" class="mu lt iq mq b gy np mw l mx my">CC=C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/gcc.exe</span><span id="5772" class="mu lt iq mq b gy np mw l mx my">CXX=C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/g++.exe</span><span id="ee94" class="mu lt iq mq b gy np mw l mx my">[settings]</span><span id="9e64" class="mu lt iq mq b gy np mw l mx my">os_build=Windows</span><span id="1516" class="mu lt iq mq b gy np mw l mx my">arch_build=x86</span><span id="00b3" class="mu lt iq mq b gy np mw l mx my">os=Windows</span><span id="e4df" class="mu lt iq mq b gy np mw l mx my">arch=x86</span><span id="99e5" class="mu lt iq mq b gy np mw l mx my">compiler=gcc</span><span id="951a" class="mu lt iq mq b gy np mw l mx my">compiler.version=8</span><span id="09b5" class="mu lt iq mq b gy np mw l mx my">compiler.libcxx=libstdc++11</span><span id="1737" class="mu lt iq mq b gy np mw l mx my">build_type=Release</span></pre><p id="582c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将设置编译项目所需的所有路径和变量。</p><p id="ab1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置好概要文件后，现在我将在项目目录中创建<code class="fe nb nc nd mq b">conanfile.txt</code>。<br/>查看柯南中心的<a class="ae kv" href="https://conan.io/center/parg" rel="noopener ugc nofollow" target="_blank"> parg库</a>，我可以找到我需要的所有细节。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3a42" class="mu lt iq mq b gy mv mw l mx my">[requires]<br/>    parg/1.0.2</span><span id="735b" class="mu lt iq mq b gy np mw l mx my">[generators]<br/>    cmake</span></pre><p id="6b00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我的项目依赖于<code class="fe nb nc nd mq b">parg</code>，柯南知道这一点，所以应该为cmake提供它。</p><p id="9ba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我可以运行柯南安装命令了:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="85ae" class="mu lt iq mq b gy mv mw l mx my">conan install . -pr=myprofile</span></pre><p id="cf92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5e1e" class="mu lt iq mq b gy mv mw l mx my">Configuration:<br/>[settings]<br/>arch=x86<br/>arch_build=x86<br/>build_type=Release<br/>compiler=gcc<br/>compiler.libcxx=libstdc++11<br/>compiler.version=8<br/>os=Windows<br/>os_build=Windows<br/>[options]<br/>[build_requires]<br/>[env]<br/>CC=C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/gcc.exe<br/>CXX=C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/g++.exe<br/>conanfile.txt: Installing package<br/>Requirements<br/>    parg/1.0.2 from 'conancenter' - Cache<br/>Packages<br/>    parg/1.0.2:a955db98e980a5ab86ae50d6df8bfee361185c27 - Cache</span><span id="a152" class="mu lt iq mq b gy np mw l mx my">Installing (downloading, building) binaries...<br/>parg/1.0.2: Already installed!<br/>conanfile.txt: Generator txt created conanbuildinfo.txt<br/>conanfile.txt: Generator cmake created conanbuildinfo.cmake<br/>conanfile.txt: Aggregating env generators<br/>conanfile.txt: Generated conaninfo.txt<br/>conanfile.txt: Generated graphinfo</span></pre><p id="bffe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">酷！</p><p id="8a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们给<code class="fe nb nc nd mq b">CMakeLists.txt</code>文件添加一些修改，这样它将获得包含这些依赖项的库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7f29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们包含了来自sources目录的构建信息(它是由Conan install创建的)并链接了库。</p><p id="2f97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以使用我们在第一个例子中使用的相同的C代码，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="25b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不同的是，现在我们不会用git子模块污染我们的代码，我们也不必每次都编译代码。同样，我们不再需要自己管理依赖关系和工件。</p><p id="4529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们再次编译并运行这段代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7b75" class="mu lt iq mq b gy mv mw l mx my">cmake --build ./build --config Debug --target MyProject -j 10 --</span></pre><p id="43eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="735c" class="mu lt iq mq b gy mv mw l mx my">./build/MyProject -a foo -b bar</span></pre><p id="5aa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ffb6" class="mu lt iq mq b gy mv mw l mx my">a: foo<br/>b: bar</span></pre><p id="6ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。</p></div></div>    
</body>
</html>