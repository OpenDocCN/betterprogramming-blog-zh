<html>
<head>
<title>How To Build a Redux-Like Store With React Context and Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React上下文和钩子构建一个类似Redux的存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-redux-like-store-with-react-context-hooks-234e3774495f?source=collection_archive---------1-----------------------#2019-11-05">https://betterprogramming.pub/build-a-redux-like-store-with-react-context-hooks-234e3774495f?source=collection_archive---------1-----------------------#2019-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dc67" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">并将身份验证和路由添加到您的应用中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/22f2ce13a124ec6ee8d598aa4cb5b3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZKWykJJLMdrrU5-qeZQ1Q.png"/></div></div></figure><p id="3f64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在一个晴朗的周六早晨，你醒来时对下一个兼职项目有了一个绝妙的想法。你已经想了一周了，现在你准备好投入进去了。无论如何，你想尝试所有那些你在枯燥的日常工作中错过的热门新技术和框架。</p><p id="6b72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用React的所有最新和最棒的特性(上下文、钩子等),您对前端应用程序有了大致的概念。等。)以及无服务器后端(可能使用<a class="ae ln" href="https://workers.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare Workers </a>？)</p><p id="d6f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你打开你最喜欢的编辑器，一个闪亮的新create React应用程序正在运行，准备成为下一个大事件。</p><p id="385c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后砰！开发了几个小时后，你意识到你实际上什么也没做，却打开了几十个教程标签和文档，只是对所有这些新特性和术语感到困惑和沮丧。</p><p id="a7ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我决定写这个指南来帮助我自己组织我的学习，并希望与像我一样沮丧的开发者分享这些知识时，我就在那里。</p><p id="01dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本指南中，我将从上下文和钩子的基础开始，逐步将它们相互集成，创建一个简单但功能强大的状态管理器，就像<a class="ae ln" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>一样。</p><p id="3f43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/pubudu-ranasinghe/react-context-example" rel="noopener ugc nofollow" target="_blank">TL；博士刚刚给我看了代码</a>。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="dfef" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">React中的状态管理</h1><p id="668b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">所以，让我们回过头来定义一下我的需求。我想设置一个React应用程序，并且:</p><ul class=""><li id="ea3e" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">使用上下文和钩子进行全局状态管理。</li><li id="2004" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">使用全局状态实现身份验证。</li><li id="f750" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">使用公共和私有路由配置路由。</li></ul><p id="6ef6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你有这三个地方，应用程序的其余部分是非常常见的反应业务。</p><p id="4b63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<a class="ae ln" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>处理全局状态相当简单。你用一些初始值实现了一个<em class="ng">存储</em>，编写了<em class="ng">reducer</em>来帮助你更新存储，编写了<em class="ng"> actions </em>和<em class="ng"> action creators </em>，用于向存储分派更新。</p><p id="200e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，您只需<em class="ng">将应用程序中的任何组件</em>连接到商店，就可以使用全局状态或进行更新。</p><p id="bef9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将看到如何使用上下文和钩子来实现类似的东西。我们的计划是:</p><ul class=""><li id="e053" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">使用钩子实现简单的状态管理。</li><li id="4b08" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">使用React上下文将此状态转换为全局状态。</li><li id="5802" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">将Hooks+上下文逻辑抽象成一个漂亮的、可重用的API，类似于Redux，带有一个存储、reducers和动作。</li><li id="aa36" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">使用创建的存储实现简单的身份验证和路由</li></ul><p id="9ac8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">先从<a class="ae ln" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank">创建React App </a>开始，做一点试验。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="2924" class="nm lw iq ni b gy nn no l np nq">npx create-react-app react-context-example<br/>cd react-context-example<br/>yarn start</span></pre><p id="b5a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将从一个非常简单的待办事项应用程序开始，它有三个组件，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/c0f35cd3f630011bbe2678c0606c815d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUkApnIEmC1GxxaejYwijA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/af834c0139884069fff30f7721848fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGlraFkuLFetiVQC8ARmqA.png"/></div></div></figure><p id="dad7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们添加以下组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">组件/项目. js</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">App.css让它看起来好看些:)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">App.js</p></figure><p id="6286" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们希望引入一个状态来存储待办事项列表，并能够添加和删除待办事项。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="8656" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">使用钩子的状态</h1><p id="1ff2" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated"><em class="ng">钩子</em>是React 16.8中新增的。它们允许您使用状态和其他React特性，而无需编写类。</p><p id="8d86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以前，我们会将<code class="fe nz oa ob ni b">App</code>组件转换成一个类组件，并向该类引入状态。</p><p id="9087" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，使用React钩子，我们可以将它作为一个功能组件，并使用<code class="fe nz oa ob ni b">useState</code>钩子引入状态。关于钩子的非常好的介绍可以在<a class="ae ln" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">钩子的文档</a>中找到。</p><p id="0ff4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们更新<code class="fe nz oa ob ni b">App.js</code>如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="97bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们使用<code class="fe nz oa ob ni b">useState</code>钩子将一个项目数组声明为一个状态变量。它将初始状态作为参数并返回两个值，第一个是状态本身，第二个是更新状态的函数。</p><p id="de9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，与您可能习惯的类组件中的<code class="fe nz oa ob ni b">setState</code>不同，钩子的状态更新方法不合并现有数据。因此，在传递更新后的状态之前，我们必须注意合并。</p><p id="a0ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们定义了两个函数<code class="fe nz oa ob ni b">handleAddItem</code>和<code class="fe nz oa ob ni b">handleRemoveItem</code>，用于添加和删除项目。还要注意，这些函数作为道具被传递到我们的子组件<code class="fe nz oa ob ni b">NewItem</code>和<code class="fe nz oa ob ni b">ItemList</code>中。</p><p id="a8f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了一个基本但实用的待办事项列表。您可以在<code class="fe nz oa ob ni b">NewItem</code>组件中引入另一个状态钩子来捕获用户输入的文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6f14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，使用钩子使我们的代码变得更干净，并且避免了我们可能需要关心的类组件和生命周期钩子。</p><p id="8dde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的目标是创建一个类似Redux的存储，这让我们能够抽象出状态管理逻辑，并使其可重用。特别是<code class="fe nz oa ob ni b">useReducer</code>钩子，我们一会儿将会看到它，它允许我们将它包装在一个漂亮的API中。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="2756" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">使用反应上下文</h1><p id="d719" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在，让我们探讨一下什么是React上下文。React将上下文描述为:</p><blockquote class="oc"><p id="673a" class="od oe iq bd of og oh oi oj ok ol lm dk translated">“上下文提供了一种通过组件树传递数据的方式，而不必在每一级手动向下传递属性。”</p></blockquote><p id="4db3" class="pw-post-body-paragraph kr ks iq kt b ku om jr kw kx on ju kz la oo lc ld le op lg lh li oq lk ll lm ij bi translated">这正是我们全球国家管理所需要的。从使用上下文存储全局状态的顶级组件开始。</p><p id="c78d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，在组件树中的任何地方，您都可以访问和/或更新这个状态。这是像Redux这样的全局状态管理器背后的基本思想。</p><p id="5d48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还记得我们必须将<code class="fe nz oa ob ni b">handleAddItem</code>和<code class="fe nz oa ob ni b">handleRemoveItem</code>方法作为道具传递给子组件吗？让我们重构它，从上下文中获得，而不需要钻取道具。</p><p id="cf86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用React上下文非常简单。它采用以下形式。首先，您创建一个调用<code class="fe nz oa ob ni b">React.createContext()</code>的上下文。这将一个可选的初始值作为参数。</p><p id="68bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，您需要使用<code class="fe nz oa ob ni b">Context.Provider</code>向<em class="ng">提供</em>组件树中某处的上下文，以便下面的组件可以访问它。然后，在任何你想使用上下文的地方，使用<code class="fe nz oa ob ni b">Context.Consumer</code>，它将访问这个值。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="f747" class="nm lw iq ni b gy nn no l np nq">const MyContext = React.createContext(/* initialValue /*)</span><span id="3647" class="nm lw iq ni b gy or no l np nq">&lt;MyContext.Provider value={/* value*/}&gt;<br/>  &lt;MyContext.Consumer&gt;<br/>    { value =&gt; /* components can access the value object */ }<br/>  &lt;/MyContext.Consumer&gt;<br/>&lt;/MyContext.Provider&gt;</span></pre><p id="1187" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">文档中对React上下文做了很好的解释。</p><p id="1b35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从在<code class="fe nz oa ob ni b">contexts/TodoContext.js</code>中为我们的待办事项创建一个新的上下文开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6cdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如下更新<code class="fe nz oa ob ni b">App</code>组件，为我们的组件树提供<code class="fe nz oa ob ni b">TodoContext</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">App.js</p></figure><p id="1ac6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们可以在子组件中使用<code class="fe nz oa ob ni b">TodoContext.Consumer</code>，并访问传递给<code class="fe nz oa ob ni b">TodoContext.Provider</code>的状态值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">Items.js</p></figure><p id="1e58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会注意到，我们在任何需要使用上下文值的地方都重复使用了<code class="fe nz oa ob ni b">TodoContext.Consumer</code>包装器。我们可以使用<code class="fe nz oa ob ni b">useContext()</code>钩子来重构它，使它不那么冗长。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">更新了Items.js以使用useContext</p></figure><p id="c1ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，我们将全局状态存储在<code class="fe nz oa ob ni b">App</code>组件中。这不是一个非常可取的行为，尤其是当我们的待办事项状态变得越来越复杂，而保存全局状态又不完全是<code class="fe nz oa ob ni b">App</code>组件的职责。</p><p id="4868" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，让我们把它移到我们已经创建的<code class="fe nz oa ob ni b">TodoContext</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">contexts/TodoContext.js</p></figure><p id="2cc9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里导出两个函数。一个是<code class="fe nz oa ob ni b">TodoProvider</code>组件，它实际上是一个更高级的组件，将<code class="fe nz oa ob ni b">TodoContext.Provider</code>和一个状态包装在一起。</p><p id="62b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这成为我们的全球商店，我们需要更新<code class="fe nz oa ob ni b">App</code>组件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">我们的App.js要简单得多，不需要todo逻辑。</p></figure><p id="379f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个导出是一个简单的<a class="ae ln" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">定制钩子</a>，包装已经传递了<code class="fe nz oa ob ni b">TodoContext</code>的<code class="fe nz oa ob ni b">useContext</code>钩子。在<code class="fe nz oa ob ni b">Items.js</code>中，需要导入<code class="fe nz oa ob ni b">useTodoContext</code>并替换:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="bf50" class="nm lw iq ni b gy nn no l np nq">const todoContext = useContext(TodoContext);</span></pre><p id="dc78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="933a" class="nm lw iq ni b gy nn no l np nq">const todoContext = useTodoContext();</span></pre><p id="c33b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！现在，我们已经有了一个用React上下文和钩子构建的整洁的全球商店。</p><p id="bc97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">遵循同样的模式，您可以创建新的<code class="fe nz oa ob ni b">ContextProviders</code>，用它包装您的应用程序，然后在您的组件层次结构中的任何地方使用一个定制的<code class="fe nz oa ob ni b">useContext</code>挂钩，将它用作一个存储。现在，请随意休息一下。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="3e71" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">添加减速器和动作</h1><p id="c830" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">接下来的部分很大程度上受到了Redux的启发。如果您不熟悉Redux，请先查看<a class="ae ln" href="https://redux.js.org/introduction/getting-started" rel="noopener ugc nofollow" target="_blank">文档。</a></p><p id="2810" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的状态更新逻辑被定义为<code class="fe nz oa ob ni b">TodoProvider</code>中的函数，这些函数中的每一个都作为引用存储在状态本身中，消费组件可以访问这些函数来更新状态。</p><p id="ec42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照Redux模式，我们可以将<em class="ng">动作</em>和<em class="ng">减速器</em>介绍给我们的状态管理器。我们可以有描述我们的状态发生了什么的动作，以及一个处理与所述动作相对应的状态变化的缩减器。</p><p id="5171" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从创建动作<code class="fe nz oa ob ni b">ADD_TODO</code>、<code class="fe nz oa ob ni b">REMOVE_TODO</code>和<code class="fe nz oa ob ni b">CLEAR_ALL</code>开始。现在，我将在<code class="fe nz oa ob ni b">TodoContext.js</code>文件中添加所有的动作和缩减器。如果这变得太大，请随意将您的代码分成单独的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">用操作和reducer更新了TodoContext.js with</p></figure><p id="8684" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我创建了一些动作和相应的动作创建器，与Redux非常相似。然后，我们有了reducer，它也是一个简单的纯函数，将状态和动作作为参数，并返回更新后的状态。</p><p id="7422" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，在我们的<code class="fe nz oa ob ni b">TodoProvider</code>中，我们将<code class="fe nz oa ob ni b">useState</code>钩子改为<code class="fe nz oa ob ni b">useReducer</code>钩子。它接受一个缩减器和一个初始状态(不像在Redux中，我们将初始状态传递给缩减器，建议将初始状态传递给<code class="fe nz oa ob ni b">useReducer</code>钩子)。</p><p id="94c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由<code class="fe nz oa ob ni b">useReducer</code>返回的两个值是状态本身和一个调度函数，我们可以用它来调度我们的动作。</p><p id="cee7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们的消费者组件想要使用dispatch函数，所以我们将它作为一个值在<code class="fe nz oa ob ni b">TodoProvider</code>中传递。现在，我们已经准备好使用消费者组件的状态和调度动作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">更新了Items.js以使用操作和调度程序</p></figure><p id="cbad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意我是如何从<code class="fe nz oa ob ni b">useTodoContext()</code>中析构了<code class="fe nz oa ob ni b">dispatch</code>方法，并使用它来分派添加待办事项的动作。类似地，我们使用状态值，并将其与相关动作一起调度，以列出待办事项和删除待办事项。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="101a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">使用上下文+挂钩存储实现身份验证</h1><p id="3449" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在我们有了一个可用的全局存储实现，让我们回到我们的主要需求并实现身份验证。</p><p id="eab8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要一个单独的上下文来存储认证细节。因此，我们的全球状态应该是这样的:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="1c62" class="nm lw iq ni b gy nn no l np nq">{<br/>  auth: {<br/>    isLoggedIn: true,<br/>    name: "John",<br/>    error: null,<br/>  },<br/>  todos: []<br/>}</span></pre><p id="59e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要用显示登录页面的基本路由<code class="fe nz oa ob ni b">/</code>和受保护路由<code class="fe nz oa ob ni b">/todos</code>配置路由，如果用户登录，受保护路由将显示待办事项页面。</p><p id="13ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以如下更新我们的组件层次结构。<code class="fe nz oa ob ni b">Todos</code>组件将处理所有待办事项，并驻留在<code class="fe nz oa ob ni b">/todo</code>路由中，该路由将是一个私有路由。如果用户没有登录，他们将被重定向到<code class="fe nz oa ob ni b">/</code>路由，这将呈现<code class="fe nz oa ob ni b">Login</code>组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/6fec070cbb742073f43bcfbfdca63e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mf8IT0ldqkfhQMdq1EUdOQ.png"/></div></div></figure><p id="8eb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，添加<a class="ae ln" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> react-router </a>并设置组件。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="78e7" class="nm lw iq ni b gy nn no l np nq">yarn add react-router-dom</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">components/Todos.js</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">组件/Login.js</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">App.js</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">api/auth.js</p></figure><p id="de62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以遵循用于<code class="fe nz oa ob ni b">TodoContext</code>的相同模式来创建用于认证的<code class="fe nz oa ob ni b">AuthContext</code>，这非常简单明了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">上下文/AuthContext.js</p></figure><p id="7fcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们使用<code class="fe nz oa ob ni b">AuthContext</code>之前，我们需要确保我们在应用程序的顶部提供了它。</p><p id="59ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，让我们用<code class="fe nz oa ob ni b">AuthProvider</code>来包装整个app。同时，我将增强我们的<code class="fe nz oa ob ni b">Greeting</code>组件以使用auth状态并显示一个问候和一个注销按钮。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">App.js</p></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="f194" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">添加登录功能</h1><p id="16ac" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在我们已经配置了授权存储，我们可以开始构建<code class="fe nz oa ob ni b">Login</code>页面的功能了。</p><p id="1f34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在登录页面中，我们需要使用存储来检查用户是否已经登录，如果是，就将他们重定向到<code class="fe nz oa ob ni b">Todos</code>页面。</p><p id="9cfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果没有，我们显示登录表单，并在提交时调用模拟的登录API。如果登录成功，我们可以调度<code class="fe nz oa ob ni b">loginSuccess</code>动作，否则就调度<code class="fe nz oa ob ni b">loginFail</code>动作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="10b9" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">保护路线</h1><p id="9860" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">接下来，让我们将<code class="fe nz oa ob ni b">/todos</code>路由设为私有，这样只有登录的用户才能访问它。任何其他人都需要被重定向回登录页面。</p><p id="cb30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过简单地用一个更高阶的组件包装react-router <code class="fe nz oa ob ni b">Route</code>组件，并在其中使用<code class="fe nz oa ob ni b">AuthContext</code>来决定是呈现路由还是重定向到登录页面来实现这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">components/PrivateRoute.js</p></figure><p id="0191" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以简单地使用<code class="fe nz oa ob ni b">PrivateRoute</code>而不是<code class="fe nz oa ob ni b">Route</code>来使注销用户无法访问任何路由。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="b34e" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="e661" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我们完了。</p><p id="963a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们学习了如何使用上下文和钩子逐步构建一个类似Redux的存储，您可以在下一个项目中使用它作为Redux的一个简单和轻量级的替代方案。</p><p id="c119" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在接下来的步骤中，您可以尝试使用store中间件，了解如何组合上下文(类似Redux <code class="fe nz oa ob ni b">combineReducers()</code>)，以及React提供的<a class="ae ln" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">其他挂钩</a>。</p><p id="748f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae ln" href="https://github.com/pubudu-ranasinghe/react-context-example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看完整源代码。</p></div></div>    
</body>
</html>