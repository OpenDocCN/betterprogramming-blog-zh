<html>
<head>
<title>Understanding Kubernetes Deployment Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kubernetes部署策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-kubernetes-deployment-strategies-12535c3cb379?source=collection_archive---------3-----------------------#2020-10-13">https://betterprogramming.pub/understanding-kubernetes-deployment-strategies-12535c3cb379?source=collection_archive---------3-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="438f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">滚动更新、重新创建、倾斜部署、金丝雀部署等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3d6a19defdd79e5f5ed7677a416502cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bG8_rFxX8bRA4xZf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@billjelen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">比尔·杰伦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="97e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>中的部署资源简化了容器部署，它们是使用最多的Kubernetes资源之一。部署管理副本集，并且通过适当地操作它们来产生期望的效果，它们有助于创建多个部署策略。</p><p id="7d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人惊讶的是，部署只有两种策略类型:<code class="fe lv lw lx ly b">RollingUpdate</code>和<code class="fe lv lw lx ly b">Recreate</code>。</p><p id="36d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe lv lw lx ly b">RollingUpdate</code>是默认策略，Kubernetes创建一个新的副本集，并开始缩放新的副本集，同时缩小旧的副本集，但<code class="fe lv lw lx ly b">Recreate</code>策略将旧的副本集缩放到零，并立即创建一个包含所需副本的新副本集。</p><p id="a6a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，这并没有限制Kubernetes进行更高级部署的能力。部署规范中有更多的细粒度控制，可以帮助我们实现多种部署模式和策略。让我们看看可能的场景，何时使用它们，以及它们看起来如何与实际操作的例子。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4bfb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">再创造</h1><p id="3a90" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，有人可能会问为什么有人会使用它，但是相信我，这是有用例的，这也是Kubernetes仍然允许它存在于他们的API中的原因。</p><p id="7c0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下情况下使用<code class="fe lv lw lx ly b">Recreate</code>策略:</p><ul class=""><li id="2635" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">您的应用程序不支持多个版本。</li><li id="f3f1" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">您的Pod上装载了一个ReadWriteOnce卷，您不能与复制副本共享该卷。</li><li id="caa2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">您希望停止处理旧数据，并需要在启动新应用程序之前运行一些先决条件。</li></ul><p id="974a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步理解，让我们用<code class="fe lv lw lx ly b">Recreate</code>策略创建一个NGINX部署:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c1e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新映像，看看副本集会发生什么变化:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="97a9" class="nx mh it ly b gy ny nz l oa ob">kubectl set image deployment/nginx nginx=bharamicrosystems/nginx:v2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7865c86b09386c8ccac0dccb5942e4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/1*WgpPZJpmGp1l7oX9yWMhnQ.gif"/></div></figure><p id="7fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以注意到，旧的副本集立即被设置为0，并且立即创建了一个包含十个副本的新副本集。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="530d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">滚动更新</h1><p id="5bc3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">滚动更新是Kubernetes部署的默认部署策略。但是，不受控制的滚动更新可能不是您想要的。</p><p id="5248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用默认的<code class="fe lv lw lx ly b">RollingUpdate</code>策略创建一个NGINX部署:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e20c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新映像并观察副本集发生了什么变化:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="aeb9" class="nx mh it ly b gy ny nz l oa ob">kubectl set image deployment/nginx nginx=bharamicrosystems/nginx:v2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/25177f7671f625decafb29f4011bc954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/1*F6vpt9MgYsJ7K5zzuw6NhA.gif"/></div></figure><p id="9769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你注意到什么了吗？当新容器准备好时，旧副本集的所需副本减少，而新副本集增加。还值得注意的是，Kubernetes尽最大努力进行滚动更新，而不用担心对现有应用程序的任何破坏。</p><p id="5a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能不希望如此突然的更新，而希望缓慢地推出一个版本，以便我们可以在应用程序推出时遇到问题时回滚它。为此，让我们来看看我们可以使用滚动更新实现的一些策略。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e5dc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">斜坡缓慢滚动</h1><p id="b3c7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们想要在淘汰旧副本的同时缓慢推出新副本时，就需要进行倾斜式部署。我们可以选择一次要推出多少个副本，我们还需要确保在操作过程中没有不可用的单元。</p><p id="5293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用渐变缓慢部署策略完成的上述部署的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="95c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经注意到了，我们已经在<code class="fe lv lw lx ly b">RollingUpdate</code>中添加了<code class="fe lv lw lx ly b">maxSurge=1</code>和<code class="fe lv lw lx ly b">maxUnvailable=0</code>属性。这意味着我们将一次滚动一个单元，没有不可用的单元。因此，在任何给定时间，部署将保持至少10个吊舱。</p><p id="c53b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新一下图片，自己看看:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="be1f" class="nx mh it ly b gy ny nz l oa ob">kubectl set image deployment/nginx nginx=bharamicrosystems/nginx:v2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/211ce5c59345b3df99118fe3c1f9342e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/1*8mJCntq9wUFqzN44Bf3hpw.gif"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d628" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">尽最大努力控制首次展示</h1><p id="980b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经研究了渐变的缓慢推出策略，尽管它确保了您的应用程序是稳定的，但它在推出版本时是缓慢的。如果您的部署包含数百个容器，可能需要很长时间来部署整个版本。此外，您可能已经注意到，在上面的场景中，副本的数量有时会超过10个。</p><p id="0d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这两个问题的一个方法是使用尽最大努力控制展示策略。在这种情况下，我们将只把最大不可用参数指定为我们允许不可用的特定百分比，Kubernetes将尽可能快地处理新容器。我们还将在这种情况下将最大浪涌设置为0，以确保Kubernetes不会旋转超过10个pod副本的任何内容。这是你不能用一种缓慢的推广策略做到的。</p><p id="9fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个最大不可用机架数为20%且无最大激增的部署:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="328e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将映像更新到v2:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="c794" class="nx mh it ly b gy ny nz l oa ob">kubectl set image deployment/nginx nginx=bharamicrosystems/nginx:v2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c3d92bb28de97950ad14ca98741e64c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/1*T1COYmcMR_8kn4WSRQmKug.gif"/></div></figure><p id="5fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，在任何给定的时间点，只有20%的pod从旧的副本集中删除，同时在新的副本集中创建。此外，在任何给定的时间点，当前副本都不会超过10个。这还可以确保在给定时间运行适量的pod，以提供最佳的资源利用率。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d2e9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">蓝绿色部署</h1><p id="0611" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">蓝绿色部署或金丝雀部署确保给定应用程序的两个版本在给定时间运行。您可能希望这样做是为了测试一个新特性，或者您希望在推出整个版本之前保持谨慎。</p><p id="f606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个策略帮助你做金丝雀发布和A/B测试。这导致了最近生产范式测试的激增，成熟的组织正在使用这些特性来了解他们的客户行为。</p><p id="bc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes部署不提供这个特性，因此，我们需要使用Kubernetes服务。</p><p id="f273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个运行nginx:v1的部署。我们不会太担心这里的部署策略，而是尽最大努力控制部署策略:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="338c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将部署暴露给一个名为<code class="fe lv lw lx ly b">nginx</code>的<code class="fe lv lw lx ly b">LoadBalancer</code>服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="60a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等待Kubernetes给<code class="fe lv lw lx ly b">LoadBalancer</code>分配一个外部IP，一旦我们有了外部IP就卷曲它:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="7b8c" class="nx mh it ly b gy ny nz l oa ob">kubectl get svc nginx<br/>EXTERNAL_IP=$(kubectl get svc nginx|grep nginx|awk {'print $4'})<br/>for i in {1..10}<br/>do<br/>curl $EXTERNAL_IP<br/>done</span></pre><p id="a796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会看到十次中有十次我们得到“这是版本1”。</p><p id="16bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设你正在开发一个新版本的nginx:v2，但是只允许20%的流量进入。在这种情况下，我们必须使用以下步骤来准备部署:</p><ol class=""><li id="8978" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu od nj nk nl bi translated">使用相同的标签和两个副本创建另一个部署nginx-v2:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="fed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.将nginx-v1部署缩减到八个副本:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="c3af" class="nx mh it ly b gy ny nz l oa ob">kubectl scale deployment nginx-v1 --replicas=8</span></pre><p id="adf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.现在重新运行curl命令并观察:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="872e" class="nx mh it ly b gy ny nz l oa ob">for i in {1..10}<br/>do<br/>curl $EXTERNAL_IP<br/>done</span></pre><p id="d26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到大约十分之二的请求来自v2。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/554e6add0f4cb843518e24018459a56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2LgiURpRCRB3cut8QktPJg.gif"/></div></div></figure><p id="3a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步将流量迁移到v2，我们可以继续缩小v1部署，扩大v2部署。</p><p id="6580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，Kubernetes只允许您通过创建多个副本来管理蓝绿色部署和Canary发布。尽管如此，如果您希望有细粒度的控制，您可能希望考虑像Istio这样的服务网格。</p><p id="04a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它允许您缓慢迁移流量，并基于百分比进行流量分割，而不管您可能有多少个副本。更多详情请参考<a class="ae ky" href="https://medium.com/better-programming/how-to-manage-traffic-using-istio-on-kubernetes-cd4b96e00b57" rel="noopener">我的Istio系列</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bc78" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f693" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这些是组织通常采用的一些部署策略的子集。您可以有自己的部署方法和策略，而且一如既往，没有唯一正确的方法。</p><p id="2e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>