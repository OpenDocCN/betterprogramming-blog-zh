<html>
<head>
<title>Top 30 Apple Coding Interview Questions (With Solutions)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">30个苹果编码面试问题(附解答)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-30-apple-coding-interview-questions-with-solutions-19990071ebfc?source=collection_archive---------0-----------------------#2021-04-03">https://betterprogramming.pub/top-30-apple-coding-interview-questions-with-solutions-19990071ebfc?source=collection_archive---------0-----------------------#2021-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="899a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过设计、行为、图形问题等，在苹果技术面试中胜出</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/136aab68d41b64238a030ed34520075f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dP8528pkCGPLGqAq51-7qQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fa35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在苹果工作是许多开发人员的梦想——但是准备编码面试并不是一件容易的事情。为了让你的生活更轻松，我们整理了你在苹果公司技术面试中可能遇到的30个面试问题。</p><p id="df54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从软件工程面试流程的概述开始，然后通过深入的代码解决方案和复杂性度量来分解苹果面试中的主要问题。我们将用C++提供我们的解决方案。</p><p id="0ffd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">本指南一览:</strong></p><ul class=""><li id="0d23" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">苹果面试流程概述</li><li id="0255" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">数组和图形问题</li><li id="f0fe" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">链接列表问题</li><li id="fc81" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">树木问题</li><li id="6754" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">字符串问题</li><li id="f49a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">动态规划问题</li><li id="4917" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">数学、统计和回溯</li><li id="501a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">搜索和设计问题</li><li id="6901" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">行为问题</li><li id="ade6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">准备面试的技巧</li></ul><h1 id="37c6" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">苹果面试流程概述</h1><p id="acc0" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">苹果公司的软件工程师面试流程与其他大型科技公司不同，因为他们举行的面试次数和现场流程不同。</p><p id="aa60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你被邀请去苹果面试，流程通常是这样的:</p><ul class=""><li id="a6cf" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la iu">与招聘人员进行预筛选:</strong>从提交简历到第一次联系大约需要一周时间。招聘人员通常会通过LinkedIn或电子邮件联系，安排时间打电话。这个电话屏幕将持续15-30分钟，问题不会过于专业。你可能会问类似<em class="nf">你为什么想为苹果工作？</em>或<em class="nf">你最喜欢的苹果产品或服务是什么？</em></li><li id="6538" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">通常一周后，他们会安排你的下一次技术电话面试。会有一两个技术电话屏幕，询问你的简历和一个关于数据结构和算法的编码问题。编码面试大约45-60分钟，其中30分钟用于完成挑战。</li><li id="b499" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">现场面试:</strong>现场面试大约持续六个小时。你将会见8-12名苹果员工，面试将包括行为、领域知识和编码挑战。每次面试大约45分钟到一个小时，你会遇到一些技术问题。行为问题对招聘经理来说也非常重要。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="18bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">你应该知道的数据结构:</strong>数组、链表、栈、队列、树、图、堆、哈希集、哈希映射</p><p id="142a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">你应该知道的算法:</strong>深度优先搜索、广度优先搜索、二分搜索法、快速排序、归并排序、动态规划、分治</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a983" class="mi mj it bd mk ml nn mn mo mp no mr ms jz np ka mu kc nq kd mw kf nr kg my mz bi translated">数组和图形问题</h1><h2 id="68a3" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">确定三个整数的和</h2><p id="8a57" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是确定三个整数的和是否等于给定值。</p><p id="f1ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给定一个整数数组和一个值，确定数组中是否有任意三个整数的和等于给定值。</p><p id="a021" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑这个数组和目标和:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/ca7a195439216c213106c17d432c15d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igjvYEUS-x1oNzwVjR_o5w.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="29e8" class="ns mj it og b gy ok ol l om on">bool find_sum_of_two(vector&lt;int&gt;&amp; A, int val,<br/>  size_t start_index) {<br/>  for (int i = start_index, j = A.size() - 1; i &lt; j;) {<br/>    int sum = A[i] + A[j];<br/>    if (sum == val) {<br/>      return true;<br/>    }</span><span id="d575" class="ns mj it og b gy oo ol l om on">if (sum &lt; val) {<br/>      ++i;<br/>    } else {<br/>      --j;<br/>    }<br/>  }</span><span id="f6ca" class="ns mj it og b gy oo ol l om on">return false;<br/>}</span><span id="864f" class="ns mj it og b gy oo ol l om on">bool find_sum_of_three_v3(vector&lt;int&gt; arr,<br/>  int required_sum) {</span><span id="ad79" class="ns mj it og b gy oo ol l om on">std::sort(arr.begin(), arr.end());</span><span id="2b18" class="ns mj it og b gy oo ol l om on">for (int i = 0; i &lt; arr.size() - 2; ++i) {<br/>    int remaining_sum = required_sum - arr[i];<br/>    if (find_sum_of_two(arr, remaining_sum, i + 1)) {<br/>      return true;<br/>    }<br/>  }</span><span id="0e61" class="ns mj it og b gy oo ol l om on">return false;<br/>}</span><span id="379d" class="ns mj it og b gy oo ol l om on">int main(){<br/>    vector&lt;int&gt; arr = {-25, -10, -7, -3, 2, 4, 8, 10};<br/>  <br/>    cout&lt;&lt;"-8: " &lt;&lt;find_sum_of_three_v3(arr, -8)&lt;&lt;endl; <br/>    cout&lt;&lt;"-25: "&lt;&lt;find_sum_of_three_v3(arr, -25)&lt;&lt;endl;<br/>    cout&lt;&lt;"0: " &lt;&lt;find_sum_of_three_v3(arr, 0)&lt;&lt;endl;<br/>    cout&lt;&lt;"-42: " &lt;&lt;find_sum_of_three_v3(arr, -42)&lt;&lt;endl; <br/>    cout&lt;&lt;"22: " &lt;&lt;find_sum_of_three_v3(arr, 22)&lt;&lt;endl; <br/>    cout&lt;&lt;"-7: " &lt;&lt;find_sum_of_three_v3(arr, -7)&lt;&lt;endl;<br/>    cout&lt;&lt;"-3: " &lt;&lt;find_sum_of_three_v3(arr, -3)&lt;&lt;endl; <br/>    cout&lt;&lt;"2: " &lt;&lt;find_sum_of_three_v3(arr, 2)&lt;&lt;endl; <br/>    cout&lt;&lt;"4: " &lt;&lt;find_sum_of_three_v3(arr, 4)&lt;&lt;endl; <br/>    cout&lt;&lt;"8: " &lt;&lt;find_sum_of_three_v3(arr, 8)&lt;&lt;endl; <br/>    cout&lt;&lt;"7: " &lt;&lt;find_sum_of_three_v3(arr, 7)&lt;&lt;endl; <br/>    cout&lt;&lt;"1: " &lt;&lt;find_sum_of_three_v3(arr, 1)&lt;&lt;endl;<br/>  <br/>    return 0;<br/>}</span></pre><p id="e2e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个解决方案中，我们对<a class="ae op" href="https://www.educative.io/blog/data-structures-arrays-javascript-tutorial" rel="noopener ugc nofollow" target="_blank">数组</a>进行排序。然后，固定一个元素<code class="fe oq or os og b">e</code>并在剩余的数组中找到一对(a，b)使得<code class="fe oq or os og b">required_sum - e</code>是<code class="fe oq or os og b">a + b</code>。</p><p id="01a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从数组中的第一个元素<code class="fe oq or os og b">e</code>开始，尝试在剩余的数组(即<code class="fe oq or os og b">A[i + 1]</code>到<code class="fe oq or os og b">A[n - 1]</code>)中找到这样一个满足条件:<code class="fe oq or os og b">a+b = required_sum - e</code>的对(a，b)。如果找到了对，就找到了解:<code class="fe oq or os og b">a</code>、<code class="fe oq or os og b">b</code>、<code class="fe oq or os og b">e</code>。现在我们可以停止迭代了。</p><p id="a670" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">否则，我们对<code class="fe oq or os og b">index i = 1</code>到<code class="fe oq or os og b">n - 3</code>的所有元素<code class="fe oq or os og b">e</code>重复上述步骤，直到找到满足条件的一对。</p><p id="b3cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>二次，O(n)</p><p id="4964" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，O(1)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="ec72" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">合并重叠间隔</h2><p id="3fd5" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">本练习的目标是合并给定列表中所有重叠的区间，以生成一个只有互斥区间的列表。</p><p id="20c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>您有一个区间对的数组(列表)作为输入，其中每个区间都有一个开始和结束时间戳，按开始时间戳排序。合并重叠的间隔并返回一个新的输出数组。</p><p id="2677" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑下面的输入数组。间隔<code class="fe oq or os og b">(1, 5)</code>、<code class="fe oq or os og b">(3, 7)</code>、<code class="fe oq or os og b">(4, 6)</code>、<code class="fe oq or os og b">(6, 8)</code>重叠，应合并为一个间隔<code class="fe oq or os og b">(1, 8)</code>。同样，区间<code class="fe oq or os og b">(10, 12)</code>和<code class="fe oq or os og b">(12, 15)</code>也是重叠的，应该合并到<code class="fe oq or os og b">(10, 15)</code>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/2510a731e56c6a881e223e4777739805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrMSs5uggLB_XhXaptBBnA.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d512" class="ns mj it og b gy ok ol l om on">class Pair{<br/>  public:<br/>    int first, second;<br/>    Pair(int x, int y){<br/>      first = x;<br/>      second = y; <br/>    }<br/>};</span><span id="30ef" class="ns mj it og b gy oo ol l om on">vector&lt;Pair&gt; merge_intervals(vector&lt;Pair&gt;&amp; v) {</span><span id="0757" class="ns mj it og b gy oo ol l om on">if(v.size() == 0) {<br/>    return v;<br/>  }</span><span id="1ec6" class="ns mj it og b gy oo ol l om on">vector&lt;Pair&gt; result;<br/>  result.push_back(Pair(v[0].first, v[0].second));</span><span id="6059" class="ns mj it og b gy oo ol l om on">for(int i = 1 ; i &lt; v.size(); i++){<br/>    int x1 = v[i].first;<br/>    int y1 = v[i].second;<br/>    int x2 = result[result.size() - 1].first;<br/>    int y2 = result[result.size() - 1].second;</span><span id="1e68" class="ns mj it og b gy oo ol l om on">if(y2 &gt;= x1){<br/>      result[result.size() - 1].second = max(y1, y2);<br/>    }<br/>    else{<br/>      result.push_back(Pair(x1, y1));<br/>    }<br/>  }<br/>  return result;<br/>}</span><span id="4940" class="ns mj it og b gy oo ol l om on">int main() {<br/>  vector&lt;Pair&gt; v {<br/>                  Pair(1, 5),<br/>                  Pair(3, 7),<br/>                  Pair(4, 6),<br/>                  Pair(6, 8),<br/>                  Pair(10, 12),<br/>                  Pair(11, 15)<br/>                  };</span><span id="6dfa" class="ns mj it og b gy oo ol l om on">vector&lt;Pair&gt; result = merge_intervals(v);<br/>  <br/>  for(int i = 0; i &lt; result.size(); i++){<br/>    cout &lt;&lt; "[" &lt;&lt; result[i].first &lt;&lt; ", " &lt;&lt; result[i].second &lt;&lt; "] ";<br/>  }<br/>}</span></pre><p id="51fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题可以用线性扫描算法解决。给出了输入区间的列表，我们将在输出列表中保留合并的区间。对于输入列表中的每个间隔:</p><ul class=""><li id="0c2a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如果输入间隔与输出列表中的最后一个间隔重叠，请合并这两个间隔，并用合并后的间隔更新输出列表的最后一个间隔。</li><li id="cfb3" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">否则，向输出列表添加一个输入间隔。</li></ul><p id="bbeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em></p><p id="c570" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="c17d" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">克隆一个有向图</h2><p id="de08" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">本练习的目标是克隆一个有向图，并使用哈希表和深度优先遍历打印一个输出图。</p><p id="0ed8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给定一个<a class="ae op" href="https://www.educative.io/blog/data-structures-101-graphs-javascript#types" rel="noopener ugc nofollow" target="_blank">有向图</a>的根节点，通过创建深度副本克隆该图。克隆的图形将具有相同的顶点和边。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/8fd3831ca36ef17753e8b09774cd0517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEKDdsluwicoATQRpgpvNA.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8b6a" class="ns mj it og b gy ok ol l om on">struct Node {<br/>  int data;<br/>  list&lt;Node*&gt; neighbors;<br/>  Node(int d) : data(d) {}<br/>};</span><span id="0e64" class="ns mj it og b gy oo ol l om on">Node* clone_rec(Node* root, <br/>        unordered_map&lt;Node*, <br/>        Node*&gt;&amp; nodes_completed) {<br/>  <br/>  if (root == nullptr) {<br/>    return nullptr;<br/>  }</span><span id="0a88" class="ns mj it og b gy oo ol l om on">Node* pNew = new Node(root-&gt;data);<br/>  nodes_completed[root] = pNew;<br/>  <br/>  for (Node* p : root-&gt;neighbors) {<br/>    <br/>    auto x = nodes_completed.find(p);<br/>    <br/>    if (x == nodes_completed.end()){<br/>      pNew-&gt;neighbors.push_back(clone_rec(p, nodes_completed));<br/>    } else {<br/>      pNew-&gt;neighbors.push_back(x-&gt;second /*value*/);<br/>    }<br/>  }<br/>  <br/>  return pNew;<br/>}</span><span id="df85" class="ns mj it og b gy oo ol l om on">Node* clone(Node* root) {<br/>  unordered_map&lt;Node*, Node*&gt; nodes_completed;<br/>  return clone_rec(root, nodes_completed);<br/>}</span><span id="0b20" class="ns mj it og b gy oo ol l om on">// this is un-directed graph i.e.<br/>// if there is an edge from x to y<br/>// that means there must be an edge from y to x<br/>// and there is no edge from a node to itself<br/>// hence there can maximim of (nodes * nodes - nodes) / 2 edgesin this graph<br/>void create_test_graph_undirected(int nodes, int edges, vector&lt;Node*&gt;&amp; vertices) {<br/>  for (int i = 0; i &lt; nodes; ++i) {<br/>    vertices.push_back(new Node(i));<br/>  }</span><span id="7c8c" class="ns mj it og b gy oo ol l om on">vector&lt;pair&lt;int, int&gt;&gt; all_edges;<br/>  for (int i = 0; i &lt; vertices.size(); ++i) {<br/>    for (int j = i + 1; j &lt; vertices.size(); ++j) {<br/>      all_edges.push_back(pair&lt;int, int&gt;(i, j));<br/>    }<br/>  }</span><span id="8a72" class="ns mj it og b gy oo ol l om on">std::random_shuffle(all_edges.begin(), all_edges.end());</span><span id="fbea" class="ns mj it og b gy oo ol l om on">for (int i = 0; i &lt; edges &amp;&amp; i &lt; all_edges.size(); ++i) {<br/>    pair&lt;int, int&gt;&amp; edge = all_edges[i];<br/>    vertices[edge.first]-&gt;neighbors.push_back(vertices[edge.second]);<br/>    vertices[edge.second]-&gt;neighbors.push_back(vertices[edge.first]);<br/>  }<br/>}</span><span id="a9c0" class="ns mj it og b gy oo ol l om on">void print_graph(vector&lt;Node*&gt;&amp; vertices) {<br/>  for (Node* n : vertices) {<br/>    cout &lt;&lt; n-&gt;data &lt;&lt; ": {";<br/>    for (Node* t : n-&gt;neighbors) {<br/>      cout &lt;&lt; t-&gt;data &lt;&lt; " ";<br/>    }<br/>    cout &lt;&lt; "}" &lt;&lt; endl;<br/>  }<br/>}</span><span id="c6fe" class="ns mj it og b gy oo ol l om on">void print_graph(Node* root, unordered_set&lt;Node*&gt;&amp; visited_nodes) {<br/>  if (root == nullptr || visited_nodes.find(root) != visited_nodes.end()) {<br/>    return;<br/>  }</span><span id="4433" class="ns mj it og b gy oo ol l om on">visited_nodes.insert(root);</span><span id="2c80" class="ns mj it og b gy oo ol l om on">cout &lt;&lt; root-&gt;data &lt;&lt; ": {";<br/>  for (Node* n : root-&gt;neighbors) {<br/>    cout &lt;&lt; n-&gt;data &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; "}" &lt;&lt; endl;<br/>  for (Node* n : root-&gt;neighbors) {<br/>    print_graph(n, visited_nodes);<br/>  }<br/>}</span><span id="9467" class="ns mj it og b gy oo ol l om on">void print_graph(Node* root) {<br/>  unordered_set&lt;Node*&gt; visited_nodes;<br/>  print_graph(root, visited_nodes);<br/>}</span><span id="f9a1" class="ns mj it og b gy oo ol l om on">int main() {<br/>  vector&lt;Node*&gt; vertices;<br/>  create_test_graph_undirected(7, 18, vertices);<br/>  <br/>  print_graph(vertices[0]);</span><span id="2373" class="ns mj it og b gy oo ol l om on">Node* cp = clone(vertices[0]);<br/>  cout &lt;&lt; endl &lt;&lt; "After copy" &lt;&lt; endl;<br/>  print_graph(cp);<br/>  <br/>  return 0;<br/>}</span></pre><p id="a6ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用深度优先遍历，并在遍历图时创建每个节点的副本。使用一个哈希表来存储每个完成的节点，这样我们就不会重新访问哈希表中存在的节点。hashtable键将是原始图中的一个节点，它的值将是克隆图中相应的节点。</p><p id="10e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p><p id="43f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>对数，<em class="nf"> O </em> ( <em class="nf"> n </em>)，其中<em class="nf"> n </em>为图中顶点的个数。</p><h1 id="7593" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">链接列表问题</h1><h2 id="4d5c" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">将两个整数相加</h2><p id="d2aa" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是将两个链表中的两个整数相加。</p><p id="3921" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给你两个链表的头指针，每个链表代表一个整数(即每个节点是一个数字)。添加它们并返回新的链表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/a170b5eca66af33e79a3bba41b6eb4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buNJLfifrBUzjF1iQL5nFw.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="98a0" class="ns mj it og b gy ok ol l om on">// assuming both integers are stored in a linked list<br/>// e.g. 415 is stored as 5-&gt;1-&gt;4<br/>// 32 is stored as 2-&gt;3<br/>LinkedListNode* add_integers(<br/>    LinkedListNode* integer1, <br/>    LinkedListNode* integer2) {</span><span id="585e" class="ns mj it og b gy oo ol l om on">LinkedListNode* result = nullptr;<br/>  LinkedListNode* last = nullptr;<br/>  int carry = 0;<br/>  <br/>  while (<br/>      integer1 != nullptr ||<br/>      integer2 != nullptr ||<br/>      carry &gt; 0) {</span><span id="1fe3" class="ns mj it og b gy oo ol l om on">int first = <br/>        (integer1 == nullptr ? 0 : integer1-&gt;data);<br/>    int second = <br/>        (integer2 == nullptr ? 0 : integer2-&gt;data);</span><span id="8a06" class="ns mj it og b gy oo ol l om on">int sum = first + second + carry;</span><span id="eb41" class="ns mj it og b gy oo ol l om on">LinkedListNode* pNew = <br/>          new LinkedListNode(sum % 10);<br/>    <br/>    carry = sum / 10;</span><span id="e3c6" class="ns mj it og b gy oo ol l om on">if (result == nullptr) {<br/>      result = pNew;<br/>    } else {<br/>      last-&gt;next = pNew;<br/>    }</span><span id="3d1e" class="ns mj it og b gy oo ol l om on">last = pNew;<br/>    <br/>    if (integer1 != nullptr) {<br/>      integer1 = integer1-&gt;next;<br/>    }<br/>    <br/>    if (integer2 != nullptr) {<br/>      integer2 = integer2-&gt;next;<br/>    }<br/>  }<br/>  <br/>  return result;<br/>}</span><span id="7320" class="ns mj it og b gy oo ol l om on">int main(int argc, char* argv[]) {<br/> vector&lt;int&gt; v1 = {1, 2, 3}; // 321<br/>  vector&lt;int&gt; v2 = {1, 2}; // 21<br/>  <br/>  LinkedListNode* first = LinkedList::create_linked_list(v1);<br/>  LinkedListNode* second = LinkedList::create_linked_list(v2);</span><span id="aefc" class="ns mj it og b gy oo ol l om on">// sum should be 321 + 21 = 342 =&gt; 2-&gt;4-&gt;3<br/>  LinkedListNode* result = add_integers(first, second);<br/>  vector&lt;int&gt; r = {2, 4, 3}; // 342<br/>  LinkedListNode* expected = LinkedList::create_linked_list(r);<br/>  assert(LinkedList::is_equal(result, expected));</span><span id="c985" class="ns mj it og b gy oo ol l om on">cout &lt;&lt; endl &lt;&lt; "First:";<br/>  LinkedList::display(first);<br/>  cout &lt;&lt; endl &lt;&lt; "Second:";<br/>  LinkedList::display(second);<br/>  cout &lt;&lt; endl &lt;&lt; "Result:";<br/>  LinkedList::display(result);</span><span id="8bc5" class="ns mj it og b gy oo ol l om on">result = add_integers(first, nullptr);<br/>  assert(LinkedList::is_equal(result, first));</span><span id="058a" class="ns mj it og b gy oo ol l om on">result = add_integers(nullptr, second);<br/>  assert(LinkedList::is_equal(result, second));<br/>}</span></pre><p id="532a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了更好地理解这一点，让我们考虑一个例子。假设我们想把整数9901和237相加。相加的结果是10138。</p><p id="853e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整数在链表中是倒序存储的，这样更容易。数字的最高有效位是链表的最后一个元素。要开始添加，我们从两个链表的头部开始。</p><p id="e9a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每次迭代中，我们将两个列表的当前数字相加，并在结果链表的尾部插入一个新节点，结果数字位于结果链表的尾部。我们还需要保持每一步的进位。</p><p id="85c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们对两个链表中的所有数字都这样做。如果其中一个链表结束得更快，我们将继续另一个链表。一旦两个链表都完成，并且没有进位留下来添加，算法将终止。</p><p id="decd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p><p id="7970" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="7780" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">合并两个排序的链表</h2><p id="e82a" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是合并两个排序的<a class="ae op" href="https://www.educative.io/blog/data-structures-linked-list-java-tutorial" rel="noopener ugc nofollow" target="_blank">链表</a>。</p><p id="cf05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给定两个已排序的链表，合并它们，这样得到的链表也是已排序的。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="51ac" class="ns mj it og b gy ok ol l om on">typedef LinkedListNode* NodePtr;</span><span id="6386" class="ns mj it og b gy oo ol l om on">NodePtr merge_sorted(NodePtr head1, NodePtr head2) {<br/>  <br/>  // if both lists are empty then merged list is also empty<br/>  // if one of the lists is empty then other is the merged list<br/>  if (head1 == nullptr) {<br/>    return head2;<br/>  } else if (head2 == nullptr) {<br/>    return head1;<br/>  }</span><span id="a2c1" class="ns mj it og b gy oo ol l om on">NodePtr mergedHead = nullptr;<br/>  if (head1-&gt;data &lt;= head2-&gt;data) {<br/>    mergedHead = head1;<br/>    head1 = head1-&gt;next;<br/>  } else {<br/>    mergedHead = head2;<br/>    head2 = head2-&gt;next;<br/>  }</span><span id="c1b0" class="ns mj it og b gy oo ol l om on">NodePtr mergedTail = mergedHead;<br/>  <br/>  while (head1 != nullptr &amp;&amp; head2 != nullptr) {<br/>    NodePtr temp = nullptr;<br/>    if (head1-&gt;data &lt;= head2-&gt;data) {<br/>      temp = head1;<br/>      head1 = head1-&gt;next;<br/>    } else {<br/>      temp = head2;<br/>      head2 = head2-&gt;next;<br/>    }</span><span id="a5db" class="ns mj it og b gy oo ol l om on">mergedTail-&gt;next = temp;<br/>    mergedTail = temp;<br/>  }</span><span id="751f" class="ns mj it og b gy oo ol l om on">if (head1 != nullptr) {<br/>    mergedTail-&gt;next = head1;<br/>  } else if (head2 != nullptr) {<br/>    mergedTail-&gt;next = head2;<br/>  }</span><span id="d586" class="ns mj it og b gy oo ol l om on">return mergedHead;<br/>}</span><span id="56d0" class="ns mj it og b gy oo ol l om on">void test(vector&lt;int&gt;&amp; v1, vector&lt;int&gt;&amp; v2, vector&lt;int&gt;&amp; expected) {<br/>  LinkedListNode* list_head1 = LinkedList::create_linked_list(v1);<br/>  <br/>  cout&lt;&lt;"List 1: "&lt;&lt;LinkedList::getList(list_head1)&lt;&lt;endl;</span><span id="ea8e" class="ns mj it og b gy oo ol l om on">LinkedListNode* list_head2 = LinkedList::create_linked_list(v2);<br/>  <br/>  cout&lt;&lt;"List 2: "&lt;&lt;LinkedList::getList(list_head2)&lt;&lt;endl;</span><span id="117f" class="ns mj it og b gy oo ol l om on">LinkedListNode* merged = merge_sorted(list_head1, list_head2);<br/>  <br/>  cout&lt;&lt;"Result: "&lt;&lt;LinkedList::getList(merged)&lt;&lt;endl;</span><span id="3e8a" class="ns mj it og b gy oo ol l om on">LinkedListNode* expected_list = LinkedList::create_linked_list(expected);</span><span id="abc6" class="ns mj it og b gy oo ol l om on">assert(LinkedList::is_equal(merged, expected_list));<br/>}</span><span id="d768" class="ns mj it og b gy oo ol l om on">int main(int argc, char* argv[]) {</span><span id="d384" class="ns mj it og b gy oo ol l om on">vector&lt;int&gt; v1 = {1, 3, 5, 6};<br/>  vector&lt;int&gt; v2 = {2, 4, 6, 20, 34};<br/>  vector&lt;int&gt; expected = {1, 2, 3, 4, 5, 6, 6, 20, 34};</span><span id="ae09" class="ns mj it og b gy oo ol l om on">test(v1, v2, expected);</span><span id="d37e" class="ns mj it og b gy oo ol l om on">v1 = {1, 3, 5, 6};<br/>  v2 = {};<br/>  expected = {1, 3, 5, 6};</span><span id="0f78" class="ns mj it og b gy oo ol l om on">test(v1, v2, expected);</span><span id="a547" class="ns mj it og b gy oo ol l om on">v1 = {1, 3, 5, 6};<br/>  v2 = {2, 4, 6, 20};<br/>  expected = {1, 2, 3, 4, 5, 6, 6, 20};</span><span id="94cc" class="ns mj it og b gy oo ol l om on">test(v1, v2, expected);<br/>  v1 = {4, 4};<br/>  v2 = {4, 4, 4};<br/>  expected = {4, 4, 4, 4 ,4};</span><span id="4447" class="ns mj it og b gy oo ol l om on">test(v1, v2, expected);<br/>}</span></pre><p id="bef9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在合并的链表上保持一个头指针和一个尾指针。通过比较两个链表的第一个节点来选择合并链表的头。</p><p id="be6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于所有后续节点，选择较小的当前节点，并将其链接到合并列表的尾部。将列表的当前指针向前移动一步。</p><p id="40df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果只有一个列表中还有一些元素，将剩余的列表链接到合并列表的尾部。最初，合并的链表是<code class="fe oq or os og b">NULL</code>。</p><p id="f2e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比较前两个节点的值，将值较小的节点作为合并链表的头节点。在这个例子中，从<code class="fe oq or os og b">head1</code>开始是4。因为它是合并列表中的第一个也是唯一的节点，所以它将是尾部。然后向前移动<code class="fe oq or os og b">head1</code>一步。</p><p id="1045" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf">O</em>(<em class="nf">m</em>+<em class="nf">n</em>)，其中<em class="nf"> m </em>和n是我们链表的长度</p><p id="88cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，<em class="nf">O</em>①</p><h1 id="d5fe" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">树木问题</h1><h2 id="ccf3" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">确定两个二叉树是否相同</h2><p id="cfe3" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">本练习的目标是比较两个<a class="ae op" href="https://www.educative.io/blog/data-structures-trees-java" rel="noopener ugc nofollow" target="_blank">二叉树</a>以确定它们是否相同。</p><p id="83d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给你两个二叉树的根，你必须确定这两棵树是否相同。相同的树在每个节点上具有相同的布局和数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/cf33b8332aecf495ee5d44021329612d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rhtEc8pAvbk4CQxOjShEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提示:拥有相同数据的树不一定完全相同。重要的是它们的结构。</p></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="25fb" class="ns mj it og b gy ok ol l om on">bool are_identical(<br/>  BinaryTreeNode* root1,<br/>  BinaryTreeNode* root2) {</span><span id="10c6" class="ns mj it og b gy oo ol l om on">if (root1 == nullptr &amp;&amp; root2 == nullptr) {<br/>    return true;<br/>  }<br/>  <br/>  if (root1 != nullptr &amp;&amp; root2 != nullptr) {<br/>    return ((root1-&gt;data == root2-&gt;data) &amp;&amp;<br/>            are_identical(root1-&gt;left, root2-&gt;left) &amp;&amp;<br/>            are_identical(root1-&gt;right, root2-&gt;right));<br/>  }</span><span id="99d3" class="ns mj it og b gy oo ol l om on">return false;<br/>}</span><span id="898a" class="ns mj it og b gy oo ol l om on">int main() {<br/>  BinaryTreeNode *root1 = new BinaryTreeNode(100);<br/>  insert_bst(root1, 50);<br/>  insert_bst(root1, 200);<br/>  insert_bst(root1, 25);<br/>  insert_bst(root1, 125);<br/>  insert_bst(root1, 350);</span><span id="808b" class="ns mj it og b gy oo ol l om on">display_level_order(root1);<br/>  <br/>  BinaryTreeNode *root2 = create_random_BST(15);</span><span id="07fe" class="ns mj it og b gy oo ol l om on">display_level_order(root2);<br/>  <br/>  // Try changing the roots being passed<br/>  if(are_identical(root1, root2)) {<br/>    cout&lt;&lt; " the trees are identical" &lt;&lt; endl;<br/>  } else {<br/>    cout&lt;&lt; "the trees are not identical" &lt;&lt; endl;<br/>  }<br/>}</span></pre><p id="faed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题可以递归解决。这个解决方案的递归的基本情况是如果两个被比较的节点为空或者其中一个为空。</p><p id="3845" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两棵树<code class="fe oq or os og b">A</code>和<code class="fe oq or os og b">B</code>是相同的，如果:</p><ul class=""><li id="90cf" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">它们的根上的数据相同，或者两个根都为空</li><li id="8903" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oq or os og b">A</code>的左子树与<code class="fe oq or os og b">B</code>的左子树相同</li><li id="992b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oq or os og b">A</code>的右子树与<code class="fe oq or os og b">B</code>的右子树相同</li></ul><p id="2b20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时在两棵树上使用深度优先遍历，并不断比较每一层的数据来解决这个问题。</p><p id="03ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p><p id="6a04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">内存复杂度:最好的情况下为</strong> <em class="nf"> O </em> ( <em class="nf"> h </em>)，或者平衡树的情况下为<em class="nf"> O </em> ( <em class="nf"> logn </em>)，最坏的情况下可以为<em class="nf"> O </em> ( <em class="nf"> n </em>)。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="016f" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">镜像二叉树节点</h2><p id="32eb" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">本练习的目标是使用深度优先遍历和自底向上镜像来镜像二叉树的节点。</p><p id="398d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给你一个二叉树的根节点，你必须交换每个节点的<code class="fe oq or os og b">left</code>和<code class="fe oq or os og b">right</code>子节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/1e1cbb39aa75fb33dd7403017355fb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPR8xsNNTRuX5DWYYkHy0Q.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="2660" class="ns mj it og b gy ok ol l om on">void mirror_tree(BinaryTreeNode* root) {<br/>  if (root == nullptr) {<br/>    return;<br/>  }</span><span id="d8d0" class="ns mj it og b gy oo ol l om on">// We will do a post-order traversal of the binary tree.</span><span id="2821" class="ns mj it og b gy oo ol l om on">if (root-&gt;left != nullptr) {<br/>    mirror_tree(root-&gt;left);<br/>  }</span><span id="d471" class="ns mj it og b gy oo ol l om on">if (root-&gt;right != nullptr) {<br/>    mirror_tree(root-&gt;right);<br/>  }</span><span id="d849" class="ns mj it og b gy oo ol l om on">// Let's swap the left and right nodes at current level.</span><span id="5c70" class="ns mj it og b gy oo ol l om on">BinaryTreeNode* temp = root-&gt;left;<br/>  root-&gt;left = root-&gt;right;<br/>  root-&gt;right = temp;<br/>}</span><span id="6e79" class="ns mj it og b gy oo ol l om on">int main(int argc, char* argv[]) {</span><span id="ca8c" class="ns mj it og b gy oo ol l om on">BinaryTreeNode* root = create_random_BST(15);<br/>  display_level_order(root);<br/>  mirror_tree(root);<br/>  cout &lt;&lt; endl &lt;&lt; "Mirrored tree = " &lt;&lt; endl;<br/>  display_level_order(root);<br/>}</span></pre><p id="e753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们对二叉树进行后序遍历。对于每个节点，将其左子节点与其右子节点交换。我们在树上使用<a class="ae op" href="https://www.educative.io/blog/tree-traversal-algorithms#how" rel="noopener ugc nofollow" target="_blank">DFS</a>——这样在从一个节点返回之前，它的所有子节点都已经被访问过(并被镜像)。</p><p id="8a66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p><p id="3c0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，最坏情况下<em class="nf"> O </em> ( <em class="nf"> n </em>)</p><h1 id="1afd" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">字符串问题</h1><h2 id="20af" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">查找所有回文子字符串</h2><p id="44be" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是找到给定字符串的回文子字符串。</p><p id="bfea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给定一个字符串，找出所有为回文的非单字母子串。给出的字符串是<code class="fe oq or os og b">"aabbbaa"</code>。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1466" class="ns mj it og b gy ok ol l om on">int find_palindromes_in_sub_string(const string&amp; input, int j, int k) {<br/>  int count = 0;<br/>  for (; j &gt;= 0 &amp;&amp; k &lt; input.length(); --j, ++k) {<br/>    if (input[j] != input[k]) {      <br/>      break;<br/>    } <br/>    cout &lt;&lt; input.substr(j, k - j + 1) &lt;&lt; endl;<br/>    ++count;<br/>  }<br/>  return count;<br/>}</span><span id="c0dd" class="ns mj it og b gy oo ol l om on">int find_all_palindrome_substrings(const string&amp; input) {<br/>  int count = 0;<br/>  for (int i = 0; i &lt; input.length(); ++i) {    <br/>    count += find_palindromes_in_sub_string(input, i - 1, i + 1);<br/>    count += find_palindromes_in_sub_string(input, i, i + 1);<br/>  }<br/>  return count;<br/>}</span><span id="b8b4" class="ns mj it og b gy oo ol l om on">int main() {<br/>  string str = "aabbbaa";</span><span id="4de3" class="ns mj it og b gy oo ol l om on">cout &lt;&lt; "Total palindrome substrings: "  &lt;&lt; find_all_palindrome_substrings(str) &lt;&lt; endl;<br/>}</span></pre><p id="3d11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于输入字符串中的每个字母，开始向左和向右扩展，同时检查偶数和奇数长度的回文。如果我们知道一个回文不存在，就移到下一个字母。</p><p id="14c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们向左和向右扩展一个字符并进行比较。如果两者相等，我们打印出回文子串。</p><p id="0445" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>多项式，O(n)</p><p id="f60b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，O(1)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="eed1" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">颠倒句子中的单词</h2><p id="0755" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是颠倒给定字符串中的单词。一定要注意单词是如何被空格分开的。</p><p id="4ef2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>反转给定句子中的单词顺序(字符数组)。给出的词是<code class="fe oq or os og b">"Hello World!"</code>。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="ae03" class="ns mj it og b gy ok ol l om on">void str_rev(char * str, int len) {</span><span id="59e2" class="ns mj it og b gy oo ol l om on">if (str == nullptr || len &lt; 2) {<br/>    return;<br/>  }</span><span id="9494" class="ns mj it og b gy oo ol l om on">char * start = str;<br/>  char * end = str + len - 1;</span><span id="3fcb" class="ns mj it og b gy oo ol l om on">while (start &lt; end) {<br/>    if (start != nullptr &amp;&amp; end != nullptr) {<br/>      char temp = * start;<br/>      * start = * end;<br/>      * end = temp;<br/>    }<br/>    start++;<br/>    end--;<br/>  }<br/>}</span><span id="ec13" class="ns mj it og b gy oo ol l om on">void reverse_words(char * sentence) {</span><span id="3972" class="ns mj it og b gy oo ol l om on">// Here sentence is a null-terminated string ending with char '\0'.</span><span id="850f" class="ns mj it og b gy oo ol l om on">if (sentence == nullptr) {<br/>    return;<br/>  }</span><span id="ded3" class="ns mj it og b gy oo ol l om on">// To reverse all words in the string, we will first reverse<br/>  // the string. Now all the words are in the desired location, but<br/>  // in reverse order: "Hello World" -&gt; "dlroW olleH".</span><span id="c7c9" class="ns mj it og b gy oo ol l om on">int len = strlen(sentence);<br/>  str_rev(sentence, len);</span><span id="7a43" class="ns mj it og b gy oo ol l om on">// Now, let's iterate the sentence and reverse each word in place.<br/>  // "dlroW olleH" -&gt; "World Hello"</span><span id="2f2d" class="ns mj it og b gy oo ol l om on">char * start = sentence;<br/>  char * end;<br/>  while (true) {<br/>    // find the  start index of a word while skipping spaces.<br/>    while (start &amp;&amp; * start == ' ') {<br/>      ++start;<br/>    }</span><span id="a50d" class="ns mj it og b gy oo ol l om on">if (start == nullptr || * start == '\0') {<br/>      break;<br/>    }</span><span id="6a11" class="ns mj it og b gy oo ol l om on">// find the end index of the word.<br/>    end = start + 1;<br/>    while (end &amp;&amp; * end != '\0' &amp;&amp; * end != ' ') {<br/>      ++end;<br/>    }</span><span id="c70f" class="ns mj it og b gy oo ol l om on">// let's reverse the word in-place.</span><span id="8615" class="ns mj it og b gy oo ol l om on">if (end != nullptr) {<br/>      str_rev(start, (end - start));<br/>    }</span><span id="0863" class="ns mj it og b gy oo ol l om on">start = end;<br/>  }<br/>}</span><span id="4c3a" class="ns mj it og b gy oo ol l om on">int main() {</span><span id="f245" class="ns mj it og b gy oo ol l om on">  string str = "Hello World!";<br/>  char* a = const_cast&lt;char*&gt;(str.c_str());</span><span id="bd55" class="ns mj it og b gy oo ol l om on">cout &lt;&lt; a &lt;&lt; endl;<br/>  reverse_words(a);<br/>  cout &lt;&lt; a &lt;&lt; endl;<br/>}</span></pre><p id="311f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题有两个步骤。首先，反转弦。然后，遍历字符串，将每个单词颠倒过来。</p><p id="8c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p><p id="4cb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，<em class="nf"> O </em> (1)</p><h1 id="84dd" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">动态规划问题</h1><h2 id="3e62" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">最大和子阵列</h2><p id="7e77" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是使用你的<a class="ae op" href="https://www.educative.io/blog/6-dp-problems-to-solve-for-your-next-coding-interview" rel="noopener ugc nofollow" target="_blank">动态编程</a>技能和Kadane的算法找到最大和子阵列。</p><p id="968b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>求最大和子数组。在下面的数组中，最大和子数组从索引<code class="fe oq or os og b">3</code>开始，到<code class="fe oq or os og b">6</code>结束，最大和为<code class="fe oq or os og b">12</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/4bc487a4dca9b2911526b1348cd1cc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJ0vo-gqZMHeGWOu3HKwiQ.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="2e44" class="ns mj it og b gy ok ol l om on">int find_max_sum_sub_array(int A[], int n) {<br/>  if (n &lt; 1) {<br/>    return 0;<br/>  }<br/>  <br/>  int curr_max = A[0];<br/>  int global_max = A[0];<br/>  for (int i = 1; i &lt; n; ++i) {<br/>    if (curr_max &lt; 0) {<br/>      curr_max = A[i];<br/>    } else {<br/>      curr_max += A[i];<br/>    }</span><span id="e623" class="ns mj it og b gy oo ol l om on">if (global_max &lt; curr_max) {<br/>      global_max = curr_max;<br/>    }<br/>  }</span><span id="9354" class="ns mj it og b gy oo ol l om on">return global_max;<br/>}</span><span id="95dd" class="ns mj it og b gy oo ol l om on">int main() {<br/>    <br/>    int v[] = {-4, 2, -5, 1, 2, 3, 6, -5, 1};<br/>    cout &lt;&lt; "Sum of largest subarray: " &lt;&lt; find_max_sum_sub_array(v, sizeof(v) / sizeof(v[0])) &lt;&lt; endl;<br/>    return 0;<br/>  }</span></pre><p id="3f70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用Kadane的算法来解决这个问题。该算法的基本思想是扫描整个阵列，并在每个位置找到结束于此的子阵列的最大和。这是通过为当前数组索引保留一个<code class="fe oq or os og b">current_max</code>和一个<code class="fe oq or os og b">global_max</code>来实现的。</p><p id="aaa6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">算法如下:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="9c0b" class="ns mj it og b gy ok ol l om on">current_max = A[0]<br/>global_max = A[0]<br/>for i = 1 -&gt; size of A<br/>    if current_max is less than 0<br/>        then current_max = A[i]<br/>    otherwise <br/>        current_max = current_max + A[i]<br/>    if global_max is less than current_max <br/>        then global_max = current_max</span></pre><p id="fdb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>线性，<em class="nf"> O </em> ( <em class="nf"> n </em>)</p><p id="0d74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>常数，<em class="nf"> O </em> (1)</p><h1 id="2841" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">数学和统计</h1><h2 id="1b12" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">数的幂</h2><p id="cf3c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是使用<em class="nf">分治</em>并编写一个函数来计算一个数的幂。</p><p id="a578" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给你一个双精度、<code class="fe oq or os og b">x</code>和一个整数<code class="fe oq or os og b">n</code>，写一个函数计算<code class="fe oq or os og b">x</code>的幂<code class="fe oq or os og b">n</code>。</p><p id="8369" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nf">幂</em> (2，5)=32</p><p id="b917" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nf">幂</em> (3，4)=81</p><p id="7470" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nf">幂</em> (1.5，3)=3.375</p><p id="5bdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nf">功率</em> (2，2)=0.25</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="6012" class="ns mj it og b gy ok ol l om on">double power_rec(double x, int n) {<br/>  if (n == 0) return 1;<br/>  if (n == 1) return x;<br/>  <br/>  double temp = power_rec(x, n/2);<br/>  if (n % 2 == 0)  {<br/>    return temp * temp;<br/>  } else {<br/>    return x * temp * temp;<br/>  }<br/>}</span><span id="140e" class="ns mj it og b gy oo ol l om on">double power(double x, int n) {<br/>  bool is_negative = false;<br/>  if (n &lt; 0) {<br/>    is_negative = true;<br/>    n *= -1;<br/>  }</span><span id="4efe" class="ns mj it og b gy oo ol l om on">double result = power_rec(x, n);</span><span id="74ad" class="ns mj it og b gy oo ol l om on">if (is_negative) {<br/>    return 1 / result;<br/>  }</span><span id="42bb" class="ns mj it og b gy oo ol l om on">return result;<br/>}</span><span id="d319" class="ns mj it og b gy oo ol l om on">bool test_power(double x, int n) {<br/>  double r1 = power(0.753, n);<br/>  double r2 = pow(0.753, n);<br/>  double diff = r1 - r2;<br/>  if (diff &lt; 0) {<br/>    diff = diff * -1;<br/>  }<br/>  if (diff &gt; 0.00000000001) {<br/>    cout &lt;&lt; "Failed for " &lt;&lt; x &lt;&lt; ", " &lt;&lt; n &lt;&lt; endl;<br/>    return false;<br/>  }<br/>  return true;<br/>}<br/>int main(int argc, char* argv[]) {<br/>  <br/>  bool pass = true;<br/>  for (int n = -5; n &lt;= 5; ++n) {<br/>    bool temp_pass = test_power(0.753, n);<br/>    pass &amp;= temp_pass;<br/>  }</span><span id="8e06" class="ns mj it og b gy oo ol l om on">pass &amp;= test_power(0, 0);</span><span id="02c1" class="ns mj it og b gy oo ol l om on">cout &lt;&lt; "Power(0, 0) = " &lt;&lt; pow(0, 0) &lt;&lt; endl;</span><span id="8bdf" class="ns mj it og b gy oo ol l om on">if (pass) {<br/>    cout &lt;&lt; "Passed." &lt;&lt; endl;<br/>  } else {<br/>    cout &lt;&lt; "Failed." &lt;&lt; endl;<br/>  }<br/>}</span></pre><p id="ce12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用分而治之的方法来最有效地解决这个问题。在除法步骤中，我们继续递归地用<code class="fe oq or os og b">2</code>除<code class="fe oq or os og b">n</code>，直到我们到达基本情况。</p><p id="6b5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在组合步骤中，我们得到子问题的结果<code class="fe oq or os og b">r</code>，并使用以下两条规则计算当前问题的结果:</p><ul class=""><li id="bdd1" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如果<code class="fe oq or os og b">n</code>是偶数，则结果是<code class="fe oq or os og b">r * r</code>(其中<code class="fe oq or os og b">r</code>是子问题的结果)</li><li id="60b3" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果<code class="fe oq or os og b">n</code>是奇数，结果是<code class="fe oq or os og b">x * r * r</code>(其中<code class="fe oq or os og b">r</code>是子问题的结果)</li></ul><p id="58b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>对数，<em class="nf"> O </em> ( <em class="nf"> logn </em>)</p><p id="fd39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>对数，<em class="nf"> O </em> ( <em class="nf"> logn </em>)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="8758" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">查找所有求和组合</h2><p id="aa34" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是用你的回溯技巧找到所有的和组合。</p><p id="0208" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>给定一个正整数，<code class="fe oq or os og b">target</code>，打印加到<code class="fe oq or os og b">target</code>数上的正整数的所有可能组合。</p><p id="0303" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出将是列表的列表或数组的数组的形式，因为列表中的每个元素将是包含可能的总和组合的另一个列表。例如，如果给你输入<code class="fe oq or os og b">5</code>，这些是可能的总和组合:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="230b" class="ns mj it og b gy ok ol l om on">1, 4<br/>2, 3<br/>1, 1, 3<br/>1, 2, 2<br/>1, 1, 1, 2<br/>1, 1, 1, 1, 1</span></pre><p id="e344" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决方案讨论如下:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d135" class="ns mj it og b gy ok ol l om on">void print(vector&lt;vector&lt;int&gt;&gt; output){<br/>  for(int i = 0; i &lt; output.size(); i++){<br/>    cout &lt;&lt; "[ ";<br/>    for(int j = 0; j &lt; output[i].size(); j++){<br/>      cout &lt;&lt; output[i][j] &lt;&lt; ", "; <br/>    }<br/>    cout &lt;&lt; "]" &lt;&lt; endl;<br/>  }<br/>}</span><span id="252c" class="ns mj it og b gy oo ol l om on">void print_all_sum_rec(<br/>    int target,<br/>    int current_sum,<br/>    int start, vector&lt;vector&lt;int&gt;&gt;&amp; output,<br/>    vector&lt;int&gt;&amp; result) {</span><span id="cd08" class="ns mj it og b gy oo ol l om on">if (target == current_sum) {<br/>    output.push_back(result);<br/>  }</span><span id="d22a" class="ns mj it og b gy oo ol l om on">for (int i = start; i &lt; target; ++i) {<br/>    int temp_sum = current_sum + i;<br/>    if (temp_sum &lt;= target) {<br/>      result.push_back(i);<br/>      print_all_sum_rec(target, temp_sum, i, output, result);<br/>      result.pop_back();</span><span id="1328" class="ns mj it og b gy oo ol l om on">} else {<br/>      return;<br/>    }<br/>  }<br/>}</span><span id="be47" class="ns mj it og b gy oo ol l om on">vector&lt;vector&lt;int&gt;&gt; print_all_sum(int target) {<br/>  vector&lt;vector&lt;int&gt;&gt; output;<br/>  vector&lt;int&gt; result;<br/>  print_all_sum_rec(target, 0, 1, output, result);<br/>  return output;<br/>}</span><span id="921c" class="ns mj it og b gy oo ol l om on">int main(int argc, const char* argv[]) {<br/>  int n = 4;<br/>  vector&lt;vector&lt;int&gt;&gt; result = print_all_sum(n);<br/>  <br/>  print (result);<br/>}</span></pre><p id="eab6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们递归地遍历所有可能的总和组合，当运行总和等于目标时，打印该组合。该算法将递归地检查所有能够加起来达到<code class="fe oq or os og b">target</code>的数字。</p><p id="bae4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每个递归调用中，有一个从<code class="fe oq or os og b">start</code>运行到<code class="fe oq or os og b">target</code>的<code class="fe oq or os og b">for</code>循环，其中<code class="fe oq or os og b">start</code>最初是<code class="fe oq or os og b">1</code>。<code class="fe oq or os og b">current_sum</code>是随着每次递归调用而递增的变量。</p><p id="cd72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次值被添加到<code class="fe oq or os og b">current_sum</code>时，它也被添加到<code class="fe oq or os og b">result</code>列表中。每当<code class="fe oq or os og b">current_sum</code>等于<code class="fe oq or os og b">target</code>时，我们知道<code class="fe oq or os og b">result</code>列表包含了<code class="fe oq or os og b">target</code>的一个可能组合，然后这个列表被追加到最终的<code class="fe oq or os og b">output</code>列表中。以下是一些示例代码:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="c81d" class="ns mj it og b gy ok ol l om on">Base condition of recursion:<br/> <br/>if current_sum equals target<br/>  print the output contents</span></pre><p id="a2f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每次递归调用之前，向<code class="fe oq or os og b">result</code>添加一个元素。但是，每次调用后，这个元素也会从列表中删除，以重置列表。</p><p id="475b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>指数级，O</p><p id="15bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>线性，O(n)</p><h1 id="a3d4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">搜索和设计问题</h1><h2 id="57fa" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">在旋转数组中搜索</h2><p id="616d" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这个练习的目标是在一个循环数组中搜索一个排序数组中的给定数字。试着用二分搜索法解决这个问题。</p><p id="acfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>在一个排序的数组中搜索一个给定的数字，该数组具有唯一的元素，并且已经旋转了某个任意的数字，假设该数组不包含重复的元素。如果号码不存在，返回<code class="fe oq or os og b">-1</code>。</p><p id="f01a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是旋转前的原始数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/06ab08b34741fc2a1fc850c8b5a5497b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHo8YPjEZzIywMLXDR2lPA.png"/></div></div></figure><p id="211b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对该阵列执行六次旋转后，它会变为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/04861d2bcb1f38280f4ff4a5b0d58482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5J4C1Fblh8ECJqMFU6WWOA.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="c59d" class="ns mj it og b gy ok ol l om on">int binary_search(vector&lt;int&gt;&amp; arr, int start, int end, int key) {<br/>  // assuming all the keys are unique.<br/>  <br/>  if (start &gt; end) {<br/>    return -1;<br/>  }</span><span id="e1d4" class="ns mj it og b gy oo ol l om on">int mid = start + (end - start) / 2;</span><span id="11b1" class="ns mj it og b gy oo ol l om on">if (arr[mid] == key) {<br/>    return mid;<br/>  }</span><span id="d445" class="ns mj it og b gy oo ol l om on">if (arr[start] &lt;= arr[mid] &amp;&amp; key &lt;= arr[mid] &amp;&amp; key &gt;= arr[start]) {<br/>    return binary_search(arr, start, mid-1, key);<br/>  }</span><span id="a676" class="ns mj it og b gy oo ol l om on">else if (arr[mid] &lt;= arr[end] &amp;&amp; key &gt;= arr[mid] &amp;&amp; key &lt;= arr[end]) {<br/>    return binary_search(arr, mid+1, end, key);<br/>  }</span><span id="cc4a" class="ns mj it og b gy oo ol l om on">else if (arr[end] &lt;= arr[mid]) {<br/>    return binary_search(arr, mid+1, end, key);<br/>  }</span><span id="3f63" class="ns mj it og b gy oo ol l om on">else if (arr[start] &gt;= arr[mid]) {<br/>    return binary_search(arr, start, mid-1, key);<br/>  }</span><span id="e197" class="ns mj it og b gy oo ol l om on">return -1;<br/>}</span><span id="83b0" class="ns mj it og b gy oo ol l om on">int binary_search_rotated(vector&lt;int&gt;&amp; arr, int key) {<br/>  return binary_search(arr, 0, arr.size()-1, key);<br/>}</span><span id="e110" class="ns mj it og b gy oo ol l om on">int main(int argc, char* argv[]) {<br/>    vector&lt;int&gt; v1 = {6, 7, 1, 2, 3, 4, 5};<br/>  <br/>    cout&lt;&lt;"Key(3) found at: "&lt;&lt;binary_search_rotated(v1, 3)&lt;&lt;endl;<br/>    cout&lt;&lt;"Key(6) found at: "&lt;&lt;binary_search_rotated(v1, 6)&lt;&lt;endl;<br/>    <br/>    vector&lt;int&gt; v2 = {4, 5, 6, 1, 2, 3};<br/>    <br/>    cout&lt;&lt;"Key(3) found at: "&lt;&lt;binary_search_rotated(v2, 3)&lt;&lt;endl;<br/>    cout&lt;&lt;"Key(6) found at: "&lt;&lt;binary_search_rotated(v2, 6)&lt;&lt;endl;    <br/>}</span></pre><p id="e5eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个解决方案就像一个经过一些修改的二分搜索法。请注意，数组中至少有一半总是被排序的。如果数字<code class="fe oq or os og b">n</code>位于数组排序后的一半，那么我们的问题就是一个基本的二分搜索法。否则，丢弃已排序的一半，并检查未排序的一半。</p><p id="1288" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂度:</strong>对数，<em class="nf"> O </em> ( <em class="nf"> logn </em>)</p><p id="3f29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">记忆复杂度:</strong>对数，<em class="nf"> O </em> ( <em class="nf"> logn </em>)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="94f1" class="ns mj it bd mk nt nu dn mo nv nw dp ms lh nx ny mu ll nz oa mw lp ob oc my od bi translated">实现LRU缓存</h2><p id="c478" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">本设计练习的目标是实现最近最少使用(LRU)，这是一种常见的缓存策略，使用双向链表和散列法。</p><p id="ffd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">问题陈述:</strong>最近最少使用(LRU)定义了当缓存已满时从缓存中驱逐元素以便为新元素腾出空间的策略，这意味着它首先丢弃最近最少使用的项目。</p><p id="6bef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以具有四个元素容量的高速缓存为例。我们缓存了元素<code class="fe oq or os og b">1</code>、<code class="fe oq or os og b">2</code>、<code class="fe oq or os og b">3</code>和<code class="fe oq or os og b">4</code>。下图显示了首次访问所有四个元素后的缓存状态:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/889f8f4040d0fd1d3e6e640ae6fa9cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTEkJ1RIzUQjHA7UHpepWw.png"/></div></div></figure><p id="d6d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在需要缓存另一个元素<code class="fe oq or os og b">5</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/73a6d8879f6840d7db10e9678a4b7cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqE6Ir_5mbmbJhw_Y_hk1g.png"/></div></div></figure><p id="0b40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看再次访问<code class="fe oq or os og b">2</code>会发生什么。现在<code class="fe oq or os og b">3</code>成为下一个从缓存中被逐出的队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/234249af84f1051d4b3d2660afc6d86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqPYo8VF--xf5NvVbKS73A.png"/></div></div></figure><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="f0a4" class="ns mj it og b gy ok ol l om on">// Linked list operations<br/>// void add_at_tail(int val)<br/>// void delete_node(ListNode* node)<br/>// void delete_from_head()<br/>// void delete_from_tail()<br/>// ListNode* get_head()<br/>// void set_head(ListNode* node)<br/>// ListNode* get_tail()<br/>// void set_tail(ListNode* node)</span><span id="b770" class="ns mj it og b gy oo ol l om on">// simple single threaded LRUCache<br/>class LRUCache {</span><span id="6414" class="ns mj it og b gy oo ol l om on">unordered_set&lt;int&gt; cache;</span><span id="ec32" class="ns mj it og b gy oo ol l om on">// each entry in linked list is the value of the element<br/>  LinkedList cache_vals;<br/>  int capacity; // total capacity<br/>public:</span><span id="f6ea" class="ns mj it og b gy oo ol l om on">LRUCache(int capacity) {<br/>    this-&gt;capacity = capacity;<br/>  }<br/>  <br/>  ~LRUCache() {<br/>    cache.clear();<br/>  }</span><span id="ad7e" class="ns mj it og b gy oo ol l om on">ListNode* get(int val) {<br/>    auto p = cache.find(val);<br/>    if (p == cache.end()) {<br/>      return nullptr;<br/>    }<br/>    else{<br/>      ListNode* i = cache_vals.get_head();<br/>      while(i != nullptr){<br/>        if (i-&gt;value == val){<br/>          return i;<br/>        }<br/>        i = i-&gt;next;<br/>      }<br/>    }<br/>  }</span><span id="3118" class="ns mj it og b gy oo ol l om on">void set(int value) {<br/>    ListNode* check = get(value);<br/>    if(check == nullptr){<br/>      if(cache.size() &gt;= capacity){<br/>        cache_vals.add_at_tail(value);<br/>        int head_val = cache_vals.get_head()-&gt;value;<br/>        cache.erase(head_val);<br/>        cache_vals.delete_from_head();<br/>      }<br/>      else{<br/>        cache_vals.add_at_tail(value);<br/>        cache.insert(value);<br/>      }<br/>    }<br/>    else{<br/>      if(check == cache_vals.get_tail()){<br/>        return;<br/>      }<br/>      if(check == cache_vals.get_head()){<br/>        cache_vals.add_at_tail(check-&gt;value);<br/>        cache_vals.delete_from_head();<br/>        return;<br/>      }<br/>      if(check-&gt;prev != nullptr){<br/>        check-&gt;prev-&gt;next = check-&gt;next;<br/>      }<br/>      if(check-&gt;next != nullptr){<br/>        check-&gt;next-&gt;prev = check-&gt;prev;<br/>      }<br/>      cache_vals.add_at_tail(check-&gt;value);<br/>      delete check;<br/>    }<br/>  }</span><span id="be18" class="ns mj it og b gy oo ol l om on">void print() {<br/>    ListNode* i = cache_vals.get_head();<br/>      while(i != nullptr){<br/>        cout &lt;&lt; i-&gt;value &lt;&lt; ", ";<br/>        i = i -&gt;next;<br/>      }<br/>    cout &lt;&lt; endl;<br/>  }<br/>};</span><span id="558a" class="ns mj it og b gy oo ol l om on">int main(int argc, char const *argv[])<br/>{<br/>  LRUCache cache(4);<br/>  cache.set(1);<br/>  cache.print();</span><span id="c643" class="ns mj it og b gy oo ol l om on">cache.set(2);<br/>  cache.print();</span><span id="77d8" class="ns mj it og b gy oo ol l om on">cache.set(3);<br/>  cache.print();</span><span id="8cb3" class="ns mj it og b gy oo ol l om on">cache.set(4);<br/>  cache.print();</span><span id="b656" class="ns mj it og b gy oo ol l om on">cache.set(5);<br/>  cache.print();</span><span id="8894" class="ns mj it og b gy oo ol l om on">cache.set(2);<br/>  cache.print();</span><span id="f0e0" class="ns mj it og b gy oo ol l om on">return 0;<br/>}</span></pre><p id="5f9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缓存是一种将数据存储在更快的存储器(通常是RAM)中以更快地满足未来请求的技术。缓存存储通常不够大，无法存储完整的数据集。当缓存变满时，我们需要从缓存中清除数据。</p><p id="ecfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这个过程，LRU是一个非常简单和常用的算法。我们从缓存中清除最旧的数据，以容纳新数据。</p><p id="a900" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现LRU缓存，我们使用了两种数据结构:一个<strong class="la iu">哈希表和一个双向链表</strong>。双向链表有助于维护驱逐顺序，散列表有助于O(1) <em class="nf"> O </em> (1)查找缓存的键。算法是这样的:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="276e" class="ns mj it og b gy ok ol l om on">If the element exists in hashmap<br/>    move the accessed element to the tail of the linked list<br/>Otherwise,<br/>    if eviction is needed i.e. cache is already full<br/>        Remove the head element from doubly linked list and delete its hashmap entry<br/>    Add the new element at the tail of linked list and in hashmap<br/>Get from Cache and Return</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="10ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>双向链表用于跟踪最近访问的元素。双向链表尾部的元素是最近访问的元素。</p><p id="7436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有新插入的元素都放在尾部，任何被访问的元素都放在尾部。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="6512" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行时复杂性:</strong></p><ul class=""><li id="8286" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oq or os og b">get (hashset)</code>:常数，O(1)</li><li id="1709" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oq or os og b">set (hashset)</code>:常数，O(1)</li><li id="346c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">添加新元素时删除头部:常量，O(1)</li><li id="a23d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">搜索删除和添加到尾部:线性，O(n)</li></ul><p id="26b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">内存复杂度:</strong>线性，O(n)，其中<em class="nf"> n </em>是缓存的大小</p><h1 id="e87e" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">行为问题</h1><p id="5149" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">既然我们已经讨论了最重要的技术问题，让我们来看看你在苹果面试中可能遇到的最常见的行为面试问题，这些问题对你的成功同样重要。</p><p id="ea3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你将从这个列表中看到的，苹果想了解你是哪种类型的思考者，你如何处理冲突，以及你带来了哪些投资。</p><ol class=""><li id="3cc9" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt pf ma mb mc bi translated">在过去的四年里，你有过哪些最美好和最糟糕的日子？</li><li id="d4e8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">你最喜欢的苹果产品或服务是什么，为什么？</li><li id="2ca7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">描述一个你特别自豪的成就。</li><li id="d528" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">你曾经和你的经理在工作决策上有过分歧吗？发生了什么事？你是如何处理这种情况的？</li><li id="8bbf" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">你是如何战胜失败的？你从中学到了什么？</li><li id="7da5" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">你为什么想去苹果工作？</li><li id="0701" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">走进苹果专卖店，你注意到的第一件事是什么？</li><li id="ac97" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">描述你面临的最具挑战性的软件开发问题。你是怎么解决的？</li><li id="bafd" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">如果你接受了苹果公司的一份工作，你会最想念你现在这个职位的什么？你最不会错过什么？</li><li id="11df" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">工作之外，你有没有采取任何措施来提高自己的技能？</li><li id="62b7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">描述一次你为客户付出的努力。</li><li id="f327" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">向一个8岁的孩子解释什么是调制解调器/路由器及其功能。</li><li id="856d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">这个角色如何融入你的五年职业生涯或人生计划？</li><li id="0bea" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">如果我们雇用你，你想做什么？</li><li id="65ee" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">你会如何测试你最喜欢的应用程序？</li><li id="2649" class="lu lv it la b lb md le me lh mf ll mg lp mh lt pf ma mb mc bi translated">如果一个人打电话寻求技术支持，但他有一个过时的或传统的产品，你会如何处理？</li></ol></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="2777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提示:</strong>无论是什么问题或职位，都建议使用STAR方法来回答基于行为的面试问题:</p><ul class=""><li id="7e29" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">描述一下情况。</li><li id="d04f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">描述任务。</li><li id="3aa9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">描述处理任务所采取的行动。</li><li id="c5ce" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">说明你取得的成果。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0b28" class="mi mj it bd mk ml nn mn mo mp no mr ms jz np ka mu kc nq kd mw kf nr kg my mz bi translated">准备面试的技巧</h1><p id="6c71" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">为面试而练习需要大量的时间和耐心，而且没有破解编码面试的金科玉律。但是这些年来我们学到了一些最佳实践。</p><ul class=""><li id="9f32" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la iu">用不同的工具练习。</strong>最好将白板练习、在线课程和模拟面试结合起来，以充分利用您的时间。当你解决问题时，练习大声说话是至关重要的，这样你就可以使用不同种类的工具进行练习。</li><li id="1d6a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">制定学习计划。</strong>还建议制定一份3-6个月的详细准备计划。这样，你就有了一个可以遵循的结构，避免遗漏重要的概念。</li><li id="446e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">避免死记硬背。</strong>也建议避免背题。相反，通过构建苹果可能使用的真实产品来练习。这是准备面试的理想方式:你学习相同的概念，练习解决问题，并获得为苹果公司实际建立的信心。</li></ul><p id="8f2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。</p><p id="b48c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">祝你面试好运！</p></div></div>    
</body>
</html>