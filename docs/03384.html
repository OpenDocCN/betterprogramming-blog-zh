<html>
<head>
<title>New MVC: Single Responsibility Principle and Delegation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新MVC:单一责任原则和委托</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/this-is-how-you-implement-mvc-architecture-in-2020-b39d65b4212f?source=collection_archive---------10-----------------------#2020-02-06">https://betterprogramming.pub/this-is-how-you-implement-mvc-architecture-in-2020-b39d65b4212f?source=collection_archive---------10-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0294" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在你的iOS应用中实现MVC的不同方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b1db1c5a9032afee5539570c88ca461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AUL5WYu8r9Yhp8yb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ripato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">里卡多·戈麦斯·安吉尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="27ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周末，我正在修补iOS应用程序中正确的MVC架构实现的想法。听到许多开发人员抱怨Apple建议的设计模式，我决定提出自己的解决方案，试图解决这些常见问题:</p><ul class=""><li id="f2ea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">臭名昭著的“海量视图控制器”</li><li id="205f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">职责划分模糊。</li><li id="3c9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">控制器和视图之间的紧密耦合。</li><li id="4d19" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个几乎什么都不做的愚蠢而简单的模型。</li></ul><p id="dda3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了与<a class="ae ky" href="https://medium.com/better-programming/implement-a-model-view-presenter-architecture-in-swift-5-dfa21bbb8e0b" rel="noopener"> MVP </a>、<a class="ae ky" href="https://medium.com/better-programming/reactive-mvvm-and-the-coordinator-pattern-done-right-88248baf8ca5" rel="noopener"> MVVM </a>和<a class="ae ky" href="https://medium.com/better-programming/how-to-implement-viper-architecture-in-your-ios-app-rest-api-and-kingfisher-f494a0891c43" rel="noopener"> VIPER </a>的实践经验，我可以看到一种改进MVC设计模式的方法，记住这些架构的细微差别。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f624" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">我们开始吧</h1><p id="7acb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们来看看这张图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d99be4533b9e17c4f7655d1b3dcfc18c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LuQV4SSWFEJLGtXxEnI1g.png"/></div></div></figure><p id="7a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想的MVC应该是这样实现的。我们可以清楚地看到，每个组件执行自己独特的任务，然后向另一个组件发送消息来执行不同的任务，循环往复。总的来说，它代表了双向数据流:</p><ul class=""><li id="ec9a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">View</code>向<code class="fe no np nq nr b">Controller</code>发送用户动作。</li><li id="4879" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">Controller</code>告诉<code class="fe no np nq nr b">Model</code>根据用户动作执行某个任务。</li><li id="4711" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">Model</code>将任务结果转发回<code class="fe no np nq nr b">Controller</code>。</li><li id="cff7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">Controller</code>将可显示的结果发送回<code class="fe no np nq nr b">View</code>，后者用新数据刷新自己。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ef77" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">示例项目</h1><p id="e533" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">示例项目是一个简单的应用程序，允许您向列表中添加项目，在<code class="fe no np nq nr b">UITableView</code>中显示它们，并使用<a class="ae ky" href="https://github.com/realm/realm-cocoa" rel="noopener ugc nofollow" target="_blank">领域数据库</a>对它们执行<code class="fe no np nq nr b">Create</code>、<code class="fe no np nq nr b">Read</code>和<code class="fe no np nq nr b">Delete</code>操作。</p><p id="e8d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用的源代码可在GitHub 上<a class="ae ky" href="https://github.com/zafarivaev/MVC-Delegates" rel="noopener ugc nofollow" target="_blank">获得。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/bc58cf5e0d44652579ca31125ac2e62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGl3jz7kwIcZlEPjjPFpyQ.jpeg"/></div></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="178c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">项目结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/034ed630c4956bce95f086ebd86f3879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*iPY0hZST9Z9t4j0xTlLbwA.png"/></div></figure><p id="6b4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">项目的根分为三个文件夹:<code class="fe no np nq nr b">App</code>、<code class="fe no np nq nr b">Modules</code>和<code class="fe no np nq nr b">Supporting Files</code>。<code class="fe no np nq nr b">App</code>包含<code class="fe no np nq nr b">AppDelegate.swift</code>文件，而<code class="fe no np nq nr b">Supporting Files</code>文件夹有<code class="fe no np nq nr b">Assets.xcassets</code>、<code class="fe no np nq nr b">LaunchScreen.storyboard</code>和一个<code class="fe no np nq nr b">Info.plist</code>。这里我们主要关注的是<code class="fe no np nq nr b">Modules</code>文件夹。</p><p id="a458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个模块的组成如下:</p><ul class=""><li id="cab8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">Contract</code>有一个包含<code class="fe no np nq nr b">View</code>、<code class="fe no np nq nr b">Controller</code>和<code class="fe no np nq nr b">Model</code>符合的四个协议的文件。每个协议定义了<code class="fe no np nq nr b">Model</code>、<code class="fe no np nq nr b">View</code>和<code class="fe no np nq nr b">Controller</code>的职责。</li><li id="5d37" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">View</code>包含了从<code class="fe no np nq nr b">UIView</code>继承而来的所有UI元素。它所做的只是执行其子视图的布局，等待<code class="fe no np nq nr b">Controller</code>的新数据响应，然后用该数据刷新自己。</li><li id="3d3f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">Controller</code>包含一个<code class="fe no np nq nr b">UIViewController</code>子类，它是<code class="fe no np nq nr b">View</code>和<code class="fe no np nq nr b">Model</code>之间的中介。它的职责是通过触发<code class="fe no np nq nr b">Model</code>中的相关方法来响应UI事件，从<code class="fe no np nq nr b">Model</code>接收结果，然后将其转换为UI可显示的格式并发送回<code class="fe no np nq nr b">View</code>。</li><li id="ca3b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">Model</code>包含简单对象，负责对它们执行操作。它并没有假设这些对象将如何被转换为视图中的布局。在它完成一个需要的操作之后，比如从数据库中获取，它将原始结果发送给<code class="fe no np nq nr b">Controller</code>。</li></ul><p id="63a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清楚了这一点，让我们在实践中探索架构。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9631" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">项目合同</h1><p id="1f0b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们定义四个协议来描述<code class="fe no np nq nr b">Model</code>、<code class="fe no np nq nr b">View</code>和<code class="fe no np nq nr b">Controller</code>将遵循的所有规则:</p><h2 id="ce22" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemsContract.swift</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="30b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是对每个协议的详细描述:</p><ul class=""><li id="b66c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsViewInput</code>包含了<code class="fe no np nq nr b">ItemsView</code>为了响应用户动作或其生命周期事件而触发的方法。<code class="fe no np nq nr b">ItemsViewController</code>会遵守这个协议。</li><li id="7923" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsControllerInput</code>拥有将运行的方法来响应<code class="fe no np nq nr b">ItemsViewInput</code>。例如，当一个<code class="fe no np nq nr b">View</code>加载时，它触发<code class="fe no np nq nr b">onViewLayout()</code>方法，这导致<code class="fe no np nq nr b">Controller</code>触发<code class="fe no np nq nr b">retrieveItems()</code>方法。<code class="fe no np nq nr b">ItemsModel</code>将符合本协议。</li><li id="9f80" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsModelOutput</code>由方法组成，当<code class="fe no np nq nr b">ItemsModel</code>完成其任务时将被触发。例如，当运行<code class="fe no np nq nr b">retrieveItems()</code>方法并获取项目时，它运行<code class="fe no np nq nr b">onItemsRetrieval(<strong class="lb iu">_</strong> items: Results&lt;Item&gt;)</code>方法，将原始结果发送回<code class="fe no np nq nr b">ItemsViewController</code>。<code class="fe no np nq nr b">ItemsViewController</code>将符合本协议。</li><li id="db45" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsControllerOutput</code>有一些方法，当<code class="fe no np nq nr b">ItemsViewController</code>接收到来自<code class="fe no np nq nr b">ItemsModel</code>的结果并将其转换成适合<code class="fe no np nq nr b">ItemsView</code>显示的格式时，这些方法将被调用。<code class="fe no np nq nr b">ItemsView</code>将符合本协议。</li></ul><p id="847c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe no np nq nr b">Controller</code>有对<code class="fe no np nq nr b">View</code>和<code class="fe no np nq nr b">Model</code>的强引用，而<code class="fe no np nq nr b">View</code>和<code class="fe no np nq nr b">Model</code>都有一个<code class="fe no np nq nr b">weak</code>控制器属性。这样我们可以避免潜在的内存泄漏。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b04f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">应用委托</h1><p id="8126" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们为<code class="fe no np nq nr b">window</code>创建并设置<code class="fe no np nq nr b">rootViewController</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b518" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">项目视图</h1><p id="92b7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们在这里创建所有的UI元素。</p><h2 id="8020" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemsView.swift</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是当视图为<code class="fe no np nq nr b">layout</code>时，我们如何向控制器发送消息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们仔细看看<code class="fe no np nq nr b">ItemsControllerOutput</code>协议一致性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前所写的，当<code class="fe no np nq nr b">ItemsModel</code>向其发送特定结果时，这些方法将在<code class="fe no np nq nr b">ItemsViewController.swift</code>文件中被触发。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fc25" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">ItemsViewController</h1><p id="c0ed" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里要符合两个协议:<code class="fe no np nq nr b">ItemsViewInput</code>和<code class="fe no np nq nr b">ItemsModelOutput</code>。我们将通过<code class="fe no np nq nr b">ItemsViewInput</code>接收用户动作，在<code class="fe no np nq nr b">ItemsModel</code>中调用需要的方法，然后通过<code class="fe no np nq nr b">ItemsModelOutput</code>接收结果。</p><h2 id="9787" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemsViewController.swift</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="4e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将控制器的<code class="fe no np nq nr b">view</code>属性分配给<code class="fe no np nq nr b">ItemsView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来探索如何处理用户操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="427f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，当用户点击“添加”工具栏按钮时，<code class="fe no np nq nr b">ItemsView</code>触发<code class="fe no np nq nr b">onAddTap</code>方法，该方法向<code class="fe no np nq nr b">ItemsViewController</code>发送信号以显示警告。或者，当点击警报上的“保存”按钮时，<code class="fe no np nq nr b">ItemsViewController</code>告诉<code class="fe no np nq nr b">ItemsModel</code>将带有标题的项目保存在<code class="fe no np nq nr b">Realm</code>数据库中。</p><p id="1e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们如何处理<code class="fe no np nq nr b">Model</code>的操作结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="01d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">onItemsRetrieval</code>方法是结果转换并将其转发给视图的一个例子。我们从<code class="fe no np nq nr b">ItemsModel</code>接收一个项目对象列表，将其转换成一个<code class="fe no np nq nr b">String</code>的数组，并将该数组发送给<code class="fe no np nq nr b">ItemsView</code>。</p><p id="e26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">onUUIDRetrieval</code>方法也有意思。在这里，我们不希望<code class="fe no np nq nr b">ItemsView</code>做任何事情。我们所关心的是导航到显示所选项目的<code class="fe no np nq nr b">title</code>的新屏幕。我们简单地构建一个新模块，并将<code class="fe no np nq nr b">ItemDetailViewController</code>推送到导航栈中。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ec39" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">项目模型</h1><p id="f883" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们需要在这里创建一个<code class="fe no np nq nr b">Item</code>对象，并提供使用它的方法。</p><h2 id="824b" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">Item.swift</h2><p id="4e9a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">代表一个简单的<code class="fe no np nq nr b">Realm</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="2862" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemModel.swift</h2><p id="7a8c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是所有与<code class="fe no np nq nr b">Item</code>互动的地方:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="bb5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe no np nq nr b">ItemsModel</code>负责获取、添加和删除项目。每个任务完成后，它调用<code class="fe no np nq nr b">ItemsViewController</code>中的一个相关方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="f79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有以下工作流程:</p><ul class=""><li id="6a09" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsView</code>加载并触发<code class="fe no np nq nr b">layoutSubviews()</code>方法。</li><li id="f1eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsView</code>谓<code class="fe no np nq nr b">controller?.onViewLayout()</code>。</li><li id="a94b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsViewController</code>通话<code class="fe no np nq nr b">itemsModel?.retrieveItems()</code>。</li><li id="1502" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsModel</code>从<code class="fe no np nq nr b">Realm</code>数据库中检索商品，然后调用<code class="fe no np nq nr b">controller?.onItemsRetrieval()</code>，将商品属性作为参数传入。</li><li id="2dd1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsViewController</code>将<code class="fe no np nq nr b">items</code>转换为<code class="fe no np nq nr b">String</code>的数组，然后调用<code class="fe no np nq nr b">itemsView?.onItemsRetrieval()</code>作为参数传入标题数组。</li><li id="de3b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">ItemsView</code>通过分配titles属性并重新加载<code class="fe no np nq nr b">tableView</code>来对<code class="fe no np nq nr b">onItemsRetrieval()</code>方法中的新数据做出反应。</li></ul><p id="31f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们已经完成了<code class="fe no np nq nr b">Items</code>模块。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="41a6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">项目详细信息</h1><p id="0939" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里的实现非常相似。</p><h2 id="6f98" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemDetailContract.swift</h2><p id="1a8f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如前所述，我们为我们<code class="fe no np nq nr b">ItemDetailView</code>、<code class="fe no np nq nr b">ItemDetailViewController</code>和<code class="fe no np nq nr b">ItemDetailModel</code>定义了四个协议以符合:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="16ef" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemDetailView.swift</h2><p id="4b38" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">类似于我们在<code class="fe no np nq nr b">ItemsView</code>中所做的，这里<code class="fe no np nq nr b">ItemDetailView</code>使用<code class="fe no np nq nr b">onItemRetrieval</code>方法等待<code class="fe no np nq nr b">ItemsDetailViewController</code>的ss响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="0033" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemDetailViewController.swift</h2><p id="eb61" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">等待<code class="fe no np nq nr b">ItemDetailView</code>输入和<code class="fe no np nq nr b">ItemDetailModel</code>输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="b680" class="nu mr it bd ms nv nw dn mw nx ny dp na li nz oa nc lm ob oc ne lq od oe ng of bi translated">ItemDetailModel.swift</h2><p id="618c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe no np nq nr b">Model</code>接收<code class="fe no np nq nr b">Controller</code>的命令，进行取物，然后将结果返回给<code class="fe no np nq nr b">Controller</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2e62" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">包扎</h1><p id="d8c0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">因此，我们将应用内部的职责划分为三个部分:</p><ul class=""><li id="3bf3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe no np nq nr b">View</code>发送用户动作，并根据<code class="fe no np nq nr b">Controller</code>的响应更新自身。</li><li id="d234" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">Controller</code>接收<code class="fe no np nq nr b">View</code>输入，并根据该输入告诉<code class="fe no np nq nr b">Model</code>做什么，之后接收<code class="fe no np nq nr b">Model</code>响应，将其转换为适合视图的格式，并将其发送回<code class="fe no np nq nr b">View</code>。</li><li id="5ce8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe no np nq nr b">Model</code>执行所需的业务逻辑任务，将原始结果发送回<code class="fe no np nq nr b">Controller</code>。</li></ul><p id="4e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，要设置一个新模块，我们必须重复一些步骤。为此，我创建了一个Xcode文件模板来生成MVC模块。如何将其添加到Xcode的说明在本报告的<code class="fe no np nq nr b">README.md</code>文件中有所描述:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/zafarivaev/MVC-Delegates-Template" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">zafarivaev/MVC-代表-模板</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">用于生成MVC模块的Xcode文件模板。通过创建…为zafarivaev/MVC-Delegates-模板开发做出贡献</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><p id="03e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对不同的建筑模式感兴趣，请随意查看我的其他相关作品:</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/reactive-mvvm-and-the-coordinator-pattern-done-right-88248baf8ca5" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">反应式MVVM和协调模式做对了</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用Swift 5、RxSwift和RxDataSources</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/implement-a-model-view-presenter-architecture-in-swift-5-dfa21bbb8e0b" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在Swift 5中实施模型-视图-演示者架构</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用领域数据库作为业务逻辑层</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/how-to-implement-viper-architecture-in-your-ios-app-rest-api-and-kingfisher-f494a0891c43" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何使用Swift 5在您的iOS应用中实现VIPER架构</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用方便的Xcode模板和参考报告</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/better-programming/implement-a-service-oriented-architecture-in-swift-5-fc70b8117616" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">在Swift 5中实施面向服务的架构</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">为什么只用MVC/MVVM/蝰蛇还不够</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pd l ow ox oy ou oz ks ol"/></div></div></a></div><p id="1612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>