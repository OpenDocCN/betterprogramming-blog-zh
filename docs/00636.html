<html>
<head>
<title>iOS 13 — Is Your App Ready for the Dark?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 13——你的应用准备好迎接黑暗了吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-13-is-your-app-ready-for-the-dark-6aa73adec14b?source=collection_archive---------0-----------------------#2019-06-22">https://betterprogramming.pub/ios-13-is-your-app-ready-for-the-dark-6aa73adec14b?source=collection_archive---------0-----------------------#2019-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9f4da347a1319b84feb05c07d27d655e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZd4f-Ue_371jvq8eC_xgQ.jpeg"/></div></div></figure><div class=""/><h1 id="2fa0" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">关于本教程</h1><p id="9673" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">黑暗主题在晚上对你的眼睛很好，是有机发光二极管屏幕上的电池节电器，除此之外，它在大多数应用程序中看起来都很棒。</p><p id="b46e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为你的应用程序使用黑暗模式并不困难，尽管它可能需要几天时间，这取决于你拥有的UI元素的数量和屏幕的数量。</p><p id="6e50" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了有效地做到这一点，您需要了解这个特性是如何工作的，以及如何处理棘手的问题。</p><p id="7557" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在本教程中，我将解释特征集合如何与界面样式相关，什么是动态颜色和图像，以及如何处理向后兼容性。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="1d23" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">这一切都始于特质收集</h1><p id="0db8" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">苹果在iOS 8中引入了<code class="fe mo mp mq mr b">traitCollection</code>属性，以解决iPad和iPhone设备上的通用应用程序。</p><p id="2869" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe mo mp mq mr b">traitCollection</code>属性是<a class="ae ms" href="https://developer.apple.com/documentation/uikit/uitraitcollection" rel="noopener ugc nofollow" target="_blank">ui termination</a>协议的一部分，该协议被几个类采用，分别是<a class="ae ms" href="https://developer.apple.com/documentation/uikit/uiscreen" rel="noopener ugc nofollow" target="_blank"> UIScreen </a>、<a class="ae ms" href="https://developer.apple.com/documentation/uikit/uiwindow" rel="noopener ugc nofollow" target="_blank"> UIWindow </a>、<a class="ae ms" href="https://developer.apple.com/documentation/uikit/uiviewcontroller" rel="noopener ugc nofollow" target="_blank"> UIViewController </a>、<a class="ae ms" href="https://developer.apple.com/documentation/uikit/UIPresentationController" rel="noopener ugc nofollow" target="_blank">ui presentation controller</a>和<a class="ae ms" href="https://developer.apple.com/documentation/uikit/uiview" rel="noopener ugc nofollow" target="_blank"> UIView </a>。</p><p id="8bd4" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe mo mp mq mr b">traitCollection</code>包含对象所处界面环境的定义:设备类型(iPad/iPhone)、设备尺寸类别(紧凑型/常规型)和显示比例。</p><p id="bb57" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在iOS 13上，苹果增加了一个叫做<code class="fe mo mp mq mr b">userInterfaceStyle</code>的东西，它决定了外观应该是亮还是暗。</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="fa04" class="nb kc je mr b gy nc nd l ne nf">if self.traitCollection.userInterfaceStyle == .dark {<br/>     // you are in the dark!<br/> } else {<br/>     // your are in the light!<br/> }</span></pre><p id="19b0" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe mo mp mq mr b">traitCollection</code>配置按照界面层次结构流动，从UIScreen到UIWindow，然后是UIViewControllers和UIViews。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/9d2d424873506496d180e055022d047f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiEJCCdxVbV3ttSdP0q1yg.png"/></div></div></figure><p id="e985" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，正如您所看到的，每个UI元素的暗/亮主题的定义总是从其父元素继承而来，但是您总是可以自己覆盖它，以防您想要某个元素有所不同。</p><p id="121d" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">例如，您可以为某个UIViewController定义一个不同的外观，这个外观将继续流向它的所有子视图控制器及其UIViews。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="8a08" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">动态颜色</h1><p id="3ade" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">到目前为止，UIColor只包含一种颜色数据。从iOS 13开始，UIColor可以是动态的——这意味着它可以包含一组暗的RGB值，另一组亮的RGB值。</p><p id="3bec" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这是点连接的点——每当用户在其设备设置上更改为黑暗模式时，UIScreen trait集合以及层次结构下的所有UI对象都会更改。如果此层次结构包含具有颜色的元素，如UILables和背景色，并且它们的颜色是动态的(包含暗值和亮值)，它将自动更改为适当的颜色。</p><p id="fd1a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">只要你保持一切动态，它就会自动发生。听起来很棒，对吧？</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="daf3" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">如何打造动感色彩？</h1><p id="e5a9" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们有几种方法可以做到这一点:</p><h2 id="408a" class="nb kc je bd kd nh ni dn kh nj nk dp kl lk nl nm kp lo nn no kt ls np nq kx nr bi translated"><strong class="ak">故事板/界面构建器</strong></h2><p id="84fe" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">嗯，这很简单。Apple提供了一组预定义的动态颜色，如系统黑色、系统橙色等。它们中的每一个都包含两种颜色，一种是深色，另一种是浅色。在故事板中设置视图的颜色后，您不必运行应用程序来查看它的外观xCode中有一个新选项可以将界面构建器切换到黑暗模式。相当酷！</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/177e0cc604aa085124621161861f2380.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*Y03kj_pjxv6gyayO4VBV4g.png"/></div></figure><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/afb3858648ebd4cc059a6c11b1b74074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYYze2-Dd49yvh2WfpHAgg.png"/></div></div></figure><h2 id="a43f" class="nb kc je bd kd nh ni dn kh nj nk dp kl lk nl nm kp lo nn no kt ls np nq kx nr bi translated"><strong class="ak">资产目录</strong></h2><p id="5ea3" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果您不知道，有一个在资产目录上创建颜色集的选项，您可以稍后在代码和故事板中使用它们。创建新颜色集时，选择“属性”检查器，并从“外观”弹出式菜单中，确保选择了“任意、浅色、深色”选项。此时，你可以为不同的风格选择不同的颜色。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/69b31f199c18b12de63144761f8ff389.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*W4qKEzmv_e3BCrPfhuiVDg.png"/></div></figure><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/4a1f71580610347d17ee7e68ab4c93dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAxmGmRaJgJjJc3dGtrhjw.png"/></div></div></figure><h2 id="e78f" class="nb kc je bd kd nh ni dn kh nj nk dp kl lk nl nm kp lo nn no kt ls np nq kx nr bi translated"><strong class="ak">代码</strong></h2><p id="47f8" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">也可以用代码创建动态颜色。只需要用一个新的初始化方法<em class="nw">—init(dynamic provider:@ escaping(</em><a class="ae ms" href="https://developer.apple.com/documentation/uikit/uitraitcollection?changes=latest_minor" rel="noopener ugc nofollow" target="_blank"><em class="nw">UITraitCollection</em></a><em class="nw">)-&gt;</em><a class="ae ms" href="https://developer.apple.com/documentation/uikit/uicolor?changes=latest_minor" rel="noopener ugc nofollow" target="_blank"><em class="nw">ui color</em></a><em class="nw">)—</em>根据你得到的trait集合返回相应的值。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="fa60" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">如何应对外观变化</h1><p id="a0e2" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">每当用户改变他们的外观风格时，所有的视图控制器和表示控制器<code class="fe mo mp mq mr b">viewWillLayoutSubviews</code>和<code class="fe mo mp mq mr b">containerWillLayoutSubviews</code>方法都会被调用(相应的)。</p><p id="8fe5" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此外，UIView <code class="fe mo mp mq mr b">layoutSubviews</code>和draw方法也被调用。</p><p id="0666" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，为了安全起见，您可以在这些方法中更改样式时进行任何更改。</p><p id="d59d" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">相反，由于所有这些对象都符合<code class="fe mo mp mq mr b">UITraitEnviroment</code>协议，<code class="fe mo mp mq mr b">traitCollectionDidChange</code>也被调用。</p><p id="ee5f" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在UIView中，<code class="fe mo mp mq mr b">tintColorDidChange()</code>也被调用。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="7b69" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">动态图像</h1><p id="b852" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">像颜色集一样，图像也可以是动态的。您可以为浅色和深色样式定义不同的资源，这可以直接从资源目录中完成，与颜色集的方式相同。</p><p id="5f4c" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">当您选择右窗格上的<em class="nw">属性检查器</em>时，您会看到外观弹出菜单。只需选择“任何，亮，暗”，您将被要求为亮，暗以及每个分辨率和设备定义不同的资产(祝您好运)。</p><p id="0701" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">例如，您可以将日出设置为亮模式，将日落设置为暗模式。</p><p id="2018" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果到现在还不清楚，我会自动处理的。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="09cb" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">棘手的问题</h1><p id="1c74" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">嗯，关于支持黑色主题，有几种东西你应该知道。</p><p id="df7e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果你在你的<code class="fe mo mp mq mr b">init</code>和<code class="fe mo mp mq mr b">viewDidLoad</code>方法上初始化定制的颜色和图像，你应该把它们移动到你的<code class="fe mo mp mq mr b">layoutSubviews()</code>和<code class="fe mo mp mq mr b">viewDidLayoutSubiews()</code>(相应地)，这样你就可以对主题的改变做出反应，因为我们说过当<code class="fe mo mp mq mr b">traitCollection</code>改变时这些方法会被再次调用。</p><p id="5be2" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">由于<code class="fe mo mp mq mr b">CALayer</code>不是<code class="fe mo mp mq mr b">UIKit</code>的一部分，它不会响应样式的改变，所以这是你需要注意的。</p><p id="4c81" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">有时，您希望从动态颜色集中分离出实际的颜色。使用<code class="fe mo mp mq mr b">UIColor</code>的<code class="fe mo mp mq mr b">resolvedColor()</code>方法可以非常简单。</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="9a47" class="nb kc je mr b gy nc nd l ne nf">let dynamicColor = UIColor.systemBackground<br/>let traitCollection = view.traitCollection<br/>let resolvedColor = dynamicColor.resolvedColor(with: traitCollection)</span></pre><p id="cd1c" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">活动指示器也发生了变化，现在它只包含两种类型——中型和大型。但是，界面风格将决定颜色。</p><p id="850d" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在属性化文本中，你必须确保你为文本定义了一个动态的颜色，否则无论UIView <code class="fe mo mp mq mr b">traitCollection</code>有什么样的界面风格，系统给你的标签的默认颜色都是黑色，黑底黑字并没有真正显示出来。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="c6e0" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">我不想要黑暗模式</h1><p id="d432" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">禁用它非常容易。</p><p id="072b" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您可以通过在<code class="fe mo mp mq mr b">info.plist</code>中将<code class="fe mo mp mq mr b">UIUserInterfaceStyle</code>设置为<code class="fe mo mp mq mr b">Light</code>来禁用整个应用程序。</p><p id="83c1" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您也可以使用override <code class="fe mo mp mq mr b">overrideUserInterfaceStylevariable</code>对某个UIViewController/UIView(及其子视图)禁用它。</p><pre class="mt mu mv mw gt mx mr my mz aw na bi"><span id="e846" class="nb kc je mr b gy nc nd l ne nf">self.overrideUserInterfaceStyle = .dark // always dark</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b614" class="kb kc je bd kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky bi translated">我有一个现有的应用程序。我从哪里开始？</h1><p id="19a7" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">对于一个新的app来说，以iOS 13为部署目标，一切都非常容易和顺利。</p><p id="797c" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">但如果你有一个现有的应用程序，这可能是一个相当大的挑战，特别是如果你已经有某种皮肤/主题管理。</p><p id="39bb" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您使用界面构建器和资产目录来设置颜色和图像，则支持旧版本很容易。用动态颜色就行了，老版本的话iOS会挑浅色版本的颜色。</p><p id="43ae" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您打算使用代码创建动态颜色，我的建议是用一个函数包装它，并将颜色的两个版本(深色和浅色)传递给该函数。在该函数中，版本检查并相应地初始化颜色。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c17a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此外，如果你的应用程序中有一个黑暗主题功能，你应该重新考虑维护这个功能，现在你已经有了它。</p></div></div>    
</body>
</html>