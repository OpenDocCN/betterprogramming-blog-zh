<html>
<head>
<title>Authentication and Authorization using JWT with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Node.js使用JWT进行身份验证和授权</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/authentication-and-authorization-using-jwt-with-node-js-4099b2e6ca1f?source=collection_archive---------0-----------------------#2019-03-12">https://betterprogramming.pub/authentication-and-authorization-using-jwt-with-node-js-4099b2e6ca1f?source=collection_archive---------0-----------------------#2019-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2406cd2f8d92f1c87415b7f7e6385fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHXXyMz7X9wG52FVrHZILA.png"/></div></div></figure><p id="d47e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章将帮助你理解<a class="ae kz" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>背后的不同概念，并使你能够创建生产就绪的应用程序。这篇文章期望读者了解巴别塔以及如何设置它。如果需要学习巴别塔设置，请阅读这篇<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/using-babel-and-other-dependencies-in-node-js-18f74973c1f0" rel="noopener">文章</a>。</p><p id="242a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文将只关注使用<a class="ae kz" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a>为我们的REST APIs提供认证。如果我们想阅读更多关于认证方法的内容，并了解如何使用<a class="ae kz" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>来执行相同的操作，请阅读本系列的第<a class="ae kz" href="https://medium.com/@pankaj.panigrahi/authentication-and-authorization-using-redis-49c5f0e6b311" rel="noopener">6篇文章</a>。</p><p id="6d6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JSON Web Token (JWT)是一个开放标准，它定义了一种紧凑的自包含方式，以JSON对象的形式在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p><p id="df51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">授权是使用JWT最常见的场景。用户登录后，每个后续请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是目前广泛使用JWT的一个特性，因为它的开销很小，并且能够很容易地跨不同的域使用。</p><p id="19e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用JWT进行授权有一些优点:</p><ol class=""><li id="f261" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">纯粹的无国籍。不需要额外的服务器或基础设施来存储会话信息。</li><li id="1d8c" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">它可以很容易地在服务之间共享。</li></ol><p id="2e69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在其紧凑的形式中，JSON Web令牌由点(<code class="fe lo lp lq lr b">.</code>)分隔的三个部分组成，它们是:</p><ul class=""><li id="87e5" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky ls lg lh li bi translated">页眉</li><li id="d964" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky ls lg lh li bi translated">有效载荷</li><li id="edcb" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky ls lg lh li bi translated">签名</li></ul><p id="3608" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，JWT通常如下所示。</p><p id="4f54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">xxxxx.yyyyy.zzzzz</code></p><p id="b449" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TK让我们从我做的一个<a class="ae kz" href="https://github.com/pankaj805/medium-00_boiler_with_db" rel="noopener ugc nofollow" target="_blank">锅炉板</a>开始，它将在以后的文章中使用。如果你一开始就跟着系列走，锅炉板块应该很清楚了。</p><p id="2e44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用npm模块来实施JWT:</p><div class="lt lu gp gr lv lw"><a href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd iu gy z fp mb fr fs mc fu fw is bi translated">jsonwebtoken</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">JSON Web令牌实现(对称和非对称)</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">www.npmjs.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk jz lw"/></div></div></a></div><p id="c57b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在项目中安装上述模块:</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="3bba" class="mt mu it lr b gy mv mw l mx my">npm install jsonwebtoken --save</span></pre><p id="60e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将构建两个API。第一个API是“登录”API，它应该返回新的会话令牌，另一个API将更新密码，这将需要登录用户的有效会话令牌。</p><p id="a290" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先添加一个服务方法来更新用户的密码。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9fd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以最后<code class="fe lo lp lq lr b">services/UserService.js</code>应该是这样的:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="94f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们编辑我们的<code class="fe lo lp lq lr b">common/authUtils.js</code>文件来处理期望的场景。</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="292d" class="mt mu it lr b gy mv mw l mx my">import jwt from 'jsonwebtoken';</span><span id="d7d8" class="mt mu it lr b gy nb mw l mx my">const newSessionRoutes = [{ path: '/user/login', method: 'POST' }];<br/>const authRoutes = [{ path: '/user/password', method: 'PUT' }];</span><span id="85a1" class="mt mu it lr b gy nb mw l mx my">const SECRET_KEY = "JWT_SECRET";</span></pre><p id="4876" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导入<code class="fe lo lp lq lr b">jsonwebtoken</code>模块并定义三个<code class="fe lo lp lq lr b">constants</code>，第一个包含需要新会话的API方法数组，第二个包含需要有效会话的API方法数组。第三方应该保存用于数据加密的密钥。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cb8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加上面的方法来检查传递的API需要新的会话还是旧的会话。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="051b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">generateJWTToken()</code>方法应该获取用户数据，用预定义的密钥加密，然后生成<code class="fe lo lp lq lr b">jwtToken</code>字符串。</p><p id="20dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lo lp lq lr b">verifyToken()</code>方法应该接受<code class="fe lo lp lq lr b">jwtToken</code>字符串并返回解密后的数据。在无效令牌字符串的情况下，它将转到catch块和<code class="fe lo lp lq lr b">return null</code>。</p><p id="3794" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们的<code class="fe lo lp lq lr b">authUtils</code>文件应该是这样的:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7626" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们编辑<code class="fe lo lp lq lr b">app.js</code>文件。</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="be05" class="mt mu it lr b gy mv mw l mx my">import {clientApiKeyValidation} from './common/authUtils';</span></pre><p id="04ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将上面的行更新如下:</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="eb79" class="mt mu it lr b gy mv mw l mx my">import { clientApiKeyValidation, isNewSessionRequired, isAuthRequired, generateJWTToken, verifyToken } from './common/authUtils';</span></pre><p id="f805" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们注入了<code class="fe lo lp lq lr b">clientApiKeyValidation</code> <strong class="kd iu">的那一行之后添加下面的代码。</strong></p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5994" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过上面的代码，我们注入了另一个请求处理器，它将为所有API处理与会话相关的东西。首先，我们检查被调用的API是否需要一个新的会话。在这种情况下，我们只是设置了一个<code class="fe lo lp lq lr b">boolean</code>字段，稍后我们将在响应处理程序中使用它。</p><p id="2cdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在来看第二种情况:</p><p id="94bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们假设请求将带有一个承载令牌报头，如下所示:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/6c3cf6a08f3f5f9f7f236890f468cb45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHC_L8n8cCuprqThm3h5WQ.png"/></div></div></figure><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2f20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经将JWT令牌传递给了我们之前定义的<code class="fe lo lp lq lr b">verifyToken</code>方法。如果我们获得了解密的用户数据，我们将相同的数据设置到请求对象中的一个字段。</p><p id="34e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">否则，我们会发送一条带有<code class="fe lo lp lq lr b">Invalid session-token</code>消息的错误。</p><p id="d726" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们所有的路由注入之后，让我们也为我们所有的API修改响应处理程序。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ef3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在需要新会话的情况下，我们生成JWT令牌并在API响应中发送它。</p><p id="96df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在另一种情况下，会话令牌被传递给API，我们在响应中发送相同的会话令牌。</p><p id="36af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们的<code class="fe lo lp lq lr b">app.js</code>代码看起来像这样:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="775b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们转到我们的<code class="fe lo lp lq lr b">routes/user.js</code>文件。</p><p id="dcbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更新导入语句，使其也包含<code class="fe lo lp lq lr b">updateUserPassword</code>方法。</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="c0a7" class="mt mu it lr b gy mv mw l mx my">import { getUserDetails, updateUserPassword } from '../services/UserService';</span></pre><p id="333f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">登录API的代码如下:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3e7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们还可以添加另一个条件来检查请求数据中是否缺少用户名或密码。首先，我们尝试通过传递用户名来获取用户的详细信息。在数据丢失的情况下，我们会发送一条错误消息，声明“用户名无效”。否则我们尝试比较密码。</p><p id="de8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果密码不匹配，我们会发送一个错误。否则，我们更新响应数据对象和请求会话对象中的用户数据。我们的响应处理程序将使用相同的数据来创建JWT令牌。</p><p id="32a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们为更新后的密码API添加代码。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="51d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是代码中有趣的部分。在这里，我们将看到如何从会话令牌中获取所有用户的详细信息。请求中没有提到用户详细信息或用户名。但是我们作为请求处理程序注入的会话处理程序必须在请求会话对象中注入用户数据。</p><pre class="ml mm mn mo gt mp lr mq mr aw ms bi"><span id="0301" class="mt mu it lr b gy mv mw l mx my">let uname = req.session.userData.username;</span></pre><p id="7845" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从请求会话对象中获取用户名，然后执行更新用户密码所需的所有操作。</p><p id="04fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们测试我们的代码。使用节点<code class="fe lo lp lq lr b">index.js</code>命令运行项目。</p><p id="cf8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在点击登录API:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/92d0fbb0dad91b521a0d1863a6ea006e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozUZWrWBhx1AzDVXVi9Zjw.png"/></div></div></figure><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/5607e0ea1a898656fe178732d0d71716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdRe8PZ38VK3z135oPirfw.png"/></div></div></figure><p id="8edf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在响应头和响应体中发送会话令牌。</p><p id="2162" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，尝试使用无效的令牌点击更新密码API:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/43a3e1a4fe002cee5915dfbff25197d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jri9v1mniGQQ2xJD2aD9EQ.png"/></div></div></figure><p id="4e35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">复制我们之前在登录API响应中获得的会话令牌，并将其传递到更新密码API的头中。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/009ac203ce6df4cc71a3fb295d71fbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESeyE_irP7ij-GkDT1_neQ.png"/></div></div></figure><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/7059f6a2eda449930b9c95149d987c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvRZyvzeEOXmFX_LRpgt5A.png"/></div></div></figure><p id="8ea9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一篇文章中，我们使用Redis获得了相同的结果。这两种方法都可以用来实现无状态身份验证。</p><p id="98c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我更喜欢使用Redis，因为使用JWT有以下缺点:</p><ol class=""><li id="e963" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">对客户端的控制更少:</strong>假设出于某种原因，我们希望使您系统中的所有会话无效。在Redis中，您可以通过删除所有键轻松做到这一点。在某个时间点，人们不知道登录的客户端的数量。假设您想要将一些消息推送到登录的设备。在JWT实施中不可能做到这一点。</li><li id="3885" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">有效负载开销:</strong>在Redis中，令牌大小是固定的。但是在JWT，令牌大小与您想要添加到会话中的数据量成正比。如果您有大量数据要存储，这肯定会影响API的性能。</li><li id="f4d4" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">更改会话:</strong>在某些情况下，您可能希望修改正在运行的会话中的会话数据。使用Redis方法可以很容易地做到这一点，因为令牌不会改变。但是在JWT，当数据改变时，令牌也会改变。因此，客户端必须跟踪这一点，这使得集成很麻烦。</li></ol><p id="ffd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管如此，JWT仍然解决了许多用例，并且非常容易实现。</p><p id="03cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，你可以👏并与他人分享。</p></div></div>    
</body>
</html>