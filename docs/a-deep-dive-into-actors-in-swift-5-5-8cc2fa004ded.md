# Swift 5.5 中的角色探究

> 原文：<https://betterprogramming.pub/a-deep-dive-into-actors-in-swift-5-5-8cc2fa004ded>

## 什么是 Actors、actors 重入、隔离以及在 Swift 中使用主 actors 和 async/await

![](img/e2fa630df2d5787b9cd69e568280e30b.png)

由[路德·德·佩杰帕](https://unsplash.com/@ruud_exploor?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片。

随着 Swift 5.5 带来的与并发相关的新变化，该语言使得我们 Swift 开发人员编写并发代码变得更加容易。在 5.5 版本中已经接受了大量的提议，并且已经有大量的新东西推出供我们学习和习惯。

Swift 新版本中即将出现的新特性之一是一个名为`actor`的新原语的可用性。因此，在我们开始使用 Actor 之前，让我们试着了解它们是什么，以及 Swift 为支持语言中这种特殊的“Actor”模型而带来的变化。

因此，本文将分为两个主要部分。在第一部分，我们将试图理解什么是行动者，他们试图解决的潜在问题是什么，以及他们是如何解决的。然后我们将进入斯威夫特如何向我们展示演员。

# 并发性和参与者模型

编程中的并发性和并行性是非常有效的方法，可以确保您的程序利用处理器硬件和软件的优势，从而确保您的程序尽可能以最佳速度运行。现在，权力越大，责任也越大！

并发系统的最大问题之一是共享状态的问题。更具体地说，管理共享状态通常会在并发系统中导致两种类型的问题:

1.  数据争用—当两个或多个线程试图访问(至少有一次访问是写操作)单个资源时，会导致数据不一致。
2.  竞争条件——由于一段代码在共享资源上的不确定性执行，在不同的场景中，输出结果是不可预测的。基本上，由于执行的顺序是不确定的，它经常导致不同的输出。

这两者之间有一个[差异](https://blog.regehr.org/archives/490)，但一般来说，它们的出现是因为存在某种对共享状态的访问。此外，检测数据竞争通常要容易得多，但调试竞争条件却非常困难，因为前者可以重现，而后者不能每次都重现。

现在有不同的并发模型可以帮助我们解决数据竞争问题(例如，锁和互斥、对共享数据的序列化访问等)。).

Swift 试图通过鼓励我们使用值语义(即结构和枚举)来避免这个问题，因为它们通常在并发环境中更容易推理。

但是，即使值语义也不能在所有情况下都有帮助(或者因为它们在该上下文中没有意义，或者由于不正确的实现)，并且您最终会使用某种同步机制，如锁或串行队列。这就是这个新演员模型帮助我们的地方。

[角色模型](https://en.wikipedia.org/wiki/Actor_model)是一个并发模型，其中`actor`是一个新的原语结构，它通过成为唯一一个可以对其执行更改/突变的对象来保存和保护本地状态。任何外部成员都可以请求参与者对其状态进行操作，参与者将确保对其状态的所有访问/更改请求都是同步的。

演员有以下特点:

*   有自己孤立的状态。
*   可以包含改变自身状态的逻辑。
*   只能与其他参与者异步通信(通过他们的地址)。
*   可以创建其他子角色(这一点我们并不太关心)。

对参与者模型中的通信的最佳 ELI5 解释如下:

> “想象一下，每个演员就像一个孤岛，而我们的代码库就是一个由孤岛组成的世界。现在每个岛都可以通过在瓶子里给另一个岛发送信息来和它交流。每个岛都知道向哪里发送消息(即另一个岛的地址)，这就是每个岛之间的通信方式。”

尽管 Actor 模型背后的理论还有更多的内容(我将在文章底部附上不同的链接)，但我们将了解这一模型如何实际转化为我们的 Swift 世界。

# Swift 中的演员

Swift 5.5 引入了一个名为`actor`的新关键字。就像你如何定义一个`class`或者一个`struct`，现在你可以定义一个`actor`。

这些参与者可以遵循协议，并像任何早期的原语一样工作(除了继承，目前不支持继承)。唯一的区别是不同参与者之间的交互是异步发生的。

在解释并发性时，最常用的一个例子是从银行账户存钱/取钱。所以让我们继续定义一个`BankAccount`演员:

在上面的例子中，如果`BankAccount`被定义为一个`class`而不是一个`actor`，那么`balance`变量可以被认为是`BankAccount`的不安全的“可变状态”,这可能会导致并发环境中潜在的数据竞争情况。但是既然`BankAccount`已经被定义为`actor`，那么`balance`变量就不会出现数据竞争。让我们看看怎么做。

## 演员隔离

现在，上面的数据竞争保护是通过一个叫做*参与者隔离*的概念实现的。它只是一个术语，用来定义一些规则，如跨角色成员(函数和属性)访问应该如何工作。规则如下:

1.  一个 actor 可以同步读取它自己的属性或调用它自己的函数(即使用`self`)。
2.  一个参与者只能更新它自己的属性(它可能会同步更新)。这意味着您只能使用`self`关键字进行属性更新。试图更新另一个 actor 的属性将导致编译器错误。
3.  跨角色属性读取或函数调用必须使用`await`关键字异步发生。然而，不可变属性的跨角色读取可以同步发生(用`let`声明的属性)。

## 演员重返舞台

actors 中的函数执行是可重入的。我所说的重入是指这样一个事实，运行时可以在一个暂停点重新进入代码的执行，并从那里继续你的工作。让我们看一个例子:

假设您试图关闭您的银行账户，这需要您与银行的服务器进行通信。我们采取的步骤是:

1.  我们检查账户`isOpen`是否存在。关闭已经关闭的账户是没有意义的。
2.  通知银行的服务器该账户正在请求关闭(这一步可能需要时间)。
3.  检查一下账户是否还开着。如果账户仍然开着，关闭账户并归还余额。否则，抛出一个错误，说明当网络调用正在进行时，发出了另一个取消请求，可能已经关闭了帐户。

actors 中的重入是这样定义的:一个函数可以中途暂停一段时间，而执行该函数的线程执行一些其他任务，然后从暂停点恢复该函数。

例如，在这个对银行账户的调用中，您可以让您的代码“暂停”一段时间(当它与银行服务器通信时)，让同一个线程执行一些其他的工作，然后一旦您收到银行服务器的响应，就从它停止的地方“恢复”工作。

关于第 8 行有一个小而重要的讨论，在那里发生了当前线程的工作的“暂停”(也就是发生了一个`await`调用的那一行)。

记住，每个`await`调用都是代码中潜在的暂停点。

在银行服务器响应之前，这个线程可以执行我们的代码可能已经安排的其他未完成的工作，或者我们的代码请求的一些新工作。我们可以向`withdraw` money、`deposit` money 发出一个调用，或者向`cancellation`发出另一个请求，这样就会在那个线程上结束运行。

现在一旦银行服务器响应，演员的状态可能就和暂停点之前不一样了。这是非常重要的一点，因为您需要认识到这样一个事实，即您不能对您的 actor 在`await`函数调用前后的状态做出假设。

这是我在第 9 行(在`await`电话之后)再次检查账户是否仍然开放的唯一原因，因为很有可能第二次取消电话已经发出并完成，账户已经关闭。

因此，当你思考演员回归时，你需要记住两件事:

*   总是尝试在同步代码中执行状态突变(避免在改变内部状态的函数中调用`async`函数)。
*   如果您必须在改变状态的函数中执行`async`函数调用，不要在`await`完成后对该状态做任何假设。

# @MainActor

苹果建议在主线程上调用所有 UI 代码。因此，每当我们需要进行繁重的数据处理或进行网络调用来获取数据以显示我们的 UI 时，我们就在后台线程上这样做。一旦这个处理完成，我们通常做以下事情:

Swift 5.5 引入了一种新的属性包装器，称为`@MainActor`。该注释确保了对用该包装器注释的属性的任何读写访问都发生在主线程上(从而消除了所有的`DispatchQueue.main`调用)。

您可以用这个属性包装来注释属性、函数和类/结构定义。

UIKit 类(如`UILabel`、`UIView`等)。)已经用此属性包装进行了标记。因此，您可以放心，它们将总是在主线程上被访问。

这里唯一的问题是，只有在使用新的`async/await`调用时，才能在主线程上访问这些成员——而不是在使用完成处理程序时。这里有一段代码可以帮助你更好地理解它:

如果您运行这个代码片段并在第 11/12 行放置一个断点，您将看到来自`DispatchQueue.global`的调用不会在主线程上执行，但是来自`asyncDetached`的调用将在主线程上执行。

# 结论

如您所见，`actors`绝对是 Swift 这样的现代语言所急需的补充。我确信整个系统将继续发展，Swift 中可能会有很多并发性升级。也就是说，你需要从这篇文章中吸取的要点如下:

*   参与者是另一种可以用来解决并发系统中出现的数据竞争问题的方法。
*   参与者使用参与者隔离的概念来帮助防止数据竞争。
*   即使 actors 帮助您处理数据竞争，仍然存在可能发生竞争情况的争论点。因此，无论何时引入暂停点，都应该确保不对参与者状态做出任何假设。
*   使用`@MainActor`可以帮助你在没有`DispatchQueue.main`调用的情况下访问主线程上的属性，但是只使用新的`async/await`调用系统。

## 链接

*   [SE-0303 提案](https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md)
*   [WWDC 谈演员](https://developer.apple.com/videos/play/wwdc2021/10133/)
*   [WWDC 谈演员的实现](https://developer.apple.com/videos/play/wwdc2021/10254/)
*   [Doug Gregor 关于 Swift 并发性的演讲 Sundell 的 Swift](https://www.swiftbysundell.com/podcast/99/)