<html>
<head>
<title>Dagger/Hilt vs. Koin for Jetpack Compose Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">匕首/刀柄vs. Koin for Jetpack撰写应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dagger-hilt-vs-koin-dependency-injection-for-jetpack-compose-apps-2e598f00aff?source=collection_archive---------0-----------------------#2022-03-13">https://betterprogramming.pub/dagger-hilt-vs-koin-dependency-injection-for-jetpack-compose-apps-2e598f00aff?source=collection_archive---------0-----------------------#2022-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0917" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">匕首和锦鲤的优缺点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0caf72b2ec6bf117b666934a74b172e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_wG6vKAMYjwj3yX7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">mate usz waca wek在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="880a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">啊，又来了。匕首/刀柄和锦鲤的永恒斗争。我预计在评论中会有很多关于哪个更好的争论，但是不要担心，这篇文章只是向你展示它们之间的主要区别。它们都很棒，所以你必须自己选择要使用哪一个，但我希望通过向你展示它们对于Jetpack Compose应用程序的优缺点，让你的选择更容易一些！</p><p id="b9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于本文的目的，我假设你已经知道什么是依赖注入，以及Dagger/Hilt和Koin之间的主要区别，例如:</p><ul class=""><li id="d21f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">代码生成与无代码生成</li><li id="58f4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对构建时间的影响与对运行时间和注入时间的影响</li><li id="c14e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">而且显然Hilt是谷歌推荐维护的，而Koin不是。当然，谷歌并没有说Koin不好，并使用你认为更适合你的项目。</li></ul><p id="1bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Manuel Vivo对Koin的看法，例如:</p><blockquote class="mj"><p id="a6f3" class="mk ml it bd mm mn mo mp mq mr ms lu dk translated">谷歌推荐Android应用程序使用Hilt，但这只是一个建议！用你觉得对你有好处的。</p></blockquote><div class="mt mu mv mw mx my"><a href="https://medium.com/@manuelvicnt/hi-i-think-koin-is-a-great-library-as-well-use-what-you-think-fits-better-to-your-project-885b4992a5b2" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">嗨！我认为Koin也是一个很棒的图书馆。使用你认为更适合你的项目。</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">这两个库各有利弊:</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">medium.com</p></div></div></div></a></div><p id="927b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些听起来都不熟悉，那么你可能应该暂时停止阅读，在继续之前先弄清楚什么是依赖注入、匕首、剑柄和锦鲤。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="b87e" class="no np it bd nq nr ns nt nu nv nw nx ny jz nz ka oa kc ob kd oc kf od kg oe of bi translated">我们走吧</h1><p id="a956" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">好了，现在让我们比较匕首/刀柄和锦鲤。</p><p id="fca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地展示这些工具的优缺点，我将考虑两种使用Jetpack Compose编写Android应用程序的情况:</p><ul class=""><li id="edea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一种情况——当你的应用程序是用纯Jetpack Compose编写的，也就是说，没有使用片段，所以你可能使用的是<a class="ae ky" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank">导航组合库</a>。</li><li id="4b8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">而第二种情况——当你使用Fragments和ComposeView ( <a class="ae ky" href="https://developer.android.com/jetpack/compose/interop/interop-apis" rel="noopener ugc nofollow" target="_blank">互操作性</a>)，这在我看来是最好的选择(至少目前是这样)，主要是因为糟糕的导航-合成API和缺乏类型安全性。这是一个相当大和有争议的话题，但嘿，这是我最喜欢的。一定要查看<a class="ae ky" href="https://patrykkosieradzki.medium.com/why-using-navigation-compose-in-your-jetpack-compose-app-is-a-bad-idea-2b16e8751d89" rel="noopener">我关于这个</a>的文章。</li></ul></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="33d1" class="no np it bd nq nr ns nt nu nv nw nx ny jz nz ka oa kc ob kd oc kf od kg oe of bi translated">在你的应用中使用Hilt的好处</h1><p id="9474" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">那么Hilt有哪些好的方面呢？</p><h2 id="5d8b" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">喷气背包和支持</h2><p id="6740" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">首先，Hilt是<a class="ae ky" href="https://developer.android.com/jetpack" rel="noopener ugc nofollow" target="_blank"> Jetpack </a>的一部分，目前，谷歌建议你在安卓应用中使用它。当然，这没什么大不了的，但我必须说，谷歌创造了它，这真的很好，正如你们中的一些人可能知道的那样，使用Dagger并不总是像我们希望的那样好和令人愉快——特别是对于刚刚开始学习Android中的依赖注入的程序员来说。</p><h2 id="6354" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">比匕首更容易实现</h2><p id="1430" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">第二件事，就像我刚刚提到的，如果你以前用过匕首并且你喜欢它，你会喜欢用刀柄的！</p><ul class=""><li id="15a0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">像<code class="fe ox oy oz pa b"><a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank">@AndroidEntryPoint</a></code> <em class="pb"> </em>或<code class="fe ox oy oz pa b"><a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank">@HiltViewModel</a></code>这样的新注释使得管理Android类中的DI代码变得更加容易。</li><li id="e138" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-android#generated-components" rel="noopener ugc nofollow" target="_blank">为Android类</a>生成的组件，如SingletonComponent、ViewModelComponent等，创建模块变得不那么复杂了。</li><li id="af38" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">还有更多！点击查看一切<a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><h2 id="c8d5" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">编译时错误</h2><p id="555e" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">Dagger和Hilt是编译时依赖注入框架。这意味着，如果我们不小心忘记提供一些依赖，或者我们搞砸了一些事情，构建将会失败，我们的应用程序将根本无法运行。</p><p id="9014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，Koin会有不同的表现。如你所知，Koin不生成任何代码，所以如果我们用DI搞砸了什么，这个项目无论如何都会构建，但是它会在开始时崩溃或者稍后在某个特定的屏幕上崩溃。</p><p id="cc70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员必须检查应用程序的这个特定部分的依赖关系是否工作良好，应用程序是否崩溃。匕首/刀柄在那种情况下使用要安全得多。</p><h2 id="5085" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">测试</h2><p id="537d" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">下一件大事是测试。当然，编写单元，用户界面，E2E等等。用匕首测试已经是可能的了，但是我们现在从剑柄上得到的要多得多！忘记复杂的匕首测试。现在您有了<code class="fe ox oy oz pa b">HiltAndroidRule</code>来管理组件的状态，并更容易地将不同的依赖项注入到测试中。</p><pre class="kj kk kl km gt pc pa pd pe aw pf bi"><span id="da86" class="ol np it pa b gy pg ph l pi pj">@HiltAndroidTest<br/>class SettingsActivityTest {<br/><br/>  @get:Rule<br/>  var hiltRule = HiltAndroidRule(this)<br/><br/>  // UI tests here.<br/>}</span></pre><p id="973b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以轻松地动态替换和模仿依赖项，甚至是整个模块。此外，您可以在一个特殊的测试容器<code class="fe ox oy oz pa b"><a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-testing#launchfragment" rel="noopener ugc nofollow" target="_blank">launchFragmentInHiltContainer</a></code>中启动您的片段(如果您正在使用它们的话)。</p><p id="450d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有使用片段或者您只想测试可组合的，那么您可以使用<code class="fe ox oy oz pa b"><a class="ae ky" href="https://developer.android.com/jetpack/compose/testing" rel="noopener ugc nofollow" target="_blank">ComposeTestRule</a></code>轻松地做到这一点，在这里您可以将您的视图模型和其他依赖项直接传递给可组合的函数(我的Github 上的<a class="ae ky" href="https://github.com/k0siara/AndroidMVIExample/blob/master/app/src/androidTest/java/com/patrykkosieradzki/androidmviexample/ui/AddEmployeeScreenTest.kt" rel="noopener ugc nofollow" target="_blank">示例)。也可以在UI测试中自动模拟每个ViewModel，所以测试设置只有几行代码。</a></p><h2 id="6c15" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">过程死亡</h2><p id="8fb6" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">有了Hilt，保护你的应用程序免受进程死亡也容易多了。您可以简单地通过<a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-jetpack#viewmodels" rel="noopener ugc nofollow" target="_blank">将</a> <code class="fe ox oy oz pa b"><a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">SavedStateHandle</strong></a></code>注入到<code class="fe ox oy oz pa b">ViewModel</code>(这只是一个奇特的StateHandle映射)来存储和恢复在进程死亡时需要保存的数据。</p><h1 id="1328" class="no np it bd nq nr pk nt nu nv pl nx ny jz pm ka oa kc pn kd oc kf po kg oe of bi translated">使用刀柄的缺点</h1><p id="cbb3" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">剑柄是否完美无瑕？让我们找出答案。</p><h2 id="ef29" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">更慢的构建时间</h2><p id="0e80" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">正如你们大多数人可能知道的那样，Hilt在构建期间会生成一些文件，这意味着应用程序越大，模块、组件和依赖项越多，构建时间就越长，速度就越慢。</p><h2 id="d947" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">有时候你必须写匕首代码</h2><p id="06a7" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">虽然使用Hilt比使用Dagger要容易得多，但有时你仍然需要在应用程序中使用Dagger代码。如果你想在你的应用程序中为每个功能创建单独的android模块，那么你必须用Dagger以一种老式的方式编写一些代码。</p><p id="bd52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您必须创建一个定制的<code class="fe ox oy oz pa b">EntryPoint</code> <em class="pb"> </em>模块，将它组合到组件的构建器中，然后以编程方式将其注入托管该功能的活动或片段中。你可以在这里阅读更多相关信息<a class="ae ky" href="https://developer.android.com/training/dependency-injection/hilt-multi-module" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="f583" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">除了ViewModel之外，不能在Composables中注入任何东西(至少目前是这样)</h2><p id="b016" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">对我来说，一个主要的缺陷是，如果你正在编写一个没有片段的只组合的应用程序，除了视图模型之外，你不能将依赖注入到可组合的组件中。</p><p id="319a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能你们很多人现在都在想，为什么你们需要这样的东西呢？</p><p id="7575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，这肯定是功能的损失，因为在Compose之前，我们能够将依赖注入片段、活动等。现在片段被组合体“取代”,你会认为这个特性应该还在，对吗？</p><p id="0adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能给我举些有用的例子吗？</p><p id="0b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然可以。这里有几个例子:</p><ul class=""><li id="2326" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将UI逻辑/工作委托给Composables中的其他类，这样您的代码更加可重用和简洁。</li><li id="952a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">以不同的方式呈现UI，基于从AppConfig等特定依赖项中获得的数据，或者放入ViewModel的逻辑中实际上没有意义的其他东西(因为没有逻辑)。示例:如果我当前处于调试模式，我想在Composable中显示附加文本。我在<code class="fe ox oy oz pa b">AppConfig</code> singleton中有<code class="fe ox oy oz pa b">isDebug: Boolean</code> <strong class="lb iu"> <em class="pb"> </em> </strong>的值。</li><li id="2f46" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">另一个例子:假设你需要多个线圈图像加载器<em class="pb"> </em>并且你想在你的一些组件中使用它们。您不能将它们直接注入到可组合参数中，所以您可能必须将它们从活动传递到<code class="fe ox oy oz pa b">NavGraph</code> <strong class="lb iu"> <em class="pb"> </em> </strong>，然后或者通过可组合参数传递或者使用<code class="fe ox oy oz pa b"><a class="ae ky" href="https://developer.android.com/jetpack/compose/compositionlocal" rel="noopener ugc nofollow" target="_blank">CompositionLocalProvider</a></code>。</li></ul><p id="7410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pb">这个问题容易解决吗？是的。</em></p><p id="c2ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前告诉你的，我更喜欢使用片段组合，这是我仍然使用它们的另一个原因。你可以在片段中注入依赖关系，然后将它们传递给组件。</p><p id="1e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我想将依赖关系真正深入到可组合树中，该怎么办？</p><p id="3535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，首先三思如果你真的需要通过它。如果答案仍然是肯定的，那么你可以沿着树向下传递变量，或者你可以考虑使用<code class="fe ox oy oz pa b"><a class="ae ky" href="https://developer.android.com/jetpack/compose/compositionlocal" rel="noopener ugc nofollow" target="_blank">CompositionLocalProvider</a></code>。这需要您编写额外的代码，但这仍然是一个选项。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="d917" class="no np it bd nq nr ns nt nu nv nw nx ny jz nz ka oa kc ob kd oc kf od kg oe of bi translated">这和Koin有什么关系？</h1><p id="6367" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">先说优点。</p><h2 id="f44b" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">比匕首和刀柄更容易使用</h2><p id="fe33" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">首先，Koin的使用和学习肯定比匕首或剑柄简单得多。对于希望学习依赖注入的程序员新手来说，这是一个不错的选择。</p><h2 id="541e" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">您可以将依赖关系注入到组件中</h2><p id="0442" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">与Dagger或Hilt不同，Koin允许我们将依赖关系注入到组件中。</p><p id="abbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt pc pa pd pe aw pf bi"><span id="5e3c" class="ol np it pa b gy pg ph l pi pj"><a class="ae ky" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a><br/>fun SomeComposable(myService: MyService = get()) {<br/>   // ...<br/>}</span></pre><p id="0a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这解决了我之前提到的问题，当我们不使用片段时，这真的很好。</p><h2 id="d9f2" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">更多信息错误日志</h2><p id="b9c8" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">如果你以前使用过Dagger或Hilt(尤其是Dagger ),你可能会注意到它们在日志中没有给出太多关于错误发生的信息，你经常不得不猜测并找出真正的错误。</p><p id="8046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在某些情况下，Hilt会告诉你:</p><blockquote class="mj"><p id="7c20" class="mk ml it bd mm mn mo mp mq mr ms lu dk translated"><em class="pp">【剑柄】</em></p></blockquote><p id="067e" class="pw-post-body-paragraph kz la it lb b lc pq ju le lf pr jx lh li ps lk ll lm pt lo lp lq pu ls lt lu im bi translated">仅此而已。</p><p id="1ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，随着时间的推移，这些问题被修复，你现在会看到更多的信息，但仍然，Koin赢得了这场战斗，并在错误发生时有更多的信息日志。</p><h2 id="ad4e" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">不生成代码</h2><p id="3588" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">Koin根本不会生成任何代码。这意味着你的构建时间会更快。</p><p id="37e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在缺点是:</p><h2 id="d8ad" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">更多的DI代码，尤其是get()、get()、get()… get()</h2><p id="8cbc" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">正如我之前提到的，Koin实现起来容易得多，但是它也有代价——更多的代码。每个单例、工厂、视图模型等。你想注入你必须先添加到你的模块。</p><p id="da42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt pc pa pd pe aw pf bi"><span id="5edd" class="ol np it pa b gy pg ph l pi pj">val appModule = module {<br/>   single { DogRepository(get()) } <br/>   <br/>   factory { GetDogUseCase(get()) }</span><span id="b411" class="ol np it pa b gy pv ph l pi pj">   viewModel {<br/>      DogDetailsViewModel(get())<br/>   }<br/>}</span></pre><p id="3b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果你的依赖关系中有很多参数，你的模块可能会像这样结束:</p><pre class="kj kk kl km gt pc pa pd pe aw pf bi"><span id="1843" class="ol np it pa b gy pg ph l pi pj">val appModule = module {<br/>   single { <br/>      DogRepository(get(), get(), get(), get(), get())<br/>   } <br/>   <br/>   factory { <br/>      GetDogUseCase(<br/>         repo = get()<br/>         cacheRepo = get(),<br/>         service = get(),<br/>         somethingElse = get()<br/>      ) <br/>   }</span><span id="3cf7" class="ol np it pa b gy pv ph l pi pj">   viewModel {<br/>      DogDetailsViewModel(<br/>         imagine = get(),<br/>         a = get(),<br/>         lot = get(),<br/>         of = get(),<br/>         dependencies = get(),<br/>         here = get()<br/>      )<br/>   }<br/>}</span></pre><p id="7aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个视图模型和一个报告/用例。想象一下它在更大的应用程序中会有多糟糕…</p><h2 id="2dd6" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">不使用片段时的SavedStateHandle问题</h2><p id="384d" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">目前，如果你不使用片段并将视图模型直接注入到组件中，就不可能将<code class="fe ox oy oz pa b">SavedStateHandle</code>注入到视图模型中。如果你试图这样做，你会得到一个错误。这个问题应该很快就会得到解决，但是如果您想在进程死亡的情况下保留屏幕状态，这是您必须考虑的问题。</p><h2 id="5e6a" class="ol np it bd nq om on dn nu oo op dp ny li oq or oa lm os ot oc lq ou ov oe ow bi translated">对运行时性能的影响</h2><p id="ca36" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">正如我之前提到的，由于代码生成，匕首/剑柄对构建时间有很大的影响。另一方面，Koin也影响时间，但不是构建，而是运行时。Koin的运行时性能稍差，因为它在运行时解析依赖关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/c1002f255343615346f88f5b18b89450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*Uoq7Youb_a57pvVdSnKW2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/Sloy/android-dependency-injection-performance" rel="noopener ugc nofollow" target="_blank">https://github . com/Sloy/Android-dependence-injection-performance</a></p></figure><p id="68b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里找到所有的结果:</p><div class="px py gp gr pz my"><a href="https://github.com/Sloy/android-dependency-injection-performance#xiaomi-mi-a1" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">GitHub-Sloy/Android-dependency-injection-performance:[未维护]测量…的性能</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">这个项目旨在测量几个依赖注入框架(或服务定位器)在…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf ks my"/></div></div></a></div><h1 id="d559" class="no np it bd nq nr pk nt nu nv pl nx ny jz pm ka oa kc pn kd oc kf po kg oe of bi translated">摘要</h1><p id="eb69" class="pw-post-body-paragraph kz la it lb b lc og ju le lf oh jx lh li oi lk ll lm oj lo lp lq ok ls lt lu im bi translated">那么你应该选择使用哪种DI呢？你得自己决定。我必须承认我不是匕首的超级粉丝(抱歉匕首爱好者)，但我仍然会建议学习它。</p><p id="8070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到底，不是哪一个更好，而是哪一个能让你写出易于测试和维护的干净代码。我在之前的几个项目中使用了所有的剑(匕首，剑柄，锦鲤),我认为所有的剑(尤其是剑柄和锦鲤)都符合这个标准。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="2e3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看我的其他文章:</p><ul class=""><li id="b80c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://patrykkosieradzki.medium.com/why-using-navigation-compose-in-your-jetpack-compose-app-is-a-bad-idea-2b16e8751d89" rel="noopener">为什么在你的Jetpack撰写应用程序中使用导航撰写不是一个好主意</a></li><li id="acc1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://proandroiddev.com/livedata-vs-sharedflow-and-stateflow-in-mvvm-and-mvi-architecture-57aad108816d" rel="noopener ugc nofollow" target="_blank">MVVM和MVI架构中的LiveData vs SharedFlow和StateFlow</a></li><li id="2d9b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://proandroiddev.com/easy-ui-and-screenshot-testing-on-android-2b138f6d1eb8" rel="noopener ugc nofollow" target="_blank">在Android上进行简单的用户界面和屏幕截图测试</a></li></ul><p id="98dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果你是一个波兰人，你可以听听我的“Android Talks”播客:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qg qh l"/></div></figure></div></div>    
</body>
</html>