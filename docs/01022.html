<html>
<head>
<title>The Hitchhiker’s Guide to Regular Expressions and Python’s re Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式和Python的re库的指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-hitchhikers-guide-to-regular-expressions-and-python-s-re-library-1342444900d2?source=collection_archive---------6-----------------------#2019-08-07">https://betterprogramming.pub/the-hitchhikers-guide-to-regular-expressions-and-python-s-re-library-1342444900d2?source=collection_archive---------6-----------------------#2019-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c5a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要惊慌</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0e9f02cfdc1a410a1f0a1d8f5398e987.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*fkE8uHEOYfNyZZV1hk9ruw.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我的标题灵感</p></figure><p id="5098" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上周，我发现自己在不知道正则表达式是什么的情况下，试图找到一个字符串中的所有数字，这很难看。正是一行又一行超具体的、重复的陈述伤害了我打字的灵魂。想到一定有更好的方法，我做了任何优秀程序员都会做的事情；我在谷歌上搜索了更好的方法。我在StackOverflow上找到了很多简短的回答，都用到了Python的re库，但是没有一个解释清楚发生了什么。因此，我进行了尽职调查并浏览了文档，结果却发现一篇难以置信的冗长、密集的文章，花去了我全部的精力去解析。我的意思是，这是一篇文章，我引用它的话，“要了解更多信息和更温和的介绍，请参考<a class="ae lu" href="https://docs.python.org/3/howto/regex.html#regex-howto" rel="noopener ugc nofollow" target="_blank">正则表达式HOWTO </a>”如果你翻到那一页，你会发现，在我看来，这是一个同样充满敌意的陈述(或者是温柔的反义词),但是例子稍微多一点！</p><p id="c013" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我希望让这个世界处于一个比我发现时稍微好一点的状态——一个初出茅庐的数据科学家对你需要了解的关于正则表达式和Python的re库的简单综合。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c2cf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是正则表达式？Python的re库是什么？</h1><p id="d61a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这个综合有两个部分:正则表达式和Python的re库。我将它们分开是因为正则表达式是一个跨语言的工具，而Python的re库是这个工具的一个非常常见的特定于Python的实现。</p><p id="4398" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正则表达式可以用数学方法总结(而且很漂亮):它们告诉你一个字符串是否在一个<em class="mz">正则</em>集合中，其中正则集合被定义为包含可以用正则表达式表达的元素的集合。</p><p id="5230" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，您可以使用正则表达式来测试字符串是否符合某种格式(比如电子邮件的格式)或者是否包含某种字符序列。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="310d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">正则表达式的基础</h1><p id="df67" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这几乎是<em class="mz"> </em>曾经或将会存在的每一封电子邮件(按照当前的电子邮件法律规定):</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="a66d" class="ne md it lt b gy nf ng l nh ni">r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"</span></pre><p id="53b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个看起来可怕的东西是一个正则表达式，也称为regex，我希望在本节结束时，我们能够准确地解析它所说的内容。如果您已经熟悉正则表达式，可以跳过这一部分。否则，我们开始吧。</p><p id="a664" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正则表达式使用某些特殊字符和字符分组，例如:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="77f5" class="ne md it lt b gy nf ng l nh ni">.  ^  $  *  +  ?  {m}  {m, n}  \  [...]  |  (...)  \s  \S  \w  \d</span></pre><p id="942f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中大部分属于三个主要类别之一:字符集、修饰符和锚点。这些分类基本上只是指定您希望正则表达式如何理解您想要的字符串或模式的方法。</p><p id="4148" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在本节中的目标是使用每个分类来构建一个匹配字符串<code class="fe lq lr ls lt b">galaxy</code>的正则表达式。但是，为了进行更多的练习，当你通读这些描述和例子时，你可以拿出例子并用这个网站来测试你自己，我发现这个网站在我刚入门或需要进行理智检查时非常有用。</p><h2 id="c0e4" class="ne md it bd me nj nk dn mi nl nm dp mm ld nn no mo lh np nq mq ll nr ns ms nt bi translated">锚告诉正则表达式在哪里寻找匹配</h2><ul class=""><li id="1fa7" class="nu nv it kw b kx mu la mv ld nw lh nx ll ny lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">^</code>将匹配字符串的开头(它也有另外一个意思，不过我们以后再说！).例如，正则表达式<code class="fe lq lr ls lt b">^a</code>会告诉你<code class="fe lq lr ls lt b">abc</code>包含一个匹配项或者<code class="fe lq lr ls lt b">aaaaaaaxyz</code>包含一个匹配项(第一个<em class="mz"> a </em>在两者中都是匹配项)。然而，<code class="fe lq lr ls lt b">ba</code>不是一个匹配，因为它不是以a开头的。</li><li id="f376" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">$</code>将匹配字符串的结尾。例如，正则表达式<code class="fe lq lr ls lt b">a$</code>会告诉你<code class="fe lq lr ls lt b">cba</code>包含一个匹配项，但“aaaaaaaaah”不包含。</li></ul><p id="437c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用目前已知的字符构建一个正则表达式:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="0342" class="ne md it lt b gy nf ng l nh ni">^gy$</span></pre><p id="2273" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将只认为字符串<code class="fe lq lr ls lt b">gy</code>是匹配的，因为它是唯一以<em class="mz"> g </em>开头，以<em class="mz"> y </em>结尾的字符串，中间没有其他内容。我们将很快看到如何修改正则表达式，使字符串<code class="fe lq lr ls lt b">galaxy</code>匹配，但它不是这个正则表达式的匹配。</p><h2 id="9b53" class="ne md it bd me nj nk dn mi nl nm dp mm ld nn no mo lh np nq mq ll nr ns ms nt bi translated">字符集匹配字符，顾名思义</h2><ul class=""><li id="f28b" class="nu nv it kw b kx mu la mv ld nw lh nx ll ny lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">.</code>将匹配任何字符(除了新行)。例如，正则表达式<code class="fe lq lr ls lt b">a.</code>会认为<code class="fe lq lr ls lt b">as</code>匹配，或者<code class="fe lq lr ls lt b">a2</code>，或者<code class="fe lq lr ls lt b">aq</code>，或者<em class="mz">是一个</em>，后面跟有你能想到的任何其他字符。</li><li id="dcc4" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">[a-z]</code>(或<code class="fe lq lr ls lt b">[abcd]</code>或<code class="fe lq lr ls lt b">[0-9]</code>)将匹配括号中指定的任何字符。重要的是，虽然通常我们会想到用逗号列出元素，比如<code class="fe lq lr ls lt b">[1, 2, 3, 4]</code>，但是正则表达式却识别<code class="fe lq lr ls lt b">[1234]</code>。你也可以把两个范围串在一起，像<code class="fe lq lr ls lt b">[a-z1-9]</code>。因此，正则表达式<code class="fe lq lr ls lt b">[A-Z1-4]</code>会将<code class="fe lq lr ls lt b">A</code>或<code class="fe lq lr ls lt b">1G3HZ</code>识别为包含多个匹配，但不识别<code class="fe lq lr ls lt b">z99</code>(因为它区分大小写)。</li></ul><p id="a0ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以在以前的正则表达式的基础上进行构建:</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="1f69" class="ne md it lt b gy nf ng l nh ni">^g.[xX]y$</span></pre><p id="9a04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这仍然迫使我们的正则表达式只匹配以e开头或结尾的字符组，但是现在一个匹配也可以包含任何字符，后跟一个小写字母或大写字母<em class="mz"> x </em>。所以，<code class="fe lq lr ls lt b">goXy</code>是匹配的，<code class="fe lq lr ls lt b">g8xy</code>也是，甚至还有<code class="fe lq lr ls lt b">g?Xy</code>等很多例子。我们离<code class="fe lq lr ls lt b">galaxy</code>越来越近了！</p><h2 id="444c" class="ne md it bd me nj nk dn mi nl nm dp mm ld nn no mo lh np nq mq ll nr ns ms nt bi translated">修饰语修饰前面字符的含义</h2><ul class=""><li id="04b6" class="nu nv it kw b kx mu la mv ld nw lh nx ll ny lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">*</code>将匹配前一个字符0次或更多次。例如，<code class="fe lq lr ls lt b">ab*</code>将匹配<code class="fe lq lr ls lt b">a</code>、<code class="fe lq lr ls lt b">ab</code>、<code class="fe lq lr ls lt b">abb</code>等等，因为每个都有0个或更多的b实例。</li><li id="5c9b" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">+</code>跟<code class="fe lq lr ls lt b">*</code>差不多，但是1倍或者更多倍。因此，正则表达式<code class="fe lq lr ls lt b">ab+</code>将匹配<code class="fe lq lr ls lt b">ab</code>、<code class="fe lq lr ls lt b">abb</code>、<code class="fe lq lr ls lt b">abbb</code>等等，但不匹配<code class="fe lq lr ls lt b">a</code>，因为<code class="fe lq lr ls lt b">b</code>有0个实例。</li><li id="684d" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">?</code>类似于<code class="fe lq lr ls lt b">*</code>，但是0或1次，所以正则表达式<code class="fe lq lr ls lt b">ab?</code>将只匹配<code class="fe lq lr ls lt b">a</code>或<code class="fe lq lr ls lt b">ab</code>。</li><li id="e375" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">\</code>有几分熟悉；它转义了特殊字符的含义，比如<code class="fe lq lr ls lt b">*</code>，所以您也可以匹配这些字符，而不用使用方括号。</li><li id="0c36" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">注:<code class="fe lq lr ls lt b">+</code>、<code class="fe lq lr ls lt b">?</code>、<code class="fe lq lr ls lt b">*</code>的含义在方括号内更改；一般来说，当在括号内时，它们没有特殊的含义，而是代表要匹配的字符本身。在这一节的最后将给出一个例子。要记住的一个例外是<code class="fe lq lr ls lt b">^</code>，当它被放在方括号内的开头时:这意味着一个集合的补集——所有不是表达式所描述的字符。当它被直接放在方括号内时，就有了这个意思，就像在regex <code class="fe lq lr ls lt b">[[^abc]a-z]</code>中一样，它将匹配包含从d到z(小写)范围内的任何字母的任何字符串。</li></ul><p id="927b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在以前的正则表达式的基础上更进一步，非常非常接近匹配<code class="fe lq lr ls lt b">galaxy</code>。</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="880f" class="ne md it lt b gy nf ng l nh ni">^g.[alxX]+y$</span></pre><p id="3378" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将<em class="mz"> a </em>和<em class="mz"> l </em>添加到我们的方括号中，我们可以在我们的字符串中使用这些字母，并且在方括号后添加<code class="fe lq lr ls lt b">+</code>意味着该选择中的至少一个字母必须出现一次或多次。<code class="fe lq lr ls lt b">galaxy</code>终于匹配了！值得一提的是，<code class="fe lq lr ls lt b">gaallaaxxy</code>也是匹配的，<code class="fe lq lr ls lt b">goloxy</code>也是。我们的正则表达式还有改进的空间，下面的工具可以提供帮助。但是，已经达到了我们的主要目标——匹配“银河”——我将把它留给你。</p><h2 id="e503" class="ne md it bd me nj nk dn mi nl nm dp mm ld nn no mo lh np nq mq ll nr ns ms nt bi translated">要注意的其他字符或组:</h2><ul class=""><li id="ebc9" class="nu nv it kw b kx mu la mv ld nw lh nx ll ny lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">{m}</code>，其中<em class="mz"> m </em>是一个整数，将仅精确匹配前面字符的<em class="mz"> m </em>个重复。</li><li id="cfcf" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">{m, n}</code>将匹配尽可能少的<em class="mz"> m个</em>和尽可能多的<em class="mz"> n个</em>重复，尽可能贪婪(匹配尽可能多的字符串)。</li><li id="055c" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">{m, n}?</code>将匹配少至<em class="mz"> m </em>和多至<em class="mz"> n </em>的重复，但<strong class="kw iu">并不</strong>贪婪，因此将匹配尽可能少的字符串。</li><li id="cdb3" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">|</code>用于<code class="fe lq lr ls lt b">or</code>，这在很多情况下都是正确的，因此您可以从正则表达式<em class="mz"> A </em>和<em class="mz"> B </em>创建一个新的正则表达式，这样新的正则表达式就可以匹配<em class="mz"> A </em>或<em class="mz"> B </em>，如下所示:</li></ul><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="a0ae" class="ne md it lt b gy nf ng l nh ni">A | B</span></pre><ul class=""><li id="96d2" class="nu nv it kw b kx ky la lb ld oi lh oj ll ok lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">(regex)</code>会把里面所有的人物当做一个大组或者让你能够检索到某些匹配(或者称为一个捕获组，这有点超出了本文的范围，但是非常酷！).</li><li id="3d42" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">\d</code>将匹配所有数字。</li><li id="b14e" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">\D</code>将匹配所有非数字。</li><li id="b0de" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">\s</code>将匹配所有空白字符(空格、制表符等。).</li><li id="f7a5" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">\S</code>将匹配所有非空白字符。</li></ul><p id="6816" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有很多方法可以改变特殊字符的含义来对字符进行分组，但是为了节省时间和保持头脑清醒，我暂时不考虑这些方法。一旦您对这里介绍的内容感到满意，我强烈建议您进一步研究正则表达式符号。</p><p id="79c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，还可以结合正则表达式。一般来说，如果<em class="mz"> A </em>和<em class="mz"> B </em>是正则表达式，<em class="mz"> a </em>是<em class="mz"> A </em>的匹配项，<em class="mz"> b </em>是<em class="mz"> B </em>的匹配项，那么<code class="fe lq lr ls lt b">AB</code>(<em class="mz">A</em>和<em class="mz"> B </em>的串联)是正则表达式，<code class="fe lq lr ls lt b">ab</code>是<code class="fe lq lr ls lt b">AB</code>的匹配项。</p><p id="89ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了我们到目前为止已经学过的符号，以及我们已经学过的关键概念，我们终于可以(付出相当大的努力)分解描述电子邮件的正则表达式了！</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="81de" class="ne md it lt b gy nf ng l nh ni">r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"</span></pre><ul class=""><li id="332b" class="nu nv it kw b kx ky la lb ld oi lh oj ll ok lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">r"(</code> … <code class="fe lq lr ls lt b">)”</code>表示里面有一个正则表达式。</li><li id="480f" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">^[a-zA-Z0–9_.+-]+@</code>表示字母、数字、破折号、加号或下划线的任意组合，+表示这必须出现1次或更多次。毕竟，电子邮件必须在<em class="mz"> @ </em>之前至少有一个字符！开头的克拉(^)只允许以此格式开头的字符串算作有效的电子邮件，因为' ###foo@bar.com '不会是电子邮件。</li><li id="4f78" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">[a-zA-Z0-9-]+</code>表示字母数字字符和破折号的任意组合，同样必须在点(<em class="mz">之前至少出现一次。</em>)。</li><li id="6b6a" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">\.[a-zA-Z0-9-.]+$</code>通过用反斜杠转义<code class="fe lq lr ls lt b">.</code>的特殊含义并允许字母数字/虚线域名的任意组合来结束我们的电子邮件，这些组合必须在结尾(用<code class="fe lq lr ls lt b">+</code>表示)至少出现一次(用<code class="fe lq lr ls lt b">$</code>表示)。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2787" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Python re库的基础知识</h1><p id="7ca2" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">终于！在这一节中，我们将只讨论库中的一些方法。还有其他的，但是我们将只关注那些你最迫切需要知道的。还有正则表达式对象类型(比如Match)，我就不深入讨论了，只是让你知道一个方法返回那个类型。除非在同一个文件中反复使用同一个正则表达式，否则在正则表达式中使用正则表达式对象并不比只使用字符串更有效。但是，如您所知，您可能会看到一些文档使用与regex对象相关的方法(比如BeautifulSoup文档，它经常使用<code class="fe lq lr ls lt b">re.compile([regex])</code>)。方法上！</p><ul class=""><li id="0ade" class="nu nv it kw b kx ky la lb ld oi lh oj ll ok lp nz oa ob oc bi translated">在传递给它的字符串中查找第一个匹配，并返回一个匹配对象。这个对象将有一个布尔值<code class="fe lq lr ls lt b">true</code>，您可以将它传递给其他的正则表达式。我可以看到这在一个<code class="fe lq lr ls lt b">if</code>语句(<code class="fe lq lr ls lt b">if re.search([regex], [string]):</code>)中非常有用，尤其是如果您想在一个模式中找到一些特定的信息。你甚至可以把Match对象变成一个字典！(例如，如果给你一串地址，你想为每一个地址找一本字典，包括第一行、第二行、城市、州、邮政编码等等。)</li><li id="5b20" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">re.findall()</code>类似于re.search，但是会以字符串列表的形式返回所有不重叠的匹配。</li><li id="6dfd" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">re.VERBOSE()</code>用于编写跨多行注释的正则表达式，以便</li></ul><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="54d7" class="ne md it lt b gy nf ng l nh ni">r"([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"</span></pre><p id="7cda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变得越来越清晰</p><pre class="kj kk kl km gt na lt nb nc aw nd bi"><span id="4619" class="ne md it lt b gy nf ng l nh ni">re.VERBOSE([a-zA-Z0-9_.+-]+  # email user-name<br/>           @                 # the @ symbol<br/>           [a-zA-Z0-9-]+     # the domain name<br/>           \.[a-zA-Z0-9-.]+$ # the top-level domain<br/>           )</span></pre><p id="570f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该方法将忽略注释符号(' # ')之后的所有内容，直到行尾，因此您可以随心所欲地进行注释，并帮助其他人解除正则表达式的神秘性(万岁！).(你把它作为一个参数传递给像<code class="fe lq lr ls lt b">re.search()</code>这样寻找匹配的方法。)</p><ul class=""><li id="61e5" class="nu nv it kw b kx ky la lb ld oi lh oj ll ok lp nz oa ob oc bi translated"><code class="fe lq lr ls lt b">re.MULTILINE()</code>用于让<code class="fe lq lr ls lt b">^</code>在多行字符串的每一行的开头工作，而不仅仅是字符串的开头。因此，您可以使用这种方法在每一行的开头查找匹配项，而不必将一个多行字符串分成许多单独的字符串。(类似于<code class="fe lq lr ls lt b">re.VERBOSE</code>，您将它作为一个参数传递给类似于<code class="fe lq lr ls lt b">re.search()</code>的方法来寻找匹配。)</li><li id="d288" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">在这个库中，这可能是我最喜欢的方法。它使得对文本的解析。很多。更简单。例如，如果您正在解析一篇新闻文章，并且您想要使用的所有单词的列表，而不是使用典型的<code class="fe lq lr ls lt b">.split()</code>方法和一堆<code class="fe lq lr ls lt b">if</code>语句，那么您可以在regex <code class="fe lq lr ls lt b">[,:;“”!.*] | \b</code>上拆分。换句话说，在所有点或空白上分割。它像普通的<code class="fe lq lr ls lt b">str.split()</code>方法一样返回一个列表。这有多简单？</li></ul><p id="286a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一点:之前，我指定正则表达式可以告诉你一个字符串是否在正则集中。你可能问过自己，“什么是非正则集？”这是一个很好的问题！某些字符串不能写成正则表达式，比如“一系列的<em class="mz"> a </em> s，后面跟着同样数量的<em class="mz"> b </em> s，以及一半数量的<em class="mz"> c </em> s，”要找到这些，你需要一个更强大的工具，叫做上下文无关语法！</p><p id="4ea4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编辑:大声对<a class="ae lu" href="http://twitter.com/grahamhome333" rel="noopener ugc nofollow" target="_blank"> @grahamhome333 </a>说出来，我在解释邮件示例时忘记了第一克拉！</p></div></div>    
</body>
</html>