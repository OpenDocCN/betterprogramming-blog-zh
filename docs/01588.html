<html>
<head>
<title>How To Create a Follow Feature in Rails by Aliasing Associations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过别名关联在Rails中创建跟随特征</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-follow-feature-in-rails-by-aliasing-associations-30d63edee284?source=collection_archive---------7-----------------------#2019-09-26">https://betterprogramming.pub/how-to-create-a-follow-feature-in-rails-by-aliasing-associations-30d63edee284?source=collection_archive---------7-----------------------#2019-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="536d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用宏创建关联方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/162e1a8f63c24ee28d5e488846272084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K1sR7RDdrAV6J292"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本·科尔德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="18b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让用户能够在你的Rails应用中关注其他用户，你需要创建一个关注列表。下表将是一个连接表，它将用户表连接到自身。</p><p id="9296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，将表连接到自身的连接表有点令人费解。下表当然不能有两个<code class="fe lv lw lx ly b">user_id</code>列。幸运的是，Rails提供了别名关联的能力。<strong class="lb iu"> </strong>我们可以告诉Rails，一个ID是做以下事情的用户，另一个是被跟踪的用户。</p><p id="2254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请参见下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/3fc79343363ff159d0599f879b043a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fguqU19tu1cayG91bmKfAw@2x.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个用户作为关注者有很多关注者，一个用户作为被关注用户有很多关注者。我在这个图上画了两个用户模型，好像它们是分开的，但实际上它们是同一个模型。为了便于理解，这里将它们分开。</p></figure><p id="9aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了我们打算建立的关联，让我们开始吧。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8a03" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">创建下表</h1><p id="d45d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在Rails应用程序目录下的终端中，运行以下代码或类似的代码，以便将follows表添加到数据库中。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="091a" class="ni mi it ly b gy nj nk l nl nm">rails g model Follow follower_id:integer followed_user_id:integer</span></pre><p id="6260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将生成一个用于创建表的迁移文件，以及我们稍后将使用的模型文件。</p><p id="cf36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，<code class="fe lv lw lx ly b">follower_id</code>列保存了为其他用户提供关注的用户实例的ID，而<code class="fe lv lw lx ly b">followed_user_id</code>将保存被关注的用户的ID。</p><p id="f078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保运行<code class="fe lv lw lx ly b">rails db:migrate</code>，并检查您的模式看起来与下面类似。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/bd26f6233af050d3a4911e5aa34bf785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yz4FjD8TtLH_Dgkd1Xa8wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">请注意，我们已经有了一个用户表</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="dfda" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">概念理解</h1><p id="b3df" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在我们继续之前，让我们确保您了解我们最终要在这里构建什么。</p><p id="c523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建用户和关注者之间的关联时，实际上有两个最终目标——第一个是让给定的<code class="fe lv lw lx ly b">user</code>实例能够调用<code class="fe lv lw lx ly b">user.followers</code>来查看他们所有的关注者。第二个是用户能够调用<code class="fe lv lw lx ly b">user.followed_users</code>来查看他们关注的所有用户。</p><p id="6110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个最终目标都需要一个两步的过程。1.别名化用户表和follows表之间的多对多关联。2.别名化用户和用户之间的has-many-through关联。这是双向进行的。</p><p id="3f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">follower(用户)-&gt; follows -&gt; followed_users(用户)</p><p id="6616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">追随者_用户(用户)-&gt;追随者-&gt;追随者(用户)</p><p id="2a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个followed_user有很多关注他们的用户(关注者)，一个关注者有很多他们关注的用户(followed_users)。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e36a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">别名关联</h1><p id="aea9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们将下表连接到users表。我们将首先建立一个<code class="fe lv lw lx ly b">followed_user</code>和他们的追随者之间的has-many关系。</p><h2 id="6bf9" class="ni mi it bd mj no np dn mn nq nr dp mr li ns nt mt lm nu nv mv lq nw nx mx ny bi translated">关注属于用户(关注者和被关注用户)</h2><p id="d5e7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">您可以告诉ActiveRecord允许您能够呼叫<code class="fe lv lw lx ly b">user.followers</code>或<code class="fe lv lw lx ly b">user.followed_users</code>。</p><p id="f9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>如果我提供的命名约定令人困惑，考虑将<code class="fe lv lw lx ly b">user.followed_users</code>重命名为类似于<code class="fe lv lw lx ly b">user.users_they_follow</code>的名称，或者任何适合您的名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参见第3行和第6行</p></figure><p id="2b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把注意力集中在3号线上。这里，我们告诉Rails创建一个名为<code class="fe lv lw lx ly b">follower</code>的实例方法，以返回在给定follow实例中关注其他人的用户实例。</p><p id="32f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">行<code class="fe lv lw lx ly b">foreign_key: :follower_id</code>告诉Rails在下表中的属性<code class="fe lv lw lx ly b">:follower_id</code>下查找ID。然后，它获取这个ID并查看第<code class="fe lv lw lx ly b">class_name: “User”</code>行，这告诉Rails在users表的ID列中搜索给定的ID。将返回具有所述id的用户实例。</p><p id="2883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，为了获得关注者，Rails将使用<code class="fe lv lw lx ly b">follower_id</code>并尝试找到具有该ID的用户。</p><p id="9182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6行是另一个用户——被跟踪的用户。给定一个<code class="fe lv lw lx ly b">follow_instance</code>，我们可以调用<code class="fe lv lw lx ly b">follow_instance.followed_user</code>来返回第一个用户跟随的用户的用户实例。</p><p id="96a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rails将在下表中的<code class="fe lv lw lx ly b">followed_user_id</code>列下查找被跟踪的用户实例的ID。然后，它将在users表中搜索有问题的用户，并将其返回。</p><p id="5fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像前面一样，Rails基本上是采用<code class="fe lv lw lx ly b">followed_user_id</code>，找到具有该ID的对应用户，并返回它。</p><h2 id="9f29" class="ni mi it bd mj no np dn mn nq nr dp mr li ns nt mt lm nu nv mv lq nw nx mx ny bi translated">用户有许多已收到的关注</h2><p id="626e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">与任何隶属于关联一样，在另一个模型上也有一个伴随的has-many关联。</p><p id="86e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从能够看到用户实例的关注者开始。在这种情况下，我们需要告诉我们的用户，它有许多follow实例，其中用户是被关注的对象。也许我们可以尝试创建调用<code class="fe lv lw lx ly b">user.received_follows</code>的功能，以获得所有follow实例的数组，其中用户的ID列在<code class="fe lv lw lx ly b">followed_user_id</code>属性下。</p><p id="f644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong> <code class="fe lv lw lx ly b">has_many :follows</code>不够用。如果你要打电话给<code class="fe lv lw lx ly b">user.follows</code>，你怎么知道这个用户是关注者还是被关注者？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先关注第3行——这里，我们正在创建<code class="fe lv lw lx ly b">received_follows</code>的实例方法。就像前面一样，当我们编写选项<code class="fe lv lw lx ly b">foreign_key: :followed_user_id, class_name: “Follow”</code>时，我们告诉Rails检查follow表的<code class="fe lv lw lx ly b">followed_user_id</code>列，并搜索<code class="fe lv lw lx ly b">followed_user_id</code>匹配用户ID的follow实例。</p><h2 id="b3e3" class="ni mi it bd mj no np dn mn nq nr dp mr li ns nt mt lm nu nv mv lq nw nx mx ny bi translated">用户通过收到的关注拥有许多关注者</h2><p id="dc25" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们现在专注于第6行。这是一切汇集的地方。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="8556" class="ni mi it ly b gy nj nk l nl nm">has_many :followers, through: :received_follows, source: :follower</span></pre><p id="2b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们正在创建一个名为<code class="fe lv lw lx ly b">followers</code>的实例方法。注意<code class="fe lv lw lx ly b">:received_follows</code>和<code class="fe lv lw lx ly b">:follower</code>的使用，这是我们之前创建的两个方法。</p><p id="d64a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在常规的has-many-through关系中，我们首先选择列有实例ID的连接表中的所有实例。这将在连接表中返回一个实例数组，然后我们通过使用由<code class="fe lv lw lx ly b">belongs_to</code>方法创建的实例方法将它映射到一个不同的模型实例。</p><p id="a861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们做同样的事情——我们只是告诉Rails什么是连接表，以及我们将它映射到什么。</p><p id="46af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe lv lw lx ly b">:received_follows</code>部分指定<code class="fe lv lw lx ly b">user.received_follows</code>是连接表实例。事实上，它返回一个follow实例数组，其中所讨论的用户是followed _ user。</p><p id="dece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，Rails将follow实例映射到它们对应的follower(一个用户实例)。代码行<code class="fe lv lw lx ly b">source: :follower</code>告诉Rails通过对每个实例调用<code class="fe lv lw lx ly b">.follower</code>来映射从<code class="fe lv lw lx ly b">received_follows</code>返回的follow实例数组。这将创建一个用户实例数组，所有这些实例都是给定用户的追随者。</p><p id="6a21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把关注者转换成给<code class="fe lv lw lx ly b">followed_user</code>一个关注的用户。很好。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a399" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">为用户追随的用户的关联设置别名</h1><p id="7995" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如前所述，实际上有两个最终目标。我们让自己能够调用<code class="fe lv lw lx ly b">user.followers</code>来获取用户关注者的数组，但是如何获取用户关注的用户的数组呢？为此，我们还需要建立“多对多”和“多对多”协会。</p><p id="2574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个概念基本上保持不变，但是所引用的列和方法会有所不同。</p><p id="6f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将以下内容添加到用户模型中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参见第11行和第14行</p></figure><h2 id="6fcf" class="ni mi it bd mj no np dn mn nq nr dp mr li ns nt mt lm nu nv mv lq nw nx mx ny bi translated">用户有许多给定的追随者</h2><p id="a55d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对于第11行，我们使用<code class="fe lv lw lx ly b">has_many</code>宏来创建实例方法<code class="fe lv lw lx ly b">:given_follows</code>，它将返回一个follows数组，其中用户是follower。它通过查看下表(<code class="fe lv lw lx ly b">class_name: “Follow”</code>)并搜索所有<code class="fe lv lw lx ly b">:followed_user_id</code>是用户ID ( <code class="fe lv lw lx ly b">foreign_key: :followed_user_id</code>)的follow实例来实现这一点。</p><h2 id="d93c" class="ni mi it bd mj no np dn mn nq nr dp mr li ns nt mt lm nu nv mv lq nw nx mx ny bi translated">用户有许多以下通过给定的以下</h2><p id="ebe9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最后，第14行创建了一个实例方法，用于获取用户关注的所有用户。它运行<code class="fe lv lw lx ly b">:given_follows</code>(我们在第11行创建的)来获取join实例，然后通过在每个实例上调用<code class="fe lv lw lx ly b">:followed_user</code>(我们在第6行的<code class="fe lv lw lx ly b">our follow.rb</code>文件中创建的，见上文)来映射它们。这将返回一个用户数组。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e32c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="a405" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">你现在应该可以调用<code class="fe lv lw lx ly b">user.followers</code>和<code class="fe lv lw lx ly b">user.followings</code>了。现在，你可以使用这些方法在你的应用程序中显示社交媒体订阅源或计算用户的关注度。</p><p id="d311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，祝您编码愉快。</p></div></div>    
</body>
</html>