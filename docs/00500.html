<html>
<head>
<title>Create Your First CLI Application With Python Click</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python Click创建您的第一个CLI应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-click-building-your-first-command-line-interface-application-6947d5319ef7?source=collection_archive---------0-----------------------#2019-06-02">https://betterprogramming.pub/python-click-building-your-first-command-line-interface-application-6947d5319ef7?source=collection_archive---------0-----------------------#2019-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8036" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python构建命令行界面的简单指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1a8513a60d2961b861656231b90d4b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*hEbrY2aWOk9Q4NvG8rnhlQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://www.metasploit.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kv"> Metasploit </em> </a> <em class="kv">欢迎壳</em></p></figure><p id="2213" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">终点站的生活是甜蜜的。它可以快速启动任务，让多任务处理变得非常简单，并允许您保留那些原本会被花哨但不必要的GUI使用的资源。</p><p id="1bf0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">想想看，每当您想要跟踪文件中的更改时，都必须加载一个图形界面版本控制工具——这是多么浪费时间啊。这就是我们对应用程序命令行界面的需求。当您渴望为您或您的团队使用的应用程序创建一个CLI时，您当然可以通过构建一个来实现它！</p><p id="03ad" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在本文中，我们将探索用于创建命令行界面的<a class="ae ku" href="https://pypi.org/project/click/" rel="noopener ugc nofollow" target="_blank"> Python Click </a>。我们将熟悉Click最有用的功能，并在游戏中看到它们。要做到这一点，我们必须通过创建一个媒体文件转换器CLI应用程序来弄脏我们的手——一点脏东西没有坏处！</p><p id="0ade" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果你想直接进入完整的项目，这里的代码是<a class="ae ku" href="https://github.com/hogum/audioConvertor" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5bd6" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在Python click教程的第一部分，我们介绍了一个与click没有直接关系的通用但非常酷的命令行界面特性。如果你要创建你的第一个CLI应用程序，你会发现这个有点用。但是对于直接潜水，直接进入部分<a class="ae ku" href="https://medium.com/p/6947d5319ef7#90a9" rel="noopener"> <strong class="ky iu">将点击带入画面</strong> </a>。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="39ec" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">那么，为什么是命令行库呢？</h1><p id="1db0" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">Click是一个Python库。从头开始创建自己的CLI是可能的。看一下这个提示:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8915" class="nb ma it mx b gy nc nd l ne nf">$ &gt;&gt;&gt; Make the world go round?<br/>       A little [default]<br/>       Yes<br/>       No</span></pre><p id="b808" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是一个简单的提示，要求用户从三个可用选项中进行选择。我们可以简单地使用下面的命令:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="70d7" class="nb ma it mx b gy nc nd l ne nf">user_choice = input('Make the world go round?\n' +<br/>      'A little [default]\n' + 'Yes\n' + 'No\n')</span></pre><p id="1f2a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">就像那样，我们可以在命令行与用户交互。我们大胆地希望用户能从可用的选择中给我们一个回应——这可能不会发生。这就把我们带到了解析用户输入的问题。</p><p id="c154" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们必须为回复<em class="ng"> </em>“旋转它”或类似“我不确定”的更花哨的用户做好准备。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3d6c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">通过使用该条件进行循环，我们限制用户只能从三个选项中选择一个。应该可以了。</p><p id="c602" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">但是…请记住，如果用户没有指定任何内容，我们希望“一点点”<em class="ng"> </em>成为我们的默认选项。我们稍微调整了一下代码来适应这一点。我们最终应该得到如下结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6792" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">注意到解析单个用户输入需要多少耐心，这可能会减少兴奋感。大部分的努力都花在了处理不喜欢遵循指示的用户的附带情况上。</p><p id="f187" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果应用程序可以指出他们输入的错误，而不是重复同一行，那就更好了——这是另一个考虑因素。</p><p id="46aa" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">对于一个完整的CLI应用程序来说，这是可能的——解析每个提示，给出描述性的错误消息，给用户频繁的反馈(我们讨厌猜测——还记得上次你使用<a class="ae ku" href="https://en.wikipedia.org/wiki/Dd_(Unix)" rel="noopener ugc nofollow" target="_blank"> <strong class="ky iu"> <em class="ng"> dd </em> </strong> </a>)。重要的是，当我们将要做一些看起来很傻的事情时，我们应该被问及我们是否确定。</p><p id="61f7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们正在弄脏我们的手。我们应该专注于功能交付。命令行库就是用来消除这种痛苦的，这样我们就可以专注于酷的部分。记住，污垢不会伤害人——只要它只是一点点污垢！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/870a87849492449c371af4dbb7f6ef0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DuLkhp9LKIMUhJSV"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">扎克·卡多夫在<a class="ae ku" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="e5e3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">跳转到自变量向量(Argv)</h1><p id="e448" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">在旋转世界的例子中，我们使用<code class="fe no np nq mx b">input </code>与用户<em class="ng">进行交互。</em>然而，让用户在启动应用程序时直接输入更有意义。</p><p id="c0d2" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">要运行我们目前拥有的，我们将使用:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="7f72" class="nb ma it mx b gy nc nd l ne nf">&gt;&gt;&gt; python spin_world_v2.py</span><span id="c577" class="nb ma it mx b gy nr nd l ne nf">Make the world go round?<br/> A little [default]<br/> Yes<br/> No</span><span id="5480" class="nb ma it mx b gy nr nd l ne nf">: #    <em class="ng">User gives input</em></span></pre><p id="9e9e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">用户必须等待应用程序运行，以给出他们想要的输入。我们认为表现良好的脚本是:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="4665" class="nb ma it mx b gy nc nd l ne nf">&gt;&gt;&gt; python spin_world_v2.py 'a little'</span><span id="ee9b" class="nb ma it mx b gy nr nd l ne nf">#<em class="ng"> Then the world spins. Of course, a little</em></span></pre><p id="d6be" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这样，我们就不必等待输入提示来询问用户是否希望世界旋转。我们用<code class="fe no np nq mx b">argv </code>来做这件事。我们要不要再修改一下我们的第一个剧本？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="802f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">运行该脚本会产生以下结果:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8ef1" class="nb ma it mx b gy nc nd l ne nf"><strong class="mx iu">Option 1 - Known argument</strong><br/>&gt;&gt;&gt; python spin_world_v2.py 'a little'<br/>    <br/># <em class="ng">Output</em></span><span id="0dad" class="nb ma it mx b gy nr nd l ne nf">    [spin_world_v3.py 'a little'] # <em class="ng">Our argv list</em></span><span id="da76" class="nb ma it mx b gy nr nd l ne nf">    Spinning this thing a little<br/></span><span id="f872" class="nb ma it mx b gy nr nd l ne nf"><strong class="mx iu">Option 2 - Unknown argument</strong><br/>&gt;&gt;&gt; python spin_world_v2.py 'some more'</span><span id="78fe" class="nb ma it mx b gy nr nd l ne nf"># <em class="ng">Output</em></span><span id="ff0e" class="nb ma it mx b gy nr nd l ne nf">    [spin_world_v3.py 'a little'] # <em class="ng">Our argv list<br/>    <br/>    </em>Use with: a little yes, or no. Cool?</span></pre><p id="5a26" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们已经创建了一个命令行脚本。当要求用户在启动应用程序时提供参数时，所有命令行应用程序都使用argv概念。现在，当我们看到相同的概念时，它肯定会点击，但是使用点击库。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="249b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak">界面选项</strong></h1><p id="c68e" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们一直使用外壳<code class="fe no np nq mx b"><em class="ng">ls</em></code><em class="ng">。通过查看，我们可以学到一些关于接口的技巧。</em></p><p id="7c79" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在终端窗口中运行<code class="fe no np nq mx b"><em class="ng">ls</em></code> <em class="ng"> </em>:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="b768" class="nb ma it mx b gy nc nd l ne nf">ls</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/41b61a2a7a6a2ecb60d101f57e2049ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/0*98vkkfN1dRp6RI3E"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">ls上首页目录[ <a class="ae ku" href="https://www.tecmint.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kv">来源</em></a><em class="kv"/></p></figure><p id="7c2f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是一个简单的工具。我们可以在不引起争论的情况下使用它，并且很高兴。</p><p id="c971" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">但是争论的使用会让我们更快乐吗？让我们看看。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="eb76" class="nb ma it mx b gy nc nd l ne nf"> ls -l</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/744e94977ffb13c97f5c62c13c5b55e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*n3CYNBUsgdRMwnMR.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">运行ls -l [ <a class="ae ku" href="https://www.tecmint.com/" rel="noopener ugc nofollow" target="_blank">源</a></p></figure><p id="3eb7" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这里，我们通过请求细节使工具变得有点嘈杂。它向我们抛出了文件权限、所有者、组、大小、时间和名称。成功了！在这种情况下，<code class="fe no np nq mx b">-l</code>是一个选项。让我们看看关于它的使用的文档:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f1c8" class="nb ma it mx b gy nc nd l ne nf">&gt;&gt;&gt; ls --help<br/>Usage: ls [OPTION]... [FILE]...</span><span id="aca3" class="nb ma it mx b gy nr nd l ne nf"># <em class="ng">Run this to see the complete [OPTIONS] list</em></span></pre><p id="70c1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们看到<code class="fe no np nq mx b">ls</code> <em class="ng"> </em>只有两个参数——选项和可选路径。我们可以通过摆弄列出的选项来改变我们在文件和子目录中获得的信息的味道。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5c18" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">界面命令</h1><p id="1b54" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated"><code class="fe no np nq mx b">ls</code> <em class="ng"> </em>有选项。然而，我们<em class="ng">可以</em>说它没有命令。命令的用途是对CLI的相关选项进行分组。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c791" class="nb ma it mx b gy nc nd l ne nf">tool command --option</span></pre><p id="a8bf" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们可以在数百个命令中拥有数百个选项。为什么不把所有东西都放在一个选项列表中呢？这就像在你的房子里放满了陷阱，这样那些陷阱崇拜者就可以来拜访你了！应用程序的维护会很困难，用户会发现很难处理更复杂的功能。</p><p id="9de1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们回到我们的世界旋转的例子，看看一些很酷的命令。</p><p id="d314" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">世界的旋转在我们的掌控之中。也许我们可以指定<em class="ng">何时发生</em>旋转？我们的脚本可以有一个界面命令，允许我们设置旋转发生的时间。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="3a6f" class="nb ma it mx b gy nc nd l ne nf">python spin_world_v3.py time 0900 1700</span></pre><p id="a147" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在这里，我们设置我们希望世界旋转的时间间隔。从早上9点(0900小时，因为那是我们吃早餐的时间)到下午5点(1700小时，我们应该下班了)。由于现在是工作时间，我们可能希望世界在此期间比平时转得更快。</p><p id="9d3b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">因此，我们给我们的应用程序一个<em class="ng"> spin </em>命令，在这里我们可以指定旋转速度。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="29ba" class="nb ma it mx b gy nc nd l ne nf">python spin_world_v3.py time 0900 1700 --speed 1500m/h</span></pre><p id="fc38" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这让我们对CLI命令的概念有了简单的了解。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="90a9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将点击带入画面</h1><p id="2537" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们已经了解了命令行工具是如何工作的，以及创建命令行界面的基础知识。</p><p id="47e4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">现在，让我们创建我们的媒体转换器CLI应用程序。我们的应用程序应该允许我们将媒体文件转换成我们选择的格式。我们经常使用视频到音频的转换工具——如果能有一个我们自己可以调整的工具，那将是令人兴奋的。</p><h2 id="21c6" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated"><strong class="ak">应用程序设置</strong></h2><p id="09ac" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们的目录结构将如下所示:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="b2d2" class="nb ma it mx b gy nc nd l ne nf">| audioConvertor</span><span id="8bed" class="nb ma it mx b gy nr nd l ne nf">  |-convertor<br/>    |- __init__.py<br/>    |- utils<br/>      |- __init__.py<br/><strong class="mx iu">    |- cli.py</strong></span><span id="cc70" class="nb ma it mx b gy nr nd l ne nf">|- tests<br/>    |- __init__.py</span><span id="4c3e" class="nb ma it mx b gy nr nd l ne nf">- setup.py</span></pre><p id="e187" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们在文件<code class="fe no np nq mx b">cli.py</code>中创建应用程序的接口。</p><h2 id="bf7a" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated"><strong class="ak">添加使用选项</strong></h2><p id="be8a" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">要转换一个文件，我们需要知道它的位置。所以我们需要允许用户告诉我们的应用程序从哪里获取这个文件。我们通过创建一个简单的脚本来开始构建我们的应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a52b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们给用户一个选项<code class="fe no np nq mx b">--input_directory</code>来指定转换哪个文件<em class="ng">。我们可以如下运行脚本:</em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="6105" class="nb ma it mx b gy nc nd l ne nf">$ python cli.py --input_directory Videos/musicVideo.mp4</span><span id="a8e2" class="nb ma it mx b gy nr nd l ne nf"># <em class="ng">Output</em><br/>Videos/musicVideo.mp4</span></pre><p id="bd4d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们的脚本回显用户指定的文件。有用！</p><p id="1661" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们的用户如何知道如何与应用程序交互？一个简短的帮助<em class="ng"> </em>菜单很有魅力。用<em class="ng"> </em>点击<em class="ng">，</em>我们就能轻松免费地得到这个。让我们运行以下命令来检查一下:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="b544" class="nb ma it mx b gy nc nd l ne nf">$ python cli.py --help</span><span id="2ef0" class="nb ma it mx b gy nr nd l ne nf"># <em class="ng">Output</em></span><span id="991f" class="nb ma it mx b gy nr nd l ne nf">Usage: cli.py [OPTIONS]</span><span id="8699" class="nb ma it mx b gy nr nd l ne nf">audioConvertor is a command-line tool that helps convert video files to audio file formats.</span><span id="9c60" class="nb ma it mx b gy nr nd l ne nf">example: python cli.py -i input/file/path -o output/path</span><span id="c763" class="nb ma it mx b gy nr nd l ne nf">Options:<br/>  -i, --input_directory TEXT  Location of the media file to be converted<br/>  --help                      Show this message and exit.</span></pre><p id="fdfa" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">注意方便性<em class="ng">。</em> <code class="fe no np nq mx b">-i </code>也可以和<code class="fe no np nq mx b">--input_directory</code> <em class="ng">互换使用。</em>帮助示例说输出路径也是必要的。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2d14" class="nb ma it mx b gy nc nd l ne nf">example: python cli.py -i input/file/path -o output/path</span></pre><p id="705a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们可以通过在脚本中添加以下几行来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b03c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">添加的行标有<code class="fe no np nq mx b">++</code>。添加一个选项就像调用<code class="fe no np nq mx b">@click.option </code>并将我们的字符串传递给修饰函数一样简单。记得按照创造的顺序把你的选择传给<code class="fe no np nq mx b">main</code>。</p><h2 id="8f48" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated"><strong class="ak"> <em class="kv">解析用户选项</em> </strong></h2><p id="f764" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">在我们试图转换文件之前确认它的存在是一种好的习惯。我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fc63" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">如果用户提供了一个不存在的媒体文件，脚本现在应该会终止。但是有了Click，解析和验证就由我们来处理了。下面的代码片段与我们刚才所做的一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e735" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">奇迹发生在第六行。通过给Click的options命令提供<code class="fe no np nq mx b">type</code> <em class="ng"> </em>参数，我们可以告诉Click确保用户给出的as <code class="fe no np nq mx b">--input_directory</code> <em class="ng"> </em>作为路径，并且它存在。</p><p id="be8e" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">Click给了我们大量的参数用于选项中。随着我们的进步，我们将会看到更多这样的例子。</p><h2 id="d82c" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated"><strong class="ak">添加命令</strong></h2><p id="623e" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">为了方便用户，使用命令将允许我们隔离应用程序的不同特性。这也使得添加新选项变得更加容易。例如，我们有两个选项——将它们嵌套在描述它们做什么的命令中是有意义的。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="11b3" class="nb ma it mx b gy nc nd l ne nf">python cli.py convert -i input/file/path -o output/path</span></pre><p id="dd20" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们希望将我们的选项捆绑在一个<code class="fe no np nq mx b">convert</code>命令中，这样我们的应用程序就可以像图中所示的那样使用。除了转换，我们还希望我们的应用程序做什么？如果我们可以播放我们转换的歌曲，那就太好了。因此，如果我们像下面这样使用它，我们的扬声器应该会弹出一些东西:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2c00" class="nb ma it mx b gy nc nd l ne nf">python cli.py play --playlist path/to/audio</span></pre><p id="aee5" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们知道我们希望我们的应用程序如何工作。我们开始吧。</p><h2 id="28c8" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated"><strong class="ak"> <em class="kv">分组命令</em> </strong></h2><p id="06a7" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">我们做的第一件事是将命令<code class="fe no np nq mx b">play</code>和<code class="fe no np nq mx b">convert</code>添加到我们的应用程序中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bea4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们看一下这个脚本。</p><p id="1e0f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们有三个功能:——<code class="fe no np nq mx b">main</code>、<code class="fe no np nq mx b">load_files</code>和<code class="fe no np nq mx b">load_audio</code>。功能<code class="fe no np nq mx b">main</code> <em class="ng"> </em>是通过用<code class="fe no np nq mx b">@click.group</code> <em class="ng">修饰来帮助我们用Click将两个命令分组。这是我们的第一步。</em></p><p id="9413" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">之后，注意添加一个命令是多么容易——我们调用<code class="fe no np nq mx b">@main.command </code>,然后指定我们认为会让我们高兴的选项。</p><p id="e17c" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">有这样一句话:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f7d4" class="nb ma it mx b gy nc nd l ne nf">@click.pass_context</span></pre><p id="c9b2" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">每当我们想要使用command中指定的参数，但是在不同的函数中，我们传递它的上下文。这是通过将它存储在click <em class="ng">上下文对象</em>字典中来实现的。看看我们在第21行做了什么:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="45fc" class="nb ma it mx b gy nc nd l ne nf">ctx.obj[‘VERBOSE’] = verbose</span></pre><p id="a986" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这允许我们通过传入<code class="fe no np nq mx b">ctx</code> <em class="ng">来使用click decorator访问任何其他函数中<code class="fe no np nq mx b">VERBOSE</code>的值。</em>(记得用第52行的<code class="fe no np nq mx b">obj</code>参数调用main)。例如:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="dbd0" class="nb ma it mx b gy nc nd l ne nf">def load_files(ctx, input_directory, output):<br/>    """<br/>        :   Convert video file input to audio.<br/>    """<br/>    if ctx.obj.get('VERBOSE'):<br/>        # <em class="ng">shout a lot</em><br/>    else:<br/>       #  <em class="ng">convert quietly</em></span></pre><p id="4c55" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们也为我们的命令选项引入了一些新的参数。以下是他们帮助我们实现的目标:</p><ul class=""><li id="58b2" class="of og it ky b kz la lc ld lf oh lj oi ln oj lr ok ol om on bi translated"><code class="fe no np nq mx b">required</code>:必输项。</li><li id="3b11" class="of og it ky b kz oo lc op lf oq lj or ln os lr ok ol om on bi translated"><code class="fe no np nq mx b">multiple</code>:允许用户添加多个参数，如convert-<em class="ng">I</em>video _ 1-<em class="ng">I</em>video _ 2。</li><li id="6f67" class="of og it ky b kz oo lc op lf oq lj or ln os lr ok ol om on bi translated"><code class="fe no np nq mx b">nargs</code> <em class="ng"> : </em>几乎相同的一个<em class="ng"> s倍数例如</em>convert-<em class="ng">I</em>video _ 1 video _ 2 video _ 3</li></ul><p id="c6c0" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">在我们的例子中，<code class="fe no np nq mx b">nargs</code>将帮助我们指定多个输入文件。</p><ul class=""><li id="d499" class="of og it ky b kz la lc ld lf oh lj oi ln oj lr ok ol om on bi translated"><code class="fe no np nq mx b">is_flag</code>:不需要参数的布尔选项`。</li></ul><h2 id="8068" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated"><strong class="ak"> <em class="kv">转换—选项</em> </strong></h2><p id="bc4b" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">让我们列出运行convert命令的函数<code class="fe no np nq mx b">(<em class="ng">load_files</em>)</code>的所有decorators。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="658a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这是我们CLI中一个命令的选项列表。现在让我们开始处理从用户那里收到的参数。为了便于维护，我们将把所有的处理功能隔离到一个新文件中，在一个名为<code class="fe no np nq mx b">Convertor</code>的类中。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="a1e9" class="nb ma it mx b gy nc nd l ne nf">| audioConvertor</span><span id="de35" class="nb ma it mx b gy nr nd l ne nf">|-convertor<br/>    |- __init__.py<br/>    |- utils<br/>      |- __init__.py<br/><strong class="mx iu">   </strong> |- cli.py<br/><strong class="mx iu">    |- formats.py</strong></span><span id="2c65" class="nb ma it mx b gy nr nd l ne nf">|- tests<br/>    |- __init__.py</span><span id="ecfe" class="nb ma it mx b gy nr nd l ne nf">- setup.py</span></pre><p id="d60f" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">既然我们的重点是CLI，就不在<code class="fe no np nq mx b">Convertor</code> <strong class="ky iu"> <em class="ng"> </em> </strong>类上纠缠了。但是我努力把它很好地记录下来，所以不要担心。</p><p id="e5c4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们将这些行添加到我们的<code class="fe no np nq mx b">cli.py</code>的顶部:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="578f" class="nb ma it mx b gy nc nd l ne nf">import click<br/>from formats import Convertor # +</span><span id="e499" class="nb ma it mx b gy nr nd l ne nf">convertor_instance = Convertor() # +</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">处理用户输入</p></figure><p id="1335" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们用上面的选项在我们的界面上摆弄一下:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="7b56" class="nb ma it mx b gy nc nd l ne nf">$ python3 convertor/cli.py convert -i /root/Videos/</span><span id="a56a" class="nb ma it mx b gy nr nd l ne nf"># <em class="ng">Output</em><br/>/root/Videos/ is a directory. --recursive Needed for a directory</span></pre><p id="359a" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">让我们将应用指向一个文件，并尝试再次转换它:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="85f2" class="nb ma it mx b gy nc nd l ne nf">python3 convertor/cli.py convert -i Videos/snoring_noises.avi</span><span id="4a86" class="nb ma it mx b gy nr nd l ne nf"><em class="ng"><br/></em>Input specified as file name</span><span id="a500" class="nb ma it mx b gy nr nd l ne nf">.<br/>.<br/>Conversion Complete<br/>saved: snoring_noises.mp3</span></pre><p id="1afc" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">应用程序应该提示我们安装<code class="fe no np nq mx b"><a class="ae ku" href="https://pypi.org/project/ffmpeg-python/" rel="noopener ugc nofollow" target="_blank">ffmpeg</a></code> <em class="ng">，</em>这是我们应该使用的媒体转换器库。越来越令人兴奋了！</p><p id="3919" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">接下来，让我们允许用户通过运行以下命令一次转换多个视频文件:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="d2ac" class="nb ma it mx b gy nc nd l ne nf">python3 convertor/cli.py convert -i /root/Videos/* -o /root/converted_music</span></pre><p id="19d8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这个命令应该为我们将视频文件夹中的所有视频文件转换成音频，并将输出保存到目录<code class="fe no np nq mx b">converted_music</code>。将以下代码添加到<code class="fe no np nq mx b">load_files</code>函数中应该可以做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">++在“加载文件”函数中</p></figure><h2 id="0666" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated"><strong class="ak"> <em class="kv">播放—选项</em> </strong></h2><p id="57a6" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">播放命令装饰了<em class="ng"> </em> <code class="fe no np nq mx b">load_audio</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d7de" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">该应用程序现在应该允许我们加载我们选择的播放列表。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="6b0a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak">链接命令</strong></h1><p id="5a95" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">每当我们想要转换一个文件然后播放它的音频，我们的CLI应用程序限制我们单独运行<em class="ng">转换</em>和<em class="ng">播放</em>命令。这已经足够好了，但是如果我们能像下面这样使用接口不是更好吗？</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="7082" class="nb ma it mx b gy nc nd l ne nf">python convertor/cli.py <strong class="mx iu"><em class="ng">convert</em></strong> -<em class="ng">i</em> my_video_file.mp4 <strong class="mx iu"><em class="ng">play</em></strong></span></pre><p id="7705" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">为了一次使用多个命令，我们将<code class="fe no np nq mx b">chain</code>参数传递给多命令:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="9992" class="nb ma it mx b gy nc nd l ne nf"><a class="ae ku" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.group(invoke_without_command=True, chain=True)</span></pre><p id="9f5d" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这只是第一步。我们先援引<code class="fe no np nq mx b">convert</code> <em class="ng"> </em>。当我们稍后运行<code class="fe no np nq mx b">play</code> <em class="ng"> </em>时，需要知道我们转换后的文件的位置。对于每次成功的转换，我们的界面应该知道保存文件的路径。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="683f" class="nb ma it mx b gy nc nd l ne nf">ctx.obj[‘PLAYLIST’] = convertor_instance.get_file_save_path()</span></pre><p id="1cc8" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们添加了<code class="fe no np nq mx b">PLAYLIST</code>键作为所有子命令都可以访问的上下文。<code class="fe no np nq mx b">get_file_save_path </code>就是做这个的函数。在<code class="fe no np nq mx b">load_files </code>功能中的两个地方添加上述行:</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="8a86" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">一些额外考虑</h1><h2 id="6b7c" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated">单个和多个文件转换</h2><p id="5634" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">为了区分单个和多个文件输入，一个改进是允许用户设置一个递归选项。在处理过程中,<code class="fe no np nq mx b">recursive </code>标志会告诉我们是转换一个文件还是多个文件。</p><p id="c117" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">此外，为了检查输入是否是一个目录，我们递归遍历它的所有子目录，找到任何匹配视频格式的有效文件。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="7ecc" class="nb ma it mx b gy nc nd l ne nf">if os.path.isfile(input_directory) and not recursive:<br/>    # <em class="ng">convert single file<br/></em>else:<br/><em class="ng">    </em># <em class="ng">convert multiple files</em></span></pre><p id="c89b" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这就解决了我们的问题。我们甚至可以使用通配符<code class="fe no np nq mx b">*</code>递归匹配输入文件:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2a78" class="nb ma it mx b gy nc nd l ne nf">python convertor/cli.py <strong class="mx iu"><em class="ng">convert</em></strong> -<em class="ng">i</em> Videos/snoring*.mp4 <strong class="mx iu"><em class="ng">play</em></strong></span></pre><h2 id="90e6" class="nb ma it bd mb nu nv dn mf nw nx dp mj lf ny nz ml lj oa ob mn ln oc od mp oe bi translated">可选参数</h2><p id="b782" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">如果我们尝试运行上述命令，我们可能会得到如下输出:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="043e" class="nb ma it mx b gy nc nd l ne nf">python convertor/cli.py <strong class="mx iu"><em class="ng">convert</em></strong> -<em class="ng">i</em> Videos/snoring*.mp4 <strong class="mx iu"><em class="ng">play</em></strong></span><span id="cfa5" class="nb ma it mx b gy nr nd l ne nf">Usage: cli.py play [OPTIONS]<br/>Try "cli.py play --help" for help.</span><span id="63bd" class="nb ma it mx b gy nr nd l ne nf">Error: Missing option "--playlist" / "-p".</span></pre><p id="59e1" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">这意味着<code class="fe no np nq mx b">playlist </code>是一个必需的参数。要使其可选，需要设置为<code class="fe no np nq mx b">False </code>，如下所示:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="aae6" class="nb ma it mx b gy nc nd l ne nf"><a class="ae ku" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.option('--playlist', '-p', required=<strong class="mx iu">False</strong>, type=click.Path(exists=True),<br/>              help="Folder containing audio files to be played")</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="0e80" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak">结论</strong></h1><p id="2f55" class="pw-post-body-paragraph kw kx it ky b kz mr ju lb lc ms jx le lf mt lh li lj mu ll lm ln mv lp lq lr im bi translated">就这样了，伙计们。</p><p id="1ee9" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">我们现在已经熟悉了命令行界面，并学习了如何使用Click <em class="ng">将应用程序连接到终端。</em>希望这篇Python点击教程已经帮助你收获了一些令人兴奋的有用的东西。记住你可以在GitHub repo<a class="ae ku" href="https://github.com/hogum/audioConvertor" rel="noopener ugc nofollow" target="_blank">上浏览整个项目。</a></p><p id="d4d4" class="pw-post-body-paragraph kw kx it ky b kz la ju lb lc ld jx le lf lg lh li lj lk ll lm ln lo lp lq lr im bi translated">你太棒了。让您的下一个CLI更好。</p></div></div>    
</body>
</html>