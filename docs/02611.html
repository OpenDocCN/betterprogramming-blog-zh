<html>
<head>
<title>Stream Flutter: Building a Social Network with Stream Activity Feeds and Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Stream Flutter:用Stream Activity Feeds和Flutter构建一个社交网络</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stream-flutter-building-a-social-network-with-stream-activity-feeds-and-flutter-2d59bc5fe19b?source=collection_archive---------6-----------------------#2019-12-12">https://betterprogramming.pub/stream-flutter-building-a-social-network-with-stream-activity-feeds-and-flutter-2d59bc5fe19b?source=collection_archive---------6-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="171b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个简单的社交网络，允许用户向关注者发布消息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b91adc6c88c79da506507bac5101cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5ZOm0C3wBOIIBqxh1ARZg.jpeg"/></div></div></figure><p id="af0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本帖中，我们将创建一个简单的社交网络，名为Stream Flutter，允许用户向关注者发布消息。</p><p id="06dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Stream的<a class="ae lq" href="https://getstream.io/activity-feeds/" rel="noopener ugc nofollow" target="_blank"> Activity Feed API </a>结合谷歌的<a class="ae lq" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank"> Flutter </a>使得构建这种复杂的交互变得简单。这个应用程序的所有源代码都可以在<a class="ae lq" href="https://github.com/psylinse/flutter_the_stream" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。该应用程序在iOS和Android上都完全可用。</p><p id="6ddc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简洁，当我们需要下降到本机代码时，我们将只关注Android。你可以找到相应的iOS代码，看看事情是怎么实现的。为了保持重点，我们将展示更重要的代码片段来表达每一部分的思想。这些代码片段通常有重要的上下文，比如布局或导航。如果你对一些东西是如何工作的或者我们如何到达一个屏幕感到困惑，请参考完整的源代码。每个片段都附有一个注释，解释它来自哪个文件和行。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1d58" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">建筑流颤动:活动源</h1><p id="fa60" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了建立我们的社交网络，我们需要一个后端和一个移动应用程序。大部分工作是在移动应用程序中完成的，但是我们需要后端安全地创建前端令牌来与流API交互。</p><p id="4432" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于后端，我们依靠<a class="ae lq" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a> (Node.js)利用Stream的<a class="ae lq" href="https://github.com/GetStream/stream-js" rel="noopener ugc nofollow" target="_blank"> JavaScript库</a>。</p><p id="ef7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于前端，我们用Flutter wrapping Stream的<a class="ae lq" href="https://github.com/GetStream/stream-java" rel="noopener ugc nofollow" target="_blank"> Java </a>和<a class="ae lq" href="https://github.com/getstream/stream-swift" rel="noopener ugc nofollow" target="_blank"> Swift </a>库来构建。</p><p id="2239" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要发布更新，应用程序将执行以下步骤:</p><ul class=""><li id="5058" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">用户在我们的移动应用程序中键入他们的姓名即可登录。</li><li id="8682" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">移动应用向我们的后端注册用户，并接收流活动提要<a class="ae lq" href="https://getstream.io/blog/integrating-with-stream-backend-frontend-options/" rel="noopener ugc nofollow" target="_blank">前端令牌</a>。</li><li id="c8e1" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户输入他们的信息，点击“发布”。移动应用使用流令牌创建流活动，使用Flutter的<a class="ae lq" href="https://flutter.dev/docs/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">平台通道</a>通过<a class="ae lq" href="https://github.com/GetStream/stream-java" rel="noopener ugc nofollow" target="_blank"> Java </a>或<a class="ae lq" href="https://github.com/getstream/stream-swift" rel="noopener ugc nofollow" target="_blank"> Swift </a>连接到<a class="ae lq" href="https://getstream.io/docs_rest/" rel="noopener ugc nofollow" target="_blank"> Stream的REST API </a>。</li><li id="a57d" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户查看他们的帖子。移动应用程序通过Stream检索其<code class="fe nj nk nl nm b">user</code>提要来实现这一点。</li></ul><p id="4d8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果另一个用户想要关注一个用户并查看他们的消息，应用程序会经历以下过程:</p><ul class=""><li id="668a" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">登录(见上文)。</li><li id="8512" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户导航到用户列表并选择要关注的用户。移动应用程序直接与Stream API通信，在他们的<code class="fe nj nk nl nm b">timeline</code>提要上创建一个<a class="ae lq" href="https://getstream.io/get_started/#follow" rel="noopener ugc nofollow" target="_blank">关注者关系</a>。</li><li id="786b" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">用户查看他们的时间线。移动应用程序使用Stream API来检索他们的<code class="fe nj nk nl nm b">timeline</code>订阅源，该订阅源由他们关注的人的所有消息组成。</li></ul><p id="4112" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码在包含在<code class="fe nj nk nl nm b">mobile</code>目录中的Flutter移动应用程序和位于<code class="fe nj nk nl nm b">backend</code>目录中的Express后端之间进行拆分。请参见每个文件夹中的<code class="fe nj nk nl nm b">README.md</code>了解安装和运行说明。如果你想继续运行代码，确保你的后端和移动应用都在运行。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5b7f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">先决条件</h1><p id="49c7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">遵循本教程需要具备<a class="ae lq" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> (JavaScript)和<a class="ae lq" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank"> Flutter </a> ( <a class="ae lq" href="https://dart.dev/" rel="noopener ugc nofollow" target="_blank"> Dart </a>)的基础知识。此代码旨在在您的计算机上本地运行。</p><p id="5dbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想跟进，你需要一个<a class="ae lq" href="https://getstream.io/accounts/signup/" rel="noopener ugc nofollow" target="_blank"> Stream </a>的账户。请确保你可以运行一个Flutter应用程序，至少在Android上。如果你还没有这样做，确保你已经安装了Flutter <a class="ae lq" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank">和</a>。如果您在构建这个项目时遇到问题，请检查您是否可以按照这里的说明<a class="ae lq" href="https://flutter.dev/docs/get-started/test-drive" rel="noopener ugc nofollow" target="_blank">创建并运行一个简单的应用程序。</a></p><p id="0e06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">拥有Stream帐户后，您需要设置一个开发应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/6274200aa2aa7acc9199d6d18b6cd947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rA7t-sQXzfmkct7oVVktig.png"/></div></div></figure><p id="730a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您需要将Stream应用程序中的凭据添加到源代码中，这样它才能工作。参见<code class="fe nj nk nl nm b">mobile</code>和<code class="fe nj nk nl nm b">backend</code>阅读信息。</p><p id="78ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始建造吧！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3208" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">用户发布状态更新</h1><p id="e047" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们将从允许用户发布消息开始。</p><h2 id="dc96" class="no lz it bd ma np nq dn me nr ns dp mi ld nt nu mk lh nv nw mm ll nx ny mo nz bi translated">第一步:登录</h2><p id="2e68" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">为了与Stream API通信，我们需要一个安全的前端令牌，允许我们的移动应用程序直接与Stream进行身份验证。这避免了必须通过<code class="fe nj nk nl nm b">backend</code>代理。为此，我们需要一个后端端点，它使用我们的流帐户秘密来生成这个令牌。一旦我们有了这个令牌，我们不需要后端做任何其他事情，因为移动应用程序可以访问完整的流API。</p><p id="f3a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们将构建如下所示的登录屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9baf9a8ea134af8a5890684ac85b01e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_F3FWoIY1E6tVW9rkkwrWQ.png"/></div></div></figure><p id="2d9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们在Flutter中布置我们的表单。在我们的<code class="fe nj nk nl nm b">main.dart</code>文件中，我们将创建一个简单的检查来查看我们是否登录，如果我们没有登录，则向用户显示一个登录表单:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="32d2" class="no lz it nm b gy of og l oh oi">// mobile/lib/main.dart:65<br/>@override<br/>Widget build(BuildContext context) {<br/>  if (_account != null) {<br/>    // ... show full application once we're logged in<br/>  } else {<br/>    return Scaffold(<br/>      appBar: AppBar(<br/>        title: Text("The Stream"),<br/>      ),<br/>      body: Builder(<br/>        builder: (BuildContext context) {<br/>          return Container(<br/>            padding: EdgeInsets.all(12.0),<br/>            child: Center(<br/>              child: Column(<br/>                children: [<br/>                  TextField(<br/>                    controller: _userController,<br/>                  ),<br/>                  RaisedButton(<br/>                    onPressed: () =&gt; _login(context),<br/>                    child: Text("Login"),<br/>                  ),<br/>                ],<br/>              ),<br/>            ),<br/>          );<br/>        },<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="affd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl nm b">_account</code>变量是一个简单的<code class="fe nj nk nl nm b">Map&lt;String, String&gt;</code>对象，它将包含后端<code class="fe nj nk nl nm b">authToken</code>和流<code class="fe nj nk nl nm b">feedToken</code>。<code class="fe nj nk nl nm b">authToken</code>用于向后端发出进一步的请求，稍后我们将使用它来检索用户列表。<code class="fe nj nk nl nm b">feedToken</code>是流前端令牌，它允许访问流API。</p><p id="78d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了设置<code class="fe nj nk nl nm b">_account</code>变量，我们获取用户按下“Login”后输入的字符串，并将其传递给<code class="fe nj nk nl nm b">ApiService</code>来执行身份验证。下面是我们的<code class="fe nj nk nl nm b">_login(..)</code>函数:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="db26" class="no lz it nm b gy of og l oh oi">// mobile/lib/main.dart:45<br/>Future _login(BuildContext context) async {<br/>  if (_userController.text.length &gt; 0) {<br/>    var creds = await ApiService().login(_userController.text);<br/>    setState(() {<br/>      _account = {<br/>        'user': _userController.text,<br/>        'authToken': creds['authToken'],<br/>        'feedToken': creds['feedToken'],<br/>      };<br/>    });<br/>  } else {<br/>    Scaffold.of(context).showSnackBar(<br/>      SnackBar(<br/>        content: Text('Invalid User'),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="d60b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用用户名从后端获取凭证，并将其存储在<code class="fe nj nk nl nm b">_account</code>变量中。这是两个调用——一个获取<code class="fe nj nk nl nm b">backend</code>认证令牌，另一个获取流API令牌。为此，让我们看看我们的<code class="fe nj nk nl nm b">ApiService#login</code>的实现:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="928d" class="no lz it nm b gy of og l oh oi">// mobile/lib/api_service.dart:10<br/>Future&lt;Map&gt; login(String user) async {<br/>  var authResponse = await http.post('$_baseUrl/v1/users', body: {'sender': user});<br/>  var authToken = json.decode(authResponse.body)['authToken'];<br/>  var feedResponse = await http<br/>      .post('$_baseUrl/v1/stream-feed-credentials', headers: {'Authorization': 'Bearer $authToken'});<br/>  var feedToken = json.decode(feedResponse.body)['token'];</span><span id="6d89" class="no lz it nm b gy oj og l oh oi">  return {'authToken': authToken, 'feedToken': feedToken};<br/>}</span></pre><p id="2d27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生了两件事。首先，我们向后端注册一个用户，并获得一个<code class="fe nj nk nl nm b">authToken</code>。使用这个<code class="fe nj nk nl nm b">authToken</code>,我们请求后端创建我们的流活动提要前端令牌。</p><p id="2ff5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl nm b">backend</code>中的用户注册端点只是将用户存储在内存中，并为auth生成一个简单的令牌。这不是一个真正的实现，应该用任何适用于您的应用程序的身份验证和用户管理来代替。正因为如此，这里就不赘述了(有兴趣请参考源代码)。</p><p id="144b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了生成我们的流令牌，让我们看看后端是如何生成的:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="e36c" class="no lz it nm b gy of og l oh oi">// backend/src/controllers/v1/stream-feed-credentials/stream-feed-credentials.action.js:6<br/>exports.streamFeedCredentials = async (req, res) =&gt; {<br/>  try {<br/>    const data = req.body;<br/>    const apiKey = process.env.STREAM_API_KEY;<br/>    const apiSecret = process.env.STREAM_API_SECRET;<br/>    const appId = process.env.STREAM_APP_ID;</span><span id="2038" class="no lz it nm b gy oj og l oh oi">    const client = stream.connect(apiKey, apiSecret, appId);</span><span id="3d09" class="no lz it nm b gy oj og l oh oi">    await client.user(req.user.sender).getOrCreate({ name: req.user.sender });<br/>    const token = client.createUserToken(req.user.sender);</span><span id="1f41" class="no lz it nm b gy oj og l oh oi">    res.status(200).json({ token, apiKey, appId });<br/>  } catch (error) {<br/>    console.log(error);<br/>    res.status(500).json({ error: error.message });<br/>  }<br/>};</span></pre><p id="1ded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码使用我们的秘密帐户凭证来创建一个流用户并注册用户名。<code class="fe nj nk nl nm b">getOrCreate</code>调用创建了一个带有名称的用户(或者如果我们已经注册了用户，就检索这个用户)。一旦我们创建了用户，我们就将必要的凭证返回给移动应用程序。</p><p id="afeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">登录后，我们就可以发布第一条消息了！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="097a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤2:发布消息</h1><p id="4896" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在我们将构建一个表单，向我们的流活动提要发布一条状态消息。在本教程中，我们不会深入探讨导航和布局。如果你对我们如何到达这个屏幕感到好奇，请参考来源。我们需要建立一个表单，将用户想对他们的追随者说的话提交给Stream。</p><p id="754d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一，形式:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="0b7d" class="no lz it nm b gy of og l oh oi">// mobile/lib/new_activity.dart:35<br/>@override<br/>Widget build(BuildContext context) {<br/>  return Scaffold(<br/>    appBar: AppBar(<br/>      title: Text("Post Message"),<br/>    ),<br/>    body: Builder(<br/>      builder: (context) {<br/>        return Container(<br/>          padding: EdgeInsets.all(12.0),<br/>          child: Center(<br/>            child: Column(<br/>              children: [<br/>                TextField(<br/>                  controller: _messageController,<br/>                ),<br/>                MaterialButton(<br/>                  onPressed: () =&gt; _postMessage(context),<br/>                  child: Text("Post"),<br/>                ),<br/>              ],<br/>            ),<br/>          ),<br/>        );<br/>      },<br/>    ),<br/>  );<br/>}</span></pre><p id="89f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将产生如下所示的抖动视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b1cd9e8b5c0028b1789379252b80d026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGwvpTA_Mmi8wpwnv7o9Aw.png"/></div></div></figure><p id="e1d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的Flutter小部件，它使用一个<code class="fe nj nk nl nm b">TextEditingController</code>来跟踪用户的输入，使用一个<code class="fe nj nk nl nm b">MaterialButton</code>来触发post。</p><p id="d215" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看<code class="fe nj nk nl nm b">_postMessage</code>的实现，这就是我们如何创建<a class="ae lq" href="https://getstream.io/docs/#adding-activities" rel="noopener ugc nofollow" target="_blank">活动</a>，以及我们的消息，在流中:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="a6ca" class="no lz it nm b gy of og l oh oi">// mobile/lib/new_activity.dart:22<br/>Future _postMessage(BuildContext context) async {<br/>  if (_messageController.text.length &gt; 0) {<br/>    await ApiService().postMessage(widget.account, _messageController.text);<br/>    Navigator.pop(context, true);<br/>  } else {<br/>    Scaffold.of(context).showSnackBar(<br/>      SnackBar(<br/>        content: Text('Please type a message'),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="7f2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只需获取键入的文本，将其传递给我们的<code class="fe nj nk nl nm b">ApiService</code>，并弹出导航堆栈以返回到上一个屏幕。下面是<code class="fe nj nk nl nm b">ApiService#postMessage</code>的实现:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="0b8a" class="no lz it nm b gy of og l oh oi">Future&lt;bool&gt; postMessage(Map account, String message) async {<br/>  return await platform.invokeMethod&lt;bool&gt;(<br/>      'postMessage', {'user': account['user'], 'token': account['feedToken'], 'message': message});<br/>}</span></pre><p id="ccc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们将利用Streams的<a class="ae lq" href="https://github.com/getstream/stream-java" rel="noopener ugc nofollow" target="_blank"> Java </a>库(以及iOS上的<a class="ae lq" href="https://github.com/getstream/stream-java" rel="noopener ugc nofollow" target="_blank"> Swift </a>，我们通过Flutter的内置<a class="ae lq" href="https://flutter.dev/docs/development/platform-integration/platform-channels" rel="noopener ugc nofollow" target="_blank">平台通道</a>调用本地实现。我们不会详细讨论这个调用是如何发生的，所以要么参考源代码，要么阅读Flutter的文档来了解如何做到这一点。下面是Kotlin实现(iOS实现可以在源代码中找到):</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="cd7c" class="no lz it nm b gy of og l oh oi">// mobile/android/app/src/main/kotlin/io/getstream/flutter_the_stream/MainActivity.kt:59<br/>private fun postMessage(user: String, token: String, message: String) {<br/>  val client = CloudClient.builder(API_KEY, token, user).build()</span><span id="4e86" class="no lz it nm b gy oj og l oh oi">  val feed = client.flatFeed("user")<br/>  feed.addActivity(<br/>    Activity<br/>      .builder()<br/>      .actor("SU:${user}")<br/>      .verb("post")<br/>      .`object`(UUID.randomUUID().toString())<br/>      .extraField("message", message)<br/>      .build()<br/>  ).join()<br/>}</span></pre><p id="ba37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们使用<a class="ae lq" href="https://getstream.github.io/stream-java/io/getstream/cloud/package-summary.html" rel="noopener ugc nofollow" target="_blank">云包</a>中<a class="ae lq" href="https://github.com/GetStream/stream-java" rel="noopener ugc nofollow" target="_blank"> Stream Java的</a> <code class="fe nj nk nl nm b">CloudClient</code>。这组类采用我们的前端令牌，它允许移动应用程序直接与Stream通信。我们只被授权为演员<code class="fe nj nk nl nm b">SU:john</code>发布活动。因为我们没有在数据库中存储相应的对象，所以我们生成一个id来保持每篇文章的唯一性。我们还传递消息负载，这是我们的追随者将看到的。</p><p id="d2eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能想知道<code class="fe nj nk nl nm b">client.flatFeed("user")</code>指的是什么。为了实现这一点，我们需要在流中设置一个名为“user”的平面提要。这是每个用户的feed(只包含他们的消息)将被存储的地方。</p><p id="7aee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的流开发应用程序中，创建一个名为“user”的平面提要:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/e26d44269c7edbafa1f2fd0cdcdc1af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxwAJi5jqtA1sqfIoEqLCQ.png"/></div></div></figure><p id="037b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是Stream存储消息所需的全部内容。一旦所有这些功能返回，我们弹出导航器返回到用户的个人资料屏幕，这将显示我们发布的消息。我们接下来将构建这个。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4b18" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">步骤3:在我们的个人资料中显示消息</h1><p id="919b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">首先，让我们构建一个包含用户消息的Flutter小部件。这是屏幕的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/0a04f6e9f3bb7c7e2ddd048c7a665043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OavH3tObZDkxjvngmvRqYg.png"/></div></div></figure><p id="bb1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码如下:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="ae6f" class="no lz it nm b gy of og l oh oi">// mobile/lib/profile.dart:34<br/>@override<br/>Widget build(BuildContext context) {<br/>  return FutureBuilder&lt;List&lt;dynamic&gt;&gt;(<br/>    future: _activities,<br/>    builder: (BuildContext context, AsyncSnapshot&lt;List&lt;dynamic&gt;&gt; snapshot) {<br/>      if (!snapshot.hasData) {<br/>        return Center(child: CircularProgressIndicator());<br/>      }</span><span id="1d33" class="no lz it nm b gy oj og l oh oi">      return Container(<br/>        child: Center(<br/>          child: RefreshIndicator(<br/>            onRefresh: _refreshActivities,<br/>            child: ListView(<br/>              children: snapshot.data<br/>                  .map((activity) =&gt; ListTile(<br/>                        title: Text(activity['message']),<br/>                      ))<br/>                  .toList(),<br/>            ),<br/>          ),<br/>        ),<br/>      );<br/>    },<br/>  );<br/>}</span></pre><p id="0a25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用一个<code class="fe nj nk nl nm b">FutureBuilder</code>来异步加载我们的活动。我们不会在这里进入这种模式，所以请参考<a class="ae lq" href="https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html" rel="noopener ugc nofollow" target="_blank">文档</a>或<a class="ae lq" href="https://www.youtube.com/watch?v=rfagvy5xCW0&amp;list=PLOU2XLYxmsIK0r_D-zWcmJ1plIcDNnRkK&amp;index=4" rel="noopener ugc nofollow" target="_blank">无聊的颤振开发展示</a>来理解这是如何工作的。我们还使用一个简单的<code class="fe nj nk nl nm b"><a class="ae lq" href="https://api.flutter.dev/flutter/material/RefreshIndicator-class.html" rel="noopener ugc nofollow" target="_blank">RefreshIndicator</a></code>来实现拉取刷新。将这两个内置的小部件放在一起，我们可以显示用户的消息，并在用户发布新消息时刷新它们。</p><p id="7748" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">特定于流的代码发生在我们的<code class="fe nj nk nl nm b">_activities</code>变量中。为了获得用户的活动(包含我们的消息)，我们再次调用我们的<code class="fe nj nk nl nm b">ApiService</code>:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="d746" class="no lz it nm b gy of og l oh oi">// mobile/lib/profile.dart:23<br/>Future&lt;List&lt;dynamic&gt;&gt; _getActivities() async {<br/>  return await ApiService().getActivities(widget.account);<br/>}</span></pre><p id="62b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe nj nk nl nm b">ApiService#getActivities</code>调用本地代码来执行工作:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="0438" class="no lz it nm b gy of og l oh oi">// mobile/lib/api_service.dart:30<br/>Future&lt;dynamic&gt; getActivities(Map account) async {<br/>  var result =<br/>      await platform.invokeMethod&lt;String&gt;('getActivities', {'user': account['user'], 'token': account['feedToken']});<br/>  return json.decode(result);<br/>}</span></pre><p id="7d5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Kotlin中，我们使用<code class="fe nj nk nl nm b">CloudClient</code>请求用户的固定提要并获得最近的25条消息(活动):</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="4c5e" class="no lz it nm b gy of og l oh oi">// mobile/android/app/src/main/kotlin/io/getstream/flutter_the_stream/MainActivity.kt:74<br/>private fun getActivities(user: String, token: String): List&lt;Activity&gt; {<br/>  val client = CloudClient.builder(API_KEY, token, user).build()</span><span id="761f" class="no lz it nm b gy oj og l oh oi">  return client.flatFeed("user").getActivities(Limit(25)).join()<br/>}</span></pre><p id="1fa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将了解如何通过时间线提要关注多个用户。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="94a7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">用户时间线</h1><p id="bbc8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">既然用户可以发布消息，我们希望关注一些消息，并查看我们关注的用户的所有消息的组合提要。</p><h2 id="553b" class="no lz it bd ma np nq dn me nr ns dp mi ld nt nu mk lh nv nw mm ll nx ny mo nz bi translated">步骤1:关注用户</h2><p id="df52" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们需要做的第一件事是查看用户列表，并选择一些用户进行关注。我们将首先创建一个显示所有用户的视图，并让一个用户关注几个用户。这是显示所有用户的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a7bd9b3bf504c08400ca0c27af7adf80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkby3IUOKPXzjerecfS23w.png"/></div></div></figure><p id="f9c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是支持它的代码:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="851e" class="no lz it nm b gy of og l oh oi">// mobile/lib/people.dart:23<br/>@override<br/>Widget build(BuildContext context) {<br/>  return FutureBuilder&lt;List&gt;(<br/>    future: _users,<br/>    builder: (BuildContext context, AsyncSnapshot&lt;List&gt; snapshot) {<br/>      if (!snapshot.hasData) {<br/>        return Center(child: CircularProgressIndicator());<br/>      }</span><span id="0067" class="no lz it nm b gy oj og l oh oi">      return ListView(<br/>        children: snapshot.data<br/>            .where((u) =&gt; u != widget.account['user'])<br/>            .map((u) =&gt; ListTile(<br/>                  title: Text(u),<br/>                  onTap: () {<br/>                    showDialog&lt;String&gt;(<br/>                      context: context,<br/>                      builder: (BuildContext context) =&gt; AlertDialog(content: Text("Click to follow"), actions: [<br/>                        FlatButton(<br/>                          child: const Text('Follow'),<br/>                          onPressed: () async {<br/>                            await ApiService().follow(widget.account, u);<br/>                            Navigator.pop(context, "Followed");<br/>                          },<br/>                        )<br/>                      ]),<br/>                    ).then&lt;void&gt;((String message) {<br/>                      // The value passed to Navigator.pop() or null.<br/>                      if (message != null) {<br/>                        Scaffold.of(context)<br/>                          ..removeCurrentSnackBar()<br/>                          ..showSnackBar(SnackBar(<br/>                            content: Text(message),<br/>                          ));<br/>                      }<br/>                    });<br/>                  },<br/>                ))<br/>            .toList(),<br/>      );<br/>    },<br/>  );<br/>}</span></pre><p id="437b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个小部件通过使用由<code class="fe nj nk nl nm b">users</code>支持的<code class="fe nj nk nl nm b">FutureBuilder</code>遵循与概要文件相同的模式。通过调用我们的<code class="fe nj nk nl nm b">backend</code>服务，可以简单地支持<code class="fe nj nk nl nm b">users</code>变量。由于后端不是一个真正的实现，我们将在这里跳过<code class="fe nj nk nl nm b">backend</code>如何存储和检索用户的细节。请参考出处。在Flutter中，我们简单地通过HTTP调用来检索列表，如<code class="fe nj nk nl nm b">ApiService#users</code>所示:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="503a" class="no lz it nm b gy of og l oh oi">// mobile/lib/api_service.dart:20<br/>Future&lt;List&gt; users(Map account) async {<br/>  var response = await http.get('$_baseUrl/v1/users', headers: {'Authorization': 'Bearer ${account['authToken']}'});<br/>  return json.decode(response.body)['users'];<br/>}</span></pre><p id="d61a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的部分是当我们点击一个用户。我们通过<code class="fe nj nk nl nm b">showDialog</code>显示一个颤动对话框，其中包含一个允许我们跟随的按钮。当我们按下按钮时，我们触发<code class="fe nj nk nl nm b">ApiService#follow</code>。我们可以再次看到，我们如何利用本地库来跟踪用户。这是令人不安的一面:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="9499" class="no lz it nm b gy of og l oh oi">// mobile/lib/api_service.dart:42<br/>Future&lt;bool&gt; follow(Map account, String userToFollow) async {<br/>  return await platform.invokeMethod&lt;bool&gt;(<br/>      'follow', {'user': account['user'], 'token': account['feedToken'], 'userToFollow': userToFollow});<br/>}</span></pre><p id="b6da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是原生的科特林面，使用了<code class="fe nj nk nl nm b">CloudClient</code>:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="53ac" class="no lz it nm b gy of og l oh oi">// mobile/android/app/src/main/kotlin/io/getstream/flutter_the_stream/MainActivity.kt:86<br/>private fun follow(user: String, token: String, userToFollow: String): Boolean {<br/>  val client = CloudClient.builder(API_KEY, token, user).build()</span><span id="864f" class="no lz it nm b gy oj og l oh oi">  client.flatFeed("timeline").follow(client.flatFeed("user", userToFollow)).join()<br/>  return true<br/>}</span></pre><p id="6759" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们将一个<a class="ae lq" href="https://getstream.io/docs/#following" rel="noopener ugc nofollow" target="_blank">关注关系</a>添加到另一个用户的<code class="fe nj nk nl nm b">user</code> feed和这个用户的<code class="fe nj nk nl nm b">timeline</code> feed。这意味着无论何时用户向他们的<code class="fe nj nk nl nm b">user</code> feed(在第一部分实现)发帖，我们都会在我们的<code class="fe nj nk nl nm b">timeline</code> feed上看到。最酷的是，我们可以向我们的<code class="fe nj nk nl nm b">timeline</code> feed添加任意数量的用户feed，Stream将返回一个有序的活动列表。</p><p id="00b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们有了一个新的提要类型，所以我们需要在流中设置它。就像<code class="fe nj nk nl nm b">user</code>提要一样，导航到您设置的流应用程序，并创建一个名为timeline的平面提要组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/937154540d77da9bc34ed2e52810991c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q79LlCo9ZpBtVlDus7q8pA.png"/></div></div></figure><h1 id="6a98" class="ly lz it bd ma mb om md me mf on mh mi jz oo ka mk kc op kd mm kf oq kg mo mp bi translated">步骤2:查看时间线</h1><p id="5c19" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">既然我们有了跟踪用户的方法，我们就可以查看我们的时间表了。完成后，假设我们已经跟踪了“Bob”和“Sara ”,我们将看到如下所示的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b68c99b44fa352003dda3c3d13718153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hiHw-MR8Jd_ReuoGrlbW1w.png"/></div></div></figure><p id="b65a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看显示我们的时间线的代码:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="42d0" class="no lz it nm b gy of og l oh oi">// mobile/lib/timeline.dart:34<br/>@override<br/>Widget build(BuildContext context) {<br/>  return FutureBuilder&lt;List&lt;dynamic&gt;&gt;(<br/>    future: _activities,<br/>    builder: (BuildContext context, AsyncSnapshot&lt;List&lt;dynamic&gt;&gt; snapshot) {<br/>      if (!snapshot.hasData) {<br/>        return Center(child: CircularProgressIndicator());<br/>      }</span><span id="eb89" class="no lz it nm b gy oj og l oh oi">      return Container(<br/>        child: Center(<br/>          child: RefreshIndicator(<br/>            onRefresh: _refreshActivities,<br/>            child: ListView(<br/>              children: snapshot.data<br/>                  .map((activity) =&gt; ListTile(<br/>                        title: Text(activity['message']),<br/>                        subtitle: Text(activity['actor']),<br/>                      ))<br/>                  .toList(),<br/>            ),<br/>          ),<br/>        ),<br/>      );<br/>    },<br/>  );<br/>}</span></pre><p id="6833" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这看起来和我们的<code class="fe nj nk nl nm b">Profile</code>小部件一样，使用了<code class="fe nj nk nl nm b">FutureBuilder</code>和<code class="fe nj nk nl nm b">RefreshIndicator</code>并由未来的<code class="fe nj nk nl nm b">_activities</code>支持。由于<code class="fe nj nk nl nm b">timeline</code>只是一个像<code class="fe nj nk nl nm b">user</code>一样的提要，代码与我们获取用户消息的方式相同。首先我们调用<code class="fe nj nk nl nm b">ApiService#getTimeline</code>，这只是对我们本地代码的调用:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="ce84" class="no lz it nm b gy of og l oh oi">// mobile/lib/api_service.dart:36<br/>Future&lt;dynamic&gt; getTimeline(Map account) async {<br/>  var result =<br/>      await platform.invokeMethod&lt;String&gt;('getTimeline', {'user': account['user'], 'token': account['feedToken']});<br/>  return json.decode(result);<br/>}</span></pre><p id="ba6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是相应的本机代码:</p><pre class="kj kk kl km gt ob nm oc od aw oe bi"><span id="3fc8" class="no lz it nm b gy of og l oh oi">// mobile/android/app/src/main/kotlin/io/getstream/flutter_the_stream/MainActivity.kt:80<br/>private fun getTimeline(user: String, token: String): List&lt;Activity&gt; {<br/>  val client = CloudClient.builder(API_KEY, token, user).build()</span><span id="2303" class="no lz it nm b gy oj og l oh oi">  return client.flatFeed("timeline").getActivities(Limit(25)).join()<br/>}</span></pre><p id="ef65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！我们现在有了一个全功能的迷你社交网络。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8ed4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">最后的想法</h1><p id="8a21" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Flutter和Stream使得利用活动提要构建跨平台移动应用程序变得非常简单。两者都有大量现成的功能。如果你正在寻找一个替代反应原生，颤振是一个伟大的选择。使用平台通道调用本机代码很简单，这允许我们使用Stream提供给我们的所有优秀库。</p></div></div>    
</body>
</html>