<html>
<head>
<title>Touch Interactions in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack Compose中的触摸交互</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/touch-interactions-in-jetpack-compose-caf88adcae61?source=collection_archive---------4-----------------------#2022-07-12">https://betterprogramming.pub/touch-interactions-in-jetpack-compose-caf88adcae61?source=collection_archive---------4-----------------------#2022-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3693" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建一个可拖动的标签范围滑块</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a701e97329e29edac8d295823e731d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*er_eCInOk-whBK8o"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安德烈·利亚科夫在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="93c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在系列的第一部分<a class="ae kv" href="https://medium.com/@alex.frank84/custom-composable-with-jetpack-compose-912d8c53b810" rel="noopener">中我们学习了如何在画布上绘制不同的形状之后，让我们看看在第二部分中如何处理触摸交互。</a></p><p id="2064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提醒一下，有了这个主题，我们将能够使我们的标签范围滑块可拖动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/088e9a3f48ce3de5fb917161de8a415d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*E7YGO2-tBefdm9C1FGYWug.gif"/></div></figure><p id="f548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我们将创建一个可组合的Scribble，来探索我们如何处理触摸交互。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/15b0366184dfd2f459a1f9381329987c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*j3ATksAGP9Prymf9EZ39hw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可组合的涂鸦</p></figure><h1 id="d574" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">触摸交互</h1><p id="889b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于常规的交互式可组合组件，我们通常使用修饰符clickable:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="69ca" class="mv lu iq mr b gy mw mx l my mz"><em class="na">Canvas</em>(<br/>   modifier = Modifier.<em class="na">clickable </em><strong class="mr ir">{<br/>      </strong>Log.i("Tag", "Canvas clicked")<br/>   }<br/>) {<br/>   // draw something<br/>}</span></pre><p id="2ce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还是实验性的<code class="fe nb nc nd mr b">combinedClickable</code>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c115" class="mv lu iq mr b gy mw mx l my mz"><em class="na">Canvas</em>(<br/>   modifier = Modifier.<em class="na">combinedClickable</em>(<br/>      onClick = { Log.i("Tag", "Canvas clicked") },<br/>      onLongClick = { Log.i("Tag", "Canvas long clicked") },<br/>      onDoubleClick = { Log.i("Tag", "Canvas double clicked") }<br/>   )<br/>) {<br/>   // draw something<br/>}</span></pre><p id="3764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们只想处理整个可组合组件上的一次单击，这两种方法都很有效。</p><p id="4111" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是对于我们的例子，我们希望有更多的控制。我们需要知道点击发生的确切位置，以及用户是否在屏幕上拖动手指。幸运的是，Compose为我们提供了修饰语<code class="fe nb nc nd mr b">pointerInput</code> <strong class="ky ir">，</strong>，这提供了我们需要的信息。</p><h1 id="6721" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">手势检测器</h1><p id="0b8d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用<code class="fe nb nc nd mr b"><strong class="ky ir">pointerInput</strong></code>最简单的方法是实现一个已经提供的手势检测器。</p><ul class=""><li id="86e7" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe nb nc nd mr b">detectTapGestures</code>:这与<code class="fe nb nc nd mr b">combinedClickable</code>修改器非常相似，处理轻击、双击、按压和长按。这个修饰符为我们提供了用户在我们的可组合对象中粘贴的确切位置。</li><li id="ad71" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe nb nc nd mr b">detectDragGestures</code>:使用这个检测器，我们可以检测手指在我们的组件中拖动的起点、终点和路径。</li><li id="2e34" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe nb nc nd mr b">detectHorizontalDragGestures</code>:顾名思义，这类似于<code class="fe nb nc nd mr b">detectDragGestures</code>，但是只为我们提供了水平拖动运动的更新。</li><li id="78d8" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe nb nc nd mr b">detectVerticalDragGestures</code>:类似<code class="fe nb nc nd mr b">detectHorizontalDragGestures</code>，但只提供垂直拖动动作。</li><li id="4e49" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe nb nc nd mr b">detectDragGesturesAfterLongPress</code>:使用这个检测器，我们获得了与<code class="fe nb nc nd mr b">detectDragGestures</code>相同的信息，但只是在用户执行了长按之后。</li><li id="4b76" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><code class="fe nb nc nd mr b">detectTransformGestures</code>:变换手势检测器为我们提供旋转、平移和缩放手势的更新位置信息。</li></ul><p id="1406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这些预定义的检测器仍然不够，并且您想要完全控制如何处理触摸，您可以使用<code class="fe nb nc nd mr b">awaitPointerEventScope</code>。</p><p id="50df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的可组合的Scribble示例，我们将重点关注使用<code class="fe nb nc nd mr b">detectDragGestures</code> <strong class="ky ir">。</strong>因为这个检测器让我们知道用户从哪里开始触摸，并且在手指拖过我们的可组合组件时不断更新。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2088" class="mv lu iq mr b gy mw mx l my mz"><em class="na">Canvas</em>(<br/>   modifier = modifier<br/>      .<em class="na">pointerInput</em>(key1 = <em class="na">Unit</em>) {<br/>         detectDragGestures(<br/>            onDragStart = { touch -&gt;<br/>               Log.i("Tag", "Start of the interaction is $touch")<br/>            },<br/>            onDrag = { change, dragAmount -&gt;<br/>               Log.i("Tag", "Dragged $dragAmount; Result $change")<br/>            }<br/>         )<br/>      }<br/>) {<br/>   // draw something<br/>}</span></pre><p id="33c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们在<code class="fe nb nc nd mr b">pointerInput</code>中注册了一个拖拽手势检测器。对于参数<code class="fe nb nc nd mr b">key1</code>，我们简单地提供<code class="fe nb nc nd mr b">Unit</code>。因为我们不希望当<code class="fe nb nc nd mr b">key1</code>改变时我们的检测被取消。在<code class="fe nb nc nd mr b">pointerInput</code>中，我们调用<code class="fe nb nc nd mr b">detectDragGestures</code>。这为我们提供了用户在回调<code class="fe nb nc nd mr b">onDragStart</code>中开始交互的信息，以及手指在<code class="fe nb nc nd mr b">onDrag</code>中采取的路径的连续更新。</p><p id="8620" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd mr b">onDrag</code>回调有两个参数，第二个给我们最后一次拖动的增量。这不是手指现在所在位置的绝对位置，而只是到最后一次位置更新的变化。另一方面，第一个参数为我们提供了更多的细节，比如历史数据和手指在组件上的绝对位置。</p><p id="dcd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我们将使用第一个参数<code class="fe nb nc nd mr b">change</code>来获得创建线条画的绝对位置。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="eb7f" class="mv lu iq mr b gy mw mx l my mz">var points by <em class="na">remember </em>{ <em class="na">mutableStateOf</em>&lt;List&lt;Offset&gt;&gt;(<em class="na">emptyList</em>()) }<br/><br/>...<br/>         detectDragGestures(<br/>            onDragStart = { touch -&gt;<br/>               points = <em class="na">listOf</em>(touch)<br/>            },<br/>            onDrag = { change, _ -&gt;<br/>               val newPoint = change.position<br/>               points = points + newPoint<br/>            }<br/>         )<br/>...</span></pre><p id="bba4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建一个可变状态<code class="fe nb nc nd mr b">points</code>,它可以保存一个偏移量列表，该列表将保存手指在画布上拖动的路径。当拖动手势开始时，我们创建一个新的列表，并向其中添加触摸点。之后，我们只需查看<code class="fe nb nc nd mr b">change.position</code>，它给出了画布上触摸的绝对位置，我们可以将它添加到我们的路径中。</p><p id="1fd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法是可行的，当我们现在绘制路径时，我们可以得到一个不错的结果。但是如果我们想要有一个更平滑的结果，我们也应该考虑历史数据。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7476" class="mv lu iq mr b gy mw mx l my mz">...<br/>onDrag = <strong class="mr ir">{ </strong>change, _ <strong class="mr ir">-&gt;<br/>   </strong>val pointsFromHistory = change.historical<br/>      .<em class="na">map </em><strong class="mr ir">{ it</strong>.position <strong class="mr ir">}<br/>      </strong>.<em class="na">toTypedArray</em>()<br/>   val newPoints = <em class="na">listOf</em>(*pointsFromHistory, change.position)<br/>   points = points + newPoints<br/><strong class="mr ir">}<br/>...</strong></span></pre><p id="ab29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们迭代历史数据，它代表两个<code class="fe nb nc nd mr b"><strong class="ky ir">onDrag</strong></code><strong class="ky ir"/><strong class="ky ir"/>之间的点更新，并得到其位置。这样，我们只需将历史位置和当前位置添加到路径列表中。</p><p id="4b17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在剩下要做的就是在画布上绘制路径，使用我们在本系列第一部分看到的<code class="fe nb nc nd mr b"><strong class="ky ir">drawPath</strong></code> <strong class="ky ir"> </strong>方法。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4428" class="mv lu iq mr b gy mw mx l my mz">...<br/>if (points.size &gt; 1) {<br/>   val path = <em class="na">Path</em>().<em class="na">apply </em>{<br/>      val firstPoint = points.<em class="na">first</em>()<br/>      val rest = points.subList(1, points.size - 1)<br/><br/>      moveTo(firstPoint.x, firstPoint.y)<br/>      rest.<em class="na">forEach </em>{<br/>         lineTo(it.x, it.y)<br/>      }<br/>   }<br/><br/>   drawPath(path, color, style = Stroke(width = lineWidth.<em class="na">toPx</em>()))<br/>}<br/>...</span></pre><p id="d16e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当列表中有多个点时，我们创建一个新的<code class="fe nb nc nd mr b">Path</code>对象，将路径的起点移动到第一个点，然后将列表中的所有线添加到路径中。因为我们希望只绘制线条而不填充区域，所以我们用样式<code class="fe nb nc nd mr b">Stroke</code>绘制路径。</p><p id="18fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个实现中，要绘制的线条的紧密度被参数化为类型<code class="fe nb nc nd mr b">Dp</code>的<code class="fe nb nc nd mr b">lineWidth</code>，但是Stoke想要像素作为它的宽度参数。幸运的是，我们画布的<code class="fe nb nc nd mr b">DrawScope</code>为我们提供了扩展函数<code class="fe nb nc nd mr b">toPx</code>，用它我们可以将Dp转换成像素。</p><h1 id="2b25" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="1266" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们现在能够在自定义的可组合组件上处理触摸交互，并将其转化为动作。这样，我们就可以画出我们的标签范围滑块，并与之交互。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/75ff3f5a0c9d09a4f5ea93654b893725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8k4wC9_r4kNedaR8bTo6g.png"/></div></div></figure><p id="35c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在我们开始实现它之前，我们先来看看第3部分中新的Kotlin上下文接收器。敬请关注。</p><p id="552d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Scribble Composable的完整代码可以在<a class="ae kv" href="https://github.com/a-frank/touch-interaction-composable" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>