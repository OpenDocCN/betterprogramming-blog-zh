<html>
<head>
<title>Build a Real-time Chat Application With Nestjs and PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Nestjs和PostgreSQL构建实时聊天应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-real-time-chat-application-with-nestjs-and-postgresql-a212502eb436?source=collection_archive---------6-----------------------#2022-05-13">https://betterprogramming.pub/build-a-real-time-chat-application-with-nestjs-and-postgresql-a212502eb436?source=collection_archive---------6-----------------------#2022-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cff8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，您将学习使用web sockets为您的Nestjs web应用程序添加实时聊天功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bba5b3c6694b921df3a8eaa06e177f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BEPlBnr61ZzZVtV5.png"/></div></div></figure><p id="f4cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程的代码可以在我的<a class="ae lq" href="https://github.com/icode247/Chat-with-Nestjs" rel="noopener ugc nofollow" target="_blank"> Github库</a>上找到。当您按照步骤操作时，可以随意克隆它。我们开始吧！</p><h1 id="23ea" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是NestJS？</h1><p id="cd13" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">NestJS是一个Node.js框架，用于创建快速、可测试、可伸缩、松散耦合的使用TypeScript的服务器端应用程序。它利用了Express或Fastify等强大的HTTP服务器框架。</p><p id="8be0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Nest为Node.js框架增加了一个抽象层，并向开发人员公开了它们的API。它支持像PostgreSQL和MySQL这样的数据库管理系统。NestJS还提供依赖注入Websockets和APIGetaways。</p><h1 id="7eca" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是Websocket？</h1><p id="3446" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">WebSocket是一种计算机通信协议，它通过单个TCP连接提供全双工通信通道。IETF在2011年将WebSocket协议标准化为RFC 6455。</p><p id="a836" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当前的规范被称为HTML生活标准。与HTTP/HTTPS不同，Websocket是有状态协议，这意味着服务器和客户端之间建立的连接将是活动的，除非被服务器或客户端终止；一旦WebSocket连接被一端关闭，它就会扩展到另一端。</p><h2 id="0c61" class="mo ls it bd lt mp mq dn lx mr ms dp mb ld mt mu md lh mv mw mf ll mx my mh mz bi translated">先决条件</h2><p id="87d2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">本教程是一个实践演示。要继续操作，请确保您已经安装了以下软件:</p><ul class=""><li id="4088" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated"><a class="ae lq" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank">弧型</a></li><li id="161e" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><a class="ae lq" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a></li><li id="edac" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><a class="ae lq" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a></li></ul><h1 id="af27" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">项目设置</h1><p id="a697" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在开始编码之前，让我们建立我们的NestJS项目和项目结构。我们将从创建项目文件夹开始。然后，打开您的终端并运行以下命令:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fc84" class="mo ls it np b gy nt nu l nv nw">mkdir chatapp &amp;&amp; cd chatapp</span></pre><h1 id="eaa6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建项目文件夹</h1><p id="40a4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">然后使用下面的命令安装NestJS CLI:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="508b" class="mo ls it np b gy nt nu l nv nw">npm i -g @nestjs/cli</span></pre><p id="d8d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装完成后，运行下面的命令来搭建一个NestJS项目。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4e0b" class="mo ls it np b gy nt nu l nv nw">nest new chat</span></pre><p id="b0df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择您首选的npm软件包管理器。对于本教程，我们将使用<code class="fe nx ny nz np b">npm</code>并等待安装必要的包。安装完成后，用下面的命令安装<code class="fe nx ny nz np b">WebSocket</code>和<code class="fe nx ny nz np b">Socket.io</code>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="8bc1" class="mo ls it np b gy nt nu l nv nw">npm i --save @nestjs/websockets @nestjs/platform-socket.io</span></pre><p id="30c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，使用下面的命令创建一个网关应用程序:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2d32" class="mo ls it np b gy nt nu l nv nw">nest g gateway app</span></pre><p id="db65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们通过运行以下命令来启动我们的服务器:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="961f" class="mo ls it np b gy nt nu l nv nw">npm run start:dev</span></pre><h1 id="3239" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">建立Postgres数据库</h1><p id="69c4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们现在可以设置我们的Postgres数据库，用我们的服务器设置来存储我们的用户记录。</p><p id="3328" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们将使用<a class="ae lq" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>(对象关系映射器)来连接我们的数据库和应用程序。首先，我们需要通过以下步骤创建一个数据库。首先，切换到系统的Postgres用户帐户。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fb8b" class="mo ls it np b gy nt nu l nv nw">sudo su - postgres</span></pre><p id="26cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，使用下面的命令创建一个新的用户帐户。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="78e4" class="mo ls it np b gy nt nu l nv nw">createuser --interactive</span></pre><p id="0fb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，创建一个新的数据库。您可以使用以下命令来实现这一点:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0ced" class="mo ls it np b gy nt nu l nv nw">createdb chat</span></pre><p id="6f5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们将连接到刚刚创建的数据库。首先，打开app.module.ts文件，在<code class="fe nx ny nz np b">imports[]</code>的数组中添加下面的代码片段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="73c2" class="mo ls it np b gy nt nu l nv nw">...<br/>import { TypeOrmModule } from '@nestjs/typeorm';<br/>import { Chat } from './chat.entity';<br/>imports: [<br/>   TypeOrmModule.forRoot({<br/>     type: 'postgres',<br/>     host: 'localhost',<br/>     username: '&lt;USERNAME&gt;',<br/>     password: '&lt;PASSWORD&gt;',<br/>     database: 'chat',<br/>     entities: [Chat],<br/>     synchronize: true,<br/>   }),<br/>   TypeOrmModule.forFeature([Chat]),<br/> ],<br/>...</span></pre><p id="ebfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们使用<code class="fe nx ny nz np b">TypeOrmModule</code> <code class="fe nx ny nz np b">forRoot</code>方法将我们的应用程序连接到PostgresSQL数据库，并传入我们的数据库凭证。用您为<code class="fe nx ny nz np b">chat</code>数据库创建的用户名和密码替换<code class="fe nx ny nz np b">&lt;USERNAME&gt;</code>和<code class="fe nx ny nz np b">&lt;PASSWORD&gt;</code>。</p><h1 id="ebe7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建我们的聊天实体</h1><p id="ebe2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在我们已经将应用程序连接到您的数据库，创建一个聊天实体来保存用户的消息。为此，在src文件夹中创建一个<code class="fe nx ny nz np b">chat.entity.ts</code>文件，并添加下面的代码片段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="91aa" class="mo ls it np b gy nt nu l nv nw">import {<br/> Entity,<br/> Column,<br/> PrimaryGeneratedColumn,<br/> CreateDateColumn,<br/>} from 'typeorm';<br/> <br/>@Entity()<br/>export class Chat {<br/> @PrimaryGeneratedColumn('uuid')<br/> id: number;<br/> <br/> @Column()<br/> email: string;<br/> <br/> @Column({ unique: true })<br/> text: string;<br/> <br/> @CreateDateColumn()<br/> createdAt: Date;<br/>}</span></pre><p id="261a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们使用TypeOrm提供的<code class="fe nx ny nz np b"><strong class="kw iu">Entity</strong></code>、<code class="fe nx ny nz np b"><strong class="kw iu">Column</strong></code>、<code class="fe nx ny nz np b"><strong class="kw iu">CreatedDateColumn</strong></code>和<code class="fe nx ny nz np b"><strong class="kw iu">PrimaryGenerateColumn</strong></code> <strong class="kw iu"> </strong>装饰器为我们的聊天创建了列。</p><h1 id="3b9e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">设置web套接字</h1><p id="cb81" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们在服务器中设置一个Web套接字连接来发送实时消息。首先，我们将使用下面的代码片段导入所需的模块。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="57f6" class="mo ls it np b gy nt nu l nv nw">import {<br/> SubscribeMessage,<br/> WebSocketGateway,<br/> OnGatewayInit,<br/> WebSocketServer,<br/> OnGatewayConnection,<br/> OnGatewayDisconnect,<br/>} from '@nestjs/websockets';<br/>import { Socket, Server } from 'socket.io';<br/>import { AppService } from './app.service';<br/>import { Chat } from './chat.entity';</span></pre><p id="3085" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们导入了<code class="fe nx ny nz np b">SubscribeMessage()</code>来监听来自客户端的事件，<code class="fe nx ny nz np b">WebSocketGateway()</code>，这将提供对socket.io的访问；我们还导入了<code class="fe nx ny nz np b">OnGatewayInit</code>、<code class="fe nx ny nz np b">OnGatewayConnection</code>和<code class="fe nx ny nz np b">OnGatewayDisconnect</code>实例。</p><p id="04aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个WebSocket实例使您能够了解应用程序的状态。例如，当一个服务器加入或断开聊天时，我们可以让我们的服务器做一些事情。然后我们导入了<code class="fe nx ny nz np b">Chat</code>实体和<code class="fe nx ny nz np b">AppService</code>，它们公开了保存用户消息所需的方法。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="ab83" class="mo ls it np b gy nt nu l nv nw">@WebSocketGateway({<br/> cors: {<br/>   origin: '*',<br/> },<br/>})</span></pre><p id="ea02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使我们的客户端能够与服务器通信，我们通过初始化<code class="fe nx ny nz np b">WebSocketGateway</code>来启用CORS。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b271" class="mo ls it np b gy nt nu l nv nw">export class AppGateway<br/> implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect<br/>{<br/> constructor(private appService: AppService) {}<br/> <br/> @WebSocketServer() server: Server;<br/> <br/> @SubscribeMessage('sendMessage')<br/> async handleSendMessage(client: Socket, payload: Chat): Promise&lt;void&gt; {<br/>   await this.appService.createMessage(payload);<br/>   this.server.emit('recMessage', payload);<br/> }<br/> <br/> afterInit(server: Server) {<br/>   console.log(server);<br/>   //Do stuffs<br/> }<br/> <br/> handleDisconnect(client: Socket) {<br/>   console.log(`Disconnected: ${client.id}`);<br/>   //Do stuffs<br/> }<br/> <br/> handleConnection(client: Socket, ...args: any[]) {<br/>   console.log(`Connected ${client.id}`);<br/>   //Do stuffs<br/> }<br/>}</span></pre><p id="e3e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在我们的<code class="fe nx ny nz np b"><strong class="kw iu">AppGateWay</strong></code> <strong class="kw iu"> </strong>类中，我们实现了上面导入的WebSocket实例。我们创建了一个构造器方法，并绑定我们的AppService来访问它的方法。我们从<code class="fe nx ny nz np b"><strong class="kw iu">WebSocketServer</strong></code>decorator创建了一个服务器实例。</p><p id="6f0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们使用<code class="fe nx ny nz np b">@SubscribeMessage()</code>实例和<code class="fe nx ny nz np b">handleMessage()</code>方法创建一个<code class="fe nx ny nz np b">handleSendMessage</code>,将数据发送到我们的客户端。</p><p id="3eae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个消息从客户端发送到这个函数时，我们将它保存在我们的数据库中，并将消息发送回客户端所有连接的用户。</p><p id="9c80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还有许多其他方法可以尝试，比如<code class="fe nx ny nz np b">afterInit</code>，它在客户端连接后被触发，<code class="fe nx ny nz np b">handleDisconnect</code>，它在用户断开连接时被触发。<code class="fe nx ny nz np b">handleConnection</code>方法在用户加入连接时开始。</p><h1 id="8a68" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建控制器/服务</h1><p id="ef29" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在让我们创建我们的服务和控制器来保存聊天并呈现我们的静态页面。打开<code class="fe nx ny nz np b">app.service.ts</code>文件，用下面的代码片段更新内容:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="cb28" class="mo ls it np b gy nt nu l nv nw">import { Injectable } from '@nestjs/common';<br/>import { InjectRepository } from '@nestjs/typeorm';<br/>import { Repository } from 'typeorm';<br/>import { Chat } from './chat.entity';<br/> <br/>@Injectable()<br/>export class AppService {<br/> constructor(<br/>   @InjectRepository(Chat) private chatRepository: Repository&lt;Chat&gt;,<br/> ) {}<br/> async createMessage(chat: Chat): Promise&lt;Chat&gt; {<br/>   return await this.chatRepository.save(chat);<br/> }<br/> <br/> async getMessages(): Promise&lt;Chat[]&gt; {<br/>   return await this.chatRepository.find();<br/> }<br/>}</span></pre><p id="dcbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后用下面的代码片段更新<code class="fe nx ny nz np b">app.controller.ts</code> <strong class="kw iu"> </strong>文件:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1ce1" class="mo ls it np b gy nt nu l nv nw">import { Controller, Render, Get, Res } from '@nestjs/common';<br/>import { AppService } from './app.service';<br/>import { Chat } from './chat.entity';<br/> <br/>@Controller()<br/>export class AppController {<br/> constructor(private readonly appService: AppService) {}<br/> <br/> @Get('/chat')<br/> @Render('index')<br/> Home() {<br/>   return;<br/> }<br/> <br/> @Get('/api/chat')<br/> async Chat(@Res() res) {<br/>   const messages = await this.appService.getMessages();<br/>   res.json(messages);<br/> }<br/>}</span></pre><p id="7fe3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们创建了两条路由来呈现静态页面和用户消息。</p><h1 id="1423" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">为我们的静态页面服务</h1><p id="0111" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在让我们配置应用程序来呈现静态文件和页面。为此，我们将实现服务器端渲染。首先，在您的<code class="fe nx ny nz np b">main.ts</code>文件中，使用下面的命令将应用程序配置为静态服务器文件:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="60e6" class="mo ls it np b gy nt nu l nv nw">async function bootstrap() {<br/> ...<br/> app.useStaticAssets(join(__dirname, '..', 'static'));<br/> app.setBaseViewsDir(join(__dirname, '..', 'views'));<br/> app.setViewEngine('ejs');<br/> ...<br/>}</span></pre><p id="4f0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在您的<code class="fe nx ny nz np b">src</code>目录中创建一个<code class="fe nx ny nz np b">static</code>和一个<code class="fe nx ny nz np b">views</code>文件夹。在views文件夹中，创建一个<code class="fe nx ny nz np b">index.ejs</code>文件，并添加以下代码片段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="cd96" class="mo ls it np b gy nt nu l nv nw">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/> <br/>&lt;head&gt;<br/> &lt;!-- Required meta tags --&gt;<br/> &lt;meta charset="utf-8" /&gt;<br/> &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;<br/> <br/> &lt;!-- Bootstrap CSS --&gt;<br/> &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"<br/>   integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous" /&gt;<br/> <br/> &lt;title&gt;Let Chat&lt;/title&gt;<br/>&lt;/head&gt;<br/> <br/>&lt;body&gt;<br/> &lt;nav class="navbar navbar-light bg-light"&gt;<br/>   &lt;div class="container-fluid"&gt;<br/>     &lt;a class="navbar-brand"&gt;Lets Chat&lt;/a&gt;<br/>   &lt;/div&gt;<br/> &lt;/nav&gt;<br/> &lt;div class="container"&gt;<br/>   &lt;div class="mb-3 mt-3"&gt;<br/>     &lt;ul style="list-style: none" id="data-container"&gt;&lt;/ul&gt;<br/>   &lt;/div&gt;<br/>   &lt;div class="mb-3 mt-4"&gt;<br/>     &lt;input class="form-control" id="email" rows="3" placeholder="Your Email" /&gt;<br/>   &lt;/div&gt;<br/>   &lt;div class="mb-3 mt-4"&gt;<br/>     &lt;input class="form-control" id="exampleFormControlTextarea1" rows="3" placeholder="Say something..." /&gt;<br/>   &lt;/div&gt;<br/> &lt;/div&gt;<br/> &lt;script src="https://cdn.socket.io/4.3.2/socket.io.min.js"<br/>   integrity="sha384-KAZ4DtjNhLChOB/hxXuKqhMLYvx3b5MlT55xPEiNmREKRzeEm+RVPlTnAn0ajQNs"<br/>   crossorigin="anonymous"&gt;&lt;/script&gt;<br/> &lt;script src="app.js"&gt;&lt;/script&gt;<br/> &lt;!-- Option 1: Bootstrap Bundle with Popper --&gt;<br/> &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"<br/>   integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"<br/>   crossorigin="anonymous"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="3d1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了加快模板的速度，我们使用Bootstrap添加了一些样式。然后我们添加了两个输入字段和一个无序列表来显示用户的消息。我们还包含了我们的<code class="fe nx ny nz np b">app.js</code>文件，我们将在本节稍后创建该文件，以及一个到<code class="fe nx ny nz np b">socket.io</code>客户端的链接。</p><p id="147c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在创建一个<code class="fe nx ny nz np b">app.js</code>文件，并添加下面的代码片段:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c158" class="mo ls it np b gy nt nu l nv nw">const socket = io('http://localhost:3002');<br/>const msgBox = document.getElementById('exampleFormControlTextarea1');<br/>const msgCont = document.getElementById('data-container');<br/>const email = document.getElementById('email');<br/> <br/>//get old messages from the server<br/>const messages = [];<br/>function getMessages() {<br/> fetch('http://localhost:3002/api/chat')<br/>   .then((response) =&gt; response.json())<br/>   .then((data) =&gt; {<br/>     loadDate(data);<br/>     data.forEach((el) =&gt; {<br/>       messages.push(el);<br/>     });<br/>   })<br/>   .catch((err) =&gt; console.error(err));<br/>}<br/>getMessages();<br/> <br/>//When a user press the enter key,send message.<br/>msgBox.addEventListener('keydown', (e) =&gt; {<br/> if (e.keyCode === 13) {<br/>   sendMessage({ email: email.value, text: e.target.value });<br/>   e.target.value = '';<br/> }<br/>});<br/> <br/>//Display messages to the users<br/>function loadDate(data) {<br/> let messages = '';<br/> data.map((message) =&gt; {<br/>   messages += ` &lt;li class="bg-primary p-2 rounded mb-2 text-light"&gt;<br/>      &lt;span class="fw-bolder"&gt;${message.email}&lt;/span&gt;<br/>      ${message.text}<br/>    &lt;/li&gt;`;<br/> });<br/> msgCont.innerHTML = messages;<br/>}<br/> <br/>//socket.io<br/>//emit sendMessage event to send message<br/>function sendMessage(message) {<br/> socket.emit('sendMessage', message);<br/>}<br/>//Listen to recMessage event to get the messages sent by users<br/>socket.on('recMessage', (message) =&gt; {<br/> messages.push(message);<br/> loadDate(messages);<br/>})</span></pre><p id="76f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们创建了一个socket.io实例，并监听服务器上的事件，以发送和接收来自服务器的消息。我们希望当用户默认加入聊天时，旧的聊天仍然可用。我们的应用程序应该看起来像下面的截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oa"><img src="../Images/50923e3d1287f9a3606a3d30d0549d93.png" data-original-src="https://miro.medium.com/v2/0*2_PpTMUnsQ2fEUDZ"/></div></figure><h1 id="c44b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用Arctype查看用户数据</h1><p id="b94a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们现在已经成功地创建了我们的聊天应用程序。首先，让我们看看Arctype的用户数据。首先，启动Arctype，单击MySQL选项卡，并输入以下MySQL凭据，如下面的屏幕截图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oa"><img src="../Images/bb8784702f58f220ba6fec1b1853c480.png" data-original-src="https://miro.medium.com/v2/0*vRLg5Eqx_tpoiaVu"/></div></figure><p id="a52a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，点击聊天<strong class="kw iu"> </strong>表格显示用户的聊天消息，如下图截图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oa"><img src="../Images/edbef605212dac6d917ff12aa3c3a5cc.png" data-original-src="https://miro.medium.com/v2/0*eCExt15hCIKttWch"/></div></figure><h1 id="a68c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">测试应用程序</h1><p id="cedd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，在两个不同的选项卡或窗口中打开应用程序，并尝试使用不同的电子邮件地址发送邮件，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oa"><img src="../Images/f64b6ea0ffd89851ecbef552a2fb14d9.png" data-original-src="https://miro.medium.com/v2/0*gMZeAu8BqCpteU-D"/></div></figure><p id="3dc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，当您查看控制台时，您会看到用户加入服务器和从服务器断开时的日志，这些日志由<code class="fe nx ny nz np b">handleDisconnect</code>和<code class="fe nx ny nz np b">handleConnection</code>方法处理。</p><h1 id="5d12" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="ae5d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在本教程中，我们探讨了如何使用Nestjs和PostgreSQL创建实时聊天应用程序。我们首先简要介绍了Nestjs和WebSockets。然后，我们创建了一个演示应用程序来演示实现。希望你得到了你想要的知识。也许您可以从Nestjs <a class="ae lq" href="https://docs.nestjs.com/websockets/gateways" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于WebSocket实现的知识，并添加扩展应用程序。</p></div></div>    
</body>
</html>