<html>
<head>
<title>Handling NFT Presale — Allowing Lists Off-chain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理NFT预售——允许列表离线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/handling-nft-presale-allow-lists-off-chain-47a3eb466e44?source=collection_archive---------2-----------------------#2022-01-27">https://betterprogramming.pub/handling-nft-presale-allow-lists-off-chain-47a3eb466e44?source=collection_archive---------2-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="42dc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种使用离线生成的签名优惠券而不是链上允许列表的新方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a2319e348dffa88cbc798a85c4e165da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m97wXEL9rwLZYMLERIlJng.png"/></div></div></figure><p id="aaa2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">NFT的人类是一个由1500个真正独特的角色组成的项目，他们把以太坊区块链称为家。每个人都有一个手写的背景故事，由我们社区的一名成员贡献。在我们的<a class="ae ln" href="https://medium.com/@humansofnft/designing-an-nft-smart-contract-for-flexible-minting-and-claiming-5b420a9a2d82" rel="noopener">上一篇</a>文章中，我们提供了一些背景，解释了为什么我们需要在一个契约中有如此多的铸造和声明机制。</p><p id="5007" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">经验证的合同可在Etherscan上查阅:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="2af2" class="lt lu iq lp b gy lv lw l lx ly"><a class="ae ln" href="https://etherscan.io/address/0x8575B2Dbbd7608A1629aDAA952abA74Bcc53d22A#code" rel="noopener ugc nofollow" target="_blank">https://etherscan.io/address/0x8575B2Dbbd7608A1629aDAA952abA74Bcc53d22A#code</a></span></pre><h1 id="edfb" class="lz lu iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">反对线上预售/允许列表的理由</strong></h1><p id="7a0b" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">有很多不同的策略来处理一个<em class="mv">预售名单</em>在NFT的投放。您还会听到它被称为<em class="mv">白名单</em>，或<em class="mv">允许列表</em>以及其他名称。它只是指允许以特定方式与合同进行交互的预先批准的地址列表，例如在预售窗口期间生成。</p><p id="67a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一种常见的方法是在契约的存储中简单地包含一个数据结构，该数据结构将每个<code class="fe mw mx my lp b">address</code>映射到一个<code class="fe mw mx my lp b">bool</code>，或者将每个<code class="fe mw mx my lp b">address</code>映射到该地址所允许的铸币数量，看起来可能类似于:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="cc5a" class="lt lu iq lp b gy lv lw l lx ly">mapping(address =&gt; uint8) _allowList;</span><span id="d7a8" class="lt lu iq lp b gy mz lw l lx ly">function setAllowList(<br/>address[] calldata addresses, <br/>uint8 numAllowedToMint<br/>) external onlyOwner {<br/>  for (uint256 i = 0; i &lt; addresses.length; i++) {<br/>    _allowList[addresses[i]] = numAllowedToMint;<br/>  }<br/>}</span></pre><p id="e4c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法绝对没有问题，但是在填充地址列表时，对于合同所有者来说，代价可能会高一些(<code class="fe mw mx my lp b">onlyOwner </code>修饰符表示该函数只能由合同所有者调用)。如果您需要在预售列表中添加1000个地址之类的东西，那么在存储操作上会花费大量的时间。因为人类合同必须考虑几个不同的“列表”(作者、荣誉、预售、创世纪声明)，我们得出结论，这可能不是我们的最佳方法。</p><h1 id="2274" class="lz lu iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">关于Merkle树的争论</strong></h1><p id="b59a" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">在我们寻找更有效的方法时，使用了很多Merkle树。在做了大量的研究并了解了它们的工作原理之后，我们决定走Merkle Tree路线。有许多关于Merkle Trees的文章和资源。有一个非常棒的媒体帖子<a class="ae ln" href="https://nftchance.medium.com/the-gas-efficient-way-of-building-and-launching-an-erc721-nft-project-for-2022-b3b1dac5f2e1" rel="noopener"> (1) </a>是由核呆子智能合同的团队发布的，这本身就非常令人印象深刻，你应该去看看！它链接到一些关于Merkle Trees的好资源，此外还有大量关于gas优化策略的附加信息——我们稍后也会涉及其中的一些。另一个很好的资源是来自Openzeppelin <a class="ae ln" href="https://github.com/OpenZeppelin/workshops/blob/master/06-nft-merkle-drop/slides/20210506%20-%20Lazy%20minting%20workshop.pdf" rel="noopener ugc nofollow" target="_blank"> (2) </a>的一个演示，介绍了它们的实现以及如何进行merkle-proof验证。</p><p id="25cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不打算用这篇文章来解释Merkle树是如何工作的，因为有许多资源，其中一些我已经提到过，会比我做得更好。要点是Merkle树是哈希树(即存储哈希的多分支树)。树中的每个叶子都包含其父数据块的散列。每个非叶(节点)由其子节点的散列组成，依此类推。然后，我们可以使用根(我们将在合同中设置)来验证树中任何数据片段(在我们的例子中是地址)的存在。这是验证大型数据结构(例如预售地址列表)内容的一种非常有效(并且安全)的方式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/7e27b32a61b1b0c23c86034498daab89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqvFIhs93gyKVmb0ErjI_Q.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">前面提到的Openzeppelin演示中的Merkle树图。</p></figure><p id="2f5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们最初决定采用的方法，它包括三个独立的Merkle树(创建、荣誉和售前)。它包括创建三个独立的链外merkle树，并通过专用的<code class="fe mw mx my lp b">onlyOwner </code>函数调用在合同中为每个销售/索赔事件设置Merkle根。虽然您不会在我们的最终契约中看到该实现(原因我们稍后会讨论)，但该实现看起来像这样(为了清楚起见，缩写为):</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="1232" class="lt lu iq lp b gy lv lw l lx ly">import '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';</span><span id="b231" class="lt lu iq lp b gy mz lw l lx ly">...</span><span id="4d77" class="lt lu iq lp b gy mz lw l lx ly">// declare bytes32 variables to store each root (a hash)</span><span id="ae8a" class="lt lu iq lp b gy mz lw l lx ly">bytes32 public genesisMerkleRoot; <br/>bytes32 public authorsMerkleRoot; <br/>bytes32 public presaleMerkleRoot;</span><span id="72c7" class="lt lu iq lp b gy mz lw l lx ly">...</span><span id="9d13" class="lt lu iq lp b gy mz lw l lx ly">// separate functions to set the roots of each individual Merkle Tree</span><span id="2e71" class="lt lu iq lp b gy mz lw l lx ly">function setGenesisMerkleRoot(bytes32 _root) external onlyOwner {<br/> genesisMerkleRoot = _root; <br/>}  </span><span id="586e" class="lt lu iq lp b gy mz lw l lx ly">function setAuthorsMerkleRoot(bytes32 _root) external onlyOwner {<br/>  authorsMerkleRoot = _root; <br/>}</span><span id="2e75" class="lt lu iq lp b gy mz lw l lx ly">function setPresaleMerkleRoot(bytes32 _root) external onlyOwner {<br/>  presaleMerkleRoot = _root; <br/>}</span><span id="3a93" class="lt lu iq lp b gy mz lw l lx ly">...</span><span id="8346" class="lt lu iq lp b gy mz lw l lx ly">// create merkle leaves from supplied data</span><span id="dfa9" class="lt lu iq lp b gy mz lw l lx ly">function _generateGenesisMerkleLeaf(<br/>  address _account, <br/>  uint256 _tokenId<br/>)  internal  pure  returns (bytes32) {  <br/> return keccak256(abi.encodePacked(_tokenId, _account)); <br/>}</span><span id="710b" class="lt lu iq lp b gy mz lw l lx ly">function _generateAuthorsMerkleLeaf(<br/>  address _account, <br/>  uint256 _tokenCount<br/>)  internal  pure  returns (bytes32) {  <br/>  return keccak256(abi.encodePacked(_account, _tokenCount)); <br/>}</span><span id="01eb" class="lt lu iq lp b gy mz lw l lx ly">function _generatePresaleMerkleLeaf(<br/>  address _account, <br/>  uint256 _max<br/>)  internal  pure  returns (bytes32) {  <br/>  return keccak256(abi.encodePacked(_max, _account)); <br/>}</span><span id="f59a" class="lt lu iq lp b gy mz lw l lx ly">...</span><span id="8ccf" class="lt lu iq lp b gy mz lw l lx ly">// function to verify that the given leaf belongs to a given tree using its root for comparison</span><span id="29fa" class="lt lu iq lp b gy mz lw l lx ly">function _verifyMerkleLeaf(  <br/>  bytes32 _leafNode,  <br/>  bytes32 _merkleRoot,  <br/>  bytes32[] memory _proof ) internal view returns (bool) {  <br/>  return MerkleProof.verify(_proof, _merkleRoot, _leafNode); <br/>}</span></pre><p id="c669" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个mint/claim函数调用都需要使用发送者的地址生成和验证一个叶节点。例如，当使用<code class="fe mw mx my lp b">for loop</code>铸造多个代币时:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="f111" class="lt lu iq lp b gy lv lw l lx ly">require(     <br/>  _verifyMerkleLeaf(<br/>     _generateGenesisMerkleLeaf(<br/>        msg.sender, <br/>        _tokenIds[i]),      <br/>     genesisMerkleRoot,<br/>     _proofs[i]<br/>), "Invalid proof, you don't own that Token ID");</span></pre><h1 id="c306" class="lz lu iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">但是……最终的合同没有使用Merkle树……怎么回事？</h1><p id="1843" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">非常正确…我们最终放弃了Merkle Tree实现并重写了合同…但是为什么呢？在向顾问介绍和讨论这种实现时，他指出，尽管这种方法可行，但它忽略了考虑Merkle树的真正价值主张。用户应该能够根据公开可用的树来验证他们自己，所以如果我们能够不断地改变树，那就没有意义了。此外，每当需要在给定列表中添加或删除地址时，都需要生成一个新的Merkle树，并且需要在契约中设置它的新根。维护三个独立的Merkle树开始变得混乱，尤其是不断发展/增长/变化的列表。</p><p id="e484" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一种方法，也是我们最终决定采用的方法，是使用离线生成的签名优惠券，并将其作为参数传递给契约函数。通过使用这种方法，所有的mint/claim函数都可以被标准化，以利用相同的逻辑，并且它最终会稍微更加高效，因为需要为验证执行的操作更少。从部署和管理合同交互的角度来看，它也变得更加经济高效，因为优惠券是离线生成的，更改/删除它们不需要与合同本身进行任何交互。</p><p id="4826" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用优惠券背后的想法是相对直接的。如果您接触crypto或NFTs有一段时间了，您可能以前就听说过“非对称”或“公钥”加密这两个术语。毕竟，您的Eth钱包地址是您的私钥-公钥对的公钥部分，您的私钥用于签署您的交易并验证您是该地址的所有者。</p><p id="a3ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你以前没有听说过这些术语，没关系，它本质上是一个利用私有-公共密钥对的加密系统——你的私有密钥应该保密，决不能与任何人共享，而你的公共密钥是任何人都可以看到的。它是“公开”的。对于我们的优惠券，一段数据是使用只有我们知道的私有(秘密)密钥进行离线签名的，签名(或公钥)可以在链上恢复。这样，我们可以用密码证明契约接收的数据是从一个已知的来源发送的，即。优惠券本身是用我们(人类)的私钥签名的。在我们的例子中，该数据包含用户地址(例如预售名单上的某个人)和特定于该函数调用的一段数据(即匹配预售事件枚举值的整数)。</p><p id="7455" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们合同中的每个铸币/索赔选项(公开销售除外)都需要优惠券。在我们开始之前，让我们回顾一下在契约顶部声明的一些必要的数据类型。<code class="fe mw mx my lp b">Coupon</code>结构定义了签名过程离线生成的数据。例如，<code class="fe mw mx my lp b">CouponType</code> enum允许我们创建特定于事件的优惠券，因此被验证为作者的人不能在预售期间自动声明。最后，<code class="fe mw mx my lp b">SalePhase</code>枚举让我们(作为合同所有者)控制哪个事件是活动的。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="a234" class="lt lu iq lp b gy lv lw l lx ly">struct Coupon {<br/>  bytes32 r;<br/>  bytes32 s;<br/>  uint8 v;<br/> }</span><span id="a8f3" class="lt lu iq lp b gy mz lw l lx ly">enum CouponType {<br/>  Genesis,<br/>  Author,<br/>  Presale<br/>}</span><span id="960a" class="lt lu iq lp b gy mz lw l lx ly">enum SalePhase {<br/>  Locked,<br/>  PreSale,<br/>  PublicSale<br/>}</span></pre><p id="811a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经了解了一些背景信息，让我们来看看售前造币的功能定义:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3baf" class="lt lu iq lp b gy lv lw l lx ly"> /// Mint during presale<br/> /// <a class="ae ln" href="http://twitter.com/dev" rel="noopener ugc nofollow" target="_blank">@dev</a> mints by addresses validated using verified coupons signed by an admin signer<br/> /// <a class="ae ln" href="http://twitter.com/notice" rel="noopener ugc nofollow" target="_blank">@notice</a> mints tokens with randomized token IDs to addresses eligible for presale<br/> /// <a class="ae ln" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> count number of tokens to mint in transaction<br/> /// <a class="ae ln" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> coupon coupon signed by an admin coupon<br/> function mintPresale(uint256 count, Coupon memory coupon)<br/>  external<br/>  payable<br/>  ensureAvailabilityFor(count)<br/>  validateEthPayment(count)<br/> {<br/>    require( <br/>      phase == SalePhase.PreSale, <br/>      'Presale event is not active'<br/>    ); // 1<br/>  <br/>    require(<br/>      count + addressToMints[msg.sender]._numberOfMintsByAddress &lt;=<br/>      MAX_PRESALE_MINTS_PER_ADDRESS,<br/>      'Exceeds number of presale mints allowed'<br/>    ); // 2</span><span id="f73b" class="lt lu iq lp b gy mz lw l lx ly">    bytes32 digest = keccak256(<br/>      abi.encode(CouponType.Presale, msg.sender)<br/>    ); // 3<br/>  <br/>    require(<br/>      _isVerifiedCoupon(digest, coupon), <br/>     'Invalid coupon'<br/>    ); // 4</span><span id="afd4" class="lt lu iq lp b gy mz lw l lx ly">...</span><span id="d0b9" class="lt lu iq lp b gy mz lw l lx ly">}</span></pre><p id="fb62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们分解一下上面的函数中发生了什么。从函数的定义中可以看出，第二个参数属于类型<code class="fe mw mx my lp b">Coupon</code>——这是我们在契约中声明的结构。</p><p id="c3f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">// 1 <br/>第一个<code class="fe mw mx my lp b">require</code>语句检查预售事件是否活动(使用之前使用<code class="fe mw mx my lp b">SalePhase</code>枚举设置的变量)。</p><p id="05fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">// 2 <br/>第二个<code class="fe mw mx my lp b">require</code>语句确保函数调用方没有铸造超过由<code class="fe mw mx my lp b">MAX_PRESALE_MINTS_PER_ADDRESS</code>常量指定的允许量。</p><p id="c429" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">// 3 <br/>现在我们到了有趣的部分——我们为编码的<code class="fe mw mx my lp b">CouponType</code>(一个整数)和函数调用者的地址(<code class="fe mw mx my lp b">msg.sender</code>)创建了一个32字节的散列，如果我们展开它，它看起来会像这样:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="9b09" class="lt lu iq lp b gy lv lw l lx ly">bytes32 digest = keccak256(<br/> abi.encode(<br/>  2, <br/>  0x8575B2Dbbd7608A1629aDAA952abA74Bcc53d22A<br/> )<br/>);</span></pre><p id="f06a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里需要指出的是，我们使用的是<code class="fe mw mx my lp b">abi.encode</code>而不是<code class="fe mw mx my lp b">abi.encodePacked</code>。使用<code class="fe mw mx my lp b">abi.encode</code>不那么模糊，并且在我们生成优惠券时使事情变得更清晰，我们将在后面进行讨论。</p><p id="c56a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">// 4 <br/>在我们允许调用<code class="fe mw mx my lp b">_mint()</code>函数之前，我们需要验证优惠券是由我们的私钥签署的，它包含函数调用者的地址(即他们“在”预售列表上)，并且他们是在正确的时间铸造的。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="ba76" class="lt lu iq lp b gy lv lw l lx ly"> /// <a class="ae ln" href="http://twitter.com/dev" rel="noopener ugc nofollow" target="_blank">@dev</a> check that the coupon sent was signed by the admin signer<br/> function _isVerifiedCoupon(bytes32 digest, Coupon memory coupon)<br/>  internal<br/>  view<br/>  returns (bool)<br/> {<br/>  address signer = ecrecover(digest, coupon.v, coupon.r, coupon.s);<br/>  require(signer != address(0), 'ECDSA: invalid signature');<br/>  return signer == _adminSigner;<br/> }</span></pre><p id="499e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，你可以看到我们“恢复”了签名者，即。来自密钥对的公钥，其私钥最初创建了优惠券。我们使用solidity内置的<code class="fe mw mx my lp b">ecrecover</code>函数通过传入摘要(即优惠券类型和发送者地址的32字节散列)以及优惠券本身。如果你有兴趣深入了解，这篇文章对解释<code class="fe mw mx my lp b">ecrecover</code>如何在幕后运作的复杂性非常有帮助。<code class="fe mw mx my lp b">_isVerifiedCoupon()</code>方法的最后一步是检查签名者是否与<code class="fe mw mx my lp b">_adminSigner</code>匹配，后者是在部署时在契约的构造函数中设置的。提醒一下，这个<code class="fe mw mx my lp b">_adminSigner</code>是属于私钥的公钥，用于在我们的开发环境中离线创建签名(即优惠券)。这种方法提供的安全性完全依赖于开发人员，即我们，对私钥保密。</p><h2 id="f9e9" class="lt lu iq bd ma nf ng dn me nh ni dp mi la nj nk mk le nl nm mm li nn no mo np bi translated"><strong class="ak">那么优惠券从何而来？</strong></h2><p id="9c7c" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">很棒的问题！优惠券是在我们独立的开发环境中使用脚本在本地生成的(在这里我们可以安全地存储我们的私钥)。优惠券然后被同步到Humans API，在那里，访问我们mint站点的用户可以获取它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/25ea4477f71a3bdf913927b24f6d4028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_Es4gY7uUDMtk6fK5LNxg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">用户通过获取优惠券来确认他们在列表中的位置</p></figure><p id="0dda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用于签署/创建优惠券的私钥<strong class="kt ir">不应该存储在服务器上，</strong>原因很明显(你不希望它落入恶意参与者的手中)。一旦手动生成优惠券，它们就会与mint网站的后端(人类API)同步。用户将他们的钱包连接到该网站，然后当他们试图访问该网站的某个造币/索赔部分时，该网站试图使用用户的地址作为查找来获取优惠券。这允许用户确认他们在特定列表中的位置。如果他们在列表上，API返回优惠券，用户被允许进入网站的造币区。当他们通过调用mint函数与合同进行交互时，优惠券和任何其他需要的参数一起被传入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/63e47f7bdfaf46a91ccb35f74ba6b89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcAPRUnQ2k3k-0b2bLiSWg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">优惠券生命周期</p></figure><p id="961e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">优惠券由API存储，用户的地址作为主键:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="541b" class="lt lu iq lp b gy lv lw l lx ly">{<br/>  "0x1813183E1A2a5a...a868A4e1b7610c0": {<br/>    "coupon": {<br/>         "r": "0x77b675bb4808.....674c42bde11618a",<br/>         "s": "0x17baa76756fed.....4b0b9f4a380b8a9",<br/>         "v": 27<br/>    }<br/>}</span></pre><p id="1fe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦从API获取了优惠券，它就被传递给各自的mint函数。下面的代码片段显示了通过从我们的前端调用合同的<code class="fe mw mx my lp b">mintPresale</code>函数来进行预售的实现。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="9040" class="lt lu iq lp b gy lv lw l lx ly">mintPresale(<br/>  qty: number, <br/>  priceInEth: number, <br/>  coupon: ICoupon<br/>) {<br/>  const mintPriceBn = utils.parseEther(priceInEth.toString());<br/>  return this.contract.mintPresale(qty, coupon, {<br/>    value: mintPriceBn.mul(qty),<br/>    gasLimit: GAS_LIMIT_PER * qty<br/>  });<br/>}</span></pre><p id="c3b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">创建优惠券</strong></p><p id="d8b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们通过自定义的Discord bot收集预售地址(我们将单独发布一篇文章来介绍我们是如何做到这一点的)。然后，在我们的本地开发环境中，从数据库中提取地址后，会为每个地址生成一个优惠券，并以用户的地址作为键存储在一个对象中。我们使用来自<code class="fe mw mx my lp b">ethers</code>和<code class="fe mw mx my lp b">ethereumjs-utils</code>库的实用程序来帮助生成优惠券。看看下面的代码，我们将逐步完成生成优惠券的过程。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="6380" class="lt lu iq lp b gy lv lw l lx ly">const {<br/>  keccak256,<br/>  toBuffer,<br/>  ecsign,<br/>  bufferToHex,<br/>} = require("ethereumjs-utils");</span><span id="8bcc" class="lt lu iq lp b gy mz lw l lx ly">const { ethers } = require('ethers');</span><span id="11b8" class="lt lu iq lp b gy mz lw l lx ly">...</span><span id="9612" class="lt lu iq lp b gy mz lw l lx ly">// create an object to match the contracts struct<br/>const CouponTypeEnum = {<br/>  Genesis: 0,<br/>  Author: 1,<br/>  Presale: 2,<br/>};</span><span id="581b" class="lt lu iq lp b gy mz lw l lx ly">let coupons = {};</span><span id="f976" class="lt lu iq lp b gy mz lw l lx ly">for (let i = 0; i &lt; presaleAddresses.length; i++) {<br/>  const userAddress = ethers.utils.getAddress(presaleAddresses[i]);<br/>  const hashBuffer = generateHashBuffer(<br/>    ["uint256", "address"],<br/>    [CouponTypeEnum["Presale"], userAddress]<br/>  );</span><span id="04d4" class="lt lu iq lp b gy mz lw l lx ly">  const coupon = createCoupon(hashBuffer, signerPvtKey);<br/>  <br/>  coupons[userAddress] = {<br/>    coupon: serializeCoupon(coupon)<br/>  };<br/>}</span><span id="6d0f" class="lt lu iq lp b gy mz lw l lx ly">// HELPER FUNCTIONS<br/>function createCoupon(hash, signerPvtKey) {<br/>   return ecsign(hash, signerPvtKey);<br/>}</span><span id="1cc7" class="lt lu iq lp b gy mz lw l lx ly">function generateHashBuffer(typesArray, valueArray) {<br/>   return keccak256(<br/>     toBuffer(ethers.utils.defaultAbiCoder.encode(typesArray,<br/>     valueArray))<br/>   );<br/>}</span><span id="73af" class="lt lu iq lp b gy mz lw l lx ly">function serializeCoupon(coupon) {<br/>   return {<br/>     r: bufferToHex(coupon.r),<br/>     s: bufferToHex(coupon.s),<br/>     v: coupon.v,<br/>   };<br/>}</span></pre><p id="ed3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您还记得，当我们验证合同中的优惠券时，我们通过使用<code class="fe mw mx my lp b">keccak256</code>算法散列编码的<code class="fe mw mx my lp b">CouponType</code>枚举和用户地址来获得摘要。也许现在是关注这种方法的安全性的好时机。虽然我们显然会尽一切可能阻止任何人访问我们的后端，即使恶意行为者设法得到一张(甚至每张)优惠券，他们也无能为力。优惠券的预定接收者被编码在被签名的散列中。这是根据合同方的<code class="fe mw mx my lp b">msg.sender</code>进行检查的，因此恢复正确签名者的唯一方法是优惠券的发送者是否被编码在优惠券本身中。如果无法访问与密钥对中的<code class="fe mw mx my lp b">_adminSigner</code>相匹配的私钥，恶意演员就无法生成他/她自己的有效优惠券。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="d5cd" class="lt lu iq lp b gy lv lw l lx ly">// [solidity] recreating the digest in the contract <br/>bytes32 digest = keccak256(<br/>  abi.encode(CouponType.Presale, msg.sender)<br/>);</span><span id="ead8" class="lt lu iq lp b gy mz lw l lx ly">// [javascript] Creating the digest for the coupon off-chain<br/>const hashBuffer = generateHashBuffer(<br/>   ["uint256", "address"],<br/>   [CouponTypeEnum["Presale"], userAddress]<br/>);</span><span id="e8ae" class="lt lu iq lp b gy mz lw l lx ly">function generateHashBuffer(typesArray, valueArray) {<br/>   return keccak256(<br/>     toBuffer(ethers.utils.defaultAbiCoder.encode(typesArray,<br/>     valueArray))<br/>   );<br/>}</span></pre><p id="f9ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在生成优惠券时，我们创建了一个名为<code class="fe mw mx my lp b">generateHashBuffer(typesArray, valueArray)</code>的便利函数，它利用了来自<code class="fe mw mx my lp b">ethereumjs-utils</code>的<code class="fe mw mx my lp b">keccack256</code>方法，该方法将一个缓冲区作为其唯一的参数，并返回一个包含散列数据的缓冲区。为了对数据进行编码，在将数据转换到缓冲区之前，我们利用<code class="fe mw mx my lp b">ethers.utils.defaultAbiCoder.encode()</code>方法对数据进行编码，该方法接受两个数组，第一个数组包含类型<code class="fe mw mx my lp b">[“uint256”, “address”]</code>作为字符串，第二个数组包含要编码的值<code class="fe mw mx my lp b">[CouponTypeEnum[“Presale”], userAddress]</code>。</p><p id="29d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了将用来恢复签名的数据的散列，我们可以使用来自<code class="fe mw mx my lp b">ethereumjs-utils</code>的<code class="fe mw mx my lp b">ecsign</code>方法创建优惠券。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="1f7c" class="lt lu iq lp b gy lv lw l lx ly">function createCoupon(hash, signerPvtKey) {<br/>   return ecsign(hash, signerPvtKey);<br/>}</span></pre><p id="061d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mw mx my lp b">ecsign</code>方法接受散列数据(缓冲区)和签名者的私钥(也是一个缓冲区)，并返回一个<code class="fe mw mx my lp b">ECDSASignature</code>。椭圆曲线数字签名算法(ECDSA) <a class="ae ln" href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" rel="noopener ugc nofollow" target="_blank"> (4) </a>是非对称加密的另一个例子，其中用户A用他们的私钥创建签名，用户B能够应用标准算法来恢复签名人(用户A)的公钥。这篇中型文章<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/secure-and-test-the-contract-with-ecdsa-signature-3ff368a479a6"> (5) </a>对如何使用它提供了一些很好的见解。还值得指出的是，<code class="fe mw mx my lp b">ecsign</code>方法为<code class="fe mw mx my lp b">eth_sign</code> RPC方法转换签名格式，而不是<code class="fe mw mx my lp b">personal_sign</code>方法，后者会将<code class="fe mw mx my lp b">\x19Ethereum Signed Message:\n</code>字符串添加到消息前面，这在我们的用例中是不需要的。一旦我们创建了优惠券，我们就调用<code class="fe mw mx my lp b">serializeCoupon()</code>便利函数并传入原始优惠券。该函数返回一个对象，其中的<code class="fe mw mx my lp b">r</code>和<code class="fe mw mx my lp b">s</code>缓冲区被转换为十六进制字符串，以便于存储。如果你有兴趣了解更多关于<code class="fe mw mx my lp b">ECDSASignature</code>的<code class="fe mw mx my lp b">{r,s,v}</code>组件，这本关于密码学的实用指南<a class="ae ln" href="https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages" rel="noopener ugc nofollow" target="_blank"> (6) </a>提供了一些很好的见解。</p><p id="cdbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您还记得，我们之前提到过<code class="fe mw mx my lp b">ecsign</code>的私钥参数需要一个缓冲区，所以在使用它来生成优惠券之前，我们一定不要忘记将它从字符串转换过来:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="6783" class="lt lu iq lp b gy lv lw l lx ly">const signerPvtKeyString = process.env.ADMIN_SIGNER_PRIVATE_KEY || "";</span><span id="0ca0" class="lt lu iq lp b gy mz lw l lx ly">const signerPvtKey = Buffer.from(signerPvtKeyString, "hex");</span></pre><p id="079e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">值得一提的是，私钥不必来自现有的/活动的钱包，事实上它可能更安全。相反，您可以使用<code class="fe mw mx my lp b">crypto.randomBytes(32)</code>生成一个单一用途的私有密钥，然后使用下面的代码从中导出公共密钥(签名者):</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="03c0" class="lt lu iq lp b gy lv lw l lx ly">const { privateToAddress } = require("ethereumjs-utils");<br/>const { ethers } = require("ethers");<br/>const crypto = require("crypto");</span><span id="69a9" class="lt lu iq lp b gy mz lw l lx ly">const pvtKey = crypto.randomBytes(32);<br/>const pvtKeyString = pvtKey.toString("hex");<br/>const signerAddress = ethers.utils.getAddress(<br/>privateToAddress(pvtKey).toString("hex"));</span><span id="07a7" class="lt lu iq lp b gy mz lw l lx ly">console.log({ signerAddress, pvtKeyString });</span></pre><p id="dd30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，<code class="fe mw mx my lp b">signerAddress</code>是我们在部署契约时传递给构造函数来设置<code class="fe mw mx my lp b">_adminSigner</code>的地址。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h2 id="edcd" class="lt lu iq bd ma nf ng dn me nh ni dp mi la nj nk mk le nl nm mm li nn no mo np bi translated"><strong class="ak">人类契约中的优惠券有哪些不同的使用案例？</strong></h2><p id="87f4" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">正如我们在这篇文章的前文中提到的，我们有各种各样的mint / claim事件，每一个都有其特殊的环境和条件。使用优惠券允许我们使用相同的方法来处理所有的优惠券，而不需要重复代码或添加任何定制的复杂逻辑。我将在下面详述这些。</p><h2 id="4b1e" class="lt lu iq bd ma nf ng dn me nh ni dp mi la nj nk mk le nl nm mm li nn no mo np bi translated"><strong class="ak">作者</strong> <br/>我们的作者获得了免费的薄荷糖，作为为我们人类提交Bios的交换。每个作者根据自己的个人贡献获得不同数量的人类，并有权免费获得他们获得的人类(除了支付汽油费)。让我们看看函数定义和优惠券创建代码。</h2><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="7bb8" class="lt lu iq lp b gy lv lw l lx ly">// [solidity] function signature</span><span id="2d5e" class="lt lu iq lp b gy mz lw l lx ly">function claimAuthorTokens(<br/>  uint256 count, <br/>  uint256 allotted, <br/>  Coupon memory coupon<br/>) public ensureAvailabilityFor(count) {</span><span id="a372" class="lt lu iq lp b gy mz lw l lx ly">  require(claimActive, 'Claim event is not active');</span><span id="2f81" class="lt lu iq lp b gy mz lw l lx ly">  bytes32 digest = keccak256(<br/>    abi.encode(<br/>      CouponType.Author, allotted, msg.sender<br/>    )<br/>  );</span><span id="39b2" class="lt lu iq lp b gy mz lw l lx ly">  require(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');</span><span id="2857" class="lt lu iq lp b gy mz lw l lx ly">  ...</span><span id="5b4d" class="lt lu iq lp b gy mz lw l lx ly">}</span><span id="f17e" class="lt lu iq lp b gy mz lw l lx ly">// [javascript] Creating the Author Coupons<br/>  <br/>for (const [address, qty] of Object.entries(authorAddressList)) {<br/>  const hashBuffer = generateHashBuffer(<br/>    [<br/>      "uint256", <br/>      "uint256", <br/>      "address"<br/>    ],<br/>    [<br/>      CouponTypeEnum["Author"], <br/>      qty, <br/>      ethers.utils.getAddress(address)<br/>    ]<br/>  );</span><span id="51c9" class="lt lu iq lp b gy mz lw l lx ly">  const coupon = createCoupon(hashBuffer, signerPvtKey);<br/>  coupons[ethers.utils.getAddress(address)] = {<br/>     qty,<br/>     coupon: serializeCoupon(coupon)<br/>  };<br/>}</span></pre><p id="254e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面的片段可以看出，<code class="fe mw mx my lp b">qty</code>(即。获得的人类数量)因作者而异，所以每个作者的优惠券都有分配给他们的编码数字。我们将<code class="fe mw mx my lp b">qty</code>(他们被允许索赔的总数量)和<code class="fe mw mx my lp b">count</code>(在该事务中被索赔的数量)一起传递到合同<code class="fe mw mx my lp b">claimAuthorTokens()</code>函数中。我觉得这是一个很好的时机来指出我们的优惠券不包含nonce，这将在大多数实现中使用。传统上，这可以防止有人重复使用优惠券，但在这种情况下，我们可以重复使用优惠券，因为合同会跟踪有多少人被认领:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="5eae" class="lt lu iq lp b gy lv lw l lx ly">require( <br/> count + addressToMints[msg.sender]._numberOfAuthorMintsByAddress &lt;=<br/> allotted,'Exceeds number of earned Tokens'<br/>);</span></pre><h2 id="e889" class="lt lu iq bd ma nf ng dn me nh ni dp mi la nj nk mk le nl nm mm li nn no mo np bi translated"><strong class="ak">荣誉人类</strong></h2><p id="884e" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">我们总共有35名荣誉人类。这些是为帮助支持和/或激励该项目的特定个人创建的1对1手绘人类。我们为这些人保留了代币id<code class="fe mw mx my lp b">230 — 264</code>，所以我们需要将指定的id合并到优惠券中。让我们检查一下函数定义:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="379a" class="lt lu iq lp b gy lv lw l lx ly">function claimReservedTokensByIds(<br/>  address owner_,<br/>  uint256[] calldata idxsToClaim,<br/>  uint256[] calldata idsOfOwner,<br/>  Coupon memory coupon<br/>) external {<br/>  require(claimActive, 'Claim event is not active');<br/>  bytes32 digest = keccak256(<br/>    abi.encode(CouponType.Genesis, idsOfOwner, owner_)<br/>  );</span><span id="5b53" class="lt lu iq lp b gy mz lw l lx ly">  ...</span><span id="5fea" class="lt lu iq lp b gy mz lw l lx ly">}</span></pre><p id="7ede" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为项目团队，这个<code class="fe mw mx my lp b">claimReservedTokensByIds()</code>函数也是我们的一个方法，如果出于某种原因，他们不能自己认领，就把特定的id空投到给定的地址。它使用相同的机制来提供接收者地址(<code class="fe mw mx my lp b">owner_</code>)、包含属于<code class="fe mw mx my lp b">owner_</code>地址的id的<code class="fe mw mx my lp b">idsOfOwner</code>数组的索引(<code class="fe mw mx my lp b">idxsToClaim</code>)。这听起来有点混乱，但是让我们看看函数定义中缺少的部分:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="ce8f" class="lt lu iq lp b gy lv lw l lx ly">   ...</span><span id="2c0c" class="lt lu iq lp b gy mz lw l lx ly">  require(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');</span><span id="0191" class="lt lu iq lp b gy mz lw l lx ly">  for (uint256 i; i &lt; idxsToClaim.length; i++) {<br/>     uint256 tokenId = idsOfOwner[idxsToClaim[i]];<br/>     _claimReservedToken(owner_, tokenId);<br/>  }</span><span id="8ffc" class="lt lu iq lp b gy mz lw l lx ly">}</span></pre><p id="cc25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设用户拥有令牌id<code class="fe mw mx my lp b">[3,9,122,211]</code>，这些都将被编码在优惠券中。如果出于某种原因，他们只想声明id<code class="fe mw mx my lp b">9</code>和<code class="fe mw mx my lp b">211</code>，那么作为<code class="fe mw mx my lp b">idxsToClaim</code>，他们会在数组<code class="fe mw mx my lp b">[1,3]</code>中传递，因为<code class="fe mw mx my lp b">idsOfOwner[1] = 9;</code>等。这允许用户或代表他们空投代币的美国人在单次交易中申领他们所有代币的子集。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="140f" class="lt lu iq lp b gy lv lw l lx ly">const hashBuffer = generateHashBuffer(<br/>  [<br/>    "uint256",<br/>    "uint256[]",<br/>    "address"<br/>  ],<br/>  [<br/>    CouponTypeEnum["Genesis"],<br/>    idsArray,<br/>    ethers.utils.getAddress(address)<br/>  ]<br/>);</span><span id="919d" class="lt lu iq lp b gy mz lw l lx ly">const coupon = createCoupon(hashBuffer, signerPvtKey);</span></pre><p id="68f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您在上面的代码片段中看到的，当我们生成优惠券时，我们包含了用于Genesis声明的<code class="fe mw mx my lp b">CouponType</code> enum(用于保留令牌id)，以及用户拥有的id数组。</p><h2 id="908a" class="lt lu iq bd ma nf ng dn me nh ni dp mi la nj nk mk le nl nm mm li nn no mo np bi translated"><strong class="ak">焚烧-认领创世令牌</strong></h2><p id="b546" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">在前面的帖子中，我们提到了我们有一个由229个人组成的创世纪系列，这些人是根据Opensea的共享ERC1155合同制造的。我们希望将这些合并到我们自己合同的新集合中，所以我们实现了一个烧录替换机制。我们将在另一个帖子中讨论转移机制，但现在我们将扩展我们如何使用优惠券，因为我们认为这是一个有趣的用例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9ef11c051168e484cdbcc07e8da06a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*Hl0975HTmz_JRo8uM_TpQw.png"/></div></figure><p id="cacf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了从Opensea合同中烧录令牌并从我们的新合同中要求一对一的替换，我们需要知道每个令牌的Opensea令牌ID。如果你不熟悉ERC1155标准的令牌id是什么样子，它们被存储为一个<code class="fe mw mx my lp b">uint256</code>。当我们创建最初的集合时，我们决定通过集合中的编号来“命名”人类(即一个我们自己的ID)，例如<code class="fe mw mx my lp b">HumansOfNFT #1 </code>。Opensea分配它自己的令牌id(不是连续的)，所以为了将我们的id映射到它们的Opensea IDs，我们创建了一个脚本，从Opensea的API中提取我们的集合，解析元数据，并从<code class="fe mw mx my lp b">name</code>属性中提取我们的id。下面是我们的API中的一个条目示例，它将我们自己的令牌ID映射到由Opensea的共享合同分配的令牌ID:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="2795" class="lt lu iq lp b gy lv lw l lx ly">{<br/>  "genesisId": 1,<br/>  "openseaTokenId": "23436743935348681979378854387323145555258469867980315876480069342051002482689"<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/db82747226c88f2b89c8d7e2c223ede0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ecAUBqmwoJFTInZu3x-0aw.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">燃烧到索赔替代创世令牌</p></figure><p id="926f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当用户点击我们的<code class="fe mw mx my lp b">genesis_claim.png</code>图标时，我们会扫描他们的钱包，检查是否有来自Opensea共享合同的令牌。然后，我们将这些令牌id与为原始集合存储的令牌id进行比较。如果找到匹配，就从API中检索该ID的优惠券。因为burn机制涉及调用Opensea契约上的<code class="fe mw mx my lp b">safeTransferFrom()</code>方法，所以传递优惠券的唯一方式是在附加的<code class="fe mw mx my lp b">data</code>字段中。看一下我们如何在前端启动传输:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="6761" class="lt lu iq lp b gy lv lw l lx ly">function burnOpenseaToken( <br/>   userAddress: string,<br/>   openseaId: string,<br/>   newCollectionId: number,<br/>   coupon: Object<br/>) {<br/><br/>  const openseaIdBN = ethers.BigNumber.from(openseaId);<br/>  const data = utils.defaultAbiCoder.encode(<br/>     ["uint256", "tuple(bytes32 r, bytes32 s, uint8 v)"],<br/>     [newCollectionId, coupon]<br/>  );</span><span id="674c" class="lt lu iq lp b gy mz lw l lx ly">  const callData = {<br/>    from: utils.getAddress(userAddress),<br/>    to: utils.getAddress(this.humansContractAddress),<br/>    id: openseaIdBN,<br/>    data,<br/>  };</span><span id="4cb2" class="lt lu iq lp b gy mz lw l lx ly">  // call the opensea contracts safeTransferFrom fn</span><span id="294e" class="lt lu iq lp b gy mz lw l lx ly">  return this.contract.safeTransferFrom(<br/>    callData.from,<br/>    callData.to,<br/>    callData.id,<br/>    1,<br/>    callData.data<br/>  );<br/>}</span></pre><p id="afd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了做到这一点，我们简单地包含了来自标准ERC1155契约实现的ABI，它允许我们使用<code class="fe mw mx my lp b">ethers </code>调用函数。在我们深入上面的代码片段之前，让我们快速浏览一下ERC1155的<code class="fe mw mx my lp b">safeTransferFrom()</code>的函数签名:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="c299" class="lt lu iq lp b gy lv lw l lx ly">safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data)</span></pre><p id="b9c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您会注意到传入的最后一个参数(<code class="fe mw mx my lp b">data</code>)的类型是<code class="fe mw mx my lp b">bytes</code>。因此，为了让我们通过优惠券，我们需要将其编码为一个<code class="fe mw mx my lp b">tuple</code>:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="4147" class="lt lu iq lp b gy lv lw l lx ly">const data = utils.defaultAbiCoder.encode(<br/>     ["uint256", "tuple(bytes32 r, bytes32 s, uint8 v)"],<br/>     [newCollectionId, coupon]<br/>  );</span></pre><p id="99ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，我们能够将优惠券作为一个字符串<code class="fe mw mx my lp b">bytes</code>传递，并在转移启动时触发<code class="fe mw mx my lp b">onERC1155Received</code>回调时在契约中对其进行解码。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="e9a0" class="lt lu iq lp b gy lv lw l lx ly">function onERC1155Received(<br/>  address, <br/>  address from,<br/>  uint256 id, <br/>  uint256, <br/>  bytes memory data<br/>) public virtual override returns (bytes4) { </span><span id="2486" class="lt lu iq lp b gy mz lw l lx ly">  require(<br/>    msg.sender == _openseaSharedContractAddress,<br/>    'Sender not approved'<br/>  );<br/>  (uint256 genesisId, Coupon memory coupon) = abi.decode(<br/>    data(uint256, Coupon)<br/>  );</span><span id="28e3" class="lt lu iq lp b gy mz lw l lx ly">  ...<br/>}</span></pre><p id="93b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们确保只有来自Opensea共享契约的令牌可以被我们的契约接收——我们不希望人们向我们的契约发送随机令牌。接下来，我们提取<code class="fe mw mx my lp b">genesisId</code>(新集合中的令牌ID)和优惠券。为了恢复签名者，我们需要<code class="fe mw mx my lp b">CouponType</code>、<code class="fe mw mx my lp b">genesisId</code>(即。新集合中的ID)和<code class="fe mw mx my lp b">id</code>(来自共享契约的<code class="fe mw mx my lp b">uint256</code>令牌ID)。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3b89" class="lt lu iq lp b gy lv lw l lx ly">bytes32 digest = keccak256(<br/>  abi.encode(CouponType.Genesis, genesisId, id)<br/>);</span></pre><p id="69d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们创建了摘要并确认恢复的签名者与签名者的公钥匹配，令牌传输就可以完成了。</p><h2 id="ab5f" class="lt lu iq bd ma nf ng dn me nh ni dp mi la nj nk mk le nl nm mm li nn no mo np bi translated"><strong class="ak">预售</strong></h2><p id="6cec" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">我们在这篇文章中使用了预售优惠券作为例子，所以我们不会再重复这个实现，因为我们已经深入讨论过了。</p><h2 id="e328" class="lt lu iq bd ma nf ng dn me nh ni dp mi la nj nk mk le nl nm mm li nn no mo np bi translated"><strong class="ak">那么，在将优惠券部署到mainnet之前，我们如何测试它们呢？</strong></h2><p id="ae37" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">测试，测试，再测试。我再怎么强调测试尽可能多的场景的重要性也不为过。我使用Hardhat作为我的工作流程的一部分，因此作为我的单元测试的一部分，我能够动态地生成优惠券。请看下面我们的一个单元测试的摘录:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="c182" class="lt lu iq lp b gy lv lw l lx ly">describe('presale minting', async function () {<br/>  it('should be active', async function () {<br/>    await expect(await humansOfNft.phase()).to.equal(1);<br/>  });</span><span id="7af8" class="lt lu iq lp b gy mz lw l lx ly">  // presaleAddresses are populated using ethers.getSigners();</span><span id="ea48" class="lt lu iq lp b gy mz lw l lx ly">  presaleAddresses.forEach(async function (account) {<br/>    it('should allow a whitelisted wallet to mint during presale',<br/>      async function () {<br/>        console.log(`${account} is minting presale`);<br/>        let presaleIndex = this.accounts.findIndex(<br/>        (signer: SignerWithAddress) =&gt; {<br/>          return ( signer.address === account);<br/>        });<br/>        const tokenCount = Math.ceil(Math.random() * 3);<br/>        const mintPriceInWei = await humansOfNft.mintPrice();<br/>        const mintAmountInEther = parseFloat(<br/>          ethers.utils.formatEther(mintPriceInWei.toString())<br/>        ) * tokenCount;</span><span id="5cc7" class="lt lu iq lp b gy mz lw l lx ly">        const hash = generateHashBuffer(<br/>           ['uint256', 'address',[CouponTypeEnum['Presale'],<br/>           this.accounts[presaleIndex].address]<br/>        );</span><span id="7026" class="lt lu iq lp b gy mz lw l lx ly">        const coupon = createCoupon(hash, this.signerPvtKey);</span><span id="e8a2" class="lt lu iq lp b gy mz lw l lx ly">        expect(await humansOfNft.connect(<br/>           this.accounts[presaleIndex]).mintPresale(<br/>             tokenCount, coupon, { <br/>               value: ethers.utils.parseEther(<br/>               mintAmountInEther.toString())<br/>             })<br/>           ).to.emit(humansOfNft, 'Transfer');<br/>        });<br/>    });<br/>})</span></pre><p id="89ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是全部了！如果你有任何问题，或者注意到文章中的任何错误，请在评论中提出来！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="940f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">特别感谢<a class="ob oc ep" href="https://medium.com/u/f8fef5ff64a6?source=post_page-----47a3eb466e44--------------------------------" rel="noopener" target="_blank"> xtremetom </a>他好心地回答了我的问题并提供了一些建议，感谢<a class="ob oc ep" href="https://medium.com/u/6f41ae64d95?source=post_page-----47a3eb466e44--------------------------------" rel="noopener" target="_blank"> Lawrence Forman </a>的指导和智慧。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="c58b" class="lt lu iq lp b gy lv lw l lx ly"><strong class="lp ir">Want to Connect?</strong></span><span id="b17f" class="lt lu iq lp b gy mz lw l lx ly">You can find us via our website: <a class="ae ln" href="https://humansofnft.com" rel="noopener ugc nofollow" target="_blank">https://humansofnft.com</a>. Or come and visit us on Discord: <a class="ae ln" href="https://discord.gg/humansofnft" rel="noopener ugc nofollow" target="_blank">https://discord.gg/humansofnft</a></span></pre></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="e523" class="lz lu iq bd ma mb od md me mf oe mh mi jw of jx mk jz og ka mm kc oh kd mo mp bi translated"><strong class="ak">参考文献</strong></h1><p id="b3dd" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">(1)<a class="ae ln" href="https://nftchance.medium.com/the-gas-efficient-way-of-building-and-launching-an-erc721-nft-project-for-2022-b3b1dac5f2e1" rel="noopener">https://NFT chance . medium . com/the-gas-efficient-way-of-building-and-launch-an-ERC 721-NFT-project-for-2022-B3 B1 DAC 5 F2 e 1</a></p><p id="af07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(2)<a class="ae ln" href="https://github.com/OpenZeppelin/workshops/blob/master/06-nft-merkle-drop/slides/20210506%20-%20Lazy%20minting%20workshop.pdf" rel="noopener ugc nofollow" target="_blank">https://github . com/open zeppelin/workshop/blob/master/06-NFT-merkle-drop/slides/2021 05 06% 20-% 20 lazy % 20 minting % 20 workshop . pdf</a></p><p id="3347" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">③https://soliditydeveloper.com/ecrecover<a class="ae ln" href="https://soliditydeveloper.com/ecrecover" rel="noopener ugc nofollow" target="_blank"/></p><p id="7dc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(4)<a class="ae ln" href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Elliptic _ Curve _ Digital _ Signature _ Algorithm</a></p><p id="0726" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(5)<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/secure-and-test-the-contract-with-ecdsa-signature-3ff368a479a6">https://better programming . pub/secure-and-test-the-contract-with-ECD sa-signature-3ff 368 a 479 a 6</a></p><p id="fc4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(6)<a class="ae ln" href="https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages" rel="noopener ugc nofollow" target="_blank">https://crypto book . nakov . com/digital-signatures/ECD sa-sign-verify-messages</a></p></div></div>    
</body>
</html>