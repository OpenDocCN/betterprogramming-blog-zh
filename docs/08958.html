<html>
<head>
<title>How To Implement a Foreground Service in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中实现前台服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-foreground-service-in-android-3487d9719ab6?source=collection_archive---------1-----------------------#2021-06-30">https://betterprogramming.pub/what-is-foreground-service-in-android-3487d9719ab6?source=collection_archive---------1-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="36b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解什么是前台服务，并将其集成到您的Android应用程序中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c431fe47d215db32e4a22e3627648fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDPZP-U9e8AYKe4P55iSig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="d470" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Android世界中，服务的典型定义是在后台执行<strong class="la iu"> </strong>长期运行任务的应用程序组件。它不提供用户界面。一个服务主要运行在主线程<strong class="la iu"> </strong>上，除非另有说明。我们应该确保在服务中运行非阻塞操作。服务从一开始就是Android组件的一部分，但现在正在对它们进行增强，以提供最佳的用户体验。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8d1b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">问题</h1><p id="bccd" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">服务在后台运行，可以消耗位置、摄像机等资源。从背景本身来说。由于它没有任何用户界面，用户不会知道应用程序中正在运行什么类型的服务以及正在消耗的资源。这对安全性和性能都有影响。</p><p id="2882" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是前台服务的用武之地。</p><p id="3480" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将发现什么是前台服务，为什么我们需要前台服务，以及如何实现前台服务。</p><p id="491b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果想直接跳转到代码库，请查看<a class="ae my" href="https://github.com/pavan5208/android_sample_foreground_service" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="496a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是前台服务？</h1><p id="9a24" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">前台服务只不过是执行用户可察觉的任务的服务。为了通知用户，我们需要在状态栏中显示通知。这些通知的优先级应该为<code class="fe mz na nb nc b">PRIORITY_LOW</code>或更高。除非任务完成，并且服务由于各种因素被自身或系统停止或移除，否则通知不能被移除。</p><p id="8095" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，用户将会意识到一些工作正在后台执行，这些工作可能会消耗系统资源。</p><p id="8655" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前台服务的一个简单例子是任何音频播放器应用程序。让我们以一个音乐播放器应用程序为例，即使该应用程序没有运行，它也会在播放歌曲时显示通知。这里，我们有一些控件可以与服务交互，显示与正在播放的当前歌曲相关的信息，等等。在通知中。但是，只有当服务终止时，通知才会被删除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/99829c488cf2401aae336838e9a17770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Am4jmjZLik3L9UD9T_OzoQ.jpeg"/></div></div></figure><p id="b23d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们也看到送货应用程序在状态栏中显示订单的跟踪情况，并带有通知，像优步这样的出租车乘车应用程序在通知中显示乘车的轨迹，如果乘车正在进行，等等。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="48a4" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">我们为什么需要前台服务？</strong></h1><p id="9195" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果针对Android的应用程序在应用程序未运行时试图使用一个正常的服务来进行后台操作，那么系统会杀死这个服务，我们无法完成我们的任务。为了在后台顺利处理事情，我们需要使用前台服务通知用户。</p><p id="4429" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在下面的示例中看到这一点，以便更好地理解它。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="07b2" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">如何实现前台服务</h1><p id="62e9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">实现部分与服务的实现部分非常相似，但略有不同。让我们检查一下执行此操作的逐步过程。</p><p id="2833" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个示例应用程序，其中有一个带有两个按钮(开始和停止)的活动和一个显示服务状态(运行或不运行)的文本视图。在这里，我们也创建一个普通服务，测试它以了解问题，然后通过添加通知将服务迁移到前台服务。</p><h2 id="ddd6" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">第一步</h2><p id="1b85" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们需要为针对Android 9 (API级别28) <strong class="la iu"> </strong>或更高版本的应用程序请求前台服务权限。我们需要在清单文件中指定以下权限:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="b977" class="ne mc it nc b gy nu nv l nw nx"><strong class="nc iu">&lt;</strong>uses-permission android:name<strong class="nc iu">="</strong>android.permission<strong class="nc iu">.FOREGROUND_SERVICE"/&gt;</strong></span></pre><p id="5727" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这是系统授予的权限，因此不需要额外的处理。当在清单中指定时，系统自动授予它。</p><p id="bdff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ny">注意:如果在清单文件中没有这个权限就启动前台服务，系统会在运行时抛出一个</em><code class="fe mz na nb nc b"><em class="ny">SecurityException</em></code><strong class="la iu"><em class="ny"/></strong><em class="ny">导致app崩溃:</em></p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="1e5a" class="ne mc it nc b gy nu nv l nw nx">java.lang.SecurityException: Permission Denial: startForeground from pid=xxx, uid=xxxx requires android.permission.FOREGROUND_SERVICE</span></pre><h2 id="e319" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">第二步</h2><p id="4b4d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们创建一个带有两个按钮和一个文本视图的布局文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="779a" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">第三步</h2><p id="70ea" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们创建一个简单的<code class="fe mz na nb nc b">Service</code>类。当我们收到<code class="fe mz na nb nc b">ACTION_STOP</code><em class="ny"/>动作时，我们停止服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4a8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">ACTION_STOP</code> <strong class="la iu"> </strong>不过是一个被赋予任意值的常数。我给出了以下值:</p><pre class="kj kk kl km gt nq nc nr ns aw nt bi"><span id="78ec" class="ne mc it nc b gy nu nv l nw nx">const val  ACTION_STOP =  "${BuildConfig.<em class="ny">APPLICATION_ID</em>}.stop"</span></pre><h2 id="8f2f" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">第四步</h2><p id="bf44" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">现在让我们根据这些要求创建一个<code class="fe mz na nb nc b">Activity</code>:</p><ul class=""><li id="92bc" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated">单击start按钮，我们启动服务并在文本视图中更新状态。</li><li id="cf90" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">单击stop按钮，我们停止服务并在文本视图中更新状态。</li><li id="2a49" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">在<code class="fe mz na nb nc b">onCreate</code>中，我们在文本视图中更新服务状态。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="6ba3" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated">检查服务是否正在运行</h2><p id="9430" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe mz na nb nc b">isMyServiceRunning</code> <strong class="la iu"> </strong>是一种功法。当我们给一个类名时，我们可以通过使用<code class="fe mz na nb nc b">ActivityManager</code>来检查一个服务是否正在运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ca2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在运行应用程序，并通过启动应用程序来检查输出。单击start按钮，注意文本视图得到了更新。现在杀死app，重新打开，查看文本视图中的服务状态是否处于停止状态。默认情况下，Android系统在以Android 9 (API级别28)或更高版本为目标的设备上执行此操作。你可以测试各种情况。</p><h2 id="c7c9" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated"><strong class="ak">输出</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a992057c5929dc896759e0bd7209aef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/1*N0MPx4XYTqZT8VJN1O6b3A.gif"/></div></figure><h2 id="9730" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated"><strong class="ak">第五步</strong></h2><p id="c1e4" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们通过添加通知、调用<code class="fe mz na nb nc b">startForeground</code> <strong class="la iu">、</strong>并返回<code class="fe mz na nb nc b">START_STICKY</code>来将我们的普通服务类迁移到前台服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1659" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">START_STICKY</code> <strong class="la iu"> </strong>无非是从<code class="fe mz na nb nc b">onStartCommand</code> <strong class="la iu">返回的常量。</strong>如果返回，系统基本上会在服务被杀死后尝试重新创建服务。</p><p id="f428" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您在这种情况下检查输出时，即使应用程序被终止并重新启动，服务(一旦启动)也不会停止。我们可以通过查看文本视图中显示的状态来检查这一点。我们应该手动停止它，当我们经过<code class="fe mz na nb nc b">stopForeground</code>内的<code class="fe mz na nb nc b">true</code>时，它会自动取消通知。传递<code class="fe mz na nb nc b">boolean</code>是可选的，如果我们设置<code class="fe mz na nb nc b">true</code>，它将删除通知。</p><h2 id="0441" class="ne mc it bd md nf ng dn mh nh ni dp ml lh nj nk mn ll nl nm mp lp nn no mr np bi translated"><strong class="ak">输出</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/2be8cf6f5562be3e396fffb4fb03822b.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/1*5xSal1JiHaEuaaVRBBgqvw.gif"/></div></figure><p id="5b61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，由于我们的服务是实时的而不是停止的，所以我们可以执行长期运行的任务。此外，它还显示通知，通知用户我们正在消耗系统资源。</p><p id="ce5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您在执行代码片段时发现任何困难，请查看<a class="ae my" href="https://github.com/pavan5208/android_sample_foreground_service" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6e9b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">摘要</h1><p id="5768" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">服务可以以多种方式使用，但是对服务进行前台限制可以提高安全性和性能。根据您的需求使用前台服务。不要忘记在清单中添加<code class="fe mz na nb nc b">FOREGROUND_SERVICE</code> <strong class="la iu"> </strong>权限。要启动前台服务，调用<code class="fe mz na nb nc b">startForeground()</code>。要停止它，调用<code class="fe mz na nb nc b">stopForeground()</code>。</p><p id="d889" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e004" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="134c" class="ob oc it la b lb mt le mu lh oq ll or lp os lt og oh oi oj bi translated"><a class="ae my" href="https://developer.android.com/guide/components/foreground-services" rel="noopener ugc nofollow" target="_blank">前台服务</a></li><li id="1946" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae my" href="https://github.com/pavan5208/android_sample_foreground_service" rel="noopener ugc nofollow" target="_blank">Android _ sample _ foreground _ service</a></li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="5dd3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">更多Android文章</h1><ul class=""><li id="1cf3" class="ob oc it la b lb mt le mu lh oq ll or lp os lt og oh oi oj bi translated"><a class="ae my" href="https://medium.com/@pavan.careers5208" rel="noopener">了解视图在Android中的呈现方式</a></li><li id="acc1" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae my" href="https://proandroiddev.com/the-life-cycle-of-a-view-in-android-6a2c4665b95e" rel="noopener ugc nofollow" target="_blank">Android中一个视图的生命周期</a></li><li id="b5a2" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae my" href="https://medium.com/android-dev-hacks/kotlin-advanced-programming-89aef9b2ecb8" rel="noopener">科特林系列</a></li><li id="9c2c" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/how-to-implement-in-app-purchases-in-your-android-app-7cc1f80148a4">如何在您的Android应用中实现应用内购买</a></li><li id="b34e" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated"><a class="ae my" href="https://medium.com/@pavan.careers5208" rel="noopener">多更</a></li></ul></div></div>    
</body>
</html>