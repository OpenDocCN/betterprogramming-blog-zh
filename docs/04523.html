<html>
<head>
<title>Why Bother Using Property Decorators in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么要在Python中使用属性装饰器呢？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-bother-using-property-decorators-in-python-935c425f86ed?source=collection_archive---------1-----------------------#2020-04-20">https://betterprogramming.pub/why-bother-using-property-decorators-in-python-935c425f86ed?source=collection_archive---------1-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对@property有了更深入的了解</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e35b3d0b817f0b02dbecb924beb1286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zMnoWjUkgAxR4LcZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Radek Grzybowski 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要掌握任何编程语言，你都必须学习样本代码——Python也不例外。作为一种面向对象的编程语言，Python允许我们定义自定义类，这一特性允许我们优雅地对相关数据和功能进行分组。</p><p id="ea41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在回顾一些经验丰富的Python程序员的代码时，您可能会遇到在自定义类中使用<code class="fe lv lw lx ly b">@property</code>的情况。此时，您可能已经知道这是Python decorators的语法，以及decorator是什么。然而，你可能已经学过的教程大多是一般性的讨论——其中一些很可能使用了<code class="fe lv lw lx ly b">@property</code>作为例子。然而，你不知道在什么场景下使用decorators才是正确的。你还在想<em class="lz">为什么我们要在Python中使用属性装饰器</em>。</p><p id="a63b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将简要了解如何使用属性装饰器的语法。从下面的第一部分可以看出，通过采用点符号访问，可以使定义的属性变得简洁，从而增加代码的可读性。您还将了解使用属性装饰器的四个基本好处，以及在您自己的代码中实现这一特性的一些通用指南。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d96f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">基本语法</h1><p id="266f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">下面的代码片段向您展示了自定义类中属性装饰器的基本语法。我们将<code class="fe lv lw lx ly b">@property</code>应用到我们想要装饰的属性中。在本例中，它是<code class="fe lv lw lx ly b">Mask</code>实例对象的<code class="fe lv lw lx ly b">price</code>。我们还为<code class="fe lv lw lx ly b">price</code>属性定义了setter和deleter方法。通过实现这些方法，我们可以像访问常规属性一样访问、更新和删除属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实现属性装饰器</p></figure><p id="e814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，我们使用下划线作为前缀来创建<code class="fe lv lw lx ly b">_price</code>属性，这表明该属性是“私有的”众所周知，这不是真正的私有，因为其他模块仍然可以访问它。关于下划线不同含义的更多信息，请参考我以前关于这个主题的文章。</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/better-programming/not-all-underscores-are-equal-in-python-b50768124092" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">在Python中，并不是所有的下划线都相等</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">了解每个单词的含义</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="c932" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">原因1:数据验证</h1><p id="67a2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">理解了基本语法之后，我们就可以开始有趣的部分了——decorator。使用属性装饰器的第一个好处是允许我们在设置属性时验证数据。</p><p id="55cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，需要检查要设置的价格是否是一个有效的正数。此外，我们需要为价格设定一个上限。我们希望防止有人以高得离谱的价格出售口罩，尤其是在冠状病毒爆发期间。</p><p id="b325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们升级上面的代码来实现这些数据验证检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的Setter</p></figure><p id="ad7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个更新的setter，我们可以在定价时验证我们的数据。以下代码片段向您展示了各种可能的场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据有效性</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="09d3" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">原因2:数据操作(封装)</h1><p id="c7df" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有时，我们访问一个对象的属性的唯一场合是为了数据显示的目的，这样，如果检索价格的API返回一个已经格式化的值，它会更友好。考虑我们示例的以下升级:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的Getter</p></figure><p id="c925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用更新的getter方法，我们可以直接获得格式化的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取格式化的值</p></figure><p id="6c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们可以通过基于应用程序的语言环境提供额外的定制来使其更加强大。考虑下面的假设示例，我们的应用程序将部署在美国和英国:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Getter方法:一般示例</p></figure><p id="42c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了getter方法上的数据操作，如果这是一个合理的特性，我们还可以将一些相关的代码应用到setter方法上。我们不会在这个话题上展开太多，但是下面显示了一个简化的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Setter方法上的数据操作</p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="2d4f" class="ny mi it bd mj nz oa dn mn ob oc dp mr li od oe mt lm of og mv lq oh oi mx oj bi translated">原因三:懒加载</h2><p id="fc3c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果您来自不同的编程背景，比如Swift或Kotlin，您应该熟悉惰性加载的概念。本质上，我们可以推迟工作，直到相关数据被实际请求，这样我们就可以在对象被实例化时不预先加载所有属性，从而节省时间和内存。</p><p id="df6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这种惰性加载概念应用于属性装饰器，我们还可以创建一些仅支持getter的属性，如下面的代码片段所示。换句话说，属性装饰者只实现getters函数是可以的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">属性的延迟加载</p></figure><p id="06db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看到，创建实例对象<code class="fe lv lw lx ly b">mask5</code>后，存储的属性只包括<code class="fe lv lw lx ly b">category</code>和<code class="fe lv lw lx ly b">_price</code>，如使用内置<code class="fe lv lw lx ly b">__dict__</code>函数所示。当我们访问像<code class="fe lv lw lx ly b">promotion_price</code>和<code class="fe lv lw lx ly b">sales_price</code>这样的各种属性时，所需的计算是在数据检索时完成的。</p><p id="736e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还记得，我们可以将decorators概念化为接受其他函数的函数包装器。这些属性只是函数，访问这些属性实质上就是调用它们。与此相关的一点是，函数也是Python中的一级对象，因此它们可以在调用其他函数时用作参数。</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/swlh/everything-is-an-object-in-python-learn-to-use-functions-as-objects-ace7f30e283e" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">在Python中，一切都是对象——学习使用函数作为对象</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">就像str、int、dict一样，函数也是Python中的对象。了解我们如何利用这一特性…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="ok l nu nv nw ns nx ks nj"/></div></div></a></div></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ebae" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">原因4:调试和监控</h1><p id="44b7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当这个项目的范围扩大时，许多其他模块开始使用这个自定义类。项目中的多个地方可能会访问和更新同一个对象，这可能会引入不一致甚至错误。因此，了解对象的特定属性在其生命周期中是如何变化的会很有用。</p><p id="4df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有getter和setter方法，就不容易知道到底发生了什么。实现属性装饰器为我们记录这些更新记录创造了机会，这对调试和数据监控非常有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调试和监控</p></figure><p id="3a03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们更新了setter和deleter方法，这将记录相关事件。重要的是，当出现一些异常事件时，例如将价格提高到10英镑以上，我们会将它们记录到应急日志中，该日志可以链接到一些警报系统，要求立即关注和调查。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1034" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="1995" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在本文中，我们回顾了在Python中使用属性装饰器的四个好处。特别是在大型项目中，属性装饰器在获取和设置某些属性方面给了我们更多的灵活性。在适用的情况下，我们可以封装各种操作，而不会将无关的API暴露给其他模块。更重要的是，我们可以记录关键事件，以便及时调试和监控数据。</p></div></div>    
</body>
</html>