<html>
<head>
<title>Challenge your NestJS skills by creating a REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过创建REST API来挑战您的NestJS技能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/nestjs-challenge-take-the-basic-steps-and-start-developing-a-rest-api-5401b234d834?source=collection_archive---------2-----------------------#2022-03-19">https://betterprogramming.pub/nestjs-challenge-take-the-basic-steps-and-start-developing-a-rest-api-5401b234d834?source=collection_archive---------2-----------------------#2022-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2856" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NestJS REST API项目的蓝图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f177633d67bd053356439c839e7a439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqJsUTfuV9ibSsEJQDpKlg.jpeg"/></div></div></figure><h1 id="ee40" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">简介和先决条件</h1><p id="867a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你认为是时候接受挑战，开始开发一个<a class="ae mi" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank">NestJS</a><a class="ae mi" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">REST</a><a class="ae mi" href="https://en.wikipedia.org/wiki/API" rel="noopener ugc nofollow" target="_blank">API</a>了，那么这篇文章可能是有用的敲门砖。</p><p id="ff84" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这篇文章只是介绍了启动这样一个项目所需的基本步骤。实际上，它将引导您到这样一个点，您会认为下一阶段是使用数据库(如MongoDB、PostgreSQL、MySQL/MariaDB、Oracle、MS SQL Server等)为项目添加一些持久性。</p><p id="5525" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">用户认证，即用户访问限制，是几乎所有REST API后端项目的关键部分。所以，这篇文章真正要做的，是向您展示创建用户认证项目所需的基本步骤。</p><p id="af76" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">别想歪了。在这篇文章中，您不会得到任何关于包安装和/或创建项目或者项目模块的示例命令。这是你的挑战。然而，您的奖励将是一个带有示例代码的存储库，作为下面给出的步骤的结果。</p><p id="2293" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">因此，假设您已经对<a class="ae mi" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>和<a class="ae mi" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>框架及其<a class="ae mi" href="https://docs.nestjs.com/cli/overview" rel="noopener ugc nofollow" target="_blank"> CLI </a>足够熟悉。</p><p id="3590" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">此外，如果您还不熟悉NestJS的基本构件，如<a class="ae mi" href="https://docs.nestjs.com/modules" rel="noopener ugc nofollow" target="_blank">模块</a>、<a class="ae mi" href="https://docs.nestjs.com/providers" rel="noopener ugc nofollow" target="_blank">提供者</a>、<a class="ae mi" href="https://docs.nestjs.com/controllers" rel="noopener ugc nofollow" target="_blank">控制器</a>、<a class="ae mi" href="https://docs.nestjs.com/recipes/router-module" rel="noopener ugc nofollow" target="_blank">路由器</a>等。请花些时间去做，否则，你应该按照下面的步骤逐步去做。此外，您应该准备好处理一些与开发简单REST API相关的关键主题，如<a class="ae mi" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD操作</a>、<a class="ae mi" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"> DTO </a>、<a class="ae mi" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>和JSON类对象、<a class="ae mi" href="https://en.wikipedia.org/wiki/Authentication" rel="noopener ugc nofollow" target="_blank">认证</a>和<a class="ae mi" href="https://en.wikipedia.org/wiki/Authorization" rel="noopener ugc nofollow" target="_blank">授权</a>、<a class="ae mi" href="https://en.wikipedia.org/wiki/Key_derivation_function#Password_hashing" rel="noopener ugc nofollow" target="_blank">密码散列</a>、<a class="ae mi" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a>令牌以及<a class="ae mi" href="https://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">护照</a>包。最后，你还必须处理一些其他的概念和包，例如，如何使用decorators，数据验证和转换，如何为你的NestJS项目定义和使用外部定义的参数，等等。</p><p id="878d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">所以，做好准备，开始遵循下面的步骤。编码快乐！</p><h1 id="9bb2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">a .</strong>T27】基础知识</h1><p id="aa3b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">创造一个新的巢穴。Js项目。NestJS CLI 将成为您的工具。</p><p id="0231" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">创建核心数据库实体</p><ul class=""><li id="919d" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">识别并开始创建主要实体(类)和/或接口。至少，定义并创建一个基本的用户实体类及其属性。例如:</li><li id="681c" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><code class="fe nc nd ne nf b">id: string;<br/>username: string;<br/>password: string;<br/>email: string;<br/>registrationdate: Date;<br/>confirmed: boolean;<br/>canceled: boolean;<br/>typeid: number;<br/>countryid: number;</code></li><li id="20de" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">稍后，您将添加其他对象，如<a class="ae mi" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank">数据传输对象—dto</a>、回购等。</li><li id="a1d3" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">你可以考虑使用一个单独的文件夹(例如<code class="fe nc nd ne nf b">dataObjects</code>)来存放你所有的实体和dto。</li></ul><p id="2954" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">定义您的主要REST API端点。例如，从一个类似的表开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/22b996077e1a2e5d391c30d09673f6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fBJ_5BzP10Hi5wXFovZGQ.png"/></div></div></figure><p id="7369" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">注意:稍后，您可以在表中添加更多的端点，并采取类似的步骤。</p><ul class=""><li id="de8d" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">考虑为REST API端点使用一个全局前缀(例如，<code class="fe nc nd ne nf b">tickets</code>)。</li><li id="3af4" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">稍后，您可以考虑添加API版本控制方法和/或每个模块的路由和子路由</li></ul><p id="6a0a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">创建主/核心模块、控制器和服务:</p><ul class=""><li id="c763" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">第一个基本方法是为每个端点创建一个模块。例如，对于上面的端点<code class="fe nc nd ne nf b">/auth</code>和<code class="fe nc nd ne nf b">/users</code>，分别创建<code class="fe nc nd ne nf b">AuthModule</code>和<code class="fe nc nd ne nf b">UsersModule</code>(如果没有其他特殊原因，可以删除<code class="fe nc nd ne nf b">app.controller.ts</code>和<code class="fe nc nd ne nf b">app.service.ts</code>——因为默认为<code class="fe nc nd ne nf b">app.module.ts</code>，所以默认创建)。</li><li id="d65a" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">为每个模块创建一个控制器和一个服务(例如，<code class="fe nc nd ne nf b">UsersController</code>、<code class="fe nc nd ne nf b">UsersService</code>和<code class="fe nc nd ne nf b">AuthController</code>、<code class="fe nc nd ne nf b">AuthService</code>)。</li><li id="53e7" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">为每个控制器创建必要的REST API处理程序(用<code class="fe nc nd ne nf b">@Get</code>、<code class="fe nc nd ne nf b">@Post</code>、<code class="fe nc nd ne nf b">@Delete</code>、<code class="fe nc nd ne nf b">@Patch</code>等修饰的函数)。)</li><li id="4cfb" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">对于服务(与特定的控制器相匹配),创建对应于特定REST API处理程序的函数(函数处理程序)。</li></ul><p id="e58f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">为您的项目启用Git版本控制，并执行您的第一次提交。</p><p id="5e76" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">创建一个存储库，例如<code class="fe nc nd ne nf b">DbRepo</code>:</p><ul class=""><li id="492f" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">这样的repo可以托管支持两者所需的所有功能:即<code class="fe nc nd ne nf b">AuthService</code>和<code class="fe nc nd ne nf b">UsersService</code>。它实际上将对来自控制器和服务的API请求提供真实的响应。</li><li id="beb8" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">注1:出于同样的目的，我们当然可以分别使用<code class="fe nc nd ne nf b">AuthService</code>和<code class="fe nc nd ne nf b">UsersServiice</code>。然而，这种方法会导致重用一些相似的(如果不是完全相同的)功能，此外还会在决定哪个服务应该包含其他帮助功能时遇到麻烦。如果以后我们决定为处理其他实体的其他端点添加更多的模块，那就更是如此。</li><li id="3dbc" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">注2:我们也可以使用单独的<code class="fe nc nd ne nf b">DbModule</code>和<code class="fe nc nd ne nf b">DbService</code>(或同名:<code class="fe nc nd ne nf b">DbRepo</code>)作为<code class="fe nc nd ne nf b">DbModule</code>的服务。但是这种方法会让我们处于试图解决循环依赖问题的境地。(你可以在Nest.js 的<a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/nest-js-avoid-circular-dependency-issues-4f7577377acc">避免循环依赖问题中看到我的一篇与此类问题相关的帖子)。因此，使用一个<code class="fe nc nd ne nf b">solo</code>库作为<code class="fe nc nd ne nf b">Provider</code>似乎是一个更好的方法，允许我们避免大量的</a><a class="ae mi" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">枯燥的</a>代码。</li></ul><p id="3e02" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">使用日志记录。为您的类使用NestJS日志记录器，而不是console.log。将其用于测试目的、调试、错误等。</p><p id="6b40" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">使用<a class="ae mi" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>和/或浏览器开始执行初始测试，例如，测试主要的REST API端点。</p><p id="7418" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">提交更改。</p><h1 id="972e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak"> B. </strong> <strong class="ak">增强、细化、验证和变形</strong></h1><p id="e054" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">完善和增强端点的功能。例如，添加通过id获取用户的参数，搜索并返回用户对象，等等。</p><ul class=""><li id="9381" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">处理搜索和过滤—搜索用户名、搜索电子邮件等。(例如:<code class="fe nc nd ne nf b">users?status=statusId&amp;page=1&amp;pageSize=10</code>)</li><li id="fc02" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">基于带有可选参数的DTO添加补丁/更新</li><li id="6179" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">对于特定的端点和REST API(例如，一些CRUD)动作，考虑创建一些特定的DTO，例如，使用DTO进行搜索/过滤</li><li id="a4aa" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">如果属性条目已经存在，则改进Post/Patch(具有相同名称和/或电子邮件的用户)等。</li></ul><p id="d064" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">提交。</p><p id="2b84" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">类/实体的验证和转换</p><ul class=""><li id="9de4" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">安装并使用<a class="ae mi" href="https://www.npmjs.com/package/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a>和<a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/class-transformer">类转换器</a>库——这些库允许我们在dto中使用decorators，并为API端点的请求和响应提供数据转换功能。0</li><li id="117e" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">在dto中配置和使用Nest.js <code class="fe nc nd ne nf b">ValidationPipe</code>。</li><li id="9dd7" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">为提供数据(有效负载)的传入客户端参数化请求应用验证规则—使用NestJS管道验证器—相应地修饰您想要的dto</li><li id="4423" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">为可序列化的类/对象实现类转换。</li><li id="ed0f" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">从以下两种方法中选择一种合适的方法来实现序列化对象的转换。</li><li id="9d53" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">-通过使用内置的<code class="fe nc nd ne nf b">ClassSerializerInterceptor</code>(参见<a class="ae mi" href="https://docs.nestjs.com/techniques/serialization" rel="noopener ugc nofollow" target="_blank">序列化文档</a>)。<code class="fe nc nd ne nf b">@UseInterceptors(ClassSerializerInterceptor)</code></li><li id="a462" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">-通过为我们的应用程序创建一个更通用的实现自定义<code class="fe nc nd ne nf b">Transformation Interceptor</code>。</li><li id="dec8" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">用适当的转换装饰器来装饰必要的类实体(和/或dto)</li></ul><p id="8288" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">提交更改。创建一个新的远程git repo并提交您的提交。</p><h1 id="f162" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">c .</strong>T15】实施外部定义的配置</h1><p id="47c0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用外部。env文件来定义一些必要的参数——为NestJS安装<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.npmjs.com/package/@nestjs/config" rel="noopener ugc nofollow" target="_blank">@nestjs/config</a></code>包(注意:<code class="fe nc nd ne nf b">@nestjs/config</code>包内部使用众所周知的<a class="ae mi" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>包)。</p><p id="b865" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在大多数情况下，这是必要的，因为我们使用一些值以及一些可能在生产中改变的敏感信息。示例:</p><ul class=""><li id="08cf" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">App监听端口号、API全局路由前缀、JWT参数(令牌秘密、令牌到期时间，例如，以秒为单位—参见下一节— D)。数据库连接参数(类型、主机、端口、用户名、密码、数据库)等。,</li><li id="df8d" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">全局使用<a class="ae mi" href="https://docs.nestjs.com/techniques/configuration#getting-started" rel="noopener ugc nofollow" target="_blank"> ConfigModule </a>，并在<strong class="lo iu"> main.ts </strong>和其他模块以及动态导入的模块中实现。示例:<code class="fe nc nd ne nf b">JwtModule</code></li><li id="1259" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">排除。git中的env文件(将它/它们添加到。gitignore) —如有必要，将它们包括到生产部署中，例如在/dist文件夹中</li><li id="6ca7" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">使用schema validation pro-tool(<a class="ae mi" href="https://joi.dev/" rel="noopener ugc nofollow" target="_blank">Joi</a>是NestJS建议/推广的工具)来验证从外部. env文件获得的配置值。</li><li id="145e" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">注1:我们也可以使用Joi进行DTOs类验证，而不是类验证器。然而，我们必须意识到Joi使用带有Joi属性装饰器的JSON对象作为模式验证器，因此我们必须为每个DTO创建这样的模式对象，与我们的dto分开。一个可能的解决方案——如果我们想使用Joi验证——是使用一些其他的助手包，这些包超出了本文的挑战范围。</li><li id="77a9" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">注意2:对于配置:或者，我们可以创建并使用我们自己的<code class="fe nc nd ne nf b">Configuration</code>服务(基于<code class="fe nc nd ne nf b">@nestjs/config/ConfigModule</code>)来处理来自操作系统运行时环境的环境变量(例如，通过操作系统外壳导出的<code class="fe nc nd ne nf b">export DATABASE_USER=test</code>)和位于内部的环境变量。env文件，以及在用于不同目的的不同配置集和各种功能模块中使用它(例如，当我们必须处理不同的数据库和存储库时)。此外，请注意，我们可以使用<a class="ae mi" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>格式/语法(通过<a class="ae mi" href="https://www.npmjs.com/package/js-yaml" rel="noopener ugc nofollow" target="_blank"> js-yaml </a>)来使用定制配置文件</li></ul><p id="2a11" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">测试您的更改是否正常运行。</p><p id="c6a3" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">提交更改并提交您的提交。[看这个基础回购:<a class="ae mi" href="https://github.com/zzpzaf/nest-external-config-env" rel="noopener ugc nofollow" target="_blank">https://github.com/zzpzaf/nest-external-config-env</a>]</p><h1 id="1cbe" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak"> D. </strong> <strong class="ak">开始使用JWT实施基础认证(用户认证)。</strong></h1><p id="8b0f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">安装<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank">bcrypt</a></code>和<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank">UUID</a></code>包/库。</p><ul class=""><li id="5baf" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated"><a class="ae mi" href="https://en.wikipedia.org/wiki/Bcrypt" rel="noopener ugc nofollow" target="_blank"> bcrypt </a>是一个<a class="ae mi" href="https://en.wikipedia.org/wiki/Password-hashing_function" rel="noopener ugc nofollow" target="_blank">密码散列</a>函数，它能够散列和取消散列一个普通密码。</li><li id="f869" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mi" href="https://en.wikipedia.org/wiki/Universally_unique_identifier" rel="noopener ugc nofollow" target="_blank"> UUID </a>提供允许你创建一个通用的唯一标识符(UUID ),它可以被用作唯一值，因此它们可以被用作用户实体中ID属性的主键。</li><li id="6b99" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">注意:以后添加数据库时，如果您选择的数据库提供密码哈希和自动生成UUID功能，则可以删除它们。</li><li id="249a" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">为用户凭证定义一个新的DTO，并应用一些验证规则(用户名长度、电子邮件、使用@Matches decorator和regex的密码要求等)。)</li></ul><p id="bb7d" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">提交更改并提交您的提交。</p><p id="44e6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">安装<a class="ae mi" href="https://www.npmjs.com/package/@nestjs/jwt" rel="noopener ugc nofollow" target="_blank"> @nestjs/jwt </a>包，该包使您能够用签名的<a class="ae mi" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a>来保护您的应用程序。</p><ul class=""><li id="2030" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">基于JWTs实现初始认证—对于NestJS，这是<a class="ae mi" href="https://www.npmjs.com/package/@nestjs/jwt" rel="noopener ugc nofollow" target="_blank"> @nestjs/jwt </a>包。(稍后，我们还将添加护照包)。</li><li id="bd13" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">在现有模块的imports部分添加/声明<code class="fe nc nd ne nf b"><strong class="lo iu">JwtModule</strong></code>(例如在AthModule中),并应用一些基本配置，例如secret和以秒为单位的过期时间。</li><li id="4c0f" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">然后，您可以在另一个类中使用<code class="fe nc nd ne nf b"><strong class="lo iu">JwtService</strong></code>(来自JwtModule)，例如在认证服务“AuthService”中创建/返回或验证JWT。</li><li id="07f8" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">定义一个<code class="fe nc nd ne nf b"><strong class="lo iu">payload</strong></code>接口或类(为了一致性和可维护性，避免错误，等等)。).</li><li id="b359" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">我们总是可以从请求体中获得有效负载对象</li><li id="e917" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">为登录流程创建一个新的令牌(JWT )(用于<code class="fe nc nd ne nf b">/auth/signin</code>端点)</li><li id="fa32" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">检查用户端点中的JWT—我们可以在<code class="fe nc nd ne nf b">AuthService</code>中实现验证，然而，另一个选择是在我们的<code class="fe nc nd ne nf b"><strong class="lo iu">repo</strong></code> ( <code class="fe nc nd ne nf b">DbRepo</code>)中实现。</li><li id="d918" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">注意:我们可以只对一个或几个端点这样做，看看我们如何处理它。然而，为每个端点做这件事需要大量的样板代码，因此不容易维护。因此，稍后我们将使用<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">Passport</a></code>库，它允许我们实现一个<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.passportjs.org/packages/passport-jwt/" rel="noopener ugc nofollow" target="_blank">jwt strategy</a></code>并使用Passport提供的<code class="fe nc nd ne nf b">AuthGuard</code>对象(实际上是<code class="fe nc nd ne nf b">@nestjs/passport</code>)(见下文)来保护整个路由(例如端点)。</li></ul><p id="e189" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">通过邮递员测试您的更改。</p><p id="4a38" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">提交更改并提交您的提交。[看看这个回购:<a class="ae mi" href="https://github.com/zzpzaf/nest-external-config-env-jwt" rel="noopener ugc nofollow" target="_blank">https://github.com/zzpzaf/nest-external-config-env-jwt</a></p><h1 id="635f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak"> E. </strong> <strong class="ak">通过使用Passport库增强项目的认证(用户认证)。</strong></h1><p id="5c98" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">添加<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.npmjs.com/package/passport" rel="noopener ugc nofollow" target="_blank">Passport</a></code>包和助手包:<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.npmjs.com/package/@nestjs/passport" rel="noopener ugc nofollow" target="_blank">@nestjs/passport</a></code>，它提供了与NestJS框架/生态系统的集成，以及<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.npmjs.com/package/passport-jwt" rel="noopener ugc nofollow" target="_blank">passport-jwt</a></code>，它是jwt的通行证策略包(我们还必须添加<code class="fe nc nd ne nf b"><a class="ae mi" href="https://www.npmjs.com/package/@types/passport-jwt" rel="noopener ugc nofollow" target="_blank">@types/passport-jwt</a></code>作为<code class="fe nc nd ne nf b">devDependency</code>)</p><ul class=""><li id="a7e5" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">在我们的<code class="fe nc nd ne nf b">AuthModule</code>中声明(导入)<code class="fe nc nd ne nf b">PassportModule</code>，并将jwt注册为默认策略。</li><li id="7e21" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">创建一个<code class="fe nc nd ne nf b">JwtStrategy</code>类(它应该扩展<code class="fe nc nd ne nf b">PassportStrategy</code>)并定义一个validate()函数</li><li id="8dfa" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">使用<code class="fe nc nd ne nf b">UsersController</code>中的<a class="ae mi" href="https://docs.nestjs.com/guards#putting-it-all-together" rel="noopener ugc nofollow" target="_blank"> NestJS路线保护装置</a>(使用带有Passport的<code class="fe nc nd ne nf b">AuthGuard()</code>内置方法的<code class="fe nc nd ne nf b">@UseGuards()</code>装饰器)或任何其他控制器或端点处理器。</li><li id="7bd1" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">测试并提交更改。推进你的承诺。</li></ul><h2 id="0211" class="nh kv it bd kw ni nj dn la nk nl dp le lv nm nn lg lz no np li md nq nr lk ns bi translated"><strong class="ak">太好了！你做到了！</strong></h2><h1 id="7390" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated"><strong class="ak">外卖</strong></h1><p id="ef1d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">到目前为止，一切顺利。如果您已经完成了上面的所有步骤，那么您应该已经掌握了开始开发NestJS REST API以及使用和实现关键概念和包的惊人知识。如果你没有，不要担心！还有“B计划”。这是一个<a class="ae mi" href="https://github.com/zzpzaf/nest-external-config-env-jwt-passport" rel="noopener ugc nofollow" target="_blank">库</a>，可以作为一个例子来说明如何实现一个结果代码。</p><p id="2088" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">请注意，包含的代码可能不是最好的，但肯定可以更好。但无论如何，这是有效的！(嗯，至少对我来说是).</p><p id="56b9" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">项目文件夹结构如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://github.com/zzpzaf/nest-external-config-env-jwt-passport"><div class="gh gi nt"><img src="../Images/b348f00b8329f9ffa88806d0738dc49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*hXtJ4uwd6RQ99h_-JX6AXg.png"/></div></a></figure><p id="594b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">因此，获取或克隆<a class="ae mi" href="https://github.com/zzpzaf/nest-external-config-env-jwt-passport" rel="noopener ugc nofollow" target="_blank">示例库</a>并尝试解释所有相关的模块和文件，使用上述步骤作为参考指南。以下是我的一些其他帖子，你可能会觉得对这个挑战有用:</p><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/step-ahead-fast-with-nestjs-environment-configuration-406701b3379f"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">在NestJS中实现外部定义的配置设置</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用NestJS环境配置快速前进</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">better编程. pub</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/jwt-and-passport-jwt-strategy-for-your-nestjs-rest-api-project-cafa9dd59890"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">您的NestJS REST API项目的JWT和护照JWT策略</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">一步一步详细实施</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">better编程. pub</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><p id="20d0" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">祝你的编码之旅好运！就是这样。Thnx阅读，敬请关注！</p></div></div>    
</body>
</html>