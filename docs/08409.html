<html>
<head>
<title>The Power of the MutationObserver in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中变异观测器的威力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-power-of-the-mutationobserver-in-javascript-930450a92e48?source=collection_archive---------8-----------------------#2021-04-27">https://betterprogramming.pub/the-power-of-the-mutationobserver-in-javascript-930450a92e48?source=collection_archive---------8-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用变异观察器来观察你的用户</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9962d10b448dfb75633d9c56af61006e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27ubATqyJF5S_BWV2d0bvw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b35e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现代编程中，有很多关于所谓的<em class="lv">状态</em>的讨论，这通常围绕着用户交互性。<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank">变异观察器</a>是一个强大的API，可以帮助我们做到这一点，因为我们可以用它来对用户交互做出反应。它取代了DOM3事件规范中遗留的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent" rel="noopener ugc nofollow" target="_blank">突变事件</a> API。</p><p id="79f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个<code class="fe lw lx ly lz b">MutationObserver</code>，我们需要用关键字<code class="fe lw lx ly lz b">new</code>和回调来实例化它，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="746f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">onMutation</code>回调接收两个参数(按顺序):</p><ol class=""><li id="25bb" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><code class="fe lw lx ly lz b">Mutations</code>—<code class="fe lw lx ly lz b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" rel="noopener ugc nofollow" target="_blank">MutationRecord</a></code>对象列表。</li><li id="865c" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe lw lx ly lz b">Observer</code> —建造的<code class="fe lw lx ly lz b">MutationObserver</code>。在我们最近的例子中，它是<code class="fe lw lx ly lz b">observer</code>变量。</li></ol><p id="f440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次使用<code class="fe lw lx ly lz b">observe</code>方法注册的DOM节点发生变化或突变时，都会调用<code class="fe lw lx ly lz b">onMutation</code>回调。</p><p id="7534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">observe</code>方法接受一个DOM元素作为它的第一个参数，接受一个options对象作为它的第二个参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="dd92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当DOM节点有任何变化时，回调就会被调用，并接收一个<code class="fe lw lx ly lz b">MutationRecord</code>对象的列表作为它的第一个参数，其中包含发生的突变的<em class="lv">类型</em>以及关于发生了什么的附加信息。通过这些记录对象，我们可以对用户体验进行巧妙的改进。</p><p id="2e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以开始观察一个元素，并在我们添加、删除甚至用其他子元素替换子元素时得到通知，但是我们必须通过在<em class="lv">选项</em>参数中传递<code class="fe lw lx ly lz b">childList: true</code>来请求该信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/16d3e4b8382c176c0ebdadde66187d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HQduKcOlyZxsLJm7.png"/></div></div></figure><p id="a2b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以询问其他信息。下面是我们可以传入的选项的完整列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="59e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们请求<code class="fe lw lx ly lz b">attributes</code>并且一个属性的值被改变时，我们能够通过像这样传入<code class="fe lw lx ly lz b">attributeOldValue: true</code>来观察它被改变之前的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/e6dd24dd1af2286a24cb3008346b31f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A4lT72wkv7P6XmIC.png"/></div></div></figure><p id="c60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">attributeFilter</code>选项用于过滤掉我们不关心的突变。从逻辑上讲，应用程序越大，就越有必要这样做。否则，我们会很快结束一堆调用，这些调用是我们很可能永远不会在那个观察者中关联的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/7a833acb2c74088d0e261e45357c1e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ze6P8tW4NwhTfMj_.png"/></div></div></figure><p id="8f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只关心在<code class="fe lw lx ly lz b">hidden</code>和<code class="fe lw lx ly lz b">title</code>改变时接收通知，我们可以把它放在过滤器选项中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="819e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这减少了结果，我们不必在回调实现中过滤它(这会膨胀功能块，使我们的代码将来更难维护):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/40c865ae6f83538655a7082291383992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ySkNKJ6kMhenxWAx.png"/></div></div></figure><p id="8780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在选项中设置<code class="fe lw lx ly lz b">subtree: true</code>时，我们将会得到被观察元素的所有后代发生变化的通知:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/3456ab785970be86aa0b4a90f8a80dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d2WG7q3QnVDs36YB.png"/></div></div></figure><p id="0fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将<code class="fe lw lx ly lz b">characterData</code>设置为<code class="fe lw lx ly lz b">true</code>，我们可以得到元素内文本内容变化的通知，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3fc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，选择选项将调用我们在观察器上的回调:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/54b0191e5667cd4deae8be9210102ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y7i_gbYSxem-WKgn.png"/></div></div></figure><p id="6666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<code class="fe lw lx ly lz b">characterData</code>选项只会在<code class="fe lw lx ly lz b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createTextNode" rel="noopener ugc nofollow" target="_blank">Text</a></code>节点上的文本内容发生变化时通知我们。</p><p id="550d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以代替这个的是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="46a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须创建一个<code class="fe lw lx ly lz b">Text</code>节点，并在它的<code class="fe lw lx ly lz b">data</code>上设置它的文本，这将触发回调:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="db1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你已经对<code class="fe lw lx ly lz b">MutationObserver</code>的工作原理有了基本的了解，让我们快速构建一些使用它来增强用户体验的东西吧！</p><p id="fa84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在构建一个页面，让用户自定义他们的个人资料页面。我们给他们一个选项，让他们添加框来决定视觉结构，这就是它的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7398824ed9572107bc4181816f9cc203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/0*xkT5IfY2umjxlLaC.gif"/></div></figure><p id="d397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将展示样式表、DOM结构和JavaScript(代码中还没有<code class="fe lw lx ly lz b">MutationObserver</code>):</p><p id="edfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样式表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="dbda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们点击按钮，出现方框时，我们会感到有点困惑，不知道从哪里开始，或者甚至不知道应该关注哪个方框。我们可以通过在最近的框中添加一个高亮来解决这个问题，以提醒用户应该查看他们刚刚添加的框。稍后，我们可以添加输入、选择等控件。就像普通的应用程序一样。</p><p id="cba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">突出显示最近的框意味着向用户发出信号，表明最近的框是活动的，引导用户找到它，而不是他们看着每个框，不知道从哪里开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/4edf1939db37b5b7ecf64fece4c4a70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/0*iZAF-cGxhB-2dOeM.gif"/></div></figure><p id="7a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地使用一个<code class="fe lw lx ly lz b">MutationObserver</code>来动态突出显示(甚至取消突出显示)添加到页面中的框。</p><p id="a33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以在前面的例子上再加一步，通过<code class="fe lw lx ly lz b">MutationObserver</code> API来改善用户体验。</p><p id="bd84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们为活动框添加类名样式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以创建一些帮助器函数，以便在添加盒子时添加/删除它们的类名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe lw lx ly lz b">MutationObserver</code>来救援了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bb1dfebe1ec3638204f150d870b942dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/0*0stmX_32uGDk4nJ7.gif"/></div></figure><p id="2d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在回调中，它采用发生的最后一个突变，这样我们就可以访问最近的元素。这就是我们从<code class="fe lw lx ly lz b">MutationRecord</code>中所需要的，因为它包含了一个<code class="fe lw lx ly lz b">target</code>属性，将我们直接带到DOM元素。这个DOM元素包含了<code class="fe lw lx ly lz b">previousSibling</code>，我们需要访问它以便从中移除焦点样式。</p><p id="a9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们回顾一下返回的API，它是对<code class="fe lw lx ly lz b">new MutationObserver</code>的调用在<code class="fe lw lx ly lz b">observer</code>变量中返回给我们的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">MutationObserver</code>返回了<code class="fe lw lx ly lz b">observer</code>可以使用的三个方法。我们已经讨论了<code class="fe lw lx ly lz b">observe</code>方法:</p><ol class=""><li id="4b97" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><code class="fe lw lx ly lz b">disconnect()</code></li><li id="a199" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe lw lx ly lz b">observe()</code></li><li id="671e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><code class="fe lw lx ly lz b">takeRecords()</code></li></ol><p id="0e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">disconnect</code>方法阻止<code class="fe lw lx ly lz b">observer</code>接收来自突变的进一步通知。这意味着它将在应用程序的剩余生命周期中保持沉默，直到在另一个DOM元素上调用<code class="fe lw lx ly lz b">observe</code>来再次接收通知。</p><p id="fd6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">takeRecords</code>方法获取所有剩余的突变(一个<code class="fe lw lx ly lz b">MutationRecord</code>实例列表)并将它们作为数组返回。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="efc4" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">结论</h1><p id="bffd" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated"><code class="fe lw lx ly lz b">MutationObserver</code>是一个强大的API，它封装了现在已经废弃的<em class="lv"/><code class="fe lw lx ly lz b">MutationEvent</code>API。</p><p id="3e87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">MutationObserver</code>使得使用DOM和对按需发生的变化做出反应变得更加容易。这使得它成为为像Google Chrome这样的浏览器开发web扩展的好伙伴。</p><p id="e7da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的文章到此结束！我希望你觉得它有价值。以后多多关照！</p></div></div>    
</body>
</html>