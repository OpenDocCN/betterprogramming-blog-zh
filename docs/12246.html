<html>
<head>
<title>Bug Tracking: Fixing Hibernate Heap Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">错误跟踪:修复Hibernate堆问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bug-tracking-fixing-hibernate-heap-problems-5944a313c4d3?source=collection_archive---------7-----------------------#2022-05-21">https://betterprogramming.pub/bug-tracking-fixing-hibernate-heap-problems-5944a313c4d3?source=collection_archive---------7-----------------------#2022-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="81b6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为了避免不必要的数据检索</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/564b3f61bd823b1875a2d965396e9170.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/0*FquyE2v_EugukdTN.jpg"/></div></figure><p id="dbf8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在现代世界中，数据是最有价值的资产，无论应用程序是什么，数据处理和加工都是其核心功能的一部分，这并不奇怪。通过拥有几个ORM(对象/关系映射)框架，像<a class="ae lj" href="https://hibernate.org/" rel="noopener ugc nofollow" target="_blank"> Hibernate </a>或<a class="ae lj" href="https://www.eclipse.org/eclipselink/" rel="noopener ugc nofollow" target="_blank"> Eclipselink </a> Java，在访问应用数据的过程中为开发者提供了真正的帮助。它通过创建一个抽象数据访问层来实现这一点，抽象数据访问层负责检索应用程序数据并将其保存到数据库中。</p><p id="6a50" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lk">“只要数据被保存或检索，应用程序开发人员就不应该关心数据是如何保存或检索的。”</em></p><p id="1888" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">还是应该关心？</p><p id="6a2a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最近，我们有一个真实的情况，在几次高堆内存分配后，一个应用程序后端崩溃了(如图所示)，在很短的时间内有超过2G的内存分配。</p><p id="4701" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用<a class="ae lj" href="https://visualvm.github.io/" rel="noopener ugc nofollow" target="_blank"> VisualVM </a>，我们能够实时跟踪内存分配，并查看应用程序进行的对象分配。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/6e0838e12f3af9bb27603059d291776d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JVfrirgX808eXp0o.jpg"/></div></div></figure><p id="d4ca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">强制垃圾收集是一个临时的解决方案，堆被释放，但是，过了一段时间后，内存分配又开始增加。</p><p id="253d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">事实上，垃圾收集器能够释放内存，这暗示我们没有处理内存泄漏，但一定有其他东西产生了高内存使用率。</p><p id="de87" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在应用程序中，我们在与<code class="fe lq lr ls lt b">FetchType</code>惰性和分页相关的任何地方都使用它，以避免检索不需要的数据时不必要的数据库负载。</p><p id="8949" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">VisualVM允许我们在如此大的堆内存分配之后立即进行内存转储。它看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/ae793c2a0e433d1156648be616325c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EMQx_sHFycHWDR05.png"/></div></div></figure><p id="6fa2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们的一个域类<code class="fe lq lr ls lt b">Task</code>在堆上有几个实例。尽管启用了分页和惰性抓取，hibernate还是设法将所有这些元素加载到内存中。830万条记录。这是内存使用量不时急剧增加的原因。</p><p id="86a3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">是时候检查代码了。</p><p id="3920" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在域定义中，我们定义了两个类，一个是<code class="fe lq lr ls lt b">Task</code>，另一个是<code class="fe lq lr ls lt b">User</code>。<code class="fe lq lr ls lt b">User</code>和<code class="fe lq lr ls lt b">Task</code>之间还有<code class="fe lq lr ls lt b">@OneToMany</code>关系，<code class="fe lq lr ls lt b">Task</code>和<code class="fe lq lr ls lt b">User</code>之间还有<code class="fe lq lr ls lt b">@ManyToOne</code>关系。</p><pre class="kg kh ki kj gt lu lt lv lw aw lx bi"><span id="8d4c" class="ly lz iq lt b gy ma mb l mc md">/* Relation between User and Task */<br/>@Transient private int tasksNo;</span><span id="97f9" class="ly lz iq lt b gy me mb l mc md">@OneToMany(<!-- -->mappedBy<!-- --> = "author")<br/>@JsonIgnore private List&lt;Task&gt; tasks;</span><span id="57c7" class="ly lz iq lt b gy me mb l mc md">/* Relation between Task and User */ <br/>@ManyToOne(fetch = FetchType.LAZY) <br/>@JoinColumn(name = "author_id") <br/>@JsonIgnore private User author;</span></pre><p id="eb8d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在领域级定义上，一切似乎都很好。</p><p id="89f1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在业务层面，后端正在处理几个与<code class="fe lq lr ls lt b">User</code>和<code class="fe lq lr ls lt b">Task</code>相关的REST API调用。在一些API响应中，我们需要获得分配给用户的任务总数。当我们返回一个JSON响应时，我们有一个<code class="fe lq lr ls lt b">Transient</code>变量<code class="fe lq lr ls lt b">tasksNo</code>，它应该包含任务的数量，并且定义了一个getter来计算任务的数量。</p><pre class="kg kh ki kj gt lu lt lv lw aw lx bi"><span id="87a2" class="ly lz iq lt b gy ma mb l mc md">public int getTasksNo() {<br/>  if (tasks != null) {<br/>    return tasks.size();<br/>  }<br/>  return 0;<br/>}</span></pre><p id="7e7d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，这是一个问题。即使我们为任务提供了惰性数据获取，hibernate也需要检索集合中的所有记录，以便能够计算其大小。让一个用户处理830万个任务，最终要从数据库中检索830万个对象，最终会出现内存问题。</p><p id="3d5d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lk">“使用合适的工具完成工作。”</em></p><p id="4de4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">显然，这不是检索集合大小的正确方法。该框架为解决这个问题提供了一个解决方案。在hibernate中，可以将公式附加到字段，如下所示:</p><pre class="kg kh ki kj gt lu lt lv lw aw lx bi"><span id="be92" class="ly lz iq lt b gy ma mb l mc md">@Formula("(select count(task.id) from task where task.author_id = id)")<br/>private int tasksNo;</span></pre><p id="7c52" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这样，hibernate将使用提供的查询对记录进行计数，避免不必要的数据检索。</p><p id="7f0b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">以下是一些休眠技巧:</p><ul class=""><li id="be6b" class="mf mg iq kp b kq kr kt ku kw mh la mi le mj li mk ml mm mn bi translated">尽可能使用惰性数据提取</li><li id="e993" class="mf mg iq kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated">使用分页来限制检索的记录数</li><li id="7e85" class="mf mg iq kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated">确保您的代码没有强制hibernate检索整个集合</li><li id="7576" class="mf mg iq kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated">更喜欢框架提供的解决方案，而不是在应用程序中编码它们</li></ul><p id="c89f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢阅读。敬请关注更多内容！</p></div></div>    
</body>
</html>